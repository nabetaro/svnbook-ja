<chapter id="svn.basic">
  <title>基本コンセプト</title>

  <para>This chapter is a short, casual introduction to Subversion and its approach
to version control.  We begin with a discussion of general version control
concepts, work our way into the specific ideas behind Subversion, and show
some simple examples of Subversion in use.</para>

  <para>この章の例では、複数のプログラムソースコードの共有を扱いますが、Subversion
はどのようなファイルの集まりも管理できることに注意してください。コンピュータプログラマを助けるだけにはとどまりません。</para>


  
  
  
  <!-- ================================================================= -->
<!-- ================================================================= -->
<!-- ================================================================= -->
<sect1 id="svn.basic.version-control-basics">
    <title>バージョン管理の基本</title>

    <indexterm>
      <primary>バージョン管理システム</primary>
    </indexterm>

    <para>A version control system (or revision control system) is a system that
tracks incremental versions (or revisions) of files and, in some cases,
directories over time.  Of course, merely tracking the various versions of a
user's (or group of users')  files and directories isn't very interesting in
itself.  What makes a version control system useful is the fact that it
allows you to explore the changes which resulted in each of those versions
and facilitates the arbitrary recall of the same.</para>

    <para>In this section, we'll introduce some fairly high-level version control
system components and concepts.  We'll limit our discussion to modern
version control systems&mdash;in today's interconnected world, there is very
little point in acknowledging version control systems which cannot operate
across wide-area networks.</para>

    
    <!-- =============================================================== -->
<sect2 id="svn.basic.repository">
      <title>リポジトリ</title>

      <indexterm>
        <primary>リポジトリ</primary>
        <secondary>defined</secondary>
      </indexterm>

      <para>At the core of the version control system is a repository, which is the
central store of that system's data.  The repository usually stores
information in the form of a <firstterm>filesystem tree</firstterm>&mdash;a
hierarchy of files and directories.  Any number of
<firstterm>clients</firstterm> connect to the repository, and then read or
write to these files.  By writing data, a client makes the information
available to others; by reading data, the client receives information from
others.  <xref linkend="svn.basic.repository.dia-1"/> illustrates this.</para>

      <figure id="svn.basic.repository.dia-1">
        <title>典型的なクライアント/サーバシステム</title>
<graphic fileref="images/ch02dia1.png"/></figure>

      <para>Why is this interesting? So far, this sounds like the definition of a
typical file server.  And indeed, the repository <emphasis>is</emphasis> a
kind of file server, but it's not your usual breed.  What makes the
repository special is that as the files in the repository are changed, the
repository remembers each version of those files.</para>

      <para>When a client reads data from the repository, it normally sees only the
latest version of the filesystem tree.  But what makes a version control
client interesting is that it also has the ability to request previous
states of the filesystem from the repository.  A version control client can
ask historical questions such as <quote>What did this directory contain last
Wednesday?</quote> and <quote>Who was the last person to change this file,
and what changes did he make?</quote> These are the sorts of questions that
are at the heart of any version control system.</para>

    </sect2>

    
    <!-- =============================================================== -->
<sect2 id="svn.basic.working-copy">
      <title>作業コピー</title>

      <indexterm>
        <primary>作業コピー</primary>
        <secondary>defined</secondary>
      </indexterm>

      <para>A version control system's value comes from the fact that it tracks versions
of files and directories, but the rest of the software universe doesn't
operate on <quote>versions of files and directories</quote>.  Most software
programs understand how to operate only on a <emphasis>single</emphasis>
version of a specific type of file.  So how does a version control user
interact with an abstract&mdash;and, often, remote&mdash;repository full of
multiple versions of various files in a concrete fashion? How does his or
her word processing software, presentation software, source code editor, web
design software, or some other program&mdash;all of which trade in the
currency of simple data files&mdash;get access to such files? The answer is
found in the version control construct known as a <firstterm>working
copy</firstterm>.</para>

      <para>A working copy is, quite literally, a local copy of a particular version of
a user's VCS-managed data upon which that user is free to work.  Working
copies<footnote><para>The term <quote>working copy</quote> can be generally applied to any one
file version's local instance.  When most folks use the term, though, they
are referring to a whole directory tree containing files and subdirectories
managed by the version control system.</para></footnote> appear to other software just as
any other local directory full of files, so those programs don't have to be
<quote>version-control-aware</quote> in order to read from and write to that
data.  The task of managing the working copy and communicating changes made
to its contents to and from the repository falls squarely to the version
control system's client software.</para>

    </sect2>

    
    <!-- =============================================================== -->
<sect2 id="svn.basic.vsn-models">
      <title>バージョン管理モデル</title>

      <para>If the primary mission of a version control system is to track the various
versions of digital information over time, a very close secondary mission in
any modern version control system is to enable collaborative editing and
sharing of that data.  But different systems use different strategies to
achieve this.  It's important to understand these different strategies, for
a couple of reasons.  First, it will help you compare and contrast existing
version control systems, in case you encounter other systems similar to
Subversion.  Beyond that, it will also help you make more effective use of
Subversion, since Subversion itself supports a couple of different ways of
working.</para>

      
      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<sect3 id="svn.basic.vsn-models.problem-sharing">
        <title>ファイル共有の問題</title>

        <para>あらゆるバージョン管理システムは、どれも基本的な問題をひとつ解決しなければなりません。どうやってユーザに情報を共有させつつ、お互いの変更点が重ならないようにするか、です。リポジトリ上にある他人の変更を、間違って上書きしてしまうことは、簡単に起こりえます。</para>

        <para>Consider the scenario shown in <xref
linkend="svn.basic.vsn-models.problem-sharing.dia-1"/>.  Suppose we have two
coworkers, Harry and Sally.  They each decide to edit the same repository
file at the same time.  If Harry saves his changes to the repository first,
it's possible that (a few moments later) Sally could accidentally overwrite
them with her own new version of the file.  While Harry's version of the
file won't be lost forever (because the system remembers every change), any
changes Harry made <emphasis>won't</emphasis> be present in Sally's newer
version of the file, because she never saw Harry's changes to begin with.
Harry's work is still effectively lost&mdash;or at least missing from the
latest version of the file&mdash;and probably by accident.  This is
definitely a situation we want to avoid!</para>

        <figure id="svn.basic.vsn-models.problem-sharing.dia-1">
          <title>避けなくてはならない問題</title>
<graphic fileref="images/ch02dia2.png"/></figure>

      </sect3>

      
      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<sect3 id="svn.basic.vsn-models.lock-unlock">
        <title>ロック・変更・ロック解除法</title>

        <indexterm>
          <primary>バージョン管理</primary>
          <secondary>models</secondary>
<tertiary>ロック・変更・ロック解除法</tertiary></indexterm>

        <para>Many version control systems use a <firstterm>lock-modify-unlock</firstterm>
model to address the problem of many authors clobbering each other's work.
In this model, the repository allows only one person to change a file at a
time.  This exclusivity policy is managed using locks.  Harry must
<quote>lock</quote> a file before he can begin making changes to it.  If
Harry has locked a file, Sally cannot also lock it, and therefore cannot
make any changes to that file.  All she can do is read the file and wait for
Harry to finish his changes and release his lock.  After Harry unlocks the
file, Sally can take her turn by locking and editing the file.  <xref
linkend="svn.basic.vsn-models.lock-unlock.dia-1"/> demonstrates this simple
solution.</para>

        <figure id="svn.basic.vsn-models.lock-unlock.dia-1">
          <title>ロック・変更・ロック解除法</title>
<graphic fileref="images/ch02dia3.png"/></figure>

        <para>ロック・変更・ロック解除のモデルの問題は、ファイル管理が少々厳しすぎることで、しばしばユーザにとって、以下のような作業の障害になります。</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>Locking may cause administrative problems.</emphasis> Sometimes
Harry will lock a file and then forget about it.  Meanwhile, because Sally
is still waiting to edit the file, her hands are tied.  And then Harry goes
on vacation.  Now Sally has to get an administrator to release Harry's
lock.  The situation ends up causing a lot of unnecessary delay and wasted
time.</para>
          </listitem>

          <listitem>
            <para><emphasis>Locking may cause unnecessary serialization.</emphasis> What if
Harry is editing the beginning of a text file, and Sally simply wants to
edit the end of the same file? These changes don't overlap at all.  They
could easily edit the file simultaneously, and no great harm would come,
assuming the changes were properly merged together.  There's no need for
them to take turns in this situation.</para>
          </listitem>

          <listitem>
            <para><emphasis>Locking may create a false sense of security.</emphasis> Suppose
Harry locks and edits file A, while Sally simultaneously locks and edits
file B.  But what if A and B depend on one another, and the changes made to
each are semantically incompatible? Suddenly A and B don't work together
anymore.  The locking system was powerless to prevent the problem&mdash;yet
it somehow provided a false sense of security.  It's easy for Harry and
Sally to imagine that by locking files, each is beginning a safe, insulated
task, and thus they need not bother discussing their incompatible changes
early on.  Locking often becomes a substitute for real communication.</para>
          </listitem>
        </itemizedlist>

      </sect3>

      
      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<sect3 id="svn.basic.vsn-models.copy-merge">
        <title>コピー・変更・マージ法</title>

        <indexterm>
          <primary>バージョン管理</primary>
          <secondary>models</secondary>
<tertiary>コピー・変更・マージ法</tertiary></indexterm>

        <para>Subversion, CVS, and many other version control systems use a
<firstterm>copy-modify-merge</firstterm> model as an alternative to
locking.  In this model, each user's client contacts the project repository
and creates a personal working copy.  Users then work simultaneously and
independently, modifying their private copies.  Finally, the private copies
are merged together into a new, final version.  The version control system
often assists with the merging, but ultimately, a human being is responsible
for making it happen correctly.</para>

        <para>Here's an example.  Say that Harry and Sally each create working copies of
the same project, copied from the repository.  They work concurrently and
make changes to the same file A within their copies.  Sally saves her
changes to the repository first.  When Harry attempts to save his changes
later, the repository informs him that his file A is <firstterm>out of
date</firstterm>.  In other words, file A in the repository has somehow
changed since he last copied it.  So Harry asks his client to
<firstterm>merge</firstterm> any new changes from the repository into his
working copy of file A.  Chances are that Sally's changes don't overlap with
his own; once he has both sets of changes integrated, he saves his working
copy back to the repository.  <xref
linkend="svn.basic.vsn-models.copy-merge.dia-1"/> and <xref
linkend="svn.basic.vsn-models.copy-merge.dia-2"/> show this process.</para>

        <figure id="svn.basic.vsn-models.copy-merge.dia-1">
          <title>コピー・変更・マージ法</title>
<graphic fileref="images/ch02dia4.png"/></figure>

        <figure id="svn.basic.vsn-models.copy-merge.dia-2">
          <title>コピー・変更・マージ法(続き)</title>
<graphic fileref="images/ch02dia5.png"/></figure>

        <indexterm>
          <primary>競合</primary>
        </indexterm>

        <para>But what if Sally's changes <emphasis>do</emphasis> overlap with Harry's
changes? What then? This situation is called a
<firstterm>conflict</firstterm>, and it's usually not much of a problem.
When Harry asks his client to merge the latest repository changes into his
working copy, his copy of file A is somehow flagged as being in a state of
conflict: he'll be able to see both sets of conflicting changes and manually
choose between them.  Note that software can't automatically resolve
conflicts; only humans are capable of understanding and making the necessary
intelligent choices.  Once Harry has manually resolved the overlapping
changes&mdash;perhaps after a discussion with Sally&mdash;he can safely save
the merged file back to the repository.</para>

        <para>The copy-modify-merge model may sound a bit chaotic, but in practice, it
runs extremely smoothly.  Users can work in parallel, never waiting for one
another.  When they work on the same files, it turns out that most of their
concurrent changes don't overlap at all; conflicts are infrequent.  And the
amount of time it takes to resolve conflicts is usually far less than the
time lost by a locking system.</para>

        <para>In the end, it all comes down to one critical factor: user communication.
When users communicate poorly, both syntactic and semantic conflicts
increase.  No system can force users to communicate perfectly, and no system
can detect semantic conflicts.  So there's no point in being lulled into a
false sense of security that a locking system will somehow prevent
conflicts; in practice, locking seems to inhibit productivity more than
anything else.</para>

        <sidebar id="svn.basic.vsn-models.copy-merge.sb-1">
          <title>ロックが必要な場合</title>

          <para>ロック・変更・ロック解除モデルは、複数で協力して作業する場合、一般的には有害だと考えられていますが、ロックが有効な場合もあります。</para>

          <para>The copy-modify-merge model is based on the assumption that files are
contextually mergeable&mdash;that is, that the majority of the files in the
repository are line-based text files (such as program source code).  But for
files with binary formats, such as artwork or sound, it's often impossible
to merge conflicting changes.  In these situations, it really is necessary
for users to take strict turns when changing the file.  Without serialized
access, somebody ends up wasting time on changes that are ultimately
discarded.</para>

          <para>While Subversion is primarily a copy-modify-merge system, it still
recognizes the need to lock an occasional file, and thus provides mechanisms
for this.  We discuss this feature in <xref
linkend="svn.advanced.locking"/>.</para>

        </sidebar>

      </sect3>
    </sect2>
  </sect1>

  
  
  
  <!-- ================================================================= -->
<!-- ================================================================= -->
<!-- ================================================================= -->
<sect1 id="svn.basic.in-action">
    <title>Version Control the Subversion Way</title>

    <para>We've mentioned already that Subversion is a modern, network-aware version
control system.  As we described in <xref
linkend="svn.basic.version-control-basics"/> (our high-level version control
overview), a repository serves as the core storage mechanism for
Subversion's versioned data, and it's via working copies that users and
their software programs interact with that data.  In this section, we'll
begin to introduce the specific ways in which Subversion implements version
control.</para>

    
    <!-- =============================================================== -->
<sect2 id="svn.basic.svn-repositories">
      <title>Subversion Repositories</title>

      <para>Subversion implements the concept of a version control repository much as
any other modern version control system would.  Unlike a working copy, a
Subversion repository is an abstract entity, able to be operated upon almost
exclusively by Subversion's own libraries and tools.  As most of a user's
Subversion interactions involve the use of the Subversion client and occur
in the context of a working copy, we spend the majority of this book
discussing the Subversion working copy and how to manipulate it.  For the
finer details of the repository, though, check out <xref
linkend="svn.reposadmin"/>.</para>

    </sect2>

    
    <!-- =============================================================== -->
<sect2 id="svn.basic.in-action.revs">
      <title>リビジョン</title>

      <indexterm>
        <primary>リビジョン</primary>
        <secondary>defined</secondary>
      </indexterm>

      <para>A Subversion client commits (that is, communicates the changes made to) any
number of files and directories as a single atomic transaction.  By atomic
transaction, we mean simply this: either all of the changes are accepted
into the repository, or none of them is.  Subversion tries to retain this
atomicity in the face of program crashes, system crashes, network problems,
and other users' actions.</para>

      <para>Each time the repository accepts a commit, this creates a new state of the
filesystem tree, called a <firstterm>revision</firstterm>.  Each revision is
assigned a unique natural number, one greater than the number assigned to
the previous revision.  The initial revision of a freshly created repository
is numbered 0 and consists of nothing but an empty root directory.</para>

      <para><xref linkend="svn.basic.in-action.revs.dia-1"/> illustrates a nice way to
visualize the repository.  Imagine an array of revision numbers, starting at
0, stretching from left to right.  Each revision number has a filesystem
tree hanging below it, and each tree is a <quote>snapshot</quote> of the way
the repository looked after a commit.</para>

      <figure id="svn.basic.in-action.revs.dia-1">
        <title>Tree changes over time</title>
<graphic fileref="images/ch02dia7.png"/></figure>

      <sidebar>
        <title>グローバルリビジョン番号</title>

        <indexterm>
          <primary>リビジョン</primary>
          <secondary>global</secondary>
        </indexterm>

        <para>Unlike most version control systems, Subversion's revision numbers apply to
<emphasis>entire trees</emphasis>, not individual files.  Each revision
number selects an entire tree, a particular state of the repository after
some committed change.  Another way to think about it is that revision N
represents the state of the repository filesystem after the Nth commit.
When Subversion users talk about <quote>revision 5 of
<filename>foo.c</filename>,</quote> they really mean
<quote><filename>foo.c</filename> as it appears in revision 5.</quote>
Notice that in general, revisions N and M of a file do
<emphasis>not</emphasis> necessarily differ! Many other version control
systems use per-file revision numbers, so this concept may seem unusual at
first. (Former CVS users might want to see <xref linkend="svn.forcvs"/> for
more details.)</para>
      </sidebar>

    </sect2>

    
    <!-- =============================================================== -->
<sect2 id="svn.advanced.reposurls">
      <title>Addressing the Repository</title>

      <indexterm>
        <primary>svn</primary>
        <secondary>syntax</secondary>
<tertiary>URL</tertiary></indexterm>
      <indexterm>
        <primary>svnsync</primary>
        <secondary>syntax</secondary>
<tertiary>URL</tertiary></indexterm>

      <para>Subversion client programs use URLs to identify versioned files and
directories in Subversion repositories.  For the most part, these URLs use
the standard syntax, allowing for server names and port numbers to be
specified as part of the URL.</para>

      <informalexample>
        <itemizedlist spacing="compact">
          <listitem>
            <simpara>http://svn.example.com/svn/project</simpara>
          </listitem>
          <listitem>
            <simpara>http://svn.example.com:9834/repos</simpara>
          </listitem>
        </itemizedlist>
      </informalexample>

      <para>Subversion repository URLs aren't limited to only the
<literal>http://</literal> variety.  Because Subversion offers several
different ways for its clients to communicate with its servers, the URLs
used to address the repository differ subtly depending on which repository
access mechanism is employed.  <xref
linkend="svn.basic.in-action.wc.tbl-1"/> describes how different URL schemes
map to the available repository access methods.  For more details about
Subversion's server options, see <xref linkend="svn.serverconfig"/>.</para>

      <table id="svn.basic.in-action.wc.tbl-1">
        <title>リポジトリにアクセスする URL</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>スキーム</entry>
              <entry>アクセス方法</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><literal>file:///</literal></entry>
              <entry>リポジトリへの直接アクセス (ローカルディスク)</entry>
            </row>
            <row>
              <entry><literal>http://</literal></entry>
              <entry>Subversion 対応 Apacheサーバへの WebDAV プロトコル経由でのアクセス</entry>
            </row>
            <row>
              <entry><literal>https://</literal></entry>
              <entry><literal>http://</literal>と同じだが SSL で暗号化</entry>
            </row>
            <row>
              <entry><literal>svn://</literal></entry>
              <entry><literal>svnserve</literal> サーバへの独自プロトコル経由アクセス</entry>
            </row>
            <row>
              <entry><literal>svn+ssh://</literal></entry>
              <entry> <literal>svn://</literal> と同じだが SSH トンネルを利用</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Subversion's handling of URLs has some notable nuances.  For example, URLs
containing the <literal>file://</literal> access method (used for local
repositories) must, in accordance with convention, have either a server name
of <literal>localhost</literal> or no server name at all:</para>

      <informalexample>
        <itemizedlist spacing="compact">
          <listitem>
            <simpara>file:///var/svn/repos</simpara>
          </listitem>
          <listitem>
            <simpara>file://localhost/var/svn/repos</simpara>
          </listitem>
        </itemizedlist>
      </informalexample>

      <para>Also, users of the <literal>file://</literal> scheme on Windows platforms
will need to use an unofficially <quote>standard</quote> syntax for
accessing repositories that are on the same machine, but on a different
drive than the client's current working drive.  Either of the two following
URL path syntaxes will work, where <literal>X</literal> is the drive on
which the repository resides:</para>

      <informalexample>
        <itemizedlist spacing="compact">
          <listitem>
            <simpara>file:///X:/var/svn/repos</simpara>
          </listitem>
          <listitem>
            <simpara>file:///X|/var/svn/repos</simpara>
          </listitem>
        </itemizedlist>
      </informalexample>

      <para>Note that a URL uses forward slashes even though the native (non-URL) form
of a path on Windows uses backslashes.  Also note that when using the
<literal>file:///<replaceable>X</replaceable>|/</literal> form at the
command line, you need to quote the URL (wrap it in quotation marks) so that
the vertical bar character is not interpreted as a pipe.</para>

      <note>
        <para>You cannot use Subversion's <literal>file://</literal> URLs in a regular web
browser the way typical <literal>file://</literal> URLs can.  When you
attempt to view a <literal>file://</literal> URL in a regular web browser,
it reads and displays the contents of the file at that location by examining
the filesystem directly.  However, Subversion's resources exist in a virtual
filesystem (see <xref linkend="svn.developer.layerlib.repos" />), and your
browser will not understand how to interact with that filesystem.</para>
      </note>

      <para>The Subversion client will automatically encode URLs as necessary, just like
a web browser does.  For example, the URL <literal>http://host/path with
space/project/españa</literal> &mdash; which contains both spaces and
upper-ASCII characters &mdash; will be automatically interpreted by
Subversion as if you'd provided
<literal>http://host/path%20with%20space/project/espa%C3%B1a</literal>.  If
the URL contains spaces, be sure to place it within quotation marks at the
command line so that your shell treats the whole thing as a single argument
to the program.</para>

      <para>There is one notable exception to Subversion's handling of URLs which also
applies to its handling of local paths in many contexts, too.  If the final
path component of your URL or local path contains an at sign
(<literal>@</literal>), you need to use a special syntax&mdash;described in
<xref linkend="svn.advanced.pegrevs" />&mdash;in order to make Subversion
properly address that resource.</para>

      <para>In Subversion 1.6, a new caret (<literal>^</literal>)  notation was
introduced as a shorthand for <quote>the URL of the repository's root
directory</quote>.  For example, you can use the
<literal>^/tags/bigsandwich/</literal> to refer to the URL of the
<filename>/tags/bigsandwich</filename> directory in the root of the
repository.  Note that this URL syntax works only when your current working
directory is a working copy&mdash;the command-line client knows the
repository's root URL by looking at the working copy's metadata.  Also note
that when you wish to refer precisely to the root directory of the
repository, you must do so using <literal>^/</literal> (with the trailing
slash character), not merely <literal>^</literal>.</para>

    </sect2>

    
    <!-- =============================================================== -->
<sect2 id="svn.basic.in-action.wc">
      <title>Subversion Working Copies</title>

      <indexterm>
        <primary>作業コピー</primary>
        <secondary>defined</secondary>
      </indexterm>

      <para>A Subversion working copy is an ordinary directory tree on your local
system, containing a collection of files.  You can edit these files however
you wish, and if they're source code files, you can compile your program
from them in the usual way.  Your working copy is your own private work
area: Subversion will never incorporate other people's changes, nor make
your own changes available to others, until you explicitly tell it to do
so.  You can even have multiple working copies of the same project.</para>

      <para>After you've made some changes to the files in your working copy and
verified that they work properly, Subversion provides you with commands to
<quote>publish</quote> your changes to the other people working with you on
your project (by writing to the repository).  If other people publish their
own changes, Subversion provides you with commands to merge those changes
into your working copy (by reading from the repository).</para>

      <para>A working copy also contains some extra files, created and maintained by
Subversion, to help it carry out these commands.  In particular, each
working copy contains a subdirectory named <filename>.svn</filename>, also
known as the working copy's <firstterm>administrative
directory</firstterm>.  The files in the administrative directory help
Subversion recognize which of your versioned files contain unpublished
changes, and which files are out of date with respect to others' work.</para>

      <note>
        <para>Prior to version 1.7, Subversion maintained <filename>.svn</filename>
administrative subdirectories in <emphasis>every</emphasis> versioned
directory of your working copy.  Subversion 1.7 offers a completely new
approach to how working copy metadata is stored and maintained, and chief
among the visible changes to this approach is that each working copy now has
only one <filename>.svn</filename> subdirectory which is an immediate child
of the root of that working copy.</para>
      </note>

      
      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<sect3 id="svn.basic.in-action.track-repos">
        <title>How the working copy works</title>

        <para>For each file in a working directory, Subversion records (among other
things) two essential pieces of information:</para>

        <itemizedlist>
          <listitem>
            <para>作業ファイルは、どのリビジョンに基づいているか (これをファイルの<firstterm>作業リビジョン</firstterm>と呼びます)</para>
          </listitem>
          <listitem>
            <para>リポジトリによって、作業コピーが最後に更新された時刻</para>
          </listitem>
        </itemizedlist>

        <para>これらの情報とリポジトリとの対話によって、Subversionは作業ファイルの それぞれが、以下の四つの状態のどれにあるかを見分けることができます:</para>

        <variablelist>
          <varlistentry>
            <term>変更なし、かつ最新</term>
            <listitem>
              <para>The file is unchanged in the working directory, and no changes to that file
have been committed to the repository since its working revision.  An
<command>svn commit</command> of the file will do nothing, and an
<command>svn update</command> of the file will do nothing.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>ローカルで変更あり、かつ最新</term>
            <listitem>
              <para>The file has been changed in the working directory, and no changes to that
file have been committed to the repository since you last updated.  There
are local changes that have not been committed to the repository; thus an
<command>svn commit</command> of the file will succeed in publishing your
changes, and an <command>svn update</command> of the file will do nothing.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>変更なし、かつ最新ではない</term>
            <listitem>
              <para>The file has not been changed in the working directory, but it has been
changed in the repository.  The file should eventually be updated in order
to make it current with the latest public revision.  An <command>svn
commit</command> of the file will do nothing, and an <command>svn
update</command> of the file will fold the latest changes into your working
copy.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>ローカルで変更あり、かつ最新ではない</term>
            <listitem>
              <para>The file has been changed both in the working directory and in the
repository.  An <command>svn commit</command> of the file will fail with an
<quote>out-of-date</quote> error.  The file should be updated first; an
<command>svn update</command> command will attempt to merge the public
changes with the local changes.  If Subversion can't complete the merge in a
plausible way automatically, it leaves it to the user to resolve the
conflict.</para>
            </listitem>
          </varlistentry>
        </variablelist>

      </sect3>

      
      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<sect3 id="svn.basic.in-action.wc-funcdamentals">
        <title>Fundamental working copy interactions</title>

        <para>A typical Subversion repository often holds the files (or source code) for
several projects; usually, each project is a subdirectory in the
repository's filesystem tree.  In this arrangement, a user's working copy
will usually correspond to a particular subtree of the repository.</para>

        <para>For example, suppose you have a repository that contains two software
projects, <literal>paint</literal> and <literal>calc</literal>.  Each
project lives in its own top-level subdirectory, as shown in <xref
linkend="svn.basic.in-action.wc.dia-1"/>.</para>

        <figure id="svn.basic.in-action.wc.dia-1">
          <title>リポジトリのファイルシステム</title>
<graphic fileref="images/ch02dia6.png"/></figure>

        <indexterm>
          <primary>svn</primary>
          <secondary>サブコマンド</secondary>
<tertiary>checkout</tertiary></indexterm>
        <indexterm>
          <primary>作業コピー</primary>
          <secondary>creation</secondary>
        </indexterm>
        <indexterm>
          <primary>checkout</primary>
          <see>working copy, creation</see>
        </indexterm>

        <para>To get a working copy, you must <firstterm>check out</firstterm> some
subtree of the repository.  (The term <emphasis>check out</emphasis> may
sound like it has something to do with locking or reserving resources, but
it doesn't; it simply creates a working copy of the project for you.)  For
example, if you check out <filename>/calc</filename>, you will get a working
copy like this:</para>

        <informalexample>
          <screen>
$ svn checkout http://svn.example.com/repos/calc
A    calc/Makefile
A    calc/integer.c
A    calc/button.c
Checked out revision 56.
$ ls -A calc
Makefile  button.c integer.c .svn/
$
</screen>
        </informalexample>

        <para>The list of letter <literal>A</literal>s in the left margin indicates that
Subversion is adding a number of items to your working copy.  You now have a
personal copy of the repository's <filename>/calc</filename> directory, with
one additional entry&mdash;<filename>.svn</filename>&mdash;which holds the
extra information needed by Subversion, as mentioned earlier.</para>

        <para>Suppose you make changes to <filename>button.c</filename>.  Since the
<filename>.svn</filename> directory remembers the file's original
modification date and contents, Subversion can tell that you've changed the
file.  However, Subversion does not make your changes public until you
explicitly tell it to.  The act of publishing your changes is more commonly
known as <firstterm>committing</firstterm> (or <firstterm>checking
in</firstterm>) changes to the repository.</para>

        <indexterm>
          <primary>svn</primary>
          <secondary>サブコマンド</secondary>
<tertiary>commit</tertiary></indexterm>
        <indexterm>
          <primary>コミット</primary>
          <see>作業コピー、コミット</see>
        </indexterm>
        <indexterm>
          <primary>作業コピー</primary>
          <secondary>commit</secondary>
        </indexterm>

        <para>変更点を他の人に公開するには、Subversion の <command>commit</command> コマンドを使用します。</para>

        <informalexample>
          <screen>
$ svn commit button.c -m "Fixed a typo in button.c."
Sending        button.c
Transmitting file data .
Committed revision 57.
$
</screen>
        </informalexample>

        <para>Now your changes to <filename>button.c</filename> have been committed to the
repository, with a note describing your change (namely, that you fixed a
typo).  If another user checks out a working copy of
<filename>/calc</filename>, she will see your changes in the latest version
of the file.</para>

        <para>Suppose you have a collaborator, Sally, who checked out a working copy of
<filename>/calc</filename> at the same time you did.  When you commit your
change to <filename>button.c</filename>, Sally's working copy is left
unchanged; Subversion modifies working copies only at the user's request.</para>

        <indexterm>
          <primary>svn</primary>
          <secondary>サブコマンド</secondary>
<tertiary>update</tertiary></indexterm>
        <indexterm>
          <primary>更新</primary>
          <see>作業コピー、更新</see>
        </indexterm>
        <indexterm>
          <primary>作業コピー</primary>
          <secondary>update</secondary>
        </indexterm>

        <para>To bring her project up to date, Sally can ask Subversion to
<firstterm>update</firstterm> her working copy, by using the <command>svn
update</command> command.  This will incorporate your changes into her
working copy, as well as any others that have been committed since she
checked it out.</para>

        <informalexample>
          <screen>
$ pwd
/home/sally/calc
$ ls -A
Makefile button.c integer.c .svn/
$ svn update
Updating '.':
U    button.c
リビジョン 57 に更新しました。.
$
</screen>
        </informalexample>

        <para>The output from the <command>svn update</command> command indicates that
Subversion updated the contents of <filename>button.c</filename>.  Note that
Sally didn't need to specify which files to update; Subversion uses the
information in the <filename>.svn</filename> directory as well as further
information in the repository, to decide which files need to be brought up
to date.</para>

      </sect3>

      
      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<sect3 id="svn.basic.in-action.mixedrevs">
        <title>Mixed-revision working copies</title>

        <indexterm>
          <primary>作業コピー</primary>
          <secondary>混合リビジョン</secondary>
        </indexterm>

        <para>As a general principle, Subversion tries to be as flexible as possible.  One
special kind of flexibility is the ability to have a working copy containing
files and directories with a mix of different working revision numbers.
Subversion working copies do not always correspond to any single revision in
the repository; they may contain files from several different revisions.
For example, suppose you check out a working copy from a repository whose
most recent revision is 4:</para>

        <informalexample>
          <literallayout>
calc/
   Makefile:4
   integer.c:4
   button.c:4
</literallayout>
        </informalexample>

        <para>At the moment, this working directory corresponds exactly to revision 4 in
the repository.  However, suppose you make a change to
<filename>button.c</filename>, and commit that change.  Assuming no other
commits have taken place, your commit will create revision 5 of the
repository, and your working copy will now look like this:</para>

        <informalexample>
          <literallayout>
calc/
   Makefile:4
   integer.c:4
   button.c:5
</literallayout>
        </informalexample>

        <para>Suppose that, at this point, Sally commits a change to
<filename>integer.c</filename>, creating revision 6.  If you use
<command>svn update</command> to bring your working copy up to date, it will
look like this:</para>

        <informalexample>
          <literallayout>
calc/
   Makefile:6
   integer.c:6
   button.c:6
</literallayout>
        </informalexample>

        <para>Sally's change to <filename>integer.c</filename> will appear in your working
copy, and your change will still be present in
<filename>button.c</filename>.  In this example, the text of
<filename>Makefile</filename> is identical in revisions 4, 5, and 6, but
Subversion will mark your working copy of <filename>Makefile</filename> with
revision 6 to indicate that it is still current.  So, after you do a clean
update at the top of your working copy, it will generally correspond to
exactly one revision in the repository.</para>
  
        <sect4 id="svn.basic.in-action.mixedrevs.update-commit">
          <title>更新とコミットは別の処理</title>

          <para>One of the fundamental rules of Subversion is that a <quote>push</quote>
action does not cause a <quote>pull,</quote> nor vice versa.  Just because
you're ready to submit new changes to the repository doesn't mean you're
ready to receive changes from other people.  And if you have new changes
still in progress, <command>svn update</command> should gracefully merge
repository changes into your own, rather than forcing you to publish them.</para>

          <para>The main side effect of this rule is that it means a working copy has to do
extra bookkeeping to track mixed revisions as well as be tolerant of the
mixture.  It's made more complicated by the fact that directories themselves
are versioned.</para>

          <para>For example, suppose you have a working copy entirely at revision 10.  You
edit the file <filename>foo.html</filename> and then perform an <command>svn
commit</command>, which creates revision 15 in the repository.  After the
commit succeeds, many new users would expect the working copy to be entirely
at revision 15, but that's not the case! Any number of changes might have
happened in the repository between revisions 10 and 15.  The client knows
nothing of those changes in the repository, since you haven't yet run
<command>svn update</command>, and <command>svn commit</command> doesn't
pull down new changes.  If, on the other hand, <command>svn commit</command>
were to automatically download the newest changes, it would be possible to
set the entire working copy to revision 15&mdash;but then we'd be breaking
the fundamental rule of <quote>push</quote> and <quote>pull</quote>
remaining separate actions.  Therefore, the only safe thing the Subversion
client can do is mark the one
file&mdash;<filename>foo.html</filename>&mdash;as being at revision 15.  The
rest of the working copy remains at revision 10.  Only by running
<command>svn update</command> can the latest changes be downloaded and the
whole working copy be marked as revision 15.</para>

        </sect4>

        <sect4 id="svn.basic.in-action.mixedrevs.normal">
          <title>混合リビジョンは正常な状態です</title>

          <para>The fact is, <emphasis>every time</emphasis> you run <command>svn
commit</command> your working copy ends up with some mixture of revisions.
The things you just committed are marked as having larger working revisions
than everything else.  After several commits (with no updates in between),
your working copy will contain a whole mixture of revisions.  Even if you're
the only person using the repository, you will still see this phenomenon.
To examine your mixture of working revisions, use the <command>svn
status</command> command with the <option>--verbose</option>
(<option>-v</option>) option (see <xref
linkend="svn.tour.cycle.examine.status"/> for more information).</para>

          <para>Often, new users are completely unaware that their working copy contains
mixed revisions.  This can be confusing, because many client commands are
sensitive to the working revision of the item they're examining.  For
example, the <command>svn log</command> command is used to display the
history of changes to a file or directory (see <xref
linkend="svn.tour.history.log"/>).  When the user invokes this command on a
working copy object, he expects to see the entire history of the object.
But if the object's working revision is quite old (often because
<command>svn update</command> hasn't been run in a long time), the history
of the <emphasis>older</emphasis> version of the object is shown.</para>

        </sect4>

        <sect4 id="svn.basic.in-action.mixedrevs.useful">
          <title>混合リビジョンは便利です</title>

          <para>If your project is sufficiently complex, you'll discover that it's sometimes
nice to forcibly <firstterm>backdate</firstterm> (or update to a revision
older than the one you already have) portions of your working copy to an
earlier revision; you'll learn how to do that in <xref
linkend="svn.tour"/>.  Perhaps you'd like to test an earlier version of a
submodule contained in a subdirectory, or perhaps you'd like to figure out
when a bug first came into existence in a specific file.  This is the
<quote>time machine</quote> aspect of a version control system&mdash;the
feature that allows you to move any portion of your working copy forward and
backward in history.</para>

        </sect4>

        <sect4 id="svn.basic.in-action.mixedrevs.limits">
          <title>混合リビジョンには制約があります</title>

          <para>作業コピーの中で混合リビジョンを使用することはできますが、この柔軟性には制約があります。</para>

          <para>First, you cannot commit the deletion of a file or directory that isn't
fully up to date.  If a newer version of the item exists in the repository,
your attempt to delete will be rejected to prevent you from accidentally
destroying changes you've not yet seen.</para>

          <para>Second, you cannot commit a metadata change to a directory unless it's fully
up to date.  You'll learn about attaching <quote>properties</quote> to items
in <xref linkend="svn.advanced"/>.  A directory's working revision defines a
specific set of entries and properties, and thus committing a property
change to an out-of-date directory may destroy properties you've not yet
seen.</para>

           

        <!-- ### TODO: In Subversion 1.7, you cannot merge into a
                ### mixed-rev working copy by default -->
</sect4>
      </sect3>
    </sect2>
  </sect1>

  
  
  
  <!-- ================================================================= -->
<!-- ================================================================= -->
<!-- ================================================================= -->
<sect1 id="svn.basic.summary">
    <title>まとめ</title>
    
    <para>この章では、さまざまな Subversion の基本概念を扱いました。</para>

    <itemizedlist>
      <listitem>
        <para>中央リポジトリ、クライアントの作業コピー、リポジトリのリビジョンツリーという概念を紹介しました。</para>
      </listitem>

      <listitem>
        <para>どのように二人の共同作業者が、Subversion を利用してお互いの修正点を公開したり受け取ったりするかといった
(<quote>コピー・変更・マージ</quote> のモデルを利用する)、簡単な例を見てきました。</para>
      </listitem>

      <listitem>
        <para>Subversion が、作業コピー内の情報を、追跡・管理する方法について少し触れました。</para>
      </listitem>

    </itemizedlist>

    <para>At this point, you should have a good idea of how Subversion works in the
most general sense.  Armed with this knowledge, you should now be ready to
move into the next chapter, which is a detailed tour of Subversion's
commands and features.</para>

  </sect1>

</chapter>


<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
