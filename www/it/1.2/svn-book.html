<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Controllo di Versione con Subversion</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.70.1" /></head><body><div class="book" lang="it" xml:lang="it"><div class="titlepage"><div><div><h1 class="title"><a id="svn"></a>Controllo di Versione con Subversion</h1></div><div><h2 class="subtitle">Per Subversion 1.2</h2></div><div><h2 class="subtitle">(libro compilato da Revision 2196:2198M)</h2></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Ben</span> <span class="surname">Collins-Sussman</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Brian W.</span> <span class="surname">Fitzpatrick</span></h3></div><div class="author"><h3 class="author"><span class="firstname">C. Michael</span> <span class="surname">Pilato</span></h3></div></div></div><div><p class="copyright">Copyright © 2002, 2003, 2004, 2005, 2006 Ben Collins-Sussman, Brian W. Fitzpatrick, C. Michael Pilato</p></div><div><div class="legalnotice"><a id="id4723957"></a><p>
        Questo lavoro è licenziato sotto la licenza Creative Commons Attribution.
	Per vedere una copia di questa licenza consultare il sito
	http://creativecommons.org/licenses/by/2.0/ od inviate una lettera
	a 
	Creative Commons, 559 Nathan Abbott Way, Stanford, California 94305,
	USA.
     </p></div></div><div><p class="pubdate">(TBA)</p></div></div><hr /></div><div class="toc"><p><b>Sommario</b></p><dl><dt><span class="preface"><a href="#svn.foreword">Foreword</a></span></dt><dt><span class="preface"><a href="#svn.preface">Prefazione</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn.preface.audience">A chi è rivolto questo libro</a></span></dt><dt><span class="sect1"><a href="#svn.preface.howread">Come Leggere Questo Libro</a></span></dt><dt><span class="sect1"><a href="#svn.preface.conventions">Convenzioni Utilizzate in Questo Libro</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.preface.conventions.typo">Convenzioni Tipografiche</a></span></dt><dt><span class="sect2"><a href="#svn.preface.conventions.icons">Icons</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.preface.organization">Organizzazione di questo libro</a></span></dt><dt><span class="sect1"><a href="#svn.preface.free">Questo libro è libero</a></span></dt><dt><span class="sect1"><a href="#svn.preface.acks">Acknowledgments</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.preface.acks.sussman">Da Ben Collins-Sussman</a></span></dt><dt><span class="sect2"><a href="#svn.preface.acks.fitz">Da Brian W. Fitzpatrick</a></span></dt><dt><span class="sect2"><a href="#svn.preface.acks.cmpilato">Da C. Michael Pilato</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#svn.intro">1. Introduzione</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn.intro.whatis">Cos'è Subversion?</a></span></dt><dt><span class="sect1"><a href="#svn.intro.history">La storia di Subversion</a></span></dt><dt><span class="sect1"><a href="#svn.intro.features">Le caratteristiche di Subversion</a></span></dt><dt><span class="sect1"><a href="#svn.intro.architecture">Architettura di Subversion</a></span></dt><dt><span class="sect1"><a href="#svn.intro.install">Installazione di Subversion</a></span></dt><dt><span class="sect1"><a href="#svn.intro.components">I Componenti di Subversion</a></span></dt><dt><span class="sect1"><a href="#svn.intro.quickstart">Un rapido inizio</a></span></dt></dl></dd><dt><span class="chapter"><a href="#svn.basic">2. Basic Concepts</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn.basic.repository">The Repository</a></span></dt><dt><span class="sect1"><a href="#svn.basic.vsn-models">Versioning Models</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.basic.vsn-models.problem-sharing">The Problem of File-Sharing</a></span></dt><dt><span class="sect2"><a href="#svn.basic.vsn-models.lock-unlock">The Lock-Modify-Unlock Solution</a></span></dt><dt><span class="sect2"><a href="#svn.basic.vsn-models.copy-merge">The Copy-Modify-Merge Solution</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.basic.in-action">Subversion in Action</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.basic.in-action.wc">Working Copies</a></span></dt><dt><span class="sect2"><a href="#svn.basic.in-action.revs">Revisions</a></span></dt><dt><span class="sect2"><a href="#svn.basic.in-action.track-repos">Come le copie di lavoro sono in relazione con il repository</a></span></dt><dt><span class="sect2"><a href="#svn.basic.in-action.mixedrevs">Copie di lavoro con revisioni miste</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.basic.in-action.mixedrevs.update-commit">Update e commit sono azioni separate</a></span></dt><dt><span class="sect3"><a href="#svn.basic.in-action.mixedrevs.normal">E' normale avere reivisioni mischiate</a></span></dt><dt><span class="sect3"><a href="#svn.basic.in-action.mixedrevs.useful">Le revisioni miste sono utili</a></span></dt><dt><span class="sect3"><a href="#svn.basic.in-action.mixedrevs.limits">Le revisioni miste hanno dei limiti</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.basic.summary">Sommario</a></span></dt></dl></dd><dt><span class="chapter"><a href="#svn.tour">3. Visita guidata</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn.tour.help">Help!</a></span></dt><dt><span class="sect1"><a href="#svn.tour.import">Import</a></span></dt><dt><span class="sect1"><a href="#svn.tour.revs">Revisioni:Numeri,Chiavi e Date, Accidenti</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.tour.revs.numbers">Numeri di revisione</a></span></dt><dt><span class="sect2"><a href="#svn.tour.revs.keywords">Chiavi per le Revisioni</a></span></dt><dt><span class="sect2"><a href="#svn.tour.revs.dates">Date di revisione</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.tour.initial">Checkout iniziale</a></span></dt><dt><span class="sect1"><a href="#svn.tour.cycle">Basic Work Cycle</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.tour.cycle.update">Update Your Working Copy</a></span></dt><dt><span class="sect2"><a href="#svn.tour.cycle.edit">Make Changes to Your Working Copy</a></span></dt><dt><span class="sect2"><a href="#svn.tour.cycle.examine">Examine Your Changes</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.tour.cycle.examine.status"><span><strong class="command">svn status</strong></span></a></span></dt><dt><span class="sect3"><a href="#svn.tour.cycle.examine.diff"><span><strong class="command">svn diff</strong></span></a></span></dt><dt><span class="sect3"><a href="#svn.tour.cycle.examine.revert"><span><strong class="command">svn revert</strong></span></a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.tour.cycle.resolve">Resolve Conflicts (Merging Others' Changes)</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.tour.cycle.resolve.byhand">Merging Conflicts by Hand</a></span></dt><dt><span class="sect3"><a href="#svn.tour.cycle.resolve.copyover">Copying a File Onto Your Working File</a></span></dt><dt><span class="sect3"><a href="#svn.tour.cycle.resolve.revert">Punting: Using <span><strong class="command">svn revert</strong></span></a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.tour.cycle.commit">Commit Your Changes</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.tour.history">Examining History</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.tour.history.log"><span><strong class="command">svn log</strong></span></a></span></dt><dt><span class="sect2"><a href="#svn.tour.history.diff"><span><strong class="command">svn diff</strong></span></a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.tour.history.diff.local">Examining Local Changes</a></span></dt><dt><span class="sect3"><a href="#svn.tour.history.diff.wcrepos">Comparing Working Copy to Repository</a></span></dt><dt><span class="sect3"><a href="#svn.tour.history.diff.reposrepos">Comparing Repository to Repository</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.tour.history.cat"><span><strong class="command">svn cat</strong></span></a></span></dt><dt><span class="sect2"><a href="#svn.tour.history.list"><span><strong class="command">svn list</strong></span></a></span></dt><dt><span class="sect2"><a href="#svn.tour.history.finalword">A Final Word on History</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.tour.other">Other Useful Commands</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.tour.other.cleanup"><span><strong class="command">svn cleanup</strong></span></a></span></dt><dt><span class="sect2"><a href="#svn.tour.other.import"><span><strong class="command">svn import</strong></span></a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.tour.summary">Summary</a></span></dt></dl></dd><dt><span class="chapter"><a href="#svn.branchmerge">4. Branching and Merging</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn.branchmerge.whatis">What's a Branch?</a></span></dt><dt><span class="sect1"><a href="#svn.branchmerge.using">Using Branches</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.branchmerge.using.create">Creating a Branch</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.using.work">Working with Your Branch</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.using.concepts">The Key Concepts Behind Branches</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.branchmerge.copychanges">Copying Changes Between Branches</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.branchmerge.copychanges.specific">Copying Specific Changes</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.copychanges.keyconcept">The Key Concept Behind Merging</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.copychanges.bestprac">Best Practices for Merging</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.branchmerge.copychanges.bestprac.track">Tracking Merges Manually</a></span></dt><dt><span class="sect3"><a href="#svn.branchmerge.copychanges.bestprac.preview">Previewing Merges</a></span></dt><dt><span class="sect3"><a href="#svn.branchmerge.copychanges.bestprac.merge">Merge Conflicts</a></span></dt><dt><span class="sect3"><a href="#svn.branchmerge.copychanges.bestprac.ancestry">Noticing or Ignoring Ancestry</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.branchmerge.commonuses">Common Use-Cases</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.branchmerge.commonuses.wholebr">Merging a Whole Branch to Another</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.commonuses.undo">Undoing Changes</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.commonuses.resurrect">Resurrecting Deleted Items</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.commonuses.patterns">Common Branching Patterns</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.branchmerge.commonuses.patterns.release">Release Branches</a></span></dt><dt><span class="sect3"><a href="#svn.branchmerge.commonuses.patterns.feature">Feature Branches</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.branchmerge.switchwc">Switching a Working Copy</a></span></dt><dt><span class="sect1"><a href="#svn.branchmerge.tags">Tags</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.branchmerge.tags.mksimple">Creating a Simple Tag</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.tags.mkcomplex">Creating a Complex Tag</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.branchmerge.maint">Branch Maintenance</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.branchmerge.maint.layout">Repository Layout</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.maint.lifetime">Data Lifetimes</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.branchmerge.summary">Summary</a></span></dt></dl></dd><dt><span class="chapter"><a href="#svn.reposadmin">5. Repository Administration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn.reposadmin.basics">Repository Basics</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.reposadmin.basics.txnsrevs">Understanding Transactions and Revisions</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.basics.revprops">Unversioned Properties</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.basics.backends">Repository Data Stores</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.reposadmin.basics.backends.bdb">Berkeley DB</a></span></dt><dt><span class="sect3"><a href="#svn.reposadmin.basics.backends.fsfs">FSFS</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.reposadmin.create">Repository Creation and Configuration</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.reposadmin.create.hooks">Hook Scripts</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.create.bdb">Berkeley DB Configuration</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.reposadmin.maint">Repository Maintenance</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.reposadmin.maint.tk">An Administrator's Toolkit</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.reposadmin.maint.tk.svnlook">svnlook</a></span></dt><dt><span class="sect3"><a href="#svn.reposadmin.maint.tk.svnadmin">svnadmin</a></span></dt><dt><span class="sect3"><a href="#svn.reposadmin.maint.tk.svndumpfilter">svndumpfilter</a></span></dt><dt><span class="sect3"><a href="#svn.reposadmin.maint.tk.bdbutil">Berkeley DB Utilities</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.reposadmin.maint.cleanup">Repository Cleanup</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.maint.diskspace">Managing Disk Space</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.maint.recovery">Repository Recovery</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.maint.migrate">Migrating a Repository</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.maint.backup">Repository Backup</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.reposadmin.projects">Adding Projects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.reposadmin.projects.chooselayout">Choosing a Repository Layout</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.projects.import">Creating the Layout, and Importing Initial Data</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.reposadmin.summary">Summary</a></span></dt></dl></dd><dt><span class="chapter"><a href="#svn.serverconfig">6. Server Configuration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn.serverconfig.overview">Overview</a></span></dt><dt><span class="sect1"><a href="#svn.serverconfig.netmodel">Network Model</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.serverconfig.netmodel.reqresp">Requests and Responses</a></span></dt><dt><span class="sect2"><a href="#svn.serverconfig.netmodel.credcache">Client Credentials Caching</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.serverconfig.svnserve">svnserve, a custom server</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.serverconfig.svnserve.invoking">Invoking the Server</a></span></dt><dt><span class="sect2"><a href="#svn.serverconfig.svnserve.auth">Built-in authentication and authorization</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.serverconfig.svnserve.auth.users">Create a 'users' file and realm</a></span></dt><dt><span class="sect3"><a href="#svn.serverconfig.svnserve.auth.general">Set access controls</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.serverconfig.svnserve.sshauth">SSH authentication and authorization</a></span></dt><dt><span class="sect2"><a href="#svn.serverconfig.svnserve.sshtricks">SSH configuration tricks</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.serverconfig.svnserve.sshtricks.setup">Initial setup</a></span></dt><dt><span class="sect3"><a href="#svn.serverconfig.svnserve.sshtricks.fixedcmd">Controlling the invoked command</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.serverconfig.httpd">httpd, the Apache HTTP server</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.serverconfig.httpd.prereqs">Prerequisites</a></span></dt><dt><span class="sect2"><a href="#svn.serverconfig.httpd.basic">Basic Apache Configuration</a></span></dt><dt><span class="sect2"><a href="#svn.serverconfig.httpd.authn">Authentication Options</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.serverconfig.httpd.authn.basic">Basic HTTP Authentication</a></span></dt><dt><span class="sect3"><a href="#svn.serverconfig.httpd.authn.sslcerts">SSL Certificate Management</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.serverconfig.httpd.authz">Authorization Options</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.serverconfig.httpd.authz.blanket">Blanket Access Control</a></span></dt><dt><span class="sect3"><a href="#svn.serverconfig.httpd.authz.perdir">Per-Directory Access Control</a></span></dt><dt><span class="sect3"><a href="#svn.serverconfig.httpd.authz.pathauthzoff">Disabling Path-based Checks</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.serverconfig.httpd.extra">Extra Goodies</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.serverconfig.httpd.extra.browsing">Repository Browsing</a></span></dt><dt><span class="sect3"><a href="#svn.serverconfig.httpd.extra.other">Other Features</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.serverconfig.multimethod">Supporting Multiple Repository Access Methods</a></span></dt></dl></dd><dt><span class="chapter"><a href="#svn.advanced">7. Advanced Topics</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn.advanced.confarea">Runtime Configuration Area</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.advanced.confarea.layout">Configuration Area Layout</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.confarea.windows-registry">Configuration and the Windows Registry</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.confarea.opts">Configuration Options</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.advanced.confarea.opts.servers">Servers</a></span></dt><dt><span class="sect3"><a href="#svn.advanced.confarea.opts.config">Config</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.advanced.props">Properties</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.advanced.props.why">Why Properties?</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.props.manip">Manipulating Properties</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.props.special">Special Properties</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.advanced.props.special.executable"><code class="literal">svn:executable</code></a></span></dt><dt><span class="sect3"><a href="#svn.advanced.props.special.mime-type"><code class="literal">svn:mime-type</code></a></span></dt><dt><span class="sect3"><a href="#svn.advanced.props.special.ignore"><code class="literal">svn:ignore</code></a></span></dt><dt><span class="sect3"><a href="#svn.advanced.props.special.keywords"><code class="literal">svn:keywords</code></a></span></dt><dt><span class="sect3"><a href="#svn.advanced.props.special.eol-style"><code class="literal">svn:eol-style</code></a></span></dt><dt><span class="sect3"><a href="#svn.advanced.props.special.externals"><code class="literal">svn:externals</code></a></span></dt><dt><span class="sect3"><a href="#svn.advanced.props.special.special"><code class="literal">svn:special</code></a></span></dt><dt><span class="sect3"><a href="#svn.advanced.props.special.needs-lock"><code class="literal">svn:needs-lock</code></a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.advanced.props.auto">Automatic Property Setting</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.advanced.locking">Locking</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.advanced.locking.creation">Creating locks</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.locking.discovery">Discovering locks</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.locking.break-steal">Breaking and stealing locks</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.locking.lock-communication">Lock Communication</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.advanced.pegrevs">Peg and Operative Revisions</a></span></dt><dt><span class="sect1"><a href="#svn.advanced.externals">Externals Definitions</a></span></dt><dt><span class="sect1"><a href="#svn.advanced.vendorbr">Vendor branches</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.advanced.vendorbr.general">General Vendor Branch Management Procedure</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.vendorbr.svn_load_dirs"><span><strong class="command">svn_load_dirs.pl</strong></span></a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.advanced.l10n">Localization</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.advanced.l10n.understanding">Understanding locales</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.l10n.svnuse">Subversion's use of locales</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.advanced.externaldifftools">Using External Differencing Tools</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.advanced.externaldifftools.diff">External diff</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.externaldifftools.diff3">External diff3</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.advanced.reposurls">Subversion Repository URLs</a></span></dt></dl></dd><dt><span class="chapter"><a href="#svn.developer">8. Developer Information</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn.developer.layerlib">Layered Library Design</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.developer.layerlib.repos">Repository Layer</a></span></dt><dt><span class="sect2"><a href="#svn.developer.layerlib.ra">Repository Access Layer</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.developer.layerlib.ra.dav">RA-DAV (Repository Access Using HTTP/DAV)</a></span></dt><dt><span class="sect3"><a href="#svn.developer.layerlib.ra.svn">RA-SVN (Custom Protocol Repository Access)</a></span></dt><dt><span class="sect3"><a href="#svn.developer.layerlib.ra.local">RA-Local (Direct Repository Access)</a></span></dt><dt><span class="sect3"><a href="#svn.developer.layerlib.ra.yours">Your RA Library Here</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.developer.layerlib.client">Client Layer</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.developer.usingapi">Using the APIs</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.developer.usingapi.apr">The Apache Portable Runtime Library</a></span></dt><dt><span class="sect2"><a href="#svn.developer.usingapi.urlpath">URL and Path Requirements</a></span></dt><dt><span class="sect2"><a href="#svn.developer.usingapi.otherlangs">Using Languages Other than C and C++</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.developer.insidewc">Inside the Working Copy Administration Area</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.developer.insidewc.entries">The Entries File</a></span></dt><dt><span class="sect2"><a href="#svn.developer.insidewc.base-and-props">Pristine Copies and Property Files</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.developer.webdav">WebDAV</a></span></dt><dt><span class="sect1"><a href="#svn.developer.pools">Programming with Memory Pools</a></span></dt><dt><span class="sect1"><a href="#svn.developer.contrib">Contributing to Subversion</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.developer.contrib.join">Join the Community</a></span></dt><dt><span class="sect2"><a href="#svn.developer.contrib.get-code">Get the Source Code</a></span></dt><dt><span class="sect2"><a href="#svn.developer.contrib.hacking">Become Familiar with Community Policies</a></span></dt><dt><span class="sect2"><a href="#svn.developer.contrib.code-and-test">Make and Test Your Changes</a></span></dt><dt><span class="sect2"><a href="#svn.developer.contrib.submit">Donate Your Changes</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#svn.ref">9. Subversion Complete Reference</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn.ref.svn">The Subversion Command Line Client:
      <span><strong class="command">svn</strong></span></a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.ref.svn.sw"><span><strong class="command">svn</strong></span> Switches</a></span></dt><dt><span class="sect2"><a href="#svn.ref.svn.c"><span><strong class="command">svn</strong></span> Subcommands</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.add">svn add</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.blame">svn blame</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.cat">svn cat</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.checkout">svn checkout</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.cleanup">svn cleanup</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.commit">svn commit</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.copy">svn copy</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.delete">svn delete</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.diff">svn diff</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.export">svn export</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.help">svn help</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.import">svn import</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.info">svn info</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.list">svn list</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.lock">svn lock</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.log">svn log</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.merge">svn merge</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.mkdir">svn mkdir</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.move">svn move</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.propdel">svn propdel</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.propedit">svn propedit</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.propget">svn propget</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.proplist">svn proplist</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.propset">svn propset</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.resolved">svn resolved</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.revert">svn revert</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.status">svn status</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.switch">svn switch</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.unlock">svn unlock</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.update">svn update</a></span><span class="refpurpose"></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.ref.svnadmin"><span><strong class="command">svnadmin</strong></span></a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.ref.svnadmin.sw"><span><strong class="command">svnadmin</strong></span> Switches</a></span></dt><dt><span class="sect2"><a href="#svn.ref.svnadmin.c"><span><strong class="command">svnadmin</strong></span> Subcommands</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.create">svnadmin create</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.deltify">svnadmin deltify</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.dump">svnadmin dump</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.help">svnadmin help</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.hotcopy">svnadmin hotcopy</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.list-dblogs">svnadmin list-dblogs</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.list-unused-dblogs">svnadmin list-unused-dblogs</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.load">svnadmin load</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.lslocks">svnadmin lslocks</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.lstxns">svnadmin lstxns</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.recover">svnadmin recover</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.rmlocks">svnadmin rmlocks</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.rmtxns">svnadmin rmtxns</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.setlog">svnadmin setlog</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.verify">svnadmin verify</a></span><span class="refpurpose"></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.ref.svnlook"><span><strong class="command">svnlook</strong></span></a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.ref.svnlook.sw"><span><strong class="command">svnlook</strong></span> Switches</a></span></dt><dt><span class="sect2"><a href="#svn.ref.svnlook.c"><span><strong class="command">svnlook</strong></span></a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.author">svnlook author</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.cat">svnlook cat</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.changed">svnlook changed</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.date">svnlook date</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.diff">svnlook diff</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.dirs-changed">svnlook dirs-changed</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.help">svnlook help</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.history">svnlook history</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.info">svnlook info</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.lock">svnlook lock</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.log">svnlook log</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.propget">svnlook propget</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.proplist">svnlook proplist</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.tree">svnlook tree</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.uuid">svnlook uuid</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.youngest">svnlook youngest</a></span><span class="refpurpose"></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.ref.svnserve"><span><strong class="command">svnserve</strong></span></a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.ref.svnserve.sw"><span><strong class="command">svnserve</strong></span> Switches</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.ref.svnversion"><span><strong class="command">svnversion</strong></span></a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#svn.ref.svnversion.re">svnversion</a></span><span class="refpurpose"></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.ref.mod_dav_svn"><span><strong class="command">mod_dav_svn</strong></span></a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#svn.ref.mod_dav_svn.conf"><code class="literal">mod_dav_svn</code> Configuration
        Directives</a></span><span class="refpurpose"></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.ref.properties"><span><strong class="command">Subversion properties</strong></span></a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#svn.ref.svnprops">Subversion-defined properties</a></span><span class="refpurpose"></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="#svn.forcvs">A. Subversion for CVS Users</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn.forcvs.revnums">Revision Numbers Are Different Now</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.directories">Directory Versions</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.disconnected">More Disconnected Operations</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.status-vs-update">Distinction Between Status and Update</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.forcvs.status-vs-update.status">Status</a></span></dt><dt><span class="sect2"><a href="#svn.forcvs.status-vs-update.update">Update</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.forcvs.branches-and-tags">Branches and Tags</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.properties">Metadata Properties</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.conflicts">Conflict Resolution</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.binary-and-trans">Binary Files and Translation</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.modules">Versioned Modules</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.auth">Authentication</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.convert">Converting a Repository from CVS to Subversion</a></span></dt></dl></dd><dt><span class="appendix"><a href="#svn.webdav">B. WebDAV and Autoversioning</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn.webdav.basic">Basic WebDAV Concepts</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.webdav.basic.original">Original WebDAV</a></span></dt><dt><span class="sect2"><a href="#svn.webdav.basic.deltav">DeltaV Extensions</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.webdav.svn-and-deltav">Subversion and DeltaV</a></span></dt><dt><span class="sect1"><a href="#svn.webdav.autoversioning">Autoversioning</a></span></dt><dt><span class="sect1"><a href="#svn.webdav.clients">Client Interoperability</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.webdav.clients.standalone">Standalone WebDAV applications</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.webdav.clients.standalone.windows">Microsoft Office, Dreamweaver, Photoshop</a></span></dt><dt><span class="sect3"><a href="#svn.webdav.clients.standalone.free">Cadaver, DAV Explorer</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.webdav.clients.file-explorer-extensions">File-explorer WebDAV extensions</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.webdav.clients.file-explorer-extensions.windows">Microsoft Web Folders</a></span></dt><dt><span class="sect3"><a href="#svn.webdav.clients.file-explorer-extensions.linux-de">Nautilus, Konqueror</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.webdav.clients.fs-impl">WebDAV filesystem implementation</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.webdav.clients.fs-impl.windows">WebDrive, NetDrive</a></span></dt><dt><span class="sect3"><a href="#svn.webdav.clients.fs-impl.macosx">Mac OS X</a></span></dt><dt><span class="sect3"><a href="#svn.webdav.clients.fs-impl.linux">Linux davfs2</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="appendix"><a href="#svn.3rdparty">C. Third Party Tools</a></span></dt><dt><span class="appendix"><a href="#svn.copyright">D. Copyright</a></span></dt></dl></div><div class="list-of-figures"><p><b>Lista delle Figure</b></p><dl><dt>1.1. <a href="#svn.intro.architecture.dia-1">Architettura di Subversion</a></dt><dt>2.1. <a href="#svn.basic.repository.dia-1">A typical client/server system</a></dt><dt>2.2. <a href="#svn.basic.vsn-models.problem-sharing.dia-1">The problem to avoid</a></dt><dt>2.3. <a href="#svn.basic.vsn-models.lock-unlock.dia-1">The lock-modify-unlock solution</a></dt><dt>2.4. <a href="#svn.basic.vsn-models.copy-merge.dia-1">The copy-modify-merge solution</a></dt><dt>2.5. <a href="#svn.basic.vsn-models.copy-merge.dia-2">The copy-modify-merge solution (continued)</a></dt><dt>2.6. <a href="#svn.basic.in-action.wc.dia-1">The repository's filesystem</a></dt><dt>2.7. <a href="#svn.basic.in-action.revs.dia-1">The repository</a></dt><dt>4.1. <a href="#svn.branchmerge.whatis.dia-1">Branches of development</a></dt><dt>4.2. <a href="#svn.branchmerge.using.dia-1">Starting repository layout</a></dt><dt>4.3. <a href="#svn.branchmerge.using.create.dia-1">Repository with new copy</a></dt><dt>4.4. <a href="#svn.branchmerge.using.work.dia-1">The branching of one file's history</a></dt><dt>8.1. <a href="#svn.developer.layerlib.repos.dia-1">Files and directories in two dimensions</a></dt><dt>8.2. <a href="#svn.developer.layerlib.repos.dia-2">Versioning time—the third dimension!</a></dt></dl></div><div class="list-of-tables"><p><b>Lista delle Tabelle</b></p><dl><dt>2.1. <a href="#svn.basic.in-action.wc.tbl-1">Repository Access URLs</a></dt><dt>5.1. <a href="#svn.reposadmin.basics.backends.tbl-1">Repository Data Store Comparison</a></dt><dt>6.1. <a href="#svn.serverconfig.overview.tbl-1">Network Server Comparison</a></dt><dt>8.1. <a href="#svn.developer.layerlib.tbl-1">A Brief Inventory of the Subversion Libraries</a></dt><dt>B.1. <a href="#svn.webdav.clients.tbl-1">Common WebDAV Clients</a></dt></dl></div><div class="list-of-examples"><p><b>Lista degli Esempi</b></p><dl><dt>5.1. <a href="#svn.reposadmin.maint.cleanup.ex-1">txn-info.sh (Reporting Outstanding Transactions)</a></dt><dt>6.1. <a href="#svn.serverconfig.httpd.authz.perdir.ex-1">A sample configuration for anonymous access.</a></dt><dt>6.2. <a href="#svn.serverconfig.httpd.authz.perdir.ex-2">A sample configuration for authenticated access.</a></dt><dt>6.3. <a href="#svn.serverconfig.httpd.authz.perdir.ex-3">A sample configuration for mixed
            authenticated/anonymous access.</a></dt><dt>6.4. <a href="#svn.serverconfig.httpd.authz.pathauthzoff.ex-1">Disabling path checks altogether</a></dt><dt>7.1. <a href="#svn.advanced.confarea.windows-registry.ex-1">Sample Registration Entries (.reg) File.</a></dt><dt>7.2. <a href="#svn.advanced.externaldifftools.diff.ex-1">diffwrap.sh</a></dt><dt>7.3. <a href="#svn.advanced.externaldifftools.diff.ex-2">diffwrap.bat</a></dt><dt>7.4. <a href="#svn.advanced.externaldifftools.diff3.ex-1">diff3wrap.sh</a></dt><dt>7.5. <a href="#svn.advanced.externaldifftools.diff3.ex-2">diff3wrap.bat</a></dt><dt>8.1. <a href="#svn.developer.layerlib.repos.ex-1">Using the Repository Layer</a></dt><dt>8.2. <a href="#svn.developer.usingapi.otherlangs.ex-1">Using the Repository Layer with Python</a></dt><dt>8.3. <a href="#svn.developer.usingapi.otherlangs.ex-2">A Python Status Crawler</a></dt><dt>8.4. <a href="#svn.developer.insidewc.entries.ex-1">Contents of a Typical <code class="filename">.svn/entries</code>
          File</a></dt><dt>8.5. <a href="#svn.developer.pools.ex-1">Effective Pool Usage</a></dt></dl></div><div class="preface" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title"><a id="svn.foreword"></a>Foreword</h2></div></div></div><div class="simplesect" lang="it" xml:lang="it"><div class="titlepage"></div><p>A bad Frequently Asked Questions (FAQ) sheet is one that is
      composed not of the questions people actually asked, but of the
      questions the FAQ's author <span class="emphasis"><em>wished</em></span> people
      had asked.  Perhaps you've seen the type before:</p><div class="blockquote"><blockquote class="blockquote"><p>Q: How can I use Glorbosoft XYZ to maximize team
        productivity?</p></blockquote></div><div class="blockquote"><blockquote class="blockquote"><p>A: Many of our customers want to know how they can
        maximize productivity through our patented office groupware
        innovations.  The answer is simple: first, click on the
        «<span class="quote"><code class="literal">File</code></span>» menu, scroll down to
        «<span class="quote"><code class="literal">Increase Productivity</code></span>»,
        then…</p></blockquote></div><p>The problem with such FAQs is that they are not, in a
      literal sense, FAQs at all.  No one ever called the tech support
      line and asked, «<span class="quote">How can we maximize
      productivity?</span>».  Rather, people asked highly specific
      questions, like, «<span class="quote">How can we change the calendaring system
      to send reminders two days in advance instead of one?</span>»
      and so on.  But it's a lot easier to make up imaginary
      Frequently Asked Questions than it is to discover the real ones.
      Compiling a true FAQ sheet requires a sustained, organized
      effort: over the lifetime of the software, incoming questions
      must be tracked, responses monitored, and all gathered into a
      coherent, searchable whole that reflects the collective
      experience of users in the wild.  It calls for the patient,
      observant attitude of a field naturalist.  No grand
      hypothesizing, no visionary pronouncements here—open eyes
      and accurate note-taking are what's needed most.</p><p>What I love about this book is that it grew out of just such
      a process, and shows it on every page.  It is the direct result
      of the authors' encounters with users.  It began with Ben
      Collins-Sussman's observation that people were asking the same
      basic questions over and over on the Subversion mailing lists:
      What are the standard workflows to use with Subversion?  Do
      branches and tags work the same way as in other version control
      systems?  How can I find out who made a particular change?</p><p>Frustrated at seeing the same questions day after day, Ben
      worked intensely over a month in the summer of 2002 to write
      <em class="citetitle">The Subversion Handbook</em>, a sixty page
      manual that covered all the basics of using Subversion.  The
      manual made no pretense of being complete, but it was
      distributed with Subversion and got users over that initial hump
      in the learning curve.  When O'Reilly and Associates decided to
      publish a full-length Subversion book, the path of least
      resistance was obvious: just expand the Subversion
      handbook.</p><p>The three co-authors of the new book were thus presented
      with an unusual opportunity.  Officially, their task was to
      write a book top-down, starting from a table of contents and an
      initial draft.  But they also had access to a steady
      stream—indeed, an uncontrollable geyser—of bottom-up
      source material.  Subversion was already in the hands of
      thousands of early adopters, and those users were giving tons of
      feedback, not only about Subversion, but about its existing
      documentation.</p><p>During the entire time they wrote this book, Ben, Mike, and
      Brian haunted the Subversion mailing lists and chat rooms
      incessantly, carefully noting the problems users were having in
      real-life situations.  Monitoring such feedback is part of their
      job descriptions at CollabNet anyway, and it gave them a huge
      advantage when they set out to document Subversion.  The book
      they produced is grounded firmly in the bedrock of experience,
      not in the shifting sands of wishful thinking; it combines the
      best aspects of user manual and FAQ sheet.  This duality might
      not be noticeable on a first reading.  Taken in order, front to
      back, the book is simply a straightforward description of a
      piece of software.  There's the overview, the obligatory guided
      tour, the chapter on administrative configuration, some advanced
      topics, and of course a command reference and troubleshooting
      guide.  Only when you come back to it later, seeking the
      solution to some specific problem, does its authenticity shine
      out: the telling details that can only result from encounters
      with the unexpected, the examples honed from genuine use cases,
      and most of all the sensitivity to the user's needs and the
      user's point of view.</p><p>Of course, no one can promise that this book will answer
      every question you have about Subversion.  Sometimes, the
      precision with which it anticipates your questions will seem
      eerily telepathic; yet occasionally, you will stumble into a
      hole in the community's knowledge, and come away empty-handed.
      When this happens, the best thing you can do is email
      <code class="email">&lt;<a href="mailto:users@subversion.tigris.org">users@subversion.tigris.org</a>&gt;</code> and present your
      problem.  The authors are still there, still watching, and they
      include not just the three listed on the cover, but many others
      who contributed corrections and original material.  From the
      community's point of view, solving your problem is merely a
      pleasant side effect of a much larger project—namely,
      slowly adjusting this book, and ultimately Subversion itself, to
      more closely match the way people actually use it.  They are
      eager to hear from you not merely because they can help you, but
      because you can help them.  With Subversion as with all active
      free software projects, <span class="emphasis"><em>you are not
      alone</em></span>.</p><p>Let this book be your first companion.</p><p>—
      <span class="author"><span class="firstname">Karl</span> <span class="surname">Fogel</span></span>, Chicago, 14 March, 2004</p></div></div><div class="preface" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title"><a id="svn.preface"></a>Prefazione</h2></div></div></div><div class="toc"><p><b>Sommario</b></p><dl><dt><span class="sect1"><a href="#svn.preface.audience">A chi è rivolto questo libro</a></span></dt><dt><span class="sect1"><a href="#svn.preface.howread">Come Leggere Questo Libro</a></span></dt><dt><span class="sect1"><a href="#svn.preface.conventions">Convenzioni Utilizzate in Questo Libro</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.preface.conventions.typo">Convenzioni Tipografiche</a></span></dt><dt><span class="sect2"><a href="#svn.preface.conventions.icons">Icons</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.preface.organization">Organizzazione di questo libro</a></span></dt><dt><span class="sect1"><a href="#svn.preface.free">Questo libro è libero</a></span></dt><dt><span class="sect1"><a href="#svn.preface.acks">Acknowledgments</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.preface.acks.sussman">Da Ben Collins-Sussman</a></span></dt><dt><span class="sect2"><a href="#svn.preface.acks.fitz">Da Brian W. Fitzpatrick</a></span></dt><dt><span class="sect2"><a href="#svn.preface.acks.cmpilato">Da C. Michael Pilato</a></span></dt></dl></dd></dl></div><div class="simplesect" lang="it" xml:lang="it"><div class="titlepage"></div><div class="blockquote"><blockquote class="blockquote"><p>«<span class="quote">If C gives you enough rope to hang yourself, think
        of Subversion as a sort of rope storage facility.</span>»
	«<span class="quote">Se il C fornisce corda a sufficienza per impiccarti, pensa a 
	Subversion come una sorta di magazzino di corde.</span>»
        —Brian W. Fitzpatrick</p></blockquote></div><p>Nel mondo del software open-source, Concurrent Versions System (CVS)
      è stato a lungo lo strumento preferito per la gestione delle versioni.
      E giustamente. Lo stesso CVS è software libero ed il suo 
      <span class="foreignphrase"><em class="foreignphrase">modus operandi</em></span> non-restrittivo, unito al
      supporto per il funzionamento in rete—che permette a dozzine di 
      programmatori sparsi per il mondo di condividere il proprio 
      lavoro—calza perfettamente alla natura collaborativa del mondo
      open-source. CVS ed il suo modello di sviluppo semi-caotico sono 
      diventati un elemento fondamentale della cultura open-source.
    </p><p>Ma come molti altri strumenti, CVS sta iniziando a mostrare la sua età.
      Subversion è un sistema di controllo di versione relativamente nuovo,
      progettato per essere il successore di CVS. I progettisti hanno mirato al 
      cuore degli utenti CVS in due modi: creando un sistema open-source con
      un'architettura (ed un «<span class="quote">look and feel</span>») simili a CVS, e 
      contemporaneamente provando ad eliminare la maggior parte dei difetti più
      evidenti di CVS.
      Sebbene il risultato non sia il prossimo grande salto evolutivo dei 
      sistemi di controllo di versione, Subversion <span class="emphasis"><em>è</em></span> 
      molto potente, usabile e flessibile.
    </p><p>Questo libro documenta la serie 1.2 del sistema di controllo di 
      versione Subversion.  Abbiamo cercato di essere esaustivi nella nostra 
      analisi. Tuttavia, Subversion ha una comunità di sviluppo fiorente e 
      piena di energie ed esiste già un nutrito numero di funzionalità e
      miglioramenti pianificati per le prossime versioni che potranno 
      apportare modifiche ad alcuni dei comandi ed annotazioni contenuti in
      questo libro.
    </p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.preface.audience"></a>A chi è rivolto questo libro</h2></div></div></div><p>Questo libro è scritto per persone con una certa 
      dimestichezza con il computer che vogliono utilizzare 
      Subversion per gestire i propri dati.  Nonostante Subversion
      sia disponibile per un certo numero di sistemi operativi, 
      la sua interfaccia primaria è basata sulla linea di comando.
      Il programma discusso ed utilizzato in questo libro è
      (<span><strong class="command">svn</strong></span>).  Per coerenza, gli esempi di questo
      libro assumono che il lettore utilizzi un sistema operativo 
      di derivazione Unix e sia relativamente a proprio agio con Unix
      e le interfacce a linea di comando.</p><p>Detto questo, il programma <span><strong class="command">svn</strong></span> funziona anche
      su piattaforme non-Unix come Microsoft Windows.  Con qualche piccola
      eccezione, come l'uso dei backslash (<code class="literal">\</code>) al posto
      degli slash (<code class="literal">/</code>) come separatore di percorso, 
      l'input e l'output prodotti dal programma quando questo è eseguito 
      su Windows sono identici a quelli prodotti dalla controparte su Unix.
      Tuttavia, gli utenti Windows potrebbero avere più successo eseguendo
      gli esempi all'interno dell'ambiente di emulazione Unix Cygwin.</p><p>La maggior parte dei lettori saranno probabilmente programmatori
      o amministratori di sistema che necessitano di tenere traccia delle
      modifiche al codice sorgente. Questo è l'uso più comune di
      Subversion, e quindi è lo scenario utilizzato in tutti gli esempi
      del libro. Ma Subversion può essere utilizzato per gestire modifiche
      apportate a qualunque tipo di informazione: immagini, musica, database,
      documentazione e via dicendo. Per Subversion, i dati sono solo dati.</p><p>Nonostante questo libro sia stato scritto presumendo che il
      lettore non abbia mai utilizzato un sistema di controllo di versione,
      abbiamo provato a rendere la transizione di utenti CVS indolore.
      Speciali trafiletti discuteranno CVS di tanto in tanto ed 
      un'apposita appendice fornisce un sommario delle principali
      differenze tra CVS e Subversion.</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.preface.howread"></a>Come Leggere Questo Libro</h2></div></div></div><p>Questo libro mira ad essere utile per gente con preparazione di
      livello diferente—da persone senza nessuna precedente 
      esperienza con il controllo di versione ad amministratori di 
      sistema esperti. A seconda del proprio background, certi capitoli
      potranno essere più o meno importanti.  La seguente può essere 
      considerata una «<span class="quote">lista di letture consigliate</span>» per i 
      vari tipi di lettore:</p><div class="variablelist"><dl><dt><span class="term">Amministratori di sistema con esperienza</span></dt><dd><p>L'assunto è che tu abbia usato CVS in precedenza, 
	    e che tu muoia dalla voglia di avere un server Subversion
	    funzionante il prima possibile.  <a href="#svn.reposadmin" title="Capitolo&#xA0;5.&#xA0;Repository Administration">Capitolo 5, <i>Repository Administration</i></a> e <a href="#svn.serverconfig" title="Capitolo&#xA0;6.&#xA0;Server Configuration">Capitolo 6, <i>Server Configuration</i></a> ti mostreranno come creare 
	      il tuo primo repository e renderlo disponibile in rete.  
	      Fatto questo, <a href="#svn.tour" title="Capitolo&#xA0;3.&#xA0;Visita guidata">Capitolo 3, <i>Visita guidata</i></a> e
            <a href="#svn.forcvs" title="Appendice&#xA0;A.&#xA0;Subversion for CVS Users">Appendice A, <i>Subversion for CVS Users</i></a> sono la via più veloce per
	    imparare ad usare il client Subversion attingendo dalla tua
	    esperienza con CVS.</p></dd><dt><span class="term">Nuovi utenti</span></dt><dd><p>Probabilmente il tuo amministratore ha già installato
	    Subversion, e tu vuoi imparare ad utilizzare il client.  Se non 
	    hai mai utilizzato un sistema di controllo delle versioni (come
	    CVS), <a href="#svn.basic" title="Capitolo&#xA0;2.&#xA0;Basic Concepts">Capitolo 2, <i>Basic Concepts</i></a> e <a href="#svn.tour" title="Capitolo&#xA0;3.&#xA0;Visita guidata">Capitolo 3, <i>Visita guidata</i></a> forniscono un'introduzione essenziale. 
	      Se invece hai già una discreta esperienza con CVS, il capitolo 
	      3 e l'appendice A sono i migliori punti di partenza.</p></dd><dt><span class="term">Utenti esperti</span></dt><dd><p>Che tu sia un utente o un amministratore, il tuo 
	    progetto potrebbe diventare più grande. Vorrai imparare
	    come fare cose più avanzate con Subversion, ad esempio come
	    usare le branch ed effettuare merge (<a href="#svn.branchmerge" title="Capitolo&#xA0;4.&#xA0;Branching and Merging">Capitolo 4, <i>Branching and Merging</i></a>), come usare il supporto di 
	    Subversion per le proprietà, come confiurare le opzioni di
	    esecuzione (<a href="#svn.advanced" title="Capitolo&#xA0;7.&#xA0;Advanced Topics">Capitolo 7, <i>Advanced Topics</i></a>), e altro ancora.
	    Questi due capitoli non sono di importanza vitale all'inizio, 
	    ma assicurati di leggerli una volta preso confidenza con le
	    operazioni di base.</p></dd><dt><span class="term">Sviluppatori</span></dt><dd><p>Presubimilmente Subversion ti è già familiare, ed ora vorresti
	    approfondire l'argomento o creare nuovi programmi utilizzando
	    le sue numerose API.  <a href="#svn.developer" title="Capitolo&#xA0;8.&#xA0;Developer Information">Capitolo 8, <i>Developer Information</i></a> fa al 
	    caso tuo.</p></dd></dl></div><p>Il libro si chiude con le appendici—<a href="#svn.ref" title="Capitolo&#xA0;9.&#xA0;Subversion Complete Reference">Capitolo 9, <i>Subversion Complete Reference</i></a> è una guida di riferimento per tutti i comandi di 
	Subversion e le appendici coprono una serie di argomenti utili.
	Questi sono i capitoli su cui tornerai con maggior probabilità una
	volta finito di leggere il libro.</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.preface.conventions"></a>Convenzioni Utilizzate in Questo Libro</h2></div></div></div><p>Questa sezione copre le varie convenzioni utilizzate nel 
      presente libro.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.preface.conventions.typo"></a>Convenzioni Tipografiche</h3></div></div></div><div class="variablelist"><dl><dt><span class="term"><span><strong class="command">Larghezza fissa</strong></span></span></dt><dd><p>Utilizzato per comandi, output dei programmi, e switch</p></dd><dt><span class="term"><em class="replaceable"><code>Larghezza fissa e corsivo</code></em></span></dt><dd><p>Utilizzato per elementi sostituibili nel codice e nel testo</p></dd><dt><span class="term"><code class="filename">Corsivo</code></span></dt><dd><p>Utilizzato per nomi di file e directory</p></dd></dl></div></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.preface.conventions.icons"></a>Icons</h3></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Nota</h3><p>Questa icona indica una nota relativa al testo adiacente.</p></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Suggerimento</h3><p>Questa icon indica un aiuto utile relativo al testo adiacente.</p></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Avvertimento</h3><p>Questa icona identifica un avviso relativo al testo adicente.</p></div></div><p>Notare che gli esempi di codice sorgenti sono solo quello —esempi.  
      Sebbene compilino sono stati scritti a supporto dell'illustrazione dei vari 
      problemi, non sono necessariamente da prendere come esempi di buona pragrammazione.
      </p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.preface.organization"></a>Organizzazione di questo libro</h2></div></div></div><p>Segue la lista dei capitoli e del loro contenuto:</p><div class="variablelist"><dl><dt><span class="term"><a href="#svn.intro" title="Capitolo&#xA0;1.&#xA0;Introduzione">Capitolo 1, <i>Introduzione</i></a></span></dt><dd><p>Copre la storia di Subversion ed anche le sue caratteristiche, 
	    l'architettura, i componenti ed i metodi d'installazione.
              Include anche una guida per un'inizio rapido.</p></dd><dt><span class="term"><a href="#svn.basic" title="Capitolo&#xA0;2.&#xA0;Basic Concepts">Capitolo 2, <i>Basic Concepts</i></a></span></dt><dd><p>Explains the basics of version control and different
              versioning models, along with Subversion's repository,
              working copies, and revisions.</p></dd><dt><span class="term"><a href="#svn.tour" title="Capitolo&#xA0;3.&#xA0;Visita guidata">Capitolo 3, <i>Visita guidata</i></a></span></dt><dd><p>Descrive una giornata di lavoro di un utente di  Subversion.
	    Mostra come usare subversion per ottenere, modificare ed effettuare commit
	    di dati.</p></dd><dt><span class="term"><a href="#svn.branchmerge" title="Capitolo&#xA0;4.&#xA0;Branching and Merging">Capitolo 4, <i>Branching and Merging</i></a></span></dt><dd><p>Discute i branches, le fusioni (merges), le etichettature, comprendendo
              consigli per il branching e le fusioni (merging), casi d'uso comuni,
	      come annullare i cambiamenti, e come dondolarsi da un ramo (branch) ad un altro.</p></dd><dt><span class="term"><a href="#svn.reposadmin" title="Capitolo&#xA0;5.&#xA0;Repository Administration">Capitolo 5, <i>Repository Administration</i></a></span></dt><dd><p>Descrive le basi del repositor di Subversiion,
              come creare, configurare e mantenere un repository, e gli 
	      strumenti che possono essere usati per fare tutto questo.</p></dd><dt><span class="term"><a href="#svn.serverconfig" title="Capitolo&#xA0;6.&#xA0;Server Configuration">Capitolo 6, <i>Server Configuration</i></a></span></dt><dd><p>Spiega come configurare il vostro server Subversion ed 
	    i tre modi per accedere al repository:
              <code class="literal">HTTP</code>, il protocollo <code class="literal">svn</code>,
	      e l'accesso locale.  Copre anche i dettagli riguardanti l'autenticazione,
	      l'autorizzazione e l'accesso anonimo.</p></dd><dt><span class="term"><a href="#svn.advanced" title="Capitolo&#xA0;7.&#xA0;Advanced Topics">Capitolo 7, <i>Advanced Topics</i></a></span></dt><dd><p>Esplora i file di configurazione del client Subversion,
              le proprietà dei files e delle directory, come
              <code class="literal">ignorare</code> i files nella vostra copia locale,
              come includere alberature esterne nella vostra copia di lavoro, ed infine,
	      come gestire i rami (branches) di terze parti.</p></dd><dt><span class="term"><a href="#svn.developer" title="Capitolo&#xA0;8.&#xA0;Developer Information">Capitolo 8, <i>Developer Information</i></a></span></dt><dd><p> Descrive gli aspetti interni di Subversion, il file system di Subversion,
	    e, dal punto di vista di un programmatore, aree amministrative della copia locale.
              Mostra coeme usare le API pubbliche per scrivere un programma 
	      che utilizzi subversion, e più importante, come contribuire
	      allo sviluppo di subversion.</p></dd><dt><span class="term"><a href="#svn.ref" title="Capitolo&#xA0;9.&#xA0;Subversion Complete Reference">Capitolo 9, <i>Subversion Complete Reference</i></a></span></dt><dd><p>Spiega con grande dettaglio ogni comando di 
              <span><strong class="command">svn</strong></span>, <span><strong class="command">svnadmin</strong></span>, e
              <span><strong class="command">svnlook</strong></span> con molti esempi al riguardo!</p></dd><dt><span class="term"><a href="#svn.forcvs" title="Appendice&#xA0;A.&#xA0;Subversion for CVS Users">Appendice A, <i>Subversion for CVS Users</i></a></span></dt><dd><p>Copre le similitudini e differenze tra 
              Subversion e CVS,con numerosi suggerimenti riguardo come
	      evitare i cattivi comportamenti che sono stati acquisiti 
	      durante gli anni d'uso di CVS.
	      Vengono incluse descrizioni dei numeri di revisione di Subversion,
	      delle directory versionate, delle operazioni offline, di <span><strong class="command">update</strong></span>
              rispetto a <span><strong class="command">status</strong></span>, ramificazioni (branches), etichettature, metadata,
              risoluzioni di conflitti ed autenicazione.</p></dd><dt><span class="term"><a href="#svn.webdav" title="Appendice&#xA0;B.&#xA0;WebDAV and Autoversioning">Appendice B, <i>WebDAV and Autoversioning</i></a></span></dt><dd><p>Descrive i dettagli di WebDAV e DeltaV, come configurare 
	    il repository Subversion per essere montato in lettura/scrittura come una
	    condivisioe DAV.</p></dd><dt><span class="term"><a href="#svn.3rdparty" title="Appendice&#xA0;C.&#xA0;Third Party Tools">Appendice C, <i>Third Party Tools</i></a></span></dt><dd><p>Discute i tools che supportano o utilizzano Subversion,
              includendo programmi client alternativi, strumenti per il browsin della
	      repository, e così via.</p></dd></dl></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.preface.free"></a>Questo libro è libero</h2></div></div></div><p>This book started out as bits of documentation written by
      Subversion project developers, which were then coalesced into a
      single work and rewritten.  As such, it has always been under a
      free license.  (See <a href="#svn.copyright" title="Appendice&#xA0;D.&#xA0;Copyright">Appendice D, <i>Copyright</i></a>.)  In fact,
      the book was written in the public eye, as a part of Subversion.
      This means two things:</p><div class="itemizedlist"><ul type="disc"><li><p>You will always find the latest version of this book in
          the book's own Subversion repository.</p></li><li><p>You can distribute and make changes to this book however
          you wish—it's under a free license.  Of course,
          rather than distribute your own private version of this
          book, we'd much rather you send feedback and patches to the
          Subversion developer community.  See <a href="#svn.developer.contrib" title="Contributing to Subversion">la sezione chiamata «Contributing to Subversion»</a> to learn about joining this
          community.</p></li></ul></div><p>Una copia relativamente recente della versione online di questo libro 
    può essere trovata presso <a href="http://svnbook.red-bean.com" target="_top">http://svnbook.red-bean.com</a>.</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.preface.acks"></a>Acknowledgments</h2></div></div></div><p>
      Questo libero non esisterebbe (non sarebbe molto utile) se 
      Subversion non esistesse.  Per questo, gli autori vogliono ringraziare
       Brian Behlendorf ed il CollabNet per la volontà di finanziare 
       un progetto Open Source così rischioso ed ambizioso; ringraziano anche Jim Blandy
       per il nome orginale Subversion e per il progetto— ti abbiamo perso, Jim;
      Karl Fogel per essere, in quest'ordine, un così buon amico ed un grande leader per la comunità.
      <sup>[<a id="id4725434" href="#ftn.id4725434">1</a>]</sup></p><p>Thanks alla O'Reilly ed ai suoi editori, Linda Mui e Tatiana
      Diaz per la loro pazienza e supporto.</p><p>Infine, ringraziamo l'innumerevole lista di persone che hanno contribuito
      a questo libro con revisioni informali, suggerimenti e correzioni: 
      sebbene questa lista sia sicuramente incompleta, questo libro sarebbe
      incompleto e non corretto senza l'aiuto di: 
      Jani Averbach,
      Ryan Barrett, Francois Beausoleil, Jennifer Bevan, Matt Blais,
      Zack Brown, Martin Buchholz, Brane Cibej, John R. Daily, Peter
      Davis, Olivier Davy, Robert P. J. Day, Mo DeJong, Brian Denny,
      Joe Drew, Nick Duffek, Ben Elliston, Justin Erenkrantz, Shlomi
      Fish, Julian Foad, Chris Foote, Martin Furter, Dave Gilbert,
      Eric Gillespie, Matthew Gregan, Art Haas, Greg Hudson, Alexis
      Huxley, Jens B. Jorgensen, Tez Kamihira, David Kimdon, Mark
      Benedetto King, Andreas J. Koenig, Nuutti Kotivuori, Matt Kraai,
      Scott Lamb, Vincent Lefevre, Morten Ludvigsen, Paul Lussier,
      Bruce A. Mah, Philip Martin, Feliciano Matias, Patrick Mayweg,
      Gareth McCaughan, Jon Middleton, Tim Moloney, Mats Nilsson, Joe
      Orton, Amy Lyn Pilato, Kevin Pilch-Bisson, Dmitriy Popkov,
      Michael Price, Mark Proctor, Steffen Prohaska, Daniel Rall,
      Tobias Ringstrom, Garrett Rooney, Joel Rosdahl, Christian Sauer,
      Larry Shatzer, Russell Steicke, Sander Striker, Erik Sjoelund,
      Johan Sundstroem, John Szakmeister, Mason Thomas, Eric
      Wadsworth, Colin Watson, Alex Waugh, Chad Whitacre, Josef Wolf,
      Blair Zajac, e l'intera comunità di Subversion.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.preface.acks.sussman"></a>Da Ben Collins-Sussman</h3></div></div></div><p>Grazie a mia moglie Frances, che, per molti mesi, mi ha ascoltato,
       «<span class="quote">Ma tesoro, sto ancora lavorando al libro</span>»,
        più del solito, «<span class="quote">Ma tesoro, sto ancora scrivendo delle email.
	</span>»  Non so da dove prenda tutta quella pazienza!
        E' un contrappeso perfetta.</p><p>Grazie alla mia famiglia acquisita per il loro sincero
      incoraggiamento, nonostante non abbiano un reale interesse nell'argomento. 
      (Sai quando uno ti dice, «<span class="quote">Ooh, stai scrivendo un libro?</span>», 
      e poi quando gli dite che è un libro di computer, glissano.)
      </p><p>Grazie a tutti i miei amici più vicini, che mi rendono un uomo ricco, ricco davvero.
        Non guardatemi in quel modo—voi sapete chi siete.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.preface.acks.fitz"></a>Da Brian W. Fitzpatrick</h3></div></div></div><p>Un enorme ringraziamento a mia moglie Marie per essere incredibilmente 
        comprensiva, di aiuto, e soprautto, paziente.  Grazie a mio fratello Eric
	che per primo mi ha introdotto al modo di programmare UNIX.
	Grazie alla mia Mamam e Nonna per tutto il loro aiuto, per non dire
	durante le vacanze di Natale quando tornai a casa ed immediatamente 
	e subito mi misi testa a cuocere sul portatile per lavorare sul libro.
	</p><p>A Mike e Ben: è stato un piacere lavorare con voi al libro.
      Heck, è un piacere lavorare con te al lavoro!</p><p>A chiunque nella comunità Subversion e nella Apache
        Software Foundation, grazie for avermi tra voi.  
	Non passa giorno nel quale non impari qualcosa da almeno uno di voi.
      </p><p>Infine grazie, grazie a mio Nonno che mi ha sempre detto che 
        «<span class="quote">libertà uguale responsabilità.</span>» Non potrei essere più
	d'accordo.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.preface.acks.cmpilato"></a>Da C. Michael Pilato</h3></div></div></div><p>
	Un ringraziamento speciale a mia moglie, Amy, per il suo amore e 
	paziente aiuto, alzarsi a notte fonda, ed anche per 
	aver rivisto intere sezioni di questo libro—
	fai sempre cose straordinarie e lo fai con una grazie incredibile. 
	Gavin, quando sarai abbastanza grande per leggere, spero che tu possa essere
	orgoglioso di tuo padre come lui lo è di te.
	Mamma e Papà (ed il resto della famiglia), grazie per vostro costante aiuto ed
	entusiamo.</p><p>Tanto di cappello per Shep Kendall, tramite il quale mi introdusse al 
      mondo dei computer per la prima volta; Ben Collins-Sussman, la mia guida turistica
      nel mondo open-source; Karl Fogel— tu
        <span class="emphasis"><em>sei</em></span> il mio <code class="filename">.emacs</code>; Greg
        Stein, per distillare conoscenza riguardo la programmazione pratica; 
		
	Brian Fitzpatrick— per avere condiviso come me questa esperienza di scrittura.
        Ai tutti quelli dai quali costantemente raccolgo nuova conoscenza
        —continuate a lasciarla cadere!</p><p>Infine, per il Solo che perfettamente dimostrato eccellenza creativa
        — grazie.</p></div></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.id4725434" href="#id4725434">1</a>] </sup>Oh, e grazie a, Karl, per aver troppo da fare per poter
      scrivere da solo questo libro.</p></div></div></div><div class="chapter" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title"><a id="svn.intro"></a>Capitolo 1. Introduzione</h2></div></div></div><div class="toc"><p><b>Sommario</b></p><dl><dt><span class="sect1"><a href="#svn.intro.whatis">Cos'è Subversion?</a></span></dt><dt><span class="sect1"><a href="#svn.intro.history">La storia di Subversion</a></span></dt><dt><span class="sect1"><a href="#svn.intro.features">Le caratteristiche di Subversion</a></span></dt><dt><span class="sect1"><a href="#svn.intro.architecture">Architettura di Subversion</a></span></dt><dt><span class="sect1"><a href="#svn.intro.install">Installazione di Subversion</a></span></dt><dt><span class="sect1"><a href="#svn.intro.components">I Componenti di Subversion</a></span></dt><dt><span class="sect1"><a href="#svn.intro.quickstart">Un rapido inizio</a></span></dt></dl></div><div class="simplesect" lang="it" xml:lang="it"><div class="titlepage"></div><p>Il controllo di versione è l'arte di gestire i cambiamenti
      delle informazioni. Tale attività è stata per molto tempo uno
      strumento critico per i programmatori, che solitamente passano
      le loro giornate ad effettuare piccoli cambiamenti ad un software
      per poi cancellare i cambiamenti il giorno seguente. Ma l'utilità
      di un software di versionamento si estende ben fuori dai limiti
      del mondo dello sviluppo software. Ovunque è possibile incontrare
      persone che utilizzano il computer per gestire informazioni che 
      cambiano di frequente, lì trova spazio il controllo di versione.
      E qui entra in gioco Subversion.</p><p>Questo capitolo contiene un'introduzione di alto livello a 
      Subversion—cos'è; cosa fa; come ottenerlo.</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.intro.whatis"></a>Cos'è Subversion?</h2></div></div></div><p>Subversion è un sistema di controllo di versione libero e
      open-source. Cioè Subversion gestisce files e directories nel tempo.
      L'alberatura dei files è inserita all'interno di un <em class="firstterm">
      repository</em> centrale. Il repository è paragonabile
      ad un file server, in più esso ricorda qualsiasi cambiamento
      fatto ai files e alle directories. Ciò permette di ripristinare
      vecchie versioni o esaminare lo storico dei cambiamenti dei dati.
      Per questo motivo, molte persone pensano che un sistema di 
      versionamento assomigli ad una sorta di «<span class="quote">macchina del
      tempo</span>».</p><p>Subversion può accedere ai suoi repositories attraverso
      la rete; ciò gli permette di essere utilizzato da più persone
      contemporaneamente su più computers. In alcune circostanze,
      la possibilità per più persone di modificare e gestire lo
nebiac
      la possibilità per più persone di modificare e maneggiare lo
      stesso elenco di dati, ognuno dalle rispettive postazioni, 
      alimenta la collaborazione. Miglioramenti possono intervenire
      più velocemente se non tutte le modifiche devono per forza
      passare per un unico canale. E dato che il lavoro è sotto controllo,
      di versione non c'è da temere che la qualità sia il prezzo da 
      pagare—se vengono applicate alla data alcune modifiche 
      non corrette, basta annullare tali cambiamenti.</p><p>Alcuni sistemi per il controllo di versione sono anche
      sistemi 'software configuration management' (SCM). Questi 
nebiac
      sistemi di software configuration management (SCM). Questi 
      sistemi sono orientati specificatamente alla gestione di 
nebiac
      sistemi sono tagliati specificatamente alla gestione di 
      alberature di codice sorgente, e hanno molte caratteristiche
      che sono specifiche allo sviluppo software—come
      comprendere nativamente i linguaggi di programmazione o
      integrare strumenti per la compilazione del software.
      Subversion, tuttavia, non è uno di questi sistemi. E' un 
      sistema generale che può essere utilizzato per gestire 
      <span class="emphasis"><em>qualsiasi</em></span> insieme di files. Per qualcuno
      questi files possono contenere codice sorgente—per 
      altri qualunque cosa, dalla lista della spesa a montaggi video
      digitali, e così via.</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.intro.history"></a>La storia di Subversion</h2></div></div></div><p>All'inizio del 2000, CollabNet,
      Inc. (<a href="http://www.collab.net" target="_top">http://www.collab.net</a>) iniziò a cercare
      sviluppatori per scrivere un software che sostituisse CVS. 
      CollabNet offre una suite di software collaborativi chiamata
      CollabNet Enterprise Edition (CEE)
      <sup>[<a id="id4725936" href="#ftn.id4725936">2</a>]</sup>
      di cui un componente è il controllo di versione. Sebbene
      CEE usasse proprio CVS come suo  sistema di 
      versionamento iniziale, fin dall'inizio fu chiaro che tale software
nebiac (2 righe)
      CEE usasse proprio CVS come suo iniziale sistema di 
      versionamento, fin dall'inizio fu chiaro che tale software
      portava con se alcune limitazioni e CollabNet capì che 
      avrebbe dovuto trovare qualcosa di meglio.
      Sfortunatamente, CVS nel frattempo era ampiamente diventato 
      lo standard <span class="foreignphrase"><em class="foreignphrase">de facto</em></span> nel
      mondo dell'open source, poichè non c'è nulla di meglio, per
      lo meno non sotto una licenza free. Così CollabNet decise di
      di scrivere da zero un nuovo sistema per il controllo di 
      versione, mantenendo l'idea base di CVS, evitando i suoi bugs
      e aggiungendo features.</p><p>Nel febbraio del 2000, fu contattato Karl Fogel, l'autore 
      del libro <em class="citetitle">Sviluppare Open Source con CVS</em>
      (Coriolis, 1999), al quale fu chiesto se avesse avuto piacere
      di lavorare su questo nuovo progetto. Coincidenza volle che, 
      in quel periodo, Karl, stava già lavorando a un progetto per
      un nuovo sistema di versionamento con il suo amico Jim Blandy.
      Nel 1995, i due avevano fondato la Cyclic Software, una 
      compagnia che si occupava di stipulare contratti di supporto
      all'utilizzo di CVS, e sebbene più tardi essi cedettero la 
      loro attività, continuarono ancora ad utilizzare, per lavoro, 
      CVS ogni giorno. La loro frustrazione con CVS, condusse Jim a
      pensare seriamente ad un modo migliore per gestire dati 
      versionati; egli aveva già non solo ideato il nome
      «<span class="quote">Subversion</span>», ma anche la concezione base del
      repository. Quando CollabNet li contattò, Karl accettò
      immediatamente di lavorare su questo progetto, e Jim ottenne
      dalla sua azienda, la Red Hat Software, sostanzialmente di
      potersi dedicare al progetto a tempo indeterminato. CollabNet assunse
      Karl e Ben Collins-Sussman e il lavoro vero e proprio sul
      progetto inizio nel mese di maggio. Con l'aiuto di alcuni
      ben piazzati sostenitori, da Brian Behlendorf e Jason Robbins 
      of CollabNet, a Greg Stein (al tempo sviluppatore indipendente
      attivo nel processo di specifica di WebDAV/DeltaV), Subversion
      in breve tempo attrasse intorno a se una gruppo di attivi
      sviluppatori. Ciò dimostrava che molte persone avevano le 
      stesse frustranti esperienze con CVS, e accolsero con 
      entusiasmo la possibilità di fare finalmente qualcosa per 
      migliorarlo.</p><p>Il team di sviluppo originario si concentrò su alcuni 
      semplici obiettivi. Essi non volevano introdurre un nuovo
      approccio nella metodologia del controllo di versione, essi
      volevano solamente migliorare CVS. Decisero che Subversion
      avrebbe incluso le caratteristiche di CVS e preservato il
      medesimo modello di sviluppo, ma non avrebbe riproposto le
      sue più ovvie debolezze. E sebbene il loro software non avesse
      bisogno di presentarsi come una copia di CVS, sarebbe comunque
      dovuto essere abbastanza simile per permettere che qualsiasi
      utente di CVS, potesse cambiare e utilizzare Subversion con 
      pochissima fatica.</p><p>Dopo quattordici mesi passati a scrivere codice, 
      Subversion divenne «<span class="quote">autogestente (self-hosted)</span>» il 31 agosto 2001.
nebiac
      Subversion divenne «<span class="quote">self-hosted</span>» il 31 agosto 2001.
      Da quel momento, cioè, gli sviluppatori smisero di utilizzare 
      CVS per gestire il codice di Subversion e iniziarono ad 
      utilizzare Subversion stesso.</p><p>Mentre CollabNet iniziava il progetto e tuttora finanzia la
      maggior parte del lavoro (paga lo stipendio di un piccolo gruppo
      di sviluppatori che lavorano su Subversion a tempo pieno), Subversion 
      viene portato avanti come la maggior parte dei progetti open-source, 
      gestito attraverso un insieme di regole aperto e trasparente  che 
nebiac
      gestito attraverso un aperto e trasparente insieme di regole che 
      incoraggiano la meritocrazia. La licenza di copyright di CollabNet
      rispetta pienamente le linee guida Debian Free Software. In altre
      parole, chiunque è libero di scaricare, modificare e redistribuire 
      Subversion come preferisce; senza richiedere alcun permesso da 
      CollabNet o chiunque altro.</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.intro.features"></a>Le caratteristiche di Subversion</h2></div></div></div><p>Discutere delle caratteristiche che Subversion porta 
      al tavolo del controllo di versione, è spesso utile approfondire
      in che modo tali peculiarità apportino miglioramenti alla struttura
      di CVS. Se non si ha familiarità con CVS, si rischia di non 
      comprenderne a dovere l'efficacia. Se, poi, il lettore non ha 
      dimestichezza con il controllo di versione in generale, i suoi occhi
      potrebbero coprirsi di una patina a meno che non si legga prima 
      <a href="#svn.basic" title="Capitolo&#xA0;2.&#xA0;Basic Concepts">Capitolo 2, <i>Basic Concepts</i></a>, nel quale viene fornita una precisa
      introduzione al generale concetto di versionamento.</p><p>Subversion offre:</p><div class="variablelist"><dl><dt><span class="term">Versionamento delle directories</span></dt><dd><p>Solo CVS traccia la storia dei soli files, mentre
            Subversion implementa il versionamento di un filesystem 
            «<span class="quote">virtuale</span>» che traccia i cambiamenti nel tempo
            degli interi alberi directory. I files <span class="emphasis"><em>e</em></span> le
            directories vengono quindi versionati.</p></dd><dt><span class="term">La vera history di versione</span></dt><dd><p>Dal momento che CVS è limitato al versionamento dei 
            soli files, operazioni come copia e rinomina—che 
            dovrebbero essere propri dei files, ma che poi non sono
            altro che modifiche ai contenuti di ciò che contiene una
            directory—non sono supportate in CVS.
            In più, in CVS non è possibile rimpiazzare un file versionato
            con un nuovo file che ne erediti il nome ma non la
            storia—perchè completamente differente dal vecchio
            file. Con Subversion, è possibile aggiungere, cancellare,
            copiare e rinominare sia files che directories. E ogni file
            aggiunto nuovamente, inizia con una storia nuova e pulita
            tutta per se.</p></dd><dt><span class="term">Commits atomici</span></dt><dd><p>Un insieme di modifiche o vengono inserite nel repository
  	    tutte insieme o non ne viene inserita nessuna. Ciò permette agli 
  	    sviluppatori di costruire ed effettuare commit di cambiamenti come 
nebiac
  	    sviluppatori di costruire e committare i cambiamenti come 
 	    un blocco logico unico, prevenendo problemi che possono 
 	    occorrere quando solo una parte d'un insieme di modifiche 
nebiac
 	    occorrere quando solo una parte di un set di modifiche 
 	    vengono inviate con successo al repository.</p></dd><dt><span class="term">Versionamento dei metadata</span></dt><dd><p>
	  Ogni file e directory ha un set di proprietà—chiavi
	    e rispettivi valori—associati ad esso. L'utilizzatore
	    può creare e memorizzare qualsiasi coppia di chiave/valore 
	    che preferisce, arbitrariamente. Le proprietà sono
	    soggette a versionamento esattamente come il file a cui sono
	    associate.</p></dd><dt><span class="term">Tipologie di livelli di rete</span></dt><dd><p>Subversion ha una nozione astratta di accesso al
	    repository, che rende semplice per chiunque implementare 
	    nuovi meccanismi di rete. Inoltre è possibile 
	    integrarlo con Apache HTTP Server, come modulo di
	    estensione. Ciò conferisce a Subversion un grande 
	    vantaggio in stabilità e interoperabilità, oltrechè un
	    accesso istantaneo alle caratteristiche che tale webserver
	    mette a disposizione—autenticazione, autorizzazione,
	    wire compression, e così via. E' tuttavia disponibile 
            anche un processo server standalone proprio di Subversion
	    più leggero. Questo server è progettato su un protocollo 
	    proprio che può essere facilmente veicolato su SSH.</p></dd><dt><span class="term">Consistent data handling, </span><span class="term">Maneggiare dati consistenti</span></dt><dd><p>Subversion esprime le differenze di un file usando 
	    un algoritmo di differenziazione binario, che lavora
	    ugualmente sia sui files di testo (leggibili dall'uomo) 
	    che sui files binari (illeggibili dall'uomo). Entrambi
	    i tipi di files sono memorizzati ugualmente compressi
	    nel repository e le differenze sono trasmesse in 
	    entrambi i casi attraverso la rete.</p></dd><dt><span class="term">Efficiente metodo di branching e tagging</span></dt><dd><p>Il costo in termini di tempo e spazio dedicato al 
nebiac: direi di non mettere le doppie virgolette, cosa dici?
	   Il "costo" in termini di tempo e spazio dedicato al 
	    branching e al tagging non deve essere proporzionale 
	    alla grandezza del progetto. Subversion crea branches e 
  	    tags utilizzando un meccanismo simile all'hard-link unix 
	    (collegamento) per copiare il progetto. In questo modo, 
	    tali operazioni occupano solo una quantità di tempo 
	    molto piccolo e costante.
nebiac
	    molto breve e costante.
	    </p></dd><dt><span class="term">Versatilità</span></dt><dd><p>Subversion non ha alcun bagaglio storico; esso è 
	    implementato come una collezione di librerie C condivise
	    con delle APIs ben definite. Ciò lo rende estremamente 
	    manutenibile e usabile da altre applicazioni e in 
	    altre lingue.</p></dd></dl></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.intro.architecture"></a>Architettura di Subversion</h2></div></div></div><p><a href="#svn.intro.architecture.dia-1" title="Figura&#xA0;1.1.&#xA0;Architettura di Subversion">Figura 1.1, «Architettura di Subversion»</a>  illustra ciò che si può chiamare
      una vista «<span class="quote">dall'altezza di un miglio</span>» dell'architettura di Subversion.</p><div class="figure"><a id="svn.intro.architecture.dia-1"></a><p class="title"><b>Figura 1.1. Architettura di Subversion</b></p><div class="figure-contents"><div><img src="images/ch01dia1.png" alt="Architettura di Subversion" /></div></div></div><br class="figure-break" /><p>
    Ad un estremo c'è il repository Subversion che contiene tutti i vostri dati 
    sotto controllo di versione. All'altro estremo c'è il vostro client Subversion, 
    che gestisce le specchiature locali di parte dei dati sotto controllo 
    di versione (chiamate  «<span class="quote">copie locali</span>»). 
    Tra questi estremi vi sono diversi percorsi tramite vari strati per l'Accesso al Repository 
    (AR). Alcune di queste strade attraversano reti di computer e reti di server che che a loro volta 
    accedono il repository.  
    Altre scavalcano del tutto la rete ed accedono direttamente il repository.
    </p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.intro.install"></a>Installazione di Subversion</h2></div></div></div><p>
      Subversion è costruito su uno strato portabile chiamato APR—
      la libreria Apache Portable Runtime. La libreria APR fornisce tutte le interfaccie
      per le funzioni richieste da Subversion per funzionare su diversi sistemi operativi: 
      l'accesso al disco, alla rete, la gestione della memoria e così via.
      Anche se Subversion è in grado di utilizzare Apache come uno dei possibili componenti lato server, 
      la sua dipendenza da APR <span class="emphasis"><em>non</em></span> significa che Apache sia un 
      componente rihiesto per funzionare. Significa, comunque, che come Apache, i client
      ed i server di Subversion funzionano su ogni sistema operativo sul quale gira il server httpd Apache:
      Windows, Linux, tutte le varianti di BSD, MAc OS X, Netware ed altri.
      </p><p>
      Il modo più facile per ottenere Subversion è scaricare il pacchetto di eseguibili già pronto
      per il vostro sistema operativo.
      Il sito web di Subversion (<a href="http://subversion.tigris.org" target="_top">http://subversion.tigris.org</a>)
      rende disponibili questi pacchetti, preparati ed inviati da volontari.
      Il sito normalmente contiene pacchetti d'installazione grafici
      per gli utenti dei sistemi operativi Microsoft.
      Se siete utenti di un sistema operativo di tipo Unix, per ottenere Subversion potete utilizzare
      i sistemi di distribuzione nativi per il vostro sistema (RPMs. DEBs, ports tree, etc.).
     </p><p>
	Come alternativa, si può costruire Subversion direttamente dai codici sorgenti.
	Scaricate l'ultima release del codice sorgente dal sito web di Subversion.
	Dopo averlo spacchettato, seguite le istruzioni contenute nel file 
	<code class="filename">INSTALL</code> per costruirlo.
	Da notare che un pacchetto di sorgenti rilasciato, contiene tutto ciò di 
	cui si necessiti per costruire un client a linea di comando in grado di parlare con
	un repository remoto (in particolare, apr, apr-util, e le librerie neon).
	Ma parti opzionali di Subversion hanno molte altre dipendenze, come il DB Berkeley ed anche
	Apace httpd. 
	Se volete realizzare una costruzione completa, siate sicuri di avere tutti i pacchetti 
	descritti nel file <code class="filename">INSTALL</code>.
	Se avete intenzione di lavorare su Subversion stesso, potete utilizzare il client
	per ottenere l'ultima copia dei sorgenti allineata con la frontiera degli sviluppi.
      Ciò è documentato in <a href="#svn.developer.contrib.get-code" title="Get the Source Code">la sezione chiamata «Get the Source Code»</a>.
      </p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.intro.components"></a>I Componenti di Subversion</h2></div></div></div><div class="variablelist"><dl><dt><span class="term">svn</span></dt><dd><p>Il client a linea di comando.</p></dd><dt><span class="term">svnversion</span></dt><dd><p>Un programma per conoscere lo stato (in termini di 
            revisione degli elementi presenti) di una copia di lavoro.</p></dd><dt><span class="term">svnlook</span></dt><dd><p>Un tool per ispezionare una repository Subversion.</p></dd><dt><span class="term">svnadmin</span></dt><dd><p>Un tool per creare, operare e riparare una repository Subversion.</p></dd><dt><span class="term">svndumpfilter</span></dt><dd><p>Un programma per filtrare i flussi di dump di una repository Subversion.</p></dd><dt><span class="term">mod_dav_svn</span></dt><dd><p>Un modulo plug-in per il Server Apache HTTP, usato per rendere disponibile ad altri la 
            vostra repository via rete.</p></dd><dt><span class="term">svnserve</span></dt><dd><p>Un programma server specializzato per essere eseguito come un processo demone 
          oppure essere invocato tramite SSH; un altro modo per rendere accessibile via rete
          ad altri il vostro repository.</p></dd></dl></div><p>Assumendo di avere Subversion correttamente installato, dovreste essere pronti a partire.
    I prossimi due capitoli vi condurranno attraverso l'uso di <span><strong class="command">svn</strong></span> il client command line
    di Subversion.
    </p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.intro.quickstart"></a>Un rapido inizio</h2></div></div></div><p>Alcune persone hanno dei problemi ad assorbire una nuova tecnologia 
	tramite l'approccio «<span class="quote">top down</span>» di questo libro.  
	Questa sezione è un'introduzione a Subversion molto sintetica, ed è pensata per
	fornire una possibilità  in più a chi è abituato ad imparare con un approccio «<span class="quote">bottom up</span>».
	Se si preferisce imparare sperimentando, gli esempi seguenti vi permetteranno di essere
	subito operativi.
	Strada facendo, saranno evidenziati i collegamenti ai capitoli più importanti di questo libro.
        </p><p>Se per voi sono nuovi sia l'insieme dei concetti di controllo di versione, sia il modello
         «<span class="quote">copia-modifica-fusione (copy-modify-merge)</span>» usato sia da CVS che da Subversion, 
         allora dovreste leggere <a href="#svn.basic" title="Capitolo&#xA0;2.&#xA0;Basic Concepts">Capitolo 2, <i>Basic Concepts</i></a>
      prima di andare avanti.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Nota</h3><p>Il seguente esempio assume di avere  pronti all'uso <span><strong class="command">svn</strong></span>, il client a linea di comando di Subversion,
        e <span><strong class="command">svnadmin</strong></span>, il tool di amministrazione.  
        Si assume anche che stiate usando Subversion 1.2 o successivo
        (usare il comando <span><strong class="command">svn --version</strong></span> per controllare.)</p></div><p>Subversion memorizza tutti i dati sotto controllo di versione in un repository centrale. 
    Per iniziare, creiamo un nuovo repoitory:</p><pre class="screen">
$ svnadmin create /path/to/repos
$ ls /path/to/repos
conf/  dav/  db/  format  hooks/  locks/  README.txt
</pre><p>Questo comando crea una nuova directory
      <code class="filename">/path/to/repos</code> che contiene un repository Subversion.
      Questa nuova directory contiene (tra le altre cose) un insieme di files di database.
      Non vedreste i vostri file sotto il controllo di versione se provaste a sbirciarci dentro.
      Per maggiori informazioni riguardo la creazione e la manutenzione del repository, vedi anche
      <a href="#svn.reposadmin" title="Capitolo&#xA0;5.&#xA0;Repository Administration">Capitolo 5, <i>Repository Administration</i></a>.</p><p>Subversion non ha il concetto di «<span class="quote">progetto</span>».  
    Il repository è solo un filesystem virtuale versionato, un albero di directory molto vasto
    che può conservare ciò che si desidera. Alcuni sistemisti preferiscono memorizzare
    solo un progetto per repository alti memorizzano più progetti in un repository
    ponendoli in directory separate.
    I pregi di ogni approcci sono discussi in  <a href="#svn.reposadmin.projects.chooselayout" title="Choosing a Repository Layout">la sezione chiamata «Choosing a Repository Layout»</a>.
    Ad ogni modo il repository gestisce solo file e directory,
    in tal senso è copito degli umani interpretare le particolari directory,
    come «<span class="quote">projects</span>».  
    Per questo ogni qual volta in questo libro venga fatto riferimento ai progetti,
    si tenga presente che è come se si parlasse di directory (od insiemi di directories) nel
    repository.</p><p> In questo esempio,  si assume di avere una qualche sorta di progetto
    (un insieme di files e directories) che vorreste importare in un repository
    appena creato.
    Iniziamo organizzandoli in una sola directory chiamata <code class="filename">myproject</code> 
    (oppure un qualunque altro nome vi piaccia).
    Per ragioni che saranno chiare tra poco (vedi <a href="#svn.branchmerge" title="Capitolo&#xA0;4.&#xA0;Branching and Merging">Capitolo 4, <i>Branching and Merging</i></a>), 
    l'alberatura del vostro progetto dovrà  contenere tre directory di livello piu' alto
    chiamate <code class="filename">branches</code>,
      <code class="filename">tags</code>, and
      <code class="filename">trunk</code>.  La directory <code class="filename">trunk</code>
      conterrà tutti i vostri dati,
      mentre le directory <code class="filename">branches</code>
      e <code class="filename">tags</code> sono vuote:</p><pre class="screen">
/tmp/myproject/branches/
/tmp/myproject/tags/
/tmp/myproject/trunk/
                     foo.c
                     bar.c
                     Makefile
                     …
</pre><p>Le sottodirectory <code class="filename">branches</code>, <code class="filename">tags</code>,
      e <code class="filename">trunk</code> non sono in realta' richieste da Subversion
      Sono semplicemente una convenzione comune che molto probabilmente
      vorrete usare in seguito anche voi.</p><p>Non appena la vostra struttura di directory è pronta, importatela in una
        repository svn con il comando <span><strong class="command">svn import</strong></span> 
      (see <a href="#svn.tour.other.import" title="svn import">la sezione chiamata «<span><strong class="command">svn import</strong></span>»</a>):</p><pre class="screen">
$ svn import /tmp/myproject file:///path/to/repos/myproject -m "initial import"
Adding         /tmp/myproject/branches
Adding         /tmp/myproject/tags
Adding         /tmp/myproject/trunk
Adding         /tmp/myproject/trunk/foo.c
Adding         /tmp/myproject/trunk/bar.c
Adding         /tmp/myproject/trunk/Makefile
…
Committed revision 1.
$ 
</pre><p>Ora il repository contiene questa struttura di directory.  Come citato prima,
     non vedreste i vostri file sbirciando direttamente nel repository;
     sono tutti memorizzati all'interno di un database. Ma il filesystem immaginario
     del repository ora contiene una directory di livello più alto chiamata
      <code class="filename">myproject</code>, che contiene i vostri dati.</p><p>Notare che la directory originaria <code class="filename">/tmp/myproject</code>
      non e' cambiata; Subversion non lo sa.  (Infatti, potete anche cancellare quella
      directory se volete.)  Per essere in grado di iniziare a manipolare i dati nel repository,
      avete bisogno di creare una nuova «<span class="quote">copia di lavoro (working copy)</span>» dei dati, 
      una sorta di spazio di lavoro privato. 
      Domandate a Subversion di effettuare un  «<span class="quote">check out</span>» della copia di lavoro
      della directory <code class="filename">myproject/trunk</code> memorizzata nel repository:</p><pre class="screen">
$ svn checkout file:///path/to/repos/myproject/trunk myproject
A  myproject/foo.c
A  myproject/bar.c
A  myproject/Makefile
…
Checked out revision 1.
</pre><p>Ora avete una copia personale di parte del repository
    in una nuova directory chiamata <code class="filename">myproject</code>.  
    Potete modificare i files nella copia di lavoro e poi sottomettere a svn (commit)
    i cambiamenti nel repository.</p><div class="itemizedlist"><ul type="disc"><li><p>Entrare nella copia di lavoro e modificare il contento di un file.</p></li><li><p>Run <span><strong class="command">svn diff</strong></span> to see unified diff
          output of your changes.</p></li><li><p>Eseguire <span><strong class="command">svn commit</strong></span> per sottomettere a svn la nuova versione del vostro file nel repository.</p></li><li><p>Eseguire <span><strong class="command">svn update</strong></span> per «<span class="quote">allineare</span>» la vostra copia locale con il contenuto del repository.</p></li></ul></div><p>Per un tour completo riguado tutte le cose che si possono fare con la copia locale, 
    leggere <a href="#svn.tour" title="Capitolo&#xA0;3.&#xA0;Visita guidata">Capitolo 3, <i>Visita guidata</i></a>.</p><p> A questo punto, potete scegliere di rendere accessibile il vostro repository via rete.
    Consultare anche <a href="#svn.serverconfig" title="Capitolo&#xA0;6.&#xA0;Server Configuration">Capitolo 6, <i>Server Configuration</i></a> per imparare riguardo i diversi tipi di processi server disponibili 
      e come configurarli.</p></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.id4725936" href="#id4725936">2</a>] </sup>Ne esiste anche una versione chiamata CollabNet Team
        Edition (CTE) pensata per gruppi più piccoli.</p></div></div></div><div class="chapter" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title"><a id="svn.basic"></a>Capitolo 2. Basic Concepts</h2></div></div></div><div class="toc"><p><b>Sommario</b></p><dl><dt><span class="sect1"><a href="#svn.basic.repository">The Repository</a></span></dt><dt><span class="sect1"><a href="#svn.basic.vsn-models">Versioning Models</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.basic.vsn-models.problem-sharing">The Problem of File-Sharing</a></span></dt><dt><span class="sect2"><a href="#svn.basic.vsn-models.lock-unlock">The Lock-Modify-Unlock Solution</a></span></dt><dt><span class="sect2"><a href="#svn.basic.vsn-models.copy-merge">The Copy-Modify-Merge Solution</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.basic.in-action">Subversion in Action</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.basic.in-action.wc">Working Copies</a></span></dt><dt><span class="sect2"><a href="#svn.basic.in-action.revs">Revisions</a></span></dt><dt><span class="sect2"><a href="#svn.basic.in-action.track-repos">Come le copie di lavoro sono in relazione con il repository</a></span></dt><dt><span class="sect2"><a href="#svn.basic.in-action.mixedrevs">Copie di lavoro con revisioni miste</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.basic.in-action.mixedrevs.update-commit">Update e commit sono azioni separate</a></span></dt><dt><span class="sect3"><a href="#svn.basic.in-action.mixedrevs.normal">E' normale avere reivisioni mischiate</a></span></dt><dt><span class="sect3"><a href="#svn.basic.in-action.mixedrevs.useful">Le revisioni miste sono utili</a></span></dt><dt><span class="sect3"><a href="#svn.basic.in-action.mixedrevs.limits">Le revisioni miste hanno dei limiti</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.basic.summary">Sommario</a></span></dt></dl></div><div class="simplesect" lang="it" xml:lang="it"><div class="titlepage"></div><p>This chapter is a short, casual introduction to Subversion.
      If you're new to version control, this chapter is definitely for
      you.  We begin with a discussion of general version control
      concepts, work our way into the specific ideas behind
      Subversion, and show some simple examples of Subversion in
      use.</p><p>Even though the examples in this chapter show people sharing
      collections of program source code, keep in mind that Subversion
      can manage any sort of file collection—it's not limited to
      helping computer programmers.</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.basic.repository"></a>The Repository</h2></div></div></div><p>Subversion is a centralized system for sharing information.
      At its core is a repository, which is a central store of data.
      The repository stores information in the form of a
      <em class="firstterm">filesystem tree</em>—a typical hierarchy
      of files and directories.  Any number of
      <em class="firstterm">clients</em> connect to the repository, and
      then read or write to these files.  By writing data, a client
      makes the information available to others; by reading data, the
      client receives information from others.  <a href="#svn.basic.repository.dia-1" title="Figura&#xA0;2.1.&#xA0;A typical client/server system">Figura 2.1, «A typical client/server system»</a> illustrates this.</p><div class="figure"><a id="svn.basic.repository.dia-1"></a><p class="title"><b>Figura 2.1. A typical client/server system</b></p><div class="figure-contents"><div><img src="images/ch02dia1.png" alt="A typical client/server system" /></div></div></div><br class="figure-break" /><p>So why is this interesting?  So far, this sounds like the
      definition of a typical file server.  And indeed, the repository
      <span class="emphasis"><em>is</em></span> a kind of file server, but it's not your
      usual breed.  What makes the Subversion repository special is
      that <span class="emphasis"><em>it remembers every change</em></span> ever written
      to it: every change to every file, and even changes to the
      directory tree itself, such as the addition, deletion, and
      rearrangement of files and directories.</p><p>When a client reads data from the repository, it normally
      sees only the latest version of the filesystem tree.  But the
      client also has the ability to view
      <span class="emphasis"><em>previous</em></span> states of the filesystem.  For
      example, a client can ask historical questions like, «<span class="quote">What
      did this directory contain last Wednesday?</span>» or «<span class="quote">Who
      was the last person to change this file, and what changes did
      he make?</span>» These are the sorts of questions that are at
      the heart of any <em class="firstterm">version control system</em>:
      systems that are designed to record and track changes to data
      over time.
    </p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.basic.vsn-models"></a>Versioning Models</h2></div></div></div><p>The core mission of a version control system is to enable
      collaborative editing and sharing of data.  But different
      systems use different strategies to achieve this.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.basic.vsn-models.problem-sharing"></a>The Problem of File-Sharing</h3></div></div></div><p>All version control systems have to solve the same
        fundamental problem: how will the system allow users to share
        information, but prevent them from accidentally stepping on
        each other's feet?  It's all too easy for users to
        accidentally overwrite each other's changes in the
        repository.</p><p>Consider the scenario shown in <a href="#svn.basic.vsn-models.problem-sharing.dia-1" title="Figura&#xA0;2.2.&#xA0;The problem to avoid">Figura 2.2, «The problem to avoid»</a>.
        Suppose we have two co-workers, Harry and Sally.  They each
        decide to edit the same repository file at the same time.  If
        Harry saves his changes to the repository first, then it's
        possible that (a few moments later) Sally could accidentally
        overwrite them with her own new version of the file.  While
        Harry's version of the file won't be lost forever (because the
        system remembers every change), any changes Harry made
        <span class="emphasis"><em>won't</em></span> be present in Sally's newer version
        of the file, because she never saw Harry's changes to begin
        with.  Harry's work is still effectively lost—or at
        least missing from the latest version of the file—and
        probably by accident.  This is definitely a situation we want
        to avoid!</p><div class="figure"><a id="svn.basic.vsn-models.problem-sharing.dia-1"></a><p class="title"><b>Figura 2.2. The problem to avoid</b></p><div class="figure-contents"><div><img src="images/ch02dia2.png" alt="The problem to avoid" /></div></div></div><br class="figure-break" /></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.basic.vsn-models.lock-unlock"></a>The Lock-Modify-Unlock Solution</h3></div></div></div><p>Many version control systems use a
        <em class="firstterm">lock-modify-unlock</em> model to address the
        problem of many authors clobbering each other's work.  In this
        model, the repository allows only one person to change a file
        at a time.  This exclusivity policy is managed using locks.
        Harry must «<span class="quote">lock</span>» a file before he can begin
        making changes to it.  If Harry has locked a file, then Sally
        cannot also lock it, and therefore cannot make any changes to
        that file.  All she can do is read the file, and wait for
        Harry to finish his changes and release his lock.  After Harry
        unlocks the file, Sally can take her turn by locking and
        editing the file.  <a href="#svn.basic.vsn-models.lock-unlock.dia-1" title="Figura&#xA0;2.3.&#xA0;The lock-modify-unlock solution">Figura 2.3, «The lock-modify-unlock solution»</a>
        demonstrates this simple solution.</p><div class="figure"><a id="svn.basic.vsn-models.lock-unlock.dia-1"></a><p class="title"><b>Figura 2.3. The lock-modify-unlock solution</b></p><div class="figure-contents"><div><img src="images/ch02dia3.png" alt="The lock-modify-unlock solution" /></div></div></div><br class="figure-break" /><p>The problem with the lock-modify-unlock model is that it's
        a bit restrictive, and often becomes a roadblock for
        users:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Locking may cause administrative
            problems.</em></span>

            Sometimes Harry will lock a file and then forget about it.
            Meanwhile, because Sally is still waiting to edit the file,
            her hands are tied.  And then Harry goes on vacation.  Now
            Sally has to get an administrator to release Harry's lock.
            The situation ends up causing a lot of unnecessary delay
            and wasted time.</p></li><li><p><span class="emphasis"><em>Locking may cause unnecessary
            serialization.</em></span>

            What if Harry is editing the beginning of a text file,
            and Sally simply wants to edit the end of the same file?
            These changes don't overlap at all.  They could easily
            edit the file simultaneously, and no great harm would
            come, assuming the changes were properly merged together.
            There's no need for them to take turns in this
            situation.</p></li><li><p><span class="emphasis"><em>Locking may create a false sense of
            security.</em></span>

            Pretend that Harry locks and edits file A, while
            Sally simultaneously locks and edits file B.  But suppose
            that A and B depend on one another, and the changes made
            to each are semantically incompatible.  Suddenly A and B
            don't work together anymore.  The locking system was
            powerless to prevent the problem—yet it somehow
            provided a false sense of security.  It's easy for Harry and
            Sally to imagine that by locking files, each is beginning a
            safe, insulated task, and thus not bother
            discussing their incompatible changes early
            on.</p></li></ul></div></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.basic.vsn-models.copy-merge"></a>The Copy-Modify-Merge Solution</h3></div></div></div><p>Subversion, CVS, and other version control systems use a
        <em class="firstterm">copy-modify-merge</em> model as an
        alternative to locking.  In this model, each user's client
        contacts the project repository and creates a personal
        <em class="firstterm">working copy</em>—a local reflection
        of the repository's files and directories.  Users then work in
        parallel, modifying their private copies.  Finally, the
        private copies are merged together into a new, final version.
        The version control system often assists with the merging, but
        ultimately a human being is responsible for making it happen
        correctly.</p><p>Here's an example.  Say that Harry and Sally each create
        working copies of the same project, copied from the
        repository.  They work concurrently, and make changes to the
        same file A within their copies.  Sally saves her changes to
        the repository first.  When Harry attempts to save his changes
        later, the repository informs him that his file A is
        <em class="firstterm">out-of-date</em>.  In other words, that file
        A in the repository has somehow changed since he last copied
        it.  So Harry asks his client to <em class="firstterm">merge</em>
        any new changes from the repository into his working copy of
        file A.  Chances are that Sally's changes don't overlap with
        his own; so once he has both sets of changes integrated, he
        saves his working copy back to the repository.  <a href="#svn.basic.vsn-models.copy-merge.dia-1" title="Figura&#xA0;2.4.&#xA0;The copy-modify-merge solution">Figura 2.4, «The copy-modify-merge solution»</a> and <a href="#svn.basic.vsn-models.copy-merge.dia-2" title="Figura&#xA0;2.5.&#xA0;The copy-modify-merge solution (continued)">Figura 2.5, «The copy-modify-merge solution (continued)»</a>
        show this process.</p><div class="figure"><a id="svn.basic.vsn-models.copy-merge.dia-1"></a><p class="title"><b>Figura 2.4. The copy-modify-merge solution</b></p><div class="figure-contents"><div><img src="images/ch02dia4.png" alt="The copy-modify-merge solution" /></div></div></div><br class="figure-break" /><div class="figure"><a id="svn.basic.vsn-models.copy-merge.dia-2"></a><p class="title"><b>Figura 2.5. The copy-modify-merge solution (continued)</b></p><div class="figure-contents"><div><img src="images/ch02dia5.png" alt="The copy-modify-merge solution (continued)" /></div></div></div><br class="figure-break" /><p>But what if Sally's changes <span class="emphasis"><em>do</em></span> overlap
        with Harry's changes?  What then?  This situation is called a
        <em class="firstterm">conflict</em>, and it's usually not much of
        a problem.  When Harry asks his client to merge the latest
        repository changes into his working copy, his copy of file A
        is somehow flagged as being in a state of conflict: he'll be
        able to see both sets of conflicting changes, and manually
        choose between them.  Note that software can't automatically
        resolve conflicts; only humans are capable of understanding
        and making the necessary intelligent choices.  Once Harry has
        manually resolved the overlapping changes—perhaps after
        a discussion with Sally—he can safely save the
        merged file back to the repository.</p><p>The copy-modify-merge model may sound a bit chaotic, but
        in practice, it runs extremely smoothly.  Users can work in
        parallel, never waiting for one another.  When they work on
        the same files, it turns out that most of their concurrent
        changes don't overlap at all; conflicts are infrequent.  And
        the amount of time it takes to resolve conflicts is far less
        than the time lost by a locking system.</p><p>In the end, it all comes down to one critical factor: user
        communication.  When users communicate poorly, both syntactic
        and semantic conflicts increase.  No system can force users to
        communicate perfectly, and no system can detect semantic
        conflicts.  So there's no point in being lulled into a false
        promise that a locking system will somehow prevent conflicts;
        in practice, locking seems to inhibit productivity more than
        anything else.</p><div class="sidebar"><a id="svn.basic.vsn-models.copy-merge.sb-1"></a><p class="title"><b>When Locking is Necessary</b></p><p>While the lock-modify-unlock model is considered
          generally harmful to collaboration, there are still times
          when locking is appropriate.</p><p>The copy-modify-merge model is based on the assumption
          that files are contextually mergeable: that is, that the
          majority of the files in the repository are line-based text
          files (such as program source code).  But for files with
          binary formats, such as artwork or sound, it's often
          impossible to merge conflicting changes.  In these
          situations, it really is necessary to users to take strict
          turns when changing the file.  Without serialized access,
          somebody ends up wasting time on changes that are ultimately
          discarded.</p><p>While CVS and Subversion are still primarily
          copy-modify-merge systems, they both recognize the need to
          lock an occasional file and provide mechanisms for this.
          See <a href="#svn.advanced.locking" title="Locking">la sezione chiamata «Locking»</a>.</p></div></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.basic.in-action"></a>Subversion in Action</h2></div></div></div><p>It's time to move from the abstract to the concrete.  In
      this section, we'll show real examples of Subversion being
      used.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.basic.in-action.wc"></a>Working Copies</h3></div></div></div><p>You've already read about working copies; now we'll
        demonstrate how the Subversion client creates and uses
        them.</p><p>A Subversion working copy is an ordinary directory tree on
        your local system, containing a collection of files.  You can
        edit these files however you wish, and if they're source code
        files, you can compile your program from them in the usual
        way.  Your working copy is your own private work area:
        Subversion will never incorporate other people's changes, nor
        make your own changes available to others, until you
        explicitly tell it to do so.  You can even have multiple
        working copies of the same project.</p><p>After you've made some changes to the files in your
        working copy and verified that they work properly, Subversion
        provides you with commands to «<span class="quote">publish</span>» your
        changes to the other people working with you on your project
        (by writing to the repository).  If other people publish their
        own changes, Subversion provides you with commands to merge
        those changes into your working directory (by reading from the
        repository).</p><p>A working copy also contains some extra files, created and
        maintained by Subversion, to help it carry out these commands.
        In particular, each directory in your working copy contains a
        subdirectory named <code class="filename">.svn</code>, also known as
        the working copy <em class="firstterm">administrative
        directory</em>.  The files in each administrative
        directory help Subversion recognize which files contain
        unpublished changes, and which files are out-of-date with
        respect to others' work.</p><p>A typical Subversion repository often holds the files (or
        source code) for several projects; usually, each project is a
        subdirectory in the repository's filesystem tree.  In this
        arrangement, a user's working copy will usually correspond to
        a particular subtree of the repository.</p><p>For example, suppose you have a repository that contains
        two software projects, <code class="literal">paint</code> and
        <code class="literal">calc</code>.  Each project lives in its own
        top-level subdirectory, as shown in <a href="#svn.basic.in-action.wc.dia-1" title="Figura&#xA0;2.6.&#xA0;The repository's filesystem">Figura 2.6, «The repository's filesystem»</a>.</p><div class="figure"><a id="svn.basic.in-action.wc.dia-1"></a><p class="title"><b>Figura 2.6. The repository's filesystem</b></p><div class="figure-contents"><div><img src="images/ch02dia6.png" alt="The repository's filesystem" /></div></div></div><br class="figure-break" /><p>To get a working copy, you must <em class="firstterm">check
        out</em> some subtree of the repository.  (The term
        «<span class="quote">check out</span>» may sound like it has something to do
        with locking or reserving resources, but it doesn't; it simply
        creates a private copy of the project for you.) For example,
        if you check out <code class="filename">/calc</code>, you will get a
        working copy like this:</p><pre class="screen">
$ svn checkout http://svn.example.com/repos/calc
A    calc/Makefile
A    calc/integer.c
A    calc/button.c
Checked out revision 56.

$ ls -A calc
Makefile  integer.c  button.c  .svn/
</pre><p>The list of letter A's indicates that Subversion is adding
        a number of items to your working copy.  You now have a
        personal copy of the repository's <code class="filename">/calc</code>
        directory, with one additional
        entry—<code class="filename">.svn</code>—which holds the
        extra information needed by Subversion, as mentioned
        earlier.</p><div class="sidebar"><a id="svn.basic.in-action.wc.sb-1"></a><p class="title"><b>Repository URLs</b></p><p>Subversion repositories can be accessed through many
          different methods—on local disk, or through various
          network protocols.  A repository location, however, is
          always a URL.  <a href="#svn.basic.in-action.wc.tbl-1" title="Tabella&#xA0;2.1.&#xA0;Repository Access URLs">Tabella 2.1, «Repository Access URLs»</a> describes how
          different URL schemas map to the available access methods.</p><div class="table"><a id="svn.basic.in-action.wc.tbl-1"></a><p class="title"><b>Tabella 2.1. Repository Access URLs</b></p><div class="table-contents"><table summary="Repository Access URLs" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Schema</th><th>Access Method</th></tr></thead><tbody><tr><td><code class="literal">file:///</code></td><td>direct repository access (on local disk)</td></tr><tr><td><code class="literal">http://</code></td><td>access via WebDAV protocol to Subversion-aware
                  Apache server</td></tr><tr><td><code class="literal">https://</code></td><td>same as <code class="literal">http://</code>, but with
                  SSL encryption.</td></tr><tr><td><code class="literal">svn://</code></td><td>access via custom protocol to an
                  <code class="literal">svnserve</code> server</td></tr><tr><td><code class="literal">svn+ssh://</code></td><td>same as <code class="literal">svn://</code>, but through
                  an SSH tunnel.</td></tr></tbody></table></div></div><br class="table-break" /><p>For more information on how Subversion parses URLs, see
        <a href="#svn.advanced.reposurls" title="Subversion Repository URLs">la sezione chiamata «Subversion Repository URLs»</a>.</p></div><p>Suppose you make changes to <code class="filename">button.c</code>.
        Since the <code class="filename">.svn</code> directory remembers the
        file's modification date and original contents, Subversion can
        tell that you've changed the file.  However, Subversion does
        not make your changes public until you explicitly tell it to.
        The act of publishing your changes is more commonly known as
        <em class="firstterm">committing</em> (or <em class="firstterm">checking
        in</em>) changes to the repository.</p><p>To publish your changes to others, you can use
        Subversion's <span><strong class="command">commit</strong></span> command:</p><pre class="screen">
$ svn commit button.c
Sending        button.c
Transmitting file data .
Committed revision 57.
</pre><p>Now your changes to <code class="filename">button.c</code> have
        been committed to the repository; if another user checks out a
        working copy of <code class="filename">/calc</code>, they will see
        your changes in the latest version of the file.</p><p>Suppose you have a collaborator, Sally, who checked out a
        working copy of <code class="filename">/calc</code> at the same time
        you did.  When you commit your change to
        <code class="filename">button.c</code>, Sally's working copy is left
        unchanged; Subversion only modifies working copies at the
        user's request.</p><p>To bring her project up to date, Sally can ask
        Subversion to <em class="firstterm">update</em> her working copy,
        by using the Subversion <span><strong class="command">update</strong></span> command.
        This will incorporate your changes into her working copy, as
        well as any others that have been committed since she checked
        it out.</p><pre class="screen">
$ pwd
/home/sally/calc

$ ls -A 
.svn/ Makefile integer.c button.c

$ svn update
U    button.c
Updated to revision 57.
</pre><p>The output from the <span><strong class="command">svn update</strong></span> command
        indicates that Subversion updated the contents of
        <code class="filename">button.c</code>.  Note that Sally didn't need to
        specify which files to update; Subversion uses the information
        in the <code class="filename">.svn</code> directory, and further
        information in the repository, to decide which files need to
        be brought up to date.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.basic.in-action.revs"></a>Revisions</h3></div></div></div><p>An <span><strong class="command">svn commit</strong></span> operation can publish
        changes to any number of files and directories as a single
        atomic transaction.  In your working copy, you can change
        files' contents, create, delete, rename and copy files and
        directories, and then commit the complete set of changes as a
        unit.</p><p>In the repository, each commit is treated as an atomic
        transaction: either all the commit's changes take place, or
        none of them take place.  Subversion tries to retain this
        atomicity in the face of program crashes, system crashes,
        network problems, and other users' actions.</p><p>Each time the repository accepts a commit, this creates a
        new state of the filesystem tree, called a
        <em class="firstterm">revision</em>.  Each revision is assigned a
        unique natural number, one greater than the number of the
        previous revision.  The initial revision of a freshly created
        repository is numbered zero, and consists of nothing but an
        empty root directory.</p><p><a href="#svn.basic.in-action.revs.dia-1" title="Figura&#xA0;2.7.&#xA0;The repository">Figura 2.7, «The repository»</a> illustrates a nice way to
        visualize the repository.  Imagine an array of revision
        numbers, starting at 0, stretching from left to right.  Each
        revision number has a filesystem tree hanging below it, and
        each tree is a «<span class="quote">snapshot</span>» of the way the
        repository looked after a commit.</p><div class="figure"><a id="svn.basic.in-action.revs.dia-1"></a><p class="title"><b>Figura 2.7. The repository</b></p><div class="figure-contents"><div><img src="images/ch02dia7.png" alt="The repository" /></div></div></div><br class="figure-break" /><div class="sidebar"><p class="title"><b>Global Revision Numbers</b></p><p>Unlike those of many other version control systems,
          Subversion's revision numbers apply to <span class="emphasis"><em>entire
          trees</em></span>, not individual files.  Each revision
          number selects an entire tree, a particular state of the
          repository after some committed change.  Another way to
          think about it is that revision N represents the state of
          the repository filesystem after the Nth commit.  When
          Subversion users talk about «<span class="quote">revision 5 of
          <code class="filename">foo.c</code></span>», they really mean
          «<span class="quote"><code class="filename">foo.c</code> as it appears in revision
          5.</span>» Notice that in general, revisions N and M of a
          file do <span class="emphasis"><em>not</em></span> necessarily differ!  Because
          CVS uses per-file revision numbers, CVS users might want to
          see <a href="#svn.forcvs" title="Appendice&#xA0;A.&#xA0;Subversion for CVS Users">Appendice A, <i>Subversion for CVS Users</i></a> for more details.</p></div><p>It's important to note that working copies do not always
        correspond to any single revision in the repository; they may
        contain files from several different revisions.  For example,
        suppose you check out a working copy from a repository whose
        most recent revision is 4:</p><pre class="screen">
calc/Makefile:4
     integer.c:4
     button.c:4
</pre><p>At the moment, this working directory corresponds exactly
        to revision 4 in the repository.  However, suppose you make a
        change to <code class="filename">button.c</code>, and commit that
        change.  Assuming no other commits have taken place, your
        commit will create revision 5 of the repository, and your
        working copy will now look like this:</p><pre class="screen">
calc/Makefile:4
     integer.c:4
     button.c:5
</pre><p>Suppose that, at this point, Sally commits a change to
        <code class="filename">integer.c</code>, creating revision 6.  If you
        use <span><strong class="command">svn update</strong></span> to bring your working copy
        up to date, then it will look like this:</p><pre class="screen">
calc/Makefile:6
     integer.c:6
     button.c:6
</pre><p>Sally's change to <code class="filename">integer.c</code> will
        appear in your working copy, and your change will still be
        present in <code class="filename">button.c</code>.  In this example,
        the text of <code class="filename">Makefile</code> is identical in
        revisions 4, 5, and 6, but Subversion will mark your working
        copy of <code class="filename">Makefile</code> with revision 6 to
        indicate that it is still current.  So, after you do a clean
        update at the top of your working copy, it will generally
        correspond to exactly one revision in the repository.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.basic.in-action.track-repos"></a>Come le copie di lavoro sono in relazione con il repository</h3></div></div></div><p>Per ogni file nella direcotory di lavoro, Subversion registra due porzioni di informazione essenziali nell' area di amministrazione <code class="filename">.svn/</code> :</p><div class="itemizedlist"><ul type="disc"><li><p>il numero di revisione su cui è basata la copia di lavoro  (detta <em class="firstterm">revisione di lavoro</em> del file), e </p></li><li><p>una marca temporale relativa a quando la copia locale è stata aggiornata con il repository</p></li></ul></div><p>Date queste informazioni, comunicando con il repository, Subversion può decidere in quale dei seguenti quattro stati si trova un file nella copia di lavoro: </p><div class="variablelist"><dl><dt><span class="term">Non modificato e aggiornato</span></dt><dd><p>Il file non è stato modificato nella directory di lavoro e nessun cambiamento è stato sottomesso al repository dalla sua revisione di lavoro. 
              Un comando <span><strong class="command">svn commit</strong></span> del file non farà nulla, e un comando <span><strong class="command">svn update</strong></span> del file non farà nulla.</p></dd><dt><span class="term">Localmente modificato e aggiornato</span></dt><dd><p>Il file è stato modificato nella directory di lavoro, e nessun cambiamento è stato sottomesso al repository dalla sua revisione di lavoro.
              Ci sono delle modifiche locali che devono essere salvate sul repository, quindi un <span><strong class="command">svn commit</strong></span> 
              del file pubblicherà con successo le modifiche, e un <span><strong class="command">svn update</strong></span> del file non farà nulla.</p></dd><dt><span class="term">Non modificato e scaduto</span></dt><dd><p>Il file non è stato modificato nella directory di lavoro, me ha subito dei cambiamenti nel repository.
            Il file dovrebbe essere aggiornato per renderlo sincronizzato con l'attuale revisione pubblica.
              Un <span><strong class="command">svn commit</strong></span> del file non farà nulla, 
              e un <span><strong class="command">svn commit</strong></span> del file caricherà gli ultimi cambiamenti nella copia di lavoro.</p></dd><dt><span class="term">Localmente modificato e scaduto</span></dt><dd><p>Il file è stato cambiato sia nella directory di lavoro, sia nel repository. Un comando <span><strong class="command">svn commit</strong></span>
              del file fallirà con un errore di «<span class="quote">out-of-date</span>». Il file dovrebbe prima essere aggoirnato; un comando <span><strong class="command">svn update</strong></span> tenterà di incorporare le modifiche pubbliche con le modifiche locali. 
              Se Subversion non può completare la fusione automatica in un modo coerente, lascerà all'utente il compito di risolvere il conflitto.  
             </p></dd></dl></div><p>Potrebbe sembrare eccessivo tenter tracca di tutto questo, ma il comando <span><strong class="command">svn status</strong></span> mostrerà la stato di ogni elemento nella copia di lavoro.
        Per altre informazioni su questo comando, si veda <a href="#svn.tour.cycle.examine.status" title="svn status">la sezione chiamata «<span><strong class="command">svn status</strong></span>»</a>.
      </p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.basic.in-action.mixedrevs"></a>Copie di lavoro con revisioni miste</h3></div></div></div><p>Come principio generale, Subversion vuole essere il più flessibile possibile. Una particolare flessibilità deriva dalla possibilità
        di avere una copia di lavoro contenente file e directory con un MIX di differenti numeri di revisione. 
        Sfortunatamente questa flessibilità tende a confondere alcuni utenti. Segue quindi un'introduzione sul perchè esiste questa caratteristica e su come utilizzarla.
      </p><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.basic.in-action.mixedrevs.update-commit"></a>Update e commit sono azioni separate</h4></div></div></div><p>Una delle regole fondamentali di Subversion è che un'azione di «<span class="quote">invio</span>» non causa una «<span class="quote">ricezione</span>», nè viceversa.
          Il fatto che ci siano le condizioni per inviare nuove modifiche al repository non significa che si sia pronti per ricevere quelle apportate dagli altri utenti.
          Se si sta lavorando a delle modifiche, il comando <span><strong class="command">svn update</strong></span> deve integrare le eventali modifiche avvenute sul repository
          in quelle sui cui si sta lavroando, piuttosto che forzare a pubblicarle. 
           
        </p><p>La conseguenza principale di questa regola è che implica che una copia di lavoro deve fare un lavoro in più per tener traccia 
        delle diverse revisioni, e deve anche tollerare le le diversità stesse. Ciò inoltre è reso più complicato dal fatto che anche le directory stesse sono versionate. 
        </p><p>Ad esempio, si suppone di avere una copia di lavoro completamente allineata alla revisione 10. Il file <code class="filename">foo.html</code>
          viene modificato e successivamente viene eseguito un <span><strong class="command">svn commit</strong></span> il quale crea la revisione numero 15 nel repository. 
          Visto l'esito positivo del comando di commit, molti utenti potrebbero pensare che la copia di lavorazione sia interamente allineata con la revisione 15, ma non è cosiì! 
          Molti cambiamenti potrebbero essersi verificati nel repository tra la revisione 10 e la 15. Il client non sa nulla di questi cambiamenti in quanto
          non si è ancora eseguito il comando <span><strong class="command">svn update</strong></span>, e il comando <span><strong class="command">svn commit</strong></span> non riceve nessun cambiamento.
          D'altronde, se il comando <span><strong class="command">svn commit</strong></span> scaricasse automaticamente le nuove modifiche dal repository, allora sarebbe possibile 
          allineare tutta la copia di lavoro alla revisone 15— ma si verrebbe così ad infrangere la regola fondamentale che impone a "PUSH" E "PULL"
          di essere azioni separate. Quindi l'unica cosa sicura che il client di Subversion può fare è ricordare che il file — <code class="filename">foo.html</code>— 
          è della revisione 15. Il resto della copia di lavorazione rimane alla revisione 10. Solo eseguendo un <span><strong class="command">svn update</strong></span> si possono scaricare 
          gli utlimissim cambiamenti, e tutta la copia di lavorazione sarà contrassegnata alla revisone 15.
        </p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.basic.in-action.mixedrevs.normal"></a>E' normale avere reivisioni mischiate</h4></div></div></div><p>Di fatto <span class="emphasis"><em>ogni volta</em></span> che si esegue il comando <span><strong class="command">svn commit</strong></span>
            la copia di lavorazione si viene a trovare in un insieme misto di revisioni. Gli elementi che sono appena stati inviati al repository avranno 
            la revisione di lavorazione più alta di ogni altro. Dopo diversi commit (senza operazioni di aggiornamento intermedie) la copia di lavorazione 
            conterrà una vasta combinazione di revisioni. Anche se una sola persona sta usando il repository, si continuerà a verficare questo fenomeno.
            Per esaminare la miscela delle revisioni di lavorazione, si può usare il comando <span><strong class="command">svn status --verbose</strong></span> 
            (per maggiori informazioni vedere <a href="#svn.tour.cycle.examine.status" title="svn status">la sezione chiamata «<span><strong class="command">svn status</strong></span>»</a>).
          </p><p>
            Spesso i nuovi utenti ignorano completamente che la loro copia di lavorazione contiene diverse revisioni. Ciò può generare confusione,
            perchè molti comandi sono sensibili alla revisione di lavorazione degli oggetti che devono esminare. Per esempio, il comando <span><strong class="command">svn log</strong></span>
            viene utilizzato per mostrare la storia dei cambiamenti di un file o una directory (vedere <a href="#svn.tour.history.log" title="svn log">la sezione chiamata «<span><strong class="command">svn log</strong></span>»</a>).
            Quando un utente invoca questo comando sulla copia di lavorazione di un oggetto, si aspetta di vedere l'intera storia dell'oggetto stesso. 
            In realtà se la revisione di lavorazione è puittosto vecchia (solitamente perchè non si è usato il comando <span><strong class="command">svn update</strong></span> da molto tempo), 
            allora viene mostrata la storia della <span class="emphasis"><em>precedente</em></span> versione dell'oggetto.
            
          </p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.basic.in-action.mixedrevs.useful"></a>Le revisioni miste sono utili</h4></div></div></div><p>Se il progetto è piuttosto complesso, a volte è meglio forzare alcune porzioni della copia di lavorazione a «<span class="quote">retrocedere</span>» a versioni precedenti;
            nel Capitolo 3 si potrà vedere come fare. Si potrebbe voler testare una versione precedete di qualche componente contenuta in una sotto directory; 
            oppure si vorrebbe capire quando un bug è comparso per la prima volta in un certo file. Questo è l'aspetto di un sistema di controllo delle versioni 
            che lo caratterizza come una «<span class="quote">macchina del tempo</span>» — questa è caratteristica che permette di muovere ogni porzione della copia di lavorazione
            avanti e indietro nella storia.
          </p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.basic.in-action.mixedrevs.limits"></a>Le revisioni miste hanno dei limiti</h4></div></div></div><p>Qualunque uso si faccia delle revisioni miste nella copia di lavorazione, ci sono sempre delle limitazioni a questa flessibilità.</p><p>Primo, non si può effettuare la commit della cancellazione di un file o directory che non sia completamente aggiornato.
          Se nel repository esiste una versione più recente, il tentativo di elimnazione verrà rifiutato, per evitare la distruzione accidentale 
          di modifiche che non si sono ancora viste.</p><p>Secondo, non è possibile effettuare la commit della modifica di un metadato su una directory senza che questa 
            sia completamente aggiornata. Nel capitolo 6 si imparerà ad assegnare le «<span class="quote">proprietà</span>» agli oggetti.
            La revisione di lavorazione di una directory definisce un insieme specifico di voci e proprietà, quindi effettuare la commit della modifica di una proprietà
            a una directory non aggiornata potrebbe distruggere qualche proprietà che non è ancora stata vista.
          </p></div></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.basic.summary"></a>Sommario</h2></div></div></div><p>In questo capitolo si sono affrontati alcuni concetti fondamentali di Subversion:</p><div class="itemizedlist"><ul type="disc"><li><p>Si sono introdotte le nozioni di repository centrale, copia di lavorazione e serie di alberi di revisione.</p></li><li><p>Si è visto qualche semplice esempio di come due collaboratori possono usare Subversion per pubblicare e ricevere
          le modifiche da uno all'altro secono il modello «<span class="quote">copia-modifica-integra</span>».        
        </p></li><li><p>Si è parlato di come Subversion traccia e gestisce le informazioni in una copia di lavorazione</p></li></ul></div><p>A questo punto, si dovrebbe avere una buona idea di come lavora Subversion nel senso più generale.
      Dotati di questa conoscenza si dovrebbe essere ora pronti a passare al prossimo capitolo, che rappresenta una visita dettagliata dei comandi e delle caratteristiche
      di Subversion.
    </p></div></div><div class="chapter" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title"><a id="svn.tour"></a>Capitolo 3. Visita guidata</h2></div></div></div><div class="toc"><p><b>Sommario</b></p><dl><dt><span class="sect1"><a href="#svn.tour.help">Help!</a></span></dt><dt><span class="sect1"><a href="#svn.tour.import">Import</a></span></dt><dt><span class="sect1"><a href="#svn.tour.revs">Revisioni:Numeri,Chiavi e Date, Accidenti</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.tour.revs.numbers">Numeri di revisione</a></span></dt><dt><span class="sect2"><a href="#svn.tour.revs.keywords">Chiavi per le Revisioni</a></span></dt><dt><span class="sect2"><a href="#svn.tour.revs.dates">Date di revisione</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.tour.initial">Checkout iniziale</a></span></dt><dt><span class="sect1"><a href="#svn.tour.cycle">Basic Work Cycle</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.tour.cycle.update">Update Your Working Copy</a></span></dt><dt><span class="sect2"><a href="#svn.tour.cycle.edit">Make Changes to Your Working Copy</a></span></dt><dt><span class="sect2"><a href="#svn.tour.cycle.examine">Examine Your Changes</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.tour.cycle.examine.status"><span><strong class="command">svn status</strong></span></a></span></dt><dt><span class="sect3"><a href="#svn.tour.cycle.examine.diff"><span><strong class="command">svn diff</strong></span></a></span></dt><dt><span class="sect3"><a href="#svn.tour.cycle.examine.revert"><span><strong class="command">svn revert</strong></span></a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.tour.cycle.resolve">Resolve Conflicts (Merging Others' Changes)</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.tour.cycle.resolve.byhand">Merging Conflicts by Hand</a></span></dt><dt><span class="sect3"><a href="#svn.tour.cycle.resolve.copyover">Copying a File Onto Your Working File</a></span></dt><dt><span class="sect3"><a href="#svn.tour.cycle.resolve.revert">Punting: Using <span><strong class="command">svn revert</strong></span></a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.tour.cycle.commit">Commit Your Changes</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.tour.history">Examining History</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.tour.history.log"><span><strong class="command">svn log</strong></span></a></span></dt><dt><span class="sect2"><a href="#svn.tour.history.diff"><span><strong class="command">svn diff</strong></span></a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.tour.history.diff.local">Examining Local Changes</a></span></dt><dt><span class="sect3"><a href="#svn.tour.history.diff.wcrepos">Comparing Working Copy to Repository</a></span></dt><dt><span class="sect3"><a href="#svn.tour.history.diff.reposrepos">Comparing Repository to Repository</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.tour.history.cat"><span><strong class="command">svn cat</strong></span></a></span></dt><dt><span class="sect2"><a href="#svn.tour.history.list"><span><strong class="command">svn list</strong></span></a></span></dt><dt><span class="sect2"><a href="#svn.tour.history.finalword">A Final Word on History</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.tour.other">Other Useful Commands</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.tour.other.cleanup"><span><strong class="command">svn cleanup</strong></span></a></span></dt><dt><span class="sect2"><a href="#svn.tour.other.import"><span><strong class="command">svn import</strong></span></a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.tour.summary">Summary</a></span></dt></dl></div><div class="simplesect" lang="it" xml:lang="it"><div class="titlepage"></div><p>
      Entriamo nei dettagli dell'utilizzo di Subversion. Alla fine
      di questo capitolo, sarete  in grado di compiere al meglio tutte
      le attività di cui si ha bisogno per utilizzare Subversion in un normale
      giorno di lavoro.      
      La prima cosa da fare è il checkout del proprio
      codice, per poi procedere effettuando modifiche ed esaminando i cambiamenti.
      Si imparerà  anche ad importare cambiamenti fatti da altri nella propria directory di lavoro,
      ad esaminarli ed a risolvere qualsiasi tipo di conflitto  possa nascere.
    </p><p>
      Questo capitolo non vuole essere un elenco esaustivo di tutti
      i comandi di Subversion — quanto piuttosto un'introduzione alle più comuni attività
      che si possono compiere con Subversion. Si assume che si sia stato letto e compreso
      <a href="#svn.basic" title="Capitolo&#xA0;2.&#xA0;Basic Concepts">Capitolo 2, <i>Basic Concepts</i></a> e che si abbia familiarità  con il modello di Subversion.
      Per un riferimento completo a tutti i comandi si rimanda a <a href="#svn.ref" title="Capitolo&#xA0;9.&#xA0;Subversion Complete Reference">Capitolo 9, <i>Subversion Complete Reference</i></a>.
    </p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.tour.help"></a>Help!</h2></div></div></div><p>
      Prima di andare oltre, segue uno dei comando più importanti di cui si ha bisogno
      quando si usa Subversion: <span><strong class="command">svn help</strong></span>.
      Il client a riga di comando di Subversion è autoesplicativo;
      ad ogni modo, il veloce ricorso al comando svn help ,<span><strong class="command">
        svn help
        &lt;subcommand&gt;
      </strong></span>,descriverà la sintassi,
      le opioni e il comportamento del  <span><strong class="command">sottocomando</strong></span>
    </p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.tour.import"></a>Import</h2></div></div></div><p>
      Per importare un nuovo progetto nel repository di Subversion, si usa il comando
      <span><strong class="command">svn import</strong></span>. Sebbene questa sia la prima cosa da fare quando
      si prepara un server Subversion server, non è una cosa che si debba fare frequentemente.
      Per una descrizione dettagliata dell'import si rimanda a  <a href="#svn.tour.other.import" title="svn import">la sezione chiamata «<span><strong class="command">svn import</strong></span>»</a> nel seguito di questo capitolo
    </p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.tour.revs"></a>Revisioni:Numeri,Chiavi e Date, Accidenti</h2></div></div></div><p>
      Prima di andare avanti, bisogna sapere qualcosa su come identificare
      una particolare revisione nel proprio repository.  Come si è visto in
      <a href="#svn.basic.in-action.revs" title="Revisions">la sezione chiamata «Revisions»</a>, una revisione è «<span class="quote">un'istantanea </span>»
      del repository fatta in  un particolare istante di tempo.  Man mano che
      si continua a fare commit  aumentano le dimensioni del repository,
      perciò bisogna avere un metodo per identificare queste istantanee..
    </p><p>
      Per specificare le revisioni si usa l'opzione <code class="option">--revision</code>
      (<code class="option">-r</code>) specificando la revisione desiderata (<span><strong class="command">svn --revision REV</strong></span>)
      oppure si può specificare un intervallo separando le due revisioni con i due punti ":"
      (<span><strong class="command">svn --revision REV1:REV2</strong></span>).Subversion permette di referenziare
      queste revisioni attraverso numeri,chiavi oppure data.
    </p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.tour.revs.numbers"></a>Numeri di revisione</h3></div></div></div><p>
        Quando si crea un nuovo repository Subversion, esso comincia la sua vita dalla revisione zero
        e ogni successivo commit incrementa il numero di revisione di uno.
        Quando si completa il commit, il client Subversion vi comunica il nuovo numero della revisione:
      </p><pre class="screen">
        $ svn commit --message "Corrected number of cheese slices."
        Sending        sandwich.txt
        Transmitting file data .
        Committed revision 3.
      </pre><p>
        Se ad un certo punto, in seguito ci si vuole riferire a quella particolare revisione
        (si vedrà come e perchè si dovrebbe volerlo nel seguito di questo capitolo),
        ci si potrà riferire ad essa in questo modo : «<span class="quote">3</span>».
      </p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.tour.revs.keywords"></a>Chiavi per le Revisioni</h3></div></div></div><p>
        Il client Subversion riconosce un numero di <em class="firstterm">
          chiavi per le revisioni
        </em>.
        Queste chiavi possono essere usate al posto degli argomenti interi
        per richiamare le <code class="option">--revisioni</code> e vengono risolte
        da Subversion in specifici numeri di revisione:
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Nota</h3><p>

          Ogni cartella della propria copia di lavoro contiene una sottocartella
          di amministrazione chiamata <code class="filename">.svn</code>.
          Per ogni file in una cartella, Subversion mantiene una copia nell'area d'amministrazione.
          Questa copia non modificata da parte di Subversion (non è stato applicata l'espansione delle chiavi,
          non è stata effettuata la conversione dei fine riga, non è stato fatto nulla) è una copia dell'ultima revisione
          del file (chiamata la revisione «<span class="quote">BASE</span>») che è stata aggiornata nella propria copia di lavoro.
          Ci si riferirà a questo file come alla revisione <em class="firstterm">copia di ripristino</em> oppure
          <em class="firstterm">testo-base</em>, esso è sempre una copia esatta byte per byte del file che
          si trova nel repository.
          
        </p></div><div class="variablelist"><dl><dt><span class="term">HEAD</span></dt><dd><p>
              L'ultima revisione (o «<span class="quote">la più recente</span>»)nel repository.
            </p></dd><dt><span class="term">BASE</span></dt><dd><p>
              The revision number of an item in a working copy.
              If the item has been locally modified, the «<span class="quote">
                BASE
                version
              </span>» refers to the way the item appears
              without those local modifications.
            </p><p>
              Il numero di revisione di un oggetto in una copia di lavoro.
              Se l'oggetto è stato modificato in locale, la  «<span class="quote">
                versione BASE
              </span>» fa riferimento al modo in cui l'oggetto appare
              senza le modifiche effettuate.
            </p></dd><dt><span class="term">COMMITTED</span></dt><dd><p>
              La revisione più recente "prima di" oppure "uguale a"
              <code class="literal">BASE</code>,nella quale un oggetto è cambiato.
            </p></dd><dt><span class="term">PREV</span></dt><dd><p>
              La revisione immediatamente <span class="emphasis"><em>precedente</em></span> rispetto
              all'ultima revisione nella quale un oggetto è cambiato.
              (Tecnicamente, <code class="literal">COMMITTED</code> - 1.)
            </p></dd></dl></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Nota</h3><p>
          <code class="literal">PREV</code>,<code class="literal">BASE</code>, and
          <code class="literal">COMMITTED</code> possono essere usati per far riferimento a percorsi locali
          ma non a URLs.

        </p></div><p>
        Diamo alcuni esempi di chiavi di revisione in azione.
        Non bisogna preoccuparsi se i comandi sembrano non aver senso;
        saranno spiegati in seguito.
      </p><pre class="screen">
        $ svn diff --revision PREV:COMMITTED foo.c
        # shows the last change committed to foo.c

        $ svn log --revision HEAD
        # shows log message for the latest repository commit

        $ svn diff --revision HEAD
        # compares your working file (with local changes) to the latest version
        # in the repository

        $ svn diff --revision BASE:HEAD foo.c
        # compares your «<span class="quote">pristine</span>» foo.c (no local changes) with the
        # latest version in the repository

        $ svn log --revision BASE:HEAD
        # shows all commit logs since you last updated

        $ svn update --revision PREV foo.c
        # rewinds the last change on foo.c
        # (foo.c's working revision is decreased)
      </pre><p>
        Queste chiavi permettono di effettuare le più comuni
        (ed utili) operazioni senza bisogno di specificare i numeri di revisione
        o di ricordare l'esatta revisione della propria copia di lavoro.
      </p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.tour.revs.dates"></a>Date di revisione</h3></div></div></div><p>Ovunque si specifichi un numero di revisione o una chiave 
      di revisione, si può anche specificare una data racchiusa 
      fra parentesi graffe «<span class="quote">{}</span>».  Si potrà accedere ad un insieme
      di cambiamenti nel repository usando assieme le date e le revisioni!
      </p><p> Qui potete trovare alcuni esempi di formati di data accettati 
      	da Subversion. Ricordarsi di racchiudere la data tra le doppie 
	      virgolette se al suo interno contiene degli spazi.      	
      </p><pre class="screen">
$ svn checkout --revision {2002-02-17}
$ svn checkout --revision {15:30}
$ svn checkout --revision {15:30:00.200000}
$ svn checkout --revision {"2002-02-17 15:30"}
$ svn checkout --revision {"2002-02-17 15:30 +0230"}
$ svn checkout --revision {2002-02-17T15:30}
$ svn checkout --revision {2002-02-17T15:30Z}
$ svn checkout --revision {2002-02-17T15:30-04:00}
$ svn checkout --revision {20020217T1530}
$ svn checkout --revision {20020217T1530Z}
$ svn checkout --revision {20020217T1530-0500}
…
</pre><pre class="screen">
$ svn log --revision {2002-11-28}
------------------------------------------------------------------------
r12 | ira | 2002-11-27 12:31:51 -0600 (Wed, 27 Nov 2002) | 6 lines
…
</pre><div class="sidebar"><p class="title"><b>Subversion è indietro di un giorno?</b></p><p>Se si specifica una singola data come revisione senza
	 specificare l'ora (ad esempio
          <code class="literal">2002-11-27</code>), si potrebbe pensare che Subversion
          restituisca l'ultima revisione effettuata il 
          27 Novembre.  Invece , restituirà una revisione del 
          26 Novembre, o anche precedente.  Bisogna ricordare che Subversion 
          troverà la <span class="emphasis"><em>più recente revisione del 
	  repositroy</em></span> a partire dalla data inserita.  Se inseriamo
          una data senza un timestamp, come 
          <code class="literal">2002-11-27</code>, Subversion assumerà 
          00:00:00 come timestamp, cosi cercando la revisione più recente non 
	  troveremmo nulla effettuato il 27 Novembre.</p><p>Se volessimo includere il 27 Novembre nelle nostre ricerche,
          possiamo specificare assieme alla data anche l'ora  (<code class="literal">{"2002-11-27
          23:59"}</code>), oppure semplicemente inserire la data del giorno
          successivo (<code class="literal">{2002-11-28}</code>).</p></div><p>Si può anche usare un insieme di date.  Subversion troverà
        tutte le revisioni comprese tra le due date (estremi compresi):</p><pre class="screen">
$ svn log --revision {2002-11-20}:{2002-11-29}
…
</pre><p>Come abbiamo visto, è possibile combinare le date e le revisioni:</p><pre class="screen">
$ svn log --revision {2002-11-20}:4040
</pre><p>Gli utenti dovrebbero fare attenzione ad una sottigliezza che si potrebbe
        rilevare un ostacolto quando si utilizzano le date in Subversion. Poiché
        il timestamp di una revision è salvato come una proprietà della
        revisione—una proprietà modificabile e non gestita dal sistema
	di controllo di versione—i timestamp di revisione possono essere
        modificati per falsificare completamente l'ordine cronologico, o possono
        essere rimossi completamente.  Questo portà problemi sul sistema 
	di coversione data-revisione utilizzato da Subversion.</p></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.tour.initial"></a>Checkout iniziale</h2></div></div></div><p>La maggior parte delle volte si inizierà ad 
     utilizzare un repository Subversion, effettuando un 
     <em class="firstterm">checkout</em> di un determinato progetto.
      Il checkout crea una copia sulla macchina locale di un repository.
      Questa copia contiene la <code class="literal">HEAD</code>
      (ultima versione) del repository di Subversion che abbiamo 
      specificato dalla linea di comando:</p><pre class="screen">
$ svn checkout http://svn.collab.net/repos/svn/trunk
A  trunk/subversion.dsw
A  trunk/svn_check.dsp
A  trunk/COMMITTERS
A  trunk/configure.in
A  trunk/IDEAS
…
Checked out revision 2499.
</pre><div class="sidebar"><p class="title"><b>Cosa c'è in un Nome ?</b></p><p>Subversion cerca energicamente di limitare i tipi di dati che
        possono essere messi mettere sotto il controllo di versione.  
	Il contenuto dei files e i valori delle proprietà sono salvati e 
	trasmessi come dati binari, e 
        <a href="#svn.advanced.props.special.mime-type" title="svn:mime-type">la sezione chiamata «<code class="literal">svn:mime-type</code>»</a>
        ci dirà come informare Subversion che operazioni 
        «<span class="quote">testuali</span>» su un particolare tipo di file non hanno senso
	.  Comunque ci sono vari posti dove Subversion 
	inserisce delle restrizioni sulle informazioni che salva.</p><p>Subversion gestisce internamente certi bit di dati
        —ad esempio, nomi delle proprietà, percorsi e messaggi di log
	—come Unicode codificato UTF-8.  Questo non vuol dire, comunque, 
        che tutte le interazioni con Subversion debbano utilizzare la 
	codifica UTF-8. Come regola generale, i client Subversion gesticono con 
        eleganza e trasparenza la conversione tra UTF-8 e il sistema di codifica
        ultizzato dal computer dell'utente, se questa conversione può essere  
	portata a termine significativamente (che è il caso nella maggior parte
	sistemi di codifica odierni).</p><p>In aggiunta, i percorsi dei file sono usati come attributi XML 
        in scambi WebDAV, così come in alcuni file di configurazione di 
	Subversion.  Questo significa che i percorsi possono solo contenere 
        caratteri XML (1.0) valdii.  Subversion proibisce l'uso dei caratteri
        TAB, CR, and LF nei percorsi, cosi non saranno scomposti nelle diff, 
	or nell'output di comandi come <a href="#svn.ref.svn.c.log" title="svn log">svn log</a> o 
	<a href="#svn.ref.svn.c.status" title="svn status">svn status</a>.</p><p>Potrebbe sembrare di dover ricordare molte cose, in pratica
        raramente queste limitazioni si rivelano un problema.  Fin quando i
        settaggi locali sono compatibili con UTF-8, e non si utilizzano 
	caratteri di controllo nei percorsi dei file, non si 
	avranno problemi di comunicazione con Subversion.  
	I client da linea di comando ci danno un aiuto in più 
        —si occuperanno, ove necessario, di sostituire i caratteri legali
	presenti nelle URL da noi inserite in sequenze di escape creando cosi versioni di
		URL «<span class="quote">legittime</span>»per un uso interno.
	</p><p>Utenti esperti di Subversion hanno sviluppato un insieme 
	di convenzioni per costruire percorsi nel repository.
        Anche se l'adozione di queste convenzioni non sono strettamente 
	necessarie come la sitassi descritta sopra, portano sicuramente
	benifici nell'organizzazione ed esecuzione di operazioni che avvengono 
	con una certa frequenza. La parte <code class="literal">/trunk</code> degli URLs
        che in questo libro si trova ovunque, è una di queste convenzioni;
        in seguito parleremo diffusamente sia di queste convenzioni sia delle 
	relative raccomandazioni
        <a href="#svn.branchmerge" title="Capitolo&#xA0;4.&#xA0;Branching and Merging">Capitolo 4, <i>Branching and Merging</i></a>.</p></div><p>Sebbene l'esempio sopra effettua un ckeckout della directory trunk,
      si puo' semplicemente effettuare il chekout di una qualunque 
      sottodirectory di un repository specificando la sottodirectory nel URL
    </p><pre class="screen">
$ svn checkout http://svn.collab.net/repos/svn/trunk/doc/book/tools
A  tools/readme-dblite.html
A  tools/fo-stylesheet.xsl
A  tools/svnbook.el
A  tools/dtd
A  tools/dtd/dblite.dtd
…
Checked out revision 2499.
</pre><p>Da quando Subversion utilizza un modello 
      «<span class="quote">copy-modify-merge</span>» invece di uno 
      «<span class="quote">lock-modify-unlock</span>» (see <a href="#svn.basic" title="Capitolo&#xA0;2.&#xA0;Basic Concepts">Capitolo 2, <i>Basic Concepts</i></a>), 
      possiamo direttamente effettuare cambiamenti sui file e le directory
      della nostra working copy. La nostra working copy è semplicemente come
      ogni altro file e directory sul nostro sistema.  
      Si possono modificare e muovere, si può anche cancellare l'intera
      working copy e dimenticarsi completamente della sua esistenza.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Nota</h3><p>Mentre la nostra working copy «<span class="quote"> è come ogni altro 
          insieme di file e directory sul nostro sistema</span>»,
          dobbiamo far sapere a Subversion se stiamo ridisponiamo qualcosa
	  all'interna della working copy.  Se volessimo sposare o copiare
          un elemento facente parte della working copy, dovremmo utilizzare
          <span><strong class="command">svn copy</strong></span> oppure <span><strong class="command">svn
          move</strong></span> invece dei rispettivi comandi forniti dal sistema 
          operativo da noi utlizzato. Nel parleremo in modo più approfondito 
	  più avanti nel capitolo.</p></div><p> A meno che non dobbiamo fare un commit di un nuovo file o 
      di una nuova directory, oppure dei cambiamenti effettuati su un file 
      esistente, non ci sono ulteriori notifiche al Subversion server di quello
      efettuato.</p><div class="sidebar"><p class="title"><b>Cosa è la directory<code class="filename">.svn</code>?</b></p><p>Ogni directory in una working copy contiene un area di 
      	amministrazione, la subdirectory 
        <code class="filename">.svn</code>.  Di solito, i comandi per elencare
	il contenuto di una directory non mostrano questa subdirectory,
        , ma tuttavia è una directory importante.  
	Qualunque cosa facciamo la cosa importante è di non modificare o 
	cancellare, nulla nell'area di amministrazione.
        Per Subversion questa area è fondamentale per gestire la nostra 
        working copy.</p></div><p>Mentre si può cercatemente effettuare un ckeckout di una working copy
      con l'URL del repository come unico argomento, si può anche specificare 
      una directory dopo l'URL del repository.  Questo posiziona la working copy
      nella directory con quel nome.  Ad esempio:</p><pre class="screen">
$ svn checkout http://svn.collab.net/repos/svn/trunk subv
A  subv/subversion.dsw
A  subv/svn_check.dsp
A  subv/COMMITTERS
A  subv/configure.in
A  subv/IDEAS
…
Checked out revision 2499.
</pre><p>Questo posizionerà la nostra working copy nella directory
      <code class="literal">subv</code> invece che nella directory 
      <code class="literal">trunk</code> come era accaduto precedentemente.</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.tour.cycle"></a>Basic Work Cycle</h2></div></div></div><p>Subversion has numerous features, options, bells and
      whistles, but on a day-to-day basis, odds are that you will only
      use a few of them.  In this section we'll run through the most
      common things that you might find yourself doing with Subversion
      in the course of a day's work.</p><p>The typical work cycle looks like this:</p><div class="itemizedlist"><ul type="disc"><li><p>Update your working copy</p><div class="itemizedlist"><ul type="circle"><li><p><span><strong class="command">svn update</strong></span></p></li></ul></div></li><li><p>Make changes</p><div class="itemizedlist"><ul type="circle"><li><p><span><strong class="command">svn add</strong></span></p></li><li><p><span><strong class="command">svn delete</strong></span></p></li><li><p><span><strong class="command">svn copy</strong></span></p></li><li><p><span><strong class="command">svn move</strong></span></p></li></ul></div></li><li><p>Examine your changes</p><div class="itemizedlist"><ul type="circle"><li><p><span><strong class="command">svn status</strong></span></p></li><li><p><span><strong class="command">svn diff</strong></span></p></li><li><p><span><strong class="command">svn revert</strong></span></p></li></ul></div></li><li><p>Merge others' changes into your working copy</p><div class="itemizedlist"><ul type="circle"><li><p><span><strong class="command">svn update</strong></span></p></li><li><p><span><strong class="command">svn resolved</strong></span></p></li></ul></div></li><li><p>Commit your changes</p><div class="itemizedlist"><ul type="circle"><li><p><span><strong class="command">svn commit</strong></span></p></li></ul></div></li></ul></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.tour.cycle.update"></a>Update Your Working Copy</h3></div></div></div><p>When working on a project with a team, you'll want to
        update your working copy to receive any changes made since
        your last update by other developers on the project.  Use
        <span><strong class="command">svn update</strong></span> to bring your working copy into
        sync with the latest revision in the repository.</p><pre class="screen">
$ svn update
U  foo.c
U  bar.c
Updated to revision 2.
</pre><p>In this case, someone else checked in modifications to
        both <code class="filename">foo.c</code> and <code class="filename">bar.c</code>
        since the last time you updated, and Subversion has updated
        your working copy to include those changes.</p><p>Let's examine the output of <span><strong class="command">svn update</strong></span>
        a bit more.  When the server sends changes to your working
        copy, a letter code is displayed next to each item to let you
        know what actions Subversion performed to bring your working
        copy up-to-date:</p><div class="variablelist"><dl><dt><span class="term"><code class="computeroutput">U      foo</code></span></dt><dd><p>File <code class="filename">foo</code> was
              <code class="computeroutput">U</code>pdated (received changes
              from the server).</p></dd><dt><span class="term"><code class="computeroutput">A      foo</code></span></dt><dd><p>File or directory <code class="filename">foo</code> was
              <code class="computeroutput">A</code>dded to your working
              copy.</p></dd><dt><span class="term"><code class="computeroutput">D      foo</code></span></dt><dd><p>File or directory <code class="filename">foo</code> was
              <code class="computeroutput">D</code>eleted from your working
              copy.</p></dd><dt><span class="term"><code class="computeroutput">R      foo</code></span></dt><dd><p>File or directory <code class="filename">foo</code> was
              <code class="computeroutput">R</code>eplaced in your working
              copy; that is, <code class="filename">foo</code> was deleted, and a
              new item with the same name was added.  While they may have
              the same name, the repository considers them to be distinct
              objects with distinct histories.</p></dd><dt><span class="term"><code class="computeroutput">G      foo</code></span></dt><dd><p>File <code class="filename">foo</code> received new changes
              from the repository, but your local copy of the file had
              your modifications.  Either the changes did not intersect,
              or the changes were exactly the same as your local
              modifications, so Subversion has successfully
              mer<code class="computeroutput">G</code>ed the repository's
              changes into the file without a problem.</p></dd><dt><span class="term"><code class="computeroutput">C      foo</code></span></dt><dd><p>File <code class="filename">foo</code> received
              <code class="computeroutput">C</code>onflicting changes from
              the server.  The changes from the server directly overlap
              your own changes to the file.  No need to panic, though.
              This overlap needs to be resolved by a human (you); we
              discuss this situation later in this chapter.</p></dd></dl></div></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.tour.cycle.edit"></a>Make Changes to Your Working Copy</h3></div></div></div><p>Now you can get to work and make changes in your
        working copy.  It's usually most convenient to decide on a
        particular change (or set of changes) to make, such as writing
        a new feature, fixing a bug, etc.  The Subversion commands
        that you will use here are <span><strong class="command">svn add</strong></span>,
        <span><strong class="command">svn delete</strong></span>, <span><strong class="command">svn copy</strong></span>,
        and <span><strong class="command">svn move</strong></span>.  However, if you are merely
        editing files that are already in Subversion, you may not need
        to use any of these commands until you commit.  Changes you can
        make to your working copy:</p><div class="variablelist"><dl><dt><span class="term">File changes</span></dt><dd><p>This is the simplest sort of change.  You don't need
              to tell Subversion that you intend to change a file;
              just make your changes.  Subversion will be able to
              automatically detect which files have been
              changed.</p></dd><dt><span class="term">Tree changes</span></dt><dd><p>You can ask Subversion to «<span class="quote">mark</span>» files
              and directories for scheduled removal, addition,
              copying, or moving.  While these changes may take place
              immediately in your working copy, no additions or
              removals will happen in the repository until you commit
              them.</p></dd></dl></div><p>To make file changes, use your text editor, word
        processor, graphics program, or whatever tool you would
        normally use.  Subversion handles binary files just as easily
        as it handles text files—and just as efficiently
        too.</p><p>Here is an overview of the four Subversion subcommands
        that you'll use most often to make tree changes (we'll cover
        <span><strong class="command">svn import</strong></span> and <span><strong class="command">svn mkdir</strong></span>
        later).</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Avvertimento</h3><p>While you can edit your files with whatever tool you
          like, you shouldn't change the structure of your working
          copy without letting Subversion know what you're doing.  Use
          the <span><strong class="command">svn copy</strong></span>, <span><strong class="command">svn
          delete</strong></span>, and <span><strong class="command">svn move</strong></span> commands
          to change the structure of your working copy, and use the
          <span><strong class="command">svn add</strong></span> command to place new files and
          directories under version control.</p></div><div class="variablelist"><dl><dt><span class="term"><span><strong class="command">svn add foo</strong></span></span></dt><dd><p>Schedule file, directory, or symbolic link
              <code class="filename">foo</code> to be added to the repository.
              When you next commit, <code class="filename">foo</code> will
              become a child of its parent directory.  Note that if
              <code class="filename">foo</code> is a directory, everything
              underneath <code class="filename">foo</code> will be scheduled
              for addition.  If you only want to add
              <code class="filename">foo</code> itself, pass the
              <code class="option">--non-recursive</code> (<code class="option">-N</code>)
              switch.</p></dd><dt><span class="term"><span><strong class="command">svn delete foo</strong></span></span></dt><dd><p>Schedule file, directory, or symbolic link
              <code class="filename">foo</code> to be deleted from the
              repository.  If <code class="filename">foo</code> is a file or
              link, it is immediately deleted from your working copy.
              If <code class="filename">foo</code> is a directory, it is not
              deleted, but Subversion schedules it for deletion.  When
              you commit your changes, <code class="filename">foo</code> will
              be removed from your working copy and the repository.
              <sup>[<a id="id4732906" href="#ftn.id4732906">3</a>]</sup></p></dd><dt><span class="term"><span><strong class="command">svn copy foo bar</strong></span></span></dt><dd><p>Create a new item <code class="filename">bar</code> as a
              duplicate of <code class="filename">foo</code>.
              <code class="filename">bar</code> is automatically scheduled for
              addition.  When <code class="filename">bar</code> is added to the
              repository on the next commit, its copy history is
              recorded (as having originally come from
              <code class="filename">foo</code>).  <span><strong class="command">svn copy</strong></span>
              does not create intermediate directories.</p></dd><dt><span class="term"><span><strong class="command">svn move foo bar</strong></span></span></dt><dd><p>This command is exactly the same as running
              <span><strong class="command">svn copy foo bar; svn delete foo</strong></span>.
              That is, <code class="filename">bar</code> is scheduled for
              addition as a copy of <code class="filename">foo</code>, and
              <code class="filename">foo</code> is scheduled for removal.
              <span><strong class="command">svn move</strong></span> does not create intermediate
              directories.</p></dd></dl></div><div class="sidebar"><p class="title"><b>Changing the Repository Without a Working Copy</b></p><p>Earlier in this chapter, we said that you have to commit
          any changes that you make in order for the repository to
          reflect these changes.  That's not entirely true—there
          <span class="emphasis"><em>are</em></span> some use cases that immediately
          commit tree changes to the repository.  This only happens
          when a subcommand is operating directly on a URL, rather
          than on a working-copy path.  In particular, specific uses
          of <span><strong class="command">svn mkdir</strong></span>, <span><strong class="command">svn
          copy</strong></span>, <span><strong class="command">svn move</strong></span>, and
          <span><strong class="command">svn delete</strong></span> can work with URLs.</p><p>URL operations behave in this manner because commands
          that operate on a working copy can use the working copy as a
          sort of «<span class="quote">staging area</span>» to set up your changes
          before committing them to the repository.  Commands that
          operate on URLs don't have this luxury, so when you operate
          directly on a URL, any of the above actions represent an
          immediate commit.</p></div></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.tour.cycle.examine"></a>Examine Your Changes</h3></div></div></div><p>Once you've finished making changes, you need to commit
        them to the repository, but before you do so, it's usually a
        good idea to take a look at exactly what you've changed.  By
        examining your changes before you commit, you can make a
        more accurate log message.  You may also discover that
        you've inadvertently changed a file, and this gives you a
        chance to revert those changes before committing.
        Additionally, this is a good opportunity to review and
        scrutinize changes before publishing them.  You can see
        exactly what changes you've made by using <span><strong class="command">svn
        status</strong></span>, <span><strong class="command">svn diff</strong></span>, and
        <span><strong class="command">svn revert</strong></span>.  You will usually use the first
        two commands to find out what files have changed in your
        working copy, and then perhaps the third to revert some (or
        all) of those changes.</p><p>Subversion has been optimized to help you with this task,
        and is able to do many things without communicating with the
        repository.  In particular, your working copy contains a
        secret cached «<span class="quote">pristine</span>» copy of each version
        controlled file within the <code class="filename">.svn</code> area.
        Because of this, Subversion can quickly show you how your
        working files have changed, or even allow you to undo your
        changes without contacting the repository.</p><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.tour.cycle.examine.status"></a><span><strong class="command">svn status</strong></span></h4></div></div></div><p>You'll probably use the <span><strong class="command">svn status</strong></span>
          command more than any other Subversion command.</p><div class="sidebar"><p class="title"><b>CVS Users: Hold That Update!</b></p><p>You're probably used to using <span><strong class="command">cvs
            update</strong></span> to see what changes you've made to your
            working copy.  <span><strong class="command">svn status</strong></span> will give you
            all the information you need regarding what has changed in
            your working copy—without accessing the repository
            or potentially incorporating new changes published by
            other users.</p><p>In Subversion, <span><strong class="command">update</strong></span> does just
            that—it updates your working copy with any changes
            committed to the repository since the last time you've
            updated your working copy.  You'll have to break the habit
            of using the <span><strong class="command">update</strong></span> command to see what
            local modifications you've made.</p></div><p>If you run <span><strong class="command">svn status</strong></span> at the top of
          your working copy with no arguments, it will detect all file
          and tree changes you've made.  Below are examples of
          the different status codes that <span><strong class="command">svn
          status</strong></span> can return.  (Note that the text following
          <code class="literal">#</code> is not
          actually printed by <span><strong class="command">svn status</strong></span>.)</p><pre class="screen">
  L     some_dir            # svn left a lock in the .svn area of some_dir
M       bar.c               # the content in bar.c has local modifications
 M      baz.c               # baz.c has property but no content modifications
X       3rd_party           # dir is part of an externals definition
?       foo.o               # svn doesn't manage foo.o
!       some_dir            # svn manages this, but it's missing or incomplete
~       qux                 # versioned as file/dir/link, but type has changed
I       .screenrc           # svn doesn't manage this, and is set to ignore it
A  +    moved_dir           # added with history of where it came from
M  +    moved_dir/README    # added with history and has local modifications
D       stuff/fish.c        # file is scheduled for deletion
A       stuff/loot/bloo.h   # file is scheduled for addition
C       stuff/loot/lump.c   # file has textual conflicts from an update
 C      stuff/loot/glub.c   # file has property conflicts from an update
R       xyz.c               # file is scheduled for replacement
    S   stuff/squawk        # file or dir has been switched to a branch
     K  dog.jpg             # file is locked locally; lock-token present 
     O  cat.jpg             # file is locked in the repository by other user
     B  bird.jpg            # file is locked locally, but lock has been broken
     T  fish.jpg            # file is locked locally, but lock has been stolen

</pre><p>In this output format <span><strong class="command">svn status</strong></span>
          prints five columns of characters, followed by several
          whitespace characters, followed by a file or directory name.
          The first column tells the status of a file or directory
          and/or its contents.  The codes printed here are:</p><div class="variablelist"><dl><dt><span class="term"><code class="computeroutput">A      item</code></span></dt><dd><p>The file, directory, or symbolic link
                <code class="filename">item</code> has been scheduled for
                addition into the repository.</p></dd><dt><span class="term"><code class="computeroutput">C      item</code></span></dt><dd><p>The file <code class="filename">item</code> is in a state
                of conflict.  That is, changes received from the
                server during an update overlap with local changes
                that you have in your working copy.  You must resolve
                this conflict before committing your changes to the
                repository.</p></dd><dt><span class="term"><code class="computeroutput">D      item</code></span></dt><dd><p>The file, directory, or symbolic link
                <code class="filename">item</code> has been scheduled for
                deletion from the repository.</p></dd><dt><span class="term"><code class="computeroutput">M      item</code></span></dt><dd><p>The contents of the file <code class="filename">item</code>
                have been modified.</p></dd><dt><span class="term"><code class="computeroutput">R      item</code></span></dt><dd><p>The file, directory, or symbolic link
                <code class="filename">item</code> has been scheduled to
                replace <code class="filename">item</code> in the repository.
                This means that the object is first deleted, then
                another object of the same name is added, all within a
                single revision.</p></dd><dt><span class="term"><code class="computeroutput">X      item</code></span></dt><dd><p>The directory <code class="filename">item</code> is
                unversioned, but is related to a Subversion externals
                definition.  To find out more about externals
                definitions, see <a href="#svn.advanced.externals" title="Externals Definitions">la sezione chiamata «Externals Definitions»</a>.</p></dd><dt><span class="term"><code class="computeroutput">?      item</code></span></dt><dd><p>The file, directory, or symbolic link
                <code class="filename">item</code> is not under version
                control.  You can silence the question marks by either
                passing the <code class="option">--quiet</code>
                (<code class="option">-q</code>) switch to <span><strong class="command">svn
                status</strong></span>, or by setting the
                <code class="literal">svn:ignore</code> property on the parent
                directory.  For more information on ignored files, see
                <a href="#svn.advanced.props.special.ignore" title="svn:ignore">la sezione chiamata «<code class="literal">svn:ignore</code>»</a>.</p></dd><dt><span class="term"><code class="computeroutput">!      item</code></span></dt><dd><p>The file, directory, or symbolic link
                <code class="filename">item</code> is under version control but
                is missing or somehow incomplete.  The item can be
                missing if it's removed using a non-Subversion
                command.  In the case of a directory, it can be
                incomplete if you happened to interrupt a checkout or
                update.  A quick <span><strong class="command">svn update</strong></span> will
                refetch the file or directory from the repository, or
                <span><strong class="command">svn revert file</strong></span> will restore a
                missing file.</p></dd><dt><span class="term"><code class="computeroutput">~      item</code></span></dt><dd><p>The file, directory, or symbolic link
                <code class="filename">item</code> is in the repository as one
                kind of object, but what's actually in your working
                copy is some other kind.  For example, Subversion
                might have a file in the repository, but you removed
                the file and created a directory in its place, without
                using the <span><strong class="command">svn delete</strong></span> or
                <span><strong class="command">svn add</strong></span> command.</p></dd><dt><span class="term"><code class="computeroutput">I      item</code></span></dt><dd><p>The file, directory, or symbolic link
                <code class="filename">item</code> is not under version control,
                and Subversion is configured to ignore it during
                <span><strong class="command">svn add</strong></span>, <span><strong class="command">svn import</strong></span>
                and <span><strong class="command">svn status</strong></span> operations.  For more
                information on ignored files, see <a href="#svn.advanced.props.special.ignore" title="svn:ignore">la sezione chiamata «<code class="literal">svn:ignore</code>»</a>.  Note that this
                symbol only shows up if you pass the
                <code class="option">--no-ignore</code> option to <span><strong class="command">svn
                status</strong></span>—otherwise the file would be
                ignored and not listed at all!</p></dd></dl></div><p>The second column tells the status of a file or
          directory's properties (see <a href="#svn.advanced.props" title="Properties">la sezione chiamata «Properties»</a> for more information on
          properties).  If an <code class="computeroutput">M</code>
          appears in the second column, then the properties have been
          modified, otherwise a whitespace will be printed.</p><p>The third column will only show whitespace or an
          <code class="computeroutput">L</code> which means that
          Subversion has locked the directory's
          <code class="filename">.svn</code> working area.  You will see an
          <code class="computeroutput">L</code> if you run <span><strong class="command">svn
          status</strong></span> in a directory where an <span><strong class="command">svn
          commit</strong></span> is in progress—perhaps when you are
          editing the log message.  If Subversion is not running, then
          presumably Subversion was interrupted and the lock needs to
          be cleaned up by running <span><strong class="command">svn cleanup</strong></span>
          (more about that later in this chapter).</p><p>The fourth column will only show whitespace or a
          <code class="computeroutput">+</code> which means that the file
          or directory is scheduled to be added or modified with
          additional attached history.  This typically happens when you
          <span><strong class="command">svn move</strong></span> or <span><strong class="command">svn copy</strong></span> a file
          or directory.  If you see
          <code class="computeroutput">A  +</code>, this means
          the item is scheduled for addition-with-history.  It could be
          a file, or the root of a copied directory.
          <code class="computeroutput">+</code>
          means the item is part of a subtree scheduled for
          addition-with-history, i.e. some parent got copied, and it's
          just coming along for the ride.
          <code class="computeroutput">M  +</code> means the item
          is part of a subtree scheduled for addition-with-history,
          <span class="emphasis"><em>and</em></span> it has local modifications.  When you
          commit, first the parent will be added-with-history (copied),
          which means this file will automatically exist in the copy.
          Then the local modifications will be uploaded into the
          copy.</p><p>The fifth column will only show whitespace or an
          <code class="computeroutput">S</code>.  This signifies that the
          file or directory has been switched from the path of the
          rest of the working copy (using <span><strong class="command">svn
          switch</strong></span>) to a branch.</p><p>The sixth column shows information about locks, which is
          further explained in <a href="#svn.advanced.locking" title="Locking">la sezione chiamata «Locking»</a>.
          (These are not the same locks as the ones indicated by an
          <code class="computeroutput">L</code> in the third column;
          see <a href="#svn.advanced.locking.meanings" title="Three meanings of &#xAB;lock&#xBB;">Three meanings of «<span class="quote">lock</span>»</a>.)</p><p>If you pass a specific path to <span><strong class="command">svn
          status</strong></span>, it gives you information about that item
          alone:</p><pre class="screen">
$ svn status stuff/fish.c
D      stuff/fish.c
</pre><p><span><strong class="command">svn status</strong></span> also has a
          <code class="option">--verbose</code> (<code class="option">-v</code>) switch,
          which will show you the status of <span class="emphasis"><em>every</em></span>
          item in your working copy, even if it has not been
          changed:</p><pre class="screen">
$ svn status --verbose
M               44        23    sally     README
                44        30    sally     INSTALL
M               44        20    harry     bar.c
                44        18    ira       stuff
                44        35    harry     stuff/trout.c
D               44        19    ira       stuff/fish.c
                44        21    sally     stuff/things
A                0         ?     ?        stuff/things/bloo.h
                44        36    harry     stuff/things/gloo.c
</pre><p>This is the «<span class="quote">long form</span>» output of
          <span><strong class="command">svn status</strong></span>.  The first column remains
          the same, but the second column shows the working-revision of
          the item.  The third and fourth columns show the revision in
          which the item last changed, and who changed it.</p><p>None of the above invocations to <span><strong class="command">svn
          status</strong></span> contact the repository, they work only
          locally by comparing the metadata in the
          <code class="filename">.svn</code> directory with the working copy.
          Finally, there is the <code class="option">--show-updates</code>
          (<code class="option">-u</code>) switch, which contacts the repository
          and adds information about things that are
          out-of-date:</p><pre class="screen">
$ svn status --show-updates --verbose
M      *        44        23    sally     README
M               44        20    harry     bar.c
       *        44        35    harry     stuff/trout.c
D               44        19    ira       stuff/fish.c
A                0         ?     ?        stuff/things/bloo.h
Status against revision:   46
</pre><p>Notice the two asterisks: if you were to run
          <span><strong class="command">svn update</strong></span> at this point, you would
          receive changes to <code class="filename">README</code>
          and <code class="filename">trout.c</code>.  This tells you some very
          useful information—you'll need to update and get the
          server changes on <code class="filename">README</code> before you
          commit, or the repository will reject your commit for being
          out-of-date.  (More on this subject later.)</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.tour.cycle.examine.diff"></a><span><strong class="command">svn diff</strong></span></h4></div></div></div><p>Another way to examine your changes is with the
          <span><strong class="command">svn diff</strong></span> command.  You can find out
          <span class="emphasis"><em>exactly</em></span> how you've modified things by
          running <span><strong class="command">svn diff</strong></span> with no arguments, which
          prints out file changes in unified diff
          format:<sup>[<a id="id4734073" href="#ftn.id4734073">4</a>]</sup></p><pre class="screen">
$ svn diff
Index: bar.c
===================================================================
--- bar.c	(revision 3)
+++ bar.c	(working copy)
@@ -1,7 +1,12 @@
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;unistd.h&gt;
+
+#include &lt;stdio.h&gt;

 int main(void) {
-  printf("Sixty-four slices of American Cheese...\n");
+  printf("Sixty-five slices of American Cheese...\n");
 return 0;
 }

Index: README
===================================================================
--- README	(revision 3)
+++ README	(working copy)
@@ -193,3 +193,4 @@ 
+Note to self:  pick up laundry.

Index: stuff/fish.c
===================================================================
--- stuff/fish.c	(revision 1)
+++ stuff/fish.c	(working copy)
-Welcome to the file known as 'fish'.
-Information on fish will be here soon.

Index: stuff/things/bloo.h
===================================================================
--- stuff/things/bloo.h	(revision 8)
+++ stuff/things/bloo.h	(working copy)
+Here is a new file to describe
+things about bloo.
</pre><p>The <span><strong class="command">svn diff</strong></span> command produces this
          output by comparing your working files against the cached
          «<span class="quote">pristine</span>» copies within the
          <code class="filename">.svn</code> area.  Files scheduled for
          addition are displayed as all added-text, and files
          scheduled for deletion are displayed as all deleted
          text.</p><p>Output is displayed in <em class="firstterm">unified diff
          format</em>.  That is, removed lines are prefaced
          with a <code class="literal">-</code> and added lines are prefaced
          with a <code class="literal">+</code>.  <span><strong class="command">svn diff</strong></span>
          also prints filename and offset information useful to the
          <span><strong class="command">patch</strong></span> program, so you can generate
          «<span class="quote">patches</span>» by redirecting the diff output to a
          file:</p><pre class="screen">
$ svn diff &gt; patchfile
</pre><p>You could, for example, email the patch file to another
          developer for review or testing prior to commit.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.tour.cycle.examine.revert"></a><span><strong class="command">svn revert</strong></span></h4></div></div></div><p>Now suppose you see the above diff output, and realize
          that your changes to <code class="filename">README</code> are a
          mistake; perhaps you accidentally typed that text into the
          wrong file in your editor.</p><p>This is a perfect opportunity to use <span><strong class="command">svn
          revert</strong></span>.</p><pre class="screen">
$ svn revert README
Reverted 'README'
</pre><p>Subversion reverts the file to its pre-modified state by
          overwriting it with the cached «<span class="quote">pristine</span>» copy
          from the <code class="filename">.svn</code> area.  But also note that
          <span><strong class="command">svn revert</strong></span> can undo
          <span class="emphasis"><em>any</em></span> scheduled operations—for
          example, you might decide that you don't want to add a new
          file after all:</p><pre class="screen">
$ svn status foo
?      foo

$ svn add foo
A         foo

$ svn revert foo
Reverted 'foo'

$ svn status foo
?      foo
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Nota</h3><p><span><strong class="command">svn revert</strong></span>
            <em class="replaceable"><code>ITEM</code></em> has exactly the same
            effect as deleting <em class="replaceable"><code>ITEM</code></em> from
            your working copy and then running <span><strong class="command">svn update -r
            BASE</strong></span> <em class="replaceable"><code>ITEM</code></em>.  However,
            if you're reverting a file, <span><strong class="command">svn revert</strong></span>
            has one very noticeable difference—it doesn't have
            to communicate with the repository to restore your
            file.</p></div><p>Or perhaps you mistakenly removed a file from version
          control:</p><pre class="screen">
$ svn status README 
       README

$ svn delete README 
D         README

$ svn revert README
Reverted 'README'

$ svn status README
       README
</pre></div><div class="sidebar"><p class="title"><b>Look Ma! No Network!</b></p><p>All three of these commands (<span><strong class="command">svn
          status</strong></span>, <span><strong class="command">svn diff</strong></span>, and
          <span><strong class="command">svn revert</strong></span>) can be used without any
          network access.  This makes it easy to manage your
          changes-in-progress when you are somewhere without a network
          connection, such as travelling on an airplane, riding a
          commuter train or hacking on the beach.</p><p>Subversion does this by keeping private caches of
          pristine versions of each versioned file inside of the
          <code class="filename">.svn</code> administrative areas.  This allows
          Subversion to report—and revert—local
          modifications to those files <span class="emphasis"><em>without network
          access</em></span>.  This cache (called the
          «<span class="quote">text-base</span>») also allows Subversion to send the
          user's local modifications during a commit to the server as
          a compressed <em class="firstterm">delta</em> (or
          «<span class="quote">difference</span>») against the pristine version.
          Having this cache is a tremendous benefit—even if you
          have a fast net connection, it's much faster to send only a
          file's changes rather than the whole file to the server.  At
          first glance, this might not seem that important, but
          imagine the repercussions if you try to commit a one line
          change to a 400MB file and have to send the whole file to
          the server!</p></div></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.tour.cycle.resolve"></a>Resolve Conflicts (Merging Others' Changes)</h3></div></div></div><p>We've already seen how <span><strong class="command">svn status -u</strong></span>
        can predict conflicts.  Suppose you run <span><strong class="command">svn
        update</strong></span> and some interesting things occur:</p><pre class="screen">
$ svn update
U  INSTALL
G  README
C  bar.c
Updated to revision 46.
</pre><p>The <code class="computeroutput">U</code> and
        <code class="computeroutput">G</code> codes are no cause for
        concern; those files cleanly absorbed changes from the
        repository.  The files marked with
        <code class="computeroutput">U</code> contained no local changes
        but were <code class="computeroutput">U</code>pdated with changes
        from the repository.  The <code class="computeroutput">G</code>
        stands for mer<code class="computeroutput">G</code>ed, which
        means that the file had local changes to begin with, but the
        changes coming from the repository didn't overlap with the local
        changes.</p><p>But the <code class="computeroutput">C</code> stands for
        conflict.  This means that the changes from the server overlapped
        with your own, and now you have to manually choose between
        them.</p><p>Whenever a conflict occurs, three things typically occur
        to assist you in noticing and resolving that conflict:</p><div class="itemizedlist"><ul type="disc"><li><p>Subversion prints a <code class="computeroutput">C</code>
            during the update, and remembers that the file is in a
            state of conflict.</p></li><li><p>If Subversion considers the file to be of a mergeable
            type, it places <em class="firstterm">conflict
            markers</em>—special strings of text which
            delimit the «<span class="quote">sides</span>» of the
            conflict—into the file to visibly demonstrate the
            overlapping areas.  (Subversion uses the
            <code class="literal">svn:mime-type</code> property to decide if a
            file is capable of contextual, line-based merging.  See
            <a href="#svn.advanced.props.special.mime-type" title="svn:mime-type">la sezione chiamata «<code class="literal">svn:mime-type</code>»</a> to learn more.)</p></li><li><p>For every conflicted file, Subversion places up to
            three extra unversioned files in your working copy:</p><div class="variablelist"><dl><dt><span class="term"><code class="filename">filename.mine</code></span></dt><dd><p>This is your file as it existed in your working
                  copy before you updated your working copy—that
                  is, without conflict markers.  This file has your
                  latest changes in it and nothing else.  (If
                  Subversion considers the file to be unmergeable,
                  then the <code class="filename">.mine</code> file isn't
                  created, since it would be identical to the working
                  file.)</p></dd><dt><span class="term"><code class="filename">filename.rOLDREV</code></span></dt><dd><p>This is the file that was the
                  <code class="literal">BASE</code> revision before you updated
                  your working copy.  That is, the file that you
                  checked out before you made your latest
                  edits.</p></dd><dt><span class="term"><code class="filename">filename.rNEWREV</code></span></dt><dd><p>This is the file that your Subversion client
                  just received from the server when you updated your
                  working copy.  This file corresponds to the
                  <code class="literal">HEAD</code> revision of the
                  repository.</p></dd></dl></div><p>Here <code class="literal">OLDREV</code> is the revision number
            of the file in your <code class="filename">.svn</code> directory
            and <code class="literal">NEWREV</code> is the revision number of
            the repository <code class="literal">HEAD</code>.</p></li></ul></div><p>For example, Sally makes changes to the file
        <code class="filename">sandwich.txt</code> in the repository.  Harry has
        just changed the file in his working copy and checked it in.
        Sally updates her working copy before checking in and she gets
        a conflict:</p><pre class="screen">
$ svn update
C  sandwich.txt
Updated to revision 2.
$ ls -1
sandwich.txt
sandwich.txt.mine
sandwich.txt.r1
sandwich.txt.r2
</pre><p>At this point, Subversion will <span class="emphasis"><em>not</em></span>
        allow you to commit the file <code class="filename">sandwich.txt</code>
        until the three temporary files are removed.</p><pre class="screen">
$ svn commit --message "Add a few more things"
svn: Commit failed (details follow):
svn: Aborting commit: '/home/sally/svn-work/sandwich.txt' remains in conflict
</pre><p>If you get a conflict, you need to do one of three
        things:</p><div class="itemizedlist"><ul type="disc"><li><p>Merge the conflicted text «<span class="quote">by hand</span>» (by
              examining and editing the conflict markers within the
              file).</p></li><li><p>Copy one of the temporary files on top of your
              working file.</p></li><li><p>Run <span><strong class="command">svn revert &lt;filename&gt;</strong></span>
              to throw away all of your local changes.</p></li></ul></div><p>Once you've resolved the conflict, you need to let
        Subversion know by running <span><strong class="command">svn resolved</strong></span>.
        This removes the three temporary files and Subversion no
        longer considers the file to be in a state of
        conflict.<sup>[<a id="id4734795" href="#ftn.id4734795">5</a>]</sup></p><pre class="screen">
$ svn resolved sandwich.txt
Resolved conflicted state of 'sandwich.txt'
</pre><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.tour.cycle.resolve.byhand"></a>Merging Conflicts by Hand</h4></div></div></div><p>Merging conflicts by hand can be quite intimidating the
          first time you attempt it, but with a little practice, it
          can become as easy as falling off a bike.</p><p>Here's an example.  Due to a miscommunication, you and
          Sally, your collaborator, both edit the file
          <code class="filename">sandwich.txt</code> at the same time.  Sally
          commits her changes, and when you go to update your working
          copy, you get a conflict and we're going to have to edit
          <code class="filename">sandwich.txt</code> to resolve the conflicts.
          First, let's take a look at the file:</p><pre class="screen">
$ cat sandwich.txt
Top piece of bread
Mayonnaise
Lettuce
Tomato
Provolone
&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine
Salami
Mortadella
Prosciutto
=======
Sauerkraut
Grilled Chicken
&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r2
Creole Mustard
Bottom piece of bread
</pre><p>The strings of less-than signs, equal signs, and
          greater-than signs are conflict markers, and are not part of
          the actual data in conflict.  You generally want to ensure
          that those are removed from the file before your next
          commit.  The text between the first two sets of markers is
          composed of the changes you made in the conflicting
          area:</p><pre class="screen">
&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine
Salami
Mortadella
Prosciutto
=======
</pre><p>The text between the second and third sets of conflict
          markers is the text from Sally's commit:</p><pre class="screen">
=======
Sauerkraut
Grilled Chicken
&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r2
</pre><p>Usually you won't want to just delete the conflict
          markers and Sally's changes—she's going to be awfully
          surprised when the sandwich arrives and it's not what she
          wanted.  So this is where you pick up the phone or walk
          across the office and explain to Sally that you can't get
          sauerkraut from an Italian deli.<sup>[<a id="id4734892" href="#ftn.id4734892">6</a>]</sup> Once you've agreed on the changes
          you will check in, edit your file and remove the conflict
          markers.</p><pre class="screen">
Top piece of bread
Mayonnaise
Lettuce
Tomato
Provolone
Salami
Mortadella
Prosciutto
Creole Mustard
Bottom piece of bread
</pre><p>Now run <span><strong class="command">svn resolved</strong></span>, and you're
          ready to commit your changes:</p><pre class="screen">
$ svn resolved sandwich.txt
$ svn commit -m "Go ahead and use my sandwich, discarding Sally's edits."
</pre><p>Remember, if you ever get confused while editing the
          conflicted file, you can always consult the three files that
          Subversion creates for you in your working
          copy—including your file as it was before you updated.
          You can even use a third-party interactive merging tool to
          examine those three files.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.tour.cycle.resolve.copyover"></a>Copying a File Onto Your Working File</h4></div></div></div><p>If you get a conflict and decide that you want to throw
          out your changes, you can merely copy one of the temporary
          files created by Subversion over the file in your working
          copy:</p><pre class="screen">
$ svn update
C  sandwich.txt
Updated to revision 2.
$ ls sandwich.*
sandwich.txt  sandwich.txt.mine  sandwich.txt.r2  sandwich.txt.r1
$ cp sandwich.txt.r2 sandwich.txt
$ svn resolved sandwich.txt
</pre></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.tour.cycle.resolve.revert"></a>Punting: Using <span><strong class="command">svn revert</strong></span></h4></div></div></div><p>If you get a conflict, and upon examination decide that
          you want to throw out your changes and start your edits
          again, just revert your changes:</p><pre class="screen">
$ svn revert sandwich.txt
Reverted 'sandwich.txt'
$ ls sandwich.*
sandwich.txt
</pre><p>Note that when you revert a conflicted file, you don't
          have to run <span><strong class="command">svn resolved</strong></span>.</p></div><p>Now you're ready to check in your changes.  Note that
        <span><strong class="command">svn resolved</strong></span>, unlike most of the other
        commands we've dealt with in this chapter, requires an
        argument.  In any case, you want to be careful and only run
        <span><strong class="command">svn resolved</strong></span> when you're certain that you've
        fixed the conflict in your file—once the temporary files
        are removed, Subversion will let you commit the file even if
        it still contains conflict markers.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.tour.cycle.commit"></a>Commit Your Changes</h3></div></div></div><p>Finally!  Your edits are finished, you've merged all
        changes from the server, and you're ready to commit your
        changes to the repository.</p><p>The <span><strong class="command">svn commit</strong></span> command sends all of
        your changes to the repository.  When you commit a change, you
        need to supply a <em class="firstterm">log message</em>,
        describing your change.  Your log message will be attached to
        the new revision you create.  If your log message is brief,
        you may wish to supply it on the command line using the
        <code class="option">--message</code> (or <code class="option">-m</code>)
        option:</p><pre class="screen">
$ svn commit --message "Corrected number of cheese slices."
Sending        sandwich.txt
Transmitting file data .
Committed revision 3.
</pre><p>However, if you've been composing your log message as you
        work, you may want to tell Subversion to get the message from
        a file by passing the filename with the
        <code class="option">--file</code> switch:</p><pre class="screen">
$ svn commit --file logmsg 
Sending        sandwich.txt
Transmitting file data .
Committed revision 4.
</pre><p>If you fail to specify either the
        <code class="option">--message</code> or <code class="option">--file</code> switch,
        then Subversion will automatically launch your favorite editor
        (see the <code class="literal">editor-cmd</code> section in
        <a href="#svn.advanced.confarea.opts.config" title="Config">la sezione chiamata «Config»</a>) for composing a log
        message.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Suggerimento</h3><p>If you're in your editor writing a commit message and
          decide that you want to cancel your commit, you can just
          quit your editor without saving changes.  If you've already
          saved your commit message, simply delete the text and save
          again.</p><pre class="screen">
$ svn commit
Waiting for Emacs...Done

Log message unchanged or not specified
a)bort, c)ontinue, e)dit
a
$
</pre></div><p>The repository doesn't know or care if your changes make
        any sense as a whole; it only checks to make sure that nobody
        else has changed any of the same files that you did when you
        weren't looking.  If somebody <span class="emphasis"><em>has</em></span> done
        that, the entire commit will fail with a message informing you
        that one or more of your files is out-of-date:</p><pre class="screen">
$ svn commit --message "Add another rule"
Sending        rules.txt
svn: Commit failed (details follow):
svn: Out of date: 'rules.txt' in transaction 'g'
</pre><p>At this point, you need to run <span><strong class="command">svn
        update</strong></span>, deal with any merges or conflicts that
        result, and attempt your commit again.</p><p>That covers the basic work cycle for using Subversion.
        There are many other features in Subversion that you can use
        to manage your repository and working copy, but you can get by
        quite easily using only the commands that we've discussed so
        far in this chapter.</p></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.tour.history"></a>Examining History</h2></div></div></div><p>As we mentioned earlier, the repository is like a time
      machine.  It keeps a record of every change ever committed,
      and allows you to explore this history by examining previous
      versions of files and directories as well as the metadata that
      accompanies them.  With a single Subversion command, you can
      check out the repository (or restore an existing working copy)
      exactly as it was at any date or revision number in the past.
      However, sometimes you just want to <span class="emphasis"><em>peer
      into</em></span> the past instead of <span class="emphasis"><em>going
      into</em></span> the past.</p><p>There are several commands that can provide you with
      historical data from the repository:</p><div class="variablelist"><dl><dt><span class="term"><span><strong class="command">svn log</strong></span></span></dt><dd><p>Shows you broad information: log messages with date
              and author information attached to revisions, and which
              paths changed in each revision.</p></dd><dt><span class="term"><span><strong class="command">svn diff</strong></span></span></dt><dd><p>Shows you the specific details of how a file changed
              over time.</p></dd><dt><span class="term"><span><strong class="command">svn cat</strong></span></span></dt><dd><p>This is used to retrieve any file as it existed in a
              particular revision number and display it on your
              screen.</p></dd><dt><span class="term"><span><strong class="command">svn list</strong></span></span></dt><dd><p>Displays the files in a directory for any given
              revision.</p></dd></dl></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.tour.history.log"></a><span><strong class="command">svn log</strong></span></h3></div></div></div><p>To find information about the history of a file or
        directory, use the <span><strong class="command">svn log</strong></span>
        command. <span><strong class="command">svn log</strong></span> will provide you with a
        record of who made changes to a file or directory, at what
        revision it changed, the time and date of that revision, and,
        if it was provided, the log message that accompanied the
        commit.</p><pre class="screen">
$ svn log
------------------------------------------------------------------------
r3 | sally | Mon, 15 Jul 2002 18:03:46 -0500 | 1 line

Added include lines and corrected # of cheese slices.
------------------------------------------------------------------------
r2 | harry | Mon, 15 Jul 2002 17:47:57 -0500 | 1 line

Added main() methods.
------------------------------------------------------------------------
r1 | sally | Mon, 15 Jul 2002 17:40:08 -0500 | 1 line

Initial import
------------------------------------------------------------------------
</pre><p>Note that the log messages are printed in
        <span class="emphasis"><em>reverse chronological order</em></span> by default.
        If you wish to see a different range of revisions in a
        particular order, or just a single revision, pass the
        <code class="option">--revision</code> (<code class="option">-r</code>)
        switch:</p><pre class="screen">
$ svn log --revision 5:19    # shows logs 5 through 19 in chronological order

$ svn log -r 19:5            # shows logs 5 through 19 in reverse order

$ svn log -r 8               # shows log for revision 8
</pre><p>You can also examine the log history of a single file or
        directory.  For example:</p><pre class="screen">
$ svn log foo.c
…
$ svn log http://foo.com/svn/trunk/code/foo.c
…
</pre><p>These will display log messages <span class="emphasis"><em>only</em></span>
        for those revisions in which the working file (or URL)
        changed.</p><p>If you want even more information about a file or
        directory, <span><strong class="command">svn log</strong></span> also takes a
        <code class="option">--verbose</code> (<code class="option">-v</code>) switch.
        Because Subversion allows you to move and copy files and
        directories, it is important to be able to track path changes
        in the filesystem, so in verbose mode, <span><strong class="command">svn
        log</strong></span> will include a list of changed paths in a
        revision in its output:</p><pre class="screen">
$ svn log -r 8 -v
------------------------------------------------------------------------
r8 | sally | 2002-07-14 08:15:29 -0500 | 1 line
Changed paths:
M /trunk/code/foo.c
M /trunk/code/bar.h
A /trunk/code/doc/README

Frozzled the sub-space winch.

------------------------------------------------------------------------
</pre><p>
        <span><strong class="command">svn log</strong></span> also takes a <code class="option">--quiet</code>
        (<code class="option">-q</code>) switch, which suppresses the body of the
        log message.  When combined with <code class="option">--verbose</code>, it
        gives just the names of the changed files.</p><div class="sidebar"><p class="title"><b>Why Does <span><strong class="command">svn log</strong></span> Give Me an Empty
          Response?</b></p><p>After working with Subversion for a bit, most users will
          come across something like this:</p><pre class="screen">
$ svn log -r 2
------------------------------------------------------------------------
$
</pre><p>At first glance, this seems like an error.  But recall
          that while revisions are repository-wide, <span><strong class="command">svn
          log</strong></span> operates on a path in the repository.  If you
          supply no path, Subversion uses the current working
          directory as the default target.  As a result, if you're
          operating in a subdirectory of your working copy and attempt
          to see the log of a revision in which neither that directory
          nor any of its children was changed, Subversion will show you
          an empty log.  If you want to see what changed in that
          revision, try pointing <span><strong class="command">svn log</strong></span> directly at
          the top-most URL of your repository, as in <span><strong class="command">svn log -r 2
          http://svn.collab.net/repos/svn</strong></span>.</p></div></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.tour.history.diff"></a><span><strong class="command">svn diff</strong></span></h3></div></div></div><p>We've already seen <span><strong class="command">svn diff</strong></span>
        before—it displays file differences in unified diff
        format; it was used to show the local modifications made to
        our working copy before committing to the repository.</p><p>In fact, it turns out that there are
        <span class="emphasis"><em>three</em></span> distinct uses of <span><strong class="command">svn
        diff</strong></span>:</p><div class="itemizedlist"><ul type="disc"><li><p>Examine local changes</p></li><li><p>Compare your working copy to the repository</p></li><li><p>Compare repository to repository</p></li></ul></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.tour.history.diff.local"></a>Examining Local Changes</h4></div></div></div><p>As we've seen, invoking <span><strong class="command">svn diff</strong></span> with
          no switches will compare your working files to the cached
          «<span class="quote">pristine</span>» copies in
          the <code class="filename">.svn</code> area:</p><pre class="screen">
$ svn diff
Index: rules.txt
===================================================================
--- rules.txt	(revision 3)
+++ rules.txt	(working copy)
@@ -1,4 +1,5 @@
 Be kind to others
 Freedom = Responsibility
 Everything in moderation
-Chew with your mouth open
+Chew with your mouth closed
+Listen when others are speaking
$
</pre></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.tour.history.diff.wcrepos"></a>Comparing Working Copy to Repository</h4></div></div></div><p>If a single <code class="option">--revision</code>
          (<code class="option">-r</code>) number is passed, then your
          working copy is compared to the specified revision in the
          repository.</p><pre class="screen">
$ svn diff --revision 3 rules.txt 
Index: rules.txt
===================================================================
--- rules.txt	(revision 3)
+++ rules.txt	(working copy)
@@ -1,4 +1,5 @@
 Be kind to others
 Freedom = Responsibility
 Everything in moderation
-Chew with your mouth open
+Chew with your mouth closed
+Listen when others are speaking
$
</pre></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.tour.history.diff.reposrepos"></a>Comparing Repository to Repository</h4></div></div></div><p>If two revision numbers, separated by a colon, are
          passed via <code class="option">--revision</code>
          (<code class="option">-r</code>), then the two revisions are directly
          compared.</p><pre class="screen">
$ svn diff --revision 2:3 rules.txt 
Index: rules.txt
===================================================================
--- rules.txt	(revision 2)
+++ rules.txt	(revision 3)
@@ -1,4 +1,4 @@
 Be kind to others
-Freedom = Chocolate Ice Cream
+Freedom = Responsibility
 Everything in moderation
 Chew with your mouth open
$
</pre><p>Not only can you use <span><strong class="command">svn diff</strong></span> to
          compare files in your working copy to the repository, but if
          you supply a URL argument, you can examine the differences
          between items in the repository without even having a
          working copy.  This is especially useful if you wish to
          inspect changes in a file when you don't have a working copy
          on your local machine:</p><pre class="screen">
$ svn diff --revision 4:5 http://svn.red-bean.com/repos/example/trunk/text/rules.txt
…
$
</pre></div></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.tour.history.cat"></a><span><strong class="command">svn cat</strong></span></h3></div></div></div><p>If you want to examine an earlier version of a file and
        not necessarily the differences between two files, you can use
        <span><strong class="command">svn cat</strong></span>:</p><pre class="screen">
$ svn cat --revision 2 rules.txt 
Be kind to others
Freedom = Chocolate Ice Cream
Everything in moderation
Chew with your mouth open
$
</pre><p>You can also redirect the output directly into a
        file:</p><pre class="screen">
$ svn cat --revision 2 rules.txt &gt; rules.txt.v2
$
</pre><p>You're probably wondering why we don't just use
        <span><strong class="command">svn update --revision</strong></span> to update the file to
        the older revision.  There are a few reasons why we might
        prefer to use <span><strong class="command">svn cat</strong></span>.</p><p>First, you may want to see the differences between two
        revisions of a file using an external diff program (perhaps a
        graphical one, or perhaps your file is in such a format that
        the output of unified diff is nonsensical).  In this case,
        you'll need to grab a copy of the old revision, redirect it to
        a file, and pass both that and the file in your working copy
        to your external diff program.</p><p>Sometimes it's easier to look at an older version of a
        file in its entirety as opposed to just the differences
        between it and another revision.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.tour.history.list"></a><span><strong class="command">svn list</strong></span></h3></div></div></div><p>The <span><strong class="command">svn list</strong></span> command shows you what
        files are in a repository directory without actually
        downloading the files to your local machine:</p><pre class="screen">
$ svn list http://svn.collab.net/repos/svn
README
branches/
clients/
tags/
trunk/
</pre><p>If you want a more detailed listing, pass the
        <code class="option">--verbose</code> (<code class="option">-v</code>) flag to get
        output like this:</p><pre class="screen">
$ svn list --verbose http://svn.collab.net/repos/svn
   2755 harry          1331 Jul 28 02:07 README
   2773 sally               Jul 29 15:07 branches/
   2769 sally               Jul 29 12:07 clients/
   2698 harry               Jul 24 18:07 tags/
   2785 sally               Jul 29 19:07 trunk/
</pre><p>The columns tell you the revision at which the file or
        directory was last modified, the user who modified it, the size
        if it is a file, the date it was last modified, and the item's
        name.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.tour.history.finalword"></a>A Final Word on History</h3></div></div></div><p>In addition to all of the above commands, you can use
        <span><strong class="command">svn update</strong></span> and <span><strong class="command">svn
        checkout</strong></span> with the <code class="option">--revision</code> switch
        to take an entire working copy «<span class="quote">back in time</span>»
        <sup>[<a id="id4735868" href="#ftn.id4735868">7</a>]</sup>:</p><pre class="screen">
$ svn checkout --revision 1729 # Checks out a new working copy at r1729
…
$ svn update --revision 1729 # Updates an existing working copy to r1729
…
</pre></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.tour.other"></a>Other Useful Commands</h2></div></div></div><p>While not as frequently used as the commands previously
        discussed in this chapter, you will occasionally need these
        commands.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.tour.other.cleanup"></a><span><strong class="command">svn cleanup</strong></span></h3></div></div></div><p>When Subversion modifies your working copy (or any
        information within <code class="filename">.svn</code>), it tries to do
        so as safely as possible.  Before changing the working copy,
        Subversion writes its intentions to a log file.  Next it
        executes the commands in the log file to apply the requested
        change, holding a lock on the relevant part of the working
        copy while it works — to prevent othe Subversion clients
        from accessing the working copy in mid-change.  Finally,
        Subversion removes the log file.  Architecturally, this is
        similar to a journaled filesystem.  If a Subversion operation
        is interrupted (if the process is killed, or if the machine
        crashes, for example), the log files remain on disk.  By
        re-executing the log files, Subversion can complete the
        previously started operation, and your working copy can get
        itself back into a consistent state.</p><p>And this is exactly what <span><strong class="command">svn cleanup</strong></span>
        does: it searches your working copy and runs any leftover
        logs, removing working copy locks in the process.
        If Subversion ever tells you that some part of your working copy
        is «<span class="quote">locked</span>», then this is the command that you
        should run.  Also, <span><strong class="command">svn status</strong></span> will display
        an <code class="literal">L</code> next to locked items:</p><pre class="screen">
$ svn status
  L    somedir
M      somedir/foo.c 

$ svn cleanup
$ svn status
M      somedir/foo.c
</pre><p>Don't confuse these working copy locks with the ordinary
        locks that Subversion users create when using
        the «<span class="quote">lock-modify-unlock</span>» model of concurrent
        version control; see
        <a href="#svn.advanced.locking.meanings" title="Three meanings of &#xAB;lock&#xBB;">Three meanings of «<span class="quote">lock</span>»</a> for
        clarification.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.tour.other.import"></a><span><strong class="command">svn import</strong></span></h3></div></div></div><p>The <span><strong class="command">svn import</strong></span> command is a quick way
        to copy an unversioned tree of files into a repository,
        creating intermediate directories as necessary.</p><pre class="screen">
$ svnadmin create /usr/local/svn/newrepos
$ svn import mytree file:///usr/local/svn/newrepos/some/project \
             -m "Initial import"
Adding         mytree/foo.c
Adding         mytree/bar.c
Adding         mytree/subdir
Adding         mytree/subdir/quux.h

Committed revision 1.
</pre><p>The previous example copied the contents of directory
        <code class="filename">mytree</code> under the directory
        <code class="filename">some/project</code> in the repository:</p><pre class="screen">
$ svn list file:///usr/local/svn/newrepos/some/project
bar.c
foo.c
subdir/
</pre><p>Note that after the import is finished, the original tree
        is <span class="emphasis"><em>not</em></span> converted into a working copy.  To
        start working, you still need to <span><strong class="command">svn
        checkout</strong></span> a fresh working copy of the tree.</p></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.tour.summary"></a>Summary</h2></div></div></div><p>Now we've covered most of the Subversion client commands.
        Notable exceptions are those dealing with branching and
        merging (see <a href="#svn.branchmerge" title="Capitolo&#xA0;4.&#xA0;Branching and Merging">Capitolo 4, <i>Branching and Merging</i></a>) and properties (see
        <a href="#svn.advanced.props" title="Properties">la sezione chiamata «Properties»</a>).  However, you may want to
        take a moment to skim through <a href="#svn.ref" title="Capitolo&#xA0;9.&#xA0;Subversion Complete Reference">Capitolo 9, <i>Subversion Complete Reference</i></a> to
        get an idea of all the many different commands that Subversion
        has—and how you can use them to make your work
        easier.</p></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.id4732906" href="#id4732906">3</a>] </sup>Of course, nothing is ever totally
              deleted from the repository—just from the
              <code class="literal">HEAD</code> of the repository.  You can get
              back anything you delete by checking out (or updating
              your working copy) a revision earlier than the one in
              which you deleted it.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4734073" href="#id4734073">4</a>] </sup>Subversion uses its internal diff
          engine, which produces unified diff format, by default.  If
          you want diff output in a different format, specify an
          external diff program using <code class="option">--diff-cmd</code> and
          pass any flags you'd like to it using the
          <code class="option">--extensions</code> switch.  For example, to see
          local differences in file <code class="filename">foo.c</code> in
          context output format while ignoring whitespace changes, you
          might run <span><strong class="command">svn diff --diff-cmd /usr/bin/diff
          --extensions '-bc' foo.c</strong></span>.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4734795" href="#id4734795">5</a>] </sup>You can always remove the temporary
        files yourself, but would you really want to do that when
        Subversion can do it for you?  We didn't think so.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4734892" href="#id4734892">6</a>] </sup>And if you
          ask them for it, they may very well ride you out of town on
          a rail.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4735868" href="#id4735868">7</a>] </sup>See?  We told you that Subversion was a time
        machine.</p></div></div></div><div class="chapter" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title"><a id="svn.branchmerge"></a>Capitolo 4. Branching and Merging</h2></div></div></div><div class="toc"><p><b>Sommario</b></p><dl><dt><span class="sect1"><a href="#svn.branchmerge.whatis">What's a Branch?</a></span></dt><dt><span class="sect1"><a href="#svn.branchmerge.using">Using Branches</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.branchmerge.using.create">Creating a Branch</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.using.work">Working with Your Branch</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.using.concepts">The Key Concepts Behind Branches</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.branchmerge.copychanges">Copying Changes Between Branches</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.branchmerge.copychanges.specific">Copying Specific Changes</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.copychanges.keyconcept">The Key Concept Behind Merging</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.copychanges.bestprac">Best Practices for Merging</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.branchmerge.copychanges.bestprac.track">Tracking Merges Manually</a></span></dt><dt><span class="sect3"><a href="#svn.branchmerge.copychanges.bestprac.preview">Previewing Merges</a></span></dt><dt><span class="sect3"><a href="#svn.branchmerge.copychanges.bestprac.merge">Merge Conflicts</a></span></dt><dt><span class="sect3"><a href="#svn.branchmerge.copychanges.bestprac.ancestry">Noticing or Ignoring Ancestry</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.branchmerge.commonuses">Common Use-Cases</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.branchmerge.commonuses.wholebr">Merging a Whole Branch to Another</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.commonuses.undo">Undoing Changes</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.commonuses.resurrect">Resurrecting Deleted Items</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.commonuses.patterns">Common Branching Patterns</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.branchmerge.commonuses.patterns.release">Release Branches</a></span></dt><dt><span class="sect3"><a href="#svn.branchmerge.commonuses.patterns.feature">Feature Branches</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.branchmerge.switchwc">Switching a Working Copy</a></span></dt><dt><span class="sect1"><a href="#svn.branchmerge.tags">Tags</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.branchmerge.tags.mksimple">Creating a Simple Tag</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.tags.mkcomplex">Creating a Complex Tag</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.branchmerge.maint">Branch Maintenance</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.branchmerge.maint.layout">Repository Layout</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.maint.lifetime">Data Lifetimes</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.branchmerge.summary">Summary</a></span></dt></dl></div><div class="simplesect" lang="it" xml:lang="it"><div class="titlepage"></div><p>Branching, tagging, and merging are concepts common to
      almost all version control systems.  If you're not familiar with
      these ideas, we provide a good introduction in this chapter.  If
      you are familiar, then hopefully you'll find it interesting to
      see how Subversion implements these ideas.</p><p>Branching is a fundamental part of version control.  If
      you're going to allow Subversion to manage your data, then this
      is a feature you'll eventually come to depend on.  This chapter
      assumes that you're already familiar with Subversion's basic
      concepts (<a href="#svn.basic" title="Capitolo&#xA0;2.&#xA0;Basic Concepts">Capitolo 2, <i>Basic Concepts</i></a>).</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.branchmerge.whatis"></a>What's a Branch?</h2></div></div></div><p>Suppose it's your job to maintain a document for a division
      in your company, a handbook of some sort.  One day a different
      division asks you for the same handbook, but with a few parts
      «<span class="quote">tweaked</span>» for them, since they do things slightly
      differently.</p><p>What do you do in this situation?  You do the obvious thing:
      you make a second copy of your document, and begin maintaining
      the two copies separately.  As each department asks you to make
      small changes, you incorporate them into one copy or the
      other.</p><p>You often want to make the same change to both copies.  For
      example, if you discover a typo in the first copy, it's very
      likely that the same typo exists in the second copy.  The two
      documents are almost the same, after all; they only differ in
      small, specific ways.</p><p>This is the basic concept of a
      <em class="firstterm">branch</em>—namely, a line of
      development that exists independently of another line, yet still
      shares a common history if you look far enough back in time.  A
      branch always begins life as a copy of something, and moves on
      from there, generating its own history (see <a href="#svn.branchmerge.whatis.dia-1" title="Figura&#xA0;4.1.&#xA0;Branches of development">Figura 4.1, «Branches of development»</a>).</p><div class="figure"><a id="svn.branchmerge.whatis.dia-1"></a><p class="title"><b>Figura 4.1. Branches of development</b></p><div class="figure-contents"><div><img src="images/ch04dia1.png" alt="Branches of development" /></div></div></div><br class="figure-break" /><p>Subversion has commands to help you maintain parallel
      branches of your files and directories.  It allows you to create
      branches by copying your data, and remembers that the copies are
      related to one another.  It also helps you duplicate changes
      from one branch to another.  Finally, it can make portions of
      your working copy reflect different branches, so that you can
      «<span class="quote">mix and match</span>» different lines of development in
      your daily work.</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.branchmerge.using"></a>Using Branches</h2></div></div></div><p>At this point, you should understand how each commit creates
      an entire new filesystem tree (called a «<span class="quote">revision</span>»)
      in the repository.  If not, go back and read about revisions in
      <a href="#svn.basic.in-action.revs" title="Revisions">la sezione chiamata «Revisions»</a>.</p><p>For this chapter, we'll go back to the same example from
      Chapter 2.  Remember that you and your collaborator, Sally, are
      sharing a repository that contains two projects,
      <code class="filename">paint</code> and <code class="filename">calc</code>.
      Notice that in <a href="#svn.branchmerge.using.dia-1" title="Figura&#xA0;4.2.&#xA0;Starting repository layout">Figura 4.2, «Starting repository layout»</a>, however, each
      project directory now contains subdirectories named
      <code class="filename">trunk</code> and <code class="filename">branches</code>.
      The reason for this will soon become clear.</p><div class="figure"><a id="svn.branchmerge.using.dia-1"></a><p class="title"><b>Figura 4.2. Starting repository layout</b></p><div class="figure-contents"><div><img src="images/ch04dia2.png" alt="Starting repository layout" /></div></div></div><br class="figure-break" /><p>As before, assume that Sally and you both have working
      copies of the «<span class="quote">calc</span>» project.  Specifically, you
      each have a working copy of <code class="filename">/calc/trunk</code>.
      All the files for the project are in this subdirectory rather
      than in <code class="filename">/calc</code> itself, because your team has
      decided that <code class="filename">/calc/trunk</code> is where the
      «<span class="quote">main line</span>» of development is going to take
      place.</p><p>Let's say that you've been given the task of performing a
      radical reorganization of the project.  It will take a long time
      to write, and will affect all the files in the project.  The
      problem here is that you don't want to interfere with Sally, who
      is in the process of fixing small bugs here and there.  She's
      depending on the fact that the latest version of the project (in
      <code class="filename">/calc/trunk</code>) is always usable.  If you
      start committing your changes bit-by-bit, you'll surely break
      things for Sally.</p><p>One strategy is to crawl into a hole: you and Sally can stop
      sharing information for a week or two.  That is, start gutting
      and reorganizing all the files in your working copy, but don't
      commit or update until you're completely finished with the task.
      There are a number of problems with this, though.  First, it's
      not very safe.  Most people like to save their work to the
      repository frequently, should something bad accidentally happen
      to their working copy.  Second, it's not very flexible.  If you
      do your work on different computers (perhaps you have a working
      copy of <code class="filename">/calc/trunk</code> on two different
      machines), you'll need to manually copy your changes back and
      forth, or just do all the work on a single computer.  By that
      same token, it's difficult to share your changes-in-progress
      with anyone else.  A common software development «<span class="quote">best
      practice</span>» is to allow your peers to review your work as you
      go.  If nobody sees your intermediate commits, you lose
      potential feedback.  Finally, when you're finished with all your
      changes, you might find it very difficult to re-merge your final
      work with the rest of the company's main body of code.  Sally
      (or others) may have made many other changes in the repository
      that are difficult to incorporate into your working
      copy—especially if you run <span><strong class="command">svn update</strong></span>
      after weeks of isolation.</p><p>The better solution is to create your own branch, or line of
      development, in the repository.  This allows you to save your
      half-broken work frequently without interfering with others, yet
      you can still selectively share information with your
      collaborators.  You'll see exactly how this works later
      on.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.using.create"></a>Creating a Branch</h3></div></div></div><p>Creating a branch is very simple—you make a copy of
        the project in the repository using the <span><strong class="command">svn
        copy</strong></span> command.  Subversion is not only able to copy
        single files, but whole directories as well.  In this case,
        you want to make a copy of the
        <code class="filename">/calc/trunk</code> directory.  Where should the
        new copy live?  Wherever you wish—it's a matter of
        project policy.  Let's say that your team has a policy of
        creating branches in the <code class="filename">/calc/branches</code>
        area of the repository, and you want to name your branch
        <code class="literal">my-calc-branch</code>.  You'll want to create a
        new directory,
        <code class="filename">/calc/branches/my-calc-branch</code>, which
        begins its life as a copy of
        <code class="filename">/calc/trunk</code>.</p><p>There are two different ways to make a copy.  We'll
        demonstrate the messy way first, just to make the concept
        clear.  To begin, check out a working copy of the project's
        root directory, <code class="filename">/calc</code>:</p><pre class="screen">
$ svn checkout http://svn.example.com/repos/calc bigwc
A  bigwc/trunk/
A  bigwc/trunk/Makefile
A  bigwc/trunk/integer.c
A  bigwc/trunk/button.c
A  bigwc/branches/
Checked out revision 340.
</pre><p>Making a copy is now simply a matter of passing two
        working-copy paths to the <span><strong class="command">svn copy</strong></span>
        command:</p><pre class="screen">
$ cd bigwc
$ svn copy trunk branches/my-calc-branch
$ svn status
A  +   branches/my-calc-branch
</pre><p>In this case, the <span><strong class="command">svn copy</strong></span> command
        recursively copies the <code class="filename">trunk</code> working
        directory to a new working directory,
        <code class="filename">branches/my-calc-branch</code>.  As you can see
        from the <span><strong class="command">svn status</strong></span> command, the new
        directory is now scheduled for addition to the repository.
        But also notice the «<span class="quote">+</span>» sign next to the letter
        A.  This indicates that the scheduled addition is a
        <span class="emphasis"><em>copy</em></span> of something, not something new.
        When you commit your changes, Subversion will create
        <code class="filename">/calc/branches/my-calc-branch</code> in the
        repository by copying <code class="filename">/calc/trunk</code>, rather
        than resending all of the working copy data over the
        network:</p><pre class="screen">
$ svn commit -m "Creating a private branch of /calc/trunk."
Adding         branches/my-calc-branch
Committed revision 341.
</pre><p>And now the easier method of creating a branch, which we
        should have told you about in the first place: <span><strong class="command">svn
        copy</strong></span> is able to operate directly on two URLs.</p><pre class="screen">
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/branches/my-calc-branch \
      -m "Creating a private branch of /calc/trunk."

Committed revision 341.
</pre><p>There's really no difference between these two methods.
        Both procedures create a new directory in revision 341, and
        the new directory is a copy of
        <code class="filename">/calc/trunk</code>.  This is shown in <a href="#svn.branchmerge.using.create.dia-1" title="Figura&#xA0;4.3.&#xA0;Repository with new copy">Figura 4.3, «Repository with new copy»</a>.  Notice that the second method,
        however, performs an <span class="emphasis"><em>immediate</em></span> commit.
        <sup>[<a id="id4736664" href="#ftn.id4736664">8</a>]</sup>
        It's an easier procedure, because it doesn't require you to
        check out a large mirror of the repository.  In fact, this
        technique doesn't even require you to have a working copy at
        all.</p><div class="figure"><a id="svn.branchmerge.using.create.dia-1"></a><p class="title"><b>Figura 4.3. Repository with new copy</b></p><div class="figure-contents"><div><img src="images/ch04dia3.png" alt="Repository with new copy" /></div></div></div><br class="figure-break" /><div class="sidebar"><p class="title"><b>Cheap Copies</b></p><p>Subversion's repository has a special design.  When you
          copy a directory, you don't need to worry about the
          repository growing huge—Subversion doesn't actually
          duplicate any data.  Instead, it creates a new directory
          entry that points to an <span class="emphasis"><em>existing</em></span> tree.
          If you're a Unix user, this is the same concept as a
          hard-link.  From there, the copy is said to be
          «<span class="quote">lazy</span>».  That is, if you commit a change to one
          file within the copied directory, then only that file
          changes—the rest of the files continue to exist as
          links to the original files in the original
          directory.</p><p>This is why you'll often hear Subversion users talk
          about «<span class="quote">cheap copies</span>».  It doesn't matter how
          large the directory is—it takes a very tiny, constant
          amount of time to make a copy of it.  In fact, this feature
          is the basis of how commits work in Subversion: each
          revision is a «<span class="quote">cheap copy</span>» of the previous
          revision, with a few items lazily changed within.  (To read
          more about this, visit Subversion's website and read about
          the «<span class="quote">bubble up</span>» method in Subversion's design
          documents.)</p><p>Of course, these internal mechanics of copying and
          sharing data are hidden from the user, who simply sees
          copies of trees.  The main point here is that copies are
          cheap, both in time and space.  Make branches as often as
          you want.</p></div></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.using.work"></a>Working with Your Branch</h3></div></div></div><p>Now that you've created a branch of the project, you can
        check out a new working copy to start using it:</p><pre class="screen">
$ svn checkout http://svn.example.com/repos/calc/branches/my-calc-branch
A  my-calc-branch/Makefile
A  my-calc-branch/integer.c
A  my-calc-branch/button.c
Checked out revision 341.
</pre><p>There's nothing special about this working copy; it simply
        mirrors a different directory in the repository.  When you
        commit changes, however, Sally won't ever see them when she
        updates.  Her working copy is of
        <code class="filename">/calc/trunk</code>.  (Be sure to read <a href="#svn.branchmerge.switchwc" title="Switching a Working Copy">la sezione chiamata «Switching a Working Copy»</a> later in this chapter: the
        <span><strong class="command">svn switch</strong></span> command is an alternate way of
        creating a working copy of a branch.)</p><p>Let's pretend that a week goes by, and the following
        commits happen:</p><div class="itemizedlist"><ul type="disc"><li><p>
          You make a change to
          <code class="filename">/calc/branches/my-calc-branch/button.c</code>,
          which creates revision 342.</p></li><li><p>
          You make a change to
          <code class="filename">/calc/branches/my-calc-branch/integer.c</code>,
          which creates revision 343.</p></li><li><p>
          Sally makes a change to
          <code class="filename">/calc/trunk/integer.c</code>, which creates
          revision 344.</p></li></ul></div><p>There are now two independent lines of development, shown
        in <a href="#svn.branchmerge.using.work.dia-1" title="Figura&#xA0;4.4.&#xA0;The branching of one file's history">Figura 4.4, «The branching of one file's history»</a>, happening on
        <code class="filename">integer.c</code>.</p><div class="figure"><a id="svn.branchmerge.using.work.dia-1"></a><p class="title"><b>Figura 4.4. The branching of one file's history</b></p><div class="figure-contents"><div><img src="images/ch04dia4.png" alt="The branching of one file's history" /></div></div></div><br class="figure-break" /><p>Things get interesting when you look at the history of
        changes made to your copy of
        <code class="filename">integer.c</code>:</p><pre class="screen">
$ pwd
/home/user/my-calc-branch

$ svn log --verbose integer.c
------------------------------------------------------------------------
r343 | user | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   M /calc/branches/my-calc-branch/integer.c

* integer.c:  frozzled the wazjub.

------------------------------------------------------------------------
r341 | user | 2002-11-03 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)

Creating a private branch of /calc/trunk.

------------------------------------------------------------------------
r303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  changed a docstring.

------------------------------------------------------------------------
r98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  adding this file to the project.

------------------------------------------------------------------------
</pre><p>Notice that Subversion is tracing the history of your
        branch's <code class="filename">integer.c</code> all the way back
        through time, even traversing the point where it was copied.
        It shows the creation of the branch as an event in the
        history, because <code class="filename">integer.c</code> was implicitly
        copied when all of <code class="filename">/calc/trunk/</code> was
        copied.  Now look what happens when Sally runs the same
        command on her copy of the file:</p><pre class="screen">
$ pwd
/home/sally/calc

$ svn log --verbose integer.c
------------------------------------------------------------------------
r344 | sally | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  fix a bunch of spelling errors.

------------------------------------------------------------------------
r303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  changed a docstring.

------------------------------------------------------------------------
r98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  adding this file to the project.

------------------------------------------------------------------------
</pre><p>Sally sees her own revision 344 change, but not the change
        you made in revision 343.  As far as Subversion is concerned,
        these two commits affected different files in different
        repository locations.  However, Subversion
        <span class="emphasis"><em>does</em></span> show that the two files share a
        common history.  Before the branch-copy was made in revision
        341, they used to be the same file.  That's why you and Sally
        both see the changes made in revisions 303 and 98.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.using.concepts"></a>The Key Concepts Behind Branches</h3></div></div></div><p>There are two important lessons that you should remember
        from this section.</p><div class="orderedlist"><ol type="1"><li><p>Unlike many other version control systems,
            Subversion's branches exist as <span class="emphasis"><em>normal filesystem
            directories</em></span> in the repository, not in an extra
            dimension.  These directories just happen to carry some
            extra historical information.</p></li><li><p>Subversion has no internal concept of a
            branch—only copies.  When you copy a directory, the
            resulting directory is only a «<span class="quote">branch</span>»
            because <span class="emphasis"><em>you</em></span> attach that meaning to
            it.  You may think of the directory differently, or treat
            it differently, but to Subversion it's just an ordinary
            directory that happens to have been created by
            copying.</p></li></ol></div></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.branchmerge.copychanges"></a>Copying Changes Between Branches</h2></div></div></div><p>Now you and Sally are working on parallel branches of the
      project: you're working on a private branch, and Sally is
      working on the <em class="firstterm">trunk</em>, or main line of
      development.</p><p>For projects that have a large number of contributors, it's
      common for most people to have working copies of the trunk.
      Whenever someone needs to make a long-running change that is
      likely to disrupt the trunk, a standard procedure is to create a
      private branch and commit changes there until all the work is
      complete.</p><p>So, the good news is that you and Sally aren't interfering
      with each other.  The bad news is that it's very easy to drift
      <span class="emphasis"><em>too</em></span> far apart.  Remember that one of the
      problems with the «<span class="quote">crawl in a hole</span>» strategy is
      that by the time you're finished with your branch, it may be
      near-impossible to merge your changes back into the trunk
      without a huge number of conflicts.</p><p>Instead, you and Sally might continue to share changes as
      you work.  It's up to you to decide which changes are worth
      sharing; Subversion gives you the ability to selectively
      «<span class="quote">copy</span>» changes between branches.  And when you're
      completely finished with your branch, your entire set of branch
      changes can be copied back into the trunk.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.copychanges.specific"></a>Copying Specific Changes</h3></div></div></div><p>In the previous section, we mentioned that both you and
        Sally made changes to <code class="filename">integer.c</code> on
        different branches.  If you look at Sally's log message for
        revision 344, you can see that she fixed some spelling errors.
        No doubt, your copy of the same file still has the same spelling
        errors.  It's likely that your future changes to this file will
        be affecting the same areas that have the spelling errors, so
        you're in for some potential conflicts when you merge your
        branch someday.  It's better, then, to receive Sally's change
        now, <span class="emphasis"><em>before</em></span> you start working too heavily
        in the same places.</p><p>It's time to use the <span><strong class="command">svn merge</strong></span> command.
        This command, it turns out, is a very close cousin to the
        <span><strong class="command">svn diff</strong></span> command (which you read about in
        Chapter 3).  Both commands are able to compare any two objects
        in the repository and describe the differences.  For example,
        you can ask <span><strong class="command">svn diff</strong></span> to show you the exact
        change made by Sally in revision 344:</p><pre class="screen">
$ svn diff -r 343:344 http://svn.example.com/repos/calc/trunk

Index: integer.c
===================================================================
--- integer.c	(revision 343)
+++ integer.c	(revision 344)
@@ -147,7 +147,7 @@
     case 6:  sprintf(info-&gt;operating_system, "HPFS (OS/2 or NT)"); break;
     case 7:  sprintf(info-&gt;operating_system, "Macintosh"); break;
     case 8:  sprintf(info-&gt;operating_system, "Z-System"); break;
-    case 9:  sprintf(info-&gt;operating_system, "CPM"); break;
+    case 9:  sprintf(info-&gt;operating_system, "CP/M"); break;
     case 10:  sprintf(info-&gt;operating_system, "TOPS-20"); break;
     case 11:  sprintf(info-&gt;operating_system, "NTFS (Windows NT)"); break;
     case 12:  sprintf(info-&gt;operating_system, "QDOS"); break;
@@ -164,7 +164,7 @@
     low = (unsigned short) read_byte(gzfile);  /* read LSB */
     high = (unsigned short) read_byte(gzfile); /* read MSB */
     high = high &lt;&lt; 8;  /* interpret MSB correctly */
-    total = low + high; /* add them togethe for correct total */
+    total = low + high; /* add them together for correct total */
 
     info-&gt;extra_header = (unsigned char *) my_malloc(total);
     fread(info-&gt;extra_header, total, 1, gzfile);
@@ -241,7 +241,7 @@
      Store the offset with ftell() ! */
 
   if ((info-&gt;data_offset = ftell(gzfile))== -1) {
-    printf("error: ftell() retturned -1.\n");
+    printf("error: ftell() returned -1.\n");
     exit(1);
   }
 
@@ -249,7 +249,7 @@
   printf("I believe start of compressed data is %u\n", info-&gt;data_offset);
   #endif
   
-  /* Set postion eight bytes from the end of the file. */
+  /* Set position eight bytes from the end of the file. */
 
   if (fseek(gzfile, -8, SEEK_END)) {
     printf("error: fseek() returned non-zero\n");
</pre><p>The <span><strong class="command">svn merge</strong></span> command is almost exactly
        the same.  Instead of printing the differences to your
        terminal, however, it applies them directly to your working
        copy as <span class="emphasis"><em>local modifications</em></span>:</p><pre class="screen">
$ svn merge -r 343:344 http://svn.example.com/repos/calc/trunk
U  integer.c

$ svn status
M  integer.c
</pre><p>The output of <span><strong class="command">svn merge</strong></span> shows that your
        copy of <code class="filename">integer.c</code> was patched.  It now
        contains Sally's change—the change has been
        «<span class="quote">copied</span>» from the trunk to your working copy of
        your private branch, and now exists as a local modification.
        At this point, it's up to you to review the local modification
        and make sure it works correctly.</p><p>In another scenario, it's possible that things may not have
        gone so well, and that <code class="filename">integer.c</code> may have
        entered a conflicted state.  You might need to resolve the
        conflict using standard procedures (see Chapter 3), or if you
        decide that the merge was a bad idea altogether, simply give up
        and <span><strong class="command">svn revert</strong></span> the local change.</p><p>But assuming that you've reviewed the merged change, you can
        <span><strong class="command">svn commit</strong></span> the change as usual.  At that
        point, the change has been merged into your repository branch.
        In version control terminology, this act of copying changes
        between branches is commonly called
        <em class="firstterm">porting</em> changes.</p><p>When you commit the local modification, make sure your log
        message mentions that you're porting a specific change from
        one branch to another.  For example:</p><pre class="screen">
$ svn commit -m "integer.c: ported r344 (spelling fixes) from trunk."
Sending        integer.c
Transmitting file data .
Committed revision 360.
</pre><p>As you'll see in the next sections, this is a very
        important «<span class="quote">best practice</span>» to follow.</p><div class="sidebar"><p class="title"><b>Why Not Use Patches Instead?</b></p><p>A question may be on your mind, especially if you're a
          Unix user: why bother to use <span><strong class="command">svn merge</strong></span> at
          all?  Why not simply use the operating system's
          <span><strong class="command">patch</strong></span> command to accomplish the same job?
          For example:</p><pre class="screen">
$ svn diff -r 343:344 http://svn.example.com/repos/calc/trunk &gt; patchfile
$ patch -p0  &lt; patchfile
Patching file integer.c using Plan A...
Hunk #1 succeeded at 147.
Hunk #2 succeeded at 164.
Hunk #3 succeeded at 241.
Hunk #4 succeeded at 249.
done
</pre><p>In this particular case, yes, there really is no
          difference.  But <span><strong class="command">svn merge</strong></span> has special
          abilities that surpass the <span><strong class="command">patch</strong></span> program.
          The file format used by <span><strong class="command">patch</strong></span> is quite
          limited; it's only able to tweak file contents.  There's no
          way to represent changes to <span class="emphasis"><em>trees</em></span>, such
          as the addition, removal, or renaming of files and
          directories.  If Sally's change had, say, added a new
          directory, the output of <span><strong class="command">svn diff</strong></span>
          wouldn't have mentioned it at all.  <span><strong class="command">svn
          diff</strong></span> only outputs the limited patch-format, so
          there are some ideas it simply can't express.
          <sup>[<a id="id4737444" href="#ftn.id4737444">9</a>]</sup>
          The <span><strong class="command">svn merge</strong></span> command, however, can express
          changes in tree structure and properties by directly applying
          them to your working copy.</p></div><p>A word of warning: while <span><strong class="command">svn diff</strong></span> and
        <span><strong class="command">svn merge</strong></span> are very similar in concept, they
        do have different syntax in many cases.  Be sure to read about
        them in Chapter 9 for details, or ask <span><strong class="command">svn
        help</strong></span>.  For example, <span><strong class="command">svn merge</strong></span>
        requires a working-copy path as a target, i.e. a place where
        it should apply the tree-changes.  If the target isn't
        specified, it assumes you are trying to perform one of the
        following common operations:</p><div class="orderedlist"><ol type="1"><li><p>You want to merge directory changes into your current
            working directory.</p></li><li><p>You want to merge the changes in a specific file into
            a file by the same name which exists in your current working 
            directory.</p></li></ol></div><p>If you are merging a directory and haven't specified a
        target path, <span><strong class="command">svn merge</strong></span> assumes the first case
        above and tries to apply the changes into your current
        directory.  If you are merging a file, and that file (or a file
        by the same name) exists in your current working directory,
        <span><strong class="command">svn merge</strong></span> assumes the second case and tries
        to apply the changes to a local file with the same name.</p><p>If you want changes applied somewhere else, you'll
        need to say so.  For example, if you're sitting in the parent
        directory of your working copy, you'll have to specify the
        target directory to receive the changes:</p><pre class="screen">
$ svn merge -r 343:344 http://svn.example.com/repos/calc/trunk my-calc-branch
U   my-calc-branch/integer.c
</pre></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.copychanges.keyconcept"></a>The Key Concept Behind Merging</h3></div></div></div><p>You've now seen an example of the <span><strong class="command">svn
          merge</strong></span> command, and you're about to see several
          more.  If you're feeling confused about exactly how merging
          works, you're not alone.  Many users (especially those new
          to version control) are initially perplexed about the proper
          syntax of the command, and about how and when the feature
          should be used.  But fear not, this command is actually much
          simpler than you think!  There's a very easy technique for
          understanding exactly how <span><strong class="command">svn merge</strong></span>
          behaves.</p><p>The main source of confusion is the
        <span class="emphasis"><em>name</em></span> of the command.  The term
        «<span class="quote">merge</span>» somehow denotes that branches are
        combined together, or that there's some sort of mysterious
        blending of data going on.  That's not the case.  A better
        name for the command might have been <span><strong class="command">svn
        diff-and-apply</strong></span>, because that's all that happens:
        two repository trees are compared, and the differences are
        applied to a working copy.</p><p>The command takes three arguments:</p><div class="orderedlist"><ol type="1"><li><p>An initial repository tree (often called the
        <em class="firstterm">left side</em> of the
        comparison),</p></li><li><p>A final repository tree (often called the
        <em class="firstterm">right side</em> of the
        comparison),</p></li><li><p>A working copy to accept the differences as
        local changes (often called the <em class="firstterm">target</em>
        of the merge).</p></li></ol></div><p>Once these three arguments are specified, the two trees
        are compared, and the resulting differences are applied to the
        target working copy as local modifications.  When the command
        is done, the results are no different than if you had
        hand-edited the files, or run various <span><strong class="command">svn
        add</strong></span> or <span><strong class="command">svn delete</strong></span> commands
        yourself.  If you like the results, you can commit them.  If
        you don't like the results, you can simply <span><strong class="command">svn
        revert</strong></span> all of the changes.</p><p>The syntax of <span><strong class="command">svn merge</strong></span> allows you to
        specify the three necessary arguments rather flexibly.  Here
        are some examples:</p><pre class="screen">      
$ svn merge http://svn.example.com/repos/branch1@150 \
            http://svn.example.com/repos/branch2@212 \
            my-working-copy
            
$ svn merge -r 100:200 http://svn.example.com/repos/trunk my-working-copy

$ svn merge -r 100:200 http://svn.example.com/repos/trunk
</pre><p>The first syntax lays out all three arguments explicitly,
        naming each tree in the form <span class="emphasis"><em>URL@REV</em></span> and
        naming the working copy target.  The second syntax can be used
        as a shorthand for situations when you're comparing two
        different revisions of the same URL.  The last syntax shows
        how the working-copy argument is optional; if omitted, it
        defaults to the current directory.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.copychanges.bestprac"></a>Best Practices for Merging</h3></div></div></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.branchmerge.copychanges.bestprac.track"></a>Tracking Merges Manually</h4></div></div></div><p>Merging changes sounds simple enough, but in practice it
          can become a headache.  The problem is that if you
          repeatedly merge changes from one branch to another, you
          might accidentally merge the same change
          <span class="emphasis"><em>twice</em></span>.  When this happens, sometimes
          things will work fine.  When patching a file, Subversion
          typically notices if the file already has the change, and
          does nothing.  But if the already-existing change has been
          modified in any way, you'll get a conflict.</p><p>Ideally, your version control system should prevent the
          double-application of changes to a branch.  It should
          automatically remember which changes a branch has already
          received, and be able to list them for you.  It should use
          this information to help automate merges as much as
          possible.</p><p>Unfortunately, Subversion is not such a system.  Like
          CVS, Subversion does not yet record any information about
          merge operations.  When you commit local modifications, the
          repository has no idea whether those changes came from
          running <span><strong class="command">svn merge</strong></span>, or from just
          hand-editing the files.</p><p>What does this mean to you, the user?  It means that
          until the day Subversion grows this feature, you'll have to
          track merge information yourself.  The best place to do this
          is in the commit log-message.  As demonstrated in the
          earlier example, it's recommended that your log-message
          mention a specific revision number (or range of revisions)
          that are being merged into your branch.  Later on, you can
          run <span><strong class="command">svn log</strong></span> to review which changes your
          branch already contains.  This will allow you to carefully
          construct a subsequent <span><strong class="command">svn merge</strong></span> command
          that won't be redundant with previously ported
          changes.</p><p>In the next section, we'll show some examples of this
          technique in action.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.branchmerge.copychanges.bestprac.preview"></a>Previewing Merges</h4></div></div></div><p>Because merging only results in local modifications,
          it's not usually a high-risk operation.  If you get the
          merge wrong the first time, simply <span><strong class="command">svn
          revert</strong></span> the changes and try again.</p><p>It's possible, however, that your working copy might
          already have local modifications.  The changes applied by a
          merge will be mixed with your pre-existing ones, and running
          <span><strong class="command">svn revert</strong></span> is no longer an option.  The
          two sets of changes may be impossible to separate.</p><p>In cases like this, people take comfort in being able to
          predict or examine merges before they happen.  One simple
          way to do that is to run <span><strong class="command">svn diff</strong></span> with
          the same arguments you plan to pass to <span><strong class="command">svn
          merge</strong></span>, as we already showed in our first example
          of merging.  Another method of previewing is to pass the
          <code class="option">--dry-run</code> option to the merge
          command:</p><pre class="screen">
$ svn merge --dry-run -r 343:344 http://svn.example.com/repos/calc/trunk
U  integer.c

$ svn status
#  nothing printed, working copy is still unchanged.
</pre><p>The <code class="option">--dry-run</code> option doesn't actually
          apply any local changes to the working copy.  It only shows
          status codes that <span class="emphasis"><em>would</em></span> be printed in a
          real merge.  It's useful for getting a «<span class="quote">high
          level</span>» preview of the potential merge, for those
          times when running <span><strong class="command">svn diff</strong></span> gives too
          much detail.</p></div><div class="sidebar"><p class="title"><b>Subversion and Changesets</b></p><p>Everyone seems to have a slightly different definition
          of «<span class="quote">changeset</span>», or at least a different
          expectation of what it means for a version control system to
          have «<span class="quote">changeset features</span>».  For our purpose,
          let's say that a changeset is just a collection of changes
          with a unique name.  The changes might include textual edits
          to file contents, modifications to tree structure, or tweaks
          to metadata.  In more common speak, a changeset is just a
          patch with a name you can refer to.</p><p>In Subversion, a global revision number N names a tree
          in the repository: it's the way the repository looked after
          the Nth commit.  It's also the name of an implicit
          changeset: if you compare tree N with tree N-1, you can
          derive the exact patch that was committed.  For this reason,
          it's easy to think of «<span class="quote">revision N</span>» as not just
          a tree, but a changeset as well.  If you use an issue
          tracker to manage bugs, you can use the revision numbers to
          refer to particular patches that fix bugs—for example,
          «<span class="quote">this issue was fixed by revision 9238.</span>».
          Somebody can then run <span><strong class="command">svn log -r9238</strong></span> to
          read about the exact changeset which fixed the bug, and run
          <span><strong class="command">svn diff -r9237:9238</strong></span> to see the patch
          itself.  And Subversion's <code class="literal">merge</code> command
          also uses revision numbers.  You can merge specific changesets
          from one branch to another by naming them in the merge
          arguments: <span><strong class="command">svn merge -r9237:9238</strong></span> would
          merge changeset #9238 into your working copy.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.branchmerge.copychanges.bestprac.merge"></a>Merge Conflicts</h4></div></div></div><p>Just like the <span><strong class="command">svn update</strong></span> command,
          <span><strong class="command">svn merge</strong></span> applies changes to your working
          copy.  And therefore it's also capable of creating
          conflicts.  The conflicts produced by <span><strong class="command">svn
          merge</strong></span>, however, are sometimes different, and this
          section explains those differences.</p><p>To begin with, assume that your working copy has no
          local edits.  When you <span><strong class="command">svn update</strong></span> to a
          particular revision, the changes sent by the server will
          always apply «<span class="quote">cleanly</span>» to your working copy.
          The server produces the delta by comparing two trees: a
          virtual snapshot of your working copy, and the revision tree
          you're interested in.  Because the left-hand side of the
          comparison is exactly equal to what you already have, the
          delta is guaranteed to correctly convert your working copy
          into the right-hand tree.</p><p>But <span><strong class="command">svn merge</strong></span> has no such guarantees
          and can be much more chaotic: the user can ask the server to
          compare <span class="emphasis"><em>any</em></span> two trees at all, even ones
          that are unrelated to the working copy!  This means there's
          large potential for human error.  Users will sometimes
          compare the wrong two trees, creating a delta that doesn't
          apply cleanly.  <span><strong class="command">svn merge</strong></span> will do its
          best to apply as much of the delta as possible, but some
          parts may be impossible.  Just like the Unix
          <span><strong class="command">patch</strong></span> command sometimes complains about
          «<span class="quote">failed hunks</span>», <span><strong class="command">svn merge</strong></span>
          will complain about «<span class="quote">skipped targets</span>»:</p><pre class="screen">
$ svn merge -r 1288:1351 http://svn.example.com/repos/branch
U  foo.c
U  bar.c
Skipped missing target: 'baz.c'
U  glub.c
C  glorb.h

$
</pre><p>In the previous example it might be the case that
          <code class="filename">baz.c</code> exists in both snapshots of the
          branch being compared, and the resulting delta wants to
          change the file's contents, but the file doesn't exist in
          the working copy.  Whatever the case, the
          «<span class="quote">skipped</span>» message means that the user is most
          likely comparing the wrong two trees; they're the classic
          sign of driver error.  When this happens, it's easy to
          recursively revert all the changes created by the merge
          (<span><strong class="command">svn revert --recursive</strong></span>), delete any
          unversioned files or directories left behind after the
          revert, and re-run <span><strong class="command">svn merge</strong></span> with
          different arguments.</p><p>Also notice that the previous example shows a conflict
          happening on <code class="filename">glorb.h</code>.  We already
          stated that the working copy has no local edits: how can a
          conflict possibly happen?  Again, because the user can use
          <span><strong class="command">svn merge</strong></span> to define and apply any old
          delta to the working copy, that delta may contain textual
          changes that don't cleanly apply to a working file, even if
          the file has no local modifications.</p><p>Another small difference between <span><strong class="command">svn
          update</strong></span> and <span><strong class="command">svn merge</strong></span> are the
          names of the full-text files created when a conflict
          happens.  In <a href="#svn.tour.cycle.resolve" title="Resolve Conflicts (Merging Others' Changes)">la sezione chiamata «Resolve Conflicts (Merging Others' Changes)»</a>, we saw
          that an update produces files named
          <code class="filename">filename.mine</code>,
          <code class="filename">filename.rOLDREV</code>, and
          <code class="filename">filename.rNEWREV</code>.  When <span><strong class="command">svn
          merge</strong></span> produces a conflict, though, it creates
          three files named <code class="filename">filename.working</code>,
          <code class="filename">filename.left</code>, and
          <code class="filename">filename.right</code>.  In this case, the
          terms «<span class="quote">left</span>» and «<span class="quote">right</span>» are
          describing which side of the double-tree comparison the file
          came from.  In any case, these differing names will help you
          distinguish between conflicts that happened as a result of an
          update versus ones that happened as a result of a
          merge.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.branchmerge.copychanges.bestprac.ancestry"></a>Noticing or Ignoring Ancestry</h4></div></div></div><p>When conversing with a Subversion developer, you might
          very likely hear reference to the term
          <em class="firstterm">ancestry</em>.  This word is used to
          describe the relationship between two objects in a
          repository: if they're related to each other, then one
          object is said to be an ancestor of the other.</p><p>For example, suppose you commit revision 100, which
          includes a change to a file <code class="filename">foo.c</code>.
          Then <code class="filename">foo.c@99</code> is an
          «<span class="quote">ancestor</span>» of <code class="filename">foo.c@100</code>.
          On the other hand, suppose you commit the deletion of
          <code class="filename">foo.c</code> in revision 101, and then add a
          new file by the same name in revision 102.  In this case,
          <code class="filename">foo.c@99</code> and
          <code class="filename">foo.c@102</code> may appear to be related
          (they have the same path), but in fact are completely
          different objects in the repository.  They share no history
          or «<span class="quote">ancestry</span>».</p><p>The reason for bringing this up is to point out an
          important difference between <span><strong class="command">svn diff</strong></span> and
          <span><strong class="command">svn merge</strong></span>.  The former command ignores
          ancestry, while the latter command is quite sensitive to it.
          For example, if you asked <span><strong class="command">svn diff</strong></span> to
          compare revisions 99 and 102 of <code class="filename">foo.c</code>,
          you would see line-based diffs; the <code class="literal">diff</code>
          command is blindly comparing two paths.  But if you asked
          <span><strong class="command">svn merge</strong></span> to compare the same two objects,
          it would notice that they're unrelated and first attempt to
          delete the old file, then add the new file;  the output would
          indicate a deletion followed by an add:</p><pre class="screen">
D  foo.c
A  foo.c
</pre><p>Most merges involve comparing trees that are ancestrally
          related to one another, and therefore <span><strong class="command">svn
          merge</strong></span> defaults to this behavior.  Occasionally,
          however, you may want the <code class="literal">merge</code> command to
          compare two unrelated trees.  For example, you may have
          imported two source-code trees representing different vendor
          releases of a software project (see <a href="#svn.advanced.vendorbr" title="Vendor branches">la sezione chiamata «Vendor branches»</a>).
          If you asked <span><strong class="command">svn merge</strong></span> to compare the two
          trees, you'd see the entire first tree being deleted,
          followed by an add of the entire second tree!</p><p>In these situations, you'll want <span><strong class="command">svn
          merge</strong></span> to do a path-based comparison only, ignoring
          any relations between files and directories.  Add the
          <code class="option">--ignore-ancestry</code> option to your merge
          command, and it will behave just like <span><strong class="command">svn
          diff</strong></span>.  (And conversely, the
          <code class="option">--notice-ancestry</code> option will cause
          <span><strong class="command">svn diff</strong></span> to behave like the
          <code class="literal">merge</code> command.)</p></div></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.branchmerge.commonuses"></a>Common Use-Cases</h2></div></div></div><p>There are many different uses for branching and <span><strong class="command">svn
      merge</strong></span>, and this section describes the most common ones
      you're likely to run into.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.commonuses.wholebr"></a>Merging a Whole Branch to Another</h3></div></div></div><p>To complete our running example, we'll move forward in
        time.  Suppose several days have passed, and many changes have
        happened on both the trunk and your private branch.  Suppose
        that you've finished working on your private branch; the
        feature or bug fix is finally complete, and now you want to
        merge all of your branch changes back into the trunk for
        others to enjoy.</p><p>So how do we use <span><strong class="command">svn merge</strong></span> in this
        scenario?  Remember that this command compares two trees, and
        applies the differences to a working copy.  So to receive the
        changes, you need to have a working copy of the trunk.  We'll
        assume that either you still have your original one lying
        around (fully updated), or that you recently checked out a
        fresh working copy of <code class="filename">/calc/trunk</code>.</p><p>But which two trees should be compared?  At first glance,
        the answer may seem obvious: just compare the latest trunk
        tree with your latest branch tree.  But beware—this
        assumption is <span class="emphasis"><em>wrong</em></span>, and has burned many
        a new user!  Since <span><strong class="command">svn merge</strong></span> operates like
        <span><strong class="command">svn diff</strong></span>, comparing the latest trunk and 
        branch trees will <span class="emphasis"><em>not</em></span> merely describe
        the set of changes you made to your branch.  Such a comparison
        shows too many changes: it would not only show the addition of
        your branch changes, but also the <span class="emphasis"><em>removal</em></span>
        of trunk changes that never happened on your branch.</p><p>To express only the changes that happened on your branch,
        you need to compare the initial state of your branch to its
        final state.  Using <span><strong class="command">svn log</strong></span> on your branch,
        you can see that your branch was created in revision 341.  And
        the final state of your branch is simply a matter of using the
        <code class="literal">HEAD</code> revision.  That means you want to
        compare revisions 341 and <code class="literal">HEAD</code> of your
        branch directory, and apply those differences to a working
        copy of the trunk.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Suggerimento</h3><p>A nice way of finding the revision in which a branch was
          created (the «<span class="quote">base</span>» of the branch) is to use the
          <code class="option">--stop-on-copy</code> option to <span><strong class="command">svn
          log</strong></span>.  The log subcommand will normally show every
          change ever made to the branch, including tracing back
          through the copy which created the branch.  So normally,
          you'll see history from the trunk as well.  The
          <code class="option">--stop-on-copy</code> will halt log output as soon
          as <span><strong class="command">svn log</strong></span> detects that its target was
          copied or renamed.</p><p>So in our continuing example,</p><pre class="screen">
$ svn log --verbose --stop-on-copy \
          http://svn.example.com/repos/calc/branches/my-calc-branch
…
------------------------------------------------------------------------
r341 | user | 2002-11-03 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)

$
</pre><p>As expected, the final revision printed by this command
          is the revision in which <code class="filename">my-calc-branch</code>
          was created by copying.</p></div><p>Here's the final merging procedure, then:</p><pre class="screen">
$ cd calc/trunk
$ svn update
At revision 405.

$ svn merge -r 341:405 http://svn.example.com/repos/calc/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile

$ svn status
M   integer.c
M   button.c
M   Makefile

# ...examine the diffs, compile, test, etc...

$ svn commit -m "Merged my-calc-branch changes r341:405 into the trunk."
Sending        integer.c
Sending        button.c
Sending        Makefile
Transmitting file data ...
Committed revision 406.
</pre><p>Again, notice that the commit log message very
        specifically mentions the range of changes that was merged
        into the trunk.  Always remember to do this, because it's
        critical information you'll need later on.</p><p>For example, suppose you decide to keep working on your
        branch for another week, in order to complete an enhancement
        to your original feature or bug fix.  The repository's
        <code class="literal">HEAD</code> revision is now 480, and you're ready
        to do another merge from your private branch to the trunk.
        But as discussed in <a href="#svn.branchmerge.copychanges.bestprac" title="Best Practices for Merging">la sezione chiamata «Best Practices for Merging»</a>, you
        don't want to merge the changes you've already merged before;
        you only want to merge everything «<span class="quote">new</span>» on your
        branch since the last time you merged.  The trick is to figure
        out what's new.</p><p>The first step is to run <span><strong class="command">svn log</strong></span> on the
        trunk, and look for a log message about the last time you
        merged from the branch:</p><pre class="screen">
$ cd calc/trunk
$ svn log
…
------------------------------------------------------------------------
r406 | user | 2004-02-08 11:17:26 -0600 (Sun, 08 Feb 2004) | 1 line

Merged my-calc-branch changes r341:405 into the trunk.
------------------------------------------------------------------------
…
</pre><p>Aha!  Since all branch-changes that happened between
        revisions 341 and 405 were previously merged to the trunk as
        revision 406, you now know that you want to merge only the
        branch changes after that—by comparing revisions 406 and
        <code class="literal">HEAD</code>.</p><pre class="screen">
$ cd calc/trunk
$ svn update
At revision 480.

# We notice that HEAD is currently 480, so we use it to do the merge:

$ svn merge -r 406:480 http://svn.example.com/repos/calc/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile

$ svn commit -m "Merged my-calc-branch changes r406:480 into the trunk."
Sending        integer.c
Sending        button.c
Sending        Makefile
Transmitting file data ...
Committed revision 481.
</pre><p>Now the trunk contains the complete second wave of changes
        made to the branch.  At this point, you can either delete your
        branch (we'll discuss this later on), or continue working on
        your branch and repeat this procedure for subsequent
        merges.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.commonuses.undo"></a>Undoing Changes</h3></div></div></div><p>Another common use for <span><strong class="command">svn merge</strong></span> is to
        roll back a change that has already been committed.  Suppose
        you're working away happily on a working copy of
        <code class="filename">/calc/trunk</code>, and you discover that the
        change made way back in revision 303, which changed
        <code class="filename">integer.c</code>, is completely wrong.  It never
        should have been committed.  You can use <span><strong class="command">svn
        merge</strong></span> to «<span class="quote">undo</span>» the change in your
        working copy, and then commit the local modification to the
        repository.  All you need to do is to specify a
        <span class="emphasis"><em>reverse</em></span> difference:</p><pre class="screen">
$ svn merge -r 303:302 http://svn.example.com/repos/calc/trunk
U  integer.c

$ svn status
M  integer.c

$ svn diff
…
# verify that the change is removed
…

$ svn commit -m "Undoing change committed in r303."
Sending        integer.c
Transmitting file data .
Committed revision 350.
</pre><p>One way to think about a repository revision is as a
        specific group of changes (some version control systems call
        these <em class="firstterm">changesets</em>).  By using the
        <code class="option">-r</code> switch, you can ask <span><strong class="command">svn
        merge</strong></span> to apply a changeset, or whole range of
        changesets, to your working copy.  In our case of undoing a
        change, we're asking <span><strong class="command">svn merge</strong></span> to apply
        changeset #303 to our working copy
        <span class="emphasis"><em>backwards</em></span>.</p><p>Keep in mind that rolling back a change like this is just
        like any other <span><strong class="command">svn merge</strong></span> operation, so you
        should use <span><strong class="command">svn status</strong></span> and <span><strong class="command">svn
        diff</strong></span> to confirm that your work is in the state you
        want it to be in, and then use <span><strong class="command">svn commit</strong></span>
        to send the final version to the repository.  After
        committing, this particular changeset is no longer reflected
        in the <code class="literal">HEAD</code> revision.</p><p>Again, you may be thinking: well, that really didn't undo
        the commit, did it?  The change still exists in revision 303.
        If somebody checks out a version of the
        <code class="filename">calc</code> project between revisions 303 and
        349, they'll still see the bad change, right?</p><p>Yes, that's true.  When we talk about
        «<span class="quote">removing</span>» a change, we're really talking about
        removing it from <code class="literal">HEAD</code>.  The original change
        still exists in the repository's history.  For most
        situations, this is good enough.  Most people are only
        interested in tracking the <code class="literal">HEAD</code> of a
        project anyway.  There are special cases, however, where you
        really might want to destroy all evidence of the commit.
        (Perhaps somebody accidentally committed a confidential
        document.)  This isn't so easy, it turns out, because
        Subversion was deliberately designed to never lose
        information.  Revisions are immutable trees which build upon
        one another.  Removing a revision from history would cause a
        domino effect, creating chaos in all subsequent revisions and
        possibly invalidating all working copies.
        <sup>[<a id="id4738955" href="#ftn.id4738955">10</a>]</sup>
      </p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.commonuses.resurrect"></a>Resurrecting Deleted Items</h3></div></div></div><p>The great thing about version control systems is that
        information is never lost.  Even when you delete a file or
        directory, it may be gone from the <code class="literal">HEAD</code>
        revision, but the object still exists in earlier revisions.
        One of the most common questions new users ask is, «<span class="quote">How
        do I get my old file or directory back?</span>».</p><p>The first step is to define exactly <span class="bold"><strong>which</strong></span> item you're trying to resurrect.
        Here's a useful metaphor: you can think of every object in the
        repository as existing in a sort of two-dimensional coordinate
        system.  The first coordinate is a particular revision tree,
        and the second coordinate is a path within that tree.  So
        every version of your file or directory can be defined by a
        specific coordinate pair.</p><p>Subversion has no <code class="filename">Attic</code> directory
        like CVS does,
        <sup>[<a id="id4739035" href="#ftn.id4739035">11</a>]</sup>
        so you need to use <span><strong class="command">svn
        log</strong></span> to discover the exact coordinate pair you wish
        to resurrect.  A good strategy is to run <span><strong class="command">svn log
        --verbose</strong></span> in a directory which used to contain your
        deleted item.  The <code class="option">--verbose</code> option shows a
        list of all changed items in each revision; all you need to do
        is find the revision in which you deleted the file or
        directory.  You can do this visually, or by using another tool
        to examine the log output (via <span><strong class="command">grep</strong></span>, or
        perhaps via an incremental search in an editor).</p><pre class="screen">
$ cd parent-dir
$ svn log --verbose
…
------------------------------------------------------------------------
r808 | joe | 2003-12-26 14:29:40 -0600 (Fri, 26 Dec 2003) | 3 lines
Changed paths:
   D /calc/trunk/real.c
   M /calc/trunk/integer.c

Added fast fourier transform functions to integer.c.
Removed real.c because code now in double.c.
…
</pre><p>In the example, we're assuming that you're looking for a
        deleted file <code class="filename">real.c</code>.  By looking through
        the logs of a parent directory, you've spotted that this file
        was deleted in revision 808.  Therefore, the last version of
        the file to exist was in the revision right before that.
        Conclusion: you want to resurrect the path
        <code class="filename">/calc/trunk/real.c</code> from revision
        807.</p><p>That was the hard part—the research.  Now that you
        know what you want to restore, you have two different
        choices.</p><p>One option is to use <span><strong class="command">svn merge</strong></span> to apply
        revision 808 «<span class="quote">in reverse</span>».  (We've already
        discussed how to undo changes, see <a href="#svn.branchmerge.commonuses.undo" title="Undoing Changes">la sezione chiamata «Undoing Changes»</a>.)  This would have the effect of
        re-adding <code class="filename">real.c</code> as a local modification.
        The file would be scheduled for addition, and after a commit,
        the file would again exist in <code class="literal">HEAD</code>.</p><p>In this particular example, however, this is probably not
        the best strategy.  Reverse-applying revision 808 would not
        only schedule <code class="filename">real.c</code> for addition, but
        the log message indicates that it would also undo certain
        changes to <code class="filename">integer.c</code>, which you don't
        want.  Certainly, you could reverse-merge revision 808 and
        then <span><strong class="command">svn revert</strong></span> the local modifications to
        <code class="filename">integer.c</code>, but this technique doesn't
        scale well.  What if there were 90 files changed in revision
        808?</p><p>A second, more targeted strategy is not to use
        <span><strong class="command">svn merge</strong></span> at all, but rather the
        <span><strong class="command">svn copy</strong></span> command.  Simply copy the exact
        revision and path «<span class="quote">coordinate pair</span>» from the
        repository to your working copy:</p><pre class="screen">
$ svn copy --revision 807 \
           http://svn.example.com/repos/calc/trunk/real.c ./real.c

$ svn status
A  +   real.c

$ svn commit -m "Resurrected real.c from revision 807, /calc/trunk/real.c."
Adding         real.c
Transmitting file data .
Committed revision 1390.
</pre><p>The plus sign in the status output indicates that the item
        isn't merely scheduled for addition, but scheduled for
        addition «<span class="quote">with history</span>».  Subversion remembers
        where it was copied from.  In the future, running <span><strong class="command">svn
        log</strong></span> on this file will traverse back through the
        file's resurrection and through all the history it had prior
        to revision 807.  In other words, this new
        <code class="filename">real.c</code> isn't really new; it's a direct
        descendant of the original, deleted file.</p><p>Although our example shows us resurrecting a file, note
        that these same techniques work just as well for resurrecting
        deleted directories.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.commonuses.patterns"></a>Common Branching Patterns</h3></div></div></div><p>Version control is most often used for software
        development, so here's a quick peek at two of the most common
        branching/merging patterns used by teams of programmers.  If
        you're not using Subversion for software development, feel
        free to skip this section.  If you're a software developer
        using version control for the first time, pay close attention,
        as these patterns are often considered best practices by
        experienced folk.  These processes aren't specific to
        Subversion; they're applicable to any version control system.
        Still, it may help to see them described in Subversion
        terms.</p><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.branchmerge.commonuses.patterns.release"></a>Release Branches</h4></div></div></div><p>Most software has a typical lifecycle: code, test,
          release, repeat.  There are two problems with this process.
          First, developers need to keep writing new features while
          quality-assurance teams take time to test supposedly-stable
          versions of the software.  New work cannot halt while the
          software is tested.  Second, the team almost always needs to
          support older, released versions of software; if a bug is
          discovered in the latest code, it most likely exists in
          released versions as well, and customers will want to get
          that bugfix without having to wait for a major new
          release.</p><p>Here's where version control can help.  The typical
          procedure looks like this:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Developers commit all new work to the
                trunk.</em></span>

              Day-to-day changes are committed to
              <code class="filename">/trunk</code>: new features, bugfixes, and
              so on.</p></li><li><p><span class="emphasis"><em>The trunk is copied to a
                «<span class="quote">release</span>» branch.</em></span>

              When the team thinks the software is ready for release
              (say, a 1.0 release), then <code class="filename">/trunk</code>
              might be copied to
              <code class="filename">/branches/1.0</code>.</p></li><li><p><span class="emphasis"><em>Teams continue to work in parallel.</em></span>

              One team begins rigorous testing of the release branch,
              while another team continues new work (say, for version
              2.0) on <code class="filename">/trunk</code>.  If bugs are
              discovered in either location, fixes are ported back and
              forth as necessary.  At some point, however, even that
              process stops.  The branch is «<span class="quote">frozen</span>» for
              final testing right before a release.</p></li><li><p><span class="emphasis"><em>The branch is tagged and released.</em></span>

              When testing is complete,
              <code class="filename">/branches/1.0</code> is copied to
              <code class="filename">/tags/1.0.0</code> as a reference
              snapshot.  The tag is packaged and released to
              customers.</p></li><li><p><span class="emphasis"><em>The branch is maintained over time.</em></span>

              While work continues on <code class="filename">/trunk</code> for
              version 2.0, bugfixes continue to be ported from
              <code class="filename">/trunk</code> to
              <code class="filename">/branches/1.0</code>.  When enough
              bugfixes have accumulated, management may decide to do a
              1.0.1 release: <code class="filename">/branches/1.0</code> is
              copied to <code class="filename">/tags/1.0.1</code>, and the tag
              is packaged and released.</p></li></ul></div><p>This entire process repeats as the software matures:
          when the 2.0 work is complete, a new 2.0 release branch is
          created, tested, tagged, and eventually released.  After
          some years, the repository ends up with a number of release
          branches in «<span class="quote">maintenance</span>» mode, and a number
          of tags representing final shipped versions.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.branchmerge.commonuses.patterns.feature"></a>Feature Branches</h4></div></div></div><p>A <em class="firstterm">feature branch</em> is the sort of
          branch that's been the dominant example in this chapter, the
          one you've been working on while Sally continues to work on
          <code class="filename">/trunk</code>.  It's a temporary branch
          created to work on a complex change without interfering with
          the stability of <code class="filename">/trunk</code>.  Unlike
          release branches (which may need to be supported forever),
          feature branches are born, used for a while, merged back to
          the trunk, then ultimately deleted.  They have a finite span
          of usefulness.</p><p>Again, project policies vary widely concerning exactly
          when it's appropriate to create a feature branch.  Some
          projects never use feature branches at all: commits to
          <code class="filename">/trunk</code> are a free-for-all.  The
          advantage to this system is that it's simple—nobody
          needs to learn about branching or merging.  The disadvantage
          is that the trunk code is often unstable or unusable.  Other
          projects use branches to an extreme: no change is
          <span class="emphasis"><em>ever</em></span> committed to the trunk directly.
          Even the most trivial changes are created on a short-lived
          branch, carefully reviewed and merged to the trunk.  Then
          the branch is deleted.  This system guarantees an
          exceptionally stable and usable trunk at all times, but at
          the cost of tremendous process overhead.</p><p>Most projects take a middle-of-the-road approach.  They
          commonly insist that <code class="filename">/trunk</code> compile and
          pass regression tests at all times.  A feature branch is
          only required when a change requires a large number of
          destabilizing commits.  A good rule of thumb is to ask this
          question: if the developer worked for days in isolation and
          then committed the large change all at once (so that
          <code class="filename">/trunk</code> were never destabilized), would
          it be too large a change to review?  If the answer to that
          question is «<span class="quote">yes</span>», then the change should be
          developed on a feature branch.  As the developer commits
          incremental changes to the branch, they can be easily
          reviewed by peers.</p><p>Finally, there's the issue of how to best keep a feature
          branch in «<span class="quote">sync</span>» with the trunk as work
          progresses.  As we mentioned earlier, there's a great risk
          to working on a branch for weeks or months; trunk changes
          may continue to pour in, to the point where the two lines of
          development differ so greatly that it may become a nightmare
          trying to merge the branch back to the trunk.</p><p>This situation is best avoided by regularly merging
          trunk changes to the branch.  Make up a policy: once a week,
          merge the last week's worth of trunk changes to the branch.
          Take care when doing this; the merging needs to be
          hand-tracked to avoid the problem of repeated merges (as
          described in <a href="#svn.branchmerge.copychanges.bestprac.track" title="Tracking Merges Manually">la sezione chiamata «Tracking Merges Manually»</a>).  You'll
          need to write careful log messages detailing exactly which
          revision ranges have been merged already (as
          demonstrated in <a href="#svn.branchmerge.commonuses.wholebr" title="Merging a Whole Branch to Another">la sezione chiamata «Merging a Whole Branch to Another»</a>).  It
          may sound intimidating, but it's actually pretty easy to
          do.</p><p>At some point, you'll be ready to merge the
          «<span class="quote">synchronized</span>» feature branch back to the
          trunk.  To do this, begin by doing a final merge of the
          latest trunk changes to the branch.  When that's done, the
          latest versions of branch and trunk will be absolutely
          identical except for your branch changes.  So in this
          special case, you would merge by comparing the branch with
          the trunk:</p><pre class="screen">
$ cd trunk-working-copy

$ svn update
At revision 1910.

$ svn merge http://svn.example.com/repos/calc/trunk@1910 \
            http://svn.example.com/repos/calc/branches/mybranch@1910
U  real.c
U  integer.c
A  newdirectory
A  newdirectory/newfile
…
</pre><p>By comparing the <code class="literal">HEAD</code> revision of the
          trunk with the <code class="literal">HEAD</code> revision of the
          branch, you're defining a delta that describes only the
          changes you made to the branch; both lines of development
          already have all of the trunk changes.</p><p>Another way of thinking about this pattern is that your
          weekly sync of trunk to branch is analogous to running
          <span><strong class="command">svn update</strong></span> in a working copy, while the
          final merge step is analogous to running <span><strong class="command">svn
          commit</strong></span> from a working copy.  After all, what else
          <span class="emphasis"><em>is</em></span> a working copy but a very shallow
          private branch?  It's a branch that's only capable of
          storing one change at a time.</p></div></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.branchmerge.switchwc"></a>Switching a Working Copy</h2></div></div></div><p>The <span><strong class="command">svn switch</strong></span> command transforms an
      existing working copy into a different branch.  While this
      command isn't strictly necessary for working with branches, it
      provides a nice shortcut to users.  In our earlier example,
      after creating your private branch, you checked out a fresh
      working copy of the new repository directory.  Instead, you can
      simply ask Subversion to change your working copy of
      <code class="filename">/calc/trunk</code> to mirror the new branch
      location:</p><pre class="screen">
$ cd calc

$ svn info | grep URL
URL: http://svn.example.com/repos/calc/trunk

$ svn switch http://svn.example.com/repos/calc/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile
Updated to revision 341.

$ svn info | grep URL
URL: http://svn.example.com/repos/calc/branches/my-calc-branch
</pre><p>After «<span class="quote">switching</span>» to the branch, your working
      copy is no different than what you would get from doing a fresh
      checkout of the directory.  And it's usually more efficient to
      use this command, because often branches only differ by a small
      degree.  The server sends only the minimal set of changes
      necessary to make your working copy reflect the branch
      directory.</p><p>The <span><strong class="command">svn switch</strong></span> command also takes a
      <code class="option">--revision</code> (<code class="option">-r</code>) option, so you
      need not always move your working copy to the «<span class="quote">tip</span>»
      of the branch.</p><p>Of course, most projects are more complicated than our
      <code class="filename">calc</code> example, containing multiple
      subdirectories.  Subversion users often follow a specific
      algorithm when using branches:</p><div class="orderedlist"><ol type="1"><li><p>Copy the project's entire «<span class="quote">trunk</span>» to a
            new branch directory.</p></li><li><p>Switch only <span class="emphasis"><em>part</em></span> of the trunk
            working copy to mirror the branch.</p></li></ol></div><p>In other words, if a user knows that the branch-work only
      needs to happen on a specific subdirectory, they use
      <span><strong class="command">svn switch</strong></span> to move only that subdirectory to
      the branch.  (Or sometimes users will switch just a single
      working file to the branch!)  That way, they can continue to
      receive normal «<span class="quote">trunk</span>» updates to most of their
      working copy, but the switched portions will remain immune
      (unless someone commits a change to their branch).  This feature
      adds a whole new dimension to the concept of a «<span class="quote">mixed
      working copy</span>»—not only can working copies contain a
      mixture of working revisions, but a mixture of repository
      locations as well.</p><p>If your working copy contains a number of switched subtrees
      from different repository locations, it continues to function as
      normal.  When you update, you'll receive patches to each subtree
      as appropriate.  When you commit, your local changes will still
      be applied as a single, atomic change to the repository.</p><p>Note that while it's okay for your working copy to reflect a
      mixture of repository locations, these locations must all be
      within the <span class="emphasis"><em>same</em></span> repository.  Subversion
      repositories aren't yet able to communicate with one another;
      that's a feature planned beyond Subversion
      1.0.<sup>[<a id="id4739864" href="#ftn.id4739864">12</a>]</sup></p><div class="sidebar"><p class="title"><b>Switches and Updates</b></p><p>Have you noticed that the output of <span><strong class="command">svn
        switch</strong></span> and <span><strong class="command">svn update</strong></span> look the
        same?  The <code class="literal">switch</code> command is actually a
        superset of the update command.</p><p>When you run <span><strong class="command">svn update</strong></span>, you're asking
        the repository to compare two trees.  The repository does so,
        and then sends a description of the differences back to the
        client.  The only difference between <span><strong class="command">svn
        switch</strong></span> and <span><strong class="command">svn update</strong></span> is that the
        <code class="literal">update</code> command always compares two identical
        paths.</p><p>That is, if your working copy is a mirror of
        <code class="filename">/calc/trunk</code>, then <span><strong class="command">svn
        update</strong></span> will automatically compare your working copy
        of <code class="filename">/calc/trunk</code> to
        <code class="filename">/calc/trunk</code> in the
        <code class="literal">HEAD</code> revision.  If you're switching your
        working copy to a branch, then <span><strong class="command">svn switch</strong></span>
        will compare your working copy of
        <code class="filename">/calc/trunk</code> to some
        <span class="emphasis"><em>other</em></span> branch-directory in the
        <code class="literal">HEAD</code> revision.</p><p>In other words, an update moves your working copy through
        time.  A switch moves your working copy through time
        <span class="emphasis"><em>and</em></span> space.</p></div><p>Because <span><strong class="command">svn switch</strong></span> is essentially a
      variant of <span><strong class="command">svn update</strong></span>, it shares the same
      behaviors; any local modifications in your working copy are
      preserved when new data arrives from the repository.  This
      allows you to perform all sorts of clever tricks.</p><p>For example, suppose you have a working copy of
      <code class="filename">/calc/trunk</code> and make a number of changes to
      it.  Then you suddenly realize that you meant to make the
      changes to a branch instead.  No problem!  When you <span><strong class="command">svn
      switch</strong></span> your working copy to the branch, the local
      changes will remain.  You can then test and commit them to the
      branch.</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.branchmerge.tags"></a>Tags</h2></div></div></div><p>Another common version control concept is a
      <em class="firstterm">tag</em>.  A tag is just a
      «<span class="quote">snapshot</span>» of a project in time.  In Subversion,
      this idea already seems to be everywhere.  Each repository
      revision is exactly that—a snapshot of the filesystem
      after each commit.</p><p>However, people often want to give more human-friendly names
      to tags, like <code class="literal">release-1.0</code>.  And they want to
      make snapshots of smaller subdirectories of the filesystem.
      After all, it's not so easy to remember that release-1.0 of a
      piece of software is a particular subdirectory of revision
      4822.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.tags.mksimple"></a>Creating a Simple Tag</h3></div></div></div><p>Once again, <span><strong class="command">svn copy</strong></span> comes to the
        rescue.  If you want to create a snapshot of
        <code class="filename">/calc/trunk</code> exactly as it looks in the
        <code class="literal">HEAD</code> revision, then make a copy of it:</p><pre class="screen">
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/tags/release-1.0 \
      -m "Tagging the 1.0 release of the 'calc' project."

Committed revision 351.
</pre><p>This example assumes that a
        <code class="filename">/calc/tags</code> directory already exists.  (If it
        doesn't, see <a href="#svn.ref.svn.c.mkdir" title="svn mkdir">svn mkdir</a>).
        After the copy completes, the new
        <code class="filename">release-1.0</code> directory is forever a
        snapshot of how the project looked in the
        <code class="literal">HEAD</code> revision at the time you made the
        copy.  Of course you might want to be more precise about
        exactly which revision you copy, in case somebody else may
        have committed changes to the project when you weren't
        looking.  So if you know that revision 350 of
        <code class="filename">/calc/trunk</code> is exactly the snapshot you
        want, you can specify it by passing <code class="option">-r 350</code> to
        the <span><strong class="command">svn copy</strong></span> command.</p><p>But wait a moment: isn't this tag-creation procedure the
        same procedure we used to create a branch?  Yes, in fact, it
        is.  In Subversion, there's no difference between a tag and a
        branch.  Both are just ordinary directories that are created
        by copying.  Just as with branches, the only reason a copied
        directory is a «<span class="quote">tag</span>» is because
        <span class="emphasis"><em>humans</em></span> have decided to treat it that way:
        as long as nobody ever commits to the directory, it forever
        remains a snapshot.  If people start committing to it, it
        becomes a branch.</p><p>If you are administering a repository, there are two
        approaches you can take to managing tags.  The first approach
        is «<span class="quote">hands off</span>»: as a matter of project policy,
        decide where your tags will live, and make sure all users know
        how to treat the directories they copy in there.  (That is,
        make sure they know not to commit to them.)  The second
        approach is more paranoid: you can use one of the
        access-control scripts provided with Subversion to prevent
        anyone from doing anything but creating new copies in the
        tags-area (See <a href="#svn.serverconfig" title="Capitolo&#xA0;6.&#xA0;Server Configuration">Capitolo 6, <i>Server Configuration</i></a>.)  The paranoid
        approach, however, isn't usually necessary.  If a user
        accidentally commits a change to a tag-directory, you can
        simply undo the change as discussed in the previous section.
        This is version control, after all.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.tags.mkcomplex"></a>Creating a Complex Tag</h3></div></div></div><p>Sometimes you may want your «<span class="quote">snapshot</span>» to be
        more complicated than a single directory at a single
        revision.</p><p>For example, pretend your project is much larger than our
        <code class="filename">calc</code> example: suppose it contains a
        number of subdirectories and many more files.  In the course
        of your work, you may decide that you need to create a working
        copy that is designed to have specific features and bug fixes.
        You can accomplish this by selectively backdating files or
        directories to particular revisions (using <span><strong class="command">svn update
        -r</strong></span> liberally), or by switching files and directories
        to particular branches (making use of <span><strong class="command">svn
        switch</strong></span>).  When you're done, your working copy is a
        hodgepodge of repository locations from different revisions.
        But after testing, you know it's the precise combination of
        data you need.</p><p>Time to make a snapshot.  Copying one URL to another won't
        work here.  In this case, you want to make a snapshot of your
        exact working copy arrangement and store it in the repository.
        Luckily, <span><strong class="command">svn copy</strong></span> actually has four
        different uses (which you can read about in Chapter 9),
        including the ability to copy a working-copy tree to the
        repository:</p><pre class="screen">
$ ls
my-working-copy/

$ svn copy my-working-copy http://svn.example.com/repos/calc/tags/mytag

Committed revision 352.
</pre><p>Now there is a new directory in the repository,
        <code class="filename">/calc/tags/mytag</code>, which is an exact
        snapshot of your working copy—mixed revisions, URLs,
        and all.</p><p>Other users have found interesting uses for this feature.
        Sometimes there are situations where you have a bunch of local
        changes made to your working copy, and you'd like a
        collaborator to see them.  Instead of running <span><strong class="command">svn
        diff</strong></span> and sending a patch file (which won't capture
        tree changes, symlink changes or changes in properties), you can
        instead use <span><strong class="command">svn copy</strong></span> to «<span class="quote">upload</span>»
        your working copy to a private area of the repository.  Your
        collaborator can then either checkout a verbatim copy of your
        working copy, or use <span><strong class="command">svn merge</strong></span> to receive
        your exact changes.</p></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.branchmerge.maint"></a>Branch Maintenance</h2></div></div></div><p>You may have noticed by now that Subversion is extremely
      flexible.  Because it implements branches and tags with the same
      underlying mechanism (directory copies), and because branches
      and tags appear in normal filesystem space, many people find
      Subversion intimidating.  It's almost <span class="emphasis"><em>too</em></span>
      flexible.  In this section, we'll offer some suggestions for
      arranging and managing your data over time.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.maint.layout"></a>Repository Layout</h3></div></div></div><p>There are some standard, recommended ways to organize a
        repository.  Most people create a <code class="filename">trunk</code>
        directory to hold the «<span class="quote">main line</span>» of development,
        a <code class="filename">branches</code> directory to contain branch
        copies, and a <code class="filename">tags</code> directory to contain
        tag copies.  If a repository holds only one project, then
        often people create these top-level directories:</p><pre class="screen">
/trunk
/branches
/tags
</pre><p>If a repository contains multiple projects, admins
        typically index their layout by project (see <a href="#svn.reposadmin.projects.chooselayout" title="Choosing a Repository Layout">la sezione chiamata «Choosing a Repository Layout»</a> to read more about
        «<span class="quote">project roots</span>»):</p><pre class="screen">
/paint/trunk
/paint/branches
/paint/tags
/calc/trunk
/calc/branches
/calc/tags
</pre><p>Of course, you're free to ignore these common layouts.
        You can create any sort of variation, whatever works best for
        you or your team.  Remember that whatever you choose, it's not
        a permanent commitment.  You can reorganize your repository at
        any time.  Because branches and tags are ordinary directories,
        the <span><strong class="command">svn move</strong></span> command can move or rename
        them however you wish.  Switching from one layout to another
        is just a matter of issuing a series of server-side moves; if
        you don't like the way things are organized in the repository,
        just juggle the directories around.</p><p>Remember, though, that while moving directories may be
        easy to do, you need to be considerate of your users as well.
        Your juggling can be disorienting to users with existing
        working copies.  If a user has a working copy of a particular
        repository directory, your <span><strong class="command">svn move</strong></span>
        operation might remove the path from the latest revision.
        When the user next runs <span><strong class="command">svn update</strong></span>, she will
        be told that her working copy represents a path that no
        longer exists, and the user will be forced to <span><strong class="command">svn
        switch</strong></span> to the new location.
        </p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.maint.lifetime"></a>Data Lifetimes</h3></div></div></div><p>Another nice feature of Subversion's model is that
        branches and tags can have finite lifetimes, just like any
        other versioned item.  For example, suppose you eventually
        finish all your work on your personal branch of the
        <code class="filename">calc</code> project.  After merging all of your
        changes back into <code class="filename">/calc/trunk</code>, there's
        no need for your private branch directory to stick around
        anymore:</p><pre class="screen">
$ svn delete http://svn.example.com/repos/calc/branches/my-calc-branch \
             -m "Removing obsolete branch of calc project."

Committed revision 375.
</pre><p>And now your branch is gone.  Of course it's not really
        gone: the directory is simply missing from the
        <code class="literal">HEAD</code> revision, no longer distracting
        anyone.  If you use <span><strong class="command">svn checkout</strong></span>,
        <span><strong class="command">svn switch</strong></span>, or <span><strong class="command">svn list</strong></span>
        to examine an earlier revision, you'll still be able to see
        your old branch.</p><p>If browsing your deleted directory isn't enough, you can
        always bring it back.  Resurrecting data is very easy in
        Subversion.  If there's a deleted directory (or file) that
        you'd like to bring back into <code class="literal">HEAD</code>, simply
        use <span><strong class="command">svn copy -r</strong></span> to copy it from the old
        revision:</p><pre class="screen">
$ svn copy -r 374 http://svn.example.com/repos/calc/branches/my-calc-branch \
                  http://svn.example.com/repos/calc/branches/my-calc-branch

Committed revision 376.
</pre><p>In our example, your personal branch had a relatively
        short lifetime: you may have created it to fix a bug or
        implement a new feature.  When your task is done, so is the
        branch.  In software development, though, it's also common to
        have two «<span class="quote">main</span>» branches running side-by-side for
        very long periods.  For example, suppose it's time to release
        a stable version of the <code class="filename">calc</code> project to the
        public, and you know it's going to take a couple of months to
        shake bugs out of the software.  You don't want people to add
        new features to the project, but you don't want to tell all
        developers to stop programming either.  So instead, you create
        a «<span class="quote">stable</span>» branch of the software that won't
        change much:</p><pre class="screen">
$ svn copy http://svn.example.com/repos/calc/trunk \
         http://svn.example.com/repos/calc/branches/stable-1.0 \
         -m "Creating stable branch of calc project."

Committed revision 377.
</pre><p>And now developers are free to continue adding
        cutting-edge (or experimental) features to
        <code class="filename">/calc/trunk</code>, and you can declare a
        project policy that only bug fixes are to be committed to
        <code class="filename">/calc/branches/stable-1.0</code>.  That is, as
        people continue to work on the trunk, a human selectively
        ports bug fixes over to the stable branch.  Even after the
        stable branch has shipped, you'll probably continue to
        maintain the branch for a long time—that is, as long
        as you continue to support that release for customers.</p></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.branchmerge.summary"></a>Summary</h2></div></div></div><p>We've covered a lot of ground in this chapter.  We've
      discussed the concepts of tags and branches, and demonstrated
      how Subversion implements these concepts by copying directories
      with the <span><strong class="command">svn copy</strong></span> command.  We've shown how
      to use <span><strong class="command">svn merge</strong></span> to copy changes from one
      branch to another, or roll back bad changes.  We've gone over
      the use of <span><strong class="command">svn switch</strong></span> to create
      mixed-location working copies.  And we've talked about how one
      might manage the organization and lifetimes of branches in a
      repository.</p><p>Remember the Subversion mantra: branches and tags are cheap.
      So use them liberally!</p></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.id4736664" href="#id4736664">8</a>] </sup>Subversion does not support
            cross-repository copying.  When using URLs with <span><strong class="command">svn
            copy</strong></span> or <span><strong class="command">svn move</strong></span>, you can only
            copy items within the same repository.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4737444" href="#id4737444">9</a>] </sup>In the future, the Subversion project plans to use
              (or invent) an expanded patch format that describes
              changes in tree structure and properties.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4738955" href="#id4738955">10</a>] </sup>The Subversion project has plans, however, to someday
            implement an <span><strong class="command">svnadmin obliterate</strong></span>
            command that would accomplish the task of permanently
            deleting information.  In the meantime, see <a href="#svn.reposadmin.maint.tk.svndumpfilter" title="svndumpfilter">la sezione chiamata «svndumpfilter»</a> for a possible
            workaround.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4739035" href="#id4739035">11</a>] </sup>Because CVS doesn't version trees, it creates an
            <code class="filename">Attic</code> area within each repository
            directory as a way of remembering deleted files.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4739864" href="#id4739864">12</a>] </sup>You <span class="emphasis"><em>can</em></span>, however, use
      <span><strong class="command">svn switch</strong></span> with the
      <code class="option">--relocate</code> switch if the URL of your server
      changes and you don't want to abandon an existing working copy.
      See the <span><strong class="command">svn switch</strong></span> section in <a href="#svn.ref" title="Capitolo&#xA0;9.&#xA0;Subversion Complete Reference">Capitolo 9, <i>Subversion Complete Reference</i></a> for more information and an example.</p></div></div></div><div class="chapter" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title"><a id="svn.reposadmin"></a>Capitolo 5. Repository Administration</h2></div></div></div><div class="toc"><p><b>Sommario</b></p><dl><dt><span class="sect1"><a href="#svn.reposadmin.basics">Repository Basics</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.reposadmin.basics.txnsrevs">Understanding Transactions and Revisions</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.basics.revprops">Unversioned Properties</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.basics.backends">Repository Data Stores</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.reposadmin.basics.backends.bdb">Berkeley DB</a></span></dt><dt><span class="sect3"><a href="#svn.reposadmin.basics.backends.fsfs">FSFS</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.reposadmin.create">Repository Creation and Configuration</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.reposadmin.create.hooks">Hook Scripts</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.create.bdb">Berkeley DB Configuration</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.reposadmin.maint">Repository Maintenance</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.reposadmin.maint.tk">An Administrator's Toolkit</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.reposadmin.maint.tk.svnlook">svnlook</a></span></dt><dt><span class="sect3"><a href="#svn.reposadmin.maint.tk.svnadmin">svnadmin</a></span></dt><dt><span class="sect3"><a href="#svn.reposadmin.maint.tk.svndumpfilter">svndumpfilter</a></span></dt><dt><span class="sect3"><a href="#svn.reposadmin.maint.tk.bdbutil">Berkeley DB Utilities</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.reposadmin.maint.cleanup">Repository Cleanup</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.maint.diskspace">Managing Disk Space</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.maint.recovery">Repository Recovery</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.maint.migrate">Migrating a Repository</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.maint.backup">Repository Backup</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.reposadmin.projects">Adding Projects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.reposadmin.projects.chooselayout">Choosing a Repository Layout</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.projects.import">Creating the Layout, and Importing Initial Data</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.reposadmin.summary">Summary</a></span></dt></dl></div><div class="simplesect" lang="it" xml:lang="it"><div class="titlepage"></div><p>The Subversion repository is the central storehouse of
      versioned data for any number of projects.  As such, it becomes
      an obvious candidate for all the love and attention an
      administrator can offer.  While the repository is generally a
      low-maintenance item, it is important to understand how to
      properly configure and care for it so that potential problems
      are avoided, and actual problems are safely resolved.</p><p>In this chapter, we'll discuss how to create and configure
      a Subversion repository.  We'll also talk about repository
      maintenance, including the use of the <span><strong class="command">svnlook</strong></span>
      and <span><strong class="command">svnadmin</strong></span> tools (which are provided with
      Subversion).  We'll address some common questions and mistakes,
      and give some suggestions on how to arrange the data in the
      repository.</p><p>If you plan to access a Subversion repository only in the
      role of a user whose data is under version control (that is, via
      a Subversion client), you can skip this chapter altogether.
      However, if you are, or wish to become, a Subversion repository
      administrator,
      <sup>[<a id="id4740811" href="#ftn.id4740811">13</a>]</sup>
      you should definitely pay attention to this chapter.</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.reposadmin.basics"></a>Repository Basics</h2></div></div></div><p>Before jumping into the broader topic of repository
      administration, let's further define what a repository is.  How
      does it look?  How does it feel?  Does it take its tea hot or
      iced, sweetened, and with lemon?  As an administrator, you'll be
      expected to understand the composition of a repository both from
      a logical perspective—dealing with how data is represented
      inside the repository—and from a physical nuts-and-bolts
      perspective—how a repository looks and acts with respect
      to non-Subversion tools.  The following section covers some of
      these basic concepts at a very high level.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.reposadmin.basics.txnsrevs"></a>Understanding Transactions and Revisions</h3></div></div></div><p>Conceptually speaking, a Subversion repository is a
        sequence of directory trees.  Each tree is a snapshot of how
        the files and directories versioned in your repository looked
        at some point in time.  These snapshots are created as a
        result of client operations, and are called revisions.</p><p>Every revision begins life as a transaction tree.  When
        doing a commit, a client builds a Subversion transaction that
        mirrors their local changes (plus any additional changes that
        might have been made to the repository since the beginning of
        the client's commit process), and then instructs the
        repository to store that tree as the next snapshot in the
        sequence.  If the commit succeeds, the transaction is
        effectively promoted into a new revision tree, and is assigned
        a new revision number.  If the commit fails for some reason,
        the transaction is destroyed and the client is informed of the
        failure.</p><p>Updates work in a similar way.  The client builds a
        temporary transaction tree that mirrors the state of the
        working copy.  The repository then compares that transaction
        tree with the revision tree at the requested revision (usually
        the most recent, or «<span class="quote">youngest</span>» tree), and sends
        back information that informs the client about what changes
        are needed to transform their working copy into a replica of
        that revision tree.  After the update completes, the temporary
        transaction is deleted.</p><p>The use of transaction trees is the only way to make
        permanent changes to a repository's versioned filesystem.
        However, it's important to understand that the lifetime of a
        transaction is completely flexible.  In the case of updates,
        transactions are temporary trees that are immediately
        destroyed.  In the case of commits, transactions are
        transformed into permanent revisions (or removed if the commit
        fails).  In the case of an error or bug, it's possible that a
        transaction can be accidentally left lying around in the
        repository (not really affecting anything, but still taking up
        space).</p><p>In theory, someday whole workflow applications might
        revolve around more fine-grained control of transaction
        lifetime.  It is feasible to imagine a system whereby each
        transaction slated to become a revision is left in stasis well
        after the client finishes describing its changes to
        repository.  This would enable each new commit to be reviewed
        by someone else, perhaps a manager or engineering QA team, who
        can choose to promote the transaction into a revision, or
        abort it.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.reposadmin.basics.revprops"></a>Unversioned Properties</h3></div></div></div><p>Transactions and revisions in the Subversion repository
        can have properties attached to them.  These properties are
        generic key-to-value mappings, and are generally used to store
        information about the tree to which they are attached.  The
        names and values of these properties are stored in the
        repository's filesystem, along with the rest of your tree
        data.</p><p>Revision and transaction properties are useful for
        associating information with a tree that is not strictly
        related to the files and directories in that tree—the
        kind of information that isn't managed by client working
        copies.  For example, when a new commit transaction is created
        in the repository, Subversion adds a property to that
        transaction named <code class="literal">svn:date</code>—a
        datestamp representing the time that the transaction was
        created.  By the time the commit process is finished, and the
        transaction is promoted to a permanent revision, the tree has
        also been given a property to store the username of the
        revision's author (<code class="literal">svn:author</code>) and a
        property to store the log message attached to that revision
        (<code class="literal">svn:log</code>).</p><p>Revision and transaction properties are
        <em class="firstterm">unversioned properties</em>—as they
        are modified, their previous values are permanently discarded.
        Also, while revision trees themselves are immutable, the
        properties attached to those trees are not.  You can add,
        remove, and modify revision properties at any time in the
        future.  If you commit a new revision and later realize that
        you had some misinformation or spelling error in your log
        message, you can simply replace the value of the
        <code class="literal">svn:log</code> property with a new, corrected log
        message.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.reposadmin.basics.backends"></a>Repository Data Stores</h3></div></div></div><p>As of Subversion 1.1, there are two options for storing
        data in a Subversion repository.  One type of repository
        stores everything in a Berkeley DB database; the other kind
        stores data in ordinary flat files, using a custom
        format.  Because Subversion developers often refer to a
        repository as «<span class="quote">the (versioned) filesystem</span>», they have
        adopted the habit of referring to the latter type of repository as
        <em class="firstterm">FSFS</em>
        <sup>[<a id="id4741075" href="#ftn.id4741075">14</a>]</sup>
        —a versioned
        filesystem implementation that uses the native OS filesystem
        to store data.</p><p>When a repository is created, an administrator must decide
        whether it will use Berkeley DB or FSFS.  There are advantages
        and disadvantages to each, which we'll describe in a bit.
        Neither back-end is more «<span class="quote">official</span>» than another,
        and programs which access the repository are insulated from
        this implementation detail.  Programs have no idea how a
        repository is storing data; they only see revision and
        transaction trees through the repository API.</p><p><a href="#svn.reposadmin.basics.backends.tbl-1" title="Tabella&#xA0;5.1.&#xA0;Repository Data Store Comparison">Tabella 5.1, «Repository Data Store Comparison»</a>
        gives a comparative overview of Berkeley DB and FSFS
        repositories.  The next sections go into detail.</p><div class="table"><a id="svn.reposadmin.basics.backends.tbl-1"></a><p class="title"><b>Tabella 5.1. Repository Data Store Comparison</b></p><div class="table-contents"><table summary="Repository Data Store Comparison" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Feature</th><th>Berkeley DB</th><th>FSFS</th></tr></thead><tbody><tr><td>Sensitivity to interruptions</td><td>very;  crashes and permission problems can leave the
                database «<span class="quote">wedged</span>», requiring journaled
                recovery procedures.</td><td>quite insensitive.</td></tr><tr><td>Usable from a read-only mount</td><td>no</td><td>yes</td></tr><tr><td>Platform-independent storage</td><td>no</td><td>yes</td></tr><tr><td>Usable over network filesystems</td><td>no</td><td>yes</td></tr><tr><td>Repository size</td><td>slightly larger</td><td>slightly smaller</td></tr><tr><td>Scalability: number of revision trees</td><td>database;  no problems</td><td>some older native filesystems don't scale well with
                thousands of entries in a single directory.</td></tr><tr><td>Scalability: directories with many files</td><td>slower</td><td>faster</td></tr><tr><td>Speed:  checking out latest code</td><td>faster</td><td>slower</td></tr><tr><td>Speed:  large commits</td><td>slower, but work is spread throughout commit</td><td>faster, but finalization delay may cause client
                timeouts</td></tr><tr><td>Group permissions handling</td><td>sensitive to user umask problems;  best if accessed
                by only one user.</td><td>works around umask problems</td></tr><tr><td>Code maturity</td><td>in use since 2001</td><td>in use since 2004</td></tr></tbody></table></div></div><br class="table-break" /><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.reposadmin.basics.backends.bdb"></a>Berkeley DB</h4></div></div></div><p>When the initial design phase of Subversion was in
          progress, the developers decided to use Berkeley DB for a
          variety of reasons, including its open-source license,
          transaction support, reliability, performance, API
          simplicity, thread-safety, support for cursors, and so
          on.</p><p>Berkeley DB provides real transaction
          support—perhaps its most powerful feature.  Multiple
          processes accessing your Subversion repositories don't have
          to worry about accidentally clobbering each other's data.
          The isolation provided by the transaction system is such
          that for any given operation, the Subversion repository code
          sees a static view of the database—not a database that
          is constantly changing at the hand of some other
          process—and can make decisions based on that view.  If
          the decision made happens to conflict with what another
          process is doing, the entire operation is rolled back as if
          it never happened, and Subversion gracefully retries the
          operation against a new, updated (and yet still static) view
          of the database.</p><p>Another great feature of Berkeley DB is <em class="firstterm">hot
          backups</em>—the ability to backup the database
          environment without taking it «<span class="quote">offline</span>».  We'll
          discuss how to backup your repository in <a href="#svn.reposadmin.maint.backup" title="Repository Backup">la sezione chiamata «Repository Backup»</a>, but the benefits of being
          able to make fully functional copies of your repositories
          without any downtime should be obvious.</p><p>Berkeley DB is also a very reliable database system.
          Subversion uses Berkeley DB's logging facilities, which
          means that the database first writes to on-disk log files a
          description of any modifications it is about to make, and
          then makes the modification itself.  This is to ensure that
          if anything goes wrong, the database system can back up to
          a previous <em class="firstterm">checkpoint</em>—a
          location in the log files known not to be corrupt—and
          replay transactions until the data is restored to a usable
          state.  See <a href="#svn.reposadmin.maint.diskspace" title="Managing Disk Space">la sezione chiamata «Managing Disk Space»</a> for more
          about Berkeley DB log files.</p><p>But every rose has its thorn, and so we must note some
          known limitations of Berkeley DB.  First, Berkeley DB
          environments are not portable.  You cannot simply copy a
          Subversion repository that was created on a Unix system onto
          a Windows system and expect it to work.  While much of the
          Berkeley DB database format is architecture independent,
          there are other aspects of the environment that are not.
          Secondly, Subversion uses Berkeley DB in a way that will not
          operate on Windows 95/98 systems—if you need to house
          a repository on a Windows machine, stick with Windows 2000
          or Windows XP.  Also, you should never keep a Berkeley DB
          repository on a network share.  While Berkeley DB promises
          to behave correctly on network shares that meet a particular
          set of specifications, almost no known shares actually meet
          all those specifications.</p><p>Finally, because Berkeley DB is a library linked
          directly into Subversion, it's more sensitive to
          interruptions than a typical relational database system.
          Most SQL systems, for example, have a dedicated server
          process that mediates all access to tables.  If a program
          accessing the database crashes for some reason, the database
          daemon notices the lost connection and cleans up any mess
          left behind.  And because the database daemon is the only
          process accessing the tables, applications don't need to
          worry about permission conflicts.  These things are not the
          case with Berkeley DB, however.  Subversion (and programs
          using Subversion libraries) access the database tables
          directly, which means that a program crash can leave the
          database in a temporarily inconsistent, inaccessible state.
          When this happens, an administrator needs to ask Berkeley DB
          to restore to a checkpoint, which is a bit of an annoyance.
          Other things can cause a repository to «<span class="quote">wedge</span>»
          besides crashed processes, such as programs conflicting over
          ownership and permissions on the database files.  So while a
          Berkeley DB repository is quite fast and scalable, it's best
          used by a single server process running as one
          user—such as Apache's <span><strong class="command">httpd</strong></span> or
          <span><strong class="command">svnserve</strong></span> (see <a href="#svn.serverconfig" title="Capitolo&#xA0;6.&#xA0;Server Configuration">Capitolo 6, <i>Server Configuration</i></a>)—rather than accessing it as
          many different users via <code class="literal">file:///</code> or
          <code class="literal">svn+ssh://</code> URLs.  If using a Berkeley DB
          repository directly as multiple users, be sure to read <a href="#svn.serverconfig.multimethod" title="Supporting Multiple Repository Access Methods">la sezione chiamata «Supporting Multiple Repository Access Methods»</a>.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.reposadmin.basics.backends.fsfs"></a>FSFS</h4></div></div></div><p>In mid-2004, a second type of repository storage system
          came into being: one which doesn't use a database at all.
          An FSFS repository stores a revision tree in a single file,
          and so all of a repository's revisions can be found in a
          single subdirectory full of numbered files.  Transactions
          are created in separate subdirectories.  When complete, a
          single transaction file is created and moved to the
          revisions directory, thus guaranteeing that commits are
          atomic.  And because a revision file is permanent and
          unchanging, the repository also can be backed up while
          «<span class="quote">hot</span>», just like a Berkeley DB repository.</p><p>The revision-file format represents a revision's
          directory structure, file contents, and deltas against files
          in other revision trees.  Unlike a Berkeley DB database,
          this storage format is portable across different operating
          systems and isn't sensitive to CPU architecture.  Because
          there's no journaling or shared-memory files being used, the
          repository can be safely accessed over a network filesystem
          and examined in a read-only environment.  The lack of
          database overhead also means that the overall repository
          size is a bit smaller.</p><p>FSFS has different performance characteristics too.
          When committing a directory with a huge number of files, FSFS
          uses an O(N) algorithm to append entries, while Berkeley DB
          uses an O(N^2) algorithm to rewrite the whole directory.  On
          the other hand, FSFS writes the latest version of a file as
          a delta against an earlier version, which means that
          checking out the latest tree is a bit slower than fetching
          the fulltexts stored in a Berkeley DB HEAD revision.  FSFS
          also has a longer delay when finalizing a commit, which
          could in extreme cases cause clients to time out when
          waiting for a response.</p><p>The most important distinction, however, is FSFS's
          inability to be «<span class="quote">wedged</span>» when something goes
          wrong.  If a process using a Berkeley DB database runs into
          a permissions problem or suddenly crashes, the database is
          left unusable until an administrator recovers it.  If the
          same scenarios happen to a process using an FSFS repository,
          the repository isn't affected at all.  At worst, some
          transaction data is left behind.</p><p>The only real argument against FSFS is its relative
          immaturity compared to Berkeley DB.  It hasn't been used or
          stress-tested nearly as much, and so a lot of these
          assertions about speed and scalability are just that:
          assertions, based on good guesses.  In theory, it promises a
          lower barrier to entry for new administrators and is less
          susceptible to problems.  In practice, only time will
          tell.</p></div></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.reposadmin.create"></a>Repository Creation and Configuration</h2></div></div></div><p>Creating a Subversion repository is an incredibly simple
      task.  The <span><strong class="command">svnadmin</strong></span> utility, provided with
      Subversion, has a subcommand for doing just that.  To create a
      new repository, just run:</p><pre class="screen">
$ svnadmin create /path/to/repos
</pre><p>This creates a new repository in the directory
      <code class="filename">/path/to/repos</code>.  This new repository begins
      life at revision 0, which is defined to consist of nothing but
      the top-level root (<code class="filename">/</code>) filesystem
      directory.  Initially, revision 0 also has a single revision
      property, <code class="literal">svn:date</code>, set to the time at which
      the repository was created.</p><p>In Subversion 1.2, a repository is created with an FSFS
      back-end by default (see <a href="#svn.reposadmin.basics.backends" title="Repository Data Stores">la sezione chiamata «Repository Data Stores»</a>).  The back-end can
      be explicitly chosen with the <code class="option">--fs-type</code>
      argument:</p><pre class="screen">
$ svnadmin create --fs-type fsfs /path/to/repos
$ svnadmin create --fs-type bdb /path/to/other/repos
</pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Avvertimento</h3><p>Do not create a Berkeley DB repository on a network
        share—it <span class="emphasis"><em>cannot</em></span> exist on a remote
        filesystem such as NFS, AFS, or Windows SMB.  Berkeley DB
        requires that the underlying filesystem implement strict POSIX
        locking semantics, and more importantly, the ability to map
        files directly into process memory.  Almost no network
        filesystems provide these features.  If you attempt to use
        Berkeley DB on a network share, the results are
        unpredictable—you may see mysterious errors right away,
        or it may be months before you discover that your repository
        database is subtly corrupted.</p><p>If you need multiple computers to access the repository,
        you create an FSFS repository on the network share, not a
        Berkeley DB repository.  Or better yet, set up a real server
        process (such as Apache or <span><strong class="command">svnserve</strong></span>), store
        the repository on a local filesystem which the server can
        access, and make the repository available over a network.
        <a href="#svn.serverconfig" title="Capitolo&#xA0;6.&#xA0;Server Configuration">Capitolo 6, <i>Server Configuration</i></a> covers this process in
        detail.</p></div><p>You may have noticed that the path argument to
      <span><strong class="command">svnadmin</strong></span> was just a regular filesystem path
      and not a URL like the <span><strong class="command">svn</strong></span> client program
      uses when referring to repositories.  Both
      <span><strong class="command">svnadmin</strong></span> and <span><strong class="command">svnlook</strong></span> are
      considered server-side utilities—they are used on the
      machine where the repository resides to examine or modify
      aspects of the repository, and are in fact unable to perform
      tasks across a network.  A common mistake made by Subversion
      newcomers is trying to pass URLs (even «<span class="quote">local</span>»
      <code class="literal">file:</code> ones) to these two programs.</p><p>So, after you've run the <span><strong class="command">svnadmin create</strong></span>
      command, you have a shiny new Subversion repository in its own
      directory.  Let's take a peek at what is actually created inside
      that subdirectory.</p><pre class="screen">
$ ls repos
conf/  dav/  db/  format  hooks/  locks/  README.txt
</pre><p>With the exception of the <code class="filename">README.txt</code> and
      <code class="filename">format</code> files,
      the repository directory is a collection of subdirectories.  As
      in other areas of the Subversion design, modularity is given
      high regard, and hierarchical organization is preferred to
      cluttered chaos.  Here is a brief description of all of
      the items you see in your new repository directory:</p><div class="variablelist"><dl><dt><span class="term">conf</span></dt><dd><p>A directory containing repository configuration files.</p></dd><dt><span class="term">dav</span></dt><dd><p>A directory provided to Apache and mod_dav_svn for
            their private housekeeping data.</p></dd><dt><span class="term">db</span></dt><dd><p>Where all of your versioned data resides.  This
            directory is either a Berkeley DB environment (full of DB
            tables and other things), or is an FSFS environment
            containing revision files.</p></dd><dt><span class="term">format</span></dt><dd><p>A file whose contents are a single integer value that
            dictates the version number of the repository layout.</p></dd><dt><span class="term">hooks</span></dt><dd><p>A directory full of hook script templates (and hook
            scripts themselves, once you've installed some).</p></dd><dt><span class="term">locks</span></dt><dd><p>A directory for Subversion's repository locking
            data, used for tracking accessors to the repository.</p></dd><dt><span class="term">README.txt</span></dt><dd><p>A file which merely informs its readers that they
            are looking at a Subversion repository.</p></dd></dl></div><p>In general, you shouldn't tamper with your repository
      «<span class="quote">by hand</span>».  The <span><strong class="command">svnadmin</strong></span> tool
      should be sufficient for any changes necessary to your
      repository, or you can look to third-party tools (such as
      Berkeley DB's tool suite) for tweaking relevant subsections of
      the repository.  Some exceptions exist, though, and we'll cover
      those here.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.reposadmin.create.hooks"></a>Hook Scripts</h3></div></div></div><p>A <em class="firstterm">hook</em> is a program triggered by
        some repository event, such as the creation of a new revision
        or the modification of an unversioned property.  Each hook is
        handed enough information to tell what that event is, what
        target(s) it's operating on, and the username of the person
        who triggered the event.  Depending on the hook's output or
        return status, the hook program may continue the action, stop
        it, or suspend it in some way.</p><p>The <code class="filename">hooks</code> subdirectory is, by
        default, filled with templates for various repository
        hooks.</p><pre class="screen">
$ ls repos/hooks/
post-commit.tmpl          post-unlock.tmpl          pre-revprop-change.tmpl
post-lock.tmpl            pre-commit.tmpl           pre-unlock.tmpl
post-revprop-change.tmpl  pre-lock.tmpl             start-commit.tmpl
</pre><p>There is one template for each hook that the Subversion
        repository implements, and by examining the contents of those
        template scripts, you can see what triggers each such script
        to run and what data is passed to that script.  Also present
        in many of these templates are examples of how one might use
        that script, in conjunction with other Subversion-supplied
        programs, to perform common useful tasks.  To actually install
        a working hook, you need only place some executable program or
        script into the <code class="filename">repos/hooks</code> directory
        which can be executed as the name (like
        <span><strong class="command">start-commit</strong></span> or
        <span><strong class="command">post-commit</strong></span>) of the hook.</p><p>On Unix platforms, this means supplying a script or
        program (which could be a shell script, a Python program, a
        compiled C binary, or any number of other things) named
        exactly like the name of the hook.  Of course, the template
        files are present for more than just informational
        purposes—the easiest way to install a hook on Unix
        platforms is to simply copy the appropriate template file to a
        new file that lacks the <code class="literal">.tmpl</code> extension,
        customize the hook's contents, and ensure that the script is
        executable.  Windows, however, uses file extensions to
        determine whether or not a program is executable, so you would
        need to supply a program whose basename is the name of the
        hook, and whose extension is one of the special extensions
        recognized by Windows for executable programs, such as
        <code class="filename">.exe</code> or <code class="filename">.com</code> for
        programs, and <code class="filename">.bat</code> for batch
        files.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Suggerimento</h3><p>For security reasons, the Subversion repository executes
        hook scripts with an empty environment—that is, no
        environment variables are set at all, not even
        <code class="literal">$PATH</code> or <code class="literal">%PATH%</code>.
        Because of this, a lot of administrators are baffled when
        their hook script runs fine by hand, but doesn't work when run
        by Subversion.  Be sure to explicitly set environment
        variables in your hook and/or use absolute paths to
        programs.</p></div><p>There are nine hooks implemented by the Subversion
        repository:</p><div class="variablelist"><dl><dt><span class="term"><code class="filename">start-commit</code></span></dt><dd><p>This is run before the commit transaction is even
              created.  It is typically used to decide if the user has
              commit privileges at all.  The repository passes two
              arguments to this program: the path to the repository,
              and username which is attempting the commit.  If the
              program returns a non-zero exit value, the commit is
              stopped before the transaction is even created.  If the
              hook program writes data to stderr, it will be
              marshalled back to the client.</p></dd><dt><span class="term"><code class="filename">pre-commit</code></span></dt><dd><p>This is run when the transaction is complete, but
              before it is committed.  Typically, this hook is used to
              protect against commits that are disallowed due to
              content or location (for example, your site might
              require that all commits to a certain branch include a
              ticket number from the bug tracker, or that the incoming
              log message is non-empty).  The repository passes two
              arguments to this program: the path to the repository,
              and the name of the transaction being committed.  If the
              program returns a non-zero exit value, the commit is
              aborted and the transaction is removed.  If the hook
              program writes data to stderr, it will be marshalled
              back to the client.</p><p>The Subversion distribution includes some access
              control scripts (located in the
              <code class="filename">tools/hook-scripts</code> directory of the
              Subversion source tree) that can be called from
              <span><strong class="command">pre-commit</strong></span> to implement fine-grained
              write-access control.  Another option is to use the
              <span><strong class="command">mod_authz_svn</strong></span> Apache httpd module,
              which provides both read and write access control on
              individual directories (see <a href="#svn.serverconfig.httpd.authz.perdir" title="Per-Directory Access Control">la sezione chiamata «Per-Directory Access Control»</a>).  In a future version
              of Subversion, we plan to implement access control lists
              (ACLs) directly in the filesystem.</p></dd><dt><span class="term"><code class="filename">post-commit</code></span></dt><dd><p>This is run after the transaction is committed, and
              a new revision is created.  Most people use this hook to
              send out descriptive emails about the commit or to make
              a backup of the repository.  The repository passes two
              arguments to this program: the path to the repository,
              and the new revision number that was created.  The exit
              code of the program is ignored.</p><p>The Subversion distribution includes
              <span><strong class="command">mailer.py</strong></span> and
              <span><strong class="command">commit-email.pl</strong></span> scripts (located in
              the <code class="filename">tools/hook-scripts/</code> directory
              of the Subversion source tree) that can be used to send
              email with (and/or append to a log file) a description
              of a given commit.  This mail contains a list of the
              paths that were changed, the log message attached to the
              commit, the author and date of the commit, as well as a
              GNU diff-style display of the changes made to the
              various versioned files as part of the commit.</p><p>Another useful tool provided by Subversion is the
              <span><strong class="command">hot-backup.py</strong></span> script (located in the
              <code class="filename">tools/backup/</code> directory of the
              Subversion source tree).  This script performs hot
              backups of your Subversion repository (a feature
              supported by the Berkeley DB database back-end), and can
              be used to make a per-commit snapshot of your repository
              for archival or emergency recovery purposes.</p></dd><dt><span class="term"><code class="filename">pre-revprop-change</code></span></dt><dd><p>Because Subversion's revision properties are not
              versioned, making modifications to such a property (for
              example, the <code class="literal">svn:log</code> commit message
              property) will overwrite the previous value of that
              property forever.  Since data can be potentially lost
              here, Subversion supplies this hook (and its
              counterpart, <code class="filename">post-revprop-change</code>)
              so that repository administrators can keep records of
              changes to these items using some external means if
              they so desire.  As a precaution against losing
              unversioned property data, Subversion clients will not
              be allowed to remotely modify revision properties at all
              unless this hook is implemented for your repository.</p><p>This hook runs just before such a modification is
              made to the repository.  The repository passes four
              arguments to this hook: the path to the repository, the
              revision on which the to-be-modified property exists, the
              authenticated username of the person making the change,
              and the name of the property itself.</p></dd><dt><span class="term"><code class="filename">post-revprop-change</code></span></dt><dd><p>As mentioned earlier, this hook is the counterpart
              of the <code class="filename">pre-revprop-change</code> hook.  In
              fact, for the sake of paranoia this script will not run
              unless the <code class="filename">pre-revprop-change</code> hook
              exists.  When both of these hooks are present, the
              <code class="filename">post-revprop-change</code> hook runs just
              after a revision property has been changed, and is
              typically used to send an email containing the new value
              of the changed property.  The repository passes four
              arguments to this hook: the path to the repository, the
              revision on which the property exists, the authenticated
              username of the person making the change, and the name of
              the property itself.</p><p>The Subversion distribution includes a
              <span><strong class="command">propchange-email.pl</strong></span> script (located
              in the <code class="filename">tools/hook-scripts/</code>
              directory of the Subversion source tree) that can be
              used to send email with (and/or append to a log file)
              the details of a revision property change.  This mail
              contains the revision and name of the changed property,
              the user who made the change, and the new property
              value.</p></dd><dt><span class="term"><code class="filename">pre-lock</code></span></dt><dd><p>This hook runs whenever someone attempts to lock a
              file.  It can be used to prevent locks altogether, or to
              create a more complex policy specifying exactly which
              users are allowed to lock particular paths.  If the hook
              notices a pre-existing lock, then it can also decide
              whether a user is allowed to «<span class="quote">steal</span>» the
              existing lock.  The repository passes three arguments to
              the hook: the path to the repository, the path being
              locked, and the user attempting to perform the lock.  If
              the program returns a non-zero exit value, the lock
              action is aborted and anything printed to stderr is
              marshalled back to the client.</p></dd><dt><span class="term"><code class="filename">post-lock</code></span></dt><dd><p>This hook runs after a path is locked.  The locked
              path is passed to the hook's stdin, and the hook also
              receives two arguments:  the path to the repository, and
              the user who performed the lock.  The hook is then free
              to send email notification or record the event in any
              way it chooses.  Because the lock already happened, the
              output of the hook is ignored.</p></dd><dt><span class="term"><code class="filename">pre-unlock</code></span></dt><dd><p>This hook runs whenever someone attempts to remove a
              lock on a file.  It can be used to create policies that
              specify which users are allowed to unlock particular
              paths.  It's particularly important for determining
              policies about lock breakage.  If user A locks a file,
              is user B allowed to break the lock?  What if the lock
              is more than a week old?  These sorts of things can be
              decided and enforced by the hook.  The repository passes
              three arguments to the hook: the path to the repository,
              the path being unlocked, and the user attempting to
              remove the lock.  If the program returns a non-zero exit
              value, the unlock action is aborted and anything printed
              to stderr is marshalled back to the client.</p></dd><dt><span class="term"><code class="filename">post-unlock</code></span></dt><dd><p>This hook runs after a path is unlocked.  The
              unlocked path is passed to the hook's stdin, and the
              hook also receives two arguments: the path to the
              repository, and the user who removed the lock.  The hook
              is then free to send email notification or record the
              event in any way it chooses.  Because the lock removal
              already happened, the output of the hook is
              ignored.</p></dd></dl></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Avvertimento</h3><p>Do not attempt to modify the transaction using hook
          scripts.  A common example of this would be to automatically
          set properties such as <code class="literal">svn:eol-style</code> or
          <code class="literal">svn:mime-type</code> during the commit.  While
          this might seem like a good idea, it causes problems.  The
          main problem is that the client does not know about the
          change made by the hook script, and there is no way to
          inform the client that it is out-of-date.  This
          inconsistency can lead to surprising and unexpected
          behavior.</p><p>Instead of attempting to modify the transaction, it is
          much better to <span class="emphasis"><em>check</em></span> the transaction in
          the <code class="filename">pre-commit</code> hook and reject the
          commit if it does not meet the desired requirements.</p></div><p>Subversion will attempt to execute hooks as the same user
        who owns the process which is accessing the Subversion
        repository.  In most cases, the repository is being accessed
        via Apache HTTP server and mod_dav_svn, so this user is the
        same user that Apache runs as.  The hooks themselves will need
        to be configured with OS-level permissions that allow that
        user to execute them.  Also, this means that any file or
        programs (including the Subversion repository itself) accessed
        directly or indirectly by the hook will be accessed as the
        same user.  In other words, be alert to potential
        permission-related problems that could prevent the hook from
        performing the tasks you've written it to perform.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.reposadmin.create.bdb"></a>Berkeley DB Configuration</h3></div></div></div><p>A Berkeley DB environment is an encapsulation of one or
        more databases, log files, region files and configuration
        files.  The Berkeley DB environment has its own set of default
        configuration values for things like the number of database locks
        allowed to be taken out at any given time, or the maximum size
        of the journaling log files, etc.  Subversion's filesystem
        code additionally chooses default values for some of the
        Berkeley DB configuration options.  However, sometimes your
        particular repository, with its unique collection of data and
        access patterns, might require a different set of
        configuration option values.</p><p>The folks at Sleepycat (the producers of Berkeley DB)
        understand that different databases have different
        requirements, and so they have provided a mechanism for
        overriding at runtime many of the configuration values for the
        Berkeley DB environment.  Berkeley checks for the presence of
        a file named <code class="filename">DB_CONFIG</code> in each
        environment directory, and parses the options found in that
        file for use with that particular Berkeley environment.</p><p>The Berkeley configuration file for your repository is
        located in the <code class="filename">db</code> environment directory,
        at <code class="filename">repos/db/DB_CONFIG</code>.  Subversion itself
        creates this file when it creates the rest of the repository.
        The file initially contains some default options, as well as
        pointers to the Berkeley DB online documentation so you can
        read about what those options do.  Of course, you are free to
        add any of the supported Berkeley DB options to your
        <code class="filename">DB_CONFIG</code> file.  Just be aware that while
        Subversion never attempts to read or interpret the contents of
        the file, and makes no use of the option settings in it,
        you'll want to avoid any configuration changes that may cause
        Berkeley DB to behave in a fashion that is unexpected by the
        rest of the Subversion code.  Also, changes made to
        <code class="filename">DB_CONFIG</code> won't take effect until you
        recover the database environment (using <span><strong class="command">svnadmin
        recover</strong></span>).</p></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.reposadmin.maint"></a>Repository Maintenance</h2></div></div></div><p>Maintaining a Subversion repository can be a daunting task,
      mostly due to the complexities inherent in systems which have a
      database backend.  Doing the task well is all about knowing the
      tools—what they are, when to use them, and how to use
      them.  This section will introduce you to the repository
      administration tools provided by Subversion, and how to wield
      them to accomplish tasks such as repository migrations,
      upgrades, backups and cleanups.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.reposadmin.maint.tk"></a>An Administrator's Toolkit</h3></div></div></div><p>Subversion provides a handful of utilities useful for
        creating, inspecting, modifying and repairing your repository.
        Let's look more closely at each of those tools.  Afterward,
        we'll briefly examine some of the utilities included in the
        Berkeley DB distribution that provide functionality specific
        to your repository's database backend not otherwise provided
        by Subversion's own tools.</p><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.reposadmin.maint.tk.svnlook"></a>svnlook</h4></div></div></div><p><span><strong class="command">svnlook</strong></span> is a tool provided by
          Subversion for examining the various revisions and
          transactions in a repository.  No part of this program
          attempts to change the repository—it's a
          «<span class="quote">read-only</span>» tool.  <span><strong class="command">svnlook</strong></span>
          is typically used by the repository hooks for reporting the
          changes that are about to be committed (in the case of the
          <span><strong class="command">pre-commit</strong></span> hook) or that were just
          committed (in the case of the <span><strong class="command">post-commit</strong></span>
          hook) to the repository.  A repository administrator may use
          this tool for diagnostic purposes.</p><p><span><strong class="command">svnlook</strong></span> has a straightforward
          syntax:</p><pre class="screen">
$ svnlook help
general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]
Note: any subcommand which takes the '--revision' and '--transaction'
      options will, if invoked without one of those options, act on
      the repository's youngest revision.
Type "svnlook help &lt;subcommand&gt;" for help on a specific subcommand.
…
</pre><p>Nearly every one of <span><strong class="command">svnlook</strong></span>'s
          subcommands can operate on either a revision or a
          transaction tree, printing information about the tree
          itself, or how it differs from the previous revision of the
          repository.  You use the <code class="option">--revision</code> and
          <code class="option">--transaction</code> options to specify which
          revision or transaction, respectively, to examine.  Note
          that while revision numbers appear as natural numbers,
          transaction names are alphanumeric strings.  Keep in mind
          that the filesystem only allows browsing of uncommitted
          transactions (transactions that have not resulted in a new
          revision).  Most repositories will have no such
          transactions, because transactions are usually either
          committed (which disqualifies them from viewing) or aborted
          and removed.</p><p>In the absence of both the <code class="option">--revision</code>
          and <code class="option">--transaction</code> options,
          <span><strong class="command">svnlook</strong></span> will examine the youngest (or
          «<span class="quote">HEAD</span>») revision in the repository.  So the
          following two commands do exactly the same thing when 19 is
          the youngest revision in the repository located at
          <code class="filename">/path/to/repos</code>:</p><pre class="screen">
$ svnlook info /path/to/repos
$ svnlook info /path/to/repos --revision 19
</pre><p>The only exception to these rules about subcommands is
          the <span><strong class="command">svnlook youngest</strong></span> subcommand, which
          takes no options, and simply prints out the
          <code class="literal">HEAD</code> revision number.</p><pre class="screen">
$ svnlook youngest /path/to/repos
19
</pre><p>Output from <span><strong class="command">svnlook</strong></span> is designed to be
          both human- and machine-parsable.  Take as an example the output
          of the <code class="literal">info</code> subcommand:</p><pre class="screen">
$ svnlook info /path/to/repos
sally
2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)
27
Added the usual
Greek tree.
</pre><p>The output of the <code class="literal">info</code> subcommand is
          defined as:</p><div class="orderedlist"><ol type="1"><li><p>The author, followed by a newline.</p></li><li><p>The date, followed by a newline.</p></li><li><p>The number of characters in the log message,
              followed by a newline.</p></li><li><p>The log message itself, followed by a newline.</p></li></ol></div><p>This output is human-readable, meaning items like the
          datestamp are displayed using a textual representation
          instead of something more obscure (such as the number of
          nanoseconds since the Tasty Freeze guy drove by).  But this
          output is also machine-parsable—because the log
          message can contain multiple lines and be unbounded in
          length, <span><strong class="command">svnlook</strong></span> provides the length of
          that message before the message itself.  This allows scripts
          and other wrappers around this command to make intelligent
          decisions about the log message, such as how much memory to
          allocate for the message, or at least how many bytes to skip
          in the event that this output is not the last bit of data in
          the stream.</p><p>Another common use of <span><strong class="command">svnlook</strong></span> is to
          actually view the contents of a revision or transaction
          tree.  The <span><strong class="command">svnlook tree</strong></span> command displays
          the directories and files in the requested tree.  If you
          supply the <code class="option">--show-ids</code> option, it will also
          show the filesystem node revision IDs for each of those
          paths (which is generally of more use to developers than to
          users).</p><pre class="screen">
$ svnlook tree /path/to/repos --show-ids
/ &lt;0.0.1&gt;
 A/ &lt;2.0.1&gt;
  B/ &lt;4.0.1&gt;
   lambda &lt;5.0.1&gt;
   E/ &lt;6.0.1&gt;
    alpha &lt;7.0.1&gt;
    beta &lt;8.0.1&gt;
   F/ &lt;9.0.1&gt;
  mu &lt;3.0.1&gt;
  C/ &lt;a.0.1&gt;
  D/ &lt;b.0.1&gt;
   gamma &lt;c.0.1&gt;
   G/ &lt;d.0.1&gt;
    pi &lt;e.0.1&gt;
    rho &lt;f.0.1&gt;
    tau &lt;g.0.1&gt;
   H/ &lt;h.0.1&gt;
    chi &lt;i.0.1&gt;
    omega &lt;k.0.1&gt;
    psi &lt;j.0.1&gt;
 iota &lt;1.0.1&gt;
</pre><p>Once you've seen the layout of directories and files in
          your tree, you can use commands like <span><strong class="command">svnlook
          cat</strong></span>, <span><strong class="command">svnlook propget</strong></span>, and
          <span><strong class="command">svnlook proplist</strong></span> to dig into the details
          of those files and directories.</p><p><span><strong class="command">svnlook</strong></span> can perform a variety of
          other queries, displaying subsets of bits of information
          we've mentioned previously, reporting which paths were
          modified in a given revision or transaction, showing textual
          and property differences made to files and directories, and
          so on.  The following is a brief description of the current
          list of subcommands accepted by <span><strong class="command">svnlook</strong></span>,
          and the output of those subcommands:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">author</code></span></dt><dd><p>Print the tree's author.</p></dd><dt><span class="term"><code class="literal">cat</code></span></dt><dd><p>Print the contents of a file in the tree.</p></dd><dt><span class="term"><code class="literal">changed</code></span></dt><dd><p>List all files and directories that changed in the 
                tree.</p></dd><dt><span class="term"><code class="literal">date</code></span></dt><dd><p>Print the tree's datestamp.</p></dd><dt><span class="term"><code class="literal">diff</code></span></dt><dd><p>Print unified diffs of changed files.</p></dd><dt><span class="term"><code class="literal">dirs-changed</code></span></dt><dd><p>List the directories in the tree that were
                themselves changed, or whose file children were
                changed.</p></dd><dt><span class="term"><code class="literal">history</code></span></dt><dd><p>Display interesting points in the history of a
                versioned path (places where modifications or copies
                occurred).</p></dd><dt><span class="term"><code class="literal">info</code></span></dt><dd><p>Print the tree's author, datestamp, log message
                character count, and log message.</p></dd><dt><span class="term"><code class="literal">lock</code></span></dt><dd><p>If a path is locked, describe the lock attributes.</p></dd><dt><span class="term"><code class="literal">log</code></span></dt><dd><p>Print the tree's log message.</p></dd><dt><span class="term"><code class="literal">propget</code></span></dt><dd><p>Print the value of a property on a path in the
                tree.</p></dd><dt><span class="term"><code class="literal">proplist</code></span></dt><dd><p>Print the names and values of properties set on paths
                in the tree.</p></dd><dt><span class="term"><code class="literal">tree</code></span></dt><dd><p>Print the tree listing, optionally revealing the
                filesystem node revision IDs associated with each
                path.</p></dd><dt><span class="term"><code class="literal">uuid</code></span></dt><dd><p>Print the repository's UUID—
                <span class="emphasis"><em>U</em></span>niversal <span class="emphasis"><em>U</em></span>nique
                <span class="emphasis"><em>ID</em></span>entifier.</p></dd><dt><span class="term"><code class="literal">youngest</code></span></dt><dd><p>Print the youngest revision number.</p></dd></dl></div></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.reposadmin.maint.tk.svnadmin"></a>svnadmin</h4></div></div></div><p>The <span><strong class="command">svnadmin</strong></span> program is the
          repository administrator's best friend.  Besides providing
          the ability to create Subversion repositories, this program
          allows you to perform several maintenance operations on
          those repositories.  The syntax of
          <span><strong class="command">svnadmin</strong></span> is similar to that of
          <span><strong class="command">svnlook</strong></span>:</p><pre class="screen">
$ svnadmin help
general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp; OPTIONS ...]
Type "svnadmin help &lt;subcommand&gt;" for help on a specific subcommand.

Available subcommands:
   create
   deltify
   dump
   help (?, h)
…
</pre><p>We've already mentioned <span><strong class="command">svnadmin</strong></span>'s
          <code class="literal">create</code> subcommand (see <a href="#svn.reposadmin.create" title="Repository Creation and Configuration">la sezione chiamata «Repository Creation and Configuration»</a>).  Most of the others we will
          cover in more detail later in this chapter.  For now, let's
          just take a quick glance at what each of the available
          subcommands offers.</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">create</code></span></dt><dd><p>Create a new Subversion repository.</p></dd><dt><span class="term"><code class="literal">deltify</code></span></dt><dd><p>Run over a specified revision range, performing
                predecessor deltification on the paths changed in
                those revisions.  If no revisions are specified, this
                command will simply deltify the
                <code class="literal">HEAD</code> revision.</p></dd><dt><span class="term"><code class="literal">dump</code></span></dt><dd><p>Dump the contents of the repository, bounded by a
                given set of revisions, using a portable dump format.</p></dd><dt><span class="term"><code class="literal">hotcopy</code></span></dt><dd><p>Make a hot copy of a repository.  You can run
                this command at any time and make a safe copy of the
                repository, regardless if other processes are using
                the repository.</p></dd><dt><span class="term"><code class="literal">list-dblogs</code></span></dt><dd><p>(Berkeley DB repositories only.)  List the paths
                of Berkeley DB log files associated with the
                repository.  This list includes all log
                files—those still in use by Subversion, as well
                as those no longer in use.</p></dd><dt><span class="term"><code class="literal">list-unused-dblogs</code></span></dt><dd><p>(Berkeley DB repositories only.)  List the paths
                of Berkeley DB log files associated with, but no
                longer used by, the repository.  You may safely remove
                these log files from the repository layout, possibly
                archiving them for use in the event that you ever need
                to perform a catastrophic recovery of the
                repository.</p></dd><dt><span class="term"><code class="literal">load</code></span></dt><dd><p>Load a set of revisions into a repository from a
                stream of data that uses the same portable dump format
                generated by the <code class="literal">dump</code> subcommand.</p></dd><dt><span class="term"><code class="literal">lslocks</code></span></dt><dd><p>List and describe any locks that exist in the
                repository.</p></dd><dt><span class="term"><code class="literal">lstxns</code></span></dt><dd><p>List the names of uncommitted Subversion
                transactions that currently exist in the repository.</p></dd><dt><span class="term"><code class="literal">recover</code></span></dt><dd><p>Perform recovery steps on a repository that is in
                need of such, generally after a fatal error has
                occurred that prevented a process from cleanly
                shutting down its communication with the repository.</p></dd><dt><span class="term"><code class="literal">rmlocks</code></span></dt><dd><p>Unconditionally remove locks from listed
                paths.</p></dd><dt><span class="term"><code class="literal">rmtxns</code></span></dt><dd><p>Cleanly remove Subversion transactions from the
                repository (conveniently fed by output from the
                <code class="literal">lstxns</code> subcommand).</p></dd><dt><span class="term"><code class="literal">setlog</code></span></dt><dd><p>Replace the current value of the
                <code class="literal">svn:log</code> (commit log message)
                property on a given revision in the repository with a
                new value.</p></dd><dt><span class="term"><code class="literal">verify</code></span></dt><dd><p>Verify the contents of the repository.  This includes,
                among other things, checksum comparisons of the
                versioned data stored in the repository.</p></dd></dl></div></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.reposadmin.maint.tk.svndumpfilter"></a>svndumpfilter</h4></div></div></div><p>Since Subversion stores everything in an opaque database
          system, attempting manual tweaks is unwise, if not quite
          difficult.  And once data has been stored in your
          repository, Subversion generally doesn't provide an
          easy way to remove that data.
          <sup>[<a id="id4743767" href="#ftn.id4743767">15</a>]</sup>
          But inevitably, there will be times when you would like to
          manipulate the history of your repository.  You might need
          to strip out all instances of a file that was accidentally
          added to the repository (and shouldn't be there for whatever
          reason).  Or, perhaps you have multiple projects sharing a
          single repository, and you decide to split them up into
          their own repositories.  To accomplish tasks like this,
          administrators need a more manageable and malleable
          representation of the data in their repositories—the
          Subversion repository dump format.</p><p>The Subversion repository dump format is a
          human-readable representation of the changes that you've
          made to your versioned data over time.  You use the
          <span><strong class="command">svnadmin dump</strong></span> command to generate the
          dump data, and <span><strong class="command">svnadmin load</strong></span> to populate
          a new repository with it (see <a href="#svn.reposadmin.maint.migrate" title="Migrating a Repository">la sezione chiamata «Migrating a Repository»</a>).  The great thing about the
          human-readability aspect of the dump format is that, if you
          aren't careless about it, you can manually inspect and
          modify it.  Of course, the downside is that if you have two
          years' worth of repository activity encapsulated in what is
          likely to be a very large dump file, it could take you a
          long, long time to manually inspect and modify it.</p><p>While it won't be the most commonly used tool at the
          administrator's disposal, <span><strong class="command">svndumpfilter</strong></span>
          provides a very particular brand of useful
          functionality—the ability to quickly and easily modify
          that dump data by acting as a path-based filter.  Simply
          give it either a list of paths you wish to keep, or a list
          of paths you wish to not keep, then pipe your repository
          dump data through this filter.  The result will be a
          modified stream of dump data that contains only the
          versioned paths you (explicitly or implicitly) requested.</p><p>The syntax of <span><strong class="command">svndumpfilter</strong></span> is as
          follows:</p><pre class="screen">
$ svndumpfilter help
general usage: svndumpfilter SUBCOMMAND [ARGS &amp; OPTIONS ...]
Type "svndumpfilter help &lt;subcommand&gt;" for help on a specific subcommand.

Available subcommands:
   exclude
   include
   help (?, h)
</pre><p>There are only two interesting subcommands.  They allow
          you to make the choice between explicit or implicit
          inclusion of paths in the stream:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">exclude</code></span></dt><dd><p>Filter out a set of paths from the dump data
                stream.</p></dd><dt><span class="term"><code class="literal">include</code></span></dt><dd><p>Allow only the requested set of paths to pass
                through the dump data stream.</p></dd></dl></div><p>Let's look a realistic example of how you might use this
          program.  We discuss elsewhere (see <a href="#svn.reposadmin.projects.chooselayout" title="Choosing a Repository Layout">la sezione chiamata «Choosing a Repository Layout»</a>) the process of deciding how to
          choose a layout for the data in your
          repositories—using one repository per project or
          combining them, arranging stuff within your repository, and
          so on.  But sometimes after new revisions start flying in,
          you rethink your layout and would like to make some changes.
          A common change is the decision to move multiple projects
          which are sharing a single repository into separate
          repositories for each project.</p><p>Our imaginary repository contains three projects:
          <code class="literal">calc</code>, <code class="literal">calendar</code>, and
          <code class="literal">spreadsheet</code>.  They have been living
          side-by-side in a layout like this:</p><pre class="screen">
/
   calc/
      trunk/
      branches/
      tags/
   calendar/
      trunk/
      branches/
      tags/
   spreadsheet/
      trunk/
      branches/
      tags/
</pre><p>To get these three projects into their own repositories,
          we first dump the whole repository:</p><pre class="screen">
$ svnadmin dump /path/to/repos &gt; repos-dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
* Dumped revision 3.
…
$
</pre><p>Next, run that dump file through the filter, each time
          including only one of our top-level directories, and
          resulting in three new dump files:</p><pre class="screen">
$ cat repos-dumpfile | svndumpfilter include calc &gt; calc-dumpfile
…
$ cat repos-dumpfile | svndumpfilter include calendar &gt; cal-dumpfile
…
$ cat repos-dumpfile | svndumpfilter include spreadsheet &gt; ss-dumpfile
…
$
</pre><p>At this point, you have to make a decision.  Each of
          your dump files will create a valid repository,
          but will preserve the paths exactly as they were in the
          original repository.  This means that even though you would
          have a repository solely for your <code class="literal">calc</code>
          project, that repository would still have a top-level
          directory named <code class="filename">calc</code>.  If you want
          your <code class="filename">trunk</code>, <code class="filename">tags</code>,
          and <code class="filename">branches</code> directories to live in the
          root of your repository, you might wish to edit your
          dump files, tweaking the <code class="literal">Node-path</code> and
          <code class="literal">Node-copyfrom-path</code> headers to no longer have
          that first <code class="filename">calc/</code> path component.  Also,
          you'll want to remove the section of dump data that creates
          the <code class="filename">calc</code> directory.  It will look
          something like:</p><pre class="screen">
Node-path: calc
Node-action: add
Node-kind: dir
Content-length: 0

</pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Avvertimento</h3><p>If you do plan on manually editing the dump file to
            remove a top-level directory, make sure that your editor is
            not set to automatically convert end-lines to the native
            format (e.g. \r\n to \n) as the content will then not agree
            with the metadata and this will render the dump file
            useless.</p></div><p>All that remains now is to create your three new
          repositories, and load each dump file into the right
          repository:</p><pre class="screen">
$ svnadmin create calc; svnadmin load calc &lt; calc-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : button.c ... done.
…
$ svnadmin create calendar; svnadmin load calendar &lt; cal-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : cal.c ... done.
…
$ svnadmin create spreadsheet; svnadmin load spreadsheet &lt; ss-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : ss.c ... done.
…
$
</pre><p>Both of <span><strong class="command">svndumpfilter</strong></span>'s subcommands
          accept options for deciding how to deal with
          «<span class="quote">empty</span>» revisions.  If a given revision
          contained only changes to paths that were filtered out, that
          now-empty revision could be considered uninteresting or even
          unwanted.  So to give the user control over what to do with
          those revisions, <span><strong class="command">svndumpfilter</strong></span> provides
          the following command-line options:</p><div class="variablelist"><dl><dt><span class="term"><code class="option">--drop-empty-revs</code></span></dt><dd><p>Do not generate empty revisions at all—just
                omit them.</p></dd><dt><span class="term"><code class="option">--renumber-revs</code></span></dt><dd><p>If empty revisions are dropped (using the
                <code class="option">--drop-empty-revs</code> option), change the
                revision numbers of the remaining revisions so that
                there are no gaps in the numeric sequence.</p></dd><dt><span class="term"><code class="option">--preserve-revprops</code></span></dt><dd><p>If empty revisions are not dropped, preserve the
                revision properties (log message, author, date, custom
                properties, etc.) for those empty revisions.
                Otherwise, empty revisions will only contain the
                original datestamp, and a generated log message that
                indicates that this revision was emptied by
                <span><strong class="command">svndumpfilter</strong></span>.</p></dd></dl></div><p>While <span><strong class="command">svndumpfilter</strong></span> can be very
          useful, and a huge timesaver, there are unfortunately a
          couple of gotchas.  First, this utility is overly sensitive
          to path semantics.  Pay attention to whether paths in your
          dump file are specified with or without leading slashes.
          You'll want to look at the <code class="literal">Node-path</code> and
          <code class="literal">Node-copyfrom-path</code> headers.</p><pre class="screen">
…
Node-path: spreadsheet/Makefile
…
</pre><p>If the paths have leading slashes, you should
          include leading slashes in the paths you pass to
          <span><strong class="command">svndumpfilter include</strong></span> and
          <span><strong class="command">svndumpfilter exclude</strong></span> (and if they don't,
          you shouldn't).  Further, if your dump file has an inconsistent
          usage of leading slashes for some reason,
          <sup>[<a id="id4744262" href="#ftn.id4744262">16</a>]</sup>
          you should probably normalize those paths so they all
          have, or lack, leading slashes.</p><p>Also, copied paths can give you some trouble.
          Subversion supports copy operations in the repository, where
          a new path is created by copying some already existing path.
          It is possible that at some point in the lifetime of your
          repository, you might have copied a file or directory from
          some location that <span><strong class="command">svndumpfilter</strong></span> is
          excluding, to a location that it is including.  In order to
          make the dump data self-sufficient,
          <span><strong class="command">svndumpfilter</strong></span> needs to still show the
          addition of the new path—including the contents of any
          files created by the copy—and not represent that
          addition as a copy from a source that won't exist in your
          filtered dump data stream.  But because the Subversion
          repository dump format only shows what was changed in each
          revision, the contents of the copy source might not be
          readily available.  If you suspect that you have any copies
          of this sort in your repository, you might want to rethink
          your set of included/excluded paths.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.reposadmin.maint.tk.bdbutil"></a>Berkeley DB Utilities</h4></div></div></div><p>If you're using a Berkeley DB repository, then all of
          your versioned filesystem's structure and data live in a set
          of database tables within the <code class="filename">db</code>
          subdirectory of your repository.  This subdirectory is a
          regular Berkeley DB environment directory, and can therefore
          be used in conjunction with any of the Berkeley database
          tools (you can see the documentation for these tools at
          Sleepycat's website,
          <a href="http://www.sleepycat.com/" target="_top">http://www.sleepycat.com/</a>).</p><p>For day-to-day Subversion use, these tools are
          unnecessary.  Most of the functionality typically needed for
          Subversion repositories has been duplicated in the
          <span><strong class="command">svnadmin</strong></span> tool.  For example,
          <span><strong class="command">svnadmin list-unused-dblogs</strong></span> and
          <span><strong class="command">svnadmin list-dblogs</strong></span> perform a
          subset of what is provided by the Berkeley
          <span><strong class="command">db_archive</strong></span> command, and <span><strong class="command">svnadmin
          recover</strong></span> reflects the common use cases of the
          <span><strong class="command">db_recover</strong></span> utility.</p><p>There are still a few Berkeley DB utilities that you
          might find useful.  The <span><strong class="command">db_dump</strong></span> and
          <span><strong class="command">db_load</strong></span> programs write and read,
          respectively, a custom file format which describes the keys
          and values in a Berkeley DB database.  Since Berkeley
          databases are not portable across machine architectures,
          this format is a useful way to transfer those databases from
          machine to machine, irrespective of architecture or
          operating system.  Also, the <span><strong class="command">db_stat</strong></span>
          utility can provide useful information about the status of
          your Berkeley DB environment, including detailed statistics
          about the locking and storage subsystems.</p></div></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.reposadmin.maint.cleanup"></a>Repository Cleanup</h3></div></div></div><p>Your Subversion repository will generally require very
        little attention once it is configured to your liking.
        However, there are times when some manual assistance from an
        administrator might be in order.  The
        <span><strong class="command">svnadmin</strong></span> utility provides some helpful
        functionality to assist you in performing such tasks as:</p><div class="itemizedlist"><ul type="disc"><li><p>modifying commit log messages,</p></li><li><p>removing dead transactions,</p></li><li><p>recovering «<span class="quote">wedged</span>» repositories, and</p></li><li><p>migrating repository contents to a different
            repository.</p></li></ul></div><p>Perhaps the most commonly used of
        <span><strong class="command">svnadmin</strong></span>'s subcommands is
        <code class="literal">setlog</code>.  When a transaction is committed to
        the repository and promoted to a revision, the descriptive log
        message associated with that new revision (and provided by the
        user) is stored as an unversioned property attached to the
        revision itself.  In other words, the repository remembers
        only the latest value of the property, and discards previous
        ones.</p><p>Sometimes a user will have an error in her log message (a
        misspelling or some misinformation, perhaps).  If the
        repository is configured (using the
        <code class="literal">pre-revprop-change</code> and
        <code class="literal">post-revprop-change</code> hooks; see <a href="#svn.reposadmin.create.hooks" title="Hook Scripts">la sezione chiamata «Hook Scripts»</a>) to accept changes to this log
        message after the commit is finished, then the user can
        «<span class="quote">fix</span>» her log message remotely using the
        <span><strong class="command">svn</strong></span> program's <code class="literal">propset</code>
        command (see <a href="#svn.ref" title="Capitolo&#xA0;9.&#xA0;Subversion Complete Reference">Capitolo 9, <i>Subversion Complete Reference</i></a>).  However, because of
        the potential to lose information forever, Subversion
        repositories are not, by default, configured to allow changes
        to unversioned properties—except by an administrator.</p><p>If a log message needs to be changed by an administrator,
        this can be done using <span><strong class="command">svnadmin setlog</strong></span>.
        This command changes the log message (the
        <code class="literal">svn:log</code> property) on a given revision of a
        repository, reading the new value from a provided file.</p><pre class="screen">
$ echo "Here is the new, correct log message" &gt; newlog.txt
$ svnadmin setlog myrepos newlog.txt -r 388
</pre><p>The <span><strong class="command">svnadmin setlog</strong></span> command alone is
        still bound by the same protections against modifying
        unversioned properties as a remote client is—the
        <code class="literal">pre-</code> and
        <code class="literal">post-revprop-change</code> hooks are still
        triggered, and therefore must be setup to accept changes of
        this nature.  But an administrator can get around these
        protections by passing the <code class="option">--bypass-hooks</code>
        option to the <span><strong class="command">svnadmin setlog</strong></span> command.</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Avvertimento</h3><p>Remember, though, that by bypassing the hooks, you are
          likely avoiding such things as email notifications of
          property changes, backup systems which track unversioned
          property changes, and so on.  In other words, be very
          careful about what you are changing, and how you change
          it.</p></div><p>Another common use of <span><strong class="command">svnadmin</strong></span> is to
        query the repository for outstanding—possibly
        dead—Subversion transactions.  In the event that a
        commit should fail, the transaction is usually cleaned up.
        That is, the transaction itself is removed from the
        repository, and any data associated with (and only with) that
        transaction is removed as well.  Occasionally, though, a
        failure occurs in such a way that the cleanup of the
        transaction never happens.  This could happen for several
        reasons: perhaps the client operation was inelegantly
        terminated by the user, or a network failure might have
        occurred in the middle of an operation, etc.  Regardless of
        the reason, dead transactions can happen.  They don't do any
        real harm, other than consuming a small bit of disk space.  A
        fastidious administrator may nonetheless want to remove
        them.</p><p>You can use <span><strong class="command">svnadmin</strong></span>'s
        <code class="literal">lstxns</code> command to list the names of the
        currently outstanding transactions.</p><pre class="screen">
$ svnadmin lstxns myrepos
19
3a1
a45
$
</pre><p>Each item in the resultant output can then be used with
        <span><strong class="command">svnlook</strong></span> (and its
        <code class="option">--transaction</code> option) to determine who
        created the transaction, when it was created, what types of
        changes were made in the transaction—in other words,
        whether or not the transaction is a safe candidate for
        removal!  If so, the transaction's name can be passed to
        <span><strong class="command">svnadmin rmtxns</strong></span>, which will perform the
        cleanup of the transaction.  In fact, the
        <code class="literal">rmtxns</code> subcommand can take its input
        directly from the output of <code class="literal">lstxns</code>!</p><pre class="screen">
$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`
$
</pre><p>If you use these two subcommands like this, you should
        consider making your repository temporarily inaccessible to
        clients.  That way, no one can begin a legitimate transaction
        before you start your cleanup.  The following is a little bit
        of shell-scripting that can quickly generate information about
        each outstanding transaction in your repository:</p><div class="example"><a id="svn.reposadmin.maint.cleanup.ex-1"></a><p class="title"><b>Esempio 5.1. txn-info.sh (Reporting Outstanding Transactions)</b></p><div class="example-contents"><pre class="programlisting">
#!/bin/sh

### Generate informational output for all outstanding transactions in
### a Subversion repository.

REPOS="${1}"
if [ "x$REPOS" = x ] ; then
  echo "usage: $0 REPOS_PATH"
  exit
fi

for TXN in `svnadmin lstxns ${REPOS}`; do 
  echo "---[ Transaction ${TXN} ]-------------------------------------------"
  svnlook info "${REPOS}" --transaction "${TXN}"
done
</pre></div></div><br class="example-break" /><p>You can run the previous script using
        <span><strong class="command">/path/to/txn-info.sh /path/to/repos</strong></span>.  The
        output is basically a concatenation of several chunks of
        <span><strong class="command">svnlook info</strong></span> output (see <a href="#svn.reposadmin.maint.tk.svnlook" title="svnlook">la sezione chiamata «svnlook»</a>), and will look something
        like:</p><pre class="screen">
$ txn-info.sh myrepos
---[ Transaction 19 ]-------------------------------------------
sally
2001-09-04 11:57:19 -0500 (Tue, 04 Sep 2001)
0
---[ Transaction 3a1 ]-------------------------------------------
harry
2001-09-10 16:50:30 -0500 (Mon, 10 Sep 2001)
39
Trying to commit over a faulty network.
---[ Transaction a45 ]-------------------------------------------
sally
2001-09-12 11:09:28 -0500 (Wed, 12 Sep 2001)
0
$
</pre><p>A long-abandoned transaction usually represents some sort
        of failed or interrupted commit.  A transaction's datestamp
        can provide interesting information—for example, how
        likely is it that an operation begun nine months ago is still
        active?</p><p>In short, transaction cleanup decisions need not be made
        unwisely.  Various sources of information—including
        Apache's error and access logs, the logs of successful
        Subversion commits, and so on—can be employed in the
        decision-making process.  Finally, an administrator can often
        simply communicate with a seemingly dead transaction's owner
        (via email, for example) to verify that the transaction is, in
        fact, in a zombie state.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.reposadmin.maint.diskspace"></a>Managing Disk Space</h3></div></div></div><p>While the cost of storage has dropped incredibly in the
          past few years, disk usage is still a valid concern for
          administrators seeking to version large amounts of data.
          Every additional byte consumed by the live repository is a
          byte that needs to be backed up offsite, perhaps multiple
          times as part of rotating backup schedules.  If using a
          Berkeley DB repository, the primary storage mechanism is a
          complex database system, it is useful to know what pieces of
          data need to remain on the live site, which need to be
          backed up, and which can be safely removed.  This section is
          specific to Berkeley DB;  FSFS repositories have no extra
          data to be cleaned up or reclaimed.</p><p>Until recently, the largest offender of disk space usage
          with respect to Subversion repositories was the log files to
          which Berkeley DB performs its pre-writes before modifying
          the actual database files.  These files capture all the
          actions taken along the route of changing the database from
          one state to another—while the database files reflect
          at any given time some state, the log files contain all the
          many changes along the way between states.  As such, they
          can start to accumulate quite rapidly.</p><p>Fortunately, beginning with the 4.2 release of Berkeley
          DB, the database environment has the ability to remove its
          own unused log files without any external procedures.  Any
          repositories created using an <span><strong class="command">svnadmin</strong></span>
          which is compiled against Berkeley DB version 4.2 or greater
          will be configured for this automatic log file removal.  If
          you don't want this feature enabled, simply pass the
          <code class="option">--bdb-log-keep</code> option to the
          <span><strong class="command">svnadmin create</strong></span> command.  If you forget
          to do this, or change your mind at a later time, simple edit
          the <code class="filename">DB_CONFIG</code> file found in your
          repository's <code class="filename">db</code> directory, comment out
          the line which contains the <code class="literal">set_flags
          DB_LOG_AUTOREMOVE</code> directive, and then run
          <span><strong class="command">svnadmin recover</strong></span> on your repository to
          force the configuration changes to take effect.  See <a href="#svn.reposadmin.create.bdb" title="Berkeley DB Configuration">la sezione chiamata «Berkeley DB Configuration»</a> for more information about
          database configuration.</p><p>Without some sort of automatic log file removal in
          place, log files will accumulate as you use your repository.
          This is actually somewhat of a feature of the database
          system—you should be able to recreate your entire
          database using nothing but the log files, so these files can
          be useful for catastrophic database recovery.  But
          typically, you'll want to archive the log files that are no
          longer in use by Berkeley DB, and then remove them from disk
          to conserve space.  Use the <span><strong class="command">svnadmin
          list-unused-dblogs</strong></span> command to list the unused
          log files:</p><pre class="screen">
$ svnadmin list-unused-dblogs /path/to/repos
/path/to/repos/log.0000000031
/path/to/repos/log.0000000032
/path/to/repos/log.0000000033

$ svnadmin list-unused-dblogs /path/to/repos | xargs rm
## disk space reclaimed!
</pre><p>To keep the size of the repository as small as possible,
          Subversion uses <em class="firstterm">deltification</em> (or,
          «<span class="quote">deltified storage</span>») within the repository
          itself.  Deltification involves encoding the representation
          of a chunk of data as a collection of differences against
          some other chunk of data.  If the two pieces of data are
          very similar, this deltification results in storage savings
          for the deltified chunk—rather than taking up space
          equal to the size of the original data, it only takes up
          enough space to say, «<span class="quote">I look just like this other
          piece of data over here, except for the following couple of
          changes</span>».  Specifically, each time a new version of a
          file is committed to the repository, Subversion encodes the
          previous version (actually, several previous versions) as a
          delta against the new version.  The result is that most of
          the repository data that tends to be sizable—namely,
          the contents of versioned files—is stored at a much
          smaller size than the original «<span class="quote">fulltext</span>»
          representation of that data.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Nota</h3><p>Because all of the Subversion repository data that is
            subject to deltification is stored in a single Berkeley DB
            database file, reducing the size of the stored values will
            not necessarily reduce the size of the database file
            itself.  Berkeley DB will, however, keep internal records
            of unused areas of the database file, and use those areas
            first before growing the size of the database file.  So
            while deltification doesn't produce immediate space
            savings, it can drastically slow future growth of the
            database.</p></div></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.reposadmin.maint.recovery"></a>Repository Recovery</h3></div></div></div><p>As mentioned in <a href="#svn.reposadmin.basics.backends.bdb" title="Berkeley DB">la sezione chiamata «Berkeley DB»</a>, a
        Berkeley DB repository can sometimes be left in frozen state
        if not closed properly.  When this happens, an administrator
        needs to rewind the database back into a consistent
        state.</p><p>In order to protect the data in your repository, Berkeley
        DB uses a locking mechanism.  This mechanism ensures that
        portions of the database are not simultaneously modified by
        multiple database accessors, and that each process sees the
        data in the correct state when that data is being read from
        the database.  When a process needs to change something in the
        database, it first checks for the existence of a lock on the
        target data.  If the data is not locked, the process locks the
        data, makes the change it wants to make, and then unlocks the
        data.  Other processes are forced to wait until that lock is
        removed before they are permitted to continue accessing that
        section of the database. (This has nothing to do with the
        locks that you, as a user, can apply to versioned files within
        the repository; see
        <a href="#svn.advanced.locking.meanings" title="Three meanings of &#xAB;lock&#xBB;">Three meanings of «<span class="quote">lock</span>»</a> for more
        information.)</p><p>In the course of using your Subversion repository, fatal
        errors (such as running out of disk space or available memory)
        or interruptions can prevent a process from having the chance to
        remove the locks it has placed in the database.  The result is
        that the back-end database system gets «<span class="quote">wedged</span>».
        When this happens, any attempts to access the repository hang
        indefinitely (since each new accessor is waiting for a lock to
        go away—which isn't going to happen).</p><p>First, if this happens to your repository, don't panic.
        The Berkeley DB filesystem takes advantage of database
        transactions and checkpoints and pre-write journaling to
        ensure that only the most catastrophic of events
        <sup>[<a id="id4745144" href="#ftn.id4745144">17</a>]</sup>
        can permanently destroy a database environment.  A
        sufficiently paranoid repository administrator will be making
        off-site backups of the repository data in some fashion, but
        don't call your system administrator to restore a backup tape
        just yet.</p><p>Secondly, use the following recipe to attempt to
        «<span class="quote">unwedge</span>» your repository:</p><div class="orderedlist"><ol type="1"><li><p>Make sure that there are no processes accessing (or
            attempting to access) the repository.  For networked
            repositories, this means shutting down the Apache HTTP
            Server, too.</p></li><li><p>Become the user who owns and manages the repository.
            This is important, as recovering a repository while
            running as the wrong user can tweak the permissions of the
            repository's files in such a way that your repository will
            still be inaccessible even after it is 
            «<span class="quote">unwedged</span>».</p></li><li><p>Run the command <span><strong class="command">svnadmin recover
            /path/to/repos</strong></span>.  You should see output like
            this:</p><pre class="screen">
Repository lock acquired.
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 19.
</pre><p>This command may take many minutes to complete.</p></li><li><p>Restart the Subversion server.</p></li></ol></div><p>This procedure fixes almost every case of repository
        lock-up.  Make sure that you run this command as the user that
        owns and manages the database, not just as
        <code class="literal">root</code>.  Part of the recovery process might
        involve recreating from scratch various database files (shared
        memory regions, for example).  Recovering as
        <code class="literal">root</code> will create those files such that they
        are owned by <code class="literal">root</code>, which means that even
        after you restore connectivity to your repository, regular
        users will be unable to access it.</p><p>If the previous procedure, for some reason, does not
        successfully unwedge your repository, you should do two
        things.  First, move your broken repository out of the way and
        restore your latest backup of it.  Then, send an email to the
        Subversion user list (at
        <code class="email">&lt;<a href="mailto:users@subversion.tigris.org">users@subversion.tigris.org</a>&gt;</code>) describing your
        problem in detail.  Data integrity is an extremely high
        priority to the Subversion developers.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.reposadmin.maint.migrate"></a>Migrating a Repository</h3></div></div></div><p>A Subversion filesystem has its data spread throughout
        various database tables in a fashion generally understood by
        (and of interest to) only the Subversion developers
        themselves.  However, circumstances may arise that call for
        all, or some subset, of that data to be collected into a
        single, portable, flat file format.  Subversion provides such
        a mechanism, implemented in a pair of
        <span><strong class="command">svnadmin</strong></span> subcommands:
        <code class="literal">dump</code> and <code class="literal">load</code>.</p><p>The most common reason to dump and load a Subversion
        repository is due to changes in Subversion itself.  As
        Subversion matures, there are times when certain changes made
        to the back-end database schema cause Subversion to be
        incompatible with previous versions of the repository.  Other
        reasons for dumping and loading might be to migrate a Berkeley
        DB repository to a new OS or CPU architecture, or to switch
        between Berkeley DB and FSFS back-ends.  The recommended
        course of action is relatively simple:</p><div class="orderedlist"><ol type="1"><li><p>Using your <span class="emphasis"><em>current</em></span> version of
            <span><strong class="command">svnadmin</strong></span>, dump your repositories to
            dump files.</p></li><li><p>Upgrade to the new version of Subversion.</p></li><li><p>Move your old repositories out of the way, and create
            new empty ones in their place using your
            <span class="emphasis"><em>new</em></span> <span><strong class="command">svnadmin</strong></span>.</p></li><li><p>Again using your <span class="emphasis"><em>new</em></span>
            <span><strong class="command">svnadmin</strong></span>, load your dump files into
            their respective, just-created repositories.</p></li><li><p>Be sure to copy any customizations from your old
            repositories to the new ones, including
            <code class="filename">DB_CONFIG</code> files and hook scripts.
            You'll want to pay attention to the release notes for the
            new release of Subversion to see if any changes since your
            last upgrade affect those hooks or configuration
            options.</p></li><li><p>If the migration process made your repository
            accessible at a different URL (e.g. moved to a different
            computer, or is being accessed via a different schema),
            then you'll probably want to tell your users to run
            <span><strong class="command">svn switch --relocate</strong></span> on their existing
            working copies.  See <a href="#svn.ref.svn.c.switch" title="svn switch">svn switch</a>.</p></li></ol></div><p><span><strong class="command">svnadmin dump</strong></span> will output a range of
        repository revisions that are formatted using Subversion's
        custom filesystem dump format.  The dump format is printed to
        the standard output stream, while informative messages are
        printed to the standard error stream.  This allows you to
        redirect the output stream to a file while watching the status
        output in your terminal window.  For example:</p><pre class="screen">
$ svnlook youngest myrepos
26
$ svnadmin dump myrepos &gt; dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
…
* Dumped revision 25.
* Dumped revision 26.
</pre><p>At the end of the process, you will have a single file
        (<code class="filename">dumpfile</code> in the previous example) that
        contains all the data stored in your repository in the
        requested range of revisions.  Note that <span><strong class="command">svnadmin
        dump</strong></span> is reading revision trees from the repository
        just like any other «<span class="quote">reader</span>» process would
        (<span><strong class="command">svn checkout</strong></span>, for example).  So it's safe
        to run this command at any time.</p><p>The other subcommand in the pair, <span><strong class="command">svnadmin
        load</strong></span>, parses the standard input stream as a
        Subversion repository dump file, and effectively replays those
        dumped revisions into the target repository for that
        operation.  It also gives informative feedback, this time
        using the standard output stream:</p><pre class="screen">
$ svnadmin load newrepos &lt; dumpfile
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : A ... done.
     * adding path : A/B ... done.
     …
------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 2
     * editing path : A/mu ... done.
     * editing path : A/D/G/rho ... done.

------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;

…

&lt;&lt;&lt; Started new txn, based on original revision 25
     * editing path : A/D/gamma ... done.

------- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 26
     * adding path : A/Z/zeta ... done.
     * editing path : A/mu ... done.

------- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;

</pre><p>The result of a load is new revisions added to a
        repository—the same thing you get by making commits
        against that repository from a regular Subversion client.  And
        just as in a commit, you can use hook scripts to perform
        actions before and after each of the commits made during a load
        process.  By passing the <code class="option">--use-pre-commit-hook</code> 
        and <code class="option">--use-post-commit-hook</code> options to
        <span><strong class="command">svnadmin load</strong></span>, you can instruct Subversion
        to execute the pre-commit and post-commit hook scripts,
        respectively, for each loaded revision.  You might use these,
        for example, to ensure that loaded revisions pass through the
        same validation steps that regular commits pass through.  Of
        course, you should use these options with care—if your
        post-commit hook sends emails to a mailing list for each new
        commit, you might not want to spew hundreds or thousands of
        commit emails in rapid succession at that list for each of the
        loaded revisions!  You can read more about the use of hook 
        scripts in <a href="#svn.reposadmin.create.hooks" title="Hook Scripts">la sezione chiamata «Hook Scripts»</a>.</p><p>Note that because <span><strong class="command">svnadmin</strong></span> uses
        standard input and output streams for the repository dump and
        load process, people who are feeling especially saucy can try
        things like this (perhaps even using different versions of
        <span><strong class="command">svnadmin</strong></span> on each side of the pipe):</p><pre class="screen">
$ svnadmin create newrepos
$ svnadmin dump myrepos | svnadmin load newrepos
</pre><p>By default, the dump file will be quite large—much
        larger than the repository itself.  That's because every
        version of every file is expressed as a full text in the
        dump file.  This is the fastest and simplest behavior, and nice
        if you're piping the dump data directly into some other
        process (such as a compression program, filtering program, or
        into a loading process).  But if you're creating a dump file for
        longer-term storage, you'll likely want to save disk space by
        using the <code class="option">--deltas</code> switch.  With this option,
        successive revisions of files will be output as compressed,
        binary differences—just as file revisions are stored in
        a repository.  This option is slower, but results in a
        dump file much closer in size to the original
        repository.</p><p>We mentioned previously that <span><strong class="command">svnadmin
        dump</strong></span> outputs a range of revisions.  Use the
        <code class="option">--revision</code> option to specify a single
        revision to dump, or a range of revisions.  If you omit this
        option, all the existing repository revisions will be
        dumped.</p><pre class="screen">
$ svnadmin dump myrepos --revision 23 &gt; rev-23.dumpfile
$ svnadmin dump myrepos --revision 100:200 &gt; revs-100-200.dumpfile
</pre><p>As Subversion dumps each new revision, it outputs only
        enough information to allow a future loader to re-create that
        revision based on the previous one.  In other words, for any
        given revision in the dump file, only the items that were
        changed in that revision will appear in the dump.  The only
        exception to this rule is the first revision that is dumped
        with the current <span><strong class="command">svnadmin dump</strong></span>
        command.</p><p>By default, Subversion will not express the first dumped
        revision as merely differences to be applied to the previous
        revision.  For one thing, there is no previous revision in the
        dump file!  And secondly, Subversion cannot know the state of
        the repository into which the dump data will be loaded (if it
        ever, in fact, occurs).  To ensure that the output of each
        execution of <span><strong class="command">svnadmin dump</strong></span> is
        self-sufficient, the first dumped revision is by default a
        full representation of every directory, file, and property in
        that revision of the repository.</p><p>However, you can change this default behavior.  If you add
        the <code class="option">--incremental</code> option when you dump your
        repository, <span><strong class="command">svnadmin</strong></span> will compare the first
        dumped revision against the previous revision in the
        repository, the same way it treats every other revision that
        gets dumped.  It will then output the first revision exactly
        as it does the rest of the revisions in the dump
        range—mentioning only the changes that occurred in that
        revision.  The benefit of this is that you can create several
        small dump files that can be loaded in succession, instead of
        one large one, like so:</p><pre class="screen">
$ svnadmin dump myrepos --revision 0:1000 &gt; dumpfile1
$ svnadmin dump myrepos --revision 1001:2000 --incremental &gt; dumpfile2
$ svnadmin dump myrepos --revision 2001:3000 --incremental &gt; dumpfile3
</pre><p>These dump files could be loaded into a new repository with
        the following command sequence:</p><pre class="screen">
$ svnadmin load newrepos &lt; dumpfile1
$ svnadmin load newrepos &lt; dumpfile2
$ svnadmin load newrepos &lt; dumpfile3
</pre><p>Another neat trick you can perform with this
        <code class="option">--incremental</code> option involves appending to an
        existing dump file a new range of dumped revisions.  For
        example, you might have a <code class="literal">post-commit</code> hook
        that simply appends the repository dump of the single revision
        that triggered the hook.  Or you might have a script that runs
        nightly to append dump file data for all the revisions that
        were added to the repository since the last time the script
        ran.  Used like this, <span><strong class="command">svnadmin</strong></span>'s
        <code class="literal">dump</code> and <code class="literal">load</code> commands
        can be a valuable means by which to backup changes to your
        repository over time in case of a system crash or some other
        catastrophic event.</p><p>The dump format can also be used to merge the contents of
        several different repositories into a single repository.  By
        using the <code class="option">--parent-dir</code> option of <span><strong class="command">svnadmin
        load</strong></span>, you can specify a new virtual root directory
        for the load process.  That means if you have dump files for
        three repositories, say <code class="filename">calc-dumpfile</code>,
        <code class="filename">cal-dumpfile</code>, and
        <code class="filename">ss-dumpfile</code>, you can first create a new
        repository to hold them all:</p><pre class="screen">
$ svnadmin create /path/to/projects
$
</pre><p>Then, make new directories in the repository which will
        encapsulate the contents of each of the three previous
        repositories:</p><pre class="screen">
$ svn mkdir -m "Initial project roots" \
      file:///path/to/projects/calc \
      file:///path/to/projects/calendar \
      file:///path/to/projects/spreadsheet
Committed revision 1.
$ 
</pre><p>Lastly, load the individual dump files into their
        respective locations in the new repository:</p><pre class="screen">
$ svnadmin load /path/to/projects --parent-dir calc &lt; calc-dumpfile
…
$ svnadmin load /path/to/projects --parent-dir calendar &lt; cal-dumpfile
…
$ svnadmin load /path/to/projects --parent-dir spreadsheet &lt; ss-dumpfile
…
$
</pre><p>We'll mention one final way to use the Subversion
        repository dump format—conversion from a different
        storage mechanism or version control system altogether.
        Because the dump file format is, for the most part,
        human-readable,
        <sup>[<a id="id4745873" href="#ftn.id4745873">18</a>]</sup>
        it should be relatively easy to describe generic sets of
        changes—each of which should be treated as a new
        revision—using this file format.  In fact, the
        <span><strong class="command">cvs2svn</strong></span> utility (see <a href="#svn.forcvs.convert" title="Converting a Repository from CVS to Subversion">la sezione chiamata «Converting a Repository from CVS to Subversion»</a>) uses the dump format to represent the
        contents of a CVS repository so that those contents can be
        copied into a Subversion repository.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.reposadmin.maint.backup"></a>Repository Backup</h3></div></div></div><p>Despite numerous advances in technology since the birth of
        the modern computer, one thing unfortunately rings true with
        crystalline clarity—sometimes, things go very, very
        awry.  Power outages, network connectivity dropouts, corrupt
        RAM and crashed hard drives are but a taste of the evil that
        Fate is poised to unleash on even the most conscientious
        administrator.  And so we arrive at a very important
        topic—how to make backup copies of your repository
        data.</p><p>There are generally two types of backup methods available
        for Subversion repository administrators—incremental and
        full.  We discussed in an earlier section of this chapter how
        to use <span><strong class="command">svnadmin dump --incremental</strong></span> to
        perform an incremental backup (see <a href="#svn.reposadmin.maint.migrate" title="Migrating a Repository">la sezione chiamata «Migrating a Repository»</a>).  Essentially, the idea is to
        only backup at a given time the changes to the repository
        since the last time you made a backup.</p><p>A full backup of the repository is quite literally a
        duplication of the entire repository directory (which includes
        either Berkeley database or FSFS environment).  Now, unless
        you temporarily disable all other access to your repository,
        simply doing a recursive directory copy runs the risk of
        generating a faulty backup, since someone might be currently
        writing to the database.</p><p>In the case of Berkeley DB, Sleepycat documents describe a
        certain order in which database files can be copied that will
        guarantee a valid backup copy.  And a similar ordering exists
        for FSFS data.  Better still, you don't have to implement
        these algorithms yourself, because the Subversion development
        team has already done so.  The
        <span><strong class="command">hot-backup.py</strong></span> script is found in the
        <code class="filename">tools/backup/</code> directory of the Subversion
        source distribution.  Given a repository path and a backup
        location, <span><strong class="command">hot-backup.py</strong></span>—which is
        really just a more intelligent wrapper around the
        <span><strong class="command">svnadmin hotcopy</strong></span> command—will perform
        the necessary steps for backing up your live
        repository—without requiring that you bar public
        repository access at all—and then will clean out the
        dead Berkeley log files from your live repository.</p><p>Even if you also have an incremental backup, you might
        want to run this program on a regular basis.  For example, you
        might consider adding <span><strong class="command">hot-backup.py</strong></span> to a
        program scheduler (such as <span><strong class="command">cron</strong></span> on Unix
        systems).  Or, if you prefer fine-grained backup solutions,
        you could have your post-commit hook script call
        <span><strong class="command">hot-backup.py</strong></span> (see <a href="#svn.reposadmin.create.hooks" title="Hook Scripts">la sezione chiamata «Hook Scripts»</a>), which will then cause a new
        backup of your repository to occur with every new revision
        created.  Simply add the following to the
        <code class="filename">hooks/post-commit</code> script in your live
        repository directory:</p><pre class="programlisting">
(cd /path/to/hook/scripts; ./hot-backup.py ${REPOS} /path/to/backups &amp;)
</pre><p>The resulting backup is a fully functional Subversion
        repository, able to be dropped in as a replacement for your
        live repository should something go horribly wrong.</p><p>There are benefits to both types of backup methods.  The
        easiest is by far the full backup, which will always result in
        a perfect working replica of your repository.  This again
        means that should something bad happen to your live
        repository, you can restore from the backup with a simple
        recursive directory copy.  Unfortunately, if you are
        maintaining multiple backups of your repository, these full
        copies will each eat up just as much disk space as your live
        repository.</p><p>Incremental backups using the repository dump format are
        excellent to have on hand if the database schema changes
        between successive versions of Subversion itself.  Since a
        complete repository dump and load are generally required to
        upgrade your repository to the new schema, it's very
        convenient to already have half of that process (the dump
        part) finished.  Unfortunately, the creation of—and
        restoration from—incremental backups takes longer, as
        each commit is effectively replayed into either the dump file
        or the repository.</p><p>In either backup scenario, repository administrators need
        to be aware of how modifications to unversioned revision
        properties affect their backups.  Since these changes do not
        themselves generate new revisions, they will not trigger
        post-commit hooks, and may not even trigger the
        pre-revprop-change and post-revprop-change hooks.
        <sup>[<a id="id4746114" href="#ftn.id4746114">19</a>]</sup>  
        And since you can change revision properties without respect
        to chronological order—you can change any revision's
        properties at any time—an incremental backup of the
        latest few revisions might not catch a property modification
        to a revision that was included as part of a previous 
        backup.</p><p>Generally speaking, only the truly paranoid would need to
        backup their entire repository, say, every time a commit
        occurred.  However, assuming that a given repository has some
        other redundancy mechanism in place with relatively fine
        granularity (like per-commit emails), a hot backup of the
        database might be something that a repository administrator
        would want to include as part of a system-wide nightly backup.
        For most repositories, archived commit emails alone provide
        sufficient redundancy as restoration sources, at least for the
        most recent few commits.  But it's your data—protect it
        as much as you'd like.</p><p>Often, the best approach to repository backups is a
        diversified one.  You can leverage combinations of full and
        incremental backups, plus archives of commit emails.  The
        Subversion developers, for example, back up the Subversion
        source code repository after every new revision is created,
        and keep an archive of all the commit and property change
        notification emails.  Your solution might be similar, but
        should be catered to your needs and that delicate balance of
        convenience with paranoia.  And while all of this might not
        save your hardware from the iron fist of Fate,
        <sup>[<a id="id4746179" href="#ftn.id4746179">20</a>]</sup>
        it should certainly help you recover from those trying 
        times.</p></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.reposadmin.projects"></a>Adding Projects</h2></div></div></div><p>Once your repository is created and configured, all that
      remains is to begin using it.  If you have a collection of
      existing data that is ready to be placed under version control,
      you will more than likely want to use the <span><strong class="command">svn</strong></span>
      client program's <code class="literal">import</code> subcommand to
      accomplish that.  Before doing this, though, you should
      carefully consider your long-term plans for the repository.  In
      this section, we will offer some advice on how to plan the
      layout of your repository, and how to get your data arranged in
      that layout.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.reposadmin.projects.chooselayout"></a>Choosing a Repository Layout</h3></div></div></div><p>While Subversion allows you to move around versioned files
        and directories without any loss of information, doing so can
        still disrupt the workflow of those who access the repository
        often and come to expect things to be at certain locations.
        Try to peer into the future a bit; plan ahead before placing
        your data under version control.  By «<span class="quote">laying out</span>»
        the contents of your repositories in an effective manner the
        first time, you can prevent a load of future headaches.</p><p>There are a few things to consider when setting up
        Subversion repositories.  Let's assume that as repository
        administrator, you will be responsible for supporting the
        version control system for several projects.  The first
        decision is whether to use a single repository for multiple
        projects, or to give each project its own repository, or some
        compromise of these two.</p><p>There are benefits to using a single repository for
        multiple projects, most obviously the lack of duplicated
        maintenance.  A single repository means that there is one set
        of hook scripts, one thing to routinely backup, one thing to
        dump and load if Subversion releases an incompatible new
        version, and so on.  Also, you can move data between projects
        easily, and without losing any historical versioning
        information.</p><p>The downside of using a single repository is that
        different projects may have different commit mailing lists or
        different authentication and authorization requirements.
        Also, remember that Subversion uses repository-global revision
        numbers.  Some folks don't like the fact that even though no
        changes have been made to their project lately, the youngest
        revision number for the repository keeps climbing because
        other projects are actively adding new revisions.</p><p>A middle-ground approach can be taken, too.  For example,
        projects can be grouped by how well they relate to each other.
        You might have a few repositories with a handful of projects
        in each repository.  That way, projects that are likely to
        want to share data can do so easily, and as new revisions are
        added to the repository, at least the developers know that
        those new revisions are at least remotely related to everyone
        who uses that repository.</p><p>After deciding how to organize your projects with respect
        to repositories, you'll probably want to think about directory
        hierarchies in the repositories themselves.  Because
        Subversion uses regular directory copies for branching and
        tagging (see <a href="#svn.branchmerge" title="Capitolo&#xA0;4.&#xA0;Branching and Merging">Capitolo 4, <i>Branching and Merging</i></a>), the Subversion
        community recommends that you choose a repository location for
        each <em class="firstterm">project root</em>—the
        «<span class="quote">top-most</span>» directory which contains data related
        to that project—and then create three subdirectories
        beneath that root: <code class="filename">trunk</code>, meaning the
        directory under which the main project development occurs;
        <code class="filename">branches</code>, which is a directory in which
        to create various named branches of the main development line;
        <code class="filename">tags</code>, which is a directory of branches
        that are created, and perhaps destroyed, but never
        changed.
        <sup>[<a id="id4746368" href="#ftn.id4746368">21</a>]</sup>
        </p><p>For example, your repository might look like:</p><pre class="screen">
/
   calc/
      trunk/
      tags/
      branches/
   calendar/
      trunk/
      tags/
      branches/
   spreadsheet/
      trunk/
      tags/
      branches/
   …
</pre><p>Note that it doesn't matter where in your repository each
        project root is.  If you have only one project per repository,
        the logical place to put each project root is at the root of
        that project's respective repository.  If you have multiple
        projects, you might want to arrange them in groups inside the
        repository, perhaps putting projects with similar goals or
        shared code in the same subdirectory, or maybe just grouping
        them alphabetically.  Such an arrangement might look
        like:</p><pre class="screen">
/
   utils/
      calc/
         trunk/
         tags/
         branches/
      calendar/
         trunk/
         tags/
         branches/
      …
   office/
      spreadsheet/
         trunk/
         tags/
         branches/
      …
</pre><p>Lay out your repository in whatever way you see fit.
        Subversion does not expect or enforce a layout schema—in
        its eyes, a directory is a directory is a directory.
        Ultimately, you should choose the repository arrangement that
        meets the needs of the people who work on the projects that
        live there.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.reposadmin.projects.import"></a>Creating the Layout, and Importing Initial Data</h3></div></div></div><p>After deciding how to arrange the projects in your
        repository, you'll probably want to actually populate the
        repository with that layout and with initial project data.
        There are a couple of ways to do this in Subversion.  You
        could use the <span><strong class="command">svn mkdir</strong></span> command (see <a href="#svn.ref" title="Capitolo&#xA0;9.&#xA0;Subversion Complete Reference">Capitolo 9, <i>Subversion Complete Reference</i></a>) to create each directory in your
        skeletal repository layout, one-by-one.  A quicker way to
        accomplish the same task is to use the <span><strong class="command">svn
        import</strong></span> command (see <a href="#svn.tour.other.import" title="svn import">la sezione chiamata «<span><strong class="command">svn import</strong></span>»</a>).  By first creating the layout
        in a temporary location on your drive, you can import the
        whole layout tree into the repository in a single
        commit:</p><pre class="screen">
$ mkdir tmpdir
$ cd tmpdir
$ mkdir projectA
$ mkdir projectA/trunk
$ mkdir projectA/branches
$ mkdir projectA/tags
$ mkdir projectB
$ mkdir projectB/trunk
$ mkdir projectB/branches
$ mkdir projectB/tags
…
$ svn import . file:///path/to/repos --message 'Initial repository layout'
Adding         projectA
Adding         projectA/trunk
Adding         projectA/branches
Adding         projectA/tags
Adding         projectB
Adding         projectB/trunk
Adding         projectB/branches
Adding         projectB/tags
…
Committed revision 1.
$ cd ..
$ rm -rf tmpdir
$
</pre><p>You can verify the results of the import by running the
        <span><strong class="command">svn list</strong></span> command:</p><pre class="screen">
$ svn list --verbose file:///path/to/repos
      1 harry               May 08 21:48 projectA/
      1 harry               May 08 21:48 projectB/
…
$
</pre><p>Once you have your skeletal layout in place, you can begin
        importing actual project data into your repository, if any
        such data exists yet.  Once again, there are several ways to
        do this.  You could use the <span><strong class="command">svn import</strong></span>
        command.  You could checkout a working copy from your new
        repository, move and arrange project data inside the working
        copy, and use the <span><strong class="command">svn add</strong></span> and <span><strong class="command">svn
        commit</strong></span> commands.  But once we start talking about
        such things, we're no longer discussing repository
        administration.  If you aren't already familiar with the
        <span><strong class="command">svn</strong></span> client program, see <a href="#svn.tour" title="Capitolo&#xA0;3.&#xA0;Visita guidata">Capitolo 3, <i>Visita guidata</i></a>.</p></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.reposadmin.summary"></a>Summary</h2></div></div></div><p>By now you should have a basic understanding of how to
      create, configure, and maintain Subversion repositories.  We've
      introduced you to the various tools that will assist you with
      this task.  Throughout the chapter, we've noted common
      administration pitfalls, and suggestions for avoiding
      them.</p><p>All that remains is for you to decide what exciting data to
      store in your repository, and finally, how to make it available
      over a network.  The next chapter is all about networking.</p></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.id4740811" href="#id4740811">13</a>] </sup>This may sound really prestigious and lofty, but we're
          just talking about anyone who is interested in that
          mysterious realm beyond the working copy where everyone's
          data hangs out.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4741075" href="#id4741075">14</a>] </sup>Pronounced «<span class="quote">fuzz-fuzz</span>», if Jack
            Repenning has anything to say about it.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4743767" href="#id4743767">15</a>] </sup>That, by the way, is a <span class="emphasis"><em>feature</em></span>,
              not a bug.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4744262" href="#id4744262">16</a>] </sup>While <span><strong class="command">svnadmin dump</strong></span> has a
              consistent leading slash policy—to not include
              them—other programs which generate dump data might
              not be so consistent.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4745144" href="#id4745144">17</a>] </sup>E.g.: hard drive + huge electromagnet = disaster.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4745873" href="#id4745873">18</a>] </sup>The Subversion repository dump format resembles
            an RFC-822 format, the same type of format used for most
            email.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4746114" href="#id4746114">19</a>] </sup><span><strong class="command">svnadmin setlog</strong></span> can be called in a
            way that bypasses the hook interface altogether.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4746179" href="#id4746179">20</a>] </sup>You know—the collective term for all of her
            «<span class="quote">fickle fingers</span>».</p></div><div class="footnote"><p><sup>[<a id="ftn.id4746368" href="#id4746368">21</a>] </sup>The <code class="filename">trunk</code>, <code class="filename">tags</code>, 
            and <code class="filename">branches</code> trio are sometimes referred
            to as «<span class="quote">the TTB directories</span>».</p></div></div></div><div class="chapter" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title"><a id="svn.serverconfig"></a>Capitolo 6. Server Configuration</h2></div></div></div><div class="toc"><p><b>Sommario</b></p><dl><dt><span class="sect1"><a href="#svn.serverconfig.overview">Overview</a></span></dt><dt><span class="sect1"><a href="#svn.serverconfig.netmodel">Network Model</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.serverconfig.netmodel.reqresp">Requests and Responses</a></span></dt><dt><span class="sect2"><a href="#svn.serverconfig.netmodel.credcache">Client Credentials Caching</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.serverconfig.svnserve">svnserve, a custom server</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.serverconfig.svnserve.invoking">Invoking the Server</a></span></dt><dt><span class="sect2"><a href="#svn.serverconfig.svnserve.auth">Built-in authentication and authorization</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.serverconfig.svnserve.auth.users">Create a 'users' file and realm</a></span></dt><dt><span class="sect3"><a href="#svn.serverconfig.svnserve.auth.general">Set access controls</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.serverconfig.svnserve.sshauth">SSH authentication and authorization</a></span></dt><dt><span class="sect2"><a href="#svn.serverconfig.svnserve.sshtricks">SSH configuration tricks</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.serverconfig.svnserve.sshtricks.setup">Initial setup</a></span></dt><dt><span class="sect3"><a href="#svn.serverconfig.svnserve.sshtricks.fixedcmd">Controlling the invoked command</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.serverconfig.httpd">httpd, the Apache HTTP server</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.serverconfig.httpd.prereqs">Prerequisites</a></span></dt><dt><span class="sect2"><a href="#svn.serverconfig.httpd.basic">Basic Apache Configuration</a></span></dt><dt><span class="sect2"><a href="#svn.serverconfig.httpd.authn">Authentication Options</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.serverconfig.httpd.authn.basic">Basic HTTP Authentication</a></span></dt><dt><span class="sect3"><a href="#svn.serverconfig.httpd.authn.sslcerts">SSL Certificate Management</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.serverconfig.httpd.authz">Authorization Options</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.serverconfig.httpd.authz.blanket">Blanket Access Control</a></span></dt><dt><span class="sect3"><a href="#svn.serverconfig.httpd.authz.perdir">Per-Directory Access Control</a></span></dt><dt><span class="sect3"><a href="#svn.serverconfig.httpd.authz.pathauthzoff">Disabling Path-based Checks</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.serverconfig.httpd.extra">Extra Goodies</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.serverconfig.httpd.extra.browsing">Repository Browsing</a></span></dt><dt><span class="sect3"><a href="#svn.serverconfig.httpd.extra.other">Other Features</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.serverconfig.multimethod">Supporting Multiple Repository Access Methods</a></span></dt></dl></div><div class="simplesect" lang="it" xml:lang="it"><div class="titlepage"></div><p>A Subversion repository can be accessed simultaneously by
      clients running on the same machine on which the repository
      resides using the <code class="literal">file:///</code> method.  But the
      typical Subversion setup involves a single server machine being
      accessed from clients on computers all over the office—or,
      perhaps, all over the world.</p><p>This section describes how to get your Subversion repository
      exposed outside its host machine for use by remote clients.  We
      will cover Subversion's currently available server mechanisms,
      discussing the configuration and use of each.  After reading
      this section, you should be able to decide which networking
      setup is right for your needs, and understand how to enable such
      a setup on your host computer.</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.serverconfig.overview"></a>Overview</h2></div></div></div><p>Subversion was designed with an abstract network layer.
      This means that a repository can be programmatically accessed by
      any sort of server process, and the client «<span class="quote">repository
      access</span>» API allows programmers to write plugins that
      speak relevant network protocols.  In theory, Subversion can use
      an infinite number of network implementations.  In practice,
      there are only two servers at the time of writing.</p><p>Apache is an extremely popular webserver; using the
      <span><strong class="command">mod_dav_svn</strong></span> module, Apache can access a
      repository and make it available to clients via the WebDAV/DeltaV
      protocol, which is an extension of HTTP.  In the other corner is
      <span><strong class="command">svnserve</strong></span>: a small, standalone server
      program that speaks a custom protocol with clients.  Table 6-1
      presents a comparison of the two servers.</p><p>Note that Subversion, as an open-source project, does not
      officially endorse any server as «<span class="quote">primary</span>» or
      «<span class="quote">official</span>».  Neither network implementation is
      treated as a second-class citizen; each server has advantages
      and disadvantages.  In fact, it's possible for different servers
      to run in parallel, each accessing your repositories in its own
      way, and each without hindering the other (see <a href="#svn.serverconfig.multimethod" title="Supporting Multiple Repository Access Methods">la sezione chiamata «Supporting Multiple Repository Access Methods»</a>).  <a href="#svn.serverconfig.overview.tbl-1" title="Tabella&#xA0;6.1.&#xA0;Network Server Comparison">Tabella 6.1, «Network Server Comparison»</a> gives a brief overview and
      comparison of the two available Subversion servers—as an
      administrator, it's up to you to choose whatever works best for
      you and your users.</p><div class="table"><a id="svn.serverconfig.overview.tbl-1"></a><p class="title"><b>Tabella 6.1. Network Server Comparison</b></p><div class="table-contents"><table summary="Network Server Comparison" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Feature</th><th>Apache + mod_dav_svn</th><th>svnserve</th></tr></thead><tbody><tr><td>Authentication options</td><td>HTTP(S) basic auth, X.509 certificates, LDAP, NTLM, or
              any other mechanism available to Apache httpd</td><td>CRAM-MD5 or SSH</td></tr><tr><td>User account options</td><td>private 'users' file</td><td>private 'users' file, or existing system (SSH)
              accounts</td></tr><tr><td>Authorization options</td><td>blanket read/write access, or per-directory
              read/write control</td><td>blanket read/write access, or per-directory write
              (but not read) control using a pre-commit hook</td></tr><tr><td>Encryption</td><td>via optional SSL</td><td>via optional SSH tunnel</td></tr><tr><td>Interoperability</td><td>partially usable by other WebDAV clients</td><td>not interoperable</td></tr><tr><td>Web viewing</td><td>limited built-in support, or via 3rd-party tools
              such as ViewVC</td><td>via 3rd-party tools such as ViewVC</td></tr><tr><td>Speed</td><td>somewhat slower</td><td>somewhat faster</td></tr><tr><td>Initial setup</td><td>somewhat complex</td><td>fairly simple</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.serverconfig.netmodel"></a>Network Model</h2></div></div></div><p>This section is a general discussion of how a Subversion
      client and server interact with one another, regardless of the
      network implementation you're using.  After reading, you'll have
      a good understanding of how a server can behave and the
      different ways in which a client can be configured to
      respond.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.serverconfig.netmodel.reqresp"></a>Requests and Responses</h3></div></div></div><p>The Subversion client spends most of its time managing
        working copies.  When it needs information from a repository,
        however, it makes a network request, and the server responds
        with an appropriate answer.  The details of the network
        protocol are hidden from the user; the client attempts to
        access a URL, and depending on the URL schema, a particular
        protocol is used to contact the server (see <a href="#svn.basic.in-action.wc.sb-1" title="Repository URLs">Repository URLs</a>).  Users can run <span><strong class="command">svn
        --version</strong></span> to see which URL schemas and protocols the
        client knows how to use.</p><p>When the server process receives a client request, it
        typically demands that the client identify itself.  It issues
        an authentication challenge to the client, and the client
        responds by providing <em class="firstterm">credentials</em> back
        to the server.  Once authentication is complete, the server
        responds with the original information the client asked for.
        Notice that this system is different from systems like CVS,
        where the client pre-emptively offers credentials («<span class="quote">logs
        in</span>») to the server before ever making a request.  In
        Subversion, the server «<span class="quote">pulls</span>» credentials by
        challenging the client at the appropriate moment, rather than
        the client «<span class="quote">pushing</span>» them.  This makes certain
        operations more elegant.  For example, if a server is
        configured to allow anyone in the world to read a repository,
        then the server will never issue an authentication challenge
        when a client attempts to <span><strong class="command">svn
        checkout</strong></span>.</p><p>If the client's network request writes new data to the
        repository (e.g. <span><strong class="command">svn commit</strong></span>), then a new
        revision tree is created.  If the client's request was
        authenticated, then the authenticated user's name is stored as
        the value of the <code class="literal">svn:author</code> property on the
        new revision (see <a href="#svn.reposadmin.basics.revprops" title="Unversioned Properties">la sezione chiamata «Unversioned Properties»</a>).  If
        the client was not authenticated (in other words, the server
        never issued an authentication challenge), then the revision's
        <code class="literal">svn:author</code> property is empty.
        <sup>[<a id="id4747041" href="#ftn.id4747041">22</a>]</sup></p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.serverconfig.netmodel.credcache"></a>Client Credentials Caching</h3></div></div></div><p>Many servers are configured to require authentication on
        every request.  This can become a big annoyance to users, who
        are forced to type their passwords over and over again.</p><p>Happily, the Subversion client has a remedy for this: a
        built-in system for caching authentication credentials on
        disk.  By default, whenever the command-line client
        successfully responds to a server's authentication challenge,
        it saves the credentials in the user's private runtime
        configuration
        area—in <code class="filename">~/.subversion/auth/</code> on
        Unix-like systems or
        <code class="filename">%APPDATA%/Subversion/auth/</code> on Windows.
        (The runtime area is covered in more detail in <a href="#svn.advanced.confarea" title="Runtime Configuration Area">la sezione chiamata «Runtime Configuration Area»</a>.)  Successful credentials are
        cached on disk, keyed on a combination of hostname, port, and
        authentication realm.</p><p>When the client receives an authentication challenge, it
        first looks for the appropriate credentials in the user's disk
        cache; if not present, or if the cached credentials fail to
        authenticate, then the client simply prompts the user for the
        information.</p><p>Security-conscious people may be thinking to themselves,
        «<span class="quote">Caching passwords on disk?  That's terrible!  You
        should never do that!</span>» Please remain calm, it's not as
        dangerous as it sounds.</p><div class="itemizedlist"><ul type="disc"><li><p>The <code class="filename">auth/</code> caching area is
            permission-protected so that only the user (owner) can
            read data from it, not the world at large.  The operating
            system's own file permissions are protecting the
            password.</p></li><li><p>On Windows 2000 and later, the Subversion client uses
            standard Windows cryptography services to encrypt the
            password on disk.  Because the encryption key is managed
            by Windows and is tied to the user's own login
            credentials, only the user can decrypt the cached
            password.  (Note: if the user's Windows account password
            is reset by an administrator, all of the cached passwords
            become undecipherable.  The Subversion client will behave
            as if they don't exist, prompting for passwords when
            required.)</p></li><li><p>For the truly paranoid willing to sacrifice all
            convenience, it's possible to disable credential caching
            altogether.</p></li></ul></div><p>To disable caching for a single command, pass the
        <code class="option">--no-auth-cache</code> option:</p><pre class="screen">
$ svn commit -F log_msg.txt --no-auth-cache
Authentication realm: &lt;svn://host.example.com:3690&gt; example realm
Username:  joe
Password for 'joe':

Adding         newfile
Transmitting file data .
Committed revision 2324.

# password was not cached, so a second commit still prompts us

$ svn delete newfile
$ svn commit -F new_msg.txt
Authentication realm: &lt;svn://host.example.com:3690&gt; example realm
Username:  joe
…
</pre><p>Or, if you want to disable credential caching permanently,
        you can edit your runtime <code class="filename">config</code> file
        (located next to the <code class="filename">auth/</code> directory).
        Simply set <code class="literal">store-auth-creds</code> to
        <code class="literal">no</code>, and no credentials will be cached on
        disk, ever.</p><pre class="screen">
[auth]
store-auth-creds = no
</pre><p>Sometimes users will want to remove specific credentials
        from the disk cache.  To do this, you need to navigate into
        the <code class="filename">auth/</code> area and manually delete the
        appropriate cache file.  Credentials are cached in individual
        files;  if you look inside each file, you will see keys and
        values.  The <code class="literal">svn:realmstring</code> key describes
        the particular server realm that the file is associated
        with:</p><pre class="screen">
$ ls ~/.subversion/auth/svn.simple/
5671adf2865e267db74f09ba6f872c28        
3893ed123b39500bca8a0b382839198e
5c3c22968347b390f349ff340196ed39

$ cat ~/.subversion/auth/svn.simple/5671adf2865e267db74f09ba6f872c28

K 8
username
V 3
joe
K 8
password
V 4
blah
K 15
svn:realmstring
V 45
&lt;https://svn.domain.com:443&gt; Joe's repository
END
</pre><p>Once you have located the proper cache file, just delete
        it.</p><p>One last word about client authentication behavior: a bit
        of explanation about the <code class="option">--username</code> and
        <code class="option">--password</code> options is needed.  Many client
        subcommands accept these options; however it is important to
        understand using these options <span class="emphasis"><em>does not</em></span>
        automatically send credentials to the server.  As discussed
        earlier, the server «<span class="quote">pulls</span>» credentials from the
        client when it deems necessary; the client cannot
        «<span class="quote">push</span>» them at will.  If a username and/or
        password are passed as options, they will
        <span class="emphasis"><em>only</em></span> be presented to the server if the
        server requests them.

         <sup>[<a id="id4747299" href="#ftn.id4747299">23</a>]</sup>
        
        Typically, these options are used when:</p><div class="itemizedlist"><ul type="disc"><li><p>the user wants to authenticate as a different user
            than her system login name, or</p></li><li><p>a script wants to authenticate without using cached
            credentials.</p></li></ul></div><p>Here is a final summary that describes how a Subversion
        client behaves when it receives an authentication
        challenge:</p><div class="orderedlist"><ol type="1"><li><p>Check whether the user specified any credentials as
            command-line options, via <code class="option">--username</code>
            and/or <code class="option">--password</code>.  If not, or if these
            options fail to authenticate successfully, then</p></li><li><p>Look up the server's realm in the runtime
            <code class="filename">auth/</code> area, to see if the user already
            has the appropriate credentials cached.  If not, or if the
            cached credentials fail to authenticate, then</p></li><li><p>Resort to prompting the user.</p></li></ol></div><p>If the client successfully authenticates by any of the
        methods listed above, it will attempt to cache the credentials
        on disk (unless the user has disabled this behavior, as
        mentioned earlier).</p></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.serverconfig.svnserve"></a>svnserve, a custom server</h2></div></div></div><p>The <span><strong class="command">svnserve</strong></span> program is a lightweight
      server, capable of speaking to clients over TCP/IP using a
      custom, stateful protocol.  Clients contact an
      <span><strong class="command">svnserve</strong></span> server by using URLs that begin with
      the <code class="literal">svn://</code> or <code class="literal">svn+ssh://</code>
      schema.  This section will explain the different ways of running
      <span><strong class="command">svnserve</strong></span>, how clients authenticate themselves
      to the server, and how to configure appropriate access control
      to your repositories.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.serverconfig.svnserve.invoking"></a>Invoking the Server</h3></div></div></div><p>There are a few different ways to invoke the
        <span><strong class="command">svnserve</strong></span> program.  If invoked with no
        options, you'll see nothing but a help message.  However, if
        you're planning to have <span><strong class="command">inetd</strong></span> launch the
        process, then you can pass the <code class="option">-i</code>
        (<code class="option">--inetd</code>) option:</p><pre class="screen">
$ svnserve -i
( success ( 1 2 ( ANONYMOUS ) ( edit-pipeline ) ) )
</pre><p>When invoked with the <code class="option">--inetd</code> option,
        <span><strong class="command">svnserve</strong></span> attempts to speak with a
        Subversion client via <span class="emphasis"><em>stdin</em></span> and
        <span class="emphasis"><em>stdout</em></span> using a custom protocol.  This is
        the standard behavior for a program being run via
        <span><strong class="command">inetd</strong></span>.  The IANA has reserved port 3690
        for the Subversion protocol, so on a Unix-like system you can
        add lines to <code class="filename">/etc/services</code> like these (if
        they don't already exist):</p><pre class="screen">
svn           3690/tcp   # Subversion
svn           3690/udp   # Subversion
</pre><p>And if your system is using a classic Unix-like
        <span><strong class="command">inetd</strong></span> daemon, you can add this line to
        <code class="filename">/etc/inetd.conf</code>:</p><pre class="screen">
svn stream tcp nowait svnowner /usr/bin/svnserve svnserve -i
</pre><p>Make sure «<span class="quote">svnowner</span>» is a user which has
        appropriate permissions to access your repositories.  Now, when
        a client connection comes into your server on port 3690,
        <span><strong class="command">inetd</strong></span> will spawn an
        <span><strong class="command">svnserve</strong></span> process to service it.</p><p>On a Windows system, third-party tools exist to run
      <span><strong class="command">svnserve</strong></span> as a service.  Look on Subversion's
      website for a list of these tools.</p><p>A second option is to run <span><strong class="command">svnserve</strong></span> as a
        standalone «<span class="quote">daemon</span>» process.  Use the
        <code class="option">-d</code> option for this:</p><pre class="screen">
$ svnserve -d
$               # svnserve is now running, listening on port 3690
</pre><p>When running <span><strong class="command">svnserve</strong></span> in daemon mode,
        you can use the <code class="option">--listen-port=</code> and
        <code class="option">--listen-host=</code> options to customize the exact
        port and hostname to «<span class="quote">bind</span>» to.</p><p>There's still a third way to invoke
        <span><strong class="command">svnserve</strong></span>, and that's in «<span class="quote">tunnel
        mode</span>», with the <code class="option">-t</code> option.  This mode
        assumes that a remote-service program such as
        <span><strong class="command">RSH</strong></span> or <span><strong class="command">SSH</strong></span> has
        successfully authenticated a user and is now invoking a
        private <span><strong class="command">svnserve</strong></span> process <span class="emphasis"><em>as that
        user</em></span>.  The <span><strong class="command">svnserve</strong></span> program
        behaves normally (communicating via <span class="emphasis"><em>stdin</em></span>
        and <span class="emphasis"><em>stdout</em></span>), and assumes that the traffic
        is being automatically redirected over some sort of tunnel
        back to the client.  When <span><strong class="command">svnserve</strong></span> is
        invoked by a tunnel agent like this, be sure that the
        authenticated user has full read and write access to the
        repository database files. (See <a href="#svn.serverconfig.svnserve.invoking.sb-1" title="Servers and Permissions:  A Word of Warning">Servers and Permissions:  A Word of Warning</a>.)  It's essentially the same as
        a local user accessing the repository via
        <code class="literal">file:///</code> URLs.</p><div class="sidebar"><a id="svn.serverconfig.svnserve.invoking.sb-1"></a><p class="title"><b>Servers and Permissions:  A Word of Warning</b></p><p>First, remember that a Subversion repository is a
          collection of database files; any process which accesses the
          repository directly needs to have proper read and write
          permissions on the entire repository.  If you're not
          careful, this can lead to a number of headaches, especially
          if you're using a Berkeley DB database rather than FSFS.  Be
          sure to read <a href="#svn.serverconfig.multimethod" title="Supporting Multiple Repository Access Methods">la sezione chiamata «Supporting Multiple Repository Access Methods»</a>.</p><p>Secondly, when configuring <span><strong class="command">svnserve</strong></span>,
          Apache <span><strong class="command">httpd</strong></span>, or any other server
          process, keep in mind that you might not want to launch the
          server process as the user <code class="literal">root</code> (or as
          any other user with unlimited permissions).  Depending on
          the ownership and permissions of the repositories you're
          exporting, it's often prudent to use a
          different—perhaps custom—user.  For example,
          many administrators create a new user named
          <code class="literal">svn</code>, grant that user exclusive ownership
          and rights to the exported Subversion repositories, and only
          run their server processes as that user.</p></div><p>Once the <span><strong class="command">svnserve</strong></span> program is running,
        it makes every repository on your system available to the
        network.  A client needs to specify an
        <span class="emphasis"><em>absolute</em></span> path in the repository URL.  For
        example, if a repository is located at
        <code class="filename">/usr/local/repositories/project1</code>, then a
        client would reach it via <code class="systemitem">svn://host.example.com/usr/local/repositories/project1
        </code>.  To increase security, you can pass the
        <code class="option">-r</code> option to <span><strong class="command">svnserve</strong></span>,
        which restricts it to exporting only repositories below that
        path:</p><pre class="screen">
$ svnserve -d -r /usr/local/repositories
…
</pre><p>Using the <code class="option">-r</code> option effectively
        modifies the location that the program treats as the root of
        the remote filesystem space.  Clients then use URLs that
        have that path portion removed from them, leaving much
        shorter (and much less revealing) URLs:</p><pre class="screen">
$ svn checkout svn://host.example.com/project1
…
</pre></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.serverconfig.svnserve.auth"></a>Built-in authentication and authorization</h3></div></div></div><p>When a client connects to an <span><strong class="command">svnserve</strong></span>
        process, the following things happen:</p><div class="itemizedlist"><ul type="disc"><li><p>The client selects a specific
        repository.</p></li><li><p>The server processes the repository's
        <code class="filename">conf/svnserve.conf</code> file, and begins to
        enforce any authentication and authorization policies defined
        therein.</p></li><li><p>Depending on the situation and authorization
        policies,</p><div class="itemizedlist"><ul type="circle"><li><p>the client may be allowed to make requests
              anonymously, without ever receiving an authentication
              challenge, OR</p></li><li><p>the client may be challenged for
              authentication at any time, OR</p></li><li><p>if operating in «<span class="quote">tunnel
              mode</span>», the client will declare itself to be
              already externally authenticated.</p></li></ul></div></li></ul></div><p>At the time of writing, the server only knows how to send
        a CRAM-MD5 <sup>[<a id="id4747940" href="#ftn.id4747940">24</a>]</sup>
        authentication challenge.  In essence, the server sends a bit
        of data to the client.  The client uses the MD5 hash algorithm
        to create a fingerprint of the data and password combined,
        then sends the fingerprint as a response.  The server performs
        the same computation with the stored password to verify that
        the result is identical.  <span class="emphasis"><em>At no point does the
        actual password travel over the network.</em></span></p><p>It's also possible, of course, for the client to be
        externally authenticated via a tunnel agent, such as
        <span><strong class="command">SSH</strong></span>.  In that case, the server simply
        examines the user it's running as, and uses it as the
        authenticated username.  For more on this, see <a href="#svn.serverconfig.svnserve.sshauth" title="SSH authentication and authorization">la sezione chiamata «SSH authentication and authorization»</a>.</p><p>As you've already guessed, a repository's
        <code class="filename">svnserve.conf</code> file is the central
        mechanism for controlling authentication and authorization
        policies.  The file has the same format as other configuration
        files (see <a href="#svn.advanced.confarea" title="Runtime Configuration Area">la sezione chiamata «Runtime Configuration Area»</a>): section names
        are marked by square brackets (<code class="literal">[</code> and
        <code class="literal">]</code>), comments begin with hashes
        (<code class="literal">#</code>), and each section contains
        specific variables that can be set (<code class="literal">variable =
        value</code>).  Let's walk through this file and learn how
        to use them.</p><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.serverconfig.svnserve.auth.users"></a>Create a 'users' file and realm</h4></div></div></div><p>For now, the <code class="literal">[general]</code> section of the
          <code class="filename">svnserve.conf</code> has all the variables you
          need.  Begin by defining a file which contains usernames and
          passwords, and an authentication realm:</p><pre class="screen">
[general]
password-db = userfile
realm = example realm
</pre><p>The <code class="literal">realm</code> is a name that you define.
          It tells clients which sort of «<span class="quote">authentication
          namespace</span>» they're connecting to; the Subversion
          client displays it in the authentication prompt, and uses it
          as a key (along with the server's hostname and port) for
          caching credentials on disk (see <a href="#svn.serverconfig.netmodel.credcache" title="Client Credentials Caching">la sezione chiamata «Client Credentials Caching»</a>).  The
          <code class="literal">password-db</code> variable points to a separate
          file that contains a list of usernames and passwords, using
          the same familiar format.  For example:</p><pre class="screen">
[users]
harry = foopassword
sally = barpassword
</pre><p>The value of <code class="literal">password-db</code> can be an
          absolute or relative path to the users file.  For many
          admins, it's easy to keep the file right in the
          <code class="filename">conf/</code> area of the repository, alongside
          <code class="filename">svnserve.conf</code>.  On the other hand, it's
          possible you may want to have two or more repositories share
          the same users file; in that case, the file should probably
          live in a more public place.  The repositories sharing the
          users file should also be configured to have the same realm,
          since the list of users essentially defines an
          authentication realm.  Wherever the file lives, be sure to
          set the file's read and write permissions appropriately.  If
          you know which user(s) <span><strong class="command">svnserve</strong></span> will run
          as, restrict read access to the user file as necessary.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.serverconfig.svnserve.auth.general"></a>Set access controls</h4></div></div></div><p>There are two more variables to set in the
          <code class="filename">svnserve.conf</code> file: they determine what
          unauthenticated (anonymous) and authenticated users are
          allowed to do.  The variables <code class="literal">anon-access</code>
          and <code class="literal">auth-access</code> can be set to the values
          <code class="literal">none</code>, <code class="literal">read</code>, or
          <code class="literal">write</code>.  Setting the value to
          <code class="literal">none</code> restricts all access of any kind;
          <code class="literal">read</code> allows read-only access to the
          repository, and <code class="literal">write</code> allows complete
          read/write access to the repository.  For example:</p><pre class="screen">
[general]
password-db = userfile
realm = example realm

# anonymous users can only read the repository
anon-access = read

# authenticated users can both read and write
auth-access = write
</pre><p>The example settings are, in fact, the default values of
          the variables, should you forget to define them.  If you
          want to be even more conservative, you can block anonymous
          access completely:</p><pre class="screen">
[general]
password-db = userfile
realm = example realm

# anonymous users aren't allowed
anon-access = none

# authenticated users can both read and write
auth-access = write
</pre><p>Notice that <span><strong class="command">svnserve</strong></span> only understands
          «<span class="quote">blanket</span>» access control.  A user either has
          universal read/write access, universal read access, or no
          access.  There is no detailed control over access to
          specific paths within the repository.  For many projects and
          sites, this level of access control is more than adequate.
          However, if you need per-directory access control, you'll
          need to use either use Apache with
          <span><strong class="command">mod_authz_svn</strong></span> (see <a href="#svn.serverconfig.httpd.authz.perdir" title="Per-Directory Access Control">la sezione chiamata «Per-Directory Access Control»</a>) or use a
          <span><strong class="command">pre-commit</strong></span> hook script to control write
          access (see <a href="#svn.reposadmin.create.hooks" title="Hook Scripts">la sezione chiamata «Hook Scripts»</a>).  The
          Subversion distribution comes with
          <span><strong class="command">commit-access-control.pl</strong></span> and the more
          sophisticated <span><strong class="command">svnperms.py</strong></span> scripts for use
          in pre-commit scripts.</p></div></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.serverconfig.svnserve.sshauth"></a>SSH authentication and authorization</h3></div></div></div><p><span><strong class="command">svnserve</strong></span>'s built-in authentication can
        be very handy, because it avoids the need to create real
        system accounts.  On the other hand, some administrators
        already have well-established SSH authentication frameworks in
        place.  In these situations, all of the project's users
        already have system accounts and the ability to «<span class="quote">SSH
        into</span>» the server machine.</p><p>It's easy to use SSH in conjunction with
        <span><strong class="command">svnserve</strong></span>.  The client simply uses the
        <code class="literal">svn+ssh://</code> URL schema to connect:</p><pre class="screen">
$ whoami
harry

$ svn list svn+ssh://host.example.com/repos/project
harry@host.example.com's password:  *****

foo
bar
baz
…
</pre><p>In this example, the Subversion client is invoking a local
        <span><strong class="command">ssh</strong></span> process, connecting to
        <code class="literal">host.example.com</code>, authenticating as the
        user <code class="literal">harry</code>, then spawning a private
        <span><strong class="command">svnserve</strong></span> process on the remote machine
        running as the user <code class="literal">harry</code>.  The
        <span><strong class="command">svnserve</strong></span> command is being invoked in tunnel
        mode (<code class="option">-t</code>) and its network protocol is being
        «<span class="quote">tunneled</span>» over the encrypted connection by
        <span><strong class="command">ssh</strong></span>, the tunnel-agent.
        <span><strong class="command">svnserve</strong></span> is aware that it's running as the
        user <code class="literal">harry</code>, and if the client performs a
        commit, the authenticated username will be attributed as the
        author of the new revision.</p><p>The important thing to understand here is that the
        Subversion client is <span class="emphasis"><em>not</em></span> connecting to a
        running <span><strong class="command">svnserve</strong></span> daemon.  This method of
        access doesn't require a daemon, nor does it notice one if
        present.  It relies wholly on the ability of
        <span><strong class="command">ssh</strong></span> to spawn a temporary
        <span><strong class="command">svnserve</strong></span> process, which then terminates
        when the network connection is closed.</p><p>When using <code class="literal">svn+ssh://</code> URLs to access a
        repository, remember that it's the <span><strong class="command">ssh</strong></span>
        program prompting for authentication, and
        <span class="emphasis"><em>not</em></span> the <span><strong class="command">svn</strong></span> client
        program.  That means there's no automatic password caching
        going on (see <a href="#svn.serverconfig.netmodel.credcache" title="Client Credentials Caching">la sezione chiamata «Client Credentials Caching»</a>).  The
        Subversion client often makes multiple connections to the
        repository, though users don't normally notice this due to the
        password caching feature.  When using
        <code class="literal">svn+ssh://</code> URLs, however, users may be
        annoyed by <span><strong class="command">ssh</strong></span> repeatedly asking for a
        password for every outbound connection.  The solution is to
        use a separate SSH password-caching tool like
        <span><strong class="command">ssh-agent</strong></span> on a Unix-like system, or
        <span><strong class="command">pageant</strong></span> on Windows.</p><p>When running over a tunnel, authorization is primarily
        controlled by operating system permissions to the repository's
        database files; it's very much the same as if Harry were
        accessing the repository directly via a
        <code class="literal">file:///</code> URL.  If multiple system users are
        going to be accessing the repository directly, you may want to
        place them into a common group, and you'll need to be careful
        about umasks.  (Be sure to read <a href="#svn.serverconfig.multimethod" title="Supporting Multiple Repository Access Methods">la sezione chiamata «Supporting Multiple Repository Access Methods»</a>.)  But even in the case of
        tunneling, the <code class="filename">svnserve.conf</code> file can
        still be used to block access, by simply setting
        <code class="literal">auth-access = read</code> or <code class="literal">auth-access
        = none</code>.</p><p>You'd think that the story of SSH tunneling would end
        here, but it doesn't.  Subversion allows you to create custom
        tunnel behaviors in your run-time <code class="filename">config</code>
        file (see <a href="#svn.advanced.confarea" title="Runtime Configuration Area">la sezione chiamata «Runtime Configuration Area»</a>).  For example,
        suppose you want to use RSH instead of SSH.  In the
        <code class="literal">[tunnels]</code> section of your
        <code class="filename">config</code> file, simply define it like
        this:</p><pre class="screen">
[tunnels]
rsh = rsh
</pre><p>And now, you can use this new tunnel definition by using a
        URL schema that matches the name of your new variable:
        <code class="literal">svn+rsh://host/path</code>.  When using the new
        URL schema, the Subversion client will actually be running the
        command <span><strong class="command">rsh host svnserve -t</strong></span> behind the
        scenes.  If you include a username in the URL (for example,
        <code class="literal">svn+rsh://username@host/path</code>) the client
        will also include that in its command (<span><strong class="command">rsh
        username@host svnserve -t</strong></span>).  But you can define new
        tunneling schemes to be much more clever than that:</p><pre class="screen">
[tunnels]
joessh = $JOESSH /opt/alternate/ssh -p 29934
</pre><p>This example demonstrates a couple of things.  First, it
        shows how to make the Subversion client launch a very specific
        tunneling binary (the one located at
        <code class="filename">/opt/alternate/ssh</code>) with specific
        options.  In this case, accessing a
        <code class="literal">svn+joessh://</code> URL would invoke the
        particular SSH binary with <code class="option">-p 29934</code> as
        arguments—useful if you want the tunnel program to
        connect to a non-standard port.</p><p>Second, it shows how to define a custom environment
        variable that can override the name of the tunneling program.
        Setting the <code class="literal">SVN_SSH</code> environment variable is
        a convenient way to override the default SSH tunnel agent.
        But if you need to have several different overrides for
        different servers, each perhaps contacting a different port or
        passing a different set of options to SSH, you can use the
        mechanism demonstrated in this example.  Now if we were to set
        the <code class="literal">JOESSH</code> environment variable, its value
        would override the entire value of the tunnel
        variable—<span><strong class="command">$JOESSH</strong></span> would be executed
        instead of <span><strong class="command">/opt/alternate/ssh -p
        29934</strong></span>.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.serverconfig.svnserve.sshtricks"></a>SSH configuration tricks</h3></div></div></div><p>It's not only possible to control the way in which the
        client invokes <span><strong class="command">ssh</strong></span>, but also to control
        the behavior of <span><strong class="command">sshd</strong></span> on your server
        machine.  In this section, we'll show how to control the
        exact <span><strong class="command">svnserve</strong></span> command executed
        by <span><strong class="command">sshd</strong></span>, as well as how to have multiple
        users share a single system account.</p><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.serverconfig.svnserve.sshtricks.setup"></a>Initial setup</h4></div></div></div><p>To begin, locate the home directory of the account
          you'll be using to launch <span><strong class="command">svnserve</strong></span>.  Make
          sure the account has an SSH public/private keypair
          installed, and that the user can log in via public-key
          authentication.  Password authentication will not work,
          since all of the following SSH tricks revolve around using
          the SSH <code class="filename">authorized_keys</code> file.</p><p>If it doesn't already exist, create the
          <code class="filename">authorized_keys</code> file (on Unix,
          typically <code class="filename">~/.ssh/authorized_keys</code>).
          Each line in this file describes a public key that is
          allowed to connect.  The lines are typically of the
          form:</p><pre class="screen">
  ssh-dsa AAAABtce9euch.... user@example.com
</pre><p>The first field describes the type of key, the second
          field is the uuencoded key itself, and the third field is a
          comment.  However, it's a lesser known fact that the entire
          line can be preceded by a <code class="literal">command</code>
          field:</p><pre class="screen">
  command="program" ssh-dsa AAAABtce9euch.... user@example.com
</pre><p>When the <code class="literal">command</code> field is set, the
          SSH daemon will run the named program instead of the
          typical <span><strong class="command">svnserve -t</strong></span> invocation that the
          Subversion client asks for.  This opens the door to a number
          of server-side tricks.  In the following examples, we
          abbreviate the lines of the file as:</p><pre class="screen">
  command="program" TYPE KEY COMMENT
</pre></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.serverconfig.svnserve.sshtricks.fixedcmd"></a>Controlling the invoked command</h4></div></div></div><p>Because we can specify the executed server-side command,
          it's easy to name a specific <span><strong class="command">svnserve</strong></span>
          binary to run and to pass it extra arguments:</p><pre class="screen">
  command="/path/to/svnserve -t -r /virtual/root" TYPE KEY COMMENT
</pre><p>In this example, <code class="filename">/path/to/svnserve</code>
          might be a custom wrapper script
          around <span><strong class="command">svnserve</strong></span> which sets the umask (see
          <a href="#svn.serverconfig.multimethod" title="Supporting Multiple Repository Access Methods">la sezione chiamata «Supporting Multiple Repository Access Methods»</a>).  It also shows how to
          anchor <span><strong class="command">svnserve</strong></span> in a virtual root
          directory, just as one often does when
          running <span><strong class="command">svnserve</strong></span> as a daemon process.
          This might be done either to restrict access to parts of the
          system, or simply to relieve the user of having to type an
          absolute path in the <code class="literal">svn+ssh://</code>
          URL.</p><p>It's also possible to have multiple users share a single
          account.  Instead of creating a separate system account for
          each user, generate a public/private keypair for each
          person.  Then place each public key into
          the <code class="filename">authorized_users</code> file, one per
          line, and use the <code class="option">--tunnel-user</code>
          option:</p><pre class="screen">
  command="svnserve -t --tunnel-user=harry" TYPE1 KEY1 harry@example.com
  command="svnserve -t --tunnel-user=sally" TYPE2 KEY2 sally@example.com
</pre><p>This example allows both Harry and Sally to connect to
          the same account via public-key authentication.  Each of
          them has a custom command that will be executed;
          the <code class="option">--tunnel-user</code> option 
          tells <span><strong class="command">svnserve -t</strong></span> to assume that the named
          argument is the authenticated user.  Without
          <code class="option">--tunnel-user</code>, it would appear as though
          all commits were coming from the one shared system
          account.</p><p>A final word of caution: giving a user access to the
          server via public-key in a shared account might still allow
          other forms of SSH access, even if you've set
          the <code class="literal">command</code> value
          in <code class="filename">authorized_keys</code>.  For example, the
          user may still get shell access through SSH, or be able to
          perform X11 or general port-forwarding through your server.
          To give the user as little permission as possible, you may
          want to specify a number of restrictive options immediately
          after the <code class="literal">command</code>:</p><pre class="screen">
  command="svnserve -t --tunnel-user=harry",no-port-forwarding,\
           no-agent-forwarding,no-X11-forwarding,no-pty \
           TYPE1 KEY1 harry@example.com
</pre></div></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.serverconfig.httpd"></a>httpd, the Apache HTTP server</h2></div></div></div><p>The Apache HTTP Server is a «<span class="quote">heavy duty</span>»
      network server that Subversion can leverage.  Via a custom
      module, <span><strong class="command">httpd</strong></span> makes Subversion repositories
      available to clients via the WebDAV/DeltaV protocol, which is an
      extension to HTTP 1.1 (see <a href="http://www.webdav.org/" target="_top">http://www.webdav.org/</a>
      for more information).  This protocol takes the ubiquitous HTTP
      protocol that is the core of the World Wide Web, and adds
      writing—specifically, versioned
      writing—capabilities.  The result is a standardized,
      robust system that is conveniently packaged as part of the
      Apache 2.0 software, is supported by numerous operating systems
      and third-party products, and doesn't require network
      administrators to open up yet another custom port.
      <sup>[<a id="id4749048" href="#ftn.id4749048">25</a>]</sup>
      While an Apache-Subversion server has more features than
      <span><strong class="command">svnserve</strong></span>, it's also a bit more difficult
      to set up.  With flexibility often comes more complexity.</p><p>Much of the following discussion includes references to
      Apache configuration directives.  While some examples are given
      of the use of these directives, describing them in full is
      outside the scope of this chapter.  The Apache team maintains
      excellent documentation, publicly available on their website at
      <a href="http://httpd.apache.org" target="_top">http://httpd.apache.org</a>.  For example, a general
      reference for the configuration directives is located at <a href="       http://httpd.apache.org/docs-2.0/mod/directives.html" target="_top">       http://httpd.apache.org/docs-2.0/mod/directives.html</a>.</p><p>Also, as you make changes to your Apache setup, it is likely
      that somewhere along the way a mistake will be made.  If you are
      not already familiar with Apache's logging subsystem, you should
      become aware of it.  In your <code class="filename">httpd.conf</code>
      file are directives that specify the on-disk locations of the
      access and error logs generated by Apache (the
      <code class="literal">CustomLog</code> and <code class="literal">ErrorLog</code>
      directives, respectively).  Subversion's mod_dav_svn uses
      Apache's error logging interface as well.  You can always browse
      the contents of those files for information that might reveal
      the source of a problem that is not clearly noticeable
      otherwise.</p><div class="sidebar"><p class="title"><b>Why Apache 2?</b></p><p>If you're a system administrator, it's very likely that
        you're already running the Apache web server and have some
        prior experience with it.  At the time of writing, Apache 1.3
        is by far the most popular version of Apache.  The world has
        been somewhat slow to upgrade to the Apache 2.X series for
        various reasons: some people fear change, especially changing
        something as critical as a web server.  Other people depend on
        plug-in modules that only work against the Apache 1.3 API, and
        are waiting for a 2.X port.  Whatever the reason, many people
        begin to worry when they first discover that Subversion's
        Apache module is written specifically for the Apache 2 API.</p><p>The proper response to this problem is: don't worry about
        it.  It's easy to run Apache 1.3 and Apache 2 side-by-side;
        simply install them to separate places, and use Apache 2 as a
        dedicated Subversion server that runs on a port other than 80.
        Clients can access the repository by placing the port number
        into the URL:</p><pre class="screen">
$ svn checkout http://host.example.com:7382/repos/project
…
</pre></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.serverconfig.httpd.prereqs"></a>Prerequisites</h3></div></div></div><p>To network your repository over HTTP, you basically need
        four components, available in two packages.  You'll need
        Apache <span><strong class="command">httpd</strong></span> 2.0, the
        <span><strong class="command">mod_dav</strong></span> DAV module that comes with it,
        Subversion, and the <span><strong class="command">mod_dav_svn</strong></span>
        filesystem provider module distributed with Subversion.
        Once you have all of those components, the process of
        networking your repository is as simple as:</p><div class="itemizedlist"><ul type="disc"><li><p>getting httpd 2.0 up and running with the mod_dav
            module,</p></li><li><p>installing the mod_dav_svn plugin to mod_dav, which
            uses Subversion's libraries to access the repository,
            and</p></li><li><p>configuring your <code class="filename">httpd.conf</code>
            file to export (or expose) the repository.</p></li></ul></div><p>You can accomplish the first two items either by
        compiling <span><strong class="command">httpd</strong></span> and Subversion from
        source code, or by installing pre-built binary packages of
        them on your system.  For the most up-to-date information on
        how to compile Subversion for use with the Apache HTTP Server,
        as well as how to compile and configure Apache itself for
        this purpose, see the <code class="filename">INSTALL</code> file in
        the top level of the Subversion source code tree.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.serverconfig.httpd.basic"></a>Basic Apache Configuration</h3></div></div></div><p>Once you have all the necessary components installed on
        your system, all that remains is the configuration of Apache
        via its <code class="filename">httpd.conf</code> file.  Instruct Apache
        to load the mod_dav_svn module using the
        <code class="literal">LoadModule</code> directive.  This directive must
        precede any other Subversion-related configuration items.  If
        your Apache was installed using the default layout, your
        <span><strong class="command">mod_dav_svn</strong></span> module should have been
        installed in the <code class="filename">modules</code> subdirectory of
        the Apache install location (often
        <code class="filename">/usr/local/apache2</code>).  The
        <code class="literal">LoadModule</code> directive has a simple syntax,
        mapping a named module to the location of a shared library on
        disk:</p><pre class="screen">
LoadModule dav_svn_module     modules/mod_dav_svn.so
</pre><p>Note that if <span><strong class="command">mod_dav</strong></span> was compiled as a
        shared object (instead of statically linked directly to the
        <span><strong class="command">httpd</strong></span> binary), you'll need a similar
        <code class="literal">LoadModule</code> statement for it, too.  Be sure
        that it comes before the <span><strong class="command">mod_dav_svn</strong></span> line:</p><pre class="screen">
LoadModule dav_module         modules/mod_dav.so
LoadModule dav_svn_module     modules/mod_dav_svn.so
</pre><p>At a later location in your configuration file, you now
        need to tell Apache where you keep your Subversion repository
        (or repositories).  The <code class="literal">Location</code> directive
        has an XML-like notation, starting with an opening tag, and
        ending with a closing tag, with various other configuration
        directives in the middle.  The purpose of the
        <code class="literal">Location</code> directive is to instruct Apache to
        do something special when handling requests that are directed
        at a given URL or one of its children.  In the case of
        Subversion, you want Apache to simply hand off support for
        URLs that point at versioned resources to the DAV layer.  You
        can instruct Apache to delegate the handling of all URLs whose
        path portions (the part of the URL that follows the server's
        name and the optional port number) begin with
        <code class="filename">/repos/</code> to a DAV provider whose
        repository is located at
        <code class="filename">/absolute/path/to/repository</code> using the
        following <code class="filename">httpd.conf</code> syntax:</p><pre class="screen">
&lt;Location /repos&gt;
  DAV svn
  SVNPath /absolute/path/to/repository
&lt;/Location&gt;
</pre><p>If you plan to support multiple Subversion repositories
        that will reside in the same parent directory on your local
        disk, you can use an alternative directive, the
        <code class="literal">SVNParentPath</code> directive, to indicate that
        common parent directory.  For example, if you know you will be
        creating multiple Subversion repositories in a directory
        <code class="filename">/usr/local/svn</code> that would be accessed via
        URLs like <code class="systemitem">http://my.server.com/svn/repos1</code>,
        <code class="systemitem">http://my.server.com/svn/repos2</code>, and
        so on, you could use the <code class="filename">httpd.conf</code>
        configuration syntax in the following example:</p><pre class="screen">
&lt;Location /svn&gt;
  DAV svn

  # any "/svn/foo" URL will map to a repository /usr/local/svn/foo
  SVNParentPath /usr/local/svn
&lt;/Location&gt;
</pre><p>Using the previous syntax, Apache will delegate the
        handling of all URLs whose path portions begin with
        <code class="filename">/svn/</code> to the Subversion DAV provider,
        which will then assume that any items in the directory
        specified by the <code class="literal">SVNParentPath</code> directive
        are actually Subversion repositories.  This is a particularly
        convenient syntax in that, unlike the use of the
        <code class="literal">SVNPath</code> directive, you don't have to
        restart Apache in order to create and network new
        repositories.</p><p>Be sure that when you define your new
        <code class="literal">Location</code>, it doesn't overlap with other
        exported Locations.  For example, if your main
        <code class="literal">DocumentRoot</code> is <code class="filename">/www</code>,
        do not export a Subversion repository in <code class="literal">&lt;Location
        /www/repos&gt;</code>.  If a request comes in for the URI
        <code class="filename">/www/repos/foo.c</code>, Apache won't know
        whether to look for a file <code class="filename">repos/foo.c</code> in
        the <code class="literal">DocumentRoot</code>, or whether to delegate
        <span><strong class="command">mod_dav_svn</strong></span> to return
        <code class="filename">foo.c</code> from the Subversion
        repository.</p><div class="sidebar"><p class="title"><b>Server Names and the COPY Request</b></p><p>Subversion makes use of the <code class="literal">COPY</code>
          request type to perform server-side copies of files and
          directories.  As part of the sanity checking done by the
          Apache modules, the source of the copy is expected to be
          located on the same machine as the destination of the copy.
          To satisfy this requirement, you might need to tell mod_dav
          the name you use as the hostname of your server.  Generally,
          you can use the <code class="literal">ServerName</code> directive in
          <code class="filename">httpd.conf</code> to accomplish this.</p><pre class="screen">
ServerName svn.example.com
</pre><p>If you are using Apache's virtual hosting support via
          the <code class="literal">NameVirtualHost</code> directive, you may
          need to use the <code class="literal">ServerAlias</code> directive to
          specify additional names that your server is known by.
          Again, refer to the Apache documentation for full
          details.</p></div><p>At this stage, you should strongly consider the question
        of permissions.  If you've been running Apache for some time
        now as your regular web server, you probably already have a
        collection of content—web pages, scripts and such.
        These items have already been configured with a set of
        permissions that allows them to work with Apache, or more
        appropriately, that allows Apache to work with those files.
        Apache, when used as a Subversion server, will also need the
        correct permissions to read and write to your Subversion
        repository.  (See <a href="#svn.serverconfig.svnserve.invoking.sb-1" title="Servers and Permissions:  A Word of Warning">Servers and Permissions:  A Word of Warning</a>.)</p><p>You will need to determine a permission system setup that
        satisfies Subversion's requirements without messing up any
        previously existing web page or script installations.  This
        might mean changing the permissions on your Subversion
        repository to match those in use by other things that Apache
        serves for you, or it could mean using the
        <code class="literal">User</code> and <code class="literal">Group</code>
        directives in <code class="filename">httpd.conf</code> to specify that
        Apache should run as the user and group that owns your
        Subversion repository.  There is no single correct way to set
        up your permissions, and each administrator will have
        different reasons for doing things a certain way.  Just be
        aware that permission-related problems are perhaps the most
        common oversight when configuring a Subversion repository for
        use with Apache.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.serverconfig.httpd.authn"></a>Authentication Options</h3></div></div></div><p>At this point, if you configured
        <code class="filename">httpd.conf</code> to contain something like</p><pre class="screen">
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
&lt;/Location&gt;
</pre><p>...then your repository is «<span class="quote">anonymously</span>»
        accessible to the world.  Until you configure some
        authentication and authorization policies, the Subversion
        repositories you make available via the
        <code class="literal">Location</code> directive will be generally
        accessible to everyone.  In other words,</p><div class="itemizedlist"><ul type="disc"><li><p>anyone can use their Subversion client to checkout a
            working copy of a repository URL (or any of its
            subdirectories),</p></li><li><p>anyone can interactively browse the repository's
            latest revision simply by pointing their web browser to
            the repository URL, and</p></li><li><p>anyone can commit to the repository.</p></li></ul></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.serverconfig.httpd.authn.basic"></a>Basic HTTP Authentication</h4></div></div></div><p>The easiest way to authenticate a client is via the
          HTTP Basic authentication mechanism, which simply uses a
          username and password to verify that a user is who she says
          she is.  Apache provides an <span><strong class="command">htpasswd</strong></span>
          utility for managing the list of acceptable usernames and
          passwords, those to whom you wish to grant special access to
          your Subversion repository.  Let's grant commit access to
          Sally and Harry.  First, we need to add them to the password
          file.</p><pre class="screen">
$ ### First time: use -c to create the file
$ ### Use -m to use MD5 encryption of the password, which is more secure
$ htpasswd -cm /etc/svn-auth-file harry
New password: ***** 
Re-type new password: *****
Adding password for user harry
$ htpasswd -m /etc/svn-auth-file sally
New password: *******
Re-type new password: *******
Adding password for user sally
$
</pre><p>Next, you need to add some more
          <code class="filename">httpd.conf</code> directives inside your
          <code class="literal">Location</code> block to tell Apache what to do
          with your new password file.  The
          <code class="literal">AuthType</code> directive specifies the type of
          authentication system to use.  In this case, we want to
          specify the <code class="literal">Basic</code> authentication system.
          <code class="literal">AuthName</code> is an arbitrary name that you
          give for the authentication domain.  Most browsers will
          display this name in the pop-up dialog box when the browser
          is querying the user for his name and password.  Finally,
          use the <code class="literal">AuthUserFile</code> directive to specify
          the location of the password file you created using
          <span><strong class="command">htpasswd</strong></span>.</p><p>After adding these three directives, your
          <code class="literal">&lt;Location&gt;</code> block should look
          something like this:</p><pre class="screen">
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /etc/svn-auth-file
&lt;/Location&gt;
</pre><p>This <code class="literal">&lt;Location&gt;</code> block is not
          yet complete, and will not do anything useful.  It's merely
          telling Apache that whenever authorization is required,
          Apache should harvest a username and password from the
          Subversion client.  What's missing here, however, are
          directives that tell Apache <span class="emphasis"><em>which</em></span> sorts
          of client requests require authorization.  Wherever
          authorization is required, Apache will demand
          authentication as well.  The simplest thing to do is protect
          all requests.  Adding <code class="literal">Require valid-user</code>
          tells Apache that all requests require an authenticated
          user:</p><pre class="screen">
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /etc/svn-auth-file
  Require valid-user
&lt;/Location&gt;
</pre><p>Be sure to read the next section (<a href="#svn.serverconfig.httpd.authz" title="Authorization Options">la sezione chiamata «Authorization Options»</a>) for more detail on the
          <code class="literal">Require</code> directive and other ways to set
          authorization policies.</p><p>One word of warning: HTTP Basic Auth passwords pass in
          very nearly plain-text over the network, and thus are
          extremely insecure.  If you're worried about password
          snooping, it may be best to use some sort of SSL encryption,
          so that clients authenticate via <code class="literal">https://</code>
          instead of <code class="literal">http://</code>; at a bare minimum,
          you can configure Apache to use a self-signed server
          certificate.
          <sup>[<a id="id4749950" href="#ftn.id4749950">26</a>]</sup>
          Consult Apache's documentation (and OpenSSL documentation)
          about how to do that.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.serverconfig.httpd.authn.sslcerts"></a>SSL Certificate Management</h4></div></div></div><p>Businesses that need to expose their repositories for access
          outside the company firewall should be conscious of the
          possibility that unauthorized parties could be
          «<span class="quote">sniffing</span>» their network traffic.  SSL makes
          that kind of unwanted attention less likely to result in
          sensitive data leaks.</p><p>If a Subversion client is compiled to use OpenSSL, then
          it gains the ability to speak to an Apache server via
          <code class="literal">https://</code> URLs.  The Neon library used by
          the Subversion client is not only able to verify server
          certificates, but can also supply client certificates when
          challenged.  When the client and server have exchanged SSL
          certificates and successfully authenticated one another, all
          further communication is encrypted via a session key.</p><p>It's beyond the scope of this book to describe how to
          generate client and server certificates, and how to
          configure Apache to use them.  Many other books, including
          Apache's own documentation, describe this task.  But what
          <span class="emphasis"><em>can</em></span> be covered here is how to manage
          server and client certificates from an ordinary Subversion
          client.</p><p>When speaking to Apache via <code class="literal">https://</code>,
          a Subversion client can receive two different types of
          information:</p><div class="itemizedlist"><ul type="disc"><li><p>a server certificate</p></li><li><p>a demand for a client certificate</p></li></ul></div><p>If the client receives a server certificate, it needs to
          verify that it trusts the certificate: is the server really
          who it claims to be?  The OpenSSL library does this by
          examining the signer of the server certificate, or
          <em class="firstterm">certifying authority</em> (CA).  If
          OpenSSL is unable to automatically trust the CA, or if some
          other problem occurs (such as an expired certificate or
          hostname mismatch), the Subversion command-line client will
          ask you whether you want to trust the server certificate
          anyway:</p><pre class="screen">
$ svn list https://host.example.com/repos/project

Error validating server certificate for 'https://host.example.com:443':
 - The certificate is not issued by a trusted authority. Use the
   fingerprint to validate the certificate manually!
Certificate information:
 - Hostname: host.example.com
 - Valid: from Jan 30 19:23:56 2004 GMT until Jan 30 19:23:56 2006 GMT
 - Issuer: CA, example.com, Sometown, California, US
 - Fingerprint: 7d:e1:a9:34:33:39:ba:6a:e9:a5:c4:22:98:7b:76:5c:92:a0:9c:7b

(R)eject, accept (t)emporarily or accept (p)ermanently?
</pre><p>This dialogue should look familiar; it's essentially the
          same question you've probably seen coming from your web
          browser (which is just another HTTP client like Subversion!).
          If you choose the (p)ermanent option, the server certificate
          will be cached in your private run-time
          <code class="filename">auth/</code> area in just the same way your
          username and password are cached (see <a href="#svn.serverconfig.netmodel.credcache" title="Client Credentials Caching">la sezione chiamata «Client Credentials Caching»</a>).  If cached,
          Subversion will automatically remember to trust this certificate
          in future negotiations.</p><p>Your run-time <code class="filename">servers</code> file also gives
          you the ability to make your Subversion client automatically
          trust specific CAs, either globally or on a per-host basis.
          Simply set the <code class="literal">ssl-authority-files</code>
          variable to a semicolon-separated list of PEM-encoded CA
          certificates:</p><pre class="screen">
[global]
ssl-authority-files = /path/to/CAcert1.pem;/path/to/CAcert2.pem
</pre><p>Many OpenSSL installations also have a pre-defined set
          of «<span class="quote">default</span>» CAs that are nearly universally
          trusted.  To make the Subversion client automatically trust
          these standard authorities, set the
          <code class="literal">ssl-trust-default-ca</code> variable to
          <code class="literal">true</code>.</p><p>When talking to Apache, a Subversion client might also
          receive a challenge for a client certificate.  Apache is
          asking the client to identify itself: is the client really
          who it says it is?  If all goes correctly, the Subversion
          client sends back a private certificate signed by a CA that
          Apache trusts.  A client certificate is usually stored on
          disk in encrypted format, protected by a local password.
          When Subversion receives this challenge, it will ask you for
          both a path to the certificate and the password which
          protects it:</p><pre class="screen">
$ svn list https://host.example.com/repos/project

Authentication realm: https://host.example.com:443
Client certificate filename: /path/to/my/cert.p12
Passphrase for '/path/to/my/cert.p12':  ********
…
</pre><p>Notice that the client certificate is a
          «<span class="quote">p12</span>» file.  To use a client certificate with
          Subversion, it must be in PKCS#12 format, which is a
          portable standard.  Most web browsers are already able to
          import and export certificates in that format.   Another
          option is to use the OpenSSL command-line tools to convert
          existing certificates into PKCS#12.</p><p>Again, the runtime <code class="filename">servers</code> file
          allows you to automate this challenge on a per-host basis.
          Either or both pieces of information can be described in
          runtime variables:</p><pre class="screen">
[groups]
examplehost = host.example.com

[examplehost]
ssl-client-cert-file = /path/to/my/cert.p12
ssl-client-cert-password = somepassword
</pre><p>Once you've set the
          <code class="literal">ssl-client-cert-file</code> and
          <code class="literal">ssl-client-cert-password</code> variables, the
          Subversion client can automatically respond to a client
          certificate challenge without prompting you.
          <sup>[<a id="id4750217" href="#ftn.id4750217">27</a>]</sup>
        </p></div></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.serverconfig.httpd.authz"></a>Authorization Options</h3></div></div></div><p>At this point, you've configured authentication, but not
        authorization.  Apache is able to challenge clients and
        confirm identities, but it has not been told how to allow or
        restrict access to the clients bearing those identities.  This
        section describes two strategies for controlling access to
        your repositories.</p><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.serverconfig.httpd.authz.blanket"></a>Blanket Access Control</h4></div></div></div><p>The simplest form of access control is to authorize
          certain users for either read-only access to a repository,
          or read/write access to a repository.</p><p>You can restrict access on all repository operations by
          adding the <code class="literal">Require valid-user</code> directive
          to your <code class="literal">&lt;Location&gt;</code> block.  Using
          our previous example, this would mean that only clients that
          claimed to be either <code class="literal">harry</code> or
          <code class="literal">sally</code>, and provided the correct
          password for their respective username, would be allowed to
          do anything with the Subversion repository:</p><pre class="screen">
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # how to authenticate a user
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file
  
  # only authenticated users may access the repository
  Require valid-user
&lt;/Location&gt;
</pre><p>Sometimes you don't need to run such a tight ship.  For
          example, Subversion's own source code repository at
          <a href="http://svn.collab.net/repos/svn" target="_top">http://svn.collab.net/repos/svn</a> allows anyone
          in the world to perform read-only repository tasks (like
          checking out working copies and browsing the repository with
          a web browser), but restricts all write operations to
          authenticated users.  To do this type of selective
          restriction, you can use the <code class="literal">Limit</code> and
          <code class="literal">LimitExcept</code> configuration directives.
          Like the <code class="literal">Location</code> directive, these blocks
          have starting and ending tags, and you would nest them
          inside your <code class="literal">&lt;Location&gt;</code>
          block.</p><p>The parameters present on the <code class="literal">Limit</code>
          and <code class="literal">LimitExcept</code> directives are HTTP
          request types that are affected by that block.  For example,
          if you wanted to disallow all access to your repository
          except the currently supported read-only operations, you
          would use the <code class="literal">LimitExcept</code> directive,
          passing the <code class="literal">GET</code>,
          <code class="literal">PROPFIND</code>, <code class="literal">OPTIONS</code>, and
          <code class="literal">REPORT</code> request type parameters.  Then the
          previously mentioned <code class="literal">Require valid-user</code>
          directive would be placed inside the
          <code class="literal">&lt;LimitExcept&gt;</code> block instead of just
          inside the <code class="literal">&lt;Location&gt;</code> block.</p><pre class="screen">
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # how to authenticate a user
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file

  # For any operations other than these, require an authenticated user.
  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;
    Require valid-user
  &lt;/LimitExcept&gt;
&lt;/Location&gt;
</pre><p>These are only a few simple examples.  For more in-depth
          information about Apache access control and the
          <code class="literal">Require</code> directive, take a look at the
          <code class="literal">Security</code> section of the Apache
          documentation's tutorials collection at <a href="http://httpd.apache.org/docs-2.0/misc/tutorials.html" target="_top">http://httpd.apache.org/docs-2.0/misc/tutorials.html</a>.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.serverconfig.httpd.authz.perdir"></a>Per-Directory Access Control</h4></div></div></div><p>It's possible to set up finer-grained permissions using
          a second Apache httpd module,
          <span><strong class="command">mod_authz_svn</strong></span>.  This module grabs the
          various opaque URLs passing from client to server, asks
          <span><strong class="command">mod_dav_svn</strong></span> to decode them, and then
          possibly vetoes requests based on access policies defined in
          a configuration file.</p><p>If you've built Subversion from source code,
          <span><strong class="command">mod_authz_svn</strong></span> is automatically built
          and installed alongside <span><strong class="command">mod_dav_svn</strong></span>.
          Many binary distributions install it automatically as well.
          To verify that it's installed correctly, make sure it comes
          right after <span><strong class="command">mod_dav_svn</strong></span>'s
          <code class="literal">LoadModule</code> directive in
          <code class="filename">httpd.conf</code>:</p><pre class="screen">
LoadModule dav_module         modules/mod_dav.so
LoadModule dav_svn_module     modules/mod_dav_svn.so
LoadModule authz_svn_module   modules/mod_authz_svn.so
</pre><p>To activate this module, you need to configure your
          <code class="literal">Location</code> block to use the
          <code class="literal">AuthzSVNAccessFile</code> directive, which
          specifies a file containing the permissions policy for paths
          within your repositories.  (In a moment, we'll discuss the
          format of that file.)</p><p>Apache is flexible, so you have the option to configure
          your block in one of three general patterns.  To begin,
          choose one of these basic configuration patterns.  (The
          examples below are very simple; look at Apache's own
          documentation for much more detail on Apache authentication
          and authorization options.)</p><p>The simplest block is to allow open access to everyone.
          In this scenario, Apache never sends authentication
          challenges, so all users are treated as
          «<span class="quote">anonymous</span>».</p><div class="example"><a id="svn.serverconfig.httpd.authz.perdir.ex-1"></a><p class="title"><b>Esempio 6.1. A sample configuration for anonymous access.</b></p><div class="example-contents"><pre class="programlisting">
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # our access control policy
  AuthzSVNAccessFile /path/to/access/file                 
&lt;/Location&gt;
          </pre></div></div><br class="example-break" /><p>On the opposite end of the paranoia scale, you can
          configure your block to demand authentication from everyone.
          All clients must supply credentials to identify themselves.
          Your block unconditionally requires authentication via the
          <code class="literal">Require valid-user</code> directive, and defines
          a means to authenticate.</p><div class="example"><a id="svn.serverconfig.httpd.authz.perdir.ex-2"></a><p class="title"><b>Esempio 6.2. A sample configuration for authenticated access.</b></p><div class="example-contents"><pre class="programlisting">
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /usr/local/svn
            
  # our access control policy
  AuthzSVNAccessFile /path/to/access/file                 
            
  # only authenticated users may access the repository
  Require valid-user
            
  # how to authenticate a user
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file                  
&lt;/Location&gt;
          </pre></div></div><br class="example-break" /><p>A third very popular pattern is to allow a combination
          of authenticated and anonymous access.  For example, many
          administrators want to allow anonymous users to read certain
          repository directories, but want only authenticated users to
          read (or write) more sensitive areas.  In this setup, all
          users start out accessing the repository anonymously.  If
          your access control policy demands a real username at any
          point, Apache will demand authentication from the client.
          To do this, you use both the <code class="literal">Satisfy Any</code>
          and <code class="literal">Require valid-user</code> directives
          together.</p><div class="example"><a id="svn.serverconfig.httpd.authz.perdir.ex-3"></a><p class="title"><b>Esempio 6.3. A sample configuration for mixed
            authenticated/anonymous access.</b></p><div class="example-contents"><pre class="programlisting">
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /usr/local/svn
            
  # our access control policy
  AuthzSVNAccessFile /path/to/access/file                 
            
  # try anonymous access first, resort to real 
  # authentication if necessary.
  Satisfy Any
  Require valid-user
            
  # how to authenticate a user
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file                  
&lt;/Location&gt;
          </pre></div></div><br class="example-break" /><p>Once your basic <code class="literal">Location</code> block is
          configured, you can create an access file and define some
          authorization rules in it.</p><p>The syntax of the access file is the same familiar one
          used by <span><strong class="command">svnserve.conf</strong></span> and the runtime
          configuration files.  Lines that start with a hash
          (<code class="literal">#</code>) are ignored.  In its simplest form,
          each section names a repository and path within it, and the
          authenticated usernames are the option names within each
          section.  The value of each option describes the user's
          level of access to the repository path: either
          <code class="literal">r</code> (read-only) or <code class="literal">rw</code>
          (read-write).  If the user is not mentioned at all, no
          access is allowed.</p><p>To be more specific: the value of the section-names are
          either of the form <code class="literal">[repos-name:path]</code> or
          the form <code class="literal">[path]</code>.  If you're using the
          <code class="literal">SVNParentPath</code> directive, then it's
          important to specify the repository names in your sections.
          If you omit them, then a section like
          <code class="literal">[/some/dir]</code> will match the path
          <code class="filename">/some/dir</code> in <span class="emphasis"><em>every</em></span>
          repository.  If you're using the <code class="literal">SVNPath</code>
          directive, however, then it's fine to only define paths in
          your sections—after all, there's only one
          repository.</p><pre class="screen">
[calc:/branches/calc/bug-142]
harry = rw
sally = r
</pre><p>In this first example, the user <code class="literal">harry</code> has
          full read and write access on the
          <code class="filename">/branches/calc/bug-142</code> directory in the
          <code class="literal">calc</code> repository, but the user
          <code class="literal">sally</code> has read-only access.  Any other
          users are blocked from accessing this directory.</p><p>Of course, permissions are inherited from
          parent to child directory.  That means that we can specify a
          subdirectory with a different access policy for
          Sally:</p><pre class="screen">
[calc:/branches/calc/bug-142]
harry = rw
sally = r

# give sally write access only to the 'testing' subdir
[calc:/branches/calc/bug-142/testing]
sally = rw
</pre><p>Now Sally can write to the <code class="filename">testing</code>
          subdirectory of the branch, but can still only read other
          parts.  Harry, meanwhile, continues to have complete
          read-write access to the whole branch.</p><p>It's also possible to explicitly deny permission to
          someone via inheritance rules, by setting the username
          variable to nothing:</p><pre class="screen">
[calc:/branches/calc/bug-142]
harry = rw
sally = r

[calc:/branches/calc/bug-142/secret]
harry =
</pre><p>In this example, Harry has read-write access to the
          entire <code class="filename">bug-142</code> tree, but has absolutely no
          access at all to the <code class="filename">secret</code>
          subdirectory within it.</p><p>The thing to remember is that the most specific path
          always matches first.  The <span><strong class="command">mod_authz_svn</strong></span>
          module tries to match the path itself, and then the parent
          of the path, then the parent of that, and so on.  The net
          effect is that mentioning a specific path in the accessfile
          will always override any permissions inherited from parent
          directories.</p><p>By default, nobody has any access to the repository at
          all.  That means that if you're starting with an empty file,
          you'll probably want to give at least read permission to all
          users at the root of the repository.  You can do this by
          using the asterisk variable (<code class="literal">*</code>), which
          means «<span class="quote">all users</span>»:</p><pre class="screen">
[/]
* = r
</pre><p>This is a common setup; notice that there's no
          repository name mentioned in the section name.  This makes
          all repositories world readable to all users, whether you're
          using <code class="literal">SVNPath</code> or
          <code class="literal">SVNParentPath</code>.  Once all users have
          read-access to the repositories, you can give explicit
          <code class="literal">rw</code> permission to certain users on specific
          subdirectories within specific repositories.</p><p>The asterisk variable (<code class="literal">*</code>) is also
          worth special mention here: it's the
          <span class="emphasis"><em>only</em></span> pattern which matches an anonymous
          user.  If you've configured your <code class="literal">Location</code>
          block to allow a mixture of anonymous and authenticated
          access, all users start out accessing Apache anonymously.
          <span><strong class="command">mod_authz_svn</strong></span> looks for a
          <code class="literal">*</code> value defined for the path being
          accessed;  if it can't find one, then Apache demands real
          authentication from the client.</p><p>The access file also allows you to define whole groups
          of users, much like the Unix <code class="filename">/etc/group</code>
          file:</p><pre class="screen">
[groups]
calc-developers = harry, sally, joe
paint-developers = frank, sally, jane
everyone = harry, sally, joe, frank, sally, jane
</pre><p>Groups can be granted access control just like users.
          Distinguish them with an «<span class="quote">at</span>» (<code class="literal">@</code>)
          prefix:</p><pre class="screen">
[calc:/projects/calc]
@calc-developers = rw

[paint:/projects/paint]
@paint-developers = rw
jane = r 
</pre><p>Groups can also be defined to contain other
          groups:</p><pre class="screen">
[groups]
calc-developers = harry, sally, joe
paint-developers = frank, sally, jane
everyone = @calc-developers, @paint-developers
</pre><p>...and that's pretty much all there is to it.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.serverconfig.httpd.authz.pathauthzoff"></a>Disabling Path-based Checks</h4></div></div></div><p>The <span><strong class="command">mod_dav_svn</strong></span> module goes through a
          lot of work to make sure that data you've marked
          «<span class="quote">unreadable</span>» doesn't get accidentally leaked.
          This means that it needs to closely monitor all of the paths
          and file-contents returned by commands like <span><strong class="command">svn
          checkout</strong></span> or <span><strong class="command">svn update</strong></span>
          commands.  If these commands encounter a path that isn't
          readable according to some authorization policy, then the
          path is typically omitted altogether.  In the case of
          history or rename tracing—e.g. running a command like
          <span><strong class="command">svn cat -r OLD foo.c</strong></span> on a file that was
          renamed long ago—the rename tracking will simply halt
          if one of the object's former names is determined to be
          read-restricted.</p><p>All of this path-checking can sometimes be quite
          expensive, especially in the case of <span><strong class="command">svn
          log</strong></span>.  When retrieving a list revisions, the server
          looks at every changed path in each revision and checks it
          for readability.  If an unreadable path is discovered, then
          it's omitted from the list of the revision's changed paths
          (normally seen with the <code class="option">--verbose</code> option),
          and the whole log message is suppressed.  Needless to say,
          this can be time-consuming on revisions that affect a large
          number of files.  This is the cost of security: even if you
          haven't configured a module like
          <span><strong class="command">mod_authz_svn</strong></span> at all, the
          <span><strong class="command">mod_dav_svn</strong></span> module is still asking Apache
          <span><strong class="command">httpd</strong></span> to run authorization checks on
          every path.  The <span><strong class="command">mod_dav_svn</strong></span> module has
          no idea what authorization modules have been installed, so
          all it can do is ask Apache to invoke whatever might be
          present.</p><p>On the other hand, there's also an escape-hatch of
          sorts, one which allows you to trade security features for
          speed.  If you're not enforcing any sort of per-directory
          authorization (i.e. not using
          <span><strong class="command">mod_authz_svn</strong></span> or similar module), then
          you can disable all of this path-checking.  In your
          <code class="filename">httpd.conf</code> file, use the
          <code class="literal">SVNPathAuthz</code> directive:</p><div class="example"><a id="svn.serverconfig.httpd.authz.pathauthzoff.ex-1"></a><p class="title"><b>Esempio 6.4. Disabling path checks altogether</b></p><div class="example-contents"><pre class="programlisting">
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /usr/local/svn
            
  SVNPathAuthz off
&lt;/Location&gt;            
          </pre></div></div><br class="example-break" /><p>The <code class="literal">SVNPathAuthz</code> directive is «<span class="quote">on</span>» by
          default.  When set «<span class="quote">off</span>», all path-based
          authorization checking is disabled;
          <span><strong class="command">mod_dav_svn</strong></span> stops invoking authorization
          checks on every path it discovers.</p></div></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.serverconfig.httpd.extra"></a>Extra Goodies</h3></div></div></div><p>We've covered most of the authentication and authorization
        options for Apache and mod_dav_svn.  But there are a few other
        nice features that Apache provides.</p><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.serverconfig.httpd.extra.browsing"></a>Repository Browsing</h4></div></div></div><p>One of the most useful benefits of an Apache/WebDAV
          configuration for your Subversion repository is that the
          youngest revisions of your versioned files and directories
          are immediately available for viewing via a regular web
          browser.  Since Subversion uses URLs to identify versioned
          resources, those URLs used for HTTP-based repository access
          can be typed directly into a Web browser.  Your browser will
          issue a <code class="literal">GET</code> request for that URL, and
          based on whether that URL represents a versioned directory
          or file, mod_dav_svn will respond with a directory listing
          or with file contents.</p><p>Since the URLs do not contain any information about
          which version of the resource you wish to see, mod_dav_svn
          will always answer with the youngest version.  This
          functionality has the wonderful side-effect that you can
          pass around Subversion URLs to your peers as references to
          documents, and those URLs will always point at the latest
          manifestation of that document.  Of course, you can even use
          the URLs as hyperlinks from other web sites, too.</p><p>You generally will get more use out of URLs to versioned
          files—after all, that's where the interesting content
          tends to lie.  But you might have occasion to browse a
          Subversion directory listing, where you'll quickly note that
          the generated HTML used to display that listing is very
          basic, and certainly not intended to be aesthetically
          pleasing (or even interesting).  To enable customization of
          these directory displays, Subversion provides an XML index
          feature.  A single <code class="literal">SVNIndexXSLT</code> directive
          in your repository's <code class="literal">Location</code> block of
          <code class="filename">httpd.conf</code> will instruct mod_dav_svn to
          generate XML output when displaying a directory listing, and
          to reference the XSLT stylesheet of your choice:</p><pre class="screen">
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  SVNIndexXSLT "/svnindex.xsl"
  …
&lt;/Location&gt;
</pre><p>Using the <code class="literal">SVNIndexXSLT</code> directive and
          a creative XSLT stylesheet, you can make your directory
          listings match the color schemes and imagery used in other
          parts of your website.  Or, if you'd prefer, you can use the
          sample stylesheets provided in the Subversion source
          distribution's <code class="filename">tools/xslt/</code> directory.
          Keep in mind that the path provided to the
          <code class="literal">SVNIndexXSLT</code> directory is actually a URL
          path—browsers need to be able to read your stylesheets
          in order to make use of them!</p><div class="sidebar"><p class="title"><b>Can I view older revisions?</b></p><p>With an ordinary web browser?  In one word: nope.  At
            least, not with <span><strong class="command">mod_dav_svn</strong></span> as your
            only tool.</p><p>Your web browser only speaks ordinary HTTP.  That
            means it only knows how to GET public URLs, which
            represent the latest versions of files and directories.
            According to the WebDAV/DeltaV spec, each server defines a
            private URL syntax for older versions of resources, and
            that syntax is opaque to clients.  To find an older
            version of a file, a client must follow a specific
            procedure to «<span class="quote">discover</span>» the proper URL; the
            procedure involves issuing a series of WebDAV PROPFIND
            requests and understanding DeltaV concepts.  This is
            something your web browser simply can't do.</p><p>So to answer the question, one obvious way to see
            older revisions of files and directories is by passing the
            <code class="option">--revision</code> argument to the <span><strong class="command">svn
            list</strong></span> and <span><strong class="command">svn cat</strong></span> commands.
            To browse old revisions with your web browser, however,
            you can use third-party software.  A good example of this
            is ViewVC (<a href="http://viewvc.tigris.org/" target="_top">http://viewvc.tigris.org/</a>).
            ViewVC was originally written to display CVS repositories
            through the web,
            <sup>[<a id="id4751427" href="#ftn.id4751427">28</a>]</sup>
            and the latest bleeding-edge versions (at
            the time of writing) are able to understand Subversion
            repositories as well.</p></div></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.serverconfig.httpd.extra.other"></a>Other Features</h4></div></div></div><p>Several of the features already provided by Apache in
          its role as a robust Web server can be leveraged for
          increased functionality or security in Subversion as well.
          Subversion communicates with Apache using Neon, which is a
          generic HTTP/WebDAV library with support for such mechanisms
          as SSL (the Secure Socket Layer, discussed earlier) and
          Deflate compression (the same algorithm used by the
          <span><strong class="command">gzip</strong></span> and <span><strong class="command">PKZIP</strong></span>
          programs to «<span class="quote">shrink</span>» files into smaller chunks
          of data).  You need only to compile support for the features
          you desire into Subversion and Apache, and properly
          configure the programs to use those features.</p><p>Deflate compression places a small burden on the client
          and server to compress and decompress network transmissions
          as a way to minimize the size of the actual transmission.
          In cases where network bandwidth is in short supply, this
          kind of compression can greatly increase the speed at which
          communications between server and client can be sent.  In
          extreme cases, this minimized network transmission could be
          the difference between an operation timing out or completing
          successfully.</p><p>Less interesting, but equally useful, are other features
          of the Apache and Subversion relationship, such as the
          ability to specify a custom port (instead of the default
          HTTP port 80) or a virtual domain name by which the
          Subversion repository should be accessed, or the ability to
          access the repository through a proxy.  These things are all
          supported by Neon, so Subversion gets that support for
          free.</p><p>Finally, because <span><strong class="command">mod_dav_svn</strong></span> is
          speaking a semi-complete dialect of WebDAV/DeltaV, it's
          possible to access the repository via third-party DAV
          clients.  Most modern operating systems (Win32, OS X, and
          Linux) have the built-in ability to mount a DAV server as a
          standard network «<span class="quote">share</span>».  This is a
          complicated topic; for details, read <a href="#svn.webdav" title="Appendice&#xA0;B.&#xA0;WebDAV and Autoversioning">Appendice B, <i>WebDAV and Autoversioning</i></a>.</p></div></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.serverconfig.multimethod"></a>Supporting Multiple Repository Access Methods</h2></div></div></div><p>You've seen how a repository can be accessed in many
      different ways.  But is it possible—or safe—for your
      repository to be accessed by multiple methods simultaneously?
      The answer is yes, provided you use a bit of foresight.</p><p>At any given time, these processes may require read and
      write access to your repository:</p><div class="itemizedlist"><ul type="disc"><li><p>regular system users using a Subversion client (as
          themselves) to access the repository directly via
          <code class="literal">file:///</code> URLs;</p></li><li><p>regular system users connecting to SSH-spawned private
          <span><strong class="command">svnserve</strong></span> processes (running as
          themselves) which access the repository;</p></li><li><p>an <span><strong class="command">svnserve</strong></span> process—either a
          daemon or one launched by
          <span><strong class="command">inetd</strong></span>—running as a particular fixed
          user;</p></li><li><p>an Apache <span><strong class="command">httpd</strong></span> process, running as a
          particular fixed user.</p></li></ul></div><p>The most common problem administrators run into is repository
      ownership and permissions.  Does every process (or user) in the
      previous list have the rights to read and write the Berkeley DB
      files?  Assuming you have a Unix-like operating system, a
      straightforward approach might be to place every potential
      repository user into a new <code class="literal">svn</code> group, and
      make the repository wholly owned by that group.  But even that's
      not enough, because a process may write to the database files
      using an unfriendly umask—one that prevents access by
      other users.</p><p>So the next step beyond setting up a common group for
      repository users is to force every repository-accessing process
      to use a sane umask.  For users accessing the repository
      directly, you can make the <span><strong class="command">svn</strong></span> program into a
      wrapper script that first sets <span><strong class="command">umask 002</strong></span> and
      then runs the real <span><strong class="command">svn</strong></span> client program.  You
      can write a similar wrapper script for the
      <span><strong class="command">svnserve</strong></span> program, and add a <span><strong class="command">umask
      002</strong></span> command to Apache's own startup script,
      <code class="filename">apachectl</code>.  For example:</p><pre class="screen">
$ cat /usr/bin/svn

#!/bin/sh

umask 002
/usr/bin/svn-real "$@"

</pre><p>Another common problem is often encountered on Unix-like
      systems.  As a repository is used, Berkeley DB occasionally
      creates new log files to journal its actions.  Even if the
      repository is wholly owned by the <span><strong class="command">svn</strong></span> group,
      these newly created files won't necessarily be owned by that
      same group, which then creates more permissions problems for
      your users.  A good workaround is to set the group SUID bit on
      the repository's <code class="filename">db</code> directory.  This causes
      all newly-created log files to have the same group owner as the
      parent directory.</p><p>Once you've jumped through these hoops, your repository
      should be accessible by all the necessary processes.  It may
      seem a bit messy and complicated, but the problems of having
      multiple users sharing write-access to common files are classic
      ones that are not often elegantly solved.</p><p>Fortunately, most repository administrators will never
      <span class="emphasis"><em>need</em></span> to have such a complex configuration.
      Users who wish to access repositories that live on the same
      machine are not limited to using <code class="literal">file://</code>
      access URLs—they can typically contact the Apache HTTP
      server or <span><strong class="command">svnserve</strong></span> using
      <code class="literal">localhost</code> for the server name in their
      <code class="literal">http://</code> or <code class="literal">svn://</code> URLs.
      And to maintain multiple server processes for your Subversion
      repositories is likely to be more of a headache than necessary.
      We recommend you choose the server that best meets your needs
      and stick with it!</p><div class="sidebar"><p class="title"><b>The svn+ssh:// server checklist</b></p><p>It can be quite tricky to get a bunch of users with
        existing SSH accounts to share a repository without
        permissions problems.  If you're confused about all the things
        that you (as an administrator) need to do on a Unix-like
        system, here's a quick checklist that resummarizes some of
        things discussed in this section:</p><div class="itemizedlist"><ul type="disc"><li><p>All of your SSH users need to be able to read and
            write to the repository.  Put all the SSH users into a
            single group.  Make the repository wholly owned by that
            group, and set the group permissions to read/write.</p></li><li><p>Your users need to use a sane umask when accessing the
            repository.  Make sure that <span><strong class="command">svnserve</strong></span>
            (<code class="filename">/usr/bin/svnserve</code>, or wherever
            it lives in <code class="literal">$PATH</code>) is actually a
            wrapper script which sets <span><strong class="command">umask 002</strong></span> and
            executes the real <span><strong class="command">svnserve</strong></span>
            binary.  Take similar measures when using
            <span><strong class="command">svnlook</strong></span> and
            <span><strong class="command">svnadmin</strong></span>.  Either run them with a sane
            umask, or wrap them as described above.</p></li></ul></div></div></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.id4747041" href="#id4747041">22</a>] </sup>This problem is actually a FAQ, resulting from
        a misconfigured server setup.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4747299" href="#id4747299">23</a>] </sup>Again, a common mistake is to misconfigure a
           server so that it never issues an authentication challenge.
           When users pass <code class="option">--username</code> and
           <code class="option">--password</code> options to the client,
           they're surprised to see that they're never used, i.e. new
           revisions still appear to have been committed
           anonymously!</p></div><div class="footnote"><p><sup>[<a id="ftn.id4747940" href="#id4747940">24</a>] </sup>See RFC 2195.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4749048" href="#id4749048">25</a>] </sup>They really hate doing that.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4749950" href="#id4749950">26</a>] </sup>While self-signed server certificates are still
              vulnerable to a «<span class="quote">man in the middle</span>» attack,
              such an attack is still much more difficult for a casual
              observer to pull off, compared to sniffing unprotected
              passwords.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4750217" href="#id4750217">27</a>] </sup>More security-conscious folk might not want to store
              the client certificate password in the runtime
              <code class="filename">servers</code> file.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4751427" href="#id4751427">28</a>] </sup>Back then, it was called «<span class="quote">ViewCVS</span>».</p></div></div></div><div class="chapter" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title"><a id="svn.advanced"></a>Capitolo 7. Advanced Topics</h2></div></div></div><div class="toc"><p><b>Sommario</b></p><dl><dt><span class="sect1"><a href="#svn.advanced.confarea">Runtime Configuration Area</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.advanced.confarea.layout">Configuration Area Layout</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.confarea.windows-registry">Configuration and the Windows Registry</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.confarea.opts">Configuration Options</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.advanced.confarea.opts.servers">Servers</a></span></dt><dt><span class="sect3"><a href="#svn.advanced.confarea.opts.config">Config</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.advanced.props">Properties</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.advanced.props.why">Why Properties?</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.props.manip">Manipulating Properties</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.props.special">Special Properties</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.advanced.props.special.executable"><code class="literal">svn:executable</code></a></span></dt><dt><span class="sect3"><a href="#svn.advanced.props.special.mime-type"><code class="literal">svn:mime-type</code></a></span></dt><dt><span class="sect3"><a href="#svn.advanced.props.special.ignore"><code class="literal">svn:ignore</code></a></span></dt><dt><span class="sect3"><a href="#svn.advanced.props.special.keywords"><code class="literal">svn:keywords</code></a></span></dt><dt><span class="sect3"><a href="#svn.advanced.props.special.eol-style"><code class="literal">svn:eol-style</code></a></span></dt><dt><span class="sect3"><a href="#svn.advanced.props.special.externals"><code class="literal">svn:externals</code></a></span></dt><dt><span class="sect3"><a href="#svn.advanced.props.special.special"><code class="literal">svn:special</code></a></span></dt><dt><span class="sect3"><a href="#svn.advanced.props.special.needs-lock"><code class="literal">svn:needs-lock</code></a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.advanced.props.auto">Automatic Property Setting</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.advanced.locking">Locking</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.advanced.locking.creation">Creating locks</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.locking.discovery">Discovering locks</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.locking.break-steal">Breaking and stealing locks</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.locking.lock-communication">Lock Communication</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.advanced.pegrevs">Peg and Operative Revisions</a></span></dt><dt><span class="sect1"><a href="#svn.advanced.externals">Externals Definitions</a></span></dt><dt><span class="sect1"><a href="#svn.advanced.vendorbr">Vendor branches</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.advanced.vendorbr.general">General Vendor Branch Management Procedure</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.vendorbr.svn_load_dirs"><span><strong class="command">svn_load_dirs.pl</strong></span></a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.advanced.l10n">Localization</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.advanced.l10n.understanding">Understanding locales</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.l10n.svnuse">Subversion's use of locales</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.advanced.externaldifftools">Using External Differencing Tools</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.advanced.externaldifftools.diff">External diff</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.externaldifftools.diff3">External diff3</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.advanced.reposurls">Subversion Repository URLs</a></span></dt></dl></div><div class="simplesect" lang="it" xml:lang="it"><div class="titlepage"></div><p>If you've been reading this book chapter by chapter, from
      start to finish, you should by now have acquired enough
      knowledge to use the Subversion client to perform the most
      common version control operations.  You understand how to
      checkout a working copy from a Subversion repository.  You are
      comfortable with submitting and receiving changes using the
      <span><strong class="command">svn commit</strong></span> and <span><strong class="command">svn update</strong></span>
      functions.  You've probably even developed a reflex which causes
      you to run the <span><strong class="command">svn status</strong></span> command almost
      unconsciously.  For all intents and purposes, you are ready to
      use Subversion in a typical environment.</p><p>But the Subversion feature set doesn't stop at «<span class="quote">common
      version control operations</span>».</p><p>This chapter highlights some of Subversion's features that
      aren't quite so regularly used.  In it, we will discuss
      Subversion's property (or «<span class="quote">metadata</span>») support, and
      how to modify Subversion's default behaviors by tweaking its
      run-time configuration area.  We will describe how you can use
      externals definitions to instruct Subversion to pull data from
      multiple repositories.  We'll cover in detail some of the
      additional client- and server-side tools that are part of the
      Subversion distribution.</p><p>Before reading this chapter, you should be familiar with the
      basic file and directory versioning capabilities of Subversion.
      If you haven't already read about those, or if you need a
      refresher, we recommend that you check out <a href="#svn.basic" title="Capitolo&#xA0;2.&#xA0;Basic Concepts">Capitolo 2, <i>Basic Concepts</i></a> and <a href="#svn.tour" title="Capitolo&#xA0;3.&#xA0;Visita guidata">Capitolo 3, <i>Visita guidata</i></a>.  Once
      you've mastered the basics and consumed this chapter, you'll be
      a Subversion power-user!
    </p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.advanced.confarea"></a>Runtime Configuration Area</h2></div></div></div><p>Subversion provides many optional behaviors that can be
      controlled by the user.  Many of these options are of the kind
      that a user would wish to apply to all Subversion operations.
      So, rather than forcing users to remember command-line arguments
      for specifying these options, and to use them for each and every
      operation they perform, Subversion uses configuration files,
      segregated into a Subversion configuration area.</p><p>The Subversion <em class="firstterm">configuration area</em> is
      a two-tiered hierarchy of option names and their values.
      Usually, this boils down to a special directory that contains
      <em class="firstterm">configuration files</em> (the first tier),
      which are just text files in standard INI format (with
      «<span class="quote">sections</span>» providing the second tier).  These files
      can be easily edited using your favorite text editor (such as
      Emacs or vi), and contain directives read by the client to
      determine which of several optional behaviors the user
      prefers.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.confarea.layout"></a>Configuration Area Layout</h3></div></div></div><p>The first time that the <span><strong class="command">svn</strong></span>
        command-line client is executed, it creates a per-user
        configuration area.  On Unix-like systems, this area appears
        as a directory named <code class="filename">.subversion</code> in the
        user's home directory.  On Win32 systems, Subversion creates a
        folder named <code class="filename">Subversion</code>, typically inside
        the <code class="filename">Application Data</code> area of the user's
        profile directory (which, by the way, is usually a hidden
        directory).  However, on this platform the exact location
        differs from system to system, and is dictated by the Windows
        registry.
        <sup>[<a id="id4752056" href="#ftn.id4752056">29</a>]</sup>
        We will refer to the per-user configuration area using its Unix
        name, <code class="filename">.subversion</code>.</p><p>In addition to the per-user configuration area, Subversion
        also recognizes the existence of a system-wide configuration
        area.  This gives system administrators the ability to
        establish defaults for all users on a given machine.  Note
        that the system-wide configuration area does not alone dictate
        mandatory policy—the settings in the per-user
        configuration area override those in the system-wide one, and
        command-line arguments supplied to the <span><strong class="command">svn</strong></span>
        program have the final word on behavior.  On Unix-like
        platforms, the system-wide configuration area is
        expected to be the <code class="filename">/etc/subversion</code>
        directory; on Windows machines, it looks for a
        <code class="filename">Subversion</code> directory inside the common
        <code class="filename">Application Data</code> location (again, as
        specified by the Windows Registry).  Unlike the per-user
        case, the <span><strong class="command">svn</strong></span> program does not attempt
        to create the system-wide configuration area.</p><p>The configuration area currently contains three
        files—two configuration files (<code class="filename">config</code> and
        <code class="filename">servers</code>), and a <code class="filename">README.txt</code> 
        file which describes the INI format.  At the time of their
        creation, the files contain default values for each of the
        supported Subversion options, mostly commented out and grouped
        with textual descriptions about how the values for the key
        affect Subversion's behavior.  To change a certain behavior,
        you need only to load the appropriate configuration file into
        a text editor, and modify the desired option's value.  If at
        any time you wish to have the default configuration settings
        restored, you can simply remove (or rename) your configuration
        directory and then run some innocuous <span><strong class="command">svn</strong></span>
        command, such as <span><strong class="command">svn --version</strong></span>.  A new
        configuration directory with the default contents will be
        created.</p><p>The per-user configuration area also contains a cache of
        authentication data.  The <code class="filename">auth</code> directory
        holds a set of subdirectories that contain pieces of cached
        information used by Subversion's various supported
        authentication methods.  This directory is created in such a
        way that only the user herself has permission to read its
        contents.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.confarea.windows-registry"></a>Configuration and the Windows Registry</h3></div></div></div><p>In addition to the usual INI-based configuration area,
        Subversion clients running on Windows platforms may also use
        the Windows registry to hold the configuration data.  The
        option names and their values are the same as in the INI
        files.  The «<span class="quote">file/section</span>» hierarchy is
        preserved as well, though addressed in a slightly different
        fashion—in this schema, files and sections are just
        levels in the registry key tree.</p><p>Subversion looks for system-wide configuration values
        under the
        <code class="literal">HKEY_LOCAL_MACHINE\Software\Tigris.org\Subversion</code>
        key.  For example, the <code class="literal">global-ignores</code> option,
        which is in the <code class="literal">miscellany</code> section of the
        <code class="filename">config</code> file, would be found at
        <code class="literal">HKEY_LOCAL_MACHINE\Software\Tigris.org\Subversion\Config\Miscellany\global-ignores</code>.
        Per-user configuration values should be stored under
        <code class="literal">HKEY_CURRENT_USER\Software\Tigris.org\Subversion</code>.
      </p><p>Registry-based configuration options are parsed
        <span class="emphasis"><em>before</em></span> their file-based counterparts,
        so are overridden by values found in the configuration
        files.  In other words, configuration priority is granted in
        the following order on a Windows system:</p><div class="orderedlist"><ol type="1"><li><p>Command-line options</p></li><li><p>The per-user INI files</p></li><li><p>The per-user Registry values</p></li><li><p>The system-wide INI files</p></li><li><p>The system-wide Registry values</p></li></ol></div><p>Also, the Windows Registry doesn't really support the
        notion of something being «<span class="quote">commented out</span>».
        However, Subversion will ignore any option key whose name
        begins with a hash (<code class="literal">#</code>) character.  This
        allows you to effectively comment out a Subversion option
        without deleting the entire key from the Registry, obviously
        simplifying the process of restoring that option.</p><p>The <span><strong class="command">svn</strong></span> command-line client never
        attempts to write to the Windows Registry, and will not
        attempt to create a default configuration area there.  You can
        create the keys you need using the <span><strong class="command">REGEDIT</strong></span>
        program.  Alternatively, you can create a
        <code class="filename">.reg</code> file, and then double-click on that
        file from the Explorer shell, which will cause the data to be
        merged into your registry.</p><div class="example"><a id="svn.advanced.confarea.windows-registry.ex-1"></a><p class="title"><b>Esempio 7.1. Sample Registration Entries (.reg) File.</b></p><div class="example-contents"><pre class="programlisting">
REGEDIT4

[HKEY_LOCAL_MACHINE\Software\Tigris.org\Subversion\Servers\groups]

[HKEY_LOCAL_MACHINE\Software\Tigris.org\Subversion\Servers\global]
"#http-proxy-host"=""
"#http-proxy-port"=""
"#http-proxy-username"=""
"#http-proxy-password"=""
"#http-proxy-exceptions"=""
"#http-timeout"="0"
"#http-compression"="yes"
"#neon-debug-mask"=""
"#ssl-authority-files"=""
"#ssl-trust-default-ca"=""
"#ssl-client-cert-file"=""
"#ssl-client-cert-password"=""

[HKEY_CURRENT_USER\Software\Tigris.org\Subversion\Config\auth]
"#store-auth-creds"="no"

[HKEY_CURRENT_USER\Software\Tigris.org\Subversion\Config\helpers]
"#editor-cmd"="notepad"
"#diff-cmd"=""
"#diff3-cmd"=""
"#diff3-has-program-arg"=""

[HKEY_CURRENT_USER\Software\Tigris.org\Subversion\Config\miscellany]
"#global-ignores"="*.o *.lo *.la #*# .*.rej *.rej .*~ *~ .#* .DS_Store"
"#log-encoding"=""
"#use-commit-times"=""
"#template-root"=""
"#enable-auto-props"=""

[HKEY_CURRENT_USER\Software\Tigris.org\Subversion\Config\tunnels]

[HKEY_CURRENT_USER\Software\Tigris.org\Subversion\Config\auto-props]
</pre></div></div><br class="example-break" /><p>The previous example shows the contents of a
        <code class="filename">.reg</code> file which contains some of the most
        commonly used configuration options and their default values.
        Note the presence of both system-wide (for network
        proxy-related options) and per-user settings (editor programs
        and password storage, among others).  Also note that all the
        options are effectively commented out.  You need only to
        remove the hash (<code class="literal">#</code>) character from the
        beginning of the option names, and set the values as you
        desire.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.confarea.opts"></a>Configuration Options</h3></div></div></div><p>In this section, we will discuss the specific
        run-time configuration options that are currently supported
        by Subversion.</p><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.advanced.confarea.opts.servers"></a>Servers</h4></div></div></div><p>The <code class="filename">servers</code> file contains
          Subversion configuration options related to the network
          layers.  There are two special section names in this
          file—<code class="literal">groups</code> and
          <code class="literal">global</code>.  The <code class="literal">groups</code>
          section is essentially a cross-reference table.  The keys in
          this section are the names of other sections in the file;
          their values are <em class="firstterm">globs</em>—textual
          tokens which possibly contain wildcard
          characters—that are compared against the hostnames of
          the machine to which Subversion requests are sent.</p><pre class="programlisting">
[groups]
beanie-babies = *.red-bean.com
collabnet = svn.collab.net

[beanie-babies]
…

[collabnet]
…
</pre><p>When Subversion is used over a network, it attempts to
          match the name of the server it is trying to reach with a
          group name under the <code class="literal">groups</code> section.  If
          a match is made, Subversion then looks for a section in the
          <code class="filename">servers</code> file whose name is the matched
          group's name.  From that section it reads the actual network
          configuration settings.</p><p>The <code class="literal">global</code> section contains the
          settings that are meant for all of the servers not matched
          by one of the globs under the <code class="literal">groups</code>
          section.  The options available in this section are
          exactly the same as those valid for the other server
          sections in the file (except, of course, the special
          <code class="literal">groups</code> section), and are as
          follows:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">http-proxy-host</code></span></dt><dd><p>This specifies the hostname of the proxy computer
                through which your HTTP-based Subversion requests must
                pass.  It defaults to an empty value, which means that
                Subversion will not attempt to route HTTP requests
                through a proxy computer, and will instead attempt to
                contact the destination machine directly.</p></dd><dt><span class="term"><code class="literal">http-proxy-port</code></span></dt><dd><p>This specifies the port number on the proxy host
                to use.  It defaults to an empty value.</p></dd><dt><span class="term"><code class="literal">http-proxy-username</code></span></dt><dd><p>This specifies the username to supply to the proxy
                machine.  It defaults to an empty value.</p></dd><dt><span class="term"><code class="literal">http-proxy-password</code></span></dt><dd><p>This specifies the password to supply to the proxy
                machine.  It defaults to an empty value.</p></dd><dt><span class="term"><code class="literal">http-timeout</code></span></dt><dd><p>This specifies the amount of time, in seconds, to
                wait for a server response.  If you experience
                problems with a slow network connection causing
                Subversion operations to timeout, you should increase
                the value of this option.  The default value is
                <code class="literal">0</code>, which instructs the underlying
                HTTP library, Neon, to use its default timeout
                setting.</p></dd><dt><span class="term"><code class="literal">http-compression</code></span></dt><dd><p>This specifies whether or not Subversion should
                attempt to compress network requests made to DAV-ready
                servers.  The default value is <code class="literal">yes</code>
                (though compression will only occur if that capability
                is compiled into the network layer).  Set this to
                <code class="literal">no</code> to disable compression, such as
                when debugging network transmissions.</p></dd><dt><span class="term"><code class="literal">neon-debug-mask</code></span></dt><dd><p>This is an integer mask that the underlying HTTP
                library, Neon, uses for choosing what type of
                debugging output to yield.  The default value is
                <code class="literal">0</code>, which will silence all debugging
                output.  For more information about how Subversion
                makes use of Neon, see <a href="#svn.developer" title="Capitolo&#xA0;8.&#xA0;Developer Information">Capitolo 8, <i>Developer Information</i></a>.</p></dd><dt><span class="term"><code class="literal">ssl-authority-files</code></span></dt><dd><p>This is a semicolon-delimited list of paths to files
                containing certificates of the certificate authorities
                (or CAs) that
                are accepted by the Subversion client when accessing the
                repository over HTTPS.</p></dd><dt><span class="term"><code class="literal">ssl-trust-default-ca</code></span></dt><dd><p>Set this variable to <code class="literal">yes</code> if you
                want Subversion to automatically trust the set of
                default CAs that ship with OpenSSL.</p></dd><dt><span class="term"><code class="literal">ssl-client-cert-file</code></span></dt><dd><p>If a host (or set of hosts) requires an SSL client
                certificate, you'll normally be prompted for a path to
                your certificate.  By setting this variable to that
                same path, Subversion will be able to find your client
                certificate automatically without prompting you.
                There's no standard place to store your certificate on
                disk; Subversion will grab it from any path you
                specify.</p></dd><dt><span class="term"><code class="literal">ssl-client-cert-password</code></span></dt><dd><p>If your SSL client certificate file is encrypted
                by a passphrase, Subversion will prompt you for the
                passphrase whenever the certificate is used.  If you
                find this annoying (and don't mind storing the
                password in the <code class="filename">servers</code> file),
                then you can set this variable to the certificate's
                passphrase.  You won't be prompted anymore.</p></dd></dl></div></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.advanced.confarea.opts.config"></a>Config</h4></div></div></div><p>The <code class="filename">config</code> file contains the rest
          of the currently available Subversion run-time options,
          those not related to networking.  There are only a few
          options in use at this time, but they are again grouped into
          sections in expectation of future additions.</p><p>The <code class="literal">auth</code> section contains settings
          related to Subversion's authentication and authorization
          against the repository.  It contains:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">store-passwords</code></span></dt><dd><p>This instructs Subversion to cache, or not to
                cache, passwords that are supplied by the user in
                response to server authentication challenges.  The
                default value is <code class="literal">yes</code>.  Set this to
                <code class="literal">no</code> to disable this on-disk password
                caching.  You can override this option for a single
                instance of the <span><strong class="command">svn</strong></span> command using
                the <code class="option">--no-auth-cache</code> command-line
                parameter (for those subcommands that support it).
                For more information, see <a href="#svn.serverconfig.netmodel.credcache" title="Client Credentials Caching">la sezione chiamata «Client Credentials Caching»</a>.</p></dd><dt><span class="term"><code class="literal">store-auth-creds</code></span></dt><dd><p>This setting is the same as
                <code class="literal">store-passwords</code>, except that it
                enables or disables disk-caching of
                <span class="emphasis"><em>all</em></span> authentication information:
                usernames, passwords, server certificates, and any
                other types of cacheable credentials.</p></dd></dl></div><p>The <code class="literal">helpers</code> section controls which
          external applications Subversion uses to accomplish its
          tasks.  Valid options in this section are:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">editor-cmd</code></span></dt><dd><p>This specifies the program Subversion will use to
                query the user for a log message during a commit
                operation, such as when using <span><strong class="command">svn
                commit</strong></span> without either the
                <code class="option">--message</code> (<code class="option">-m</code>) or
                <code class="option">--file</code> (<code class="option">-F</code>) options.
                This program is also used with the <span><strong class="command">svn
                propedit</strong></span> command—a temporary file is
                populated with the current value of the property the
                user wishes to edit, and the edits take place right
                in the editor program (see <a href="#svn.advanced.props" title="Properties">la sezione chiamata «Properties»</a>).  This option's default
                value is empty.  The order of priority for determining the
                editor command is:</p><div class="orderedlist"><ol type="1"><li><p>Command-line option <code class="literal">--editor-cmd</code></p></li><li><p>Environment variable <code class="literal">SVN_EDITOR</code></p></li><li><p>Configuration option <code class="literal">editor-cmd</code></p></li><li><p>Environment variable <code class="literal">VISUAL</code></p></li><li><p>Environment variable <code class="literal">EDITOR</code></p></li><li><p>Possibly, a default value built in to Subversion
                    (not present in the official builds)</p></li></ol></div><p>The value of any of these options or variables is
                (unlike <code class="literal">diff-cmd</code>) the beginning of a
                command line to be executed by the shell.  Subversion
                appends a space and the pathname of the temporary file to be
                edited.  The editor should modify the temporary file and
                return a zero exit code to indicate success.</p></dd><dt><span class="term"><code class="literal">diff-cmd</code></span></dt><dd><p>This specifies the absolute path of a differencing
                program, used when Subversion generates
                «<span class="quote">diff</span>» output (such as when using the
                <span><strong class="command">svn diff</strong></span> command).  By default
                Subversion uses an internal differencing
                library—setting this option will cause it to
                perform this task using an external program.  See
                <a href="#svn.advanced.externaldifftools" title="Using External Differencing Tools">la sezione chiamata «Using External Differencing Tools»</a> for
                more details on using such programs.</p></dd><dt><span class="term"><code class="literal">diff3-cmd</code></span></dt><dd><p>This specifies the absolute path of a three-way
                differencing program.  Subversion uses this program to
                merge changes made by the user with those received
                from the repository.  By default Subversion uses an
                internal differencing library—setting this
                option will cause it to perform this task using an
                external program.  See <a href="#svn.advanced.externaldifftools" title="Using External Differencing Tools">la sezione chiamata «Using External Differencing Tools»</a> for more
                details on using such programs.</p></dd><dt><span class="term"><code class="literal">diff3-has-program-arg</code></span></dt><dd><p>This flag should be set to <code class="literal">true</code>
                if the program specified by the
                <code class="literal">diff3-cmd</code> option accepts a
                <code class="option">--diff-program</code> command-line
                parameter.</p></dd></dl></div><p>The <code class="literal">tunnels</code> section allows you to
          define new tunnel schemes for use with
          <span><strong class="command">svnserve</strong></span> and <code class="literal">svn://</code>
          client connections.  For more details, see <a href="#svn.serverconfig.svnserve.sshauth" title="SSH authentication and authorization">la sezione chiamata «SSH authentication and authorization»</a>.</p><p>The <code class="literal">miscellany</code> section is where
          everything that doesn't belong elsewhere winds up.
          <sup>[<a id="id4753304" href="#ftn.id4753304">30</a>]</sup>
          In this section, you can find:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">global-ignores</code></span></dt><dd><p>When running the <span><strong class="command">svn status</strong></span>
                command, Subversion lists unversioned files and
                directories along with the versioned ones, annotating
                them with a <code class="literal">?</code> character (see <a href="#svn.tour.cycle.examine.status" title="svn status">la sezione chiamata «<span><strong class="command">svn status</strong></span>»</a>).  Sometimes, it can
                be annoying to see uninteresting, unversioned
                items—for example, object files that result from
                a program's compilation—in this display.  The
                <code class="literal">global-ignores</code> option is a list of
                whitespace-delimited globs which describe the names of
                files and directories that Subversion should not
                display unless they are versioned.  The default value
                is <code class="literal">*.o *.lo *.la #*# .*.rej *.rej .*~ *~
                .#* .DS_Store</code>.</p><p>As well as <span><strong class="command">svn status</strong></span>, the
                <span><strong class="command">svn add</strong></span> and <span><strong class="command">svn import</strong></span>
                commands also ignore files that match the list
                when they are scanning a directory.  You can override this
                behaviour for a single instance of any of these commands
                by explicitly specifying the file name, or by using
                the <code class="option">--no-ignore</code> command-line flag.</p><p>For information on more fine-grained control of
                ignored items, see <a href="#svn.advanced.props.special.ignore" title="svn:ignore">la sezione chiamata «<code class="literal">svn:ignore</code>»</a>.</p></dd><dt><span class="term"><code class="literal">enable-auto-props</code></span></dt><dd><p>This instructs Subversion to automatically set
                properties on newly added or imported files.  The
                default value is <code class="literal">no</code>, so set this to
                <code class="literal">yes</code> to enable Auto-props.
                The <code class="literal">auto-props</code> section of this file
                specifies which properties are to be set on which files.</p></dd><dt><span class="term"><code class="literal">log-encoding</code></span></dt><dd><p>This variable sets the default character set
                encoding for commit log messages.  It's a permanent
                form of the <code class="option">--encoding</code> option (see
                <a href="#svn.ref.svn.sw" title="svn Switches">la sezione chiamata «<span><strong class="command">svn</strong></span> Switches»</a>).  The Subversion
                repository stores log messages in UTF-8, and assumes
                that your log message is written using your operating
                system's native locale.  You should specify a
                different encoding if your commit messages are written
                in any other encoding.</p></dd><dt><span class="term"><code class="literal">use-commit-times</code></span></dt><dd><p>Normally your working copy files have timestamps
                that reflect the last time they were touched by any
                process, whether that be your own editor or by some
                <span><strong class="command">svn</strong></span> subcommand.  This is generally
                convenient for people developing software, because
                build systems often look at timestamps as a way of
                deciding which files need to be recompiled.</p><p>In other situations, however, it's sometimes nice
                for the working copy files to have timestamps that
                reflect the last time they were changed in the
                repository.  The <span><strong class="command">svn export</strong></span> command
                always places these «<span class="quote">last-commit
                timestamps</span>» on trees that it produces.  By
                setting this config variable to
                <code class="literal">yes</code>, the <span><strong class="command">svn
                checkout</strong></span>, <span><strong class="command">svn update</strong></span>,
                <span><strong class="command">svn switch</strong></span>, and <span><strong class="command">svn
                revert</strong></span> commands will also set last-commit
                timestamps on files that they touch.</p></dd></dl></div><p>The <code class="literal">auto-props</code> section controls
          the Subversion client's ability to automatically set
          properties on files when they are added or imported.
          It contains any number of key-value pairs in the
          format <code class="literal">PATTERN = PROPNAME=PROPVALUE</code>
          where <code class="literal">PATTERN</code> is a file pattern
          that matches a set of filenames and the rest of the
          line is the property and its value.  Multiple matches
          on a file will result in multiple propsets for that
          file; however, there is no guarantee that auto-props
          will be applied in the order in which they are listed
          in the config file, so you can't have one rule
          «<span class="quote">override</span>» another.  You can find several
          examples of auto-props usage in the
          <code class="filename">config</code> file.  Lastly, don't
          forget to set <code class="literal">enable-auto-props</code> to
          <code class="literal">yes</code> in the <code class="literal">miscellany</code>
          section if you want to enable auto-props.</p></div></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.advanced.props"></a>Properties</h2></div></div></div><p>We've already covered in detail how Subversion stores and
      retrieves various versions of files and directories in its
      repository.  Whole chapters have been devoted to this most
      fundamental piece of functionality provided by the tool.  And
      if the versioning support stopped there, Subversion would still
      be complete from a version control perspective.  But it
      doesn't stop there.</p><p>In addition to versioning your directories and files,
      Subversion provides interfaces for adding, modifying, and
      removing versioned metadata on each of your versioned
      directories and files.  We refer to this metadata as
      <em class="firstterm">properties</em>, and they can be thought of as
      two-column tables that map property names to arbitrary values
      attached to each item in your working copy.  Generally speaking,
      the names and values of the properties can be whatever you want
      them to be, with the constraint that the names must be
      human-readable text.  And the best part about these properties
      is that they, too, are versioned, just like the textual contents
      of your files.  You can modify, commit, and revert property
      changes as easily as committing textual changes.  And you
      receive other people's property changes as you update your
      working copy.</p><div class="sidebar"><p class="title"><b>Other Properties in Subversion</b></p><p>Properties show up elsewhere in Subversion, too.  Just as
        files and directories may have arbitrary property names and
        values attached to them, each revision as a whole may have
        arbitrary properties attached to it.  The same constraints
        apply—human-readable, text names and anything-you-want,
        binary values—except that revision properties are not
        versioned.  See <a href="#svn.reposadmin.basics.revprops" title="Unversioned Properties">la sezione chiamata «Unversioned Properties»</a> for more
        information on these unversioned properties.</p></div><p>In this section, we will examine the utility—both to
      users of Subversion, and to Subversion itself—of property
      support.  You'll learn about the property-related
      <span><strong class="command">svn</strong></span> subcommands, and how property
      modifications affect your normal Subversion workflow.
      Hopefully, you'll be convinced that Subversion properties can
      enhance your version control experience.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.props.why"></a>Why Properties?</h3></div></div></div><p>Properties can be very useful additions to your working
        copy.  In fact, Subversion itself uses properties to house
        special information, and as a way to denote that certain
        special processing might be needed.  Likewise, you can use
        properties for your own purposes.  Of course, anything you can
        do with properties you could also do using regular versioned
        files, but consider the following example of Subversion
        property use.</p><p>Say you wish to design a website that houses many digital
        photos, and displays them with captions and a datestamp.  Now,
        your set of photos is constantly changing, so you'd like to
        have as much of this site automated as possible.  These photos
        can be quite large, so as is common with sites of this nature,
        you want to provide smaller thumbnail images to your site
        visitors.  You can do this with traditional files.  That is,
        you can have your <code class="filename">image123.jpg</code> and an
        <code class="filename">image123-thumbnail.jpg</code> side-by-side in a
        directory.  Or if you want to keep the filenames the same, you
        might have your thumbnails in a different directory, like
        <code class="filename">thumbnails/image123.jpg</code>.  You can also
        store your captions and datestamps in a similar fashion, again
        separated from the original image file.  Soon, your tree of
        files is a mess, and grows in multiples with each new photo
        added to the site.</p><p>Now consider the same setup using Subversion's file
        properties.  Imagine having a single image file,
        <code class="filename">image123.jpg</code>, and then properties set on
        that file named <code class="literal">caption</code>,
        <code class="literal">datestamp</code>, and even
        <code class="literal">thumbnail</code>.  Now your working copy directory
        looks much more manageable—in fact, it looks like there
        are nothing but image files in it.  But your automation
        scripts know better.  They know that they can use
        <span><strong class="command">svn</strong></span> (or better yet, they can use the
        Subversion language bindings—see <a href="#svn.developer.usingapi.otherlangs" title="Using Languages Other than C and C++">la sezione chiamata «Using Languages Other than C and C++»</a>) to dig out the extra
        information that your site needs to display without having to
        read an index file or play path manipulation games.</p><p>How (and if) you use Subversion properties is up to you.
        As we mentioned, Subversion has it own uses for properties,
        which we'll discuss a little later in this chapter.  But
        first, let's discuss how to manipulate properties using the
        <span><strong class="command">svn</strong></span> program.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.props.manip"></a>Manipulating Properties</h3></div></div></div><p>The <span><strong class="command">svn</strong></span> command affords a few ways to
        add or modify file and directory properties.  For properties
        with short, human-readable values, perhaps the simplest way to
        add a new property is to specify the property name and value
        on the command-line of the <span><strong class="command">propset</strong></span>
        subcommand.</p><pre class="screen">
$ svn propset copyright '(c) 2003 Red-Bean Software' calc/button.c
property 'copyright' set on 'calc/button.c'
$
</pre><p>But we've been touting the flexibility that Subversion
        offers for your property values.  And if you are planning to
        have a multi-line textual, or even binary, property value, you
        probably do not want to supply that value on the command-line.
        So the <span><strong class="command">propset</strong></span> subcommand takes a
        <code class="option">--file</code> (<code class="option">-F</code>) option for
        specifying the name of
        a file which contains the new property value.</p><pre class="screen">
$ svn propset license -F /path/to/LICENSE calc/button.c
property 'license' set on 'calc/button.c'
$
</pre><p>There are some restrictions on the names you can use for
        properties.  A property name must start with a letter, a colon
        (<code class="literal">:</code>), or an underscore
        (<code class="literal">_</code>); after that, you can also use digits,
        hyphens (<code class="literal">-</code>), and periods
        (<code class="literal">.</code>).
          <sup>[<a id="id4753964" href="#ftn.id4753964">31</a>]</sup>
      </p><p>In addition to the <span><strong class="command">propset</strong></span> command, the
        <span><strong class="command">svn</strong></span> program supplies the
        <span><strong class="command">propedit</strong></span> command.  This command uses the
        configured editor program (see <a href="#svn.advanced.confarea.opts.config" title="Config">la sezione chiamata «Config»</a>) to add or modify properties.
        When you run the command, <span><strong class="command">svn</strong></span> invokes your
        editor program on a temporary file that contains the current
        value of the property (or which is empty, if you are adding a
        new property).  Then, you just modify that value in your
        editor program until it represents the new value you wish to
        store for the property, save the temporary file, and then exit
        the editor program.  If Subversion detects that you've
        actually changed the existing value of the property, it will
        accept that as the new property value.  If you exit your
        editor without making any changes, no property modification
        will occur.</p><pre class="screen">
$ svn propedit copyright calc/button.c  ### exit the editor without changes
No changes to property 'copyright' on 'calc/button.c'
$
</pre><p>We should note that, as with other <span><strong class="command">svn</strong></span>
        subcommands, those related to properties can act on multiple
        paths at once.  This enables you to modify properties on whole
        sets of files with a single command.  For example, we could
        have done:</p><pre class="screen">
$ svn propset copyright '(c) 2002 Red-Bean Software' calc/*
property 'copyright' set on 'calc/Makefile'
property 'copyright' set on 'calc/button.c'
property 'copyright' set on 'calc/integer.c'
…
$
</pre><p>All of this property adding and editing isn't really very
        useful if you can't easily get the stored property value.  So
        the <span><strong class="command">svn</strong></span> program supplies two subcommands
        for displaying the names and values of properties stored on
        files and directories.  The <span><strong class="command">svn proplist</strong></span>
        command will list the names of properties that exist on a
        path.  Once you know the names of the properties on the node,
        you can request their values individually using <span><strong class="command">svn
        propget</strong></span>.  This command will, given a path (or set of
        paths) and a property name, print the value of the property to
        the standard output stream.</p><pre class="screen">
$ svn proplist calc/button.c
Properties on 'calc/button.c':
  copyright
  license
$ svn propget copyright calc/button.c
(c) 2003 Red-Bean Software
</pre><p>There's even a variation of the
        <span><strong class="command">proplist</strong></span> command that will list both the
        name and value of all of the properties.  Simply supply the
        <code class="option">--verbose</code> (<code class="option">-v</code>) option.</p><pre class="screen">
$ svn proplist --verbose calc/button.c
Properties on 'calc/button.c':
  copyright : (c) 2003 Red-Bean Software
  license : ================================================================
Copyright (c) 2003 Red-Bean Software.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions 
are met:

1. Redistributions of source code must retain the above copyright
notice, this list of conditions, and the recipe for Fitz's famous
red-beans-and-rice.
…
</pre><p>The last property-related subcommand is
        <span><strong class="command">propdel</strong></span>.  Since Subversion allows you to
        store properties with empty values, you can't remove a
        property altogether using <span><strong class="command">propedit</strong></span> or
        <span><strong class="command">propset</strong></span>.  For example, this command will
        <span class="emphasis"><em>not</em></span> yield the desired effect:</p><pre class="screen">
$ svn propset license '' calc/button.c
property 'license' set on 'calc/button.c'
$ svn proplist --verbose calc/button.c
Properties on 'calc/button.c':
  copyright : (c) 2003 Red-Bean Software
  license : 
$
</pre><p>You need to use the <span><strong class="command">propdel</strong></span> command to
        delete properties altogether.  The syntax is similar to the
        other property commands:</p><pre class="screen">
$ svn propdel license calc/button.c
property 'license' deleted from 'calc/button.c'.
$ svn proplist --verbose calc/button.c
Properties on 'calc/button.c':
  copyright : (c) 2003 Red-Bean Software
$
</pre><p>Now that you are familiar with all of the
        property-related <span><strong class="command">svn</strong></span> subcommands, let's see
        how property modifications affect the usual Subversion
        workflow.  As we mentioned earlier, file and directory
        properties are versioned, just like your file contents.  As a
        result, Subversion provides the same opportunities for
        merging—in cleanly or conflicting fashions—someone
        else's modifications into your own.</p><div class="sidebar"><p class="title"><b>Modifying Revision Properties</b></p><p>Remember those unversioned revision properties?  You can
          modify those, too, with the <span><strong class="command">svn</strong></span> program.
          Simply add the <code class="option">--revprop</code> command-line
          parameter, and specify the revision whose property you wish
          to modify.  Since revisions are global, you don't need to
          specify a path in this case as long as you are positioned in
          the working copy of the repository whose revision property
          you wish to modify.  For example, you might want to replace
          the commit log message of an existing revision.
          <sup>[<a id="id4754228" href="#ftn.id4754228">32</a>]</sup></p><pre class="screen">
$ svn propset svn:log '* button.c: Fix a compiler warning.' -r11 --revprop
property 'svn:log' set on repository revision '11'
$
</pre><p>Note that the ability to modify these unversioned
          properties must be explicitly added by the repository
          administrator (see <a href="#svn.reposadmin.create.hooks" title="Hook Scripts">la sezione chiamata «Hook Scripts»</a>).
          Since the properties aren't versioned, you run the risk of
          losing information if you aren't careful with your edits.
          The repository administrator can setup methods to protect
          against this loss, and by default, modification of
          unversioned properties is disabled.</p></div><p>And as with file contents, your property changes are local
        modifications, only made permanent when you commit them to the
        repository with <span><strong class="command">svn commit</strong></span>.  Your property
        changes can be easily unmade, too—the <span><strong class="command">svn
        revert</strong></span> command will restore your files and
        directories to their un-edited states, contents, properties,
        and all.  Also, you can receive interesting information about
        the state of your file and directory properties by using the
        <span><strong class="command">svn status</strong></span> and <span><strong class="command">svn diff</strong></span>
        commands.</p><pre class="screen">
$ svn status calc/button.c
 M     calc/button.c
$ svn diff calc/button.c
Property changes on: calc/button.c
___________________________________________________________________
Name: copyright
   + (c) 2003 Red-Bean Software

$
</pre><p>Notice how the <span><strong class="command">status</strong></span> subcommand
        displays <code class="literal">M</code> in the second column instead of
        the first.  That is because we have modified the properties on
        <code class="filename">calc/button.c</code>, but not modified its
        textual contents.  Had we changed both, we would have seen
        <code class="literal">M</code> in the first column, too (see <a href="#svn.tour.cycle.examine.status" title="svn status">la sezione chiamata «<span><strong class="command">svn status</strong></span>»</a>).</p><div class="sidebar"><p class="title"><b>Property Conflicts</b></p><p>As with file contents, local property modifications can
          conflict with changes committed by someone else.  If you
          update your working copy directory and receive property
          changes on a versioned resource that clash with your own,
          Subversion will report that the resource is in a conflicted
          state.</p><pre class="screen">
% svn update calc
M  calc/Makefile.in
 C calc/button.c
Updated to revision 143.
$ 
</pre><p>Subversion will also create, in the same directory as
          the conflicted resource, a file with a
          <code class="filename">.prej</code> extension which contains the
          details of the conflict.  You should examine the contents of
          this file so you can decide how to resolve the conflict.
          Until the conflict is resolved, you will see a
          <code class="literal">C</code> in the second column of <span><strong class="command">svn
          status</strong></span> output for that resource, and attempts to
          commit your local modifications will fail.</p><pre class="screen">
$ svn status calc
 C     calc/button.c
?      calc/button.c.prej
$ cat calc/button.c.prej 
prop 'linecount': user set to '1256', but update set to '1301'.
$
</pre><p>To resolve property conflicts, simply ensure that the
          conflicting properties contain the values that they should,
          and then use the <span><strong class="command">svn resolved</strong></span> command to
          alert Subversion that you have manually resolved the
          problem.</p></div><p>You might also have noticed the non-standard way that
        Subversion currently displays property differences.  You can
        still run <span><strong class="command">svn diff</strong></span> and redirect the output
        to create a usable patch file.  The <span><strong class="command">patch</strong></span>
        program will ignore property patches—as a rule, it
        ignores any noise it can't understand.  This does
        unfortunately mean that to fully apply a patch generated by
        <span><strong class="command">svn diff</strong></span>, any property modifications will
        need to be applied by hand.</p><p>As you can see, the presence of property modifications has
        no outstanding effect on the typical Subversion workflow.
        Your general patterns of updating your working copy, checking
        the status of your files and directories, reporting on the
        modifications you have made, and committing those
        modifications to the repository are completely immune to the
        presence or absence of properties.  The <span><strong class="command">svn</strong></span>
        program has some additional subcommands for actually making
        property changes, but that is the only noticeable asymmetry.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.props.special"></a>Special Properties</h3></div></div></div><p>Subversion has no particular policy regarding
        properties—you can use them for any purpose.  Subversion
        asks only that you not use property names that begin with the
        prefix <code class="literal">svn:</code>.  That's the namespace that it
        sets aside for its own use.  In fact, Subversion defines
        certain properties that have magical effects on the files and
        directories to which they are attached.  In this section,
        we'll untangle the mystery, and describe how these special
        properties make your life just a little easier.</p><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.advanced.props.special.executable"></a><code class="literal">svn:executable</code></h4></div></div></div><p>The <code class="literal">svn:executable</code> property is used
          to control a versioned file's filesystem-level execute
          permission bit in a semi-automated way.  This property has
          no defined values—its mere presence indicates a desire
          that the execute permission bit be kept enabled by Subversion.
          Removing this property will restore full control of the
          execute bit back to the operating system.</p><p>On many operating systems, the ability to execute a file
          as a command is governed by the presence of an execute
          permission bit.  This bit usually defaults to being
          disabled, and must be explicitly enabled by the user for
          each file that needs it.  In a working copy, new files are
          being created all the time as new versions of existing files
          are received during an update.  This means that you might
          enable the execute bit on a file, then update your working
          copy, and if that file was changed as part of the update,
          its execute bit might get disabled.  So, Subversion provides
          the <code class="literal">svn:executable</code> property as a way to
          keep the execute bit enabled.</p><p>This property has no effect on filesystems that have no
          concept of an executable permission bit, such as FAT32 and
          NTFS.
          <sup>[<a id="id4754574" href="#ftn.id4754574">33</a>]</sup>
          Also, although it has no defined values, Subversion will force
          its value to <code class="literal">*</code> when setting this property.
          Finally, this property is valid only on files, not on
          directories.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.advanced.props.special.mime-type"></a><code class="literal">svn:mime-type</code></h4></div></div></div><p>The <code class="literal">svn:mime-type</code> property serves
          many purposes in Subversion.  Besides being a
          general-purpose storage location for a file's Multipurpose
          Internet Mail Extensions (MIME) classification, the value of
          this property determines some behavioral characteristics
          of Subversion itself.</p><p>For example, if a file's
          <code class="literal">svn:mime-type</code> property is set to a
          non-text MIME type (generally, something that doesn't begin
          with <code class="literal">text/</code>, though there are exceptions),
          Subversion will assume that the file contains
          binary—that is, not human-readable—data.  One of
          the benefits that Subversion typically provides is
          contextual, line-based merging of changes received from the
          server during an update into your working file.  But for
          files believed to contain binary data, there is no concept
          of a «<span class="quote">line</span>».  So, for those files, Subversion
          does not attempt to perform contextual merges during
          updates.  Instead, any time you have locally modified a
          binary working copy file that is also being updated, your
          file is renamed with a <code class="filename">.orig</code> extension,
          and then Subversion stores a new working copy file that
          contains the changes received during the update, but not
          your own local modifications, at the original filename.
          This behavior is really for the protection of the user
          against failed attempts at performing contextual merges on
          files that simply cannot be contextually merged.</p><p>Also, if the <code class="literal">svn:mime-type</code>
          property is set, then the Subversion Apache module will use
          its value to populate the <code class="literal">Content-type:</code>
          HTTP header when responding to GET requests.  This gives a
          crucial clue about how to display a file when perusing
          your repository with a web browser.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.advanced.props.special.ignore"></a><code class="literal">svn:ignore</code></h4></div></div></div><p>The <code class="literal">svn:ignore</code> property contains a
          list of file patterns which certain Subversion operations
          will ignore.  Perhaps the most commonly used special
          property, it works in conjunction with the
          <code class="literal">global-ignores</code> run-time configuration
          option (see <a href="#svn.advanced.confarea.opts.config" title="Config">la sezione chiamata «Config»</a>) to
          filter unversioned files and directories out of commands
          <span><strong class="command">svn status</strong></span>, <span><strong class="command">svn
          add</strong></span>, and <span><strong class="command">svn import</strong></span>.</p><p>The rationale behind the <code class="literal">svn:ignore</code>
          property is easily explained.  Subversion does not assume
          that every file or subdirectory in a working copy directory
          is intended for version control.  Resources must be
          explicitly placed under Subversion's management using the
          <span><strong class="command">svn add</strong></span> or <span><strong class="command">svn import</strong></span>
          commands.  As a result, there are often many resources in a
          working copy that are not versioned.</p><p>Now, the <span><strong class="command">svn status</strong></span> command displays
          as part of its output every unversioned file or subdirectory
          in a working copy that is not already filtered out by the
          <code class="literal">global-ignores</code> option (or its built-in
          default value).  This is done so that users can see if
          perhaps they've forgotten to add a resource to version
          control.</p><p>But Subversion cannot possibly guess the names of
          every resource that should be ignored.  Also, quite often
          there are things that should be ignored in
          <span class="emphasis"><em>every</em></span> working copy of a particular
          repository.  To force every user of that repository to add
          patterns for those resources to their run-time configuration
          areas would be not just a burden, but has the potential to
          clash with the configuration needs of other working copies
          that the user has checked out.</p><p>The solution is to store ignore patterns that are unique
          to the resources likely to appear in a given directory with
          the directory itself.  Common examples of unversioned
          resources that are basically unique to a directory, yet
          likely to appear there, include output from program
          compilations.  Or—to use an example more appropriate
          to this book—the HTML, PDF, or PostScript files
          generated as the result of a conversion of some source
          DocBook XML files to a more legible output format.</p><div class="sidebar"><p class="title"><b>Ignore Patterns for CVS Users</b></p><p>The Subversion <code class="literal">svn:ignore</code> property
            is very similar in syntax and function to the CVS
            <code class="filename">.cvsignore</code> file.  In fact, if you are
            migrating a CVS working copy to Subversion, you can
            directly migrate the ignore patterns by using the
            <code class="filename">.cvsignore</code> file as input file to the
            <span><strong class="command">svn propset</strong></span> command:</p><pre class="screen">
$ svn propset svn:ignore -F .cvsignore .
property 'svn:ignore' set on '.'
$
</pre><p>There are, however, some differences in the ways that
            CVS and Subversion handle ignore patterns.  The two systems
            use the ignore patterns at some different times, and there
            are slight discrepancies in what the ignore patterns apply
            to.  Also, Subversion does not recognize the use of the
            <code class="literal">!</code> pattern as a reset back to having no
            ignore patterns at all.</p></div><p>For this purpose, the <code class="literal">svn:ignore</code>
          property is the solution.  Its value is a multi-line
          collection of file patterns, one pattern per line.  The
          property is set on the directory in which you wish the
          patterns to be applied.
          <sup>[<a id="id4754926" href="#ftn.id4754926">34</a>]</sup>
          For example, say you have the following output from
          <span><strong class="command">svn status</strong></span>:</p><pre class="screen">
$ svn status calc
 M     calc/button.c
?      calc/calculator
?      calc/data.c
?      calc/debug_log
?      calc/debug_log.1
?      calc/debug_log.2.gz
?      calc/debug_log.3.gz
</pre><p>In this example, you have made some property
          modifications to <code class="filename">button.c</code>, but in your
          working copy you also have some unversioned files:
          the latest <code class="filename">calculator</code> program
          that you've compiled from your source code, a source file
          named <code class="filename">data.c</code>, and a set of debugging
          output log files.  Now, you know that your build system
          always results in the <code class="filename">calculator</code>
          program being generated.
          <sup>[<a id="id4754984" href="#ftn.id4754984">35</a>]</sup>
          And you know that your test suite always leaves those
          debugging log files lying around.  These facts are true for
          all working copies, not just your own.  And you know that
          you aren't interested in seeing those things every time you
          run <span><strong class="command">svn status</strong></span>.  So you use <span><strong class="command">svn
          propedit svn:ignore calc</strong></span> to add some ignore
          patterns to the <code class="filename">calc</code> directory.  For
          example, you might add this as the new value of the
          <code class="literal">svn:ignore</code> property:</p><pre class="programlisting">
calculator
debug_log*
</pre><p>After you've added this property, you will now have a
          local property modification on the <code class="filename">calc</code>
          directory.  But notice what else is different about your
          <span><strong class="command">svn status</strong></span> output:</p><pre class="screen">
$ svn status
 M     calc
 M     calc/button.c
?      calc/data.c
</pre><p>Now, all the cruft is missing from the output!  Of
          course, those files are still in your working copy.
          Subversion is simply not reminding you that they are present
          and unversioned.  And now with all the trivial noise removed
          from the display, you are left with more interesting
          items—such as that source code file that you probably
          forgot to add to version control.</p><p>If you want to see the ignored files, you can pass the 
          <code class="option">--no-ignore</code> option to Subversion:</p><pre class="screen">
$ svn status --no-ignore
 M     calc/button.c
I      calc/calculator
?      calc/data.c
I      calc/debug_log
I      calc/debug_log.1
I      calc/debug_log.2.gz
I      calc/debug_log.3.gz
</pre><p>The list of patterns to ignore is also used by
          <span><strong class="command">svn add</strong></span> and <span><strong class="command">svn
          import</strong></span>.  Both of these operations involve asking
          Subversion to begin managing some set of files and
          directories.  Rather than force the user to pick and choose
          which files in a tree she wishes to start versioning,
          Subversion uses the ignore patterns to determine which files
          should not be swept into the version control system as part
          of a larger recursive addition or import operation.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.advanced.props.special.keywords"></a><code class="literal">svn:keywords</code></h4></div></div></div><p>Subversion has the ability to substitute
          <em class="firstterm">keywords</em>—pieces of useful,
          dynamic information about a versioned file—into the
          contents of the file itself.  Keywords generally describe
          information about the last time the file was known to be
          modified.  Because this information changes each time the
          file changes, and more importantly, just
          <span class="emphasis"><em>after</em></span> the file changes, it is a hassle
          for any process except the version control system to keep
          the data completely up-to-date.  Left to human authors, the
          information would inevitably grow stale.</p><p>For example, say you have a document in which you would
          like to display the last date on which it was modified.  You
          could burden every author of that document to, just before
          committing their changes, also tweak the part of the
          document that describes when it was last changed.  But
          sooner or later, someone would forget to do that.  Instead
          simply ask Subversion to perform keyword substitution on the
          <code class="literal">LastChangedDate</code> keyword.  You control
          where the keyword is inserted into your document by placing
          a <em class="firstterm">keyword anchor</em> at the desired
          location in the file.  This anchor is just a string of text
          formatted as
          <code class="literal">$</code><em class="replaceable"><code>KeywordName</code></em><code class="literal">$</code>.</p><p>All keywords are case-sensitive where they appear as
          anchors in files: you must use the correct capitalization in
          order for the keyword to be expanded.  You should consider the
          value of the <code class="literal">svn:keywords</code> property to be
          case-sensitive too—certain keyword names will be recognized
          regardless of case, but this behavior is deprecated.</p><p>Subversion defines the list of keywords available for
          substitution.  That list contains the following five keywords, 
          some of which have aliases that you can also use:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">Date</code></span></dt><dd><p>This keyword describes the last time the file was
                known to have been changed in the repository, and
                looks something like <code class="literal">$Date:
                2002-07-22 21:42:37 -0700 (Mon, 22 Jul 2002)
                $</code>.  It may also be specified as
                <code class="literal">LastChangedDate</code>.</p></dd><dt><span class="term"><code class="literal">Revision</code></span></dt><dd><p>This keyword describes the last known revision in
                which this file changed in the repository, and looks
                something like <code class="literal">$Revision: 144 $</code>.  
                It may also be specified as
                <code class="literal">LastChangedRevision</code> or
                <code class="literal">Rev</code>.</p></dd><dt><span class="term"><code class="literal">Author</code></span></dt><dd><p>This keyword describes the last known user to
                change this file in the repository, and looks
                something like <code class="literal">$Author: harry $</code>.  
                It may also be specified as 
                <code class="literal">LastChangedBy</code>.</p></dd><dt><span class="term"><code class="literal">HeadURL</code></span></dt><dd><p>This keyword describes the full URL to the latest
                version of the file in the repository, and looks
                something like <code class="literal">$HeadURL:
                http://svn.collab.net/repos/trunk/README $</code>.
                It may be abbreviated as
                <code class="literal">URL</code>.</p></dd><dt><span class="term"><code class="literal">Id</code></span></dt><dd><p>This keyword is a compressed combination of the
                other keywords.  Its substitution looks something like
                <code class="literal">$Id: calc.c 148 2002-07-28 21:30:43Z sally
                $</code>, and is interpreted to mean that the file
                <code class="filename">calc.c</code> was last changed in revision
                148 on the evening of July 28, 2002 by the user
                <code class="literal">sally</code>.</p></dd></dl></div><p>Simply adding keyword anchor text to your file does
          nothing special.  Subversion will never attempt to perform
          textual substitutions on your file contents unless
          explicitly asked to do so.  After all, you might be writing
          a document
          <sup>[<a id="id4755393" href="#ftn.id4755393">36</a>]</sup> 
          about how to use keywords, and you don't want Subversion to
          substitute your beautiful examples of un-substituted keyword
          anchors!</p><p>To tell Subversion whether or not to substitute keywords
          on a particular file, we again turn to the property-related
          subcommands.  The <code class="literal">svn:keywords</code> property,
          when set on a versioned file, controls which keywords will
          be substituted on that file.  The value is a space-delimited
          list of the keyword names or aliases found in the previous
          table.</p><p>For example, say you have a versioned file named
          <code class="filename">weather.txt</code> that looks like
          this:</p><pre class="programlisting">
Here is the latest report from the front lines.
$LastChangedDate$
$Rev$
Cumulus clouds are appearing more frequently as summer approaches.
</pre><p>With no <code class="literal">svn:keywords</code> property set on
          that file, Subversion will do nothing special.  Now, let's
          enable substitution of the
          <code class="literal">LastChangedDate</code> keyword.</p><pre class="screen">
$ svn propset svn:keywords "Date Author" weather.txt
property 'svn:keywords' set on 'weather.txt'
$
</pre><p>Now you have made a local property modification on the
          <code class="filename">weather.txt</code> file.  You will see no
          changes to the file's contents (unless you made some of your
          own prior to setting the property).  Notice that the file
          contained a keyword anchor for the <code class="literal">Rev</code>
          keyword, yet we did not include that keyword in the property
          value we set.  Subversion will happily ignore requests to
          substitute keywords that are not present in the file, and
          will not substitute keywords that are not present in the
          <code class="literal">svn:keywords</code> property value.</p><div class="sidebar"><p class="title"><b>Keywords and Spurious Differences</b></p><p>The user-visible result of keyword substitution might
            lead you to think that every version of a file with that
            feature in use differs from the previous version in at
            least the area where the keyword anchor was placed.
            However, this is actually not the case.  While checking
            for local modifications during <span><strong class="command">svn
            diff</strong></span>, and before transmitting those local
            modifications during <span><strong class="command">svn commit</strong></span>,
            Subversion «<span class="quote">un-substitutes</span>» any keywords that
            it previously substituted.  The result is that the
            versions of the file that are stored in the repository
            contain only the real modifications that users make to the
            file.</p></div><p>Immediately after you commit this property change,
          Subversion will update your working file with the new
          substitute text.  Instead of seeing your keyword anchor
          <code class="literal">$LastChangedDate$</code>, you'll see its
          substituted result.  That result also contains the name of
          the keyword, and continues to be bounded by the dollar sign
          (<code class="literal">$</code>) characters.  And as we predicted, the
          <code class="literal">Rev</code> keyword was not substituted because
          we didn't ask for it to be.</p><p>Note also that we set the <code class="literal">svn:keywords</code>
          property to «<span class="quote">Date Author</span>» yet the keyword
          anchor used the alias <code class="literal">$LastChangedDate$</code>
          and still expanded correctly.</p><pre class="screen">
Here is the latest report from the front lines.
$LastChangedDate: 2002-07-22 21:42:37 -0700 (Mon, 22 Jul 2002) $
$Rev$
Cumulus clouds are appearing more frequently as summer approaches.
</pre><p>If someone else now commits a change to
          <code class="filename">weather.txt</code>, your copy of that file
          will continue to display the same substituted keyword value
          as before—until you update your working copy.  At that
          time the keywords in your <code class="filename">weather.txt</code>
          file will be re-substituted with information that
          reflects the most recent known commit to that file.</p><p>Subversion 1.2 introduced a new variant of the keyword
          syntax which brought additional, useful—though perhaps
          atypical—functionality.  You can now tell Subversion
          to maintain a fixed length (in terms of the number of bytes
          consumed) for the substituted keyword.  By using a
          double-colon (<code class="literal">::</code>) after the keyword name,
          followed by a number of space characters, you define that
          fixed width.  When Subversion goes to substitute your
          keyword for the keyword and its value, it will essentially
          replace only those space characters, leaving the overall
          width of the keyword field unchanged.  If the substituted
          value is shorter than the defined field width, there will be
          extra padding characters (spaces) at the end of the
          substituted field; if it is too long, it is truncated with a
          special hash (<code class="literal">#</code>) character just before
          the final dollar sign terminator.</p><p>For example, say you have a document in which you have
          some section of tabular data reflecting the document's
          Subversion keywords.  Using the original Subversion keyword
          substitution syntax, your file might look something
          like:</p><pre class="screen">
$Rev$:     Revision of last commit
$Author$:  Author of last commit
$Date$:    Date of last commit
</pre><p>Now, that looks nice and tabular at the start of things.
          But when you then commit that file (with keyword substitution
          enabled, of course), you see:</p><pre class="screen">
$Rev: 12 $:     Revision of last commit
$Author: harry $:  Author of last commit
$Date: 2006-03-15 02:33:03 -0500 (Wed, 15 Mar 2006) $:    Date of last commit
</pre><p>The result is not so beautiful.  And you might be
          tempted to then adjust the file after the substitution so
          that it again looks tabular.  But that only holds as long as
          the keyword values are the same width.  If the last
          committed revision rolls into a new place value (say, from
          99 to 100), or if another person with a longer username
          commits the file, stuff gets all crooked again.  However, if
          you are using Subversion 1.2 or better, you can use the new
          fixed-length keyword syntax, define some field widths that
          seem sane, and now your file might look like this:</p><pre class="screen">
$Rev::               $:  Revision of last commit
$Author::            $:  Author of last commit
$Date::              $:  Date of last commit
</pre><p>You commit this change to your file.  This time,
          Subversion notices the new fixed-length keyword syntax, and
          maintains the width of the fields as defined by the padding
          you placed between the double-colon and the trailing dollar
          sign.  After substitution, the width of the fields is
          completely unchanged—the short values for
          <code class="literal">Rev</code> and <code class="literal">Author</code> are
          padded with spaces, and the long <code class="literal">Date</code>
          field is truncated by a hash character:</p><pre class="screen">
$Rev:: 13            $:  Revision of last commit
$Author:: harry      $:  Author of last commit
$Date:: 2006-03-15 0#$:  Date of last commit
</pre><p>The use of fixed-length keywords is especially handy
          when performing substitutions into complex file formats that
          themselves use fixed-length fields for data, or for which
          the stored size of a given data field is overbearingly
          difficult to modify from outside the format's native
          application (such as for Microsoft Office documents).</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Avvertimento</h3><p>Be aware that because the width of a keyword field is
            measured in bytes, the potential for corruption of
            multi-byte values exists.  For example, a username which
            contains some multi-byte UTF-8 characters might suffer
            truncation in the middle of the string of bytes which make
            up one of those characters.  The result will be a mere
            truncation when viewed at the byte level, but will likely
            appear as a string with an incorrect or garbled final
            character when viewed as UTF-8 text.  It is conceivable
            that certain applications, when asked to load the file,
            would notice the broken UTF-8 text and deem the entire
            file corrupt, refusing to operate on the file
            altogether.</p></div></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.advanced.props.special.eol-style"></a><code class="literal">svn:eol-style</code></h4></div></div></div><p>Unless otherwise noted using a versioned file's
          <code class="literal">svn:mime-type</code> property, Subversion
          assumes the file contains human-readable data.  Generally
          speaking, Subversion only uses this knowledge to determine
          if contextual difference reports for that file are
          possible.  Otherwise, to Subversion, bytes are bytes.</p><p>This means that by default, Subversion doesn't pay any
          attention to the type of <em class="firstterm">end-of-line (EOL)
          markers</em> used in your files.  Unfortunately,
          different operating systems use different tokens to represent
          the end of a line of text in a file.  For example, the usual
          line ending token used by software on the Windows platform
          is a pair of ASCII control characters—carriage return
          (<code class="literal">CR</code>) and line feed
          (<code class="literal">LF</code>).  Unix software, however, just uses
          the <code class="literal">LF</code> character to denote the end of a
          line.</p><p>Not all of the various tools on these operating systems
          are prepared to understand files that contain line endings
          in a format that differs from the <em class="firstterm">native line
          ending style</em> of the operating system on which
          they are running.  Common results are that Unix programs
          treat the <code class="literal">CR</code> character present in Windows
          files as a regular character (usually rendered as
          <code class="literal">^M</code>), and that Windows programs combine
          all of the lines of a Unix file into one giant line because
          no carriage return-linefeed (or <code class="literal">CRLF</code>)
          character combination was found to denote the end of
          line.</p><p>This sensitivity to foreign EOL markers can become
          frustrating for folks who share a file across different
          operating systems.  For example, consider a source code
          file, and developers that edit this file on both Windows and
          Unix systems.  If all the developers always use tools which
          preserve the line ending style of the file, no problems
          occur.</p><p>But in practice, many common tools either fail to
          properly read a file with foreign EOL markers, or they
          convert the file's line endings to the native style when the
          file is saved.  If the former is true for a developer, he
          has to use an external conversion utility (such as
          <span><strong class="command">dos2unix</strong></span> or its companion,
          <span><strong class="command">unix2dos</strong></span>) to prepare the file for
          editing.  The latter case requires no extra preparation.
          But both cases result in a file that differs from the
          original quite literally on every line!  Prior to committing
          his changes, the user has two choices.  Either he can use a
          conversion utility to restore the modified file to the same
          line ending style that it was in before his edits were made.
          Or, he can simply commit the file—new EOL markers and
          all.</p><p>The result of scenarios like these include wasted time
          and unnecessary modifications to committed files.  Wasted
          time is painful enough.  But when commits change every line
          in a file, this complicates the job of determining which of
          those lines were changed in a non-trivial way.  Where was
          that bug really fixed?  On what line was a syntax error
          introduced?</p><p>The solution to this problem is the
          <code class="literal">svn:eol-style</code> property.  When this
          property is set to a valid value, Subversion uses it to
          determine what special processing to perform on the file so
          that the file's line ending style isn't flip-flopping with
          every commit that comes from a different operating
          system.  The valid values are:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">native</code></span></dt><dd><p>This causes the file to contain the EOL markers
                that are native to the operating system on which
                Subversion was run.  In other words, if a user on a
                Windows machine checks out a working copy that
                contains a file with an
                <code class="literal">svn:eol-style</code> property set to
                <code class="literal">native</code>, that file will contain
                <code class="literal">CRLF</code> EOL markers.  A Unix user
                checking out a working copy which contains the same
                file will see <code class="literal">LF</code> EOL markers in his
                copy of the file.</p><p>Note that Subversion will actually store the file
                in the repository using normalized
                <code class="literal">LF</code> EOL markers regardless of the
                operating system.  This is basically transparent to
                the user, though.</p></dd><dt><span class="term"><code class="literal">CRLF</code></span></dt><dd><p>This causes the file to contain
                <code class="literal">CRLF</code> sequences for EOL markers,
                regardless of the operating system in use.</p></dd><dt><span class="term"><code class="literal">LF</code></span></dt><dd><p>This causes the file to contain
                <code class="literal">LF</code> characters for EOL markers,
                regardless of the operating system in use.</p></dd><dt><span class="term"><code class="literal">CR</code></span></dt><dd><p>This causes the file to contain
                <code class="literal">CR</code> characters for EOL markers,
                regardless of the operating system in use.  This line
                ending style is not very common.  It was used on older
                Macintosh platforms (on which Subversion doesn't even
                run).</p></dd></dl></div></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.advanced.props.special.externals"></a><code class="literal">svn:externals</code></h4></div></div></div><p>The <code class="literal">svn:externals</code> property contains
          instructions for Subversion to populate a versioned
          directory with one or more other checked-out Subversion
          working copies.  For more information on this keyword and
          its use, see <a href="#svn.advanced.externals" title="Externals Definitions">la sezione chiamata «Externals Definitions»</a>.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.advanced.props.special.special"></a><code class="literal">svn:special</code></h4></div></div></div><p>The <code class="literal">svn:special</code> property is the only
          <code class="literal">svn:</code> property that isn't meant to be
          directly set or modified by users.  Subversion automatically
          sets this property whenever a «<span class="quote">special</span>» object
          is scheduled for addition, such as a symbolic link.  The
          repository stores an <code class="literal">svn:special</code> object as
          an ordinary file.  However, when a client sees this property
          during checkouts or updates, it interprets the contents of
          the file and translates the item back into the special type
          of object.  In versions of Subversion current at the time of
          writing, only versioned symbolic links have this property
          attached, but in future versions of Subversion other special
          types of nodes will probably use this property as
          well.</p><p>Note: Windows clients don't have symbolic links, and
          thus ignore any <code class="literal">svn:special</code> files coming
          from a repository that claim to be symbolic links.  On
          Windows, the user ends up with an ordinary versioned file in
          the working copy.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.advanced.props.special.needs-lock"></a><code class="literal">svn:needs-lock</code></h4></div></div></div><p>This property is used to signify that the file it's
          attached to ought to be locked before editing.  The value of
          the property is irrelevant; Subversion will normalize its
          value to <code class="literal">*</code>.  When present, the file will
          be read-only <span class="emphasis"><em>unless</em></span> the user has
          explicitly locked the file.  When a lock-token is present
          (as a result of running <span><strong class="command">svn lock</strong></span>), the
          file becomes read-write.  When the lock is released, the
          file becomes read-only again.</p><p>To learn more about how, when, and why this property
          should be used, see
          <a href="#svn.advanced.locking.lock-communication" title="Lock Communication">la sezione chiamata «Lock Communication»</a>.</p></div></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.props.auto"></a>Automatic Property Setting</h3></div></div></div><p>Properties are a powerful feature of Subversion, acting as
        key components of many Subversion features discussed elsewhere
        in this and other chapters—textual diff and merge
        support, keyword substitution, newline translation, etc.  But
        to get the full benefit of properties, they must be set on the
        right files and directories.  Unfortunately, that can be a
        step easily forgotten in the routine of things, especially
        since failing to set a property doesn't usually result in an
        obvious error condition (at least compared to, say, failing to
        add a file to version control).  To help your properties get
        applied to the places that need them, Subversion provides a
        couple of simple but useful features.</p><p>Whenever you introduce a file to version control using the
        <span><strong class="command">svn add</strong></span> or <span><strong class="command">svn import</strong></span>
        commands, Subversion runs a very basic heuristic to determine
        if that file consists of human-readable or non-human-readable
        content.  If the latter is the decision made, Subversion will
        automatically set the <code class="literal">svn:mime-type</code>
        property on that file to
        <code class="literal">application/octet-stream</code> (the generic
        «<span class="quote">this is a collection of bytes</span>» MIME type).  Of
        course, if Subversion guesses incorrectly, or if you wish to
        set the <code class="literal">svn:mime-type</code> property to something
        more precise—perhaps <code class="literal">image/png</code> or
        <code class="literal">application/x-shockwave-flash</code>—you can
        always remove or edit that property.</p><p>Subversion also provides the auto-props feature, which
        allows you to create mappings of filename patterns to property
        names and values.  These mappings are made in your runtime
        configuration area.  They again affect adds and imports, and
        not only can override any default MIME type decision made by
        Subversion during those operations, they can also set
        additional Subversion or custom properties, too.  For example,
        you might create a mapping that says that any time you add
        JPEG files—ones that match the pattern
        <code class="literal">*.jpg</code>—Subversion should automatically
        set the <code class="literal">svn:mime-type</code> property on those
        files to <code class="literal">image/jpeg</code>.  Or perhaps any files
        that match <code class="literal">*.cpp</code> should have
        <code class="literal">svn:eol-style</code> set to
        <code class="literal">native</code>, and <code class="literal">svn:keywords</code>
        set to <code class="literal">Id</code>.  Auto-prop support is perhaps
        the handiest property related tool in the Subversion toolbox.
        See <a href="#svn.advanced.confarea.opts.config" title="Config">la sezione chiamata «Config»</a> for more about
        configuring that support.</p></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.advanced.locking"></a>Locking</h2></div></div></div><p>Subversion's «<span class="quote">copy-modify-merge</span>» model is
      optimal when users are collaborating on projects that consist of
      line-based text files, such as program source code.  However, as
      discussed in <a href="#svn.basic.vsn-models.copy-merge.sb-1" title="When Locking is Necessary">When Locking is Necessary</a>, sometimes one
      has to use the «<span class="quote">lock-modify-unlock</span>» model instead
      of Subversion's standard concurrent model.  When a file consists
      of binary data, it's often difficult or impossible to merge two
      sets of changes made in parallel by different users.  For this
      reason, Subversion 1.2 and later offers a feature known as
      <em class="firstterm">locking</em>, often known as «<span class="quote">reserved
      checkouts</span>» in other version control systems.</p><p>Subversion's locking feature has two main goals:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Serializing access to a
          resource</em></span>.  Allow a user to grab an exclusive
          right to change to a file in the repository.  If Harry
          reserves the right to change <code class="filename">foo.jpg</code>,
          then Sally should not be able to commit a change to it.</p></li><li><p><span class="emphasis"><em>Aiding communication</em></span>.
          Prevent users from wasting time on unmergeable changes.  If
          Harry has reserved the right to change
          <code class="filename">foo.jpg</code>, then it should be easy for
          Sally to notice this fact and avoid working on the
          file.</p></li></ul></div><p>Subversion's locking feature is currently limited to files
      only—it's not yet possible to reserve access to a whole
      directory tree.</p><div class="sidebar"><a id="svn.advanced.locking.meanings"></a><p class="title"><b>Three meanings of «<span class="quote">lock</span>»</b></p><p>In this section, and almost everywhere in this book, the
        words «<span class="quote">lock</span>» and «<span class="quote">locking</span>» describe
        a mechanism for mutual exclusion between users to avoid
        clashing commits. Unfortunately, there are two other sorts
        of «<span class="quote">lock</span>» with which Subversion, and therefore
        this book, sometimes needs to be concerned.</p><div class="itemizedlist"><ul type="disc"><li><p><em class="firstterm">Working copy locks</em>,
          used internally by Subversion to prevent clashes between
          multiple Subversion clients operating on the same working
          copy. This is the sort of lock indicated by
          an <code class="computeroutput">L</code> in the third column
          of <span><strong class="command">svn status</strong></span> output, and removed by
          the <span><strong class="command">svn cleanup</strong></span> command, as described in
          <a href="#svn.tour.other.cleanup" title="svn cleanup">la sezione chiamata «<span><strong class="command">svn cleanup</strong></span>»</a>.</p></li><li><p><em class="firstterm">Database locks</em>, used
          internally by the Berkeley DB backend to prevent clashes
          between multiple programs trying to access the
          database. This is the sort of lock whose unwanted
          persistence after an error can cause a repository to
          be «<span class="quote">wedged</span>», as described in
          <a href="#svn.reposadmin.maint.recovery" title="Repository Recovery">la sezione chiamata «Repository Recovery»</a>.</p></li></ul></div><p>You can generally forget about these other sorts of lock,
        until something goes wrong that requires you to care about
        them. In this book, «<span class="quote">lock</span>» means the first sort
        unless the contrary is either clear from context or explicitly
        stated.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.locking.creation"></a>Creating locks</h3></div></div></div><p>In the Subversion repository, a
        <em class="firstterm">lock</em> is a piece of metadata which
        grants exclusive access to one user to change a file.  This
        user is said to be the <em class="firstterm">lock owner</em>.
        Each lock also has a unique identifier, typically a long
        string of characters, known as the <em class="firstterm">lock
        token</em>.  The repository manages locks in a separate
        table, and enforces locks during a commit operation.  If any
        commit transaction attempts to modify or delete the file (or
        delete a parent of the file), the repository will demand two
        pieces of information:</p><div class="orderedlist"><ol type="1"><li><p><span class="bold"><strong>User
          authentication</strong></span>.  The client performing the commit
          must be authenticated as the lock owner.</p></li><li><p><span class="bold"><strong>Software
          authorization</strong></span>.  The user's working copy must send
          the lock token with the commit, proving that it knows
          exactly which lock it's using.</p></li></ol></div><p>An example is in order, to demonstrate.  Let's say that
        Harry has decided to change a JPEG image.  To prevent other
        people from committing changes to the file, he locks the file
        in the repository using the <span><strong class="command">svn lock</strong></span>
        command:</p><pre class="screen">
$ svn lock banana.jpg --message "Editing file for tomorrow's release."
'banana.jpg' locked by user 'harry'.

$ svn status
     K banana.jpg

$ svn info banana.jpg
Path: banana.jpg
Name: banana.jpg
URL: http://svn.example.com/repos/project/banana.jpg
Repository UUID: edb2f264-5ef2-0310-a47a-87b0ce17a8ec
Revision: 2198
Node Kind: file
Schedule: normal
Last Changed Author: frank
Last Changed Rev: 1950
Last Changed Date: 2005-03-15 12:43:04 -0600 (Tue, 15 Mar 2005)
Text Last Updated: 2005-06-08 19:23:07 -0500 (Wed, 08 Jun 2005)
Properties Last Updated: 2005-06-08 19:23:07 -0500 (Wed, 08 Jun 2005)
Checksum: 3b110d3b10638f5d1f4fe0f436a5a2a5
Lock Token: opaquelocktoken:0c0f600b-88f9-0310-9e48-355b44d4a58e
Lock Owner: harry
Lock Created: 2005-06-14 17:20:31 -0500 (Tue, 14 Jun 2005)
Lock Comment (1 line):
Editing file for tomorrow's release.

</pre><p>There are a number of new things demonstrated in the
        previous example.  First, notice that Harry passed the
        <code class="option">--message</code> option to <span><strong class="command">svn
        lock</strong></span>.  Similar to <span><strong class="command">svn commit</strong></span>,
        the <span><strong class="command">svn lock</strong></span> command can take comments
        (either via
        <code class="option">--message (-m)</code> or <code class="option">--file
        (-F)</code>) to describe the reason for locking the file.
        Unlike <span><strong class="command">svn commit</strong></span>, however, <span><strong class="command">svn
        lock</strong></span> will not demand a message by launching your
        preferred text editor.  Lock comments are optional, but still
        recommended to aid communication.</p><p>Second, the lock attempt succeeded.  This means that the
        file wasn't already locked, and that Harry had the latest
        version of the file.  If Harry's working copy of the file had
        been out-of-date, the repository would have rejected the
        request, forcing harry to <span><strong class="command">svn update</strong></span> and
        reattempt the locking command.</p><p>Also notice that after creating the lock in the
        repository, the working copy has cached information about the
        lock—most importantly, the lock token.  The presence of
        the lock token is critical.  It gives the working copy
        authorization to make use of the lock later on.  The
        <span><strong class="command">svn status</strong></span> command shows a
        <code class="literal">K</code> next to the file (short for locKed),
        indicating that the lock token is present.</p><div class="sidebar"><p class="title"><b>Regarding lock tokens</b></p><p>A lock token isn't an authentication token, so much as
          an <span class="emphasis"><em>authorization</em></span> token.  The token
          isn't a protected secret.  In fact, a lock's unique token is
          discoverable by anyone who runs <span><strong class="command">svn info
          URL</strong></span>.</p><p>A lock token is special only when it lives inside a
          working copy.  It's proof that the lock was created in that
          particular working copy, and not somewhere else by some
          other client.  Merely authenticating as the lock owner isn't
          enough to prevent accidents.</p><p>For example: suppose you lock a file using a computer at
         your office, perhaps as part of a changeset in progress.  It
         should not be possible for a working copy (or alternate
         Subversion client) on your home computer to accidentally
         commit a change to that same file, just because you've
         authenticated as the lock's owner.  In other words, the lock
         token prevents one piece of Subversion-related software from
         undermining the work of another.  (In our example, if you
         really need to change the file from an alternate working
         copy, you would need to break the lock and re-lock the
         file.)</p></div><p>Now that Harry has locked <code class="filename">banana.jpg</code>,
        Sally is unable to change or delete that file:</p><pre class="screen">
$ whoami
sally

$ svn delete banana.jpg
D         banana.jpg

$ svn commit -m "Delete useless file."
Deleting       banana.jpg
svn: Commit failed (details follow):
svn: DELETE of
'/repos/project/!svn/wrk/64bad3a9-96f9-0310-818a-df4224ddc35d/banana.jpg':
423 Locked (http://svn.example.com)

</pre><p>But Harry, after touching up the banana's shade of yellow,
        is able to commit his changes to the file.  That's because he
        authenticates as the lock owner, and also because his working
        copy holds the correct lock token:</p><pre class="screen">
$ whoami
harry

$ svn status
M    K banana.jpg

$ svn commit -m "Make banana more yellow"
Sending        banana.jpg
Transmitting file data .
Committed revision 2201.

$ svn status
$
</pre><p>Notice that after the commit is finished, <span><strong class="command">svn
          status</strong></span> shows that the lock token is no longer
          present in working copy.  This is the standard behavior
          of <span><strong class="command">svn commit</strong></span>: it walks the working copy
          (or list of targets, if you provide such a list), and sends
          all lock tokens it encounters to the server as part of the
          commit transaction.  After the commit completes
          successfully, all of the repository locks that were
          mentioned are released—<span class="emphasis"><em>even on files that
          weren't committed.</em></span> The rationale here is to
          discourage users from being sloppy about locking, or from
          holding locks for too long.  For example, suppose Harry were
          to haphazardly lock thirty files in a directory named
          <code class="filename">images</code>, because he's unsure of which
          files he needs to change.  He ends up making changes to only
          four files.  When he runs <span><strong class="command">svn commit
          images</strong></span>, the process would still release all thirty
          locks.</p><p>This behavior of automatically releasing locks can be
          overridden with the <code class="option">--no-unlock</code> option
          to <span><strong class="command">svn commit</strong></span>.  This is best used for
          those times when you want to commit changes, but still plan
          to make more changes and thus need to retain existing locks.
          This behavior is also semi-permanently tweakable, by setting
          <code class="literal">no-unlock = yes</code> in your run-time
          <code class="filename">config</code> file (see <a href="#svn.advanced.confarea" title="Runtime Configuration Area">la sezione chiamata «Runtime Configuration Area»</a>).</p><p>Of course, locking a file doesn't oblige one to commit a
        change to it.  The lock can be released at any time with a
        simple
        <span><strong class="command">svn unlock</strong></span> command:</p><pre class="screen">
$ svn unlock banana.c
'banana.c' unlocked.
</pre></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.locking.discovery"></a>Discovering locks</h3></div></div></div><p>When a commit fails due to someone else's locks, it's
        fairly easy to learn about them.  The easiest of
        these is <span><strong class="command">svn status --show-updates</strong></span>:</p><pre class="screen">
$ whoami
sally

$ svn status --show-updates
M              23   bar.c
M    O         32   raisin.jpg
       *       72   foo.h
Status against revision:     105
</pre><p>In this example, Sally can see not only that her copy of
        <code class="filename">foo.h</code> is out-of-date, but that one of the
        two modified files she plans to commit is locked in the
        repository.  The <code class="literal">O</code> symbol stands for
        «<span class="quote">Other</span>», meaning that a lock exists on the file,
        and was created by somebody else.  If she were to attempt a
        commit, the lock on <code class="filename">raisin.jpg</code> would
        prevent it.  Sally is left wondering who made the lock, when,
        and why.  Once again, <span><strong class="command">svn info</strong></span> has the
        answers:</p><pre class="screen">
$ svn info http://svn.example.com/repos/project/raisin.jpg
Path: raisin.jpg
Name: raisin.jpg
URL: http://svn.example.com/repos/project/raisin.jpg
Repository UUID: edb2f264-5ef2-0310-a47a-87b0ce17a8ec
Revision: 105
Node Kind: file
Last Changed Author: sally
Last Changed Rev: 32
Last Changed Date: 2005-01-25 12:43:04 -0600 (Tue, 25 Jan 2005)
Lock Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Lock Owner: harry
Lock Created: 2005-02-16 13:29:18 -0500 (Wed, 16 Feb 2005)
Lock Comment (1 line):
Need to make a quick tweak to this image.
</pre><p>Just as <span><strong class="command">svn info</strong></span> can be used to examine
        objects in the working copy, it can also be used to examine
        objects in the repository.  If the main argument to
        <span><strong class="command">svn info</strong></span> is a working copy path, then all
        of the working copy's cached information is displayed; any
        mention of a lock means that the working copy is holding a
        lock token (if a file is locked by another user or in another
        working copy, <span><strong class="command">svn info</strong></span> on a working copy
        path will show no lock information at all).  If the main
        argument to <span><strong class="command">svn info</strong></span> is a URL, then the
        information reflects the latest version of an object in the
        repository; any mention of a lock describes the current lock
        on the object.</p><p>So in this particular example, Sally can see that Harry
        locked the file on February 16th to «<span class="quote">make a quick
        tweak</span>».  It being June, she suspects that he probably
        forgot all about the lock.  She might phone Harry to complain
        and ask him to release the lock.  If he's unavailable, she
        might try to forcibly break the lock herself or ask an
        administrator to do so.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.locking.break-steal"></a>Breaking and stealing locks</h3></div></div></div><p>A repository lock isn't sacred; it can be released not
        only by the person who created it, but by anyone at all.  When
        somebody other than the original lock creator destroys a lock,
        we refer to this as <em class="firstterm">breaking</em> the
        lock.</p><p>From the administrator's chair, it's simple to break
        locks.  The <span><strong class="command">svnlook</strong></span>
        and <span><strong class="command">svnadmin</strong></span> programs have the ability to
        display and remove locks directly from the repository.  (For
        more information about these tools, see
        <a href="#svn.reposadmin.maint.tk" title="An Administrator's Toolkit">la sezione chiamata «An Administrator's Toolkit»</a>.)</p><pre class="screen">
$ svnadmin lslocks /usr/local/svn/repos
Path: /project2/images/banana.jpg
UUID Token: opaquelocktoken:c32b4d88-e8fb-2310-abb3-153ff1236923
Owner: frank
Created: 2005-06-15 13:29:18 -0500 (Wed, 15 Jun 2005)
Expires: 
Comment (1 line):
Still improving the yellow color.

Path: /project/raisin.jpg
UUID Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Owner: harry
Created: 2005-02-16 13:29:18 -0500 (Wed, 16 Feb 2005)
Expires: 
Comment (1 line):
Need to make a quick tweak to this image.

$ svnadmin rmlocks /usr/local/svn/repos /project/raisin.jpg
Removed lock on '/project/raisin.jpg'.
</pre><p>The more interesting option is allowing users to break
        each other's locks over the network.  To do this, one simply
        needs to pass the <code class="option">--force</code> to the unlock
        command:</p><pre class="screen">
$ whoami
sally

$ svn status --show-updates
M              23   bar.c
M    O         32   raisin.jpg
       *       72   foo.h
Status against revision:     105

$ svn unlock raisin.jpg
svn: 'raisin.jpg' is not locked in this working copy

$ svn info raisin.jpg | grep URL
URL: http://svn.example.com/repos/project/raisin.jpg

$ svn unlock http://svn.example.com/repos/project/raisin.jpg
svn: Unlock request failed: 403 Forbidden (http://svn.example.com)

$ svn unlock --force http://svn.example.com/repos/project/raisin.jpg
'raisin.jpg' unlocked.
</pre><p>Sally's initial attempt to unlock failed because she
        ran <span><strong class="command">svn unlock</strong></span> directly on her working copy
        of the file, and no lock token was present.  To remove the
        lock directly from the repository, she needs to pass a URL
        to <span><strong class="command">svn unlock</strong></span>.  Her first attempt to unlock
        the URL fails, because she can't authenticate as the lock
        owner (nor does she have the lock token).  But when she
        passes <code class="option">--force</code>, the authentication and
        authorization requirements are ignored, and the remote lock is
        broken.</p><p>Of course, simply breaking a lock may not be enough.  In
        the running example, Sally may not only want to break Harry's
        long-forgotten lock, but re-lock the file for her own use.
        She can accomplish this by running <span><strong class="command">svn unlock
        --force</strong></span> and then <span><strong class="command">svn lock</strong></span>
        back-to-back, but there's a small chance that somebody else
        might lock the file between the two commands.  The simpler thing
        to is <em class="firstterm">steal</em> the lock, which involves
        breaking and re-locking the file all in one atomic step.  To
        do this, pass the <code class="option">--force</code> option
        to <span><strong class="command">svn lock</strong></span>:</p><pre class="screen">
$ svn lock raisin.jpg
svn: Lock request failed: 423 Locked (http://svn.example.com)

$ svn lock --force raisin.jpg
'raisin.jpg' locked by user 'sally'.
</pre><p>In any case, whether the lock is broken or stolen, Harry
          may be in for a surprise.  Harry's working copy still
          contains the original lock token, but that lock no longer
          exists.  The lock token is said to
          be <em class="firstterm">defunct</em>.  The lock represented by
          the lock-token has either been broken (no longer in the
          repository), or stolen (replaced with a different lock).
          Either way, Harry can see this by asking <span><strong class="command">svn
          status</strong></span> to contact the repository:</p><pre class="screen">
$ whoami
harry

$ svn status
     K raisin.jpg

$ svn status --show-updates
     B         32   raisin.jpg

$ svn update
  B  raisin.jpg

$ svn status

$
</pre><p>If the repository lock was broken, then <span><strong class="command">svn
            status --show-updates</strong></span> displays
            a <code class="literal">B</code> (Broken) symbol next to the file.
            If a new lock exists in place of the old one, then
            a <code class="literal">T</code> (sTolen) symbol is shown.
            Finally, <span><strong class="command">svn update</strong></span> notices any defunct
            lock tokens and removes them from the working copy.</p><div class="sidebar"><p class="title"><b>Locking Policies</b></p><p>Different systems have different notions of how strict
            a lock should be.  Some folks argue that locks must be
            strictly enforced at all costs, releasable only by the
            original creator or administrator.  They argue that if
            anyone can break a lock, then chaos breaks loose and the
            whole point of locking is defeated.  The other side argues
            that locks are first and foremost a communication tool.
            If users are constantly breaking each others' locks, then
            it represents a cultural failure within the team and the
            problem falls outside the scope of software
            enforcement.</p><p>Subversion defaults to the «<span class="quote">softer</span>»
            approach, but still allows administrators to create
            stricter enforcement policies through the use of hook
            scripts.  In particular, the <code class="filename">pre-lock</code>
            and <code class="filename">pre-unlock</code> hooks allow
            administrators to decide when lock creation and lock
            releases are allowed to happen.  Depending on whether or
            not a lock already exists, these two hooks can decide
            whether or not to allow a certain user to break or steal a
            lock.  The <code class="filename">post-lock</code>
            and <code class="filename">post-unlock</code> hooks are also
            available, and can be used to send email after locking
            actions.</p><p>To learn more about repository hooks, see
            <a href="#svn.reposadmin.create.hooks" title="Hook Scripts">la sezione chiamata «Hook Scripts»</a>.</p></div></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.locking.lock-communication"></a>Lock Communication</h3></div></div></div><p>We've seen how <span><strong class="command">svn lock</strong></span>
        and <span><strong class="command">svn unlock</strong></span> can be used to create,
        release, break, and steal locks.  This satisfies the goal of
        serializing commit access to a file.  But what about the
        larger problem of preventing wasted time?</p><p>For example, suppose Harry locks an image file and then
        begins editing it.  Meanwhile, miles away, Sally wants to do
        the same thing.  She doesn't think to run <span><strong class="command">svn status
        --show-updates</strong></span>, so she has no idea that Harry has
        already locked the file.  She spends hours editing the file,
        and when she tries to commit her change, she discovers that
        either the file is locked or that she's out-of-date.
        Regardless, her changes aren't mergeable with Harry's.  One of
        these two people has to throw away their work, and a lot of
        time has been wasted.</p><p>Subversion's solution to this problem is provide a
        mechanism to remind users that a file ought to be locked
        <span class="emphasis"><em>before</em></span> the editing begins.</p><p>The mechanism is a special
        property, <code class="literal">svn:needs-lock</code>.  If the property
        is attached to a file (the value is irrelevant), then the file
        will have read-only permissions.  When the user locks the file
        and receives a lock token, the file becomes read-write.  When
        the lock is released—either explicitly unlocked, or
        released via commit—the file returns to read-only
        again.</p><p>The theory, then, is that if the image file has this
        property attached, then Sally would immediately notice
        something is strange when she opens the file for editing.  Her
        application would be unable to save changes, or (better yet)
        tell her that the file is read-only.  This reminds her to lock
        the file before editing, whereby she discovers the
        pre-existing lock:</p><pre class="screen">
$ /usr/local/bin/gimp raisin.jpg
gimp: error: file is read-only!

$ ls -l raisin.jpg
-r--r--r--   1 sally   sally   215589 Jun  8 19:23 raisin.jpg

$ svn lock raisin.jpg
svn: Lock request failed: 423 Locked (http://svn.example.com)

$ svn info http://svn.example.com/repos/project/raisin.jpg | grep Lock
Lock Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Lock Owner: harry
Lock Created: 2005-06-08 07:29:18 -0500 (Thu, 08 June 2005)
Lock Comment (1 line):
Making some tweaks.  Locking for the next two hours.

</pre><p>As a matter of «<span class="quote">best practice</span>», both users
          and administrators are encouraged to attach
          the <code class="literal">svn:needs-lock</code> property to any file
          which cannot be contextually merged.  It's the main
          technique for encouraging good locking habits and preventing
          wasted effort.</p><p>Note that this property is a communication tool which
          works independently from the locking system.  In other
          words, any file can be locked, whether or not this property
          is present.  And conversely, the presence of this property
          doesn't make the repository require a lock when
          committing.</p><p>The system isn't flawless, either.  It's possible that
          even when a file has the property, the read-only reminder
          won't always work.  Sometimes applications misbehave and
          «<span class="quote">hijack</span>» the read-only file, silently allowing
          users to edit and save the file anyway.  Unfortunately,
          there's not much Subversion can do about this.</p></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.advanced.pegrevs"></a>Peg and Operative Revisions</h2></div></div></div><p>We make use of the ability to copy, move, rename, and
      completely replace files and directories on our computers all
      that time.  And your version control system shouldn't get in the
      way of your doing these things with your version controlled
      files and directories, either.  Subversion's file management
      support is quite liberating, affording almost as much
      flexibility for versioned files that you'd expect when
      manipulating your unversioned ones.  But that flexibility means
      that across the lifetime of your repository, a given versioned
      resource might have many paths, and a given path might represent
      several entirely different versioned resources.  And this
      introduces a certain level of complexity to your interactions
      with those paths and resources.</p><p>Subversion is pretty smart about noticing when an object's
      version history includes such «<span class="quote">changes of address</span>».
      For example, if you ask for all the logs of a particular file
      that was renamed last week, Subversion happily provides all
      those logs—the revision in which the rename itself
      happened, plus the logs of relevant revisions both before and
      after that rename.  So, most of the time, you don't even have to
      think about such things.  But occasionally, Subversion needs
      your help to clear up ambiguities.</p><p>The simplest example of this occurs when a directory or file
      is deleted from version control, and then a new directory or
      file is created with the same name and added to version control.
      Clearly the thing you deleted and the thing you later added
      aren't the same thing, they merely happen to have had the same
      path, which we'll call <code class="filename">/trunk/object</code>.
      What, then, does it mean to ask Subversion about the history of
      <code class="filename">/trunk/object</code>?  Are you asking about the
      thing currently at that location, or the old thing you deleted
      from that location?  Are you asking about the operations that
      have happened to all the objects that have lived at that path?
      Clearly, Subversion needs a hint about what you are really
      asking.</p><p>And thanks to moves, versioned resource history can get far
      more twisted than that, even.  For example, you might have a
      directory named <code class="filename">concept</code>, containing some
      nascent software project you've been toying with.  Eventually,
      though, that project matures to the point that the idea seems to
      actually have some wings, so you do the unthinkable and decide
      to give the project a name.
      <sup>[<a id="id4757664" href="#ftn.id4757664">37</a>]</sup>
      Let's say you called your software Frabnaggilywort.  At this
      point, it makes sense to rename the directory to reflect the
      project's new name, so <code class="filename">concept</code> is renamed
      to <code class="filename">frabnaggilywort</code>.  Life goes on,
      Frabnaggilywort releases a 1.0 version, and is downloaded and
      used daily by hordes of people aiming to improve their
      lives.</p><p>It's a nice story, really, but it doesn't end there.
      Entrepreneur that you are, you've already got another think in
      the tank.  So you make a new directory,
      <code class="filename">concept</code>, and the cycle begins again.  In
      fact, the cycle begins again many times over the years, each
      time starting with that old <code class="filename">concept</code>
      directory, then sometimes seeing that directory renamed as the
      idea cures, sometimes seeing it deleted when you scrap the idea.
      Or, to get really sick, maybe you rename
      <code class="filename">concept</code> to something else for a while, but
      later rename the thing back to <code class="filename">concept</code> for
      some reason.</p><p>When scenarios like these occur, attempting to instruct
      Subversion to work with these re-used paths can be a little like
      instructing a motorist in Chicago's West Suburbs to drive east
      down Roosevelt Road and turn left onto Main Street.  In a mere
      twenty minutes, you can cross «<span class="quote">Main Street</span>» in
      Wheaton, Glen Ellyn, and Lombard.  And no, they aren't the same
      street.  Our motorist—and our Subversion—need a
      little more detail in order to do the right thing.</p><p>In version 1.1, Subversion introduced a way for you to tell
      it exactly which Main Street you meant.  It's called the
      <em class="firstterm">peg revision</em>, and it is a revision
      provided to Subversion for the sole purpose of identifying a
      unique line of history.  Because at most one versioned resource
      may occupy a path at any given time—or, more precisely, in
      any one revision—the combination of a path and a peg
      revision is all that is needed to refer to a specific line of
      history.  Peg revisions are specified to the Subversion
      command-line client using <em class="firstterm">at syntax</em>, so
      called because the syntax involves appending an «<span class="quote">at
      sign</span>» (<code class="literal">@</code>) and the peg revision to the
      end of the path with which the revision is associated.</p><p>But what of the <code class="option">--revision (-r)</code> of which
      we've spoken so much in this book?  That revision (or set of
      revisions) is called the <em class="firstterm">operative
      revision</em> (or <em class="firstterm">operative revision
      range</em>).  Once a particular line of history has been
      identified using a path and peg revision, Subversion performs
      the requested operation using the operative revision(s).  To map
      this to our Chicagoland streets analogy, if we are told to go to
      606 N. Main Street in Wheaton,
      <sup>[<a id="id4757810" href="#ftn.id4757810">38</a>]</sup>
      we can think of «<span class="quote">Main Street</span>» as our path and
      «<span class="quote">Wheaton</span>» as our peg revision.  These two pieces of
      information identify a unique path which can travelled (north or
      south on Main Street), and will keep us from travelling up and
      down the wrong Main Street in search of our destination.  Now we
      throw in «<span class="quote">606 N.</span>» as our operative revision, of
      sorts, and we know <span class="emphasis"><em>exactly</em></span> where to
      go.</p><div class="sidebar"><p class="title"><b>The "peg-revision" algorithm</b></p><p>When the commandline client sees a command of the
        form:</p><pre class="screen">
$ svn <em class="replaceable"><code>command</code></em> -r <em class="replaceable"><code>OPERATIVE-REV</code></em> item@<em class="replaceable"><code>PEG-REV</code></em>
</pre><p>...it performs the following algorithm:</p><div class="itemizedlist"><ul type="disc"><li><p>Go to revision <em class="replaceable"><code>PEG-REV</code></em>, and
          find <em class="replaceable"><code>item</code></em>.  This locates a unique
          object in the repository.</p></li><li><p>Trace the object's history backwards (through any
            possible renames) to its ancestor in
            revision <em class="replaceable"><code>OPERATIVE-REV</code></em>.</p></li><li><p>Perform the requested action on that ancestor,
            wherever it is located, or whatever its name might
            be.</p></li></ul></div><p>Remember that even when you don't explicitly supply a
        peg-revision, it's still present.  It defaults to BASE for
        working copy items, and to HEAD for URLs.</p></div><p>Say that long ago we created our repository, and in revision 1
      added our first <code class="filename">concept</code> directory, plus an
      <code class="filename">IDEA</code> file in that directory talking about
      the concept.  After several revisions in which real code was
      added and tweaked, we, in revision 20, renamed this directory to
      <code class="filename">frabnaggilywort</code>.  By revision 27, we had a
      new concept, a new <code class="filename">concept</code> directory to
      hold it, and a new <code class="filename">IDEA</code> file to describe
      it.  And then five years and twenty thousand revisions flew by,
      just like they would in any good romance story.</p><p>Now, years later, we wonder what the
      <code class="filename">IDEA</code> file looked like back in revision 1.
      But Subversion needs to know if we are asking about how the
      <span class="emphasis"><em>current</em></span> file looked back in revision 1, or
      are we asking for the contents of whatever file lived at
      <code class="filename">concepts/IDEA</code> in revision 1?  Certainly
      those questions have different answers, and because of peg
      revisions, you can ask either of them.  To find out how the
      current <code class="filename">IDEA</code> file looked in that old
      revision, you run:</p><pre class="screen">
$ svn cat -r 1 concept/IDEA 
subversion/libsvn_client/ra.c:775: (apr_err=20014)
svn: Unable to find repository location for 'concept/IDEA' in revision 1
</pre><p>Of course, in this example, the current
      <code class="filename">IDEA</code> file didn't exist yet in revision 1,
      so Subversion gives an error.  The command above is shorthand
      for a longer notation which explicitly lists a peg revision.
      The expanded notation is:</p><pre class="screen">
$ svn cat -r 1 concept/IDEA@BASE
subversion/libsvn_client/ra.c:775: (apr_err=20014)
svn: Unable to find repository location for 'concept/IDEA' in revision 1
</pre><p>And when executed, it has the expected results.  Peg revisions
      generally default to a value of <code class="literal">BASE</code> (the
      revision currently present in the working copy) when applied to
      working copy paths, and of <code class="literal">HEAD</code> when applied
      to URLs.</p><p>Let's ask the other question, then—in revision 1, what
      were the contents of whatever file occupied the address
      <code class="filename">concepts/IDEA</code> at the time?  We'll use an
      explicit peg revision to help us out.</p><pre class="screen">
$ svn cat concept/IDEA@1
The idea behind this project is to come up with a piece of software
that can frab a naggily wort.  Frabbing naggily worts is tricky
business, and doing it incorrectly can have serious ramifications, so
we need to employ over-the-top input validation and data verification
mechanisms.
</pre><p>This appears to be the right output.  The text even mentions
      frabbing naggily worts, so this is almost certainly the file
      which describes the software now called Frabnaggilywort.  In
      fact, we can verify this using the combination of an explicit
      peg revision and explicit operative revision.  We know that in
      <code class="literal">HEAD</code>, the Frabnaggilywort project is located
      in the <code class="filename">frabnaggilywort</code> directory.  So we
      specify that we want to see how the line of history identified
      in <code class="literal">HEAD</code> as the path
      <code class="filename">frabnaggilywort/IDEA</code> looked in revision
      1.</p><pre class="screen">
$ svn cat -r 1 frabnaggilywort/IDEA@HEAD
The idea behind this project is to come up with a piece of software
that can frab a naggily wort.  Frabbing naggily worts is tricky
business, and doing it incorrectly can have serious ramifications, so
we need to employ over-the-top input validation and data verification
mechanisms.
</pre><p>And the peg and operative revisions need not be so trivial,
      either.  For example, say <code class="filename">frabnaggilywort</code>
      had been deleted from <code class="literal">HEAD</code>, but we know it
      existed in revision 20, and we want to see the diffs for its
      <code class="filename">IDEA</code> file between revisions 4 and 10.  We
      can use the peg revision 20 in conjunction with the URL that
      would have held Frabnaggilywort's <code class="filename">IDEA</code> file
      in revision 20, and then use 4 and 10 as our operative revision
      range.</p><pre class="screen">
$ svn diff -r 4:10 http://svn.red-bean.com/projects/frabnaggilywort/IDEA@20
Index: frabnaggilywort/IDEA
===================================================================
--- frabnaggilywort/IDEA	(revision 4)
+++ frabnaggilywort/IDEA	(revision 10)
@@ -1,5 +1,5 @@
-The idea behind this project is to come up with a piece of software
-that can frab a naggily wort.  Frabbing naggily worts is tricky
-business, and doing it incorrectly can have serious ramifications, so
-we need to employ over-the-top input validation and data verification
-mechanisms.
+The idea behind this project is to come up with a piece of
+client-server software that can remotely frab a naggily wort.
+Frabbing naggily worts is tricky business, and doing it incorrectly
+can have serious ramifications, so we need to employ over-the-top
+input validation and data verification mechanisms.
</pre><p>Fortunately, most folks aren't faced with such complex
      situations.  But when you are, remember that peg revisions are
      that extra hint Subversion needs to clear up ambiguity.</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.advanced.externals"></a>Externals Definitions</h2></div></div></div><p>Sometimes it is useful to construct a working copy that is
      made out of a number of different checkouts.  For example, you
      may want different subdirectories to come from different
      locations in a repository, or perhaps from different
      repositories altogether.  You could certainly setup such a
      scenario by hand—using <span><strong class="command">svn checkout</strong></span> to
      create the sort of nested working copy structure you are trying
      to achieve.  But if this layout is important for everyone who
      uses your repository, every other user will need to perform the
      same checkout operations that you did.</p><p>Fortunately, Subversion provides support for
      <em class="firstterm">externals definitions</em>.  An externals
      definition is a mapping of a local directory to the
      URL—and possibly a particular revision—of a
      versioned resource.  In Subversion, you declare externals
      definitions in groups using the <code class="literal">svn:externals</code>
      property.  You can create or modify this property using
      <span><strong class="command">svn propset</strong></span> or <span><strong class="command">svn
      propedit</strong></span> (see <a href="#svn.advanced.props.why" title="Why Properties?">la sezione chiamata «Why Properties?»</a>).  
      It can be set on any versioned directory,
      and its value is a multi-line table of subdirectories (relative
      to the versioned directory on which the property is set) and
      fully qualified, absolute Subversion repository URLs.</p><pre class="screen">
$ svn propget svn:externals calc
third-party/sounds             http://sounds.red-bean.com/repos
third-party/skins              http://skins.red-bean.com/repositories/skinproj
third-party/skins/toolkit -r21 http://svn.red-bean.com/repos/skin-maker
</pre><p>The convenience of the <code class="literal">svn:externals</code>
      property is that once it is set on a versioned directory,
      everyone who checks out a working copy with that directory also
      gets the benefit of the externals definition.  In other words,
      once one person has made the effort to define those nested
      working copy checkouts, no one else has to
      bother—Subversion will, upon checkout of the original
      working copy, also checkout the external working copies.</p><p>Note the previous externals definition example.  When
      someone checks out a working copy of the
      <code class="filename">calc</code> directory, Subversion also continues
      to checkout the items found in its externals definition.</p><pre class="screen">
$ svn checkout http://svn.example.com/repos/calc
A  calc
A  calc/Makefile
A  calc/integer.c
A  calc/button.c
Checked out revision 148.

Fetching external item into calc/third-party/sounds
A  calc/third-party/sounds/ding.ogg
A  calc/third-party/sounds/dong.ogg
A  calc/third-party/sounds/clang.ogg
…
A  calc/third-party/sounds/bang.ogg
A  calc/third-party/sounds/twang.ogg
Checked out revision 14.

Fetching external item into calc/third-party/skins
…
</pre><p>If you need to change the externals definition, you can do
      so using the regular property modification subcommands.  When
      you commit a change to the <code class="literal">svn:externals</code>
      property, Subversion will synchronize the checked-out items
      against the changed externals definition when you next run
      <span><strong class="command">svn update</strong></span>.  The same thing will happen when
      others update their working copies and receive your changes to
      the externals definition.</p><p>The <span><strong class="command">svn status</strong></span> command also recognizes
      externals definitions, displaying a status code of
      <code class="literal">X</code> for the disjoint subdirectories into which
      externals are checked out, and then recursing into those
      subdirectories to display the status of the external items
      themselves.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Suggerimento</h3><p>You should strongly consider using explicit revision
        numbers in all of your externals definitions.  Doing so means
        that you get to decide when to pull down a different snapshot
        of external information, and exactly which snapshot to pull.
        Besides the common sense aspect of not being surprised by
        changes to third-party repositories that you might not have
        any control over, using explicit revision numbers also means
        that as you backdate your working copy to a previous
        revision, your externals definitions will also revert to the
        way they looked in that previous revision, which in turn means
        that the external working copies will be updated to match they
        way <span class="emphasis"><em>they</em></span> looked back when your repository was
        at that previous revision.  For software projects, this could
        be the difference between a successful and a failed build of
        an older snapshot of your complex codebase.</p></div><p>The support that exists for externals definitions in
      Subversion today can be a little misleading, though.  First, an
      externals definition can only point to directories, not files.
      Second, the externals definition cannot point to relative paths
      (paths like <code class="filename">../../skins/myskin</code>).  Third, the
      working copies created via the externals definition support are
      still disconnected from the primary working copy (on whose
      versioned directories the <code class="literal">svn:externals</code>
      property was actually set).  And Subversion still only truly
      operates on non-disjoint working copies.  So, for example, if
      you want to commit changes that you've made in one or more of
      those external working copies, you must run <span><strong class="command">svn
      commit</strong></span> explicitly on those working
      copies—committing on the primary working copy will not
      recurse into any external ones.</p><p>Also, since the definitions themselves use absolute URLs,
      moving or copying a directory to which they are attached will
      not affect what gets checked out as an external (though the
      relative local target subdirectory will, of course, move with
      renamed directory).  This can be confusing—even
      frustrating—in certain situations.  For example, if you
      use externals definitions on a directory in your
      <code class="filename">/trunk</code> development line which point to
      other areas of that same line, and then you use <span><strong class="command">svn
      copy</strong></span> to branch that line to some new location
      <code class="filename">/branches/my-branch</code>, the externals
      definitions on items in your new branch will still refer to
      versioned resources in <code class="filename">/trunk</code>.  Be aware,
      too, that if you need to re-parent your working copy (using
      <span><strong class="command">svn switch --relocate</strong></span>), externals definitions
      will <span class="emphasis"><em>not</em></span> also be re-parented.</p><p>Finally, there might be times when you would prefer that
      <span><strong class="command">svn</strong></span> subcommands would not recognize or
      otherwise operate on the external working copies created as the
      result of externals definition handling.  In those instances,
      you can pass the <code class="option">--ignore-externals</code> option to
      the subcommand.</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.advanced.vendorbr"></a>Vendor branches</h2></div></div></div><p>As is especially the case when developing software, the data
      that you maintain under version control is often closely related
      to, or perhaps dependent upon, someone else's data.  Generally,
      the needs of your project will dictate that you stay as
      up-to-date as possible with the data provided by that external
      entity without sacrificing the stability of your own project.
      This scenario plays itself out all the time—anywhere that
      the information generated by one group of people has a direct
      effect on that which is generated by another group.</p><p>For example, software developers might be working on an
      application which makes use of a third-party library.
      Subversion has just such a relationship with the Apache Portable
      Runtime library (see <a href="#svn.developer.usingapi.apr" title="The Apache Portable Runtime Library">la sezione chiamata «The Apache Portable Runtime Library»</a>).  The
      Subversion source code depends on the APR library for all its
      portability needs.  In earlier stages of Subversion's
      development, the project closely tracked APR's changing API,
      always sticking to the «<span class="quote">bleeding edge</span>» of the
      library's code churn.  Now that both APR and Subversion have
      matured, Subversion attempts to synchronize with APR's library
      API only at well-tested, stable release points.</p><p>Now, if your project depends on someone else's information,
      there are several ways that you could attempt to synchronize that
      information with your own.  Most painfully, you could issue oral
      or written instructions to all the contributors of your project,
      telling them to make sure that they have the specific versions
      of that third-party information that your project needs.  If the
      third-party information is maintained in a Subversion
      repository, you could also use Subversion's externals
      definitions to effectively «<span class="quote">pin down</span>» specific
      versions of that information to some location in your own
      working copy directory (see <a href="#svn.advanced.externals" title="Externals Definitions">la sezione chiamata «Externals Definitions»</a>).</p><p>But sometimes you want to maintain custom modifications to
      third-party data in your own version control system.  Returning
      to the software development example, programmers might need to
      make modifications to that third-party library for their own
      purposes.  These modifications might include new functionality
      or bug fixes, maintained internally only until they become part
      of an official release of the third-party library.  Or the
      changes might never be relayed back to the library maintainers,
      existing solely as custom tweaks to make the library further
      suit the needs of the software developers.</p><p>Now you face an interesting situation.  Your project could
      house its custom modifications to the third-party data in some
      disjointed fashion, such as using patch files or full-fledged
      alternate versions of files and directories.  But these quickly
      become maintenance headaches, requiring some mechanism by which
      to apply your custom changes to the third-party data, and
      necessitating regeneration of those changes with each successive
      version of the third-party data that you track.</p><p>The solution to this problem is to use <em class="firstterm">vendor
      branches</em>.  A vendor branch is a directory tree in
      your own version control system that contains information
      provided by a third-party entity, or vendor.  Each version of
      the vendor's data that you decide to absorb into your project is
      called a <em class="firstterm">vendor drop</em>.</p><p>Vendor branches provide two key benefits.  First, by storing
      the currently supported vendor drop in your own version control
      system, the members of your project never need to question
      whether they have the right version of the vendor's data.  They
      simply receive that correct version as part of their regular
      working copy updates.  Secondly, because the data lives in your
      own Subversion repository, you can store your custom changes to
      it in-place—you have no more need of an automated (or
      worse, manual) method for swapping in your customizations.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.vendorbr.general"></a>General Vendor Branch Management Procedure</h3></div></div></div><p>Managing vendor branches generally works like this.  You
        create a top-level directory (such as
        <code class="filename">/vendor</code>) to hold the vendor branches.
        Then you import the third party code into a subdirectory of
        that top-level directory.  You then copy that subdirectory
        into your main development branch (for example,
        <code class="filename">/trunk</code>) at the appropriate location.  You
        always make your local changes in the main development branch.
        With each new release of the code you are tracking you bring
        it into the vendor branch and merge the changes into
        <code class="filename">/trunk</code>, resolving whatever conflicts
        occur between your local changes and the upstream
        changes.</p><p>Perhaps an example will help to clarify this algorithm.
        We'll use a scenario where your development team is creating a
        calculator program that links against a third-party complex
        number arithmetic library, libcomplex.  We'll begin with the
        initial creation of the vendor branch, and the import of the
        first vendor drop.  We'll call our vendor branch directory
        <code class="filename">libcomplex</code>, and our code drops will go
        into a subdirectory of our vendor branch called
        <code class="filename">current</code>.  And since <span><strong class="command">svn
        import</strong></span> creates all the intermediate parent
        directories it needs, we can actually accomplish both of these
        steps with a single command.</p><pre class="screen">
$ svn import /path/to/libcomplex-1.0 \
             http://svn.example.com/repos/vendor/libcomplex/current \
             -m 'importing initial 1.0 vendor drop'
…
</pre><p>We now have the current version of the libcomplex source
        code in <code class="filename">/vendor/libcomplex/current</code>.  Now,
        we tag that version (see <a href="#svn.branchmerge.tags" title="Tags">la sezione chiamata «Tags»</a>)
        and then copy it into the main development branch.  Our copy
        will create a new directory called
        <code class="filename">libcomplex</code> in our existing
        <code class="filename">calc</code> project directory.  It is in this
        copied version of the vendor data that we will make our
        customizations.</p><pre class="screen">
$ svn copy http://svn.example.com/repos/vendor/libcomplex/current  \
           http://svn.example.com/repos/vendor/libcomplex/1.0      \
           -m 'tagging libcomplex-1.0'
…
$ svn copy http://svn.example.com/repos/vendor/libcomplex/1.0  \
           http://svn.example.com/repos/calc/libcomplex        \
           -m 'bringing libcomplex-1.0 into the main branch'
…
</pre><p>We check out our project's main branch—which now
        includes a copy of the first vendor drop—and we get to
        work customizing the libcomplex code.  Before we know it, our
        modified version of libcomplex is now completely integrated
        into our calculator program.
        <sup>[<a id="id4758804" href="#ftn.id4758804">39</a>]</sup>
      </p><p>A few weeks later, the developers of libcomplex release a
        new version of their library—version 1.1—which
        contains some features and functionality that we really want.
        We'd like to upgrade to this new version, but without losing
        the customizations we made to the existing version.  What we
        essentially would like to do is to replace our current
        baseline version of libcomplex 1.0 with a copy of libcomplex
        1.1, and then re-apply the custom modifications we previously
        made to that library to the new version.  But we actually
        approach the problem from the other direction, applying the
        changes made to libcomplex between versions 1.0 and 1.1 to our
        modified copy of it.</p><p>To perform this upgrade, we checkout a copy of our vendor
        branch, and replace the code in the
        <code class="filename">current</code> directory with the new libcomplex
        1.1 source code.  We quite literally copy new files on top of
        existing files, perhaps exploding the libcomplex 1.1 release
        tarball atop our existing files and directories.  The goal
        here is to make our <code class="filename">current</code> directory
        contain only the libcomplex 1.1 code, and to ensure that all
        that code is under version control.  Oh, and we want to do
        this with as little version control history disturbance as
        possible.</p><p>After replacing the 1.0 code with 1.1 code, <span><strong class="command">svn
        status</strong></span> will show files with local modifications as
        well as, perhaps, some unversioned or missing files.  If we
        did what we were supposed to do, the unversioned files are
        only those new files introduced in the 1.1 release of
        libcomplex—we run <span><strong class="command">svn add</strong></span> on those to
        get them under version control.  The missing files are files
        that were in 1.0 but not in 1.1, and on those paths we run
        <span><strong class="command">svn delete</strong></span>.  Finally, once our
        <code class="filename">current</code> working copy contains only the
        libcomplex 1.1 code, we commit the changes we made to get it
        looking that way.</p><p>Our <code class="filename">current</code> branch now contains the
        new vendor drop.  We tag the new version (in the same way we
        previously tagged the version 1.0 vendor drop), and then merge
        the differences between the tag of the previous version and
        the new current version into our main development
        branch.</p><pre class="screen">
$ cd working-copies/calc
$ svn merge http://svn.example.com/repos/vendor/libcomplex/1.0      \
            http://svn.example.com/repos/vendor/libcomplex/current  \
            libcomplex
… # resolve all the conflicts between their changes and our changes
$ svn commit -m 'merging libcomplex-1.1 into the main branch'
…
</pre><p>In the trivial use case, the new version of our
        third-party tool would look, from a files-and-directories
        point of view, just like the previous version.  None of the
        libcomplex source files would have been deleted, renamed or
        moved to different locations—the new version would
        contain only textual modifications against the previous one.
        In a perfect world, our modifications would apply cleanly to
        the new version of the library, with absolutely no
        complications or conflicts.</p><p>But things aren't always that simple, and in fact it is
        quite common for source files to get moved around between
        releases of software.  This complicates the process of
        ensuring that our modifications are still valid for the new
        version of code, and can quickly degrade into a situation
        where we have to manually recreate our customizations in the
        new version.  Once Subversion knows about the history of a
        given source file—including all its previous
        locations—the process of merging in the new version of
        the library is pretty simple.  But we are responsible for
        telling Subversion how the source file layout changed from
        vendor drop to vendor drop.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.vendorbr.svn_load_dirs"></a><span><strong class="command">svn_load_dirs.pl</strong></span></h3></div></div></div><p>Vendor drops that contain more than a few deletes,
        additions and moves complicate the process of upgrading to
        each successive version of the third-party data.  So
        Subversion supplies the <span><strong class="command">svn_load_dirs.pl</strong></span>
        script to assist with this process.  This script automates the
        importing steps we mentioned in the general vendor branch
        management procedure to make sure that mistakes are minimized.
        You will still be responsible for using the merge commands to
        merge the new versions of the third-party data into your main
        development branch, but <span><strong class="command">svn_load_dirs.pl</strong></span>
        can help you more quickly and easily arrive at that
        stage.</p><p>In short, <span><strong class="command">svn_load_dirs.pl</strong></span> is an
        enhancement to <span><strong class="command">svn import</strong></span> that has several
        important characteristics:</p><div class="itemizedlist"><ul type="disc"><li><p>It can be run at any point in time to bring an existing
            directory in the repository to exactly match an external
            directory, performing all the necessary adds and deletes,
            and optionally performing moves, too.</p></li><li><p>It takes care of complicated series of operations between
            which Subversion requires an intermediate commit—such
            as before renaming a file or directory twice.</p></li><li><p>It will optionally tag the newly imported directory.</p></li><li><p>It will optionally add arbitrary properties to files and
            directories that match a regular expression.</p></li></ul></div><p><span><strong class="command">svn_load_dirs.pl</strong></span> takes three mandatory
        arguments.  The first argument is the URL to the base
        Subversion directory to work in.  This argument is followed by
        the URL—relative to the first argument—into which the
        current vendor drop will be imported.  Finally, the third
        argument is the local directory to import.  Using our previous
        example, a typical run of <span><strong class="command">svn_load_dirs.pl</strong></span>
        might look like:</p><pre class="screen">
$ svn_load_dirs.pl http://svn.example.com/repos/vendor/libcomplex \
                   current                                        \
                   /path/to/libcomplex-1.1
…
</pre><p>You can indicate that you'd like
        <span><strong class="command">svn_load_dirs.pl</strong></span> to tag the new vendor drop
        by passing the <code class="option">-t</code> command-line option and
        specifying a tag name.  This tag is another URL relative to
        the first program argument.</p><pre class="screen">
$ svn_load_dirs.pl -t libcomplex-1.1                              \
                   http://svn.example.com/repos/vendor/libcomplex \
                   current                                        \
                   /path/to/libcomplex-1.1
…
</pre><p>When you run <span><strong class="command">svn_load_dirs.pl</strong></span>, it
        examines the contents of your existing «<span class="quote">current</span>»
        vendor drop, and compares them with the proposed new vendor
        drop.  In the trivial case, there will be no files that are in
        one version and not the other, and the script will perform the
        new import without incident.  If, however, there are
        discrepancies in the file layouts between versions,
        <span><strong class="command">svn_load_dirs.pl</strong></span> will prompt you for how
        you would like to resolve those differences.  For example, you
        will have the opportunity to tell the script that you know
        that the file <code class="filename">math.c</code> in version 1.0 of
        libcomplex was renamed to <code class="filename">arithmetic.c</code> in
        libcomplex 1.1.  Any discrepancies not explained by moves
        are treated as regular additions and deletions.</p><p>The script also accepts a separate configuration file for
        setting properties on files and directories matching a regular
        expression that are <span class="emphasis"><em>added</em></span> to the
        repository.  This configuration file is specified to
        <span><strong class="command">svn_load_dirs.pl</strong></span> using the
        <code class="option">-p</code> command-line option.  Each line of the
        configuration file is a whitespace-delimited set of two or
        four values: a Perl-style regular expression to match the
        added path against, a control keyword (either
        <code class="literal">break</code> or <code class="literal">cont</code>), and then
        optionally a property name and value.</p><pre class="screen">
\.png$              break   svn:mime-type   image/png
\.jpe?g$            break   svn:mime-type   image/jpeg
\.m3u$              cont    svn:mime-type   audio/x-mpegurl
\.m3u$              break   svn:eol-style   LF
.*                  break   svn:eol-style   native
</pre><p>For each added path, the configured property changes whose
        regular expression matches the path are applied in order,
        unless the control specification is <code class="literal">break</code>
        (which means that no more property changes should be applied
        to that path).  If the control specification is
        <code class="literal">cont</code>—an abbreviation for
        <code class="literal">continue</code>—then matching will continue
        with the next line of the configuration file.</p><p>Any whitespace in the regular expression, property name,
        or property value must be surrounded by either single or
        double quote characters.  You can escape quote characters that
        are not used for wrapping whitespace by preceding them with a
        backslash (<code class="literal">\</code>) character.  The backslash
        escapes only quotes when parsing the configuration file, so do
        not protect any other characters beyond what is necessary for
        the regular expression.</p></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.advanced.l10n"></a>Localization</h2></div></div></div><p><em class="firstterm">Localization</em> is the act of making
      programs behave in a region-specific way.  When a program
      formats numbers or dates in a way specific to your part of the
      world, or prints messages (or accepts input) in your native
      language, the program is said to
      be <em class="firstterm">localized</em>.  This section describes
      steps Subversion has made towards localization.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.l10n.understanding"></a>Understanding locales</h3></div></div></div><p>Most modern operating systems have a notion of the
        «<span class="quote">current locale</span>»—that is, the region or
        country whose localization conventions are honored.  These
        conventions—typically chosen by some runtime
        configuration mechanism on the computer—affect the way
        in which programs present data to the user, as well as the way
        in which they accept user input.</p><p>On Unix-like systems, you can check the values of the
        locale-related runtime configuration options by running the
        <span><strong class="command">locale</strong></span> command:</p><pre class="screen">
$ locale
LANG=
LC_COLLATE="C"
LC_CTYPE="C"
LC_MESSAGES="C"
LC_MONETARY="C"
LC_NUMERIC="C"
LC_TIME="C"
LC_ALL="C"
</pre><p>The output is a list of locale-related environment
        variables and their current values.  In this example, the
        variables are all set to the default <code class="literal">C</code>
        locale, but users can set these variables to specific
        country/language code combinations.  For example, if one were
        to set the <code class="literal">LC_TIME</code> variable to
        <code class="literal">fr_CA</code>, then programs would know to present
        time and date information formatted according a
        French-speaking Canadian's expectations.  And if one were to
        set the <code class="literal">LC_MESSAGES</code> variable to
        <code class="literal">zh_TW</code>, then programs would know to present
        human-readable messages in Traditional Chinese.  Setting the
        <code class="literal">LC_ALL</code> variable has the effect of changing
        every locale variable to the same value.  The value of
        <code class="literal">LANG</code> is used as a default value for any
        locale variable that is unset.  To see the list of available
        locales on a Unix system, run the command <span><strong class="command">locale
        -a</strong></span>.</p><p>On Windows, locale configuration is done via the
        «<span class="quote">Regional and Language Options</span>» control panel
        item.  There you can view and select the values of individual
        settings from the available locales, and even customize (at a
        sickening level of detail) several of the display formatting
        conventions.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.l10n.svnuse"></a>Subversion's use of locales</h3></div></div></div><p>The Subversion client, <span><strong class="command">svn</strong></span>, honors the
        current locale configuration in two ways.  First, it notices
        the value of the <code class="literal">LC_MESSAGES</code> variable and
        attempts to print all messages in the specified language.  For
        example:</p><pre class="screen">
$ export LC_MESSAGES=de_DE
$ svn help cat
cat: Gibt den Inhalt der angegebenen Dateien oder URLs aus.
Aufruf: cat ZIEL[@REV]...
…
</pre><p>This behavior works identically on both Unix and Windows
        systems.  Note, though, that while your operating system might
        have support for a certain locale, the Subversion client still
        may not be able to speak the particular language.  In order to
        produce localized messages, human volunteers must provide
        translations for each language.  The translations are written
        using the GNU gettext package, which results in translation
        modules that end with the <code class="filename">.mo</code> filename
        extension.  For example, the German translation file is named
        <code class="filename">de.mo</code>.  These translation files are
        installed somewhere on your system.  On Unix, they typically
        live in <code class="filename">/usr/share/locale/</code>, while
        on Windows they're often found in the
        <code class="filename">\share\locale\</code> folder in Subversion's
        installation area.  Once installed, a module is named after
        the program it provides translations for.  For example, the
        <code class="filename">de.mo</code> file may ultimately end up
        installed as
        <code class="filename">/usr/share/locale/de/LC_MESSAGES/subversion.mo</code>.
        By browsing the installed <code class="filename">.mo</code> files, you
        can see which languages the Subversion client is able to
        speak.</p><p>The second way in which the locale is honored involves how
        <span><strong class="command">svn</strong></span> interprets your input.  The repository
        stores all paths, filenames, and log messages in Unicode,
        encoded as UTF-8.  In that sense, the repository is
        <em class="firstterm">internationalized</em>—that is, the
        repository is ready to accept input in any human language.
        This means, however, that the Subversion client is responsible
        for sending only UTF-8 filenames and log messages into the
        repository.  In order to do this, it must convert the data
        from the native locale into UTF-8.</p><p>For example, suppose you create a file
        named<code class="filename">caffè.txt</code>, and then when committing
        the file, you write the log message as «<span class="quote">Adesso il caffè
        è più forte</span>».  Both the filename and log message
        contain non-ASCII characters, but because your locale is set
        to <code class="literal">it_IT</code>, the Subversion client knows to
        interpret them as Italian.  It uses an Italian character set
        to convert the data to UTF-8 before sending them off to the
        repository.</p><p>Note that while the repository demands UTF-8 filenames and
        log messages, it <span class="emphasis"><em>does not</em></span> pay attention
        to file contents.  Subversion treats file contents as opaque
        strings of bytes, and neither client nor server makes an
        attempt to understand the character set or encoding of the
        contents.</p><div class="sidebar"><p class="title"><b>Character set conversion errors</b></p><p>While using Subversion, you might get hit with an error
          related to character set conversions:</p><pre class="screen">
svn: Can't convert string from native encoding to 'UTF-8':
…
svn: Can't convert string from 'UTF-8' to native encoding:
…
</pre><p>Errors like this typically occur when the Subversion
          client has received a UTF-8 string from the repository, but
          not all of the characters in that string can be represented
          using the encoding of the current locale.  For example, if
          your locale is <code class="literal">en_US</code> but a collaborator
          has committed a Japanese filename, you're likely to see this
          error when you receive the file during an <span><strong class="command">svn
          update</strong></span>.</p><p>The solution is either to set your locale to something
          which <span class="emphasis"><em>can</em></span> represent the incoming UTF-8
          data, or to change the filename or log message in the
          repository.  (And don't forget to slap your collaborator's
          hand—projects should decide on common languages ahead of
          time, so that all participants are using the same
          locale.)</p></div></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.advanced.externaldifftools"></a>Using External Differencing Tools</h2></div></div></div><p>The presence of <code class="option">--diff-cmd</code> and
      <code class="option">--diff3-cmd</code> options, and similarly named
      runtime configuration parameters (see <a href="#svn.advanced.confarea.opts.config" title="Config">la sezione chiamata «Config»</a>), can lead to a
      false notion of how easy it is to use external differencing (or
      «<span class="quote">diff</span>») and merge tools with Subversion.  While
      Subversion can use most of popular such tools available, the
      effort invested in setting this up often turns out to be
      non-trivial.</p><p>The interface between Subversion and external diff and merge
      tools harkens back to a time when Subversion's only contextual
      differencing capabilities were built around invocations of the
      GNU diffutils toolchain, specifically the
      <span><strong class="command">diff</strong></span> and <span><strong class="command">diff3</strong></span> utilities.
      To get the kind of behavior Subversion needed, it called these
      utilities with more than a handful of options and parameters,
      most of which were quite specific to the utilities.  Some time
      later, Subversion grew its own internal differencing library,
      and as a failover mechanism,
      <sup>[<a id="id4759747" href="#ftn.id4759747">40</a>]</sup>
      the <code class="option">--diff-cmd</code> and <code class="option">--diff3-cmd</code>
      options were added to the Subversion command-line client so
      users could more easily indicate that they preferred to use the
      GNU diff and diff3 utilities instead of the newfangled internal
      diff library.  If those options were used, Subversion would
      simply ignore the internal diff library, and fall back to
      running those external programs, lengthy argument lists and all.
      And that's where things remain today.</p><p>It didn't take long for folks to realize that having such
      easy configuration mechanisms for specifying that Subversion
      should use the external GNU diff and diff3 utilities located at
      a particular place on the system could be applied toward the use
      of other diff and merge tools, too.  After all, Subversion
      didn't actually verify that the things it was being told to run
      were members of the GNU diffutils toolchain.  But the only
      configurable aspect of using those external tools is their
      location on the system—not the option set, parameter
      order, etc.  Subversion continues throwing all those GNU utility
      options at your external diff tool regardless of whether or not
      that program can understand those options.  And that's where
      things get unintuitive for most users.</p><p>The key to using external diff and merge tools (other than
      GNU diff and diff3, of course) with Subversion is to use wrapper
      scripts which convert the input from Subversion into something
      that your differencing tool can understand, and then to convert
      the output of your tool back into a format which Subversion
      expects—the format that the GNU tools would have used.
      The following sections cover the specifics of those
      expectations.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Nota</h3><p>The decision on when to fire off a contextual diff or
        merge as part of a larger Subversion operation is made
        entirely by Subversion, and is affected by, among other
        things, whether or not the files being operated on are
        human-readable as determined by their
        <code class="literal">svn:mime-type</code> property.  This means, for
        example, that even if you had the niftiest Microsoft
        Word-aware differencing or merging tool in the Universe, it
        would never be invoked by Subversion so long as your versioned
        Word documents had a configured MIME type that denoted that
        they were not human-readable (such as
        <code class="literal">application/msword</code>).  For more about MIME
        type settings, see <a href="#svn.advanced.props.special.mime-type" title="svn:mime-type">la sezione chiamata «<code class="literal">svn:mime-type</code>»</a></p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.externaldifftools.diff"></a>External diff</h3></div></div></div><p>Subversion calls external diff programs with parameters
        suitable for the GNU diff utility, and expects only that the
        external program return with a successful error code.  For
        most alternative diff program, only the sixth and seventh
        arguments, the paths of the files which represent the left and
        right sides of the diff, respectively, are of interest.  Note
        that Subversion runs the diff program once per modified file
        covered by the Subversion operation, so if your program runs
        in an asynchronous fashion (or «<span class="quote">backgrounded</span>»),
        you might have several instances of it all running
        simultaneously.  Finally, Subversion expects that your program
        return an errorcode of 0 if your program detected differences,
        or 1 if it did not—any other errorcode is considered a
        fatal error.
        <sup>[<a id="id4759884" href="#ftn.id4759884">41</a>]</sup>
      </p><p><a href="#svn.advanced.externaldifftools.diff.ex-1" title="Esempio&#xA0;7.2.&#xA0;diffwrap.sh">Esempio 7.2, «diffwrap.sh»</a>
        and <a href="#svn.advanced.externaldifftools.diff.ex-2" title="Esempio&#xA0;7.3.&#xA0;diffwrap.bat">Esempio 7.3, «diffwrap.bat»</a>
        are templates for external diff tool wrappers in the Bourne
        shell and Windows batch scripting languages,
        respectively.</p><div class="example"><a id="svn.advanced.externaldifftools.diff.ex-1"></a><p class="title"><b>Esempio 7.2. diffwrap.sh</b></p><div class="example-contents"><pre class="programlisting">
#!/bin/sh

# Configure your favorite diff program here.
DIFF="/usr/local/bin/my-diff-tool"

# Subversion provides the paths we need as the sixth and seventh 
# parameters.
LEFT=${6}
RIGHT=${7}

# Call the diff command (change the following line to make sense for
# your merge program).
$DIFF --left $LEFT --right $RIGHT

# Return an errorcode of 0 if no differences were detected, 1 if some were.
# Any other errorcode will be treated as fatal.
</pre></div></div><br class="example-break" /><div class="example"><a id="svn.advanced.externaldifftools.diff.ex-2"></a><p class="title"><b>Esempio 7.3. diffwrap.bat</b></p><div class="example-contents"><pre class="programlisting">
@ECHO OFF

REM Configure your favorite diff program here.
SET DIFF="C:\Program Files\Funky Stuff\My Diff Tool.exe"

REM Subversion provides the paths we need as the sixth and seventh 
REM parameters.
SET LEFT=%6
SET RIGHT=%7

REM Call the diff command (change the following line to make sense for
REM your merge program).
%DIFF% --left %LEFT% --right %RIGHT%

REM Return an errorcode of 0 if no differences were detected, 1 if some were.
REM Any other errorcode will be treated as fatal.
</pre></div></div><br class="example-break" /></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.externaldifftools.diff3"></a>External diff3</h3></div></div></div><p>Subversion calls external merge programs with parameters
        suitable for the GNU diff3 utility, expecting that the
        external program return with a successful error code and that
        the full file contents which result from the completed merge
        operation are printed on the standard output stream (so that
        Subversion can redirect them into the appropriate version
        controlled file).  For most alternative merge programs, only
        the ninth, tenth, and eleventh arguments, the paths of the
        files which represent the «<span class="quote">mine</span>»,
        «<span class="quote">older</span>», and «<span class="quote">yours</span>» inputs,
        respectively, are of interest.  Note that because Subversion
        depends on the output of your merge program, you wrapper
        script must not exit before that output has been delivered to
        Subversion.  When it finally does exit, it should return an
        errorcode of 0 if the merge was successful, or 1 if unresolved
        conflicts remain in the output—any other errorcode is
        considered a fatal error.</p><p><a href="#svn.advanced.externaldifftools.diff3.ex-1" title="Esempio&#xA0;7.4.&#xA0;diff3wrap.sh">Esempio 7.4, «diff3wrap.sh»</a> 
        and <a href="#svn.advanced.externaldifftools.diff3.ex-2" title="Esempio&#xA0;7.5.&#xA0;diff3wrap.bat">Esempio 7.5, «diff3wrap.bat»</a> are
        templates for external merge tool wrappers in the Bourne shell
        and Windows batch scripting languages, respectively.</p><div class="example"><a id="svn.advanced.externaldifftools.diff3.ex-1"></a><p class="title"><b>Esempio 7.4. diff3wrap.sh</b></p><div class="example-contents"><pre class="programlisting">
#!/bin/sh

# Configure your favorite diff3/merge program here.
DIFF3="/usr/local/bin/my-merge-tool"

# Subversion provides the paths we need as the ninth, tenth, and eleventh 
# parameters.
MINE=${9}
OLDER=${10}
YOURS=${11}

# Call the merge command (change the following line to make sense for
# your merge program).
$DIFF3 --older $OLDER --mine $MINE --yours $YOURS

# After performing the merge, this script needs to print the contents
# of the merged file to stdout.  Do that in whatever way you see fit.
# Return an errorcode of 0 on successful merge, 1 if unresolved conflicts
# remain in the result.  Any other errorcode will be treated as fatal.
</pre></div></div><br class="example-break" /><div class="example"><a id="svn.advanced.externaldifftools.diff3.ex-2"></a><p class="title"><b>Esempio 7.5. diff3wrap.bat</b></p><div class="example-contents"><pre class="programlisting">
@ECHO OFF

REM Configure your favorite diff3/merge program here.
SET DIFF3="C:\Program Files\Funky Stuff\My Merge Tool.exe"

REM Subversion provides the paths we need as the ninth, tenth, and eleventh 
REM parameters.  But we only have access to nine parameters at a time, so we
REM shift our nine-parameter window twice to let us get to what we need.
SHIFT
SHIFT
SET MINE=%7
SET OLDER=%8
SET YOURS=%9

REM Call the merge command (change the following line to make sense for
REM your merge program).
%DIFF3% --older %OLDER% --mine %MINE% --yours %YOURS%

REM After performing the merge, this script needs to print the contents
REM of the merged file to stdout.  Do that in whatever way you see fit.
REM Return an errorcode of 0 on successful merge, 1 if unresolved conflicts
REM remain in the result.  Any other errorcode will be treated as fatal.
</pre></div></div><br class="example-break" /></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.advanced.reposurls"></a>Subversion Repository URLs</h2></div></div></div><p>As illustrated throughout this book, Subversion uses URLs to
      identify versioned resources in Subversion repositories.  For
      the most part, these URLs use the standard syntax, allowing for
      server names and port numbers to be specified as part of the
      URL:</p><pre class="screen">
$ svn checkout http://svn.example.com:9834/repos
…
</pre><p>But there are some nuances in Subversion's handling of URLs
      that are notable.  For example, URLs containing the
      <code class="literal">file:</code> access method (used for local
      repositories) must, in accordance with convention, have either a
      server name of <code class="literal">localhost</code> or no server name at
      all:</p><pre class="screen">
$ svn checkout file:///path/to/repos
…
$ svn checkout file://localhost/path/to/repos
…
</pre><p>Also, users of the <code class="literal">file:</code> scheme on
      Windows platforms will need to use an unofficially
      «<span class="quote">standard</span>» syntax for accessing repositories
      that are on the same machine, but on a different drive than
      the client's current working drive.  Either of the two
      following URL path syntaxes will work where
      <code class="literal">X</code> is the drive on which the repository
      resides:</p><pre class="screen">
C:\&gt; svn checkout file:///X:/path/to/repos
…
C:\&gt; svn checkout "file:///X|/path/to/repos"
…
</pre><p>In the second syntax, you need to quote the URL so that the
      vertical bar character is not interpreted as a pipe.  Also, note
      that a URL uses ordinary slashes even though the native
      (non-URL) form of a path on Windows uses backslashes.</p><p>Finally, it should be noted that the Subversion client will
      automatically encode URLs as necessary, just like a web browser
      does.  For example, if a URL contains a space or upper-ASCII
      character:</p><pre class="screen">
$ svn checkout "http://host/path with space/project/españa"
</pre><p>…then Subversion will escape the unsafe characters
      and behave as if you had typed:</p><pre class="screen">
$ svn checkout http://host/path%20with%20space/project/espa%C3%B1a
</pre><p>If the URL contains spaces, be sure to place it within quote
      marks, so that your shell treats the whole thing as a single
      argument to the <span><strong class="command">svn</strong></span> program.</p></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.id4752056" href="#id4752056">29</a>] </sup>The <code class="literal">APPDATA</code> environment variable
            points to the <code class="filename">Application Data</code> area,
            so you can always refer to this folder as
            <code class="filename">%APPDATA%\Subversion</code>.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4753304" href="#id4753304">30</a>] </sup>Anyone for potluck dinner?</p></div><div class="footnote"><p><sup>[<a id="ftn.id4753964" href="#id4753964">31</a>] </sup>If you're familiar with XML, this is pretty much the
            ASCII subset of the syntax for XML "Name".</p></div><div class="footnote"><p><sup>[<a id="ftn.id4754228" href="#id4754228">32</a>] </sup>Fixing spelling errors, grammatical gotchas, and
              «<span class="quote">just-plain-wrongness</span>» in commit log
              messages is perhaps the most common use case for the
              <code class="option">--revprop</code> option.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4754574" href="#id4754574">33</a>] </sup>The Windows filesystems use file extensions (such as
              <code class="literal">.EXE</code>, <code class="literal">.BAT</code>, and
              <code class="literal">.COM</code>) to denote executable
              files.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4754926" href="#id4754926">34</a>] </sup>The patterns are strictly for that
              directory—they do not carry recursively into
              subdirectories.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4754984" href="#id4754984">35</a>] </sup>Isn't that the whole point of a build system?</p></div><div class="footnote"><p><sup>[<a id="ftn.id4755393" href="#id4755393">36</a>] </sup>… or maybe even a section of a book …</p></div><div class="footnote"><p><sup>[<a id="ftn.id4757664" href="#id4757664">37</a>] </sup>«<span class="quote">You're not supposed to name it.  Once you name it,
          you start getting attached to it.</span>» — Mike
          Wazowski</p></div><div class="footnote"><p><sup>[<a id="ftn.id4757810" href="#id4757810">38</a>] </sup>606 N. Main Street, Wheaton, Illinois, is the home of
          the Wheaton History Center.  Get it—«<span class="quote">History
          Center</span>»?  It seemed appropriate….</p></div><div class="footnote"><p><sup>[<a id="ftn.id4758804" href="#id4758804">39</a>] </sup>And entirely bug-free, of course!</p></div><div class="footnote"><p><sup>[<a id="ftn.id4759747" href="#id4759747">40</a>] </sup>Subversion developers are good, but even the best make
          mistakes.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4759884" href="#id4759884">41</a>] </sup>The GNU diff manual page puts it this way: «<span class="quote">An
            exit status of 0 means no differences were found, 1 means some
            differences were found, and 2 means trouble.</span>»</p></div></div></div><div class="chapter" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title"><a id="svn.developer"></a>Capitolo 8. Developer Information</h2></div></div></div><div class="toc"><p><b>Sommario</b></p><dl><dt><span class="sect1"><a href="#svn.developer.layerlib">Layered Library Design</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.developer.layerlib.repos">Repository Layer</a></span></dt><dt><span class="sect2"><a href="#svn.developer.layerlib.ra">Repository Access Layer</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.developer.layerlib.ra.dav">RA-DAV (Repository Access Using HTTP/DAV)</a></span></dt><dt><span class="sect3"><a href="#svn.developer.layerlib.ra.svn">RA-SVN (Custom Protocol Repository Access)</a></span></dt><dt><span class="sect3"><a href="#svn.developer.layerlib.ra.local">RA-Local (Direct Repository Access)</a></span></dt><dt><span class="sect3"><a href="#svn.developer.layerlib.ra.yours">Your RA Library Here</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.developer.layerlib.client">Client Layer</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.developer.usingapi">Using the APIs</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.developer.usingapi.apr">The Apache Portable Runtime Library</a></span></dt><dt><span class="sect2"><a href="#svn.developer.usingapi.urlpath">URL and Path Requirements</a></span></dt><dt><span class="sect2"><a href="#svn.developer.usingapi.otherlangs">Using Languages Other than C and C++</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.developer.insidewc">Inside the Working Copy Administration Area</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.developer.insidewc.entries">The Entries File</a></span></dt><dt><span class="sect2"><a href="#svn.developer.insidewc.base-and-props">Pristine Copies and Property Files</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.developer.webdav">WebDAV</a></span></dt><dt><span class="sect1"><a href="#svn.developer.pools">Programming with Memory Pools</a></span></dt><dt><span class="sect1"><a href="#svn.developer.contrib">Contributing to Subversion</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.developer.contrib.join">Join the Community</a></span></dt><dt><span class="sect2"><a href="#svn.developer.contrib.get-code">Get the Source Code</a></span></dt><dt><span class="sect2"><a href="#svn.developer.contrib.hacking">Become Familiar with Community Policies</a></span></dt><dt><span class="sect2"><a href="#svn.developer.contrib.code-and-test">Make and Test Your Changes</a></span></dt><dt><span class="sect2"><a href="#svn.developer.contrib.submit">Donate Your Changes</a></span></dt></dl></dd></dl></div><div class="simplesect" lang="it" xml:lang="it"><div class="titlepage"></div><p>Subversion is an open-source software project developed
      under an Apache-style software license.  The project is
      financially backed by CollabNet, Inc., a California-based
      software development company.  The community that has formed
      around the development of Subversion always welcomes new members
      who can donate their time and attention to the project.
      Volunteers are encouraged to assist in any way they can, whether
      that means finding and diagnosing bugs, refining existing source
      code, or fleshing out whole new features.</p><p>This chapter is for those who wish to assist in the
      continued evolution of Subversion by actually getting their
      hands dirty with the source code.  We will cover some of the
      software's more intimate details, the kind of technical
      nitty-gritty that those developing Subversion itself—or
      writing entirely new tools based on the Subversion
      libraries—should be aware of.  If you don't foresee
      yourself participating with the software at such a level, feel
      free to skip this chapter with confidence that your experience
      as a Subversion user will not be affected.</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.developer.layerlib"></a>Layered Library Design</h2></div></div></div><p>Subversion has a modular design, implemented as a collection
      of C libraries.  Each library has a well-defined purpose and
      interface, and most modules are said to exist in one of three
      main layers—the Repository Layer, the Repository Access
      (RA) Layer, or the Client Layer.  We will examine these layers
      shortly, but first, see our brief inventory of Subversion's
      libraries in <a href="#svn.developer.layerlib.tbl-1" title="Tabella&#xA0;8.1.&#xA0;A Brief Inventory of the Subversion Libraries">Tabella 8.1, «A Brief Inventory of the Subversion Libraries»</a>.  For the sake
      of consistency, we will refer to the libraries by their
      extensionless Unix library names (e.g.: libsvn_fs, libsvn_wc,
      mod_dav_svn).</p><div class="table"><a id="svn.developer.layerlib.tbl-1"></a><p class="title"><b>Tabella 8.1. A Brief Inventory of the Subversion Libraries</b></p><div class="table-contents"><table summary="A Brief Inventory of the Subversion Libraries" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Library</th><th>Description</th></tr></thead><tbody><tr><td>libsvn_client</td><td>Primary interface for client programs</td></tr><tr><td>libsvn_delta</td><td>Tree and byte-stream differencing routines</td></tr><tr><td>libsvn_diff</td><td>Contextual differencing and merging routines</td></tr><tr><td>libsvn_fs</td><td>Filesystem commons and module loader</td></tr><tr><td>libsvn_fs_base</td><td>The Berkeley DB filesystem back-end</td></tr><tr><td>libsvn_fs_fs</td><td>The native filesystem (FSFS) back-end</td></tr><tr><td>libsvn_ra</td><td>Repository Access commons and module loader</td></tr><tr><td>libsvn_ra_dav</td><td>The WebDAV Repository Access module</td></tr><tr><td>libsvn_ra_local</td><td>The local Repository Access module</td></tr><tr><td>libsvn_ra_svn</td><td>The custom protocol Repository Access module</td></tr><tr><td>libsvn_repos</td><td>Repository interface</td></tr><tr><td>libsvn_subr</td><td>Miscellaneous helpful subroutines</td></tr><tr><td>libsvn_wc</td><td>The working copy management library</td></tr><tr><td>mod_authz_svn</td><td>Apache authorization module for Subversion
            repositories access via WebDAV</td></tr><tr><td>mod_dav_svn</td><td>Apache module for mapping WebDAV operations to
            Subversion ones</td></tr></tbody></table></div></div><br class="table-break" /><p>The fact that the word «<span class="quote">miscellaneous</span>» only
      appears once in <a href="#svn.developer.layerlib.tbl-1" title="Tabella&#xA0;8.1.&#xA0;A Brief Inventory of the Subversion Libraries">Tabella 8.1, «A Brief Inventory of the Subversion Libraries»</a> is a good
      sign.  The Subversion development team is serious about making
      sure that functionality lives in the right layer and libraries.
      Perhaps the greatest advantage of the modular design is its lack
      of complexity from a developer's point of view.  As a developer,
      you can quickly formulate that kind of «<span class="quote">big
      picture</span>» that allows you to pinpoint the location of
      certain pieces of functionality with relative ease.</p><p>Another benefit of modularity is the ability to replace a
      given module with a whole new library that implements the same
      API without affecting the rest of the code base.  In some sense,
      this happens within Subversion already.  The libsvn_ra_dav,
      libsvn_ra_local, and libsvn_ra_svn all implement the same
      interface.  And all three communicate with the Repository
      Layer—libsvn_ra_dav and libsvn_ra_svn do so across a
      network, and libsvn_ra_local connects to it directly.  The
      libsvn_fs_base and libsvn_fs_fs libraries are another example of
      this.</p><p>The client itself also highlights modularity in the
      Subversion design.  While Subversion itself comes with only a
      command-line client program, there are several third party
      programs which provide various forms of client GUI.  These GUIs
      use the same APIs that the stock command-line client does.
      Subversion's libsvn_client library is the one-stop shop for most
      of the functionality necessary for designing a working
      Subversion client (see <a href="#svn.developer.layerlib.client" title="Client Layer">la sezione chiamata «Client Layer»</a>).</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.developer.layerlib.repos"></a>Repository Layer</h3></div></div></div><p>When referring to Subversion's Repository Layer, we're
        generally talking about two libraries—the repository
        library, and the filesystem library.  These libraries provide
        the storage and reporting mechanisms for the various revisions
        of your version-controlled data.  This layer is connected to
        the Client Layer via the Repository Access Layer, and is, from
        the perspective of the Subversion user, the stuff at the
        «<span class="quote">other end of the line.</span>»</p><p>The Subversion Filesystem is accessed via the libsvn_fs
        API, and is not a kernel-level filesystem that one would
        install in an operating system (like the Linux ext2 or NTFS),
        but a virtual filesystem.  Rather than storing
        «<span class="quote">files</span>» and «<span class="quote">directories</span>» as real
        files and directories (as in, the kind you can navigate
        through using your favorite shell program), it uses one of two
        available abstract storage backends—either a Berkeley DB
        database environment, or a flat-file representation.  (To
        learn more about the two repository back-ends, see <a href="#svn.reposadmin.basics.backends" title="Repository Data Stores">la sezione chiamata «Repository Data Stores»</a>.)  However, there has been
        considerable interest by the development community in giving
        future releases of Subversion the ability to use other
        back-end database systems, perhaps through a mechanism such as
        Open Database Connectivity (ODBC).</p><p>The filesystem API exported by libsvn_fs contains the
        kinds of functionality you would expect from any other
        filesystem API: you can create and remove files and
        directories, copy and move them around, modify file contents,
        and so on.  It also has features that are not quite as common,
        such as the ability to add, modify, and remove metadata
        («<span class="quote">properties</span>») on each file or directory.
        Furthermore, the Subversion Filesystem is a versioning
        filesystem, which means that as you make changes to your
        directory tree, Subversion remembers what your tree looked
        like before those changes.  And before the previous changes.
        And the previous ones.  And so on, all the way back through
        versioning time to (and just beyond) the moment you first
        started adding things to the filesystem.</p><p>All the modifications you make to your tree are done
        within the context of a Subversion transaction.  The following
        is a simplified general routine for modifying your
        filesystem:</p><div class="orderedlist"><ol type="1"><li><p>Begin a Subversion transaction.</p></li><li><p>Make your changes (adds, deletes, property
            modifications, etc.).</p></li><li><p>Commit your transaction.</p></li></ol></div><p>Once you have committed your transaction, your filesystem
        modifications are permanently stored as historical artifacts.
        Each of these cycles generates a single new revision of your
        tree, and each revision is forever accessible as an immutable
        snapshot of «<span class="quote">the way things were.</span>»</p><div class="sidebar"><p class="title"><b>The Transaction Distraction</b></p><p>The notion of a Subversion transaction, especially given
          its close proximity to the database code in libsvn_fs, can
          become easily confused with the transaction support provided
          by the underlying database itself.  Both types of
          transaction exist to provide atomicity and isolation.  In
          other words, transactions give you the ability to perform a
          set of actions in an «<span class="quote">all or nothing</span>»
          fashion—either all the actions in the set complete
          with success, or they all get treated as if
          <span class="emphasis"><em>none</em></span> of them ever happened—and in
          a way that does not interfere with other processes acting on
          the data.</p><p>Database transactions generally encompass small
          operations related specifically to the modification of data
          in the database itself (such as changing the contents of a
          table row).  Subversion transactions are larger in scope,
          encompassing higher-level operations like making
          modifications to a set of files and directories which are
          intended to be stored as the next revision of the filesystem
          tree.  If that isn't confusing enough, consider this:
          Subversion uses a database transaction during the creation
          of a Subversion transaction (so that if the creation of
          Subversion transaction fails, the database will look as if
          we had never attempted that creation in the first
          place)!</p><p>Fortunately for users of the filesystem API, the
          transaction support provided by the database system itself
          is hidden almost entirely from view (as should be expected
          from a properly modularized library scheme).  It is only
          when you start digging into the implementation of the
          filesystem itself that such things become visible (or
          interesting).</p></div><p>Most of the functionality provided by the filesystem
        interface comes as an action that occurs on a filesystem path.
        That is, from outside of the filesystem, the primary mechanism
        for describing and accessing the individual revisions of files
        and directories comes through the use of path strings like
        <code class="filename">/foo/bar</code>, just as if you were addressing
        files and directories through your favorite shell program.
        You add new files and directories by passing their paths-to-be
        to the right API functions.  You query for information about
        them by the same mechanism.</p><p>Unlike most filesystems, though, a path alone is not
        enough information to identify a file or directory in
        Subversion.  Think of a directory tree as a two-dimensional
        system, where a node's siblings represent a sort of
        left-and-right motion, and descending into subdirectories a
        downward motion.  <a href="#svn.developer.layerlib.repos.dia-1" title="Figura&#xA0;8.1.&#xA0;Files and directories in two dimensions">Figura 8.1, «Files and directories in two dimensions»</a> shows
        a typical representation of a tree as exactly that.</p><div class="figure"><a id="svn.developer.layerlib.repos.dia-1"></a><p class="title"><b>Figura 8.1. Files and directories in two dimensions</b></p><div class="figure-contents"><div><img src="images/ch08dia1.png" alt="Files and directories in two dimensions" /></div></div></div><br class="figure-break" /><p>Of course, the Subversion filesystem has a nifty third
        dimension that most filesystems do not have—Time!
        <sup>[<a id="id4760819" href="#ftn.id4760819">42</a>]</sup>
        In the filesystem interface, nearly every function that has a
        <em class="parameter"><code>path</code></em> argument also expects a
        <em class="parameter"><code>root</code></em> argument.  This
        <span class="structname">svn_fs_root_t</span> argument describes
        either a revision or a Subversion transaction (which is
        usually just a revision-to-be), and provides that
        third-dimensional context needed to understand the difference
        between <code class="filename">/foo/bar</code> in revision 32, and the
        same path as it exists in revision 98.  <a href="#svn.developer.layerlib.repos.dia-2" title="Figura&#xA0;8.2.&#xA0;Versioning time&#x2014;the third dimension!">Figura 8.2, «Versioning time—the third dimension!»</a> shows revision history as an
        added dimension to the Subversion filesystem universe.</p><div class="figure"><a id="svn.developer.layerlib.repos.dia-2"></a><p class="title"><b>Figura 8.2. Versioning time—the third dimension!</b></p><div class="figure-contents"><div><img src="images/ch08dia2.png" alt="Versioning time&#x2014;the third dimension!" /></div></div></div><br class="figure-break" /><p>As we mentioned earlier, the libsvn_fs API looks and feels
        like any other filesystem, except that it has this wonderful
        versioning capability.  It was designed to be usable by any
        program interested in a versioning filesystem.  Not
        coincidentally, Subversion itself is interested in that
        functionality.  But while the filesystem API should be
        sufficient for basic file and directory versioning support,
        Subversion wants more—and that is where libsvn_repos
        comes in.</p><p>The Subversion repository library (libsvn_repos) is
        basically a wrapper library around the filesystem
        functionality.  This library is responsible for creating the
        repository layout, making sure that the underlying filesystem
        is initialized, and so on.  Libsvn_repos also implements a set
        of hooks—scripts that are executed by the repository
        code when certain actions take place.  These scripts are
        useful for notification, authorization, or whatever purposes
        the repository administrator desires.  This type of
        functionality, and other utilities provided by the repository
        library, are not strictly related to implementing a versioning
        filesystem, which is why it was placed into its own
        library.</p><p>Developers who wish to use the libsvn_repos API will find
        that it is not a complete wrapper around the filesystem
        interface.  That is, only certain major events in the general
        cycle of filesystem activity are wrapped by the repository
        interface.  Some of these include the creation and commit of
        Subversion transactions, and the modification of revision
        properties.  These particular events are wrapped by the
        repository layer because they have hooks associated with them.
        In the future, other events may be wrapped by the repository
        API.  All of the remaining filesystem interaction will
        continue to occur directly via the libsvn_fs API, though.</p><p>For example, here is a code segment that illustrates the
        use of both the repository and filesystem interfaces to create
        a new revision of the filesystem in which a directory is
        added.  Note that in this example (and all others throughout
        this book), the <code class="function">SVN_ERR()</code> macro simply
        checks for a non-successful error return from the function it
        wraps, and returns that error if it exists.</p><div class="example"><a id="svn.developer.layerlib.repos.ex-1"></a><p class="title"><b>Esempio 8.1. Using the Repository Layer</b></p><div class="example-contents"><pre class="programlisting">
/* Create a new directory at the path NEW_DIRECTORY in the Subversion
   repository located at REPOS_PATH.  Perform all memory allocation in
   POOL.  This function will create a new revision for the addition of
   NEW_DIRECTORY.  */
static svn_error_t *
make_new_directory (const char *repos_path,
                    const char *new_directory,
                    apr_pool_t *pool)
{
  svn_error_t *err;
  svn_repos_t *repos;
  svn_fs_t *fs;
  svn_revnum_t youngest_rev;
  svn_fs_txn_t *txn;
  svn_fs_root_t *txn_root;
  const char *conflict_str;

  /* Open the repository located at REPOS_PATH.  */
  SVN_ERR (svn_repos_open (&amp;repos, repos_path, pool));

  /* Get a pointer to the filesystem object that is stored in
     REPOS.  */
  fs = svn_repos_fs (repos);

  /* Ask the filesystem to tell us the youngest revision that
     currently exists.  */
  SVN_ERR (svn_fs_youngest_rev (&amp;youngest_rev, fs, pool));

  /* Begin a new transaction that is based on YOUNGEST_REV.  We are
     less likely to have our later commit rejected as conflicting if we
     always try to make our changes against a copy of the latest snapshot
     of the filesystem tree.  */
  SVN_ERR (svn_fs_begin_txn (&amp;txn, fs, youngest_rev, pool));

  /* Now that we have started a new Subversion transaction, get a root
     object that represents that transaction.  */
  SVN_ERR (svn_fs_txn_root (&amp;txn_root, txn, pool));
  
  /* Create our new directory under the transaction root, at the path
     NEW_DIRECTORY.  */
  SVN_ERR (svn_fs_make_dir (txn_root, new_directory, pool));

  /* Commit the transaction, creating a new revision of the filesystem
     which includes our added directory path.  */
  err = svn_repos_fs_commit_txn (&amp;conflict_str, repos, 
                                 &amp;youngest_rev, txn, pool);
  if (! err)
    {
      /* No error?  Excellent!  Print a brief report of our success.  */
      printf ("Directory '%s' was successfully added as new revision "
              "'%ld'.\n", new_directory, youngest_rev);
    }
  else if (err-&gt;apr_err == SVN_ERR_FS_CONFLICT)
    {
      /* Uh-oh.  Our commit failed as the result of a conflict
         (someone else seems to have made changes to the same area 
         of the filesystem that we tried to modify).  Print an error
         message.  */
      printf ("A conflict occurred at path '%s' while attempting "
              "to add directory '%s' to the repository at '%s'.\n", 
              conflict_str, new_directory, repos_path);
    }
  else
    {
      /* Some other error has occurred.  Print an error message.  */
      printf ("An error occurred while attempting to add directory '%s' "
              "to the repository at '%s'.\n", 
              new_directory, repos_path);
    }

  /* Return the result of the attempted commit to our caller.  */
  return err;
} 
</pre></div></div><br class="example-break" /><p>In the previous code segment, calls were made to both the
        repository and filesystem interfaces.  We could just as easily
        have committed the transaction using
        <code class="function">svn_fs_commit_txn()</code>.  But the filesystem
        API knows nothing about the repository library's hook
        mechanism.  If you want your Subversion repository to
        automatically perform some set of non-Subversion tasks every
        time you commit a transaction (like, for example, sending an
        email that describes all the changes made in that transaction
        to your developer mailing list), you need to use the
        libsvn_repos-wrapped version of that
        function—<code class="function">svn_repos_fs_commit_txn()</code>.
        This function will actually first run the
        <code class="literal">pre-commit</code> hook script if one exists, then
        commit the transaction, and finally will run a
        <code class="literal">post-commit</code> hook script.  The hooks provide
        a special kind of reporting mechanism that does not really
        belong in the core filesystem library itself.  (For more
        information regarding Subversion's repository hooks, see <a href="#svn.reposadmin.create.hooks" title="Hook Scripts">la sezione chiamata «Hook Scripts»</a>.)</p><p>The hook mechanism requirement is but one of the reasons
        for the abstraction of a separate repository library from the
        rest of the filesystem code.  The libsvn_repos API provides
        several other important utilities to Subversion.  These
        include the abilities to:</p><div class="orderedlist"><ol type="1"><li><p>create, open, destroy, and perform recovery steps on a
            Subversion repository and the filesystem included in that
            repository.</p></li><li><p>describe the differences between two filesystem
            trees.</p></li><li><p>query for the commit log messages
            associated with all (or some) of the revisions in which a
            set of files was modified in the filesystem.</p></li><li><p>generate a human-readable «<span class="quote">dump</span>» of the
            filesystem, a complete representation of the revisions in
            the filesystem.</p></li><li><p>parse that dump format, loading the dumped revisions
            into a different Subversion repository.</p></li></ol></div><p>As Subversion continues to evolve, the repository library
        will grow with the filesystem library to offer increased
        functionality and configurable option support.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.developer.layerlib.ra"></a>Repository Access Layer</h3></div></div></div><p>If the Subversion Repository Layer is at «<span class="quote">the other
        end of the line</span>», the Repository Access Layer is the
        line itself.  Charged with marshalling data between the client
        libraries and the repository, this layer includes the
        libsvn_ra module loader library, the RA modules themselves
        (which currently includes libsvn_ra_dav, libsvn_ra_local, and
        libsvn_ra_svn), and any additional libraries needed by one or
        more of those RA modules, such as the mod_dav_svn Apache
        module with which libsvn_ra_dav communicates or
        libsvn_ra_svn's server, <span><strong class="command">svnserve</strong></span>.</p><p>Since Subversion uses URLs to identify its repository
        resources, the protocol portion of the URL schema (usually
        <code class="literal">file:</code>, <code class="literal">http:</code>,
        <code class="literal">https:</code>, or <code class="literal">svn:</code>) is used
        to determine which RA module will handle the communications.
        Each module registers a list of the protocols it knows how to
        «<span class="quote">speak</span>» so that the RA loader can, at runtime,
        determine which module to use for the task at hand.  You can
        determine which RA modules are available to the Subversion
        command-line client, and what protocols they claim to support,
        by running <span><strong class="command">svn --version</strong></span>:</p><pre class="screen">
$ svn --version
svn, version 1.2.3 (r15833)
   compiled Sep 13 2005, 22:45:22

Copyright (C) 2000-2005 CollabNet.
Subversion is open source software, see http://subversion.tigris.org/
This product includes software developed by CollabNet (http://www.Collab.Net/).

The following repository access (RA) modules are available:

* ra_dav : Module for accessing a repository via WebDAV (DeltaV) protocol.
  - handles 'http' scheme
  - handles 'https' scheme
* ra_svn : Module for accessing a repository using the svn network protocol.
  - handles 'svn' scheme
* ra_local : Module for accessing a repository on local disk.
  - handles 'file' scheme

</pre><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.developer.layerlib.ra.dav"></a>RA-DAV (Repository Access Using HTTP/DAV)</h4></div></div></div><p>The libsvn_ra_dav library is designed for use by clients
          that are being run on different machines than the servers
          with which they communicating, specifically servers reached
          using URLs that contain the <code class="literal">http:</code> or
          <code class="literal">https:</code> protocol portions.  To understand
          how this module works, we should first mention a couple of
          other key components in this particular configuration of the
          Repository Access Layer—the powerful Apache HTTP
          Server, and the Neon HTTP/WebDAV client library.</p><p>Subversion's primary network server is the Apache HTTP
          Server.  Apache is a time-tested, extensible open-source
          server process that is ready for serious use.  It can
          sustain a high network load and runs on many platforms.  The
          Apache server supports a number of different standard
          authentication protocols, and can be extended through the
          use of modules to support many others.  It also supports
          optimizations like network pipelining and caching.  By using
          Apache as a server, Subversion gets all of these features
          for free.  And since most firewalls already allow HTTP
          traffic to pass through, system administrators typically
          don't even have to change their firewall configurations to
          allow Subversion to work.</p><p>Subversion uses HTTP and WebDAV (with DeltaV) to
          communicate with an Apache server.  You can read more about
          this in the WebDAV section of this chapter, but in short,
          WebDAV and DeltaV are extensions to the standard HTTP 1.1
          protocol that enable sharing and versioning of files over
          the web.  Apache 2.0 and later versions come with mod_dav,
          an Apache module that understands the DAV extensions to
          HTTP.  Subversion itself supplies mod_dav_svn, though, which
          is another Apache module that works in conjunction with
          (really, as a back-end to) mod_dav to provide Subversion's
          specific implementations of WebDAV and DeltaV.</p><p>When communicating with a repository over HTTP, the RA
          loader library chooses libsvn_ra_dav as the proper access
          module.  The Subversion client makes calls into the generic
          RA interface, and libsvn_ra_dav maps those calls (which
          embody rather large-scale Subversion actions) to a set of
          HTTP/WebDAV requests.  Using the Neon library, libsvn_ra_dav
          transmits those requests to the Apache server.  Apache
          receives these requests (exactly as it does generic HTTP
          requests that your web browser might make), notices that the
          requests are directed at a URL that is configured as a DAV
          location (using the <code class="literal">&lt;Location&gt;</code>
          directive in <code class="filename">httpd.conf</code>), and hands the
          request off to its own mod_dav module.  When properly
          configured, mod_dav knows to use Subversion's mod_dav_svn for
          any filesystem-related needs, as opposed to the generic
          mod_dav_fs that comes with Apache.  So ultimately, the client
          is communicating with mod_dav_svn, which binds directly to the
          Subversion Repository Layer.</p><p>That was a simplified description of the actual
          exchanges taking place, though.  For example, the Subversion
          repository might be protected by Apache's authorization
          directives.  This could result in initial attempts to
          communicate with the repository being rejected by Apache on
          authorization grounds.  At this point, libsvn_ra_dav gets
          back the notice from Apache that insufficient identification
          was supplied, and calls back into the Client Layer to get
          some updated authentication data.  If the data is supplied
          correctly, and the user has the permissions that Apache
          seeks, libsvn_ra_dav's next automatic attempt at performing
          the original operation will be granted, and all will be
          well.  If sufficient authentication information cannot be
          supplied, the request will ultimately fail, and the client
          will report the failure to the user.</p><p>By using Neon and Apache, Subversion gets free
          functionality in several other complex areas, too.  For
          example, if Neon finds the OpenSSL libraries, it allows the
          Subversion client to attempt to use SSL-encrypted
          communications with the Apache server (whose own mod_ssl can
          «<span class="quote">speak the language</span>»).  Also, both Neon itself
          and Apache's mod_deflate can understand the
          «<span class="quote">deflate</span>» algorithm (the same one used by the
          PKZIP and gzip programs), so requests can be sent in smaller,
          compressed chunks across the wire.  Other complex features
          that Subversion hopes to support in the future include the
          ability to automatically handle server-specified redirects
          (for example, when a repository has been moved to a new
          canonical URL) and taking advantage of HTTP
          pipelining.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.developer.layerlib.ra.svn"></a>RA-SVN (Custom Protocol Repository Access)</h4></div></div></div><p>In addition to the standard HTTP/WebDAV protocol,
          Subversion also provides an RA implementation that uses a
          custom protocol.  The libsvn_ra_svn module implements
          its own network socket connectivity, and communicates with a
          stand-alone server—the <code class="filename">svnserve</code>
          program—on the machine that hosts the
          repository.  Clients access the repository using the
          <code class="literal">svn://</code> schema.</p><p>This RA implementation lacks most of the advantages of
          Apache mentioned in the previous section; however, it may be
          appealing to some system administrators nonetheless.  It is
          dramatically easier to configure and run; setting up an
          <code class="filename">svnserve</code> process is nearly
          instantaneous.  It is also much smaller (in terms of lines
          of code) than Apache, making it much easier to audit, for
          security reasons or otherwise.  Furthermore, some system
          administrators may already have an SSH security
          infrastructure in place, and want Subversion to use it.
          Clients using ra_svn can easily tunnel the protocol over
          SSH.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.developer.layerlib.ra.local"></a>RA-Local (Direct Repository Access)</h4></div></div></div><p>Not all communications with a Subversion repository
          require a powerhouse server process and a network layer.
          For users who simply wish to access the repositories on
          their local disk, they may do so using
          <code class="literal">file:</code> URLs and the functionality provided
          by libsvn_ra_local.  This RA module binds directly with the
          repository and filesystem libraries, so no network
          communication is required at all.</p><p>Subversion requires that the server name included as part
          of the <code class="literal">file:</code> URL be either
          <code class="literal">localhost</code> or empty, and that there be no
          port specification.  In other words, your URLs should look
          like either
          <code class="literal">file://localhost/path/to/repos</code> or
          <code class="literal">file:///path/to/repos</code>.</p><p>Also, be aware that Subversion's
          <code class="literal">file:</code> URLs cannot be used in a regular
          web browser the way typical <code class="literal">file:</code> URLs
          can.  When you attempt to view a <code class="literal">file:</code>
          URL in a regular web browser, it reads and displays the
          contents of the file at that location by examining the
          filesystem directly.  However, Subversion's resources exist
          in a virtual filesystem (see <a href="#svn.developer.layerlib.repos" title="Repository Layer">la sezione chiamata «Repository Layer»</a>), and your browser will not
          understand how to read that filesystem.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.developer.layerlib.ra.yours"></a>Your RA Library Here</h4></div></div></div><p>For those who wish to access a Subversion repository
          using still another protocol, that is precisely why the
          Repository Access Layer is modularized!  Developers can
          simply write a new library that implements the RA interface
          on one side and communicates with the repository on the
          other.  Your new library can use existing network protocols,
          or you can invent your own.  You could use inter-process
          communication (IPC) calls, or—let's get crazy, shall
          we?—you could even implement an email-based protocol.
          Subversion supplies the APIs; you supply the creativity.</p></div></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.developer.layerlib.client"></a>Client Layer</h3></div></div></div><p>On the client side, the Subversion working copy is where
        all the action takes place.  The bulk of functionality
        implemented by the client-side libraries exists for the sole
        purpose of managing working copies—directories full of
        files and other subdirectories which serve as a sort of local,
        editable «<span class="quote">reflection</span>» of one or more repository
        locations—and propagating changes to and from the
        Repository Access layer.</p><p>Subversion's working copy library, libsvn_wc, is directly
        responsible for managing the data in the working copies.  To
        accomplish this, the library stores administrative information
        about each working copy directory within a special
        subdirectory.  This subdirectory, named
        <code class="filename">.svn</code>, is present in each working copy
        directory and contains various other files and directories
        which record state and provide a private workspace for
        administrative action.  For those familiar with CVS, this
        <code class="filename">.svn</code> subdirectory is similar in purpose
        to the <code class="filename">CVS</code> administrative directories
        found in CVS working copies.  For more information about the
        <code class="filename">.svn</code> administrative area, see <a href="#svn.developer.insidewc" title="Inside the Working Copy Administration Area">la sezione chiamata «Inside the Working Copy Administration Area»</a>in this chapter.</p><p>The Subversion client library, libsvn_client, has the
        broadest responsibility; its job is to mingle the
        functionality of the working copy library with that of the
        Repository Access Layer, and then to provide the highest-level
        API to any application that wishes to perform general revision
        control actions.  For example, the function
        <code class="function">svn_client_checkout()</code> takes a URL as an
        argument.  It passes this URL to the RA layer and opens an
        authenticated session with a particular repository.  It then
        asks the repository for a certain tree, and sends this tree
        into the working copy library, which then writes a full
        working copy to disk (<code class="filename">.svn</code> directories
        and all).</p><p>The client library is designed to be used by any
        application.  While the Subversion source code includes a
        standard command-line client, it should be very easy to write
        any number of GUI clients on top of the client library.  New
        GUIs (or any new client, really) for Subversion need not be
        clunky wrappers around the included command-line
        client—they have full access via the libsvn_client API
        to same functionality, data, and callback mechanisms that the
        command-line client uses.</p><div class="sidebar"><p class="title"><b>Binding Directly—A Word About Correctness</b></p><p>Why should your GUI program bind directly with a
          libsvn_client instead of acting as a wrapper around a
          command-line program?  Besides simply being more efficient,
          this can address potential correctness issues as well.  A
          command-line program (like the one supplied with Subversion)
          that binds to the client library needs to effectively
          translate feedback and requested data bits from C types to
          some form of human-readable output.  This type of
          translation can be lossy.  That is, the program may not
          display all of the information harvested from the API, or
          may combine bits of information for compact representation.</p><p>If you wrap such a command-line program with yet another
          program, the second program has access only to
          already-interpreted (and as we mentioned, likely incomplete)
          information, which it must <span class="emphasis"><em>again</em></span>
          translate into <span class="emphasis"><em>its</em></span> representation
          format.  With each layer of wrapping, the integrity of the
          original data is potentially tainted more and more, much
          like the result of making a copy of a copy (of a copy …)
          of a favorite audio or video cassette.</p></div></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.developer.usingapi"></a>Using the APIs</h2></div></div></div><p>Developing applications against the Subversion library APIs
      is fairly straightforward.  All of the public header files live
      in the <code class="filename">subversion/include</code> directory of the
      source tree.  These headers are copied into your system
      locations when you build and install Subversion itself from
      source.  These headers represent the entirety of the functions
      and types meant to be accessible by users of the Subversion
      libraries.</p><p>The first thing you might notice is that Subversion's
      datatypes and functions are namespace protected.  Every public
      Subversion symbol name begins with <code class="literal">svn_</code>,
      followed by a short code for the library in which the symbol is
      defined (such as <code class="literal">wc</code>,
      <code class="literal">client</code>, <code class="literal">fs</code>, etc.),
      followed by a single underscore (<code class="literal">_</code>) and
      then the rest of the symbol name.  Semi-public functions (used
      among source files of a given library but not by code outside
      that library, and found inside the library directories
      themselves) differ from this naming scheme in that instead of a
      single underscore after the library code, they use a double
      underscore (<code class="literal">__</code>).  Functions that are private
      to a given source file have no special prefixing, and are declared
      <code class="literal">static</code>.  Of course, a compiler isn't
      interested in these naming conventions, but they help to clarify
      the scope of a given function or datatype.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.developer.usingapi.apr"></a>The Apache Portable Runtime Library</h3></div></div></div><p>Along with Subversion's own datatypes, you will see many
        references to datatypes that begin with
        <code class="literal">apr_</code>—symbols from the Apache
        Portable Runtime (APR) library.  APR is Apache's portability
        library, originally carved out of its server code as an
        attempt to separate the OS-specific bits from the
        OS-independent portions of the code.  The result was a library
        that provides a generic API for performing operations that
        differ mildly—or wildly—from OS to OS.  While the
        Apache HTTP Server was obviously the first user of the APR
        library, the Subversion developers immediately recognized the
        value of using APR as well.  This means that there are
        practically no OS-specific code portions in Subversion itself.
        Also, it means that the Subversion client compiles and runs
        anywhere that the server does.  Currently this list includes
        all flavors of Unix, Win32, BeOS, OS/2, and Mac OS X.</p><p>In addition to providing consistent implementations of
        system calls that differ across operating systems,
        <sup>[<a id="id4761948" href="#ftn.id4761948">43</a>]</sup>
        APR gives Subversion immediate access to many custom
        datatypes, such as dynamic arrays and hash tables.  Subversion
        uses these types extensively throughout the codebase.  But
        perhaps the most pervasive APR datatype, found in nearly every
        Subversion API prototype, is the
        <span class="structname">apr_pool_t</span>—the APR memory pool.
        Subversion uses pools internally for all its memory allocation
        needs (unless an external library requires a different memory
        management schema for data passed through its API),
        <sup>[<a id="id4761969" href="#ftn.id4761969">44</a>]</sup>
        and while a person coding against the Subversion APIs is
        not required to do the same, they are required to provide
        pools to the API functions that need them.  This means that
        users of the Subversion API must also link against APR, must
        call <code class="function">apr_initialize()</code> to initialize the
        APR subsystem, and then must acquire a pool for use with
        Subversion API calls.  See <a href="#svn.developer.pools" title="Programming with Memory Pools">la sezione chiamata «Programming with Memory Pools»</a>
        for more information.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.developer.usingapi.urlpath"></a>URL and Path Requirements</h3></div></div></div><p>With remote version control operation as the whole point
        of Subversion's existence, it makes sense that some attention
        has been paid to internationalization (i18n) support.  After
        all, while «<span class="quote">remote</span>» might mean «<span class="quote">across the
        office</span>», it could just as well mean «<span class="quote">across the
        globe.</span>» To facilitate this, all of Subversion's public
        interfaces that accept path arguments expect those paths to be
        canonicalized, and encoded in UTF-8.  This means, for example,
        that any new client binary that drives the libsvn_client
        interface needs to first convert paths from the
        locale-specific encoding to UTF-8 before passing those paths
        to the Subversion libraries, and then re-convert any resultant
        output paths from Subversion back into the locale's encoding
        before using those paths for non-Subversion purposes.
        Fortunately, Subversion provides a suite of functions (see
        <code class="filename">subversion/include/svn_utf.h</code>) that can be
        used by any program to do these conversions.</p><p>Also, Subversion APIs require all URL parameters to be
        properly URI-encoded.  So, instead of passing <code class="systemitem">file:///home/username/My File.txt</code> as
        the URL of a file named <code class="literal">My File.txt</code>, you
        need to pass <code class="systemitem">file:///home/username/My%20File.txt</code>.
        Again, Subversion supplies helper functions that your
        application can
        use—<code class="function">svn_path_uri_encode()</code> and
        <code class="function">svn_path_uri_decode()</code>, for URI encoding and
        decoding, respectively.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.developer.usingapi.otherlangs"></a>Using Languages Other than C and C++</h3></div></div></div><p>If you are interested in using the Subversion libraries in
        conjunction with something other than a C program—say a
        Python or Perl script—Subversion has some support for this
        via the Simplified Wrapper and Interface Generator (SWIG).  The
        SWIG bindings for Subversion are located in
        <code class="filename">subversion/bindings/swig</code> and whilst still
        maturing, they are in a usable state.  These bindings allow you
        to call Subversion API functions indirectly, using wrappers that
        translate the datatypes native to your scripting language into
        the datatypes needed by Subversion's C libraries.</p><p>There is an obvious benefit to accessing the Subversion
        APIs via a language binding—simplicity.  Generally
        speaking, languages such as Python and Perl are much more
        flexible and easy to use than C or C++.  The sort of
        high-level datatypes and context-driven type checking provided
        by these languages are often better at handling information
        that comes from users.  As you know, humans are proficient at
        botching up input to a program, and scripting languages tend
        to handle that misinformation more gracefully.  Of course,
        often that flexibility comes at the cost of performance.  That
        is why using a tightly-optimized, C-based interface and
        library suite, combined with a powerful, flexible binding
        language, is so appealing.</p><p>Let's look at a sample program that uses Subversion's
        Python SWIG bindings to recursively crawl the youngest
        repository revision, and print the various paths reached
        during the crawl.</p><div class="example"><a id="svn.developer.usingapi.otherlangs.ex-1"></a><p class="title"><b>Esempio 8.2. Using the Repository Layer with Python</b></p><div class="example-contents"><pre class="programlisting">
#!/usr/bin/python

"""Crawl a repository, printing versioned object path names."""

import sys
import os.path
import svn.fs, svn.core, svn.repos

def crawl_filesystem_dir(root, directory, pool):
    """Recursively crawl DIRECTORY under ROOT in the filesystem, and return
    a list of all the paths at or below DIRECTORY.  Use POOL for all 
    allocations."""

    # Print the name of this path.
    print directory + "/"
    
    # Get the directory entries for DIRECTORY.
    entries = svn.fs.svn_fs_dir_entries(root, directory, pool)

    # Use an iteration subpool.
    subpool = svn.core.svn_pool_create(pool)

    # Loop over the entries.
    names = entries.keys()
    for name in names:
        # Clear the iteration subpool.
        svn.core.svn_pool_clear(subpool)

        # Calculate the entry's full path.
        full_path = directory + '/' + name

        # If the entry is a directory, recurse.  The recursion will return
        # a list with the entry and all its children, which we will add to
        # our running list of paths.
        if svn.fs.svn_fs_is_dir(root, full_path, subpool):
            crawl_filesystem_dir(root, full_path, subpool)
        else:
            # Else it's a file, so print its path here.
            print full_path

    # Destroy the iteration subpool.
    svn.core.svn_pool_destroy(subpool)

def crawl_youngest(pool, repos_path):
    """Open the repository at REPOS_PATH, and recursively crawl its
    youngest revision."""
    
    # Open the repository at REPOS_PATH, and get a reference to its
    # versioning filesystem.
    repos_obj = svn.repos.svn_repos_open(repos_path, pool)
    fs_obj = svn.repos.svn_repos_fs(repos_obj)

    # Query the current youngest revision.
    youngest_rev = svn.fs.svn_fs_youngest_rev(fs_obj, pool)
    
    # Open a root object representing the youngest (HEAD) revision.
    root_obj = svn.fs.svn_fs_revision_root(fs_obj, youngest_rev, pool)

    # Do the recursive crawl.
    crawl_filesystem_dir(root_obj, "", pool)
    
if __name__ == "__main__":
    # Check for sane usage.
    if len(sys.argv) != 2:
        sys.stderr.write("Usage: %s REPOS_PATH\n"
                         % (os.path.basename(sys.argv[0])))
        sys.exit(1)

    # Canonicalize (enough for Subversion, at least) the repository path.
    repos_path = os.path.normpath(sys.argv[1])
    if repos_path == '.': 
        repos_path = ''

    # Call the app-wrapper, which takes care of APR initialization/shutdown
    # and the creation and cleanup of our top-level memory pool.
    svn.core.run_app(crawl_youngest, repos_path)
</pre></div></div><br class="example-break" /><p>This same program in C would need to deal with custom
        datatypes (such as those provided by the APR library) for
        representing the hash of entries and the list of paths, but
        Python has hashes (called «<span class="quote">dictionaries</span>») and
        lists as built-in datatypes, and provides a rich collection of
        functions for operating on those types.  So SWIG (with the
        help of some customizations in Subversion's language bindings
        layer) takes care of mapping those custom datatypes into the
        native datatypes of the target language.  This provides a more
        intuitive interface for users of that language.</p><p>The Subversion Python bindings can be used for working
        copy operations, too.  In the previous section of this
        chapter, we mentioned the <code class="filename">libsvn_client</code>
        interface, and how it exists for the sole purpose of
        simplifying the process of writing a Subversion client.  The
        following is a brief example of how that library can be
        accessed via the SWIG bindings to recreate a scaled-down
        version of the <span><strong class="command">svn status</strong></span> command.</p><div class="example"><a id="svn.developer.usingapi.otherlangs.ex-2"></a><p class="title"><b>Esempio 8.3. A Python Status Crawler</b></p><div class="example-contents"><pre class="programlisting">
#!/usr/bin/env python

"""Crawl a working copy directory, printing status information."""

import sys
import os.path
import getopt
import svn.core, svn.client, svn.wc

def generate_status_code(status):
    """Translate a status value into a single-character status code,
    using the same logic as the Subversion command-line client."""

    if status == svn.wc.svn_wc_status_none:
        return ' '
    if status == svn.wc.svn_wc_status_normal:
        return ' '
    if status == svn.wc.svn_wc_status_added:
        return 'A'
    if status == svn.wc.svn_wc_status_missing:
        return '!'
    if status == svn.wc.svn_wc_status_incomplete:
        return '!'
    if status == svn.wc.svn_wc_status_deleted:
        return 'D'
    if status == svn.wc.svn_wc_status_replaced:
        return 'R'
    if status == svn.wc.svn_wc_status_modified:
        return 'M'
    if status == svn.wc.svn_wc_status_merged:
        return 'G'
    if status == svn.wc.svn_wc_status_conflicted:
        return 'C'
    if status == svn.wc.svn_wc_status_obstructed:
        return '~'
    if status == svn.wc.svn_wc_status_ignored:
        return 'I'
    if status == svn.wc.svn_wc_status_external:
        return 'X'
    if status == svn.wc.svn_wc_status_unversioned:
        return '?'
    return '?'

def do_status(pool, wc_path, verbose):
    # Calculate the length of the input working copy path.
    wc_path_len = len(wc_path)

    # Build a client context baton.
    ctx = svn.client.svn_client_ctx_t()

    def _status_callback(path, status, root_path_len=wc_path_len):
        """A callback function for svn_client_status."""

        # Print the path, minus the bit that overlaps with the root of
        # the status crawl
        text_status = generate_status_code(status.text_status)
        prop_status = generate_status_code(status.prop_status)
        print '%s%s  %s' % (text_status, prop_status, path[wc_path_len + 1:])
        
    # Do the status crawl, using _status_callback() as our callback function.
    svn.client.svn_client_status(wc_path, None, _status_callback,
                                 1, verbose, 0, 0, ctx, pool)

def usage_and_exit(errorcode):
    """Print usage message, and exit with ERRORCODE."""
    stream = errorcode and sys.stderr or sys.stdout
    stream.write("""Usage: %s OPTIONS WC-PATH
Options:
  --help, -h    : Show this usage message
  --verbose, -v : Show all statuses, even uninteresting ones
""" % (os.path.basename(sys.argv[0])))
    sys.exit(errorcode)
    
if __name__ == '__main__':
    # Parse command-line options.
    try:
        opts, args = getopt.getopt(sys.argv[1:], "hv", ["help", "verbose"])
    except getopt.GetoptError:
        usage_and_exit(1)
    verbose = 0
    for opt, arg in opts:
        if opt in ("-h", "--help"):
            usage_and_exit(0)
        if opt in ("-v", "--verbose"):
            verbose = 1
    if len(args) != 1:
        usage_and_exit(2)
            
    # Canonicalize (enough for Subversion, at least) the working copy path.
    wc_path = os.path.normpath(args[0])
    if wc_path == '.': 
        wc_path = ''

    # Call the app-wrapper, which takes care of APR initialization/shutdown
    # and the creation and cleanup of our top-level memory pool.
    svn.core.run_app(do_status, wc_path, verbose)
</pre></div></div><br class="example-break" /><p>Subversion's language bindings unfortunately tend to lack
        the level of attention given to the core Subversion modules.
        However, there have been significant efforts towards creating
        functional bindings for Python, Perl, and Ruby.  To some extent,
        the work done preparing the SWIG interface files for these
        languages is reusable in efforts to generate bindings for other
        languages supported by SWIG (which includes versions of C#,
        Guile, Java, MzScheme, OCaml, PHP, Tcl, and others).
        However, some extra programming is required to compensate for
        complex APIs that SWIG needs some help interfacing with.  For
        more information on SWIG itself, see the project's website at
        <a href="http://www.swig.org/" target="_top">http://www.swig.org/</a>.</p></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.developer.insidewc"></a>Inside the Working Copy Administration Area</h2></div></div></div><p>As we mentioned earlier, each directory of a Subversion
      working copy contains a special subdirectory called
      <code class="filename">.svn</code> which houses administrative data about
      that working copy directory.  Subversion uses the information in
      <code class="filename">.svn</code> to keep track of things like:</p><div class="itemizedlist"><ul type="disc"><li><p>Which repository location(s) are represented by the
          files and subdirectories in the working copy
          directory.</p></li><li><p>What revision of each of those files and directories are
          currently present in the working copy.</p></li><li><p>Any user-defined properties that might be attached
          to those files and directories.</p></li><li><p>Pristine (un-edited) copies of the working copy
          files.</p></li></ul></div><p>While there are several other bits of data stored in the
      <code class="filename">.svn</code> directory, we will examine only a
      couple of the most important items.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.developer.insidewc.entries"></a>The Entries File</h3></div></div></div><p>Perhaps the single most important file in the
        <code class="filename">.svn</code> directory is the
        <code class="filename">entries</code> file.  The entries file is an XML
        document which contains the bulk of the administrative
        information about a versioned resource in a working copy
        directory.  It is this one file which tracks the repository
        URLs, pristine revision, file checksums, pristine text and
        property timestamps, scheduling and conflict state
        information, last-known commit information (author, revision,
        timestamp), local copy history—practically everything
        that a Subversion client is interested in knowing about a
        versioned (or to-be-versioned) resource!</p><div class="sidebar"><p class="title"><b>Comparing the Administrative Areas of Subversion and
          CVS</b></p><p>A glance inside the typical <code class="filename">.svn</code>
          directory turns up a bit more than what CVS maintains in its
          <code class="filename">CVS</code> administrative directories.  The
          <code class="filename">entries</code> file contains XML which
          describes the current state of the working copy directory,
          and basically serves the purposes of CVS's
          <code class="filename">Entries</code>, <code class="filename">Root</code>, and
          <code class="filename">Repository</code> files combined.</p></div><p>The following is an example of an actual entries
        file:</p><div class="example"><a id="svn.developer.insidewc.entries.ex-1"></a><p class="title"><b>Esempio 8.4. Contents of a Typical <code class="filename">.svn/entries</code>
          File</b></p><div class="example-contents"><pre class="programlisting">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;wc-entries
   xmlns="svn:"&gt;
&lt;entry
   committed-rev="1"
   name=""
   committed-date="2005-04-04T13:32:28.526873Z"
   url="http://svn.red-bean.com/repos/greek-tree/A/D"
   last-author="jrandom"
   kind="dir"
   uuid="4e820d15-a807-0410-81d5-aa59edf69161"
   revision="1"/&gt;
&lt;entry
   name="lambda"
   copied="true"
   kind="file"
   copyfrom-rev="1"
   schedule="add"
   copyfrom-url="http://svn.red-bean.com/repos/greek-tree/A/B/lambda"/&gt;
&lt;entry
   committed-rev="1"
   name="gamma"
   text-time="2005-12-11T16:32:46.000000Z"
   committed-date="2005-04-04T13:32:28.526873Z"
   checksum="ada10d942b1964d359e048dbacff3460"
   last-author="jrandom"
   kind="file"
   prop-time="2005-12-11T16:32:45.000000Z"/&gt;
&lt;entry
   name="zeta"
   kind="file"
   schedule="add"
   revision="0"/&gt;
&lt;entry
   name="G"
   kind="dir"/&gt;
&lt;entry
   name="H"
   kind="dir"
   schedule="delete"/&gt;
&lt;/wc-entries&gt;
</pre></div></div><br class="example-break" /><p>As you can see, the entries file is essentially a list of
        entries.  Each <code class="sgmltag-element">entry</code> tag represents one of
        three things: the working copy directory itself (called the
        «<span class="quote">this directory</span>» entry, and noted as having an
        empty value for its <em class="structfield"><code>name</code></em>
        attribute), a file in that working copy directory (noted by
        having its <em class="structfield"><code>kind</code></em> attribute set to
        <code class="literal">"file"</code>), or a subdirectory in that working
        copy (<em class="structfield"><code>kind</code></em> here is set to
        <code class="literal">"dir"</code>).  The files and subdirectories whose
        entries are stored in this file are either already under
        version control, or (as in the case of the file named
        <code class="filename">zeta</code> above) are scheduled to be added to
        version control when the user next commits this working copy
        directory's changes.  Each entry has a unique name, and each
        entry has a node kind.</p><p>Developers should be aware of some special rules that
        Subversion uses when reading and writing its
        <code class="filename">entries</code> files.  While each entry has a
        revision and URL associated with it, note that not every
        <code class="sgmltag-element">entry</code> tag in the sample file has explicit
        <em class="structfield"><code>revision</code></em> or
        <em class="structfield"><code>url</code></em> attributes attached to it.
        Subversion allows entries to not explicitly store those two
        attributes when their values are the same as (in the
        <em class="structfield"><code>revision</code></em> case) or trivially
        calculable from
        <sup>[<a id="id4762683" href="#ftn.id4762683">45</a>]</sup>
        (in the <em class="structfield"><code>url</code></em> case) the data stored
        in the «<span class="quote">this directory</span>» entry.  Note also that
        for subdirectory entries, Subversion stores only the crucial
        attributes—name, kind, url, revision, and schedule.  In
        an effort to reduce duplicated information, Subversion
        dictates that the method for determining the full set of
        information about a subdirectory is to traverse down into that
        subdirectory, and read the «<span class="quote">this directory</span>» entry
        from its own <code class="filename">.svn/entries</code> file.  However,
        a reference to the subdirectory is kept in its parent's
        <code class="filename">entries</code> file, with enough information to
        permit basic versioning operations in the event that the
        subdirectory itself is actually missing from disk.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.developer.insidewc.base-and-props"></a>Pristine Copies and Property Files</h3></div></div></div><p>As mentioned before, the <code class="filename">.svn</code>
        directory also holds the pristine «<span class="quote">text-base</span>»
        versions of files.  Those can be found in
        <code class="filename">.svn/text-base</code>.  The benefits of these
        pristine copies are multiple—network-free checks for
        local modifications and difference reporting, network-free
        reversion of modified or missing files, smaller transmission
        of changes to the server—but comes at the cost of having
        each versioned file stored at least twice on disk.  These
        days, this seems to be a negligible penalty for most files.
        However, the situation gets uglier as the size of your
        versioned files grows.  Some attention is being given to
        making the presence of the «<span class="quote">text-base</span>» an option.
        Ironically though, it is as your versioned files' sizes get
        larger that the existence of the «<span class="quote">text-base</span>»
        becomes more crucial—who wants to transmit a huge file
        across a network just because they want to commit a tiny
        change to it?</p><p>Similar in purpose to the «<span class="quote">text-base</span>» files
        are the property files and their pristine
        «<span class="quote">prop-base</span>» copies, located in
        <code class="filename">.svn/props</code> and
        <code class="filename">.svn/prop-base</code> respectively.  Since
        directories can have properties, too, there are also
        <code class="filename">.svn/dir-props</code> and
        <code class="filename">.svn/dir-prop-base</code> files.  Each of these
        property files («<span class="quote">working</span>» and «<span class="quote">base</span>»
        versions) uses a simple «<span class="quote">hash-on-disk</span>» file
        format for storing the property names and values.</p></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.developer.webdav"></a>WebDAV</h2></div></div></div><p>WebDAV (shorthand for «<span class="quote">Web-based Distributed Authoring
      and Versioning</span>») is an extension of the standard HTTP
      protocol designed to make the web into a read/write medium,
      instead of the basically read-only medium that exists today.
      The theory is that directories and files can be shared—as
      both readable and writable objects—over the web.  RFCs
      2518 and 3253 describe the WebDAV/DeltaV extensions to HTTP, and
      are available (along with a lot of other useful information) at
      <a href="http://www.webdav.org/" target="_top">http://www.webdav.org/</a>.</p><p>A number of operating system file browsers are already able
      to mount networked directories using WebDAV.  On Win32, the
      Windows Explorer can browse what it calls Web Folders (which are
      just WebDAV-ready network locations) as if they were regular
      shared folders.  Mac OS X also has this capability, as do the
      Nautilus and Konqueror browsers (under GNOME and KDE,
      respectively).</p><p>How does all of this apply to Subversion?  The mod_dav_svn
      Apache module uses HTTP, extended by WebDAV and DeltaV, as one
      of its network protocols.  Subversion uses mod_dav_svn to map
      between Subversion's versioning concepts and those of RFCs 2518
      and 3253.
    </p><p>For a more thorough discussion of WebDAV, how it works, and
      how Subversion uses it, see <a href="#svn.webdav" title="Appendice&#xA0;B.&#xA0;WebDAV and Autoversioning">Appendice B, <i>WebDAV and Autoversioning</i></a>.  Among
      other things, that appendix discusses the degree to which
      Subversion adheres to the generic WebDAV specification, and how
      that affects interoperability with generic WebDAV
      clients.</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.developer.pools"></a>Programming with Memory Pools</h2></div></div></div><p>Almost every developer who has used the C programming
      language has at some point sighed at the daunting task of
      managing memory usage.  Allocating enough memory to use, keeping
      track of those allocations, freeing the memory when you no
      longer need it—these tasks can be quite complex.  And of
      course, failure to do those things properly can result in a
      program that crashes itself, or worse, crashes the computer.
      Fortunately, the APR library that Subversion depends on for
      portability provides the <span class="structname">apr_pool_t</span>
      type, which represents a pool from which the application may
      allocate memory.</p><p>A memory pool is an abstract representation of a chunk of
      memory allocated for use by a program.  Rather than requesting
      memory directly from the OS using the standard
      <code class="function">malloc()</code> and friends, programs that link
      against APR can simply request that a pool of memory be created
      (using the <code class="function">apr_pool_create()</code> function).
      APR will allocate a moderately sized chunk of memory from the
      OS, and that memory will be instantly available for use by the
      program.  Any time the program needs some of the pool memory, it
      uses one of the APR pool API functions, like
      <code class="function">apr_palloc()</code>, which returns a generic
      memory location from the pool.  The program can keep requesting
      bits and pieces of memory from the pool, and APR will keep
      granting the requests.  Pools will automatically grow in size to
      accommodate programs that request more memory than the original
      pool contained, until of course there is no more memory
      available on the system.</p><p>Now, if this were the end of the pool story, it would hardly
      have merited special attention.  Fortunately, that's not the
      case.  Pools can not only be created; they can also be cleared
      and destroyed, using <code class="function">apr_pool_clear()</code> and
      <code class="function">apr_pool_destroy()</code> respectively.  This
      gives developers the flexibility to allocate several—or
      several thousand—things from the pool, and then clean up
      all of that memory with a single function call!  Further, pools
      have hierarchy.  You can make «<span class="quote">subpools</span>» of any
      previously created pool.  When you clear a pool, all of its
      subpools are destroyed; if you destroy a pool, it and its
      subpools are destroyed.</p><p>Before we go further, developers should be aware that they
      probably will not find many calls to the APR pool functions we
      just mentioned in the Subversion source code.  APR pools offer
      some extensibility mechanisms, like the ability to have custom
      «<span class="quote">user data</span>» attached to the pool, and mechanisms
      for registering cleanup functions that get called when the pool
      is destroyed.  Subversion makes use of these extensions in a
      somewhat non-trivial way.  So, Subversion supplies (and most of
      its code uses) the wrapper functions
      <code class="function">svn_pool_create()</code>,
      <code class="function">svn_pool_clear()</code>, and
      <code class="function">svn_pool_destroy()</code>.</p><p>While pools are helpful for basic memory management, the
      pool construct really shines in looping and recursive scenarios.
      Since loops are often unbounded in their iterations, and
      recursions in their depth, memory consumption in these areas of
      the code can become unpredictable.  Fortunately, using nested
      memory pools can be a great way to easily manage these
      potentially hairy situations.  The following example
      demonstrates the basic use of nested pools in a situation that
      is fairly common—recursively crawling a directory tree,
      doing some task to each thing in the tree.</p><div class="example"><a id="svn.developer.pools.ex-1"></a><p class="title"><b>Esempio 8.5. Effective Pool Usage</b></p><div class="example-contents"><pre class="programlisting">
/* Recursively crawl over DIRECTORY, adding the paths of all its file
   children to the FILES array, and doing some task to each path
   encountered.  Use POOL for the all temporary allocations, and store
   the hash paths in the same pool as the hash itself is allocated in.  */
static apr_status_t 
crawl_dir (apr_array_header_t *files,
           const char *directory,
           apr_pool_t *pool)
{
  apr_pool_t *hash_pool = files-&gt;pool;  /* array pool */
  apr_pool_t *subpool = svn_pool_create (pool);  /* iteration pool */
  apr_dir_t *dir;
  apr_finfo_t finfo;
  apr_status_t apr_err;
  apr_int32_t flags = APR_FINFO_TYPE | APR_FINFO_NAME;

  apr_err = apr_dir_open (&amp;dir, directory, pool);
  if (apr_err)
    return apr_err;

  /* Loop over the directory entries, clearing the subpool at the top of
     each iteration.  */
  for (apr_err = apr_dir_read (&amp;finfo, flags, dir);
       apr_err == APR_SUCCESS;
       apr_err = apr_dir_read (&amp;finfo, flags, dir))
    {
      const char *child_path;

      /* Clear the per-iteration SUBPOOL.  */
      svn_pool_clear (subpool);

      /* Skip entries for "this dir" ('.') and its parent ('..').  */
      if (finfo.filetype == APR_DIR)
        {
          if (finfo.name[0] == '.'
              &amp;&amp; (finfo.name[1] == '\0'
                  || (finfo.name[1] == '.' &amp;&amp; finfo.name[2] == '\0')))
            continue;
        }

      /* Build CHILD_PATH from DIRECTORY and FINFO.name.  */
      child_path = svn_path_join (directory, finfo.name, subpool);

      /* Do some task to this encountered path. */
      do_some_task (child_path, subpool);

      /* Handle subdirectories by recursing into them, passing SUBPOOL
         as the pool for temporary allocations.  */
      if (finfo.filetype == APR_DIR)
        {
          apr_err = crawl_dir (files, child_path, subpool);
          if (apr_err)
            return apr_err;
        }

      /* Handle files by adding their paths to the FILES array.  */
      else if (finfo.filetype == APR_REG)
        {
          /* Copy the file's path into the FILES array's pool.  */
          child_path = apr_pstrdup (hash_pool, child_path);

          /* Add the path to the array.  */
          (*((const char **) apr_array_push (files))) = child_path;
        }
    }

  /* Destroy SUBPOOL.  */
  svn_pool_destroy (subpool);

  /* Check that the loop exited cleanly. */
  if (apr_err)
    return apr_err;

  /* Yes, it exited cleanly, so close the dir. */
  apr_err = apr_dir_close (dir);
  if (apr_err)
    return apr_err;

  return APR_SUCCESS;
}
</pre></div></div><br class="example-break" /><p>The previous example demonstrates effective pool usage in
      <span class="emphasis"><em>both</em></span> looping and recursive situations.
      Each recursion begins by making a subpool of the pool passed to
      the function.  This subpool is used for the looping region, and
      cleared with each iteration.  The result is memory usage is
      roughly proportional to the depth of the recursion, not to total
      number of file and directories present as children of the
      top-level directory.  When the first call to this recursive
      function finally finishes, there is actually very little data
      stored in the pool that was passed to it.  Now imagine the extra
      complexity that would be present if this function had to
      <code class="function">alloc()</code> and <code class="function">free()</code>
      every single piece of data used!</p><p>Pools might not be ideal for every application, but they are
      extremely useful in Subversion.  As a Subversion developer,
      you'll need to grow comfortable with pools and how to wield them
      correctly.  Memory usage bugs and bloating can be difficult to
      diagnose and fix regardless of the API, but the pool construct
      provided by APR has proven a tremendously convenient,
      time-saving bit of functionality.</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.developer.contrib"></a>Contributing to Subversion</h2></div></div></div><p>The official source of information about the Subversion
      project is, of course, the project's website at
      <a href="http://subversion.tigris.org/" target="_top">http://subversion.tigris.org/</a>.  There you can
      find information about getting access to the source code and
      participating on the discussion lists.  The Subversion community
      always welcomes new members.  If you are interested in
      participating in this community by contributing changes to the
      source code, here are some hints on how to get started.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.developer.contrib.join"></a>Join the Community</h3></div></div></div><p>The first step in community participation is to find a way
        to stay on top of the latest happenings.  To do this most
        effectively, you will want to subscribe to the main developer
        discussion list (<code class="email">&lt;<a href="mailto:dev@subversion.tigris.org">dev@subversion.tigris.org</a>&gt;</code>) and
        commit mail list (<code class="email">&lt;<a href="mailto:svn@subversion.tigris.org">svn@subversion.tigris.org</a>&gt;</code>).
        By following these lists even loosely, you will have access
        to important design discussions, be able to see actual changes
        to Subversion source code as they occur, and be able to
        witness peer reviews of those changes and proposed changes.
        These email based discussion lists are the primary
        communication media for Subversion development.  See the
        Mailing Lists section of the website for other
        Subversion-related lists you might be interested in.</p><p>But how do you know what needs to be done?  It is quite
        common for a programmer to have the greatest intentions of
        helping out with the development, yet be unable to find a good
        starting point.  After all, not many folks come to the
        community having already decided on a particular itch they
        would like to scratch.  But by watching the developer
        discussion lists, you might see mentions of existing bugs or
        feature requests fly by that particularly interest you.  Also,
        a great place to look for outstanding, unclaimed tasks is the
        Issue Tracking database on the Subversion website.  There you
        will find the current list of known bugs and feature requests.
        If you want to start with something small, look for issues
        marked as «<span class="quote">bite-sized</span>».</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.developer.contrib.get-code"></a>Get the Source Code</h3></div></div></div><p>To edit the code, you need to have the code.  This means
        you need to check out a working copy from the public
        Subversion source repository.  As straightforward as that
        might sound, the task can be slightly tricky.  Because
        Subversion's source code is versioned using Subversion itself,
        you actually need to «<span class="quote">bootstrap</span>» by getting a
        working Subversion client via some other method.  The most
        common methods include downloading the latest binary
        distribution (if such is available for your platform), or
        downloading the latest source tarball and building your own
        Subversion client.  If you build from source, make sure to
        read the <code class="filename">INSTALL</code> file in the top level of
        the source tree for instructions.</p><p>After you have a working Subversion client, you are now
        poised to checkout a working copy of the Subversion source
        repository from <a href="http://svn.collab.net/repos/svn/trunk/" target="_top">http://svn.collab.net/repos/svn/trunk/</a>:
        <sup>[<a id="id4763418" href="#ftn.id4763418">46</a>]</sup></p><pre class="screen">
$ svn checkout http://svn.collab.net/repos/svn/trunk subversion
A    subversion/HACKING
A    subversion/INSTALL
A    subversion/README
A    subversion/autogen.sh
A    subversion/build.conf
…
</pre><p>The above command will checkout the bleeding-edge, latest
        version of the Subversion source code into a subdirectory
        named <code class="filename">subversion</code> in your current working
        directory.  Obviously, you can adjust that last argument as
        you see fit.  Regardless of what you call the new working copy
        directory, though, after this operation completes, you will
        now have the Subversion source code.  Of course, you will
        still need to fetch a few helper libraries (apr, apr-util,
        etc.)—see the <code class="filename">INSTALL</code> file in the
        top level of the working copy for details.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.developer.contrib.hacking"></a>Become Familiar with Community Policies</h3></div></div></div><p>Now that you have a working copy containing the latest
        Subversion source code, you will most certainly want to take a
        cruise through the «<span class="quote">Hacker's Guide to Subversion</span>»,
        which is available either as the
        <code class="filename">www/hacking.html</code> file in the working copy,
        or on the Subversion website at <a href="http://subversion.tigris.org/hacking.html" target="_top">http://subversion.tigris.org/hacking.html</a>.  This guide
        contains general instructions for contributing to Subversion,
        including how to properly format your source code for
        consistency with the rest of the codebase, how to describe your
        proposed changes with an effective change log message, how to
        test your changes, and so on.  Commit privileges on the
        Subversion source repository are earned—a government by
        meritocracy.
        <sup>[<a id="id4763532" href="#ftn.id4763532">47</a>]</sup>
        The «<span class="quote">Hacker's Guide</span>» is an invaluable resource when
        it comes to making sure that your proposed changes earn the
        praises they deserve without being rejected on
        technicalities.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.developer.contrib.code-and-test"></a>Make and Test Your Changes</h3></div></div></div><p>With the code and community policy understanding in hand,
        you are ready to make your changes.  It is best to try to make
        smaller but related sets of changes, even tackling larger
        tasks in stages, instead of making huge, sweeping
        modifications.  Your proposed changes will be easier to
        understand (and therefore easier to review) if you disturb
        the fewest lines of code possible to accomplish your task
        properly.  After making each set of proposed changes, your
        Subversion tree should be in a state in which the software
        compiles with no warnings.</p><p>Subversion has a fairly thorough
        <sup>[<a id="id4763591" href="#ftn.id4763591">48</a>]</sup>
        regression test suite, and your proposed changes are expected
        to not cause any of those tests to fail.  By running
        <span><strong class="command">make check</strong></span> (in Unix) from the top of the
        source tree, you can sanity-check your changes.  The fastest
        way to get your code contributions rejected (other than
        failing to supply a good log message) is to submit changes
        that cause failure in the test suite.</p><p>In the best-case scenario, you will have actually added
        appropriate tests to that test suite which verify that your
        proposed changes work as expected.  In fact,
        sometimes the best contribution a person can make is solely
        the addition of new tests.  You can write regression tests for
        functionality that currently works in Subversion as a way to
        protect against future changes that might trigger failure in
        those areas.  Also, you can write new tests that demonstrate
        known failures.  For this purpose, the Subversion test suite
        allows you to specify that a given test is expected to fail
        (called an <code class="literal">XFAIL</code>), and so long as
        Subversion fails in the way that was expected, a test result
        of <code class="literal">XFAIL</code> itself is considered a success.
        Ultimately, the better the test suite, the less time wasted on
        diagnosing potentially obscure regression bugs.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.developer.contrib.submit"></a>Donate Your Changes</h3></div></div></div><p>After making your modifications to the source code,
        compose a clear and concise log message to describe those
        changes and the reasons for them.  Then, send an email to the
        developers list containing your log message and the output of
        <span><strong class="command">svn diff</strong></span> (from the top of your Subversion
        working copy).  If the community members consider your changes
        acceptable, someone who has commit privileges (permission to
        make new revisions in the Subversion source repository) will
        add your changes to the public source code tree.  Recall that
        permission to directly commit changes to the repository is
        granted on merit—if you demonstrate comprehension of
        Subversion, programming competency, and a «<span class="quote">team
        spirit</span>», you will likely be awarded that
        permission.</p></div></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.id4760819" href="#id4760819">42</a>] </sup>We understand that this may come as a shock to sci-fi
            fans who have long been under the impression that Time was
            actually the <span class="emphasis"><em>fourth</em></span> dimension, and we
            apologize for any emotional trauma induced by our
            assertion of a different theory.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4761948" href="#id4761948">43</a>] </sup>Subversion uses ANSI system calls and datatypes as much
            as possible.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4761969" href="#id4761969">44</a>] </sup>Neon and Berkeley DB are examples of such libraries.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4762683" href="#id4762683">45</a>] </sup>That is, the URL for the entry is the same as the
            concatenation of the parent directory's URL and the
            entry's name.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4763418" href="#id4763418">46</a>] </sup>Note that the URL checked out in the example above
            ends not with <code class="literal">svn</code>, but with a
            subdirectory thereof called <code class="literal">trunk</code>.  See
            our discussion of Subversion's branching and tagging model
            for the reasoning behind this.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4763532" href="#id4763532">47</a>] </sup>While this may superficially appear as some sort of
            elitism, this «<span class="quote">earn your commit privileges</span>»
            notion is about efficiency—whether it costs more in
            time and effort to review and apply someone else's changes
            that are likely to be safe and useful, versus the
            potential costs of undoing changes that are
            dangerous.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4763591" href="#id4763591">48</a>] </sup>You might want to grab some popcorn.
            «<span class="quote">Thorough</span>», in this instance, translates to
            somewhere in the neighborhood of thirty minutes of
            non-interactive machine churn.</p></div></div></div><div class="chapter" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title"><a id="svn.ref"></a>Capitolo 9. Subversion Complete Reference</h2></div></div></div><div class="toc"><p><b>Sommario</b></p><dl><dt><span class="sect1"><a href="#svn.ref.svn">The Subversion Command Line Client:
      <span><strong class="command">svn</strong></span></a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.ref.svn.sw"><span><strong class="command">svn</strong></span> Switches</a></span></dt><dt><span class="sect2"><a href="#svn.ref.svn.c"><span><strong class="command">svn</strong></span> Subcommands</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.add">svn add</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.blame">svn blame</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.cat">svn cat</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.checkout">svn checkout</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.cleanup">svn cleanup</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.commit">svn commit</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.copy">svn copy</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.delete">svn delete</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.diff">svn diff</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.export">svn export</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.help">svn help</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.import">svn import</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.info">svn info</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.list">svn list</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.lock">svn lock</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.log">svn log</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.merge">svn merge</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.mkdir">svn mkdir</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.move">svn move</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.propdel">svn propdel</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.propedit">svn propedit</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.propget">svn propget</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.proplist">svn proplist</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.propset">svn propset</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.resolved">svn resolved</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.revert">svn revert</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.status">svn status</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.switch">svn switch</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.unlock">svn unlock</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.update">svn update</a></span><span class="refpurpose"></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.ref.svnadmin"><span><strong class="command">svnadmin</strong></span></a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.ref.svnadmin.sw"><span><strong class="command">svnadmin</strong></span> Switches</a></span></dt><dt><span class="sect2"><a href="#svn.ref.svnadmin.c"><span><strong class="command">svnadmin</strong></span> Subcommands</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.create">svnadmin create</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.deltify">svnadmin deltify</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.dump">svnadmin dump</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.help">svnadmin help</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.hotcopy">svnadmin hotcopy</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.list-dblogs">svnadmin list-dblogs</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.list-unused-dblogs">svnadmin list-unused-dblogs</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.load">svnadmin load</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.lslocks">svnadmin lslocks</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.lstxns">svnadmin lstxns</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.recover">svnadmin recover</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.rmlocks">svnadmin rmlocks</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.rmtxns">svnadmin rmtxns</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.setlog">svnadmin setlog</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.verify">svnadmin verify</a></span><span class="refpurpose"></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.ref.svnlook"><span><strong class="command">svnlook</strong></span></a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.ref.svnlook.sw"><span><strong class="command">svnlook</strong></span> Switches</a></span></dt><dt><span class="sect2"><a href="#svn.ref.svnlook.c"><span><strong class="command">svnlook</strong></span></a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.author">svnlook author</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.cat">svnlook cat</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.changed">svnlook changed</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.date">svnlook date</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.diff">svnlook diff</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.dirs-changed">svnlook dirs-changed</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.help">svnlook help</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.history">svnlook history</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.info">svnlook info</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.lock">svnlook lock</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.log">svnlook log</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.propget">svnlook propget</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.proplist">svnlook proplist</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.tree">svnlook tree</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.uuid">svnlook uuid</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.youngest">svnlook youngest</a></span><span class="refpurpose"></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.ref.svnserve"><span><strong class="command">svnserve</strong></span></a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.ref.svnserve.sw"><span><strong class="command">svnserve</strong></span> Switches</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.ref.svnversion"><span><strong class="command">svnversion</strong></span></a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#svn.ref.svnversion.re">svnversion</a></span><span class="refpurpose"></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.ref.mod_dav_svn"><span><strong class="command">mod_dav_svn</strong></span></a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#svn.ref.mod_dav_svn.conf"><code class="literal">mod_dav_svn</code> Configuration
        Directives</a></span><span class="refpurpose"></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.ref.properties"><span><strong class="command">Subversion properties</strong></span></a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#svn.ref.svnprops">Subversion-defined properties</a></span><span class="refpurpose"></span></dt></dl></dd></dl></div><div class="simplesect" lang="it" xml:lang="it"><div class="titlepage"></div><p>This chapter is intended to be a complete reference to using
      Subversion.  This includes the command line client
      (<span><strong class="command">svn</strong></span>) and all its subcommands, as well as the
      repository administration programs (<span><strong class="command">svnadmin</strong></span>
      and <span><strong class="command">svnlook</strong></span>) and their respective
      subcommands.</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.ref.svn"></a>The Subversion Command Line Client:
      <span><strong class="command">svn</strong></span></h2></div></div></div><p>To use the command line client, you type
      <span><strong class="command">svn</strong></span>, the subcommand you wish to use
      <sup>[<a id="id4763777" href="#ftn.id4763777">49</a>]</sup>, and any switches or targets that
      you wish to operate on—there is no specific order that the
      subcommand and the switches must appear in.  For example, all of
      the following are valid ways to use <span><strong class="command">svn
      status</strong></span>:</p><pre class="screen">
$ svn -v status
$ svn status -v 
$ svn status -v myfile
</pre><p>You can find many more examples of how to use most client
      commands in <a href="#svn.tour" title="Capitolo&#xA0;3.&#xA0;Visita guidata">Capitolo 3, <i>Visita guidata</i></a> and commands for managing
      properties in <a href="#svn.advanced.props" title="Properties">la sezione chiamata «Properties»</a>.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.ref.svn.sw"></a><span><strong class="command">svn</strong></span> Switches</h3></div></div></div><p>While Subversion has different switches for its
        subcommands, all switches are global—that is, each
        switch is guaranteed to mean the same thing regardless of
        the subcommand you use it with.  For example,
        <code class="option">--verbose</code> (<code class="option">-v</code>) always
        means «<span class="quote">verbose output</span>», regardless of the
        subcommand you use it with.</p><div class="variablelist"><dl><dt><span class="term"><code class="option">--auto-props</code></span></dt><dd><p>Enables auto-props, overriding the
              <code class="literal">enable-auto-props</code> directive in the
              <code class="filename">config</code> file.</p></dd><dt><span class="term"><code class="option">--config-dir</code>
            <em class="replaceable"><code>DIR</code></em></span></dt><dd><p>Instructs Subversion to read configuration
              information from the specified directory instead of the
              default location (<code class="filename">.subversion</code> in
              the user's home directory).</p></dd><dt><span class="term"><code class="option">--diff-cmd</code>
            <em class="replaceable"><code>CMD</code></em></span></dt><dd><p>Specifies an external program to use to show
              differences between files.  When <span><strong class="command">svn
              diff</strong></span> is invoked, it uses Subversion's internal
              diff engine, which provides unified diffs by default.
              If you want to use an external diff program, use
              <code class="option">--diff-cmd</code>.  You can pass switches to
              the diff program with the <code class="option">--extensions</code>
              switch (more on that later in this section).</p></dd><dt><span class="term"><code class="option">--diff3-cmd</code>
            <em class="replaceable"><code>CMD</code></em></span></dt><dd><p>Specifies an external program to use to merge files.</p></dd><dt><span class="term"><code class="option">--dry-run</code></span></dt><dd><p>Goes through all the motions of running a command,
              but makes no actual changes—either on disk or in
              the repository.</p></dd><dt><span class="term"><code class="option">--editor-cmd</code>
            <em class="replaceable"><code>CMD</code></em></span></dt><dd><p>Specifies an external program to use to edit a log message
              or a property value.  See the <code class="literal">editor-cmd</code>
              section in <a href="#svn.advanced.confarea.opts.config" title="Config">la sezione chiamata «Config»</a>
              for ways to specify a default editor.</p></dd><dt><span class="term"><code class="option">--encoding</code> <em class="replaceable"><code>ENC</code></em></span></dt><dd><p>Tells Subversion that your commit message is encoded
              in the charset provided.  The default is your operating
              system's native locale, and you should specify the
              encoding if your commit message is in any other
              encoding.</p></dd><dt><span class="term"><code class="option">--extensions</code> (<code class="option">-x</code>)
          <em class="replaceable"><code>ARGS</code></em></span></dt><dd><p>Specifies an argument or arguments that Subversion
              should pass to an external diff command when providing
              differences between files.  If you wish to pass multiple
              arguments, you must enclose all of them in quotes (for
              example, <span><strong class="command">svn diff --diff-cmd /usr/bin/diff -x
              "-b -E"</strong></span>).  This switch can
              <span class="emphasis"><em>only</em></span> be used if you also pass the
              <code class="option">--diff-cmd</code> switch.</p></dd><dt><span class="term"><code class="option">--file</code> (<code class="option">-F</code>)
            <em class="replaceable"><code>FILENAME</code></em>
          </span></dt><dd><p>Uses the contents of the file passed as an argument
              to this switch for the specified subcommand.</p></dd><dt><span class="term"><code class="option">--force</code></span></dt><dd><p>Forces a particular command or operation to run.
              There are some operations that Subversion will prevent
              you from doing in normal usage, but you can pass the
              force switch to tell Subversion «<span class="quote">I know what I'm
              doing as well as the possible repercussions of doing it,
              so let me at 'em</span>».  This switch is the
              programmatic equivalent of doing your own electrical
              work with the power on—if you don't know what
              you're doing, you're likely to get a nasty shock.</p></dd><dt><span class="term"><code class="option">--force-log</code></span></dt><dd><p>Forces a suspicious parameter passed to the
              <code class="option">--message</code> (<code class="option">-m</code>) or
              <code class="option">--file</code> (<code class="option">-F</code>) options to
              be accepted as valid.  By default, Subversion will
              produce an error if parameters to these options look
              like they might instead be targets of the subcommand.
              For example, if you pass a versioned file's path to the
              <code class="option">--file</code> (<code class="option">-F</code>) option,
              Subversion will assume you've made a mistake, that the
              path was instead intended as the target of the
              operation, and that you simply failed to provide some
              other—unversioned—file as the source of your log
              message.  To assert your intent and override these types
              of errors, pass the <code class="option">--force-log</code> option 
              to subcommands that accept log messages.</p></dd><dt><span class="term"><code class="option">--help</code> (<code class="option">-h</code> or
                <code class="option">-?</code>)
          </span></dt><dd><p>If used with one or more subcommands, shows the
              built-in help text for each subcommand.  If used alone,
              it displays the general client help text.</p></dd><dt><span class="term"><code class="option">--ignore-ancestry</code></span></dt><dd><p>Tells Subversion to ignore ancestry when calculating
              differences (rely on path contents alone).</p></dd><dt><span class="term"><code class="option">--ignore-externals</code></span></dt><dd><p>Tells Subversion to ignore external definitions and
              the external working copies managed by them.</p></dd><dt><span class="term"><code class="option">--incremental</code></span></dt><dd><p>Prints output in a format suitable for
              concatenation.</p></dd><dt><span class="term"><code class="option">--limit</code>
            <em class="replaceable"><code>NUM</code></em></span></dt><dd><p>Show only the first <em class="replaceable"><code>NUM</code></em>
              log messages.</p></dd><dt><span class="term"><code class="option">--message</code> (<code class="option">-m</code>)
            <em class="replaceable"><code>MESSAGE</code></em>
          </span></dt><dd><p>Indicates that you will specify a commit message
              on the command line, following this switch.  For
              example:</p><pre class="screen">
$ svn commit -m "They don't make Sunday."
</pre></dd><dt><span class="term"><code class="option">--new</code> <em class="replaceable"><code>ARG</code></em></span></dt><dd><p>Uses <em class="replaceable"><code>ARG</code></em> as the newer
              target.</p></dd><dt><span class="term"><code class="option">--no-auth-cache</code></span></dt><dd><p>Prevents caching of authentication information
              (e.g. username and password) in the Subversion
              administrative directories.</p></dd><dt><span class="term"><code class="option">--no-auto-props</code></span></dt><dd><p>Disables auto-props, overriding the
              <code class="literal">enable-auto-props</code> directive in the
              <code class="filename">config</code> file.</p></dd><dt><span class="term"><code class="option">--no-diff-added</code></span></dt><dd><p>Prevents Subversion from printing differences for
            added files.  The default behavior when you add a file is
            for <span><strong class="command">svn diff</strong></span> to print the same
            differences that you would see if you had added the entire
            contents of an existing (empty) file.</p></dd><dt><span class="term"><code class="option">--no-diff-deleted</code></span></dt><dd><p>Prevents Subversion from printing differences for
              deleted files.  The default behavior when you remove a
              file is for <span><strong class="command">svn diff</strong></span> to print the
              same differences that you would see if you had left
              the file but removed all the content.</p></dd><dt><span class="term"><code class="option">--no-ignore</code></span></dt><dd><p>Shows files in the status listing that would
              normally be omitted since they match a pattern in the
              <code class="literal">global-ignores</code> configuration option
              or the <code class="literal">svn:ignore</code> property.  See <a href="#svn.advanced.confarea.opts.config" title="Config">la sezione chiamata «Config»</a> and <a href="#svn.advanced.props.special.ignore" title="svn:ignore">la sezione chiamata «<code class="literal">svn:ignore</code>»</a> for more
              information.</p></dd><dt><span class="term"><code class="option">--no-unlock</code></span></dt><dd><p>Don't automatically unlock files (the default commit
              behavior is to unlock all files listed as part of the
              commit).  See <a href="#svn.advanced.locking" title="Locking">la sezione chiamata «Locking»</a> for
              more information.</p></dd><dt><span class="term"><code class="option">--non-interactive</code></span></dt><dd><p>In the case of an authentication failure, or
              insufficient credentials, prevents prompting for
              credentials (e.g. username or password).  This is useful
              if you're running Subversion inside of an automated
              script and it's more appropriate to have Subversion fail
              than to prompt for more information.</p></dd><dt><span class="term"><code class="option">--non-recursive</code> (<code class="option">-N</code>)</span></dt><dd><p>Stops a subcommand from recursing into
              subdirectories.  Most subcommands recurse by default,
              but some subcommands—usually those that have the
              potential to remove or undo your local
              modifications—do not.</p></dd><dt><span class="term"><code class="option">--notice-ancestry</code></span></dt><dd><p>Pay attention to ancestry when calculating 
              differences.</p></dd><dt><span class="term"><code class="option">--old</code> <em class="replaceable"><code>ARG</code></em></span></dt><dd><p>Uses <em class="replaceable"><code>ARG</code></em> as the older
              target.</p></dd><dt><span class="term"><code class="option">--password</code>
            <em class="replaceable"><code>PASS</code></em></span></dt><dd><p>Indicates that you are providing your password for
              authentication on the command line—otherwise, if
              it is needed, Subversion will prompt you for
              it.</p></dd><dt><span class="term"><code class="option">--quiet</code> (<code class="option">-q</code>)</span></dt><dd><p>Requests that the client print only essential
              information while performing an operation.</p></dd><dt><span class="term"><code class="option">--recursive</code> (<code class="option">-R</code>)</span></dt><dd><p>Makes a subcommand recurse into subdirectories.
              Most subcommands recurse by default.</p></dd><dt><span class="term"><code class="option">--relocate</code> <em class="replaceable"><code>FROM TO
          [PATH...]</code></em></span></dt><dd><p>Used with the <span><strong class="command">svn switch</strong></span>
              subcommand, changes the location of the repository that
              your working copy references.  This is useful if the
              location of your repository changes and you have an
              existing working copy that you'd like to continue to
              use.  See <span><strong class="command">svn switch</strong></span> for an
              example.</p></dd><dt><span class="term"><code class="option">--revision</code> (<code class="option">-r</code>)
            <em class="replaceable"><code>REV</code></em>
          </span></dt><dd><p>Indicates that you're going to supply a revision (or
              range of revisions) for a particular operation.  You can
              provide revision numbers, revision keywords or dates (in
              curly braces), as arguments to the revision switch.  If
              you wish to provide a range of revisions, you can
              provide two revisions separated by a colon.  For
              example:</p><pre class="screen">
$ svn log -r 1729
$ svn log -r 1729:HEAD
$ svn log -r 1729:1744
$ svn log -r {2001-12-04}:{2002-02-17}
$ svn log -r 1729:{2002-02-17}
</pre><p>See <a href="#svn.tour.revs.keywords" title="Chiavi per le Revisioni">la sezione chiamata «Chiavi per le Revisioni»</a> for more
              information.</p></dd><dt><span class="term"><code class="option">--revprop</code></span></dt><dd><p>Operates on a revision property instead of a
              Subversion property specific to a file or directory.
              This switch requires that you also pass a revision
              with the <code class="option">--revision</code>
              (<code class="option">-r</code>) switch.  See <a href="#svn.reposadmin.basics.revprops" title="Unversioned Properties">la sezione chiamata «Unversioned Properties»</a> for more details on
              unversioned properties.</p></dd><dt><span class="term"><code class="option">--show-updates</code> (<code class="option">-u</code>)</span></dt><dd><p>Causes the client to display information about
              which files in your working copy are out-of-date.
              This doesn't actually update any of your
              files—it just shows you which files will be
              updated if you run <span><strong class="command">svn update</strong></span>.
            </p></dd><dt><span class="term"><code class="option">--stop-on-copy</code></span></dt><dd><p>Causes a Subversion subcommand which is traversing
              the history of a versioned resource to stop harvesting
              that historical information when a copy—that is, a
              location in history where that resource was copied from
              another location in the repository—is
              encountered.</p></dd><dt><span class="term"><code class="option">--strict</code></span></dt><dd><p>Causes Subversion to use strict semantics, a notion
              which is rather vague unless talking about specific
              subcommands.</p></dd><dt><span class="term"><code class="option">--targets</code>
            <em class="replaceable"><code>FILENAME</code></em></span></dt><dd><p>Tells Subversion to get the list of files that you
              wish to operate on from the filename you provide
              instead of listing all the files on the command line.
            </p></dd><dt><span class="term"><code class="option">--username</code>
            <em class="replaceable"><code>NAME</code></em></span></dt><dd><p>Indicates that you are providing your username for
              authentication on the command line—otherwise, if
              it is needed, Subversion will prompt you for
              it.</p></dd><dt><span class="term"><code class="option">--verbose</code> (<code class="option">-v</code>)</span></dt><dd><p>Requests that the client print out as much
              information as it can while running any subcommand.
              This may result in Subversion printing out additional
              fields, detailed information about every file, or
              additional information regarding its actions.</p></dd><dt><span class="term"><code class="option">--version</code></span></dt><dd><p>Prints the client version info.  This information
              not only includes the version number of the client,
              but also a listing of all repository access modules
              that the client can use to access a Subversion
              repository.</p></dd><dt><span class="term"><code class="option">--xml</code></span></dt><dd><p>Prints output in XML format.</p></dd></dl></div></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.ref.svn.c"></a><span><strong class="command">svn</strong></span> Subcommands</h3></div></div></div><div class="refentry" lang="it" xml:lang="it"><a id="svn.ref.svn.c.add"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn add — Add files, directories, or symbolic links.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4764972"></a><h2>Synopsis</h2><pre class="programlisting">svn add PATH...</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4764983"></a><h2>Description</h2><p>Add files, directories, or symbolic links to your
            working copy and schedule them for addition to the
            repository.  They will be uploaded and added to the
            repository on your next commit.  If you add something and
            change your mind before committing, you can unschedule the
            addition using <span><strong class="command">svn revert</strong></span>.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765004"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765014"></a><h2>Changes</h2><p>Working Copy</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765025"></a><h2>Accesses Repository</h2><p>No</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765035"></a><h2>Switches</h2><pre class="screen">
--targets FILENAME
--non-recursive (-N)
--quiet (-q)
--config-dir DIR
--auto-props
--no-auto-props
--force
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765047"></a><h2>Examples</h2><p>To add a file to your working copy:</p><pre class="screen">
$ svn add foo.c 
A         foo.c
</pre><p>When adding a directory, the default behavior of
            <span><strong class="command">svn add</strong></span> is to recurse:</p><pre class="screen">
$ svn add testdir
A         testdir
A         testdir/a
A         testdir/b
A         testdir/c
A         testdir/d
</pre><p>You can add a directory without adding its
            contents:</p><pre class="screen">
$ svn add --non-recursive otherdir
A         otherdir
</pre><p>Normally, the command <span><strong class="command">svn add *</strong></span>
            will skip over any directories that are already under
            version control.  Sometimes, however, you may want to add
            every unversioned object in your working copy, including
            those hiding deeper down.  Passing the
            <code class="option">--force</code> option makes <span><strong class="command">svn
            add</strong></span> recurse into versioned directories:</p><pre class="screen">
$ svn add * --force
A         foo.c
A         somedir/bar.c
A         otherdir/docs/baz.doc
…
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svn.c.blame"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn blame — Show author and revision information in-line
            for the specified files or URLs.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765134"></a><h2>Synopsis</h2><pre class="programlisting">svn blame TARGET[@REV]...</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765144"></a><h2>Description</h2><p>Show author and revision information in-line for the
            specified files or URLs.  Each line of text is annotated
            at the beginning with the author (username) and the
            revision number for the last change to that line.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765158"></a><h2>Alternate Names</h2><p>praise, annotate, ann</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765169"></a><h2>Changes</h2><p>Nothing</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765179"></a><h2>Accesses Repository</h2><p>Yes</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765189"></a><h2>Switches</h2><pre class="screen">
--revision (-r) REV
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
--verbose
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765201"></a><h2>Examples</h2><p>If you want to see blame annotated source for
            <code class="filename">readme.txt</code> in your test
            repository:</p><pre class="screen">
$ svn blame http://svn.red-bean.com/repos/test/readme.txt
     3      sally This is a README file.
     5      harry You should read this.
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svn.c.cat"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn cat — Output the contents of the specified files or
            URLs.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765241"></a><h2>Synopsis</h2><pre class="programlisting">svn cat TARGET[@REV]...</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765251"></a><h2>Description</h2><p>Output the contents of the specified files or URLs.
            For listing the contents of directories, see <span><strong class="command">svn
            list</strong></span>.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765269"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765279"></a><h2>Changes</h2><p>Nothing</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765289"></a><h2>Accesses Repository</h2><p>Yes</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765299"></a><h2>Switches</h2><pre class="screen">
--revision (-r) REV
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765311"></a><h2>Examples</h2><p>If you want to view readme.txt in your repository
            without checking it out:</p><pre class="screen">
$ svn cat http://svn.red-bean.com/repos/test/readme.txt
This is a README file.
You should read this.
</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Suggerimento</h3><p>If your working copy is out of date (or you have
              local modifications) and you want to see the
              <code class="literal">HEAD</code> revision of a file in your
              working copy, <span><strong class="command">svn cat</strong></span> will
              automatically fetch the <code class="literal">HEAD</code> revision
              when you give it a path:</p></div><pre class="screen">
$ cat foo.c
This file is in my local working copy 
and has changes that I've made.

$ svn cat foo.c
Latest revision fresh from the repository!
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svn.c.checkout"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn checkout — Check out a working copy from a repository.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765379"></a><h2>Synopsis</h2><pre class="programlisting">svn checkout URL[@REV]... [PATH]</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765389"></a><h2>Description</h2><p>Check out a working copy from a repository.  If
            <em class="replaceable"><code>PATH</code></em> is omitted, the
            basename of the URL will be used as the destination.
            If multiple URLs are given each will be checked out into a
            subdirectory of <em class="replaceable"><code>PATH</code></em>, with the
            name of the subdirectory being the basename of the
            URL.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765412"></a><h2>Alternate Names</h2><p>co</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765422"></a><h2>Changes</h2><p>Creates a working copy.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765432"></a><h2>Accesses Repository</h2><p>Yes</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765442"></a><h2>Switches</h2><pre class="screen">
--revision (-r) REV
--quiet (-q)
--non-recursive (-N)
--username USER
--password PASS
--no-auth-cache
--non-interactive
--ignore-externals
--config-dir DIR
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765455"></a><h2>Examples</h2><p>Check out a working copy into a directory called
            <code class="filename">mine</code>:</p><pre class="screen">
$ svn checkout file:///tmp/repos/test mine
A  mine/a
A  mine/b
Checked out revision 2.
$ ls
mine
</pre><p>Check out 2 different directories into two separate
            working copies:</p><pre class="screen">
$ svn checkout file:///tmp/repos/test  file:///tmp/repos/quiz
A  test/a
A  test/b
Checked out revision 2.
A  quiz/l
A  quiz/m
Checked out revision 2.
$ ls
quiz  test
</pre><p>Check out 2 different directories into two separate
            working copies, but place both into a directory called
            <code class="filename">working-copies</code>:</p><pre class="screen">
$ svn checkout file:///tmp/repos/test  file:///tmp/repos/quiz working-copies
A  working-copies/test/a
A  working-copies/test/b
Checked out revision 2.
A  working-copies/quiz/l
A  working-copies/quiz/m
Checked out revision 2.
$ ls
working-copies
</pre><p>If you interrupt a checkout (or something else
            interrupts your checkout like loss of connectivity, etc.),
            you can restart it either by issuing the
            identical checkout command again, or by updating the
            incomplete working copy:</p><pre class="screen">
$ svn checkout file:///tmp/repos/test test
A  test/a
A  test/b
^C
svn: The operation was interrupted
svn: caught SIGINT

$ svn checkout file:///tmp/repos/test test
A  test/c
A  test/d
^C
svn: The operation was interrupted
svn: caught SIGINT

$ cd test
$ svn update
A  test/e
A  test/f
Updated to revision 3.
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svn.c.cleanup"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn cleanup — Recursively clean up the working copy.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765539"></a><h2>Synopsis</h2><pre class="programlisting">svn cleanup [PATH...]</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765550"></a><h2>Description</h2><p>Recursively clean up the working copy, removing
            working copy locks and resuming unfinished operations.
            If you ever get a «<span class="quote">working copy locked</span>» error,
            run this command to remove stale locks and get your working copy
            into a usable state again.</p><p>If, for some reason, an <span><strong class="command">svn update</strong></span>
            fails due to a problem running an external diff program
            (e.g. user input or network failure), pass the
            <code class="option">--diff3-cmd</code> to allow cleanup to complete
            any merging with your external diff program.  You can also
            specify any configuration directory with the
            <code class="option">--config-dir</code> switch, but you should need
            these switches extremely infrequently.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765591"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765601"></a><h2>Changes</h2><p>Working copy</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765612"></a><h2>Accesses Repository</h2><p>No</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765622"></a><h2>Switches</h2><pre class="screen">
--diff3-cmd CMD
--config-dir DIR
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765632"></a><h2>Examples</h2><p>Well, there's not much to the examples here as
            <span><strong class="command">svn cleanup</strong></span> generates no output.  If
            you pass no <em class="replaceable"><code>PATH</code></em>,
            «<span class="quote"><code class="filename">.</code></span>» is used.</p><pre class="screen">
$ svn cleanup

$ svn cleanup /path/to/working-copy
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svn.c.commit"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn commit — Send changes from your working copy to the repository.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765681"></a><h2>Synopsis</h2><pre class="programlisting">svn commit [PATH...]</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765692"></a><h2>Description</h2><p>Send changes from your working copy to the
            repository.  If you do not supply a log message with your
            commit by using either the <code class="option">--file</code> or
            <code class="option">--message</code> switch,
            <span><strong class="command">svn</strong></span> will launch your editor for you
            to compose a commit message.  See the
            <code class="literal">editor-cmd</code> section in <a href="#svn.advanced.confarea.opts.config" title="Config">la sezione chiamata «Config»</a>.</p><p><span><strong class="command">svn commit</strong></span> will send found lock
            tokens and release locks on all
            <em class="replaceable"><code>PATHS</code></em> committed (recursively)
            unless <code class="option">--no-unlock</code> is passed.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Suggerimento</h3><p>If you begin a commit and Subversion launches your
              editor to compose the commit message, you can still
              abort without committing your changes.  If you want to
              cancel your commit, just quit your editor without saving
              your commit message and Subversion will prompt you to
              either abort the commit, continue with no message, or
              edit the message again.</p></div></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765762"></a><h2>Alternate Names</h2><p>ci (short for «<span class="quote">check in</span>»; not 
            «<span class="quote">co</span>», which is short for 
            «<span class="quote">checkout</span>»)</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765784"></a><h2>Changes</h2><p>Working copy, repository</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765794"></a><h2>Accesses Repository</h2><p>Yes</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765804"></a><h2>Switches</h2><pre class="screen">
--message (-m) TEXT
--file (-F) FILE
--quiet (-q)
--no-unlock
--non-recursive (-N)
--targets FILENAME
--force-log
--username USER
--password PASS
--no-auth-cache
--non-interactive
--encoding ENC
--config-dir DIR
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765818"></a><h2>Examples</h2><p>Commit a simple modification to a file with the
            commit message on the command line and an implicit
            target of your current directory
            («<span class="quote"><code class="filename">.</code></span>»):</p><pre class="screen">
$ svn commit -m "added howto section."
Sending        a
Transmitting file data .
Committed revision 3.
</pre><p>Commit a modification to the file
            <code class="filename">foo.c</code> (explicitly specified on the
            command line) with the commit message in a file named
            <code class="literal">msg</code>:</p><pre class="screen">
$ svn commit -F msg foo.c
Sending        foo.c
Transmitting file data .
Committed revision 5.
</pre><p>If you want to use a file that's under version
            control for your commit message with
            <code class="option">--file</code>, you need to pass the
            <code class="option">--force-log</code> switch:</p><pre class="screen">
$ svn commit --file file_under_vc.txt foo.c
svn: The log message file is under version control
svn: Log message file is a versioned file; use '--force-log' to override

$ svn commit --force-log --file file_under_vc.txt foo.c
Sending        foo.c
Transmitting file data .
Committed revision 6.
</pre><p>To commit a file scheduled for deletion:</p><pre class="screen">
$ svn commit -m "removed file 'c'."
Deleting       c

Committed revision 7.
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svn.c.copy"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn copy — Copy a file or directory in a working copy or
            in the repository.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765911"></a><h2>Synopsis</h2><pre class="programlisting">svn copy SRC DST</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4765921"></a><h2>Description</h2><p>Copy a file in a working copy or in the repository.
            <em class="replaceable"><code>SRC</code></em> and
            <em class="replaceable"><code>DST</code></em> can each be either a
            working copy (WC) path or URL:</p><div class="variablelist"><dl><dt><span class="term">WC  -&gt; WC</span></dt><dd><p>Copy and schedule an item for
                    addition (with history).</p></dd><dt><span class="term">WC  -&gt; URL</span></dt><dd><p>Immediately commit a copy of WC to URL.</p></dd><dt><span class="term">URL -&gt; WC</span></dt><dd><p>Check out URL into WC, and schedule it for
                    addition.</p></dd><dt><span class="term">URL -&gt; URL</span></dt><dd><p>Complete server-side copy.  This is
                    usually used to branch and tag.</p></dd></dl></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Nota</h3><p>You can only copy files within a single repository.
              Subversion does not support cross-repository copying.</p></div></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4766010"></a><h2>Alternate Names</h2><p>cp</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4766020"></a><h2>Changes</h2><p>Repository if destination is a URL.</p><p>Working copy if destination is a WC path.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4766035"></a><h2>Accesses Repository</h2><p>If source or destination is in the repository, or if needed
            to look up the source revision number.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4766047"></a><h2>Switches</h2><pre class="screen">
--message (-m) TEXT
--file (-F) FILE
--revision (-r) REV
--quiet (-q)
--username USER
--password PASS
--no-auth-cache
--non-interactive
--force-log
--editor-cmd EDITOR
--encoding ENC
--config-dir DIR
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4766060"></a><h2>Examples</h2><p>Copy an item within your working copy (just
            schedules the copy—nothing goes into the repository
            until you commit):</p><pre class="screen">
$ svn copy foo.txt bar.txt
A         bar.txt
$ svn status
A  +   bar.txt
</pre><p>Copy an item in your working copy to a URL in the
            repository (an immediate commit, so you must supply a
            commit message):</p><pre class="screen">
$ svn copy near.txt file:///tmp/repos/test/far-away.txt -m "Remote copy."

Committed revision 8.
</pre><p>Copy an item from the repository to your working
            copy (just schedules the copy—nothing goes into the
            repository until you commit):</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Suggerimento</h3><p>This is the recommended way to resurrect a dead
              file in your repository!</p></div><pre class="screen">
$ svn copy file:///tmp/repos/test/far-away near-here
A         near-here
</pre><p>And finally, copying between two URLs:</p><pre class="screen">
$ svn copy file:///tmp/repos/test/far-away file:///tmp/repos/test/over-there -m "remote copy."

Committed revision 9.
</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Suggerimento</h3><p>This is the easiest way to «<span class="quote">tag</span>» a
              revision in your repository—just <span><strong class="command">svn
              copy</strong></span> that revision (usually
              <code class="literal">HEAD</code>) into your tags directory.</p></div><pre class="screen">
$ svn copy file:///tmp/repos/test/trunk file:///tmp/repos/test/tags/0.6.32-prerelease -m "tag tree"

Committed revision 12.
</pre><p>And don't worry if you forgot to tag—you can
            always specify an older revision and tag anytime:</p><pre class="screen">
$ svn copy -r 11 file:///tmp/repos/test/trunk file:///tmp/repos/test/tags/0.6.32-prerelease -m "Forgot to tag at rev 11"

Committed revision 13.
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svn.c.delete"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn delete — Delete an item from a working copy
            or the repository.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4766180"></a><h2>Synopsis</h2><pre class="programlisting">svn delete PATH...</pre><pre class="programlisting">svn delete URL...</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4766194"></a><h2>Description</h2><p>Items specified by <em class="replaceable"><code>PATH</code></em> are scheduled
            for deletion upon the next commit.  Files (and
            directories that have not been committed) are
            immediately removed from the working copy.  The command
            will not remove any unversioned or modified items; use
            the <code class="option">--force</code> switch to override this
            behavior.</p><p>Items specified by URL are deleted from
            the repository via an immediate commit.  Multiple URLs are
            committed atomically.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4766223"></a><h2>Alternate Names</h2><p>del, remove, rm</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4766233"></a><h2>Changes</h2><p>Working copy if operating on files, Repository if
            operating on URLs</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4766244"></a><h2>Accesses Repository</h2><p>Only if operating on URLs</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4766255"></a><h2>Switches</h2><pre class="screen">
--force
--force-log
--message (-m) TEXT
--file (-F) FILE
--quiet (-q)
--targets FILENAME
--username USER
--password PASS
--no-auth-cache
--non-interactive
--editor-cmd EDITOR
--encoding ENC
--config-dir DIR
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4766268"></a><h2>Examples</h2><p>Using <span><strong class="command">svn</strong></span> to delete a file from
            your working copy merely schedules it to be
            deleted.  When you commit, the file is deleted in the
            repository.</p><pre class="screen">
$ svn delete myfile
D         myfile

$ svn commit -m "Deleted file 'myfile'."
Deleting       myfile
Transmitting file data .
Committed revision 14.
</pre><p>Deleting a URL, however, is immediate, so you have
            to supply a log message:</p><pre class="screen">
$ svn delete -m "Deleting file 'yourfile'" file:///tmp/repos/test/yourfile

Committed revision 15.
</pre><p>Here's an example of how to force deletion of a file
            that has local mods:</p><pre class="screen">
$ svn delete over-there 
svn: Attempting restricted operation for modified resource
svn: Use --force to override this restriction
svn: 'over-there' has local modifications

$ svn delete --force over-there 
D         over-there
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svn.c.diff"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn diff — Display the differences between two paths.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4766331"></a><h2>Synopsis</h2><pre class="programlisting">diff [-r N[:M]] [TARGET[@REV]...]</pre><pre class="programlisting">diff [-r N[:M]] --old OLD-TGT[@OLDREV] [--new NEW-TGT[@NEWREV]] [PATH...]</pre><pre class="programlisting">diff OLD-URL[@OLDREV] NEW-URL[@NEWREV]</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4766350"></a><h2>Description</h2><p>Display the differences between two paths.  The three
            different ways you can use <span><strong class="command">svn diff</strong></span>
            are:</p><p><span><strong class="command">svn diff [-r N[:M]] [--old OLD-TGT] [--new
            NEW-TGT] [PATH...]</strong></span> displays the differences
            between <em class="replaceable"><code>OLD-TGT</code></em> and
            <em class="replaceable"><code>NEW-TGT</code></em>.  If
            <em class="replaceable"><code>PATH</code></em>s are given, they are
            treated as relative to <em class="replaceable"><code>OLD-TGT</code></em>
            and <em class="replaceable"><code>NEW-TGT</code></em> and the output is
            restricted to differences in only those paths.
            <em class="replaceable"><code>OLD-TGT</code></em> and
            <em class="replaceable"><code>NEW-TGT</code></em> may be working copy
            paths or
            <em class="replaceable"><code>URL</code></em><code class="literal">[@</code><em class="replaceable"><code>REV</code></em><code class="literal">]</code>.
            <em class="replaceable"><code>OLD-TGT</code></em> defaults to the current
            working directory and <em class="replaceable"><code>NEW-TGT</code></em>
            defaults to <em class="replaceable"><code>OLD-TGT</code></em>.
            <em class="replaceable"><code>N</code></em> defaults to
            <code class="literal">BASE</code> or, if
            <em class="replaceable"><code>OLD-TGT</code></em> is a URL, to
            <code class="literal">HEAD</code>.  <em class="replaceable"><code>M</code></em>
            defaults to the current working version or, if
            <em class="replaceable"><code>NEW-TGT</code></em> is a URL, to
            <code class="literal">HEAD</code>.  <span><strong class="command">svn diff -r N</strong></span>
            sets the revision of <em class="replaceable"><code>OLD-TGT</code></em> to
            <em class="replaceable"><code>N</code></em>, <span><strong class="command">svn diff -r
            N:M</strong></span> also sets the revision of
            <em class="replaceable"><code>NEW-TGT</code></em> to
            <em class="replaceable"><code>M</code></em>.</p><p><span><strong class="command">svn diff -r N:M URL</strong></span> is shorthand
            for <span><strong class="command">svn diff -r N:M --old=URL
            --new=URL</strong></span>.</p><p><span><strong class="command">svn diff [-r N[:M]] URL1[@N]
            URL2[@M]</strong></span> is shorthand for <span><strong class="command">svn diff [-r
            N[:M]] --old=URL1 --new=URL2</strong></span>.</p><p>If <em class="replaceable"><code>TARGET</code></em> is a URL, then
            revs N and M can be given either via the
            <code class="option">--revision</code> or by using
            «<span class="quote">@</span>» notation as described earlier.</p><p>If <em class="replaceable"><code>TARGET</code></em> is a working copy
            path, then the <code class="option">--revision</code> switch
            means:</p><div class="variablelist"><dl><dt><span class="term"><code class="option">--revision N:M</code></span></dt><dd><p>The server compares
                  <em class="replaceable"><code>TARGET</code></em>@<em class="replaceable"><code>N</code></em>
                  and
                  <em class="replaceable"><code>TARGET</code></em>@<em class="replaceable"><code>M</code></em>.</p></dd><dt><span class="term"><code class="option">--revision N</code></span></dt><dd><p>The client compares
                  <em class="replaceable"><code>TARGET</code></em>@<em class="replaceable"><code>N</code></em>
                  against working copy.</p></dd><dt><span class="term">(no <code class="option">--revision</code>)</span></dt><dd><p>The client compares base and working copies of
                  <em class="replaceable"><code>TARGET</code></em>.</p></dd></dl></div><p>If the alternate syntax is used, the server compares
            <em class="replaceable"><code>URL1</code></em> and
            <em class="replaceable"><code>URL2</code></em> at revisions
            <em class="replaceable"><code>N</code></em> and
            <em class="replaceable"><code>M</code></em> respectively.  If either
            <em class="replaceable"><code>N</code></em> or
            <em class="replaceable"><code>M</code></em> are omitted, a value of
            <code class="literal">HEAD</code> is assumed.</p><p>By default, <span><strong class="command">svn diff</strong></span> ignores the
            ancestry of files and merely compares the contents of the
            two files being compared.  If you use
            <code class="option">--notice-ancestry</code>, the ancestry of the
            paths in question will be taken into consideration when
            comparing revisions (that is, if you run <span><strong class="command">svn
            diff</strong></span> on two files with identical contents but
            different ancestry you will see the entire contents of the
            file as having been removed and added again).</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4766691"></a><h2>Alternate Names</h2><p>di</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4766701"></a><h2>Changes</h2><p>Nothing</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4766711"></a><h2>Accesses Repository</h2><p>For obtaining differences against anything but
            <code class="literal">BASE</code> revision in your working copy</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4766728"></a><h2>Switches</h2><pre class="screen">
--revision (-r) REV
--old OLD-TARGET
--new NEW-TARGET
--extensions (-x) "ARGS"
--non-recursive (-N)
--diff-cmd CMD
--notice-ancestry
--username USER
--password PASS
--no-auth-cache
--non-interactive
--no-diff-deleted
--config-dir DIR
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4766742"></a><h2>Examples</h2><p>Compare <code class="literal">BASE</code> and your working copy
            (one of the most popular uses of <span><strong class="command">svn
            diff</strong></span>):</p><pre class="screen">
$ svn diff COMMITTERS 
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 4404)
+++ COMMITTERS	(working copy)
</pre><p>See how your working copy's modifications compare
            against an older revision:</p><pre class="screen">
$ svn diff -r 3900 COMMITTERS 
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3900)
+++ COMMITTERS	(working copy)
</pre><p>Compare revision 3000 to revision 3500 using «<span class="quote">@</span>»
            syntax:</p><pre class="screen">
$ svn diff http://svn.collab.net/repos/svn/trunk/COMMITTERS@3000 http://svn.collab.net/repos/svn/trunk/COMMITTERS@3500
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3000)
+++ COMMITTERS	(revision 3500)
…
</pre><p>Compare revision 3000 to revision 3500 using range
            notation (you only pass the one URL in this
            case):</p><pre class="screen">
$ svn diff -r 3000:3500 http://svn.collab.net/repos/svn/trunk/COMMITTERS
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3000)
+++ COMMITTERS	(revision 3500)
</pre><p>Compare revision 3000 to revision 3500 of all files in
            <code class="filename">trunk</code> using range notation:</p><pre class="screen">
$ svn diff -r 3000:3500 http://svn.collab.net/repos/svn/trunk
          </pre><p>Compare revision 3000 to revision 3500 of only three
            files in <code class="filename">trunk</code> using range
            notation:</p><pre class="screen">
$ svn diff -r 3000:3500 --old http://svn.collab.net/repos/svn/trunk COMMITTERS README HACKING
          </pre><p>If you have a working copy, you can obtain the
            differences without typing in the long URLs:</p><pre class="screen">
$ svn diff -r 3000:3500 COMMITTERS 
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3000)
+++ COMMITTERS	(revision 3500)
</pre><p>Use <code class="option">--diff-cmd</code>
            <em class="replaceable"><code>CMD</code></em> <code class="option">-x</code> to
            pass arguments directly to the external diff
            program</p><pre class="screen">
$ svn diff --diff-cmd /usr/bin/diff -x "-i -b" COMMITTERS 
Index: COMMITTERS
===================================================================
0a1,2
&gt; This is a test
&gt; 
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svn.c.export"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn export — Export a clean directory tree.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4766898"></a><h2>Synopsis</h2><pre class="programlisting">svn export [-r REV] URL[@PEGREV] [PATH]</pre><pre class="programlisting">svn export [-r REV] PATH1[@PEGREV] [PATH2]</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4766913"></a><h2>Description</h2><p>The first form exports a clean directory tree from the
            repository specified by URL, at revision
            <em class="replaceable"><code>REV</code></em> if it is given, otherwise
            at <code class="literal">HEAD</code>, into
            <em class="replaceable"><code>PATH</code></em>.  If
            <em class="replaceable"><code>PATH</code></em> is omitted, the last
            component of the <em class="replaceable"><code>URL</code></em> is used
            for the local directory name.</p><p>The second form exports a clean directory tree from
            the working copy specified by
            <em class="replaceable"><code>PATH1</code></em> into
            <em class="replaceable"><code>PATH2</code></em>.  All local changes will
            be preserved, but files not under version control will not
            be copied.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4766962"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4766972"></a><h2>Changes</h2><p>Local disk</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4766982"></a><h2>Accesses Repository</h2><p>Only if exporting from a URL</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4766993"></a><h2>Switches</h2><pre class="screen">
--revision (-r) REV
--quiet (-q)
--force
--username USER
--password PASS
--no-auth-cache
--non-interactive
--non-recursive
--config-dir DIR
--native-eol EOL
--ignore-externals
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767006"></a><h2>Examples</h2><p>Export from your working copy (doesn't print every
            file and directory):</p><pre class="screen">
$ svn export a-wc my-export
Export complete.
</pre><p>Export directly from the repository (prints every
            file and directory):</p><pre class="screen">
$ svn export file:///tmp/repos my-export
A  my-export/test
A  my-export/quiz
…
Exported revision 15.
</pre><p>When rolling operating-system-specific release
            packages, it can be useful to export a tree which uses a
            specific EOL character for line endings.  The
            <code class="option">--native-eol</code> option will do this, but it
            only affects files that have <code class="literal">svn:eol-style =
            native</code> properties attached to them.  For
            example, to export a tree with all CRLF line endings
            (possibly for a Windows .zip file distribution):</p><pre class="screen">
$ svn export file://tmp/repos my-export --native-eol CRLF
A  my-export/test
A  my-export/quiz
…
Exported revision 15.
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svn.c.help"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn help — Help!</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767076"></a><h2>Synopsis</h2><pre class="programlisting">svn help [SUBCOMMAND...]</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767086"></a><h2>Description</h2><p>This is your best friend when you're using
            Subversion and this book isn't within reach!</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767098"></a><h2>Alternate Names</h2><p>?, h</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767108"></a><h2>Changes</h2><p>Nothing</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767118"></a><h2>Accesses Repository</h2><p>No</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767128"></a><h2>Switches</h2><pre class="screen">
--version
--quiet (-q)
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svn.c.import"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn import — Commit an unversioned file or tree into the 
            repository.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767156"></a><h2>Synopsis</h2><pre class="programlisting">svn import [PATH] URL</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767166"></a><h2>Description</h2><p>Recursively commit a copy of
            <em class="replaceable"><code>PATH</code></em> to
            <em class="replaceable"><code>URL</code></em>.  If
            <em class="replaceable"><code>PATH</code></em> is omitted
            «<span class="quote"><code class="filename">.</code></span>» is assumed.  Parent
            directories are created in the repository as
            necessary.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767197"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767207"></a><h2>Changes</h2><p>Repository</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767217"></a><h2>Accesses Repository</h2><p>Yes</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767227"></a><h2>Switches</h2><pre class="screen">
--message (-m) TEXT
--file (-F) FILE
--quiet (-q)
--non-recursive (-N)
--username USER
--password PASS
--no-auth-cache
--non-interactive
--force-log
--editor-cmd EDITOR
--encoding ENC
--config-dir DIR
--auto-props
--no-auto-props
--ignore-externals
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767241"></a><h2>Examples</h2><p>This imports the local directory <code class="filename">myproj</code> into the
            root of your repository:</p><pre class="screen">
$ svn import -m "New import" myproj http://svn.red-bean.com/repos/test
Adding         myproj/sample.txt
…
Transmitting file data .........
Committed revision 16.
</pre><p>This imports the local directory <code class="filename">myproj</code>
            into <code class="filename">trunk/misc</code> in your repository.  The
            directory <code class="filename">trunk/misc</code> need not exist before
            you import into it—<span><strong class="command">svn import</strong></span> will
            recursively create directories for you:</p><pre class="screen">
$ svn import -m "New import" myproj \
    http://svn.red-bean.com/repos/test/trunk/misc/myproj
Adding         myproj/sample.txt
…
Transmitting file data .........
Committed revision 19.
</pre><p>After importing data, note that the original tree is
            <span class="emphasis"><em>not</em></span> under version control.  To start
            working, you still need to <span><strong class="command">svn checkout</strong></span>
            a fresh working copy of the tree.</p></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svn.c.info"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn info — Display information about a local or remote 
            item.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767340"></a><h2>Synopsis</h2><pre class="programlisting">svn info [TARGET...]</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767351"></a><h2>Description</h2><p>Print information about both working copy paths and
            URLs, including:</p><div class="itemizedlist"><ul type="disc"><li><p>Path</p></li><li><p>Name</p></li><li><p>URL</p></li><li><p>Revision</p></li><li><p>Repository Root</p></li><li><p>Repository UUID</p></li><li><p>Node Kind</p></li><li><p>Last Changed Author</p></li><li><p>Last Changed Revision</p></li><li><p>Last Changed Date</p></li><li><p>Text Last Updated</p></li><li><p>Properties Last Updated</p></li><li><p>Checksum</p></li><li><p>Lock Token</p></li><li><p>Lock Owner</p></li><li><p>Lock Creation Date</p></li></ul></div></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767439"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767449"></a><h2>Changes</h2><p>Nothing</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767459"></a><h2>Accesses Repository</h2><p>Only if operating on URLs</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767470"></a><h2>Switches</h2><pre class="screen">
--targets FILENAME
--recursive (-R)
--revision (-r)
--config-dir DIR
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767481"></a><h2>Examples</h2><p><span><strong class="command">svn info</strong></span> will show you all the
            useful information that it has for items in your working
            copy.  It will show information for files:</p><pre class="screen">
$ svn info foo.c
Path: foo.c
Name: foo.c
URL: http://svn.red-bean.com/repos/test/foo.c
Repository Root: http://svn.red-bean.com/repos/test
Repository UUID: 5e7d134a-54fb-0310-bd04-b611643e5c25
Revision: 4417
Node Kind: file
Schedule: normal
Last Changed Author: sally
Last Changed Rev: 20
Last Changed Date: 2003-01-13 16:43:13 -0600 (Mon, 13 Jan 2003)
Text Last Updated: 2003-01-16 21:18:16 -0600 (Thu, 16 Jan 2003)
Properties Last Updated: 2003-01-13 21:50:19 -0600 (Mon, 13 Jan 2003)
Checksum: /3L38YwzhT93BWvgpdF6Zw==
</pre><p>It will also show information for directories:</p><pre class="screen">
$ svn info vendors
Path: vendors
URL: http://svn.red-bean.com/repos/test/vendors
Repository Root: http://svn.red-bean.com/repos/test
Repository UUID: 5e7d134a-54fb-0310-bd04-b611643e5c25
Revision: 19
Node Kind: directory
Schedule: normal
Last Changed Author: harry
Last Changed Rev: 19
Last Changed Date: 2003-01-16 23:21:19 -0600 (Thu, 16 Jan 2003)
</pre><p><span><strong class="command">svn info</strong></span> also acts on URLs (also
             note that the file readme.doc in this example is locked,
             so lock information is also provided):</p><pre class="screen">
$ svn info http://svn.red-bean.com/repos/test/readme.doc
Path: readme.doc
Name: readme.doc
URL: http://svn.red-bean.com/repos/test/readme.doc
Repository Root: http://svn.red-bean.com/repos/test
Repository UUID: 5e7d134a-54fb-0310-bd04-b611643e5c25
Revision: 1
Node Kind: file
Schedule: normal
Last Changed Author: sally
Last Changed Rev: 42
Last Changed Date: 2003-01-14 23:21:19 -0600 (Tue, 14 Jan 2003)
Text Last Updated: 2003-01-14 23:21:19 -0600 (Tue, 14 Jan 2003)
Checksum: d41d8cd98f00b204e9800998ecf8427e
Lock Token: opaquelocktoken:14011d4b-54fb-0310-8541-dbd16bd471b2
Lock Owner: harry
Lock Created: 2003-01-15 17:35:12 -0600 (Wed, 15 Jan 2003)
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svn.c.list"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn list — List directory entries in the repository.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767565"></a><h2>Synopsis</h2><pre class="programlisting">svn list [TARGET[@REV]...]</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767576"></a><h2>Description</h2><p>List each <em class="replaceable"><code>TARGET</code></em> file and
            the contents of each <em class="replaceable"><code>TARGET</code></em>
            directory as they exist in the repository.  If
            <em class="replaceable"><code>TARGET</code></em> is a working copy path,
            the corresponding repository URL will be used.</p><p>The default <em class="replaceable"><code>TARGET</code></em> is
            «<span class="quote"><code class="filename">.</code></span>», meaning the
            repository URL of the current working copy
            directory.</p><p>With <code class="option">--verbose</code>, the following fields show
            the status of the item:</p><div class="itemizedlist"><ul type="disc"><li><p>Revision number of the last
            commit</p></li><li><p>Author of the
            last commit</p></li><li><p>Size (in
            bytes)</p></li><li><p>Date and time of
            the last commit</p></li></ul></div><p>With <code class="option">--xml</code>, output is in XML format (with
            a header and an enclosing document element unless
            <code class="option">--incremental</code> is also specified).  All of the
            information is present; the <code class="option">--verbose</code> option
            is not accepted.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767665"></a><h2>Alternate Names</h2><p>ls</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767675"></a><h2>Changes</h2><p>Nothing</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767685"></a><h2>Accesses Repository</h2><p>Yes</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767695"></a><h2>Switches</h2><pre class="screen">
--revision (-r) REV
--verbose (-v)
--recursive (-R)
--incremental
--xml
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767708"></a><h2>Examples</h2><p><span><strong class="command">svn list</strong></span> is most useful if you
            want to see what files a repository has without
            downloading a working copy:</p><pre class="screen">
$ svn list http://svn.red-bean.com/repos/test/support
README.txt
INSTALL
examples/
…
</pre><p>You can pass the <code class="option">--verbose</code> switch for
            additional information, rather like the UNIX command
            <span><strong class="command">ls -l</strong></span>:</p><pre class="screen">
$ svn list --verbose file:///tmp/repos
     16 sally         28361 Jan 16 23:18 README.txt
     27 sally             0 Jan 18 15:27 INSTALL
     24 harry               Jan 18 11:27 examples/
</pre><p>For further details, see <a href="#svn.tour.history.list" title="svn list">la sezione chiamata «<span><strong class="command">svn list</strong></span>»</a>.</p></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svn.c.lock"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn lock — Lock working copy paths or URLs in the
              repository, so that no other user can commit changes to
              them.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767778"></a><h2>Synopsis</h2><pre class="programlisting">svn lock TARGET...</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767788"></a><h2>Description</h2><p>Lock each <em class="replaceable"><code>TARGET</code></em>.  If any
            <em class="replaceable"><code>TARGET</code></em> is already locked by
            another user, print a warning and continue locking the
            rest of the <em class="replaceable"><code>TARGET</code></em>s.  Use
            <code class="option">--force</code> to steal a lock from another user
            or working copy.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767816"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767827"></a><h2>Changes</h2><p>Working Copy, Repository</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767837"></a><h2>Accesses Repository</h2><p>Yes</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767847"></a><h2>Switches</h2><pre class="screen">
--targets ARG
--message (-m) ARG
--file (-F) ARG
--force-log
--encoding ARG
--username ARG
--password ARG
--no-auth-cache
--non-interactive
--config-dir ARG
--force
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767860"></a><h2>Examples</h2><p>Lock two files in your working copy:</p><pre class="screen">

$ svn lock tree.jpg house.jpg
'tree.jpg' locked by user 'harry'.
'house.jpg' locked by user 'harry'.
</pre><p>Lock a file in your working copy that is currently
            locked by another user:</p><pre class="screen">
$ svn lock tree.jpg
svn: warning: Path '/tree.jpg is already locked by user 'harry in \
     filesystem '/svn/repos/db'

$ svn lock --force foo
'tree.jpg' locked by user 'sally'.
</pre><p>Lock a file without a working copy:</p><pre class="screen">
$ svn lock http://svn.red-bean.com/repos/test/tree.jpg
'tree.jpg' locked by user 'sally'.
</pre><p>For further details, see <a href="#svn.advanced.locking" title="Locking">la sezione chiamata «Locking»</a>.</p></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svn.c.log"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn log — Display commit log messages.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767920"></a><h2>Synopsis</h2><pre class="programlisting">svn log [PATH]</pre><pre class="programlisting">svn log URL [PATH...]</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4767934"></a><h2>Description</h2><p>The default target is the path of your current
            directory.  If no arguments are supplied, <span><strong class="command">svn
            log</strong></span> shows the log messages for all files and
            directories inside of (and including) the current working
            directory of your working copy.  You can refine the
            results by specifying a path, one or more revisions, or
            any combination of the two.  The default revision range
            for a local path is <code class="literal">BASE:1</code>.</p><p>If you specify a URL alone, then it prints log
            messages for everything that the URL contains.  If you
            add paths past the URL, only messages for those paths
            under that URL will be printed.  The default revision range
            for a URL is <code class="literal">HEAD:1</code>.</p><p>With <code class="option">--verbose</code>, <span><strong class="command">svn log</strong></span>
            will also print all affected paths with each log message.
            With <code class="option">--quiet</code>, <span><strong class="command">svn log</strong></span>
            will not print the log message body itself (this is
            compatible with <code class="option">--verbose</code>).</p><p>Each log message is printed just once, even if more
            than one of the affected paths for that revision were
            explicitly requested.  Logs follow copy history by
            default.  Use <code class="option">--stop-on-copy</code> to disable
            this behavior, which can be useful for determining branch
            points.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768018"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768028"></a><h2>Changes</h2><p>Nothing</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768038"></a><h2>Accesses Repository</h2><p>Yes</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768048"></a><h2>Switches</h2><pre class="screen">
--revision (-r) REV
--quiet (-q)
--verbose (-v)
--targets FILENAME
--stop-on-copy
--incremental
--limit NUM
--xml
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768062"></a><h2>Examples</h2><p>You can see the log messages for all the paths that
            changed in your working copy by running <span><strong class="command">svn
            log</strong></span> from the top:</p><pre class="screen">
$ svn log
------------------------------------------------------------------------
r20 | harry | 2003-01-17 22:56:19 -0600 (Fri, 17 Jan 2003) | 1 line

Tweak.
------------------------------------------------------------------------
r17 | sally | 2003-01-16 23:21:19 -0600 (Thu, 16 Jan 2003) | 2 lines
…
</pre><p>Examine all log messages for a particular file in
            your working copy:</p><pre class="screen">
$ svn log foo.c
------------------------------------------------------------------------
r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line

Added defines.
------------------------------------------------------------------------
r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines
…
</pre><p>If you don't have a working copy handy, you can log
            a URL:</p><pre class="screen">
$ svn log http://svn.red-bean.com/repos/test/foo.c
------------------------------------------------------------------------
r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line

Added defines.
------------------------------------------------------------------------
r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines
…
</pre><p>If you want several distinct paths underneath the
            same URL, you can use the <code class="literal">URL [PATH...]</code>
            syntax.</p><pre class="screen">
$ svn log http://svn.red-bean.com/repos/test/ foo.c bar.c
------------------------------------------------------------------------
r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line

Added defines.
------------------------------------------------------------------------
r31 | harry | 2003-01-10 12:25:08 -0600 (Fri, 10 Jan 2003) | 1 line

Added new file bar.c
------------------------------------------------------------------------
r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines
…
</pre><p>When you're concatenating the results of multiple
            calls to the log command, you may want to use the
            <code class="option">--incremental</code> switch. <span><strong class="command">svn
            log</strong></span> normally prints out a dashed line at the
            beginning of a log message, after each subsequent log
            message, and following the final log message.  If you
            ran <span><strong class="command">svn log</strong></span> on a range of two
            revisions, you would get this:</p><pre class="screen">
$ svn log -r 14:15
------------------------------------------------------------------------
r14 | ... 

------------------------------------------------------------------------
r15 | ... 

------------------------------------------------------------------------
</pre><p>However, if you wanted to gather 2 non-sequential
            log messages into a file, you might do something like
            this:</p><pre class="screen">
$ svn log -r 14 &gt; mylog
$ svn log -r 19 &gt;&gt; mylog
$ svn log -r 27 &gt;&gt; mylog
$ cat mylog
------------------------------------------------------------------------
r14 | ... 

------------------------------------------------------------------------
------------------------------------------------------------------------
r19 | ... 

------------------------------------------------------------------------
------------------------------------------------------------------------
r27 | ... 

------------------------------------------------------------------------
</pre><p>You can avoid the clutter of the double dashed lines
            in your output by using the incremental switch:</p><pre class="screen">
$ svn log --incremental -r 14 &gt; mylog
$ svn log --incremental -r 19 &gt;&gt; mylog
$ svn log --incremental -r 27 &gt;&gt; mylog
$ cat mylog
------------------------------------------------------------------------
r14 | ... 

------------------------------------------------------------------------
r19 | ... 

------------------------------------------------------------------------
r27 | ... 
</pre><p>The <code class="option">--incremental</code> switch provides
            similar output control when using the
            <code class="option">--xml</code> switch.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Suggerimento</h3><p>If you run <span><strong class="command">svn log</strong></span> on a specific
              path and provide a specific revision and get no output
              at all</p><pre class="screen">
$ svn log -r 20 http://svn.red-bean.com/untouched.txt
------------------------------------------------------------------------
</pre><p>That just means that the path was not modified in
              that revision.  If you log from the top of the
              repository, or know the file that changed in that
              revision, you can specify it explicitly:</p><pre class="screen">
$ svn log -r 20 touched.txt 
------------------------------------------------------------------------
r20 | sally | 2003-01-17 22:56:19 -0600 (Fri, 17 Jan 2003) | 1 line

Made a change.
------------------------------------------------------------------------
</pre></div></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svn.c.merge"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn merge — Apply the differences between two sources to a
          working copy path.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768315"></a><h2>Synopsis</h2><pre class="programlisting">svn merge sourceURL1[@N] sourceURL2[@M] [WCPATH]</pre><pre class="programlisting">svn merge sourceWCPATH1@N sourceWCPATH2@M [WCPATH]</pre><pre class="programlisting">svn merge -r N:M SOURCE[@REV] [WCPATH]</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768334"></a><h2>Description</h2><p>In the first and second forms, the source paths (URLs
            in the first form, working copy paths in the second) are
            specified at revisions <em class="replaceable"><code>N</code></em> and
            <em class="replaceable"><code>M</code></em>.  These are the two sources
            to be compared.  The revisions default to
            <code class="literal">HEAD</code> if omitted.</p><p>In the third form, <em class="replaceable"><code>SOURCE</code></em>
            can be a URL or working copy item, in which case the
            corresponding URL is used.  This URL, at revisions
            <em class="replaceable"><code>N</code></em> and
            <em class="replaceable"><code>M</code></em>, defines the two sources to
            be compared.</p><p><em class="replaceable"><code>WCPATH</code></em> is the working copy
            path that will receive the changes.  If
            <em class="replaceable"><code>WCPATH</code></em> is omitted, a default
            value of «<span class="quote"><code class="filename">.</code></span>» is assumed,
            unless the sources have identical basenames that match a
            file within «<span class="quote"><code class="filename">.</code></span>»: in which
            case, the differences will be applied to that file.</p><p>Unlike <span><strong class="command">svn diff</strong></span>, the merge command
            takes the ancestry of a file into consideration when
            performing a merge operation.  This is very important when
            you're merging changes from one branch into another and
            you've renamed a file on one branch but not the other.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768420"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768431"></a><h2>Changes</h2><p>Working copy</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768441"></a><h2>Accesses Repository</h2><p>Only if working with URLs</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768452"></a><h2>Switches</h2><pre class="screen">
--revision (-r) REV
--non-recursive (-N)
--quiet (-q)
--force
--dry-run
--diff3-cmd CMD
--ignore-ancestry
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768465"></a><h2>Examples</h2><p>Merge a branch back into the trunk (assuming that
            you have a working copy of the trunk, and that the branch
            was created in revision 250):</p><pre class="screen">
$ svn merge -r 250:HEAD http://svn.red-bean.com/repos/branches/my-branch
U  myproj/tiny.txt
U  myproj/thhgttg.txt
U  myproj/win.txt
U  myproj/flo.txt
</pre><p>If you branched at revision 23, and you want to
            merge changes on trunk into your branch, you could do
            this from inside the working copy of your branch:</p><pre class="screen">
$ svn merge -r 23:30 file:///tmp/repos/trunk/vendors
U  myproj/thhgttg.txt
…
</pre><p>To merge changes to a single file:</p><pre class="screen">
$ cd myproj
$ svn merge -r 30:31 thhgttg.txt 
U  thhgttg.txt
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svn.c.mkdir"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn mkdir — Create a new directory under version control.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768520"></a><h2>Synopsis</h2><pre class="programlisting">svn mkdir PATH...</pre><pre class="programlisting">svn mkdir URL...</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768534"></a><h2>Description</h2><p>Create a directory with a name given by the final
            component of the <em class="replaceable"><code>PATH</code></em> or URL.
            A directory specified by a working copy
            <em class="replaceable"><code>PATH</code></em> is scheduled for addition
            in the working copy.  A directory specified by a URL is
            created in the repository via an immediate commit.
            Multiple directory URLs are committed atomically.  In both
            cases all the intermediate directories must already
            exist.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768559"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768569"></a><h2>Changes</h2><p>Working copy, repository if operating on a URL</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768580"></a><h2>Accesses Repository</h2><p>Only if operating on a URL</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768591"></a><h2>Switches</h2><pre class="screen">
--message (-m) TEXT
--file (-F) FILE
--quiet (-q)
--username USER
--password PASS
--no-auth-cache
--non-interactive
--editor-cmd EDITOR
--encoding ENC
--force-log
--config-dir DIR
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768604"></a><h2>Examples</h2><p>Create a directory in your working copy:</p><pre class="screen">
$ svn mkdir newdir
A         newdir
</pre><p>Create one in the repository (instant commit, so a
            log message is required):</p><pre class="screen">
$ svn mkdir -m "Making a new dir." http://svn.red-bean.com/repos/newdir

Committed revision 26.
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svn.c.move"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn move — Move a file or directory.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768644"></a><h2>Synopsis</h2><pre class="programlisting">svn move SRC DST</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768654"></a><h2>Description</h2><p>This command moves a file or directory in your
            working copy or in the repository.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Suggerimento</h3><p>This command is equivalent to an <span><strong class="command">svn
              copy</strong></span> followed by <span><strong class="command">svn
              delete</strong></span>.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Nota</h3><p>Subversion does not support moving between working
              copies and URLs.  In addition, you can only move files
              within a single repository—Subversion does not
              support cross-repository moving.</p></div><div class="variablelist"><dl><dt><span class="term">WC  -&gt; WC</span></dt><dd><p>Move and schedule a file or directory for
                  addition (with history).</p></dd><dt><span class="term">URL -&gt; URL</span></dt><dd><p>Complete server-side rename.</p></dd></dl></div></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768731"></a><h2>Alternate Names</h2><p>mv, rename, ren</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768742"></a><h2>Changes</h2><p>Working copy, repository if operating on a URL</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768753"></a><h2>Accesses Repository</h2><p>Only if operating on a URL</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768763"></a><h2>Switches</h2><pre class="screen">
--message (-m) TEXT
--file (-F) FILE
--revision (-r) REV
--quiet (-q)
--force
--username USER
--password PASS
--no-auth-cache
--non-interactive
--editor-cmd EDITOR
--encoding ENC
--force-log
--config-dir DIR
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768777"></a><h2>Examples</h2><p>Move a file in your working copy:</p><pre class="screen">
$ svn move foo.c bar.c
A         bar.c
D         foo.c
</pre><p>Move a file in the repository (an immediate commit,
            so it requires a commit message):</p><pre class="screen">
$ svn move -m "Move a file" http://svn.red-bean.com/repos/foo.c \
                            http://svn.red-bean.com/repos/bar.c

Committed revision 27.
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svn.c.propdel"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn propdel — Remove a property from an item.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768818"></a><h2>Synopsis</h2><pre class="programlisting">svn propdel PROPNAME [PATH...]</pre><pre class="programlisting">svn propdel PROPNAME --revprop -r REV [URL]</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768833"></a><h2>Description</h2><p>This removes properties from files, directories, or
            revisions.  The first form removes versioned properties
            in your working copy, while the second removes unversioned
            remote properties on a repository revision.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768847"></a><h2>Alternate Names</h2><p>pdel, pd</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768857"></a><h2>Changes</h2><p>Working copy, repository only if operating on a URL</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768868"></a><h2>Accesses Repository</h2><p>Only if operating on a URL</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768879"></a><h2>Switches</h2><pre class="screen">
--quiet (-q)
--recursive (-R)
--revision (-r) REV
--revprop
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768891"></a><h2>Examples</h2><p>Delete a property from a file in your working
            copy</p><pre class="screen">
$ svn propdel svn:mime-type  some-script
property 'svn:mime-type' deleted from 'some-script'.
</pre><p>Delete a revision property:</p><pre class="screen">
$ svn propdel --revprop -r 26 release-date 
property 'release-date' deleted from repository revision '26'
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svn.c.propedit"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn propedit — Edit the property of one or more items under
            version control.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768933"></a><h2>Synopsis</h2><pre class="programlisting">svn propedit PROPNAME PATH...</pre><pre class="programlisting">svn propedit PROPNAME --revprop -r REV [URL]</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768948"></a><h2>Description</h2><p>Edit one or more properties using your favorite
            editor.  The first form edits versioned properties in
            your working copy, while the second edits unversioned
            remote properties on a repository revision.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768962"></a><h2>Alternate Names</h2><p>pedit, pe</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768972"></a><h2>Changes</h2><p>Working copy, repository only if operating on a URL</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768983"></a><h2>Accesses Repository</h2><p>Only if operating on a URL</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4768993"></a><h2>Switches</h2><pre class="screen">
--revision (-r) REV
--revprop
--username USER
--password PASS
--no-auth-cache
--non-interactive
--encoding ENC
--editor-cmd EDITOR
--config-dir DIR
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769006"></a><h2>Examples</h2><p><span><strong class="command">svn propedit</strong></span> makes it easy to
            modify properties that have multiple values:</p><pre class="screen">
$ svn propedit svn:keywords  foo.c 
    &lt;svn will launch your favorite editor here, with a buffer open
    containing the current contents of the svn:keywords property.  You
    can add multiple values to a property easily here by entering one
    value per line.&gt;
Set new value for property 'svn:keywords' on 'foo.c'
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svn.c.propget"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn propget — Print the value of a property.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769052"></a><h2>Synopsis</h2><pre class="programlisting">svn propget PROPNAME [TARGET[@REV]...]</pre><pre class="programlisting">svn propget PROPNAME --revprop -r REV [URL]</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769066"></a><h2>Description</h2><p>Print the value of a property on files,
            directories, or revisions.  The first form prints the
            versioned property of an item or items in your working
            copy, while the second prints unversioned remote
            property on a repository revision.  See <a href="#svn.advanced.props" title="Properties">la sezione chiamata «Properties»</a> for more information on
            properties.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769086"></a><h2>Alternate Names</h2><p>pget, pg</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769097"></a><h2>Changes</h2><p>Working copy, repository only if operating on a URL</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769108"></a><h2>Accesses Repository</h2><p>Only if operating on a URL</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769118"></a><h2>Switches</h2><pre class="screen">
--recursive (-R)
--revision (-r) REV
--revprop
--strict
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769130"></a><h2>Examples</h2><p>Examine a property of a file in your working
            copy:</p><pre class="screen">
$ svn propget svn:keywords foo.c
Author
Date
Rev
</pre><p>The same goes for a revision property:</p><pre class="screen">
$ svn propget svn:log --revprop -r 20 
Began journal.
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svn.c.proplist"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn proplist — List all properties.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769170"></a><h2>Synopsis</h2><pre class="programlisting">svn proplist [TARGET[@REV]...]</pre><pre class="programlisting">svn proplist --revprop -r REV [URL]</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769185"></a><h2>Description</h2><p>List all properties on files, directories, or
            revisions.  The first form lists versioned properties in
            your working copy, while the second lists unversioned remote
            properties on a repository revision.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769199"></a><h2>Alternate Names</h2><p>plist, pl</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769209"></a><h2>Changes</h2><p>Working copy, repository only if operating on a URL</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769220"></a><h2>Accesses Repository</h2><p>Only if operating on a URL</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769230"></a><h2>Switches</h2><pre class="screen">
--verbose (-v)
--recursive (-R)
--revision (-r) REV
--quiet (-q)
--revprop
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769243"></a><h2>Examples</h2><p>You can use proplist to see the properties on an
            item in your working copy:</p><pre class="screen">
$ svn proplist foo.c
Properties on 'foo.c':
  svn:mime-type
  svn:keywords
  owner
</pre><p>But with the <code class="option">--verbose</code> flag, svn
            proplist is extremely handy as it also shows you the
            values for the properties:</p><pre class="screen">
$ svn proplist --verbose foo.c
Properties on 'foo.c':
  svn:mime-type : text/plain
  svn:keywords : Author Date Rev
  owner : sally
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svn.c.propset"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn propset — Set PROPNAME to PROPVAL on files, directories, or revisions.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769291"></a><h2>Synopsis</h2><pre class="programlisting">svn propset PROPNAME [PROPVAL | -F VALFILE] PATH...</pre><pre class="programlisting">svn propset PROPNAME --revprop -r REV [PROPVAL | -F VALFILE] [URL]</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769306"></a><h2>Description</h2><p>Set <em class="replaceable"><code>PROPNAME</code></em> to
            <em class="replaceable"><code>PROPVAL</code></em> on files, directories,
            or revisions.  The first example creates a versioned, local
            property change in the working copy, and the second
            creates an unversioned, remote property change on a
            repository revision.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Suggerimento</h3><p>Subversion has a number of «<span class="quote">special</span>»
              properties that affect its behavior.  See <a href="#svn.advanced.props.special" title="Special Properties">la sezione chiamata «Special Properties»</a> for more on these
              properties.</p></div></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769345"></a><h2>Alternate Names</h2><p>pset, ps</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769355"></a><h2>Changes</h2><p>Working copy, repository only if operating on a URL</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769366"></a><h2>Accesses Repository</h2><p>Only if operating on a URL</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769376"></a><h2>Switches</h2><pre class="screen">
--file (-F) FILE
--quiet (-q)
--revision (-r) REV
--targets FILENAME
--recursive (-R)
--revprop
--username USER
--password PASS
--no-auth-cache
--non-interactive
--encoding ENC
--force
--config-dir DIR
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769390"></a><h2>Examples</h2><p>Set the mimetype on a file:</p><pre class="screen">
$ svn propset svn:mime-type image/jpeg foo.jpg 
property 'svn:mime-type' set on 'foo.jpg'
</pre><p>On a UNIX system, if you want a file to have the
            executable permission set:</p><pre class="screen">
$ svn propset svn:executable ON somescript
property 'svn:executable' set on 'somescript'
</pre><p>Perhaps you have an internal policy to set certain
            properties for the benefit of your coworkers:</p><pre class="screen">
$ svn propset owner sally foo.c
property 'owner' set on 'foo.c'
</pre><p>If you made a mistake in a log message for a
            particular revision and want to change it, use
            <code class="option">--revprop</code> and set <code class="literal">svn:log</code>
            to the new log message:</p><pre class="screen">
$ svn propset --revprop -r 25 svn:log "Journaled about trip to New York."
property 'svn:log' set on repository revision '25'
</pre><p>Or, if you don't have a working copy, you can
            provide a URL.</p><pre class="screen">
$ svn propset --revprop -r 26 svn:log "Document nap." http://svn.red-bean.com/repos
property 'svn:log' set on repository revision '25'
</pre><p>Lastly, you can tell propset to take its input from
            a file.  You could even use this to set the contents of a
            property to something binary:</p><pre class="screen">
$ svn propset owner-pic -F sally.jpg moo.c 
property 'owner-pic' set on 'moo.c'
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Nota</h3><p>By default, you cannot modify revision properties
              in a Subversion repository.  Your repository
              administrator must explicitly enable revision property
              modifications by creating a hook named
              <code class="literal">pre-revprop-change</code>.  See <a href="#svn.reposadmin.create.hooks" title="Hook Scripts">la sezione chiamata «Hook Scripts»</a> for more information on
              hook scripts.</p></div></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svn.c.resolved"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn resolved — Remove «<span class="quote">conflicted</span>» state on
            working copy files or directories.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769509"></a><h2>Synopsis</h2><pre class="programlisting">svn resolved PATH...</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769519"></a><h2>Description</h2><p>Remove «<span class="quote">conflicted</span>» state on working copy
            files or directories.  This routine does not semantically
            resolve conflict markers; it merely removes
            conflict-related artifact files and allows
            <em class="replaceable"><code>PATH</code></em> to be committed again;
            that is, it tells Subversion that the conflicts have been
            «<span class="quote">resolved</span>».  See <a href="#svn.tour.cycle.resolve" title="Resolve Conflicts (Merging Others' Changes)">la sezione chiamata «Resolve Conflicts (Merging Others' Changes)»</a> for an in-depth look at
            resolving conflicts.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769552"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769562"></a><h2>Changes</h2><p>Working copy</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769572"></a><h2>Accesses Repository</h2><p>No</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769582"></a><h2>Switches</h2><pre class="screen">
--targets FILENAME
--recursive (-R)
--quiet (-q)
--config-dir DIR
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769593"></a><h2>Examples</h2><p>If you get a conflict on an update, your working
            copy will sprout three new files:</p><pre class="screen">
$ svn update
C  foo.c
Updated to revision 31.
$ ls
foo.c
foo.c.mine
foo.c.r30
foo.c.r31
</pre><p>Once you've resolved the conflict and
            <code class="filename">foo.c</code> is ready to be committed, run
            <span><strong class="command">svn resolved</strong></span> to let your working copy
            know you've taken care of everything.</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Avvertimento</h3><p>You <span class="emphasis"><em>can</em></span> just remove the
              conflict files and commit, but <span><strong class="command">svn
              resolved</strong></span> fixes up some bookkeeping data
              in the working copy administrative area in addition
              to removing the conflict files, so we recommend that
              you use this command.</p></div></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svn.c.revert"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn revert — Undo all local edits.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769664"></a><h2>Synopsis</h2><pre class="programlisting">svn revert PATH...</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769674"></a><h2>Description</h2><p>Reverts any local changes to a file or directory and
            resolves any conflicted states.  <span><strong class="command">svn
            revert</strong></span> will not only revert the contents of an
            item in your working copy, but also any property
            changes.  Finally, you can use it to undo any scheduling
            operations that you may have done (e.g. files scheduled
            for addition or deletion can be
            «<span class="quote">unscheduled</span>»).</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769700"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769711"></a><h2>Changes</h2><p>Working copy</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769721"></a><h2>Accesses Repository</h2><p>No</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769731"></a><h2>Switches</h2><pre class="screen">
--targets FILENAME
--recursive (-R)
--quiet (-q)
--config-dir DIR
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769742"></a><h2>Examples</h2><p>Discard changes to a file:</p><pre class="screen">
$ svn revert foo.c
Reverted foo.c
</pre><p>If you want to revert a whole directory of files,
            use the <code class="option">--recursive</code> flag:</p><pre class="screen">
$ svn revert --recursive .
Reverted newdir/afile
Reverted foo.c
Reverted bar.txt
</pre><p>Lastly, you can undo any scheduling
            operations:</p><pre class="screen">
$ svn add mistake.txt whoops
A         mistake.txt
A         whoops
A         whoops/oopsie.c

$ svn revert mistake.txt whoops
Reverted mistake.txt
Reverted whoops

$ svn status
?      mistake.txt
?      whoops
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Nota</h3><p>If you provide no targets to <span><strong class="command">svn
              revert</strong></span>, it will do nothing—to protect
              you from accidentally losing changes in your working
              copy, <span><strong class="command">svn revert</strong></span> requires you to
              provide at least one target.</p></div></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svn.c.status"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn status — Print the status of working copy files and directories.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769821"></a><h2>Synopsis</h2><pre class="programlisting">svn status [PATH...]</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4769832"></a><h2>Description</h2><p>Print the status of working copy files and
            directories.  With no arguments, it prints only locally
            modified items (no repository access).  With
            <code class="option">--show-updates</code>, add working revision
            and server out-of-date information.  With
            <code class="option">--verbose</code>, print full revision
            information on every item.</p><p>The first six columns in the output are each one
            character wide, and each column gives you information
            about different aspects of each working copy item.</p><p>The first column indicates that an item
            was added, deleted, or otherwise changed.</p><div class="variablelist"><dl><dt><span class="term">' '</span></dt><dd><p>No modifications.</p></dd><dt><span class="term">'A'</span></dt><dd><p>Item is scheduled for Addition.</p></dd><dt><span class="term">'D'</span></dt><dd><p>Item is scheduled for Deletion.</p></dd><dt><span class="term">'M'</span></dt><dd><p>Item has been modified.</p></dd><dt><span class="term">'R'</span></dt><dd><p>Item has been replaced in your working copy.
                This means the file was scheduled for deletion, and
                then a new file with the same name was scheduled for
                addition in its place.</p></dd><dt><span class="term">'C'</span></dt><dd><p>The contents (as opposed to the properties) of
                  the item conflict with updates received from the
                  repository.</p></dd><dt><span class="term">'X'</span></dt><dd><p>Item is related to an externals definition.</p></dd><dt><span class="term">'I'</span></dt><dd><p>Item is being ignored (e.g. with the 
                  <code class="literal">svn:ignore</code> property).</p></dd><dt><span class="term">'?'</span></dt><dd><p>Item is not under version control.</p></dd><dt><span class="term">'!'</span></dt><dd><p>Item is missing (e.g. you moved or deleted it
                  without using <span><strong class="command">svn</strong></span>).  This also
                  indicates that a directory is incomplete (a checkout
                  or update was interrupted).</p></dd><dt><span class="term">'~'</span></dt><dd><p>Item is versioned as one kind of object (file,
                  directory, link), but has been replaced by different
                  kind of object.</p></dd></dl></div><p>The second column tells the status of a file's or
            directory's properties.</p><div class="variablelist"><dl><dt><span class="term">' '</span></dt><dd><p>No modifications.</p></dd><dt><span class="term">'M'</span></dt><dd><p>Properties for this item have been
                  modified.</p></dd><dt><span class="term">'C'</span></dt><dd><p>Properties for this item are in conflict with
                  property updates received from the
                  repository.</p></dd></dl></div><p>The third column is populated only if the
            working copy directory is locked. (See
            <a href="#svn.tour.other.cleanup" title="svn cleanup">la sezione chiamata «<span><strong class="command">svn cleanup</strong></span>»</a>.)</p><div class="variablelist"><dl><dt><span class="term">' '</span></dt><dd><p>Item is not locked.</p></dd><dt><span class="term">'L'</span></dt><dd><p>Item is locked.</p></dd></dl></div><p>The fourth column is populated only if the item is
            scheduled for addition-with-history.</p><div class="variablelist"><dl><dt><span class="term">' '</span></dt><dd><p>No history scheduled with commit.</p></dd><dt><span class="term">'+'</span></dt><dd><p>History scheduled with commit.</p></dd></dl></div><p>The fifth column is populated only if the item is
            switched relative to its parent (see <a href="#svn.branchmerge.switchwc" title="Switching a Working Copy">la sezione chiamata «Switching a Working Copy»</a>).</p><div class="variablelist"><dl><dt><span class="term">' '</span></dt><dd><p>Item is a child of its parent directory.</p></dd><dt><span class="term">'S'</span></dt><dd><p>Item is switched.</p></dd></dl></div><p>The sixth column is populated with lock information.</p><div class="variablelist"><dl><dt><span class="term">' '</span></dt><dd><p>When <code class="option">--show-updates</code> is used,
                the file is not locked.  If
                <code class="option">--show-updates</code> is
                <span class="emphasis"><em>not</em></span> used, this merely means that
                the file is not locked in this working copy.</p></dd><dt><span class="term">K</span></dt><dd><p>File is locked in this working copy.</p></dd><dt><span class="term">O</span></dt><dd><p>File is locked either by another user or in
                another working copy.  This only appears when
                <code class="option">--show-updates</code> is used.</p></dd><dt><span class="term">T</span></dt><dd><p>File was locked in this working copy, but the
                lock has been «<span class="quote">stolen</span>»and is invalid.
                The file is currently locked in the repository.  This
                only appears when <code class="option">--show-updates</code> is
                used.</p></dd><dt><span class="term">B</span></dt><dd><p>File was locked in this working copy, but the
                lock has been «<span class="quote">broken</span>»and is invalid.
                The file is no longer locked This only appears when
                <code class="option">--show-updates</code> is used.</p></dd></dl></div><p>The out-of-date information appears in the seventh
            column (only if you pass the
            <code class="option">--show-updates</code> switch).</p><div class="variablelist"><dl><dt><span class="term">' '</span></dt><dd><p>The item in your working copy is up-to-date.</p></dd><dt><span class="term">'*'</span></dt><dd><p>A newer revision of the item exists on the
                  server.</p></dd></dl></div><p>The remaining fields are variable width and
            delimited by spaces.  The working revision is the next
            field if the <code class="option">--show-updates</code> or
            <code class="option">--verbose</code> switches are passed.</p><p>If the <code class="option">--verbose</code> switch is passed,
            the last committed revision and last committed author
            are displayed next.</p><p>The working copy path is always the final field, so
            it can include spaces.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4770386"></a><h2>Alternate Names</h2><p>stat, st</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4770396"></a><h2>Changes</h2><p>Nothing</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4770406"></a><h2>Accesses Repository</h2><p>Only if using <code class="option">--show-updates</code></p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4770419"></a><h2>Switches</h2><pre class="screen">
--show-updates (-u)
--verbose (-v)
--non-recursive (-N)
--quiet (-q)
--no-ignore
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir
--ignore-externals
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4770432"></a><h2>Examples</h2><p>This is the easiest way to find out what changes you
            have made to your working copy:</p><pre class="screen">
$ svn status wc
 M     wc/bar.c
A  +   wc/qax.c
</pre><p>If you want to find out what files in your working
            copy are out-of-date, pass the
            <code class="option">--show-updates</code> switch (this will
            <span class="emphasis"><em>not</em></span> make any changes to your
            working copy).  Here you can see that
            <code class="filename">wc/foo.c</code> has changed in the
            repository since we last updated our working
            copy:</p><pre class="screen">
$ svn status --show-updates wc
 M           965    wc/bar.c
       *     965    wc/foo.c
A  +         965    wc/qax.c
Status against revision:    981
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Nota</h3><p><code class="option">--show-updates</code>
              <span class="emphasis"><em>only</em></span> places an asterisk next to
              items that are out of date (that is, items that will be
              updated from the repository if you run <span><strong class="command">svn
              update</strong></span>).  <code class="option">--show-updates</code> does
              <span class="emphasis"><em>not</em></span> cause the status listing to
              reflect the repository's version of the item.</p></div><p>And finally, the most information you can get out of
            the status subcommand:</p><pre class="screen">
$ svn status --show-updates --verbose wc
 M           965       938 sally        wc/bar.c
       *     965       922 harry        wc/foo.c
A  +         965       687 harry        wc/qax.c
             965       687 harry        wc/zig.c
Head revision:   981
</pre><p>For many more examples of <span><strong class="command">svn status</strong></span>,
            see <a href="#svn.tour.cycle.examine.status" title="svn status">la sezione chiamata «<span><strong class="command">svn status</strong></span>»</a>.</p></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svn.c.switch"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn switch — Update working copy to a different URL.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4770549"></a><h2>Synopsis</h2><pre class="programlisting">svn switch URL [PATH]</pre><pre class="programlisting">switch --relocate FROM TO [PATH...]</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4770564"></a><h2>Description</h2><p>This subcommand updates your working copy to mirror
            a new URL—usually a URL which shares a common
            ancestor with your working copy, although not
            necessarily.  This is the Subversion way to move a
            working copy to a new branch.  See <a href="#svn.branchmerge.switchwc" title="Switching a Working Copy">la sezione chiamata «Switching a Working Copy»</a> for an in-depth look at
            switching.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4770588"></a><h2>Alternate Names</h2><p>sw</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4770598"></a><h2>Changes</h2><p>Working copy</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4770609"></a><h2>Accesses Repository</h2><p>Yes</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4770619"></a><h2>Switches</h2><pre class="screen">
--revision (-r) REV
--non-recursive (-N)
--quiet (-q)
--diff3-cmd CMD
--relocate
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4770632"></a><h2>Examples</h2><p>If you're currently inside the directory
            <code class="filename">vendors</code> which was branched to
            <code class="filename">vendors-with-fix</code> and you'd like to
            switch your working copy to that branch:</p><pre class="screen">
$ svn switch http://svn.red-bean.com/repos/branches/vendors-with-fix .
U  myproj/foo.txt
U  myproj/bar.txt
U  myproj/baz.c
U  myproj/qux.c
Updated to revision 31.
</pre><p>And to switch back, just provide the URL to the
            location in the repository from which you originally
            checked out your working copy:</p><pre class="screen">
$ svn switch http://svn.red-bean.com/repos/trunk/vendors .
U  myproj/foo.txt
U  myproj/bar.txt
U  myproj/baz.c
U  myproj/qux.c
Updated to revision 31.
</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Suggerimento</h3><p>You can just switch part of your working copy to a
              branch if you don't want to switch your entire working
              copy.</p></div><p>Sometimes an administrator might change the
            «<span class="quote">base location</span>» of your repository—in
            other words, the contents of the repository doesn't
            change, but the main URL used to reach the root of the
            repository does.  For example, the hostname may change,
            the URL scheme, or any part of the URL which leads to the
            repository itself.  Rather than checkout a new working
            copy, you can have the <span><strong class="command">svn switch</strong></span>
            command «<span class="quote">rewrite</span>» the beginnings of all the
            URLs in your working copy.  Use the
            <code class="option">--relocate</code> option to do the substitution.
            No file contents are changed, nor is the repository
            contacted.  It's similar to running a Perl script over
            your working copy <code class="filename">.svn/</code> directories
            which runs <span><strong class="command">s/OldRoot/NewRoot/</strong></span>.</p><pre class="screen">
$ svn checkout file:///tmp/repos test
A  test/a
A  test/b
…

$ mv repos newlocation
$ cd test/

$ svn update
svn: Unable to open an ra_local session to URL
svn: Unable to open repository 'file:///tmp/repos'

$ svn switch --relocate file:///tmp/repos file:///tmp/newlocation .
$ svn update
At revision 3.
</pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Avvertimento</h3><p>Be careful when using the
            <code class="option">--relocate</code> option.  If you mistype the
            argument, you might end up creating nonsensical URLs
            within your working copy that render the whole workspace
            unusable and tricky to fix.  It's also important to
            understand exactly when one should or shouldn't use
            <code class="option">--relocate</code>.  Here's the rule of
            thumb:</p><div class="itemizedlist"><ul type="disc"><li><p>If the working copy needs to reflect a
                  new directory <span class="emphasis"><em>within</em></span> the
                  repository, then use just <span><strong class="command">svn
                  switch</strong></span>.</p></li><li><p>If the working copy still reflects the
                  same repository directory, but the location of the
                  repository itself has changed, then use <span><strong class="command">svn
                  switch --relocate</strong></span>.</p></li></ul></div></div></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svn.c.unlock"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn unlock — Unlock working copy paths or URLs.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4770815"></a><h2>Synopsis</h2><pre class="programlisting">svn unlock TARGET...</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4770825"></a><h2>Description</h2><p>Unlock each <em class="replaceable"><code>TARGET</code></em>.  If any
            <em class="replaceable"><code>TARGET</code></em> is either locked by
            another user or no valid lock token exists in the working
            copy, print a warning and continue unlocking the rest of
            the <em class="replaceable"><code>TARGET</code></em>s.  Use
            <code class="option">--force</code> to break a lock belonging to
            another user or working copy.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4770855"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4770865"></a><h2>Changes</h2><p>Working Copy, Repository</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4770875"></a><h2>Accesses Repository</h2><p>Yes</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4770885"></a><h2>Switches</h2><pre class="screen">
--targets ARG
--username ARG
--password ARG
--no-auth-cache
--non-interactive
--config-dir ARG
--force
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4770897"></a><h2>Examples</h2><p>Unlock two files in your working copy:</p><pre class="screen">

$ svn unlock tree.jpg house.jpg
'tree.jpg' unlocked.
'house.jpg' unlocked.
</pre><p>Unlock a file in your working copy that is currently
            locked by another user:</p><pre class="screen">
$ svn unlock tree.jpg
svn: 'tree.jpg' is not locked in this working copy
$ svn unlock --force tree.jpg
'tree.jpg' unlocked.
</pre><p>Unlock a file without a working copy:</p><pre class="screen">
$ svn unlock http://svn.red-bean.com/repos/test/tree.jpg
'tree.jpg unlocked.
</pre><p>For further details, see <a href="#svn.advanced.locking" title="Locking">la sezione chiamata «Locking»</a>.</p></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svn.c.update"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svn update — Update your working copy.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4770956"></a><h2>Synopsis</h2><pre class="programlisting">svn update [PATH...]</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4770966"></a><h2>Description</h2><p><span><strong class="command">svn update</strong></span> brings changes from the
            repository into your working copy.  If no revision given,
            it brings your working copy up-to-date with the
            <code class="literal">HEAD</code> revision.  Otherwise, it
            synchronizes the working copy to the revision given by the
            <code class="option">--revision</code> switch.  As part of the
            synchronization, <span><strong class="command">svn update</strong></span> also
            removes any stale locks (see <a href="#svn.tour.other.cleanup" title="svn cleanup">la sezione chiamata «<span><strong class="command">svn cleanup</strong></span>»</a>) found in the
            working copy.</p><p>For each updated item a line will start with a
            character reporting the action taken.  These characters
            have the following meaning:</p><div class="variablelist"><dl><dt><span class="term">A</span></dt><dd><p>Added</p></dd><dt><span class="term">D</span></dt><dd><p>Deleted</p></dd><dt><span class="term">U</span></dt><dd><p>Updated</p></dd><dt><span class="term">C</span></dt><dd><p>Conflict</p></dd><dt><span class="term">G</span></dt><dd><p>Merged</p></dd></dl></div><p>A character in the first column signifies an update
            to the actual file, while updates to the file's
            properties are shown in the second column.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4771089"></a><h2>Alternate Names</h2><p>up</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4771099"></a><h2>Changes</h2><p>Working copy</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4771109"></a><h2>Accesses Repository</h2><p>Yes</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4771119"></a><h2>Switches</h2><pre class="screen">
--revision (-r) REV
--non-recursive (-N)
--quiet (-q)
--diff3-cmd CMD
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
--ignore-externals
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4771132"></a><h2>Examples</h2><p>Pick up repository changes that have happened since
            your last update:</p><pre class="screen">
$ svn update
A  newdir/toggle.c
A  newdir/disclose.c
A  newdir/launch.c
D  newdir/README
Updated to revision 32.
</pre><p>You can also update your working copy to an older
            revision (Subversion doesn't have the concept of
            «<span class="quote">sticky</span>» files like CVS does; see <a href="#svn.forcvs" title="Appendice&#xA0;A.&#xA0;Subversion for CVS Users">Appendice A, <i>Subversion for CVS Users</i></a>):</p><pre class="screen">
$ svn update -r30
A  newdir/README
D  newdir/toggle.c
D  newdir/disclose.c
D  newdir/launch.c
U  foo.c
Updated to revision 30.
</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Suggerimento</h3><p>If you want to examine an older revision of a
              single file, you may want to use <span><strong class="command">svn
              cat</strong></span>.</p></div></div></div></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.ref.svnadmin"></a><span><strong class="command">svnadmin</strong></span></h2></div></div></div><p><span><strong class="command">svnadmin</strong></span> is the administrative tool for
      monitoring and repairing your Subversion repository.  For
      detailed information, see <a href="#svn.reposadmin.maint.tk.svnadmin" title="svnadmin">la sezione chiamata «svnadmin»</a>.</p><p>Since <span><strong class="command">svnadmin</strong></span> works via direct repository access
      (and thus can only be used on the machine that holds the
      repository), it refers to the repository with a path, not a URL.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.ref.svnadmin.sw"></a><span><strong class="command">svnadmin</strong></span> Switches</h3></div></div></div><div class="variablelist"><dl><dt><span class="term"><code class="option">--bdb-log-keep</code></span></dt><dd><p>(Berkeley DB specific) Disable automatic log removal
              of database log files.</p></dd><dt><span class="term"><code class="option">--bdb-txn-nosync</code></span></dt><dd><p>(Berkeley DB specific) Disables fsync when
              committing database transactions.</p></dd><dt><span class="term"><code class="option">--bypass-hooks</code></span></dt><dd><p>Bypass the repository hook system.</p></dd><dt><span class="term"><code class="option">--clean-logs</code></span></dt><dd><p>Removes unused Berkeley DB logs.</p></dd><dt><span class="term"><code class="option">--force-uuid</code></span></dt><dd><p>By default, when loading data into repository that
              already contains revisions, <span><strong class="command">svnadmin</strong></span>
              will ignore the <code class="literal">UUID</code> from the dump
              stream.  This switch will cause the repository's
              <code class="literal">UUID</code> to be set to the
              <code class="literal">UUID</code> from the stream.</p></dd><dt><span class="term"><code class="option">--ignore-uuid</code></span></dt><dd><p>By default, when loading an empty repository,
              <span><strong class="command">svnadmin</strong></span> will use the
              <code class="literal">UUID</code> from the dump stream.  This
              switch will cause that UUID to be ignored.</p></dd><dt><span class="term"><code class="option">--incremental</code></span></dt><dd><p>Dump a revision only as a diff against the
              previous revision, instead of the usual
              fulltext.</p></dd><dt><span class="term"><code class="option">--parent-dir
          <em class="replaceable"><code>DIR</code></em></code></span></dt><dd><p>When loading a dump file, root paths at
              <em class="replaceable"><code>DIR</code></em> instead of
              <code class="filename">/</code>.</p></dd><dt><span class="term"><code class="option">--revision</code> (<code class="option">-r</code>)
          <em class="replaceable"><code>ARG</code></em></span></dt><dd><p>Specify a particular revision to operate
              on.</p></dd><dt><span class="term"><code class="option">--quiet</code></span></dt><dd><p>Do not show normal progress—show only
              errors.</p></dd><dt><span class="term"><code class="option">--use-post-commit-hook</code></span></dt><dd><p>When loading a dump file, run the repository's
              post-commit hook after finalizing each newly loaded
              revision.</p></dd><dt><span class="term"><code class="option">--use-pre-commit-hook</code></span></dt><dd><p>When loading a dump file, run the repository's
              pre-commit hook before finalizing each newly loaded
              revision.  If the hook fails, abort the commit and
              terminate the load process.</p></dd></dl></div></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.ref.svnadmin.c"></a><span><strong class="command">svnadmin</strong></span> Subcommands</h3></div></div></div><div class="refentry" lang="it" xml:lang="it"><a id="svn.ref.svnadmin.c.create"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnadmin create — Create a new, empty repository.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4771540"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin create REPOS_PATH</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4771550"></a><h2>Description</h2><p>Create a new, empty repository at the path provided.
              If the provided directory does not exist, it will be
              created for you.<sup>[<a id="id4771561" href="#ftn.id4771561">50</a>]</sup> As of
              Subversion 1.2, <span><strong class="command">svnadmin</strong></span> creates new
              repositories with the <code class="literal">fsfs</code> filesystem
              backend by default.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4771596"></a><h2>Switches</h2><pre class="screen">
--bdb-txn-nosync
--bdb-log-keep
--config-dir DIR
--fs-type TYPE
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4771607"></a><h2>Examples</h2><p>Creating a new repository is just this easy:</p><pre class="screen">
$ svnadmin create /usr/local/svn/repos
</pre><p>In Subversion 1.0, a Berkeley DB repository is always
            created.  In Subversion 1.1, a Berkeley DB repository is
            the default repository type, but an FSFS repository can be
            created using the <code class="option">--fs-type</code>
            option:</p><pre class="screen">
$ svnadmin create /usr/local/svn/repos --fs-type fsfs
</pre></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.id4771561" href="#id4771561">50</a>] </sup>Remember,
              <span><strong class="command">svnadmin</strong></span> works only with local
              <span class="emphasis"><em>paths</em></span>, not
              <span class="emphasis"><em>URLs</em></span>.</p></div></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svnadmin.c.deltify"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnadmin deltify — Deltify changed paths in a revision range.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4771654"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin deltify [-r LOWER[:UPPER]] REPOS_PATH</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4771664"></a><h2>Description</h2><p><span><strong class="command">svnadmin deltify</strong></span> only exists in
            1.0.x due to historical reasons.  This command is
            deprecated and no longer needed.</p><p>It dates from a time when Subversion offered
            administrators greater control over compression strategies
            in the repository.  This turned out to be a lot of
            complexity for <span class="emphasis"><em>very</em></span> little gain, and
            this «<span class="quote">feature</span>» was deprecated.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4771696"></a><h2>Switches</h2><pre class="screen">
--revision (-r)
--quiet
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svnadmin.c.dump"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnadmin dump — Dump the contents of filesystem to stdout.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4771723"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin dump REPOS_PATH [-r LOWER[:UPPER]] [--incremental]</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4771734"></a><h2>Description</h2><p>Dump the contents of filesystem to stdout in a
            «<span class="quote">dumpfile</span>» portable format, sending feedback
            to stderr.  Dump revisions
            <em class="replaceable"><code>LOWER</code></em> rev through
            <em class="replaceable"><code>UPPER</code></em> rev.  If no revisions are
            given, dump all revision trees.  If only
            <em class="replaceable"><code>LOWER</code></em> is given, dump that one
            revision tree.  See <a href="#svn.reposadmin.maint.migrate" title="Migrating a Repository">la sezione chiamata «Migrating a Repository»</a>
            for a practical use.</p><p>By default, the Subversion dumpfile stream contains a
            single revision (the first revision in the requested
            revision range) in which every file and directory in the
            repository in that revision is presented as if that whole
            tree was added at once, followed by other revisions (the
            remainder of the revisions in the requested range) which
            contain only the files and directories which were modified
            in those revisions.  For a modified file, the complete
            fulltext representation of its contents, as well as all of
            its properties, are presented in the dumpfile; for a
            directory, all of its properties are presented.</p><p>There are a pair of useful options which modify the
            dumpfile generator's behavior.  The first is the
            <code class="option">--incremental</code> option, which simply causes
            that first revision in the dumpfile stream to contain only
            the files and directories modified in that revision,
            instead of being presented as the addition of a new tree,
            and in exactly the same way that every other revision in
            the dumpfile is presented.  This is useful for generating
            a dumpfile that is to be loaded into another repository
            which already has the files and directories that exist in
            the original repository.</p><p>The second useful option is <code class="option">--deltas</code>.
            This switch causes <span><strong class="command">svnadmin dump</strong></span> to,
            instead of emitting fulltext representations of file
            contents and property lists, emit only deltas of those
            items against their previous versions.  This reduces (in
            some cases, drastically) the size of the dumpfile that
            <span><strong class="command">svnadmin dump</strong></span> creates.  There are, however,
            disadvantages to using this option—deltified
            dumpfiles are more CPU intensive to create, cannot be
            operated on by <span><strong class="command">svndumpfilter</strong></span>, and tend
            not to compress as well as their non-deltified counterparts
            when using third-party tools like <span><strong class="command">gzip</strong></span>
            and <span><strong class="command">bzip2</strong></span>.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4771854"></a><h2>Switches</h2><pre class="screen">
--revision (-r)
--incremental
--quiet
--deltas
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4771865"></a><h2>Examples</h2><p>Dump your whole repository:</p><pre class="screen">
$ svnadmin dump /usr/local/svn/repos
SVN-fs-dump-format-version: 1
Revision-number: 0
* Dumped revision 0.
Prop-content-length: 56
Content-length: 56
…
</pre><p>Incrementally dump a single transaction from your
            repository:</p><pre class="screen">
$ svnadmin dump /usr/local/svn/repos -r 21 --incremental 
* Dumped revision 21.
SVN-fs-dump-format-version: 1
Revision-number: 21
Prop-content-length: 101
Content-length: 101
…
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svnadmin.c.help"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnadmin help</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4771910"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin help [SUBCOMMAND...]</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4771921"></a><h2>Description</h2><p>This subcommand is useful when you're trapped on a
            desert island with neither a net connection nor a copy of
            this book.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4771933"></a><h2>Alternate Names</h2><p>?, h</p></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svnadmin.c.hotcopy"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnadmin hotcopy — Make a hot copy of a repository.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4771960"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin hotcopy REPOS_PATH NEW_REPOS_PATH</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4771970"></a><h2>Description</h2><p>This subcommand makes a full «<span class="quote">hot</span>» backup
            of your repository, including all hooks, configuration
            files, and, of course, database files.  If you pass the
            <code class="option">--clean-logs</code> switch,
            <span><strong class="command">svnadmin</strong></span> will perform a hotcopy of your
            repository, and then remove unused Berkeley DB logs from
            the original repository.  You can run this command at any
            time and make a safe copy of the repository, regardless of
            whether other processes are using the repository.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772002"></a><h2>Switches</h2><pre class="screen">
--clean-logs
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svnadmin.c.list-dblogs"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnadmin list-dblogs — Ask
          Berkeley DB which log files exist for a given Subversion
          repository (applies only to repositories using the
          <code class="literal">bdb</code> backend).</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772036"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin list-dblogs REPOS_PATH</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772047"></a><h2>Description</h2><p>Berkeley DB creates logs of all changes to the
            repository, which allow it to recover in the face of
            catastrophe.  Unless you enable
            <code class="literal">DB_LOG_AUTOREMOVE</code>, the log files
            accumulate, although most are no longer used and can be
            deleted to reclaim disk space.  See <a href="#svn.reposadmin.maint.diskspace" title="Managing Disk Space">la sezione chiamata «Managing Disk Space»</a> for more
            information.</p></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svnadmin.c.list-unused-dblogs"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnadmin list-unused-dblogs — Ask Berkeley DB which log files can be safely
          deleted (applies only to repositories using the
          <code class="literal">bdb</code> backend).</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772097"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin list-unused-dblogs REPOS_PATH</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772108"></a><h2>Description</h2><p>Berkeley DB creates logs of all changes to the
            repository, which allow it to recover in the face of
            catastrophe.  Unless you enable
            <code class="literal">DB_LOG_AUTOREMOVE</code>, the log files
            accumulate, although most are no longer used and can be
            deleted to reclaim disk space.  See <a href="#svn.reposadmin.maint.diskspace" title="Managing Disk Space">la sezione chiamata «Managing Disk Space»</a> for more
            information.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772134"></a><h2>Examples</h2><p>Remove all unused log files from a repository:</p><pre class="screen">
$ svnadmin list-unused-dblogs /path/to/repos
/path/to/repos/log.0000000031
/path/to/repos/log.0000000032
/path/to/repos/log.0000000033

$ svnadmin list-unused-dblogs /path/to/repos | xargs rm
## disk space reclaimed!
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svnadmin.c.load"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnadmin load — Read a
            «<span class="quote">dumpfile</span>»-formatted stream from
            stdin.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772173"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin load REPOS_PATH</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772183"></a><h2>Description</h2><p>Read a «<span class="quote">dumpfile</span>»-formatted stream from
            stdin, committing new revisions into the repository's
            filesystem.  Send progress feedback to stdout.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772199"></a><h2>Switches</h2><pre class="screen">
--quiet (-q)
--ignore-uuid
--force-uuid
--use-pre-commit-hook
--use-post-commit-hook
--parent-dir
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772211"></a><h2>Example</h2><p>This shows the beginning of loading a repository from
            a backup file (made, of course, with <span><strong class="command">svnadmin
            dump</strong></span>):</p><pre class="screen">
$ svnadmin load /usr/local/svn/restored &lt; repos-backup
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : test ... done.
     * adding path : test/a ... done.
…
</pre><p>Or if you want to load into a subdirectory:</p><pre class="screen">
$ svnadmin load --parent-dir new/subdir/for/project /usr/local/svn/restored &lt; repos-backup
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : test ... done.
     * adding path : test/a ... done.
…
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svnadmin.c.lslocks"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnadmin lslocks — Print descriptions of all locks.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772272"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin lslocks REPOS_PATH</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772282"></a><h2>Description</h2><p>Print descriptions of all locks in a repository.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772293"></a><h2>Switches</h2><p>None</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772303"></a><h2>Example</h2><p>This lists the one locked file in the repository at
            <code class="filename">/svn/repos</code></p><pre class="screen">
$ svnadmin lslocks /svn/repos
Path: /tree.jpg
UUID Token: opaquelocktoken:ab00ddf0-6afb-0310-9cd0-dda813329753
Owner: harry
Created: 2005-07-08 17:27:36 -0500 (Fri, 08 Jul 2005)
Expires: 
Comment (1 line):
Rework the uppermost branches on the bald cypress in the foreground.
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svnadmin.c.lstxns"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnadmin lstxns — Print the names of all uncommitted transactions.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772344"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin lstxns REPOS_PATH</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772354"></a><h2>Description</h2><p>Print the names of all uncommitted transactions.  See
            <a href="#svn.reposadmin.maint.cleanup" title="Repository Cleanup">la sezione chiamata «Repository Cleanup»</a> for information on how
            uncommitted transactions are created and what you should
            do with them.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772372"></a><h2>Examples</h2><p>List all outstanding transactions in a
            repository.</p><pre class="screen">
$ svnadmin lstxns /usr/local/svn/repos/ 
1w
1x
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svnadmin.c.recover"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnadmin recover — Bring a repository database back into a
          consistent state (applies only to repositories using the
          <code class="literal">bdb</code> backend).  In addition, if
          <code class="filename">repos/conf/passwd</code> does not exist, it
          will create a default password file .</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772418"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin recover REPOS_PATH</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772429"></a><h2>Description</h2><p>Run this command if you get an error indicating that
            your repository needs to be recovered.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772440"></a><h2>Switches</h2><pre class="screen">
--wait
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772451"></a><h2>Examples</h2><p>Recover a hung repository:</p><pre class="screen">
$ svnadmin recover /usr/local/svn/repos/ 
Repository lock acquired.
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 34.
</pre><p>Recovering the database requires an exclusive lock on
            the repository. (This is a «<span class="quote">database lock</span>»;
            see <a href="#svn.advanced.locking.meanings" title="Three meanings of &#xAB;lock&#xBB;">Three meanings of «<span class="quote">lock</span>»</a>.)
            If another process is accessing the repository,
            then <span><strong class="command">svnadmin recover</strong></span> will error:</p><pre class="screen">
$ svnadmin recover /usr/local/svn/repos
svn: Failed to get exclusive repository access; perhaps another process
such as httpd, svnserve or svn has it open?

$
</pre><p>The <code class="option">--wait</code> option, however, will
            cause <span><strong class="command">svnadmin recover</strong></span> to wait
            indefinitely for other processes to disconnect:</p><pre class="screen">
$ svnadmin recover /usr/local/svn/repos --wait
Waiting on repository lock; perhaps another process has it open?

### time goes by...

Repository lock acquired.
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 34.
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svnadmin.c.rmlocks"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnadmin rmlocks — Unconditionally remove one or more locks from a
          repository.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772535"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin rmlocks REPOS_PATH LOCKED_PATH...</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772546"></a><h2>Description</h2><p>Remove lock from each <em class="replaceable"><code>LOCKED_PATH</code></em>.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772559"></a><h2>Switches</h2><p>None</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772570"></a><h2>Example</h2><p>This deletes the locks on
            <code class="filename">tree.jpg</code> and
            <code class="filename">house.jpg</code> in the repository at
            <code class="filename">/svn/repos</code></p><pre class="screen">
$ svnadmin rmlocks /svn/repos tree.jpg house.jpg
Removed lock on '/tree.jpg.
Removed lock on '/house.jpg.
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svnadmin.c.rmtxns"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnadmin rmtxns — Delete transactions from a repository.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772619"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin rmtxns REPOS_PATH TXN_NAME...</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772630"></a><h2>Description</h2><p>Delete outstanding transactions from a repository.
            This is covered in detail in <a href="#svn.reposadmin.maint.cleanup" title="Repository Cleanup">la sezione chiamata «Repository Cleanup»</a>.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772646"></a><h2>Switches</h2><pre class="screen">
--quiet (-q)
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772656"></a><h2>Examples</h2><p>Remove named transactions:</p><pre class="screen">
$ svnadmin rmtxns /usr/local/svn/repos/ 1w 1x
</pre><p>Fortunately, the output of <span><strong class="command">lstxns</strong></span>
            works great as the input for <span><strong class="command">rmtxns</strong></span>:</p><pre class="screen">
$ svnadmin rmtxns /usr/local/svn/repos/  `svnadmin lstxns /usr/local/svn/repos/`
</pre><p>Which will remove all uncommitted transactions from
            your repository.</p></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svnadmin.c.setlog"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnadmin setlog — Set the log-message on a revision.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772713"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin setlog REPOS_PATH -r REVISION FILE</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772723"></a><h2>Description</h2><p>Set the log-message on revision REVISION to the
            contents of FILE.</p><p>This is similar to using <span><strong class="command">svn propset
            --revprop</strong></span> to set the <code class="literal">svn:log</code> property
            on a revision, except that you can also use the option
            <code class="option">--bypass-hooks</code> to avoid running any pre- or
            post-commit hooks, which is useful if the modification of
            revision properties has not been enabled in the pre-revprop-change
            hook.</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Avvertimento</h3><p>Revision properties are not under version control,
              so this command will permanently overwrite the previous
              log message.</p></div></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772768"></a><h2>Switches</h2><pre class="screen">
--revision (-r) ARG
--bypass-hooks
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772779"></a><h2>Examples</h2><p>Set the log message for revision 19 to the contents of
            the file <code class="filename">msg</code>:</p><pre class="screen">
$ svnadmin setlog /usr/local/svn/repos/ -r 19 msg
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svnadmin.c.verify"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnadmin verify — Verify the data stored in the repository.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772816"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin verify REPOS_PATH</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772827"></a><h2>Description</h2><p>Run this command if you wish to verify the integrity
            of your repository.  This basically iterates through all
            revisions in the repository by internally dumping all
            revisions and discarding the output.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4772841"></a><h2>Examples</h2><p>Verify a hung repository:</p><pre class="screen">
$ svnadmin verify /usr/local/svn/repos/ 
* Verified revision 1729.
</pre></div></div></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.ref.svnlook"></a><span><strong class="command">svnlook</strong></span></h2></div></div></div><p><span><strong class="command">svnlook</strong></span> is a command-line utility for
      examining different aspects of a Subversion repository.  It
      does not make any changes to the repository—it's just
      used for «<span class="quote">peeking</span>».
      <span><strong class="command">svnlook</strong></span> is typically used by the
      repository hooks, but a repository administrator might find it
      useful for diagnostic purposes.</p><p>Since <span><strong class="command">svnlook</strong></span> works via direct repository access
      (and thus can only be used on the machine that holds the
      repository), it refers to the repository with a path, not a URL.</p><p>If no revision or transaction is specified,
      <span><strong class="command">svnlook</strong></span> defaults to the youngest (most
      recent) revision of the repository.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.ref.svnlook.sw"></a><span><strong class="command">svnlook</strong></span> Switches</h3></div></div></div><p>Switches in <span><strong class="command">svnlook</strong></span> are global, just
        like in <span><strong class="command">svn</strong></span> and
        <span><strong class="command">svnadmin</strong></span>; however, most switches only
        apply to one subcommand since the functionality of
        <span><strong class="command">svnlook</strong></span> is (intentionally) limited in
        scope.</p><div class="variablelist"><dl><dt><span class="term"><code class="option">--no-diff-deleted</code></span></dt><dd><p>Prevents <span><strong class="command">svnlook</strong></span> from printing
              differences for deleted files.  The default behavior
              when a file is deleted in a transaction/revision is
              to print the same differences that you would see if
              you had left the file but removed all the content.</p></dd><dt><span class="term"><code class="option">--revision</code>
            (<code class="option">-r</code>)</span></dt><dd><p>Specify a particular revision number that you wish
              to examine.</p></dd><dt><span class="term"><code class="option">--revprop</code></span></dt><dd><p>Operates on a revision property instead of a
              Subversion property specific to a file or directory.
              This switch requires that you also pass a revision
              with the <code class="option">--revision</code>
              (<code class="option">-r</code>) switch.  See <a href="#svn.reposadmin.basics.revprops" title="Unversioned Properties">la sezione chiamata «Unversioned Properties»</a> for more details on
              unversioned properties.</p></dd><dt><span class="term"><code class="option">--transaction</code>
            (<code class="option">-t</code>)</span></dt><dd><p>Specify a particular transaction ID that you wish to
              examine.</p></dd><dt><span class="term"><code class="option">--show-ids</code></span></dt><dd><p>Show the filesystem node revision IDs for each path in the filesystem
              tree.</p></dd></dl></div></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.ref.svnlook.c"></a><span><strong class="command">svnlook</strong></span></h3></div></div></div><div class="refentry" lang="it" xml:lang="it"><a id="svn.ref.svnlook.c.author"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnlook author — Print the author.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773124"></a><h2>Synopsis</h2><pre class="programlisting">svnlook author REPOS_PATH</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773134"></a><h2>Description</h2><p>Print the author of a revision or transaction in
            the repository.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773145"></a><h2>Switches</h2><pre class="screen">
--revision (-r)
--transaction (-t)
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773156"></a><h2>Examples</h2><p><span><strong class="command">svnlook author</strong></span> is handy, but not
          very exciting:</p><pre class="screen">
$ svnlook author -r 40 /usr/local/svn/repos 
sally
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svnlook.c.cat"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnlook cat — Print the contents of a file.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773192"></a><h2>Synopsis</h2><pre class="programlisting">svnlook cat REPOS_PATH PATH_IN_REPOS</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773203"></a><h2>Description</h2><p>Print the contents of a file.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773214"></a><h2>Switches</h2><pre class="screen">
--revision (-r)
--transaction (-t)
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773224"></a><h2>Examples</h2><p>This shows the contents of a file in transaction
            <code class="literal">ax8</code>, located at 
            <code class="filename">/trunk/README</code>:</p><pre class="screen">
$ svnlook cat -t ax8 /usr/local/svn/repos /trunk/README

               Subversion, a version control system.
               =====================================

$LastChangedDate: 2003-07-17 10:45:25 -0500 (Thu, 17 Jul 2003) $

Contents:

     I. A FEW POINTERS
    II. DOCUMENTATION
   III. PARTICIPATING IN THE SUBVERSION COMMUNITY
…
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svnlook.c.changed"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnlook changed — Print the paths that were changed.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773279"></a><h2>Synopsis</h2><pre class="programlisting">svnlook changed REPOS_PATH</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773289"></a><h2>Description</h2><p>Print the paths that were changed in a particular
            revision or transaction, as well as «<span class="quote">svn
            update-style</span>» status letters in the first two
            columns:</p><div class="variablelist"><dl><dt><span class="term">'<code class="literal">A </code>'</span></dt><dd><p>Item added to repository.</p></dd><dt><span class="term">'<code class="literal">D </code>'</span></dt><dd><p>Item deleted from repository.</p></dd><dt><span class="term">'<code class="literal">U </code>'</span></dt><dd><p>File contents changed.</p></dd><dt><span class="term">'<code class="literal">_U</code>'</span></dt><dd><p>Properties of item changed.</p></dd><dt><span class="term">'<code class="literal">UU</code>'</span></dt><dd><p>File contents and properties changed.</p></dd></dl></div><p>Files and directories can be distinguished, as directory
            paths are displayed with a trailing '<code class="literal">/</code>'
            character.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773415"></a><h2>Switches</h2><pre class="screen">
--revision (-r)
--transaction (-t)
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773425"></a><h2>Examples</h2><p>This shows a list of all the changed files in
            revision 39 of a test repository:</p><pre class="screen">
$ svnlook changed -r 39 /usr/local/svn/repos
A   trunk/vendors/deli/
A   trunk/vendors/deli/chips.txt
A   trunk/vendors/deli/sandwich.txt
A   trunk/vendors/deli/pickle.txt
U   trunk/vendors/baker/bagel.txt
_U  trunk/vendors/baker/croissant.txt
UU  trunk/vendors/baker/pretzel.txt
D   trunk/vendors/baker/baguette.txt
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svnlook.c.date"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnlook date — Print the datestamp.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773462"></a><h2>Synopsis</h2><pre class="programlisting">svnlook date REPOS_PATH</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773472"></a><h2>Description</h2><p>Print the datestamp of a revision or transaction in
            a repository.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773483"></a><h2>Switches</h2><pre class="screen">
--revision (-r)
--transaction (-t)
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773494"></a><h2>Examples</h2><p>This shows the date of revision 40 of a test
            repository:</p><pre class="screen">            
$ svnlook date -r 40 /tmp/repos/
2003-02-22 17:44:49 -0600 (Sat, 22 Feb 2003)
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svnlook.c.diff"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnlook diff — Print differences of changed files and properties.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773527"></a><h2>Synopsis</h2><pre class="programlisting">svnlook diff REPOS_PATH</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773537"></a><h2>Description</h2><p>Print GNU-style differences of changed files and
            properties in a repository.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773549"></a><h2>Switches</h2><pre class="screen">
--revision (-r)
--transaction (-t)
--no-diff-added
--no-diff-deleted
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773560"></a><h2>Examples</h2><p>This shows a newly added (empty) file, a deleted
            file, and a copied file:</p><pre class="screen">
$ svnlook diff -r 40 /usr/local/svn/repos/
Copied: egg.txt (from rev 39, trunk/vendors/deli/pickle.txt)

Added: trunk/vendors/deli/soda.txt
==============================================================================

Modified: trunk/vendors/deli/sandwich.txt
==============================================================================
--- trunk/vendors/deli/sandwich.txt	(original)
+++ trunk/vendors/deli/sandwich.txt	2003-02-22 17:45:04.000000000 -0600
@@ -0,0 +1 @@
+Don't forget the mayo!

Modified: trunk/vendors/deli/logo.jpg
==============================================================================
(Binary files differ)

Deleted: trunk/vendors/deli/chips.txt
==============================================================================

Deleted: trunk/vendors/deli/pickle.txt
==============================================================================
</pre><p>If a file has a non-textual
            <code class="literal">svn:mime-type</code> property, then the
            differences are not explicitly shown.</p></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svnlook.c.dirs-changed"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnlook dirs-changed — Print the directories that were themselves changed.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773617"></a><h2>Synopsis</h2><pre class="programlisting">svnlook dirs-changed REPOS_PATH</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773628"></a><h2>Description</h2><p>Print the directories that were themselves changed
            (property edits) or whose file children were
            changed.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773640"></a><h2>Switches</h2><pre class="screen">
--revision (-r)
--transaction (-t)
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773651"></a><h2>Examples</h2><p>This shows the directories that changed in
            revision 40 in our sample repository:</p><pre class="screen">
$ svnlook dirs-changed -r 40 /usr/local/svn/repos
trunk/vendors/deli/
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svnlook.c.help"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnlook help</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773679"></a><h2>Synopsis</h2><pre class="programlisting">Also svnlook -h and svnlook -?.</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773690"></a><h2>Description</h2><p>Displays the help message for svnlook.  This
            command, like its brother <span><strong class="command">svn help</strong></span>, is
            also your friend, even though you never call it anymore
            and forgot to invite it to your last party.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773709"></a><h2>Alternate Names</h2><p>?, h</p></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svnlook.c.history"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnlook history — Print information about the history of a path in
            the repository (or the root directory if no path is
            supplied).</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773738"></a><h2>Synopsis</h2><pre class="programlisting">svnlook history REPOS_PATH [PATH_IN_REPOS]</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773748"></a><h2>Description</h2><p>Print information about the history of a path in
            the repository (or the root directory if no path is
            supplied).</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773761"></a><h2>Switches</h2><pre class="screen">
--revision (-r)
--show-ids
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773771"></a><h2>Examples</h2><p>This shows the history output for the path
            <code class="filename">/tags/1.0</code> as of revision 20 in our
            sample repository.</p><pre class="screen">
$ svnlook history -r 20 /usr/local/svn/repos /tags/1.0 --show-ids
REVISION   PATH &lt;ID&gt;
--------   ---------
      19   /tags/1.0 &lt;1.2.12&gt;
      17   /branches/1.0-rc2 &lt;1.1.10&gt;
      16   /branches/1.0-rc2 &lt;1.1.x&gt;
      14   /trunk &lt;1.0.q&gt;
      13   /trunk &lt;1.0.o&gt;
      11   /trunk &lt;1.0.k&gt;
       9   /trunk &lt;1.0.g&gt;
       8   /trunk &lt;1.0.e&gt;
       7   /trunk &lt;1.0.b&gt;
       6   /trunk &lt;1.0.9&gt;
       5   /trunk &lt;1.0.7&gt;
       4   /trunk &lt;1.0.6&gt;
       2   /trunk &lt;1.0.3&gt;
       1   /trunk &lt;1.0.2&gt;
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svnlook.c.info"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnlook info — Print the author, datestamp, log message size,
            and log message.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773822"></a><h2>Synopsis</h2><pre class="programlisting">svnlook info REPOS_PATH</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773832"></a><h2>Description</h2><p>Print the author, datestamp, log message size, and
            log message.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773843"></a><h2>Switches</h2><pre class="screen">
--revision (-r)
--transaction (-t)
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773854"></a><h2>Examples</h2><p>This shows the info output for revision 40 in our
            sample repository.</p><pre class="screen">
$ svnlook info -r 40 /usr/local/svn/repos
sally
2003-02-22 17:44:49 -0600 (Sat, 22 Feb 2003)
15
Rearrange lunch.
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svnlook.c.lock"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnlook lock — If a lock exists on a path in the repository,
            describe it.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773888"></a><h2>Synopsis</h2><pre class="programlisting">svnlook lock REPOS_PATH PATH_IN_REPOS</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773898"></a><h2>Description</h2><p>Print all information available for the lock at
              <em class="replaceable"><code>PATH_IN_REPOS</code></em>.  If
              <em class="replaceable"><code>PATH_IN_REPOS</code></em> is not locked,
              print nothing.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773918"></a><h2>Switches</h2><p>None</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773928"></a><h2>Examples</h2><p>This describes the lock on the file
            <code class="filename">tree.jpg</code>.</p><pre class="screen">
$ svnlook lock /svn/repos tree.jpg
UUID Token: opaquelocktoken:ab00ddf0-6afb-0310-9cd0-dda813329753
Owner: harry
Created: 2005-07-08 17:27:36 -0500 (Fri, 08 Jul 2005)
Expires: 
Comment (1 line):
Rework the uppermost branches on the bald cypress in the foreground.
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svnlook.c.log"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnlook log — Print the log message.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773968"></a><h2>Synopsis</h2><pre class="programlisting">svnlook log REPOS_PATH</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773979"></a><h2>Description</h2><p>Print the log message.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4773989"></a><h2>Switches</h2><pre class="screen">
--revision (-r)
--transaction (-t)
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4774000"></a><h2>Examples</h2><p>This shows the log output for revision 40 in our sample
            repository:</p><pre class="screen">
$ svnlook log /tmp/repos/
Rearrange lunch.
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svnlook.c.propget"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnlook propget — Print the raw value of a property on a path in
            the repository.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4774032"></a><h2>Synopsis</h2><pre class="programlisting">svnlook propget REPOS_PATH PROPNAME [PATH_IN_REPOS]</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4774043"></a><h2>Description</h2><p>List the value of a property on a path in the
            repository.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4774054"></a><h2>Alternate Names</h2><p>pg, pget</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4774065"></a><h2>Switches</h2><pre class="screen">
--revision (-r)
--transaction (-t)
--revprop
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4774076"></a><h2>Examples</h2><p>This shows the value of the «<span class="quote">seasonings</span>» property
            on the file <code class="filename">/trunk/sandwich</code> in the
            <code class="literal">HEAD</code> revision:</p><pre class="screen">
$ svnlook pg /usr/local/svn/repos seasonings /trunk/sandwich
mustard
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svnlook.c.proplist"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnlook proplist — Print the names and values of versioned file and
            directory properties.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4774124"></a><h2>Synopsis</h2><pre class="programlisting">svnlook proplist REPOS_PATH [PATH_IN_REPOS]</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4774135"></a><h2>Description</h2><p>List the properties of a path in the repository.  With
            <code class="option">--verbose</code>, show the property values too.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4774150"></a><h2>Alternate Names</h2><p>pl, plist</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4774160"></a><h2>Switches</h2><pre class="screen">
--revision (-r)
--transaction (-t)
--verbose (-v)
--revprop
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4774172"></a><h2>Examples</h2><p>This shows the names of properties set on the file
            <code class="filename">/trunk/README</code> in the
            <code class="literal">HEAD</code> revision:</p><pre class="screen">
$ svnlook proplist /usr/local/svn/repos /trunk/README
  original-author
  svn:mime-type
</pre><p>This is the same command as in the previous example,
            but this time showing the property values as well:</p><pre class="screen">
$ svnlook --verbose proplist /usr/local/svn/repos /trunk/README
  original-author : fitz
  svn:mime-type : text/plain
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svnlook.c.tree"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnlook tree — Print the tree.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4774226"></a><h2>Synopsis</h2><pre class="programlisting">svnlook tree REPOS_PATH [PATH_IN_REPOS]</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4774237"></a><h2>Description</h2><p>Print the tree, starting at
            <em class="replaceable"><code>PATH_IN_REPOS</code></em> (if supplied, at
            the root of the tree otherwise), optionally showing node
            revision IDs.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4774253"></a><h2>Switches</h2><pre class="screen">
--revision (-r)
--transaction (-t)
--show-ids
</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4774264"></a><h2>Examples</h2><p>This shows the tree output (with node-IDs) for revision
            40 in our sample repository:</p><pre class="screen">
$ svnlook tree -r 40 /usr/local/svn/repos --show-ids
/ &lt;0.0.2j&gt;
 trunk/ &lt;p.0.2j&gt;
  vendors/ &lt;q.0.2j&gt;
   deli/ &lt;1g.0.2j&gt;
    egg.txt &lt;1i.e.2j&gt;
    soda.txt &lt;1k.0.2j&gt;
    sandwich.txt &lt;1j.0.2j&gt;
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svnlook.c.uuid"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnlook uuid — Print the repository's
          <code class="literal">UUID</code>.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4774305"></a><h2>Synopsis</h2><pre class="programlisting">svnlook uuid REPOS_PATH</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4774316"></a><h2>Description</h2><p>Print the <code class="literal">UUID</code> for the repository.
            the UUID is the repository's
            <span class="emphasis"><em>u</em></span>niversal <span class="emphasis"><em>u</em></span>nique
            <span class="emphasis"><em>id</em></span>entifier.  The Subversion client
            uses this identifier to differentiate between one
            repository and another.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4774346"></a><h2>Examples</h2><pre class="screen">          
$ svnlook uuid /usr/local/svn/repos
e7fe1b91-8cd5-0310-98dd-2f12e793c5e8
</pre></div></div><div class="refentry" lang="it" xml:lang="it"><div class="refentry.separator"><hr /></div><a id="svn.ref.svnlook.c.youngest"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnlook youngest — Print the youngest revision number.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4774373"></a><h2>Synopsis</h2><pre class="programlisting">svnlook youngest REPOS_PATH</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4774384"></a><h2>Description</h2><p>Print the youngest revision number of a repository.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="id4774395"></a><h2>Examples</h2><p>This shows the youngest revision of our sample
          repository:</p><pre class="screen">          
$ svnlook youngest /tmp/repos/ 
42
</pre></div></div></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.ref.svnserve"></a><span><strong class="command">svnserve</strong></span></h2></div></div></div><p><span><strong class="command">svnserve</strong></span> allows access to Subversion
      repositories using the <code class="literal">svn</code> network protocol.
      You can run svnserve either as a standalone server process, or
      you can have another process, such as <span><strong class="command">inetd</strong></span>,
      <span><strong class="command">xinetd</strong></span> or <span><strong class="command">sshd</strong></span>, launch it
      for you.</p><p>Once the client has selected a repository by transmitting
      its URL, <span><strong class="command">svnserve</strong></span> reads a file named
      <code class="filename">conf/svnserve.conf</code> in the repository
      directory to determine repository-specific settings such as what
      authentication database to use and what authorization policies
      to apply.  See <a href="#svn.serverconfig.svnserve" title="svnserve, a custom server">la sezione chiamata «svnserve, a custom server»</a> for details of
      the <code class="filename">svnserve.conf</code> file.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.ref.svnserve.sw"></a><span><strong class="command">svnserve</strong></span> Switches</h3></div></div></div><p>Unlike the previous commands we've
        described. <span><strong class="command">svnserve</strong></span> has no
        subcommands—<span><strong class="command">svnserve</strong></span> is controlled
        exclusively by switches.</p><div class="variablelist"><dl><dt><span class="term"><code class="option">--daemon</code> (<code class="option">-d</code>)</span></dt><dd><p>Causes <span><strong class="command">svnserve</strong></span> to run in daemon
              mode.  <span><strong class="command">svnserve</strong></span> backgrounds itself
              and accepts and serves TCP/IP connections on the svn
              port (3690, by default).</p></dd><dt><span class="term"><code class="option">--listen-port</code>=<em class="replaceable"><code>PORT</code></em></span></dt><dd><p>Causes svnserve to listen on
              <em class="replaceable"><code>PORT</code></em> when run in daemon
              mode.</p></dd><dt><span class="term"><code class="option">--listen-host</code>=<em class="replaceable"><code>HOST</code></em></span></dt><dd><p>Causes <span><strong class="command">svnserve</strong></span> to listen on the
              interface specified by <em class="replaceable"><code>HOST</code></em>,
              which may be either a hostname or an IP address.</p></dd><dt><span class="term"><code class="option">--foreground</code></span></dt><dd><p>When used together with <code class="option">-d</code>, this
              switch causes <span><strong class="command">svnserve</strong></span> to stay in the
              foreground.  This switch is mainly useful for
              debugging.</p></dd><dt><span class="term"><code class="option">--inetd</code> (<code class="option">-i</code>)</span></dt><dd><p>Causes <span><strong class="command">svnserve</strong></span> to use the
              stdin/stdout file descriptors, as is appropriate for a
              daemon running out of <span><strong class="command">inetd</strong></span>.</p></dd><dt><span class="term"><code class="option">--help</code> (<code class="option">-h</code>)</span></dt><dd><p>Displays a usage summary and exits.</p></dd><dt><span class="term"><code class="option">--version</code></span></dt><dd><p>Displays version information, a list of repository
            back-end modules available, and exits.</p></dd><dt><span class="term"><code class="option">--root</code>=<em class="replaceable"><code>ROOT</code></em>
          (<code class="option">-r</code>=<em class="replaceable"><code>ROOT</code></em>)</span></dt><dd><p>Sets the virtual root for repositories served by
              <span><strong class="command">svnserve</strong></span>.  The pathname in URLs
              provided by the client will be interpreted relative to
              this root, and will not be allowed to escape this
              root.</p></dd><dt><span class="term"><code class="option">--tunnel</code> (<code class="option">-t</code>)</span></dt><dd><p>Causes <span><strong class="command">svnserve</strong></span> to run in tunnel
              mode, which is just like the <span><strong class="command">inetd</strong></span>
              mode of operation (serve one connection over
              stdin/stdout) except that the connection is considered
              to be pre-authenticated with the username of the current
              uid.  This flag is selected by the client when running
              over a tunnel agent such as
              <span><strong class="command">ssh</strong></span>.</p></dd><dt><span class="term"><code class="option">--tunnel-user NAME</code></span></dt><dd><p>Used in conjunction with <code class="option">--tunnel</code>
              switch; tells svnserve to assume that
              <em class="replaceable"><code>NAME</code></em> is the authenticated
              user, rather than the UID of the svnserve
              process.  Useful for users wishing to share a single
              system account over SSH, but maintaining separate commit
              identities.</p></dd><dt><span class="term"><code class="option">--threads</code> (<code class="option">-T</code>)</span></dt><dd><p>When running in daemon mode, causes
              <span><strong class="command">svnserve</strong></span> to spawn a thread instead of
              a process for each connection.  The
              <span><strong class="command">svnserve</strong></span> process still backgrounds
              itself at startup time.</p></dd><dt><span class="term"><code class="option">--listen-once</code> (<code class="option">-X</code>)</span></dt><dd><p>Causes <span><strong class="command">svnserve</strong></span> to accept one
              connection on the svn port, serve it, and exit.  This
              option is mainly useful for debugging.</p></dd></dl></div></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.ref.svnversion"></a><span><strong class="command">svnversion</strong></span></h2></div></div></div><div class="refentry" lang="it" xml:lang="it"><a id="svn.ref.svnversion.re"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>svnversion — Summarize the local revision(s) of a working
                    copy.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="svn.ref.svnversion.re.syn"></a><h2>Synopsis</h2><pre class="programlisting">svnversion [OPTIONS] WC_PATH [TRAIL_URL]</pre></div><div class="refsect1" lang="it" xml:lang="it"><a id="svn.ref.svnversion.re.desc"></a><h2>Description</h2><p><span><strong class="command">svnversion</strong></span> is a program for
          summarizing the revision mixture of a working copy.  The
          resultant revision number, or revision range, is written to
          standard output.</p><p><em class="replaceable"><code>TRAIL_URL</code></em>, if present, is the
          trailing portion of the URL used to determine if
          <em class="replaceable"><code>WC_PATH</code></em> itself is switched
          (detection of switches within
          <em class="replaceable"><code>WC_PATH</code></em> does not rely on
          <em class="replaceable"><code>TRAIL_URL</code></em>).</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="svn.ref.svnversion.re.sw"></a><h2>Switches</h2><p>Like <span><strong class="command">svnserve</strong></span>,
          <span><strong class="command">svnversion</strong></span> has no subcommands, it only
          has switches.</p><div class="variablelist"><dl><dt><span class="term"><code class="option">--no-newline</code> (<code class="option">-n</code>)</span></dt><dd><p>Omit the usual trailing newline from the output.</p></dd><dt><span class="term"><code class="option">--committed</code> (<code class="option">-c</code>)</span></dt><dd><p>Use the last-changed revisions rather than the
              current (i.e., highest locally available) revisions.</p></dd><dt><span class="term"><code class="option">--help</code> (<code class="option">-h</code>)</span></dt><dd><p>Print a help summary.</p></dd><dt><span class="term"><code class="option">--version</code></span></dt><dd><p>Print the version of <span><strong class="command">svnversion</strong></span>
              and exit with no error.</p></dd></dl></div></div><div class="refsect1" lang="it" xml:lang="it"><a id="svn.ref.svnversion.re.examples"></a><h2>Examples</h2><p>If the working copy is all at the same revision (for
          example, immediately after an update), then that revision is
          printed out:</p><pre class="screen">$ svnversion .
4168</pre><p>You can add TRAIL_URL to show that the working copy is
          not switched from what you expect:</p><pre class="screen">$ svnversion . /repos/svn/trunk
4168</pre><p>For a mixed-revision working copy, the range of
          revisions present is printed:</p><pre class="screen">$ svnversion .
4123:4168</pre><p>If the working copy contains modifications, a trailing
          "M" is added:</p><pre class="screen">$ svnversion .
4168M</pre><p>If the working copy is switched, a trailing "S" is
          added:</p><pre class="screen">$ svnversion .
4168S</pre><p>Thus, here is a mixed-revision, switched working copy
          containing some local modifications:</p><pre class="screen">$ svnversion .
4212:4168MS</pre><p>If invoked on a directory that is not a working copy,
          <span><strong class="command">svnversion</strong></span> assumes it is an exported
          working copy and prints "exported":</p><pre class="screen">$ svnversion .
exported</pre></div></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.ref.mod_dav_svn"></a><span><strong class="command">mod_dav_svn</strong></span></h2></div></div></div><div class="refentry" lang="it" xml:lang="it"><a id="svn.ref.mod_dav_svn.conf"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p><code class="literal">mod_dav_svn</code> Configuration
        Directives — Apache configuration
        directives for serving Subversion repositories through Apache
        HTTP Server.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="svn.ref.mod_dav_svn.conf.desc"></a><h2>Description</h2><p>This section briefly describes each of the Subversion
          Apache configuration directives.  For an in-depth
          description of configuring Apache with Subversion, see <a href="#svn.serverconfig.httpd" title="httpd, the Apache HTTP server">la sezione chiamata «httpd, the Apache HTTP server»</a>.)</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="svn.ref.mod_dav_svn.conf.directives"></a><h2>Directives</h2><div class="variablelist"><dl><dt><span class="term"><code class="literal">DAV svn</code></span></dt><dd><p>This directive must be included in any
                <code class="literal">Directory</code> or
                <code class="literal">Location</code> block for a Subversion
                repository.  It tells httpd to use the Subversion
                backend for mod_dav to handle all requests.</p></dd><dt><span class="term"><code class="literal">SVNAutoversioning On</code></span></dt><dd><p>This directive allows write requests from WebDAV
                clients to result in automatic commits.  A generic log
                message is auto-generated and attached to each
                revision.  If you enable Autoversioning, you'll likely
                want to set <code class="literal">ModMimeUsePathInfo On</code>
                so that <code class="literal">mod_mime</code> can set
                <code class="literal">svn:mime-type</code> to the correct
                mime-type automatically (as best as
                <code class="literal">mod_mime</code> is able to, of course).
                For more information, see <a href="#svn.webdav" title="Appendice&#xA0;B.&#xA0;WebDAV and Autoversioning">Appendice B, <i>WebDAV and Autoversioning</i></a></p></dd><dt><span class="term"><code class="literal">SVNPath</code></span></dt><dd><p>This directive specifies the location in the
                filesystem for a Subversion repository's files.  In a
                configuration block for a Subversion repository,
                either this directive or
                <code class="literal">SVNParentPath</code> must be present, but
                not both.</p></dd><dt><span class="term"><code class="literal">SVNSpecialURI</code></span></dt><dd><p>Specifies the URI component (namespace) for
                special Subversion resources.  The default is
                «<span class="quote"><code class="literal">!svn</code></span>», and most
                administrators will never use this directive.  Only
                set this if there is a pressing need to have a file
                named <code class="filename">!svn</code> in your repository.  If
                you change this on a server already in use, it will
                break all of the outstanding working copies and your
                users will hunt you down with pitchforks and flaming
                torches.</p></dd><dt><span class="term"><code class="literal">SVNReposName</code></span></dt><dd><p>Specifies the name of a Subversion repository for
                use in <code class="literal">HTTP GET</code> requests.  This
                value will be prepended to the title of all directory
                listings (which are served when you navigate to a
                Subversion repository with a web browser).  This
                directive is optional.</p></dd><dt><span class="term"><code class="literal">SVNIndexXSLT</code></span></dt><dd><p>Specifies the URI of an XSL transformation for
                directory indexes.  This directive is optional.</p></dd><dt><span class="term"><code class="literal">SVNParentPath</code></span></dt><dd><p>Specifies the location in the filesystem of a
                parent directory whose child directories are
                Subversion repositories.  In a configuration block for
                a Subversion repository, either this directive or
                <code class="literal">SVNPath</code> must be present, but not
                both.</p></dd><dt><span class="term"><code class="literal">SVNPathAuthz</code></span></dt><dd><p>Control path-based authorization by enabling or
                disabling subrequests.  See <a href="#svn.serverconfig.httpd.authz.pathauthzoff" title="Disabling Path-based Checks">la sezione chiamata «Disabling Path-based Checks»</a> for details.</p></dd></dl></div></div></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.ref.properties"></a><span><strong class="command">Subversion properties</strong></span></h2></div></div></div><div class="refentry" lang="it" xml:lang="it"><a id="svn.ref.svnprops"></a><div class="titlepage"></div><div class="refnamediv"><h2>Nome</h2><p>Subversion-defined properties — 
        properties defined by Subversion to control behavior.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="svn.ref.svnprops.desc"></a><h2>Description</h2><p>Subversion allows users to invent arbitrarily-named
          versioned properties on files and directories, as well as
          unversioned properties on revisions.  The only restriction
          is on properties prefixed with «<span class="quote">svn:</span>».
          Properties in that namespace are reserved for Subversion's
          own use.  While these properties may be set by users to
          control Subversion's behavior, users may not invent new
          «<span class="quote">svn:</span>» properties.</p></div><div class="refsect1" lang="it" xml:lang="it"><a id="svn.ref.properties.versioned-props"></a><h2>Versioned Properties</h2><div class="variablelist"><dl><dt><span class="term"><code class="literal">svn:executable</code></span></dt><dd><p>If present on a file, the client will make the
                file executable in Unix-hosted working copies.  See
                <a href="#svn.advanced.props.special.executable" title="svn:executable">la sezione chiamata «<code class="literal">svn:executable</code>»</a>.</p></dd><dt><span class="term"><code class="literal">svn:mime-type</code></span></dt><dd><p>If present on a file, the value indicates the
                file's mime-type.  This allows the client to decide
                whether line-based contextual merging is safe to
                perform during updates, and can also affect how the
                file behaves when fetched via web browser.  See
                <a href="#svn.advanced.props.special.mime-type" title="svn:mime-type">la sezione chiamata «<code class="literal">svn:mime-type</code>»</a>. </p></dd><dt><span class="term"><code class="literal">svn:ignore</code></span></dt><dd><p>If present on a directory, the value is a list of
                unversioned file patterns to be ignored
                by <span><strong class="command">svn status</strong></span> and other
                subcommands.  See
                <a href="#svn.advanced.props.special.ignore" title="svn:ignore">la sezione chiamata «<code class="literal">svn:ignore</code>»</a></p></dd><dt><span class="term"><code class="literal">svn:keywords</code></span></dt><dd><p>If present on a file, the value tells the client
                how to expand particular keywords within the file.
                See
                <a href="#svn.advanced.props.special.keywords" title="svn:keywords">la sezione chiamata «<code class="literal">svn:keywords</code>»</a>.</p></dd><dt><span class="term"><code class="literal">svn:eol-style</code></span></dt><dd><p>If present on a file, the value tells the client
                how to manipulate the file's line-endings in the
                working copy.  See
                <a href="#svn.advanced.props.special.eol-style" title="svn:eol-style">la sezione chiamata «<code class="literal">svn:eol-style</code>»</a>.</p></dd><dt><span class="term"><code class="literal">svn:externals</code></span></dt><dd><p>If present on a directory, the value is a
                multi-line list of other paths and URLs the client
                should check out.  See
                <a href="#svn.advanced.props.special.externals" title="svn:externals">la sezione chiamata «<code class="literal">svn:externals</code>»</a>.</p></dd><dt><span class="term"><code class="literal">svn:special</code></span></dt><dd><p>If present on a file, indicates that the file is
                not an ordinary file, but a symbolic link or other
                special object.  See
                <a href="#svn.advanced.props.special.special" title="svn:special">la sezione chiamata «<code class="literal">svn:special</code>»</a>.</p></dd><dt><span class="term"><code class="literal">svn:needs-lock</code></span></dt><dd><p>If present on a file, tells the client to make the
                file read-only in the working copy, as a reminder that
                the file should be locked before editing begins.  See
                <a href="#svn.advanced.locking.lock-communication" title="Lock Communication">la sezione chiamata «Lock Communication»</a>.</p></dd></dl></div></div><div class="refsect1" lang="it" xml:lang="it"><a id="svn.ref.properties.unversioned-props"></a><h2>Unversioned Properties</h2><div class="variablelist"><dl><dt><span class="term"><code class="literal">svn:author</code></span></dt><dd><p>If present, contains the authenticated username of
                the person who created the revision.  (If not present,
                then the revision was committed anonymously.)</p></dd><dt><span class="term"><code class="literal">svn:date</code></span></dt><dd><p>Contains the UTC time the revision was created, in
                ISO format.  The value comes from the server
                machine's clock.</p></dd><dt><span class="term"><code class="literal">svn:log</code></span></dt><dd><p>Contains the log message describing the
                revision.</p></dd><dt><span class="term"><code class="literal">svn:autoversioned</code></span></dt><dd><p>If present, the revision was created via the
                autoversioning feature.  See
                <a href="#svn.webdav.autoversioning" title="Autoversioning">la sezione chiamata «Autoversioning»</a>.</p></dd></dl></div></div></div></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.id4763777" href="#id4763777">49</a>] </sup>Yes, yes, you don't need a subcommand to use the
      <code class="option">--version</code> switch, but we'll get to that in just
      a minute.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4771561" href="#id4771561">50</a>] </sup>Remember,
              <span><strong class="command">svnadmin</strong></span> works only with local
              <span class="emphasis"><em>paths</em></span>, not
              <span class="emphasis"><em>URLs</em></span>.</p></div></div></div><div class="appendix" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title"><a id="svn.forcvs"></a>Appendice A. Subversion for CVS Users</h2></div></div></div><div class="toc"><p><b>Sommario</b></p><dl><dt><span class="sect1"><a href="#svn.forcvs.revnums">Revision Numbers Are Different Now</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.directories">Directory Versions</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.disconnected">More Disconnected Operations</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.status-vs-update">Distinction Between Status and Update</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.forcvs.status-vs-update.status">Status</a></span></dt><dt><span class="sect2"><a href="#svn.forcvs.status-vs-update.update">Update</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.forcvs.branches-and-tags">Branches and Tags</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.properties">Metadata Properties</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.conflicts">Conflict Resolution</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.binary-and-trans">Binary Files and Translation</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.modules">Versioned Modules</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.auth">Authentication</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.convert">Converting a Repository from CVS to Subversion</a></span></dt></dl></div><div class="simplesect" lang="it" xml:lang="it"><div class="titlepage"></div><p>This appendix is a guide for CVS users new to Subversion.
      It's essentially a list of differences between the two systems
      as «<span class="quote">viewed from 10,000 feet</span>».  For each section, we
      provide backreferences to relevant chapters when
      possible.</p><p>Although the goal of Subversion is to take over the current
      and future CVS user base, some new features and design changes
      were required to fix certain «<span class="quote">broken</span>» behaviors
      that CVS had.  This means that, as a CVS user, you may need to
      break habits—ones that you forgot were odd to begin
      with.</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.forcvs.revnums"></a>Revision Numbers Are Different Now</h2></div></div></div><p>In CVS, revision numbers are per-file.  This is because CVS
      stores its data in RCS files; each file has a corresponding RCS
      file in the repository, and the repository is roughly laid out
      according to the structure of your project tree.</p><p>In Subversion, the repository looks like a single
      filesystem.  Each commit results in an entirely new filesystem
      tree; in essence, the repository is an array of trees.  Each of
      these trees is labeled with a single revision number.  When
      someone talks about «<span class="quote">revision 54</span>», they're talking
      about a particular tree (and indirectly, the way the filesystem
      looked after the 54th commit).</p><p>Technically, it's not valid to talk about «<span class="quote">revision 5
      of <code class="filename">foo.c</code></span>».  Instead, one would say
      «<span class="quote"><code class="filename">foo.c</code> as it appears in revision
      5</span>».  Also, be careful when making assumptions about the
      evolution of a file.  In CVS, revisions 5 and 6 of
      <code class="filename">foo.c</code> are always different.  In Subversion,
      it's most likely that <code class="filename">foo.c</code> did
      <span class="emphasis"><em>not</em></span> change between revisions 5 and
      6.</p><p>For more details on this topic, see <a href="#svn.basic.in-action.revs" title="Revisions">la sezione chiamata «Revisions»</a>.</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.forcvs.directories"></a>Directory Versions</h2></div></div></div><p>Subversion tracks tree structures, not just file contents.
      It's one of the biggest reasons Subversion was written to
      replace CVS.</p><p>Here's what this means to you, as a former CVS user:</p><div class="itemizedlist"><ul type="disc"><li><p>The <span><strong class="command">svn add</strong></span> and <span><strong class="command">svn
          delete</strong></span> commands work on directories now, just as
          they work on files.  So do <span><strong class="command">svn copy</strong></span> and
          <span><strong class="command">svn move</strong></span>.  However, these commands do
          <span class="emphasis"><em>not</em></span> cause any kind of immediate change
          in the repository.  Instead, the working items are simply
          «<span class="quote">scheduled</span>» for addition or deletion.  No
          repository changes happen until you run <span><strong class="command">svn
          commit</strong></span>.</p></li><li><p>Directories aren't dumb containers anymore; they have
          revision numbers like files.  (Or more properly, it's
          correct to talk about «<span class="quote">directory
          <code class="filename">foo/</code> in revision 5</span>».)</p></li></ul></div><p>Let's talk more about that last point.  Directory versioning
      is a hard problem; because we want to allow mixed-revision
      working copies, there are some limitations on how far we can
      abuse this model.</p><p>From a theoretical point of view, we define «<span class="quote">revision
      5 of directory <code class="filename">foo</code></span>» to mean a
      specific collection of directory-entries and properties.  Now
      suppose we start adding and removing files from
      <code class="filename">foo</code>, and then commit.  It would be a lie
      to say that we still have revision 5 of
      <code class="filename">foo</code>.  However, if we bumped
      <code class="filename">foo</code>'s revision number after the commit,
      that would be a lie too; there may be other changes to
      <code class="filename">foo</code> we haven't yet received, because we
      haven't updated yet.</p><p>Subversion deals with this problem by quietly tracking
      committed adds and deletes in the <code class="filename">.svn</code>
      area.  When you eventually run <span><strong class="command">svn update</strong></span>,
      all accounts are settled with the repository, and the
      directory's new revision number is set correctly.
      <span class="emphasis"><em>Therefore, only after an update is it truly safe to
      say that you have a «<span class="quote">perfect</span>» revision of a
      directory.</em></span> Most of the time, your working copy will
      contain «<span class="quote">imperfect</span>» directory revisions.</p><p>Similarly, a problem arises if you attempt to commit
      property changes on a directory.  Normally, the commit would
      bump the working directory's local revision number.  But again,
      that would be a lie, because there may be adds or deletes that
      the directory doesn't yet have, because no update has happened.
      <span class="emphasis"><em>Therefore, you are not allowed to commit
      property-changes on a directory unless the directory is
      up-to-date.</em></span></p><p>For more discussion about the limitations of directory
      versioning, see <a href="#svn.basic.in-action.mixedrevs" title="Copie di lavoro con revisioni miste">la sezione chiamata «Copie di lavoro con revisioni miste»</a>.</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.forcvs.disconnected"></a>More Disconnected Operations</h2></div></div></div><p>In recent years, disk space has become outrageously cheap
      and abundant, but network bandwidth has not.  Therefore, the
      Subversion working copy has been optimized around the scarcer
      resource.</p><p>The <code class="filename">.svn</code> administrative directory
      serves the same purpose as the <code class="filename">CVS</code>
      directory, except that it also stores read-only,
      «<span class="quote">pristine</span>» copies of your files.  This allows you
      to do many things off-line:</p><div class="variablelist"><dl><dt><span class="term"><span><strong class="command">svn status</strong></span></span></dt><dd><p>Shows you any local changes you've made (see <a href="#svn.tour.cycle.examine.status" title="svn status">la sezione chiamata «<span><strong class="command">svn status</strong></span>»</a>)</p></dd><dt><span class="term"><span><strong class="command">svn diff</strong></span></span></dt><dd><p>Shows you the details of your changes (see <a href="#svn.tour.cycle.examine.diff" title="svn diff">la sezione chiamata «<span><strong class="command">svn diff</strong></span>»</a>)</p></dd><dt><span class="term"><span><strong class="command">svn revert</strong></span></span></dt><dd><p>Removes your local changes (see <a href="#svn.tour.cycle.examine.revert" title="svn revert">la sezione chiamata «<span><strong class="command">svn revert</strong></span>»</a>)</p></dd></dl></div><p>Also, the cached pristine files allow the Subversion client
      to send differences when committing, which CVS cannot do.</p><p>The last subcommand in the list is new; it will not only
      remove local changes, but it will un-schedule operations such as
      adds and deletes.  It's the preferred way to revert a file;
      running <span><strong class="command">rm file; svn update</strong></span> will still work, but
      it blurs the purpose of updating.  And, while we're on this
      subject…

    </p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.forcvs.status-vs-update"></a>Distinction Between Status and Update</h2></div></div></div><p>In Subversion, we've tried to erase a lot of the confusion
      between the <span><strong class="command">cvs status</strong></span> and
      <span><strong class="command">cvs update</strong></span> commands.</p><p>The <span><strong class="command">cvs status</strong></span> command has two purposes:
      first, to show the user any local modifications in the working
      copy, and second, to show the user which files are out-of-date.
      Unfortunately, because of CVS's hard-to-read status output, many
      CVS users don't take advantage of this command at all.  Instead,
      they've developed a habit of running <span><strong class="command">cvs
      update</strong></span> or <span><strong class="command">cvs -n update</strong></span> to quickly
      see their changes.  If users forget to use
      the <code class="option">-n</code> option, this has the side effect of
      merging repository changes they may not be ready to deal
      with.</p><p>With Subversion, we've tried to remove this muddle by making
      the output of <span><strong class="command">svn status</strong></span> easy to read for
      both humans and parsers.  Also, <span><strong class="command">svn update</strong></span>
      only prints information about files that are updated,
      <span class="emphasis"><em>not</em></span> local modifications.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.forcvs.status-vs-update.status"></a>Status</h3></div></div></div><p><span><strong class="command">svn status</strong></span> prints all files that have
        local modifications.  By default, the repository is not
        contacted.  While this subcommand accepts a fair number of
        options, the following are the most commonly used ones:</p><div class="variablelist"><dl><dt><span class="term"><code class="option">-u</code></span></dt><dd><p>Contact the repository to determine, and then display,
              out-of-dateness information.</p></dd><dt><span class="term"><code class="option">-v</code></span></dt><dd><p>Show <span class="emphasis"><em>all</em></span> entries under
              version control.</p></dd><dt><span class="term"><code class="option">-N</code></span></dt><dd><p>Run non-recursively (do not descend into
              subdirectories).</p></dd></dl></div><p>The <span><strong class="command">status</strong></span> command has two output
        formats.  In the default «<span class="quote">short</span>» format, local
        modifications look like this:</p><pre class="screen">
$ svn status
M      foo.c
M      bar/baz.c
</pre><p>If you specify the <code class="option">--show-updates</code>
        (<code class="option">-u</code>) switch, a longer output format is
        used:</p><pre class="screen">
$ svn status -u
M            1047   foo.c
       *     1045   faces.html
       *            bloo.png
M            1050   bar/baz.c
Status against revision:   1066
</pre><p>In this case, two new columns appear.  The second column
        contains an asterisk if the file or directory is out-of-date.
        The third column shows the working-copy's revision number of the
        item.  In the example above, the asterisk indicates that
        <code class="filename">faces.html</code> would be patched if we updated,
        and that <code class="filename">bloo.png</code> is a newly added file in
        the repository.  (The absence of any revision number next to
        <code class="filename">bloo.png</code> means that it doesn't yet exist in
        the working copy.)</p><p>Lastly, here's a quick summary of the most common status codes that
        you may see:</p><pre class="screen">
A    Resource is scheduled for Addition
D    Resource is scheduled for Deletion
M    Resource has local Modifications
C    Resource has Conflicts (changes have not been completely merged
       between the repository and working copy version)
X    Resource is eXternal to this working copy (may come from another
       repository).  See <a href="#svn.advanced.props.special.externals" title="svn:externals">la sezione chiamata «<code class="literal">svn:externals</code>»</a>
?    Resource is not under version control
!    Resource is missing or incomplete (removed by another tool than
       Subversion)
</pre><p>For a more detailed discussion of <span><strong class="command">svn
        status</strong></span>, see <a href="#svn.tour.cycle.examine.status" title="svn status">la sezione chiamata «<span><strong class="command">svn status</strong></span>»</a>.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.forcvs.status-vs-update.update"></a>Update</h3></div></div></div><p><span><strong class="command">svn update</strong></span> updates your working copy,
        and only prints information about files that it updates.</p><p>Subversion has combined the CVS <code class="literal">P</code> and
        <code class="literal">U</code> codes into just <code class="literal">U</code>.  When
        a merge or conflict occurs, Subversion simply prints
        <code class="literal">G</code> or <code class="literal">C</code>, rather than a
        whole sentence about it.</p><p>For a more detailed discussion of <span><strong class="command">svn
        update</strong></span>, see <a href="#svn.tour.cycle.update" title="Update Your Working Copy">la sezione chiamata «Update Your Working Copy»</a>.</p></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.forcvs.branches-and-tags"></a>Branches and Tags</h2></div></div></div><p>Subversion doesn't distinguish between filesystem space and
      «<span class="quote">branch</span>» space; branches and tags are ordinary
      directories within the filesystem.  This is probably the single
      biggest mental hurdle a CVS user will need to climb.  Read all
      about it in <a href="#svn.branchmerge" title="Capitolo&#xA0;4.&#xA0;Branching and Merging">Capitolo 4, <i>Branching and Merging</i></a>.</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Avvertimento</h3><p>Since Subversion treats branches and tags as ordinary
        directories, always remember to check out the
        <code class="literal">trunk</code>
        (<code class="literal">http://svn.example.com/repos/calc/trunk/</code>)
        of your project, and not the project itself
        (<code class="literal">http://svn.example.com/repos/calc/</code>).  If
        you make the mistake of checking out the project itself,
        you'll wind up with a working copy that contains a copy of
        your project for every branch and tag you
        have.<sup>[<a id="id4776766" href="#ftn.id4776766">51</a>]</sup></p></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.forcvs.properties"></a>Metadata Properties</h2></div></div></div><p>A new feature of Subversion is that you can attach arbitrary
      metadata (or «<span class="quote">properties</span>») to files and
      directories.  Properties are arbitrary name/value pairs
      associated with files and directories in your working
      copy.</p><p>To set or get a property name, use the <span><strong class="command">svn
      propset</strong></span> and <span><strong class="command">svn propget</strong></span>
      subcommands.  To list all properties on an object, use
      <span><strong class="command">svn proplist</strong></span>.</p><p>For more information, see <a href="#svn.advanced.props" title="Properties">la sezione chiamata «Properties»</a>.</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.forcvs.conflicts"></a>Conflict Resolution</h2></div></div></div><p>CVS marks conflicts with in-line «<span class="quote">conflict
      markers</span>», and prints a <code class="literal">C</code> during an
      update.  Historically, this has caused problems, because CVS
      isn't doing enough.  Many users forget about (or don't see) the
      <code class="literal">C</code> after it whizzes by on their terminal.
      They often forget that the conflict-markers are even present,
      and then accidentally commit files containing
      conflict-markers.</p><p>Subversion solves this problem by making conflicts more
      tangible.  It remembers that a file is in a state of conflict,
      and won't allow you to commit your changes until you run
      <span><strong class="command">svn resolved</strong></span>.  See <a href="#svn.tour.cycle.resolve" title="Resolve Conflicts (Merging Others' Changes)">la sezione chiamata «Resolve Conflicts (Merging Others' Changes)»</a> for more details.</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.forcvs.binary-and-trans"></a>Binary Files and Translation</h2></div></div></div><p>In the most general sense, Subversion handles binary files
      more gracefully than CVS does.  Because CVS uses RCS, it can
      only store successive full copies of a changing binary file.
      Subversion, however, expresses differences between files using a
      binary-differencing algorithm, regardless of whether they
      contain textual or binary data.  That means that all files are
      stored differentially (compressed) in the repository.</p><p>CVS users have to mark binary files with
      <code class="option">-kb</code> flags, to prevent data from being garbled
      (due to keyword expansion and line-ending translations).  They
      sometimes forget to do this.</p><p>Subversion takes the more paranoid route—first, it never
      performs any kind of keyword or line-ending translation unless
      you explicitly ask it do so (see <a href="#svn.advanced.props.special.keywords" title="svn:keywords">la sezione chiamata «<code class="literal">svn:keywords</code>»</a> and <a href="#svn.advanced.props.special.eol-style" title="svn:eol-style">la sezione chiamata «<code class="literal">svn:eol-style</code>»</a> for more details).  By default,
      Subversion treats all file data as literal byte strings, and
      files are always stored in the repository in an untranslated
      state.</p><p>Second, Subversion maintains an internal notion of whether a
      file is «<span class="quote">text</span>» or «<span class="quote">binary</span>» data, but
      this notion is <span class="emphasis"><em>only</em></span> extant in the working
      copy.  During an <span><strong class="command">svn update</strong></span>, Subversion will
      perform contextual merges on locally modified text files, but
      will not attempt to do so for binary files.</p><p>To determine whether a contextual merge is possible,
      Subversion examines the <code class="literal">svn:mime-type</code>
      property.  If the file has no <code class="literal">svn:mime-type</code>
      property, or has a mime-type that is textual (e.g.
      <code class="literal">text/*</code>),
      Subversion assumes it is text.  Otherwise, Subversion assumes
      the file is binary.  Subversion also helps users by running a
      binary-detection algorithm in the <span><strong class="command">svn import</strong></span>
      and <span><strong class="command">svn add</strong></span> commands.  These commands will
      make a good guess and then (possibly) set a binary
      <code class="literal">svn:mime-type</code> property on the file being
      added.  (If Subversion guesses wrong, the user can always remove
      or hand-edit the property.)</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.forcvs.modules"></a>Versioned Modules</h2></div></div></div><p>Unlike CVS, a Subversion working copy is aware that it has
      checked out a module.  That means that if somebody changes the
      definition of a module (e.g. adds or removes components), then a
      call to <span><strong class="command">svn update</strong></span> will update the working
      copy appropriately, adding and removing components.</p><p>Subversion defines modules as a list of directories within a
      directory property:  see <a href="#svn.advanced.externals" title="Externals Definitions">la sezione chiamata «Externals Definitions»</a>.</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.forcvs.auth"></a>Authentication</h2></div></div></div><p>With CVS's pserver, you are required to «<span class="quote">login</span>»
      to the server before any read or write operation—you even
      have to login for anonymous operations.  With a Subversion
      repository using Apache <span><strong class="command">httpd</strong></span> or
      <span><strong class="command">svnserve</strong></span> as the server, you don't provide
      any authentication credentials at the outset—if an
      operation that you perform requires authentication, the server
      will challenge you for your credentials (whether those
      credentials are username and password, a client certificate, or
      even both).  So if your repository is world-readable, you will
      not be required to authenticate at all for read
      operations.</p><p>As with CVS, Subversion still caches your credentials on
      disk (in your <code class="filename">~/.subversion/auth/</code>
      directory) unless you tell it not to by using the
      <code class="option">--no-auth-cache</code> switch.</p><p>The exception to this behavior, however, is in the case of
      accessing an <span><strong class="command">svnserve</strong></span> server over an SSH
      tunnel, using the <code class="literal">svn+ssh://</code> URL schema.  In
      that case, the <span><strong class="command">ssh</strong></span> program unconditionally
      demands authentication just to start the tunnel.</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.forcvs.convert"></a>Converting a Repository from CVS to Subversion</h2></div></div></div><p>Perhaps the most important way to familiarize CVS users with
      Subversion is to let them continue to work on their projects
      using the new system.  And while that can be somewhat
      accomplished using a flat import into a Subversion repository of
      an exported CVS repository, the more thorough solution involves
      transferring not just the latest snapshot of their data, but all
      the history behind it as well, from one system to another.  This
      is an extremely difficult problem to solve that involves
      deducing changesets in the absence of atomicity, and translating
      between the systems' completely orthogonal branching policies,
      among other complications.  Still, there are a handful of tools
      claiming to at least partially support the ability to convert
      existing CVS repositories into Subversion ones.</p><p>One such tool is cvs2svn
      (<a href="http://cvs2svn.tigris.org/" target="_top">http://cvs2svn.tigris.org/</a>), a Python script
      originally created by members of Subversion's own development
      community.  Others include Lev Serebryakov's RefineCVS
      (<a href="http://lev.serebryakov.spb.ru/refinecvs/" target="_top">http://lev.serebryakov.spb.ru/refinecvs/</a>).
      These tools have various levels of completeness, and may make
      entirely different decisions about how to handle your CVS
      repository history.  Whichever tool you decide to use, be sure
      to perform as much verification as you can stand on the
      conversion results—after all, you've worked hard to build
      that history!</p><p>For an updated collection of links to known converter tools,
      visit the Links page of the Subversion website
      (<a href="http://subversion.tigris.org/project_links.html" target="_top">http://subversion.tigris.org/project_links.html</a>).</p></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.id4776766" href="#id4776766">51</a>] </sup>That is, providing you don't run out of
        disk space before your checkout
        finishes.</p></div></div></div><div class="appendix" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title"><a id="svn.webdav"></a>Appendice B. WebDAV and Autoversioning</h2></div></div></div><div class="toc"><p><b>Sommario</b></p><dl><dt><span class="sect1"><a href="#svn.webdav.basic">Basic WebDAV Concepts</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.webdav.basic.original">Original WebDAV</a></span></dt><dt><span class="sect2"><a href="#svn.webdav.basic.deltav">DeltaV Extensions</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.webdav.svn-and-deltav">Subversion and DeltaV</a></span></dt><dt><span class="sect1"><a href="#svn.webdav.autoversioning">Autoversioning</a></span></dt><dt><span class="sect1"><a href="#svn.webdav.clients">Client Interoperability</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.webdav.clients.standalone">Standalone WebDAV applications</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.webdav.clients.standalone.windows">Microsoft Office, Dreamweaver, Photoshop</a></span></dt><dt><span class="sect3"><a href="#svn.webdav.clients.standalone.free">Cadaver, DAV Explorer</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.webdav.clients.file-explorer-extensions">File-explorer WebDAV extensions</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.webdav.clients.file-explorer-extensions.windows">Microsoft Web Folders</a></span></dt><dt><span class="sect3"><a href="#svn.webdav.clients.file-explorer-extensions.linux-de">Nautilus, Konqueror</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.webdav.clients.fs-impl">WebDAV filesystem implementation</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.webdav.clients.fs-impl.windows">WebDrive, NetDrive</a></span></dt><dt><span class="sect3"><a href="#svn.webdav.clients.fs-impl.macosx">Mac OS X</a></span></dt><dt><span class="sect3"><a href="#svn.webdav.clients.fs-impl.linux">Linux davfs2</a></span></dt></dl></dd></dl></dd></dl></div><div class="simplesect" lang="it" xml:lang="it"><div class="titlepage"></div><p>WebDAV is an extension to HTTP, and is growing more and more
      popular as a standard for file-sharing.  Today's operating
      systems are becoming extremely Web-aware, and many now have
      built-in support for mounting «<span class="quote">shares</span>» exported by
      WebDAV servers.</p><p>If you use Apache/mod_dav_svn as your Subversion network
      server, then to some extent, you are also running a WebDAV
      server.  This appendix gives some background on the nature of
      this protocol, how Subversion uses it, and how well Subversion
      interoperates with other software that is WebDAV-aware.</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.webdav.basic"></a>Basic WebDAV Concepts</h2></div></div></div><p>This section provides a very brief, very general overview to
      the ideas behind WebDAV.  It should lay the foundation for
      understanding WebDAV compatibility issues between clients and
      servers.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.webdav.basic.original"></a>Original WebDAV</h3></div></div></div><p>RFC 2518 defines a set of concepts and accompanying
        extension methods to HTTP 1.1 that make the web into a more
        universal read/write medium.  The basic idea is that a
        WebDAV-compliant web server can act like a generic file
        server; clients can mount shared folders that behave much like
        NFS or SMB filesystems.</p><p>The tragedy, though, is that the RFC 2518 WebDAV
        specification does not provide any sort of model for version
        control, despite the «<span class="quote">V</span>» in DAV.  Basic WebDAV
        clients and servers assume only one version of each file or
        directory exists, and can be repeatedly overwritten.</p><p>Here are the concepts and terms introduced in basic
        WebDAV:</p><div class="variablelist"><dl><dt><span class="term">Resources</span></dt><dd><p> WebDAV lingo refers to any server-side object
              (that can be described with a URI) as a
              <em class="firstterm">resource</em>.</p></dd><dt><span class="term">New write methods</span></dt><dd><p>Beyond the standard HTTP <code class="literal">PUT</code>
              method (which creates or overwrites a web resource),
              WebDAV defines new <code class="literal">COPY</code> and
              <code class="literal">MOVE</code> methods for duplicating or
              rearranging resources.</p></dd><dt><span class="term">Collections</span></dt><dd><p>A <em class="firstterm">collection</em> is the WebDAV
              term for a grouping of resources.  In most cases, it
              is analogous to a directory.  Whereas file resources
              can be written or created with a
              <code class="literal">PUT</code> method, collection resources
              are created with the new <code class="literal">MKCOL</code>
              method.</p></dd><dt><span class="term">Properties</span></dt><dd><p>This is the same idea present in
              Subversion—metadata attached to files and
              collections.  A client can list or retrieve properties
              attached to a resource with the new
              <code class="literal">PROPFIND</code> method, and can change
              them with the <code class="literal">PROPPATCH</code> method.
              Some properties are wholly created and controlled by
              users (e.g. a property called «<span class="quote">color</span>»),
              and others are wholly created and controlled by the
              WebDAV server (e.g. a property that contains the last
              modification time of a file).  The former kind are
              called <em class="firstterm">dead properties</em>, and the
              latter kind are called <em class="firstterm">live
                properties</em>.</p></dd><dt><span class="term">Locking</span></dt><dd><p>A WebDAV server may decide to offer a locking
              feature to clients—this part of the
              specification is optional, although most WebDAV
              servers do offer the feature.  If present, then
              clients can use the new <code class="literal">LOCK</code> and
              <code class="literal">UNLOCK</code> methods to mediate access to
              a resource.  In most cases these methods are used to
              create exclusive write locks (as discussed in <a href="#svn.basic.vsn-models.lock-unlock" title="The Lock-Modify-Unlock Solution">la sezione chiamata «The Lock-Modify-Unlock Solution»</a>), although shared write
              locks are also possible in some server
              implementations.</p></dd><dt><span class="term">Access control</span></dt><dd><p>A more recent specification (RFC 3744) defines a
              system for defining access control lists (ACLs) on
              WebDAV resources.  Some clients and servers have begun
              to implement this feature.</p></dd></dl></div></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.webdav.basic.deltav"></a>DeltaV Extensions</h3></div></div></div><p>Because RFC 2518 left out versioning concepts, another
        committee was left with the responsibility of writing RFC
        3253, which adds versioning to WebDAV,
        a.k.a. «<span class="quote">DeltaV</span>».  WebDAV/DeltaV clients and
        servers are often called just «<span class="quote">DeltaV</span>» programs,
        since DeltaV implies the existence of basic WebDAV.</p><p>DeltaV introduces a whole slew of new acronyms, but don't
        be intimidated.  The ideas are fairly straightforward:</p><div class="variablelist"><dl><dt><span class="term">Per-resource versioning</span></dt><dd><p>Like CVS and other version-control systems,
              DeltaV assumes that each resource has a potentially
              infinite number of states.  A client begins by placing
              a resource under version control using the new
              <code class="literal">VERSION-CONTROL</code> method.</p></dd><dt><span class="term">Server-side working-copy model</span></dt><dd><p>Some DeltaV servers support the ability to create
              a virtual workspace on the server, where all of your
              work is performed.  Clients use the
              <code class="literal">MKWORKSPACE</code> method to create a
              private area, then indicate they want to change
              specific resources by «<span class="quote">checking them out</span>»
              into the workspace, editing them, and «<span class="quote">checking
              them in</span>» again.  In HTTP terms, the sequence of
              methods would be <code class="literal">CHECKOUT</code>,
              <code class="literal">PUT</code>,
              <code class="literal">CHECKIN</code>.</p></dd><dt><span class="term">Client-side working-copy model</span></dt><dd><p>Some DeltaV servers also support the idea that the
              client may have a private working copy on local disk.
              When the client wants to commit changes to the server,
              it begins by creating a temporary server transaction
              (called an <em class="firstterm">activity</em>) with the
              <code class="literal">MKACTIVITY</code> method.  The client then
              performs a <code class="literal">CHECKOUT</code> on each
              resource it wishes to change and sends
              <code class="literal">PUT</code> requests.  Finally, the client
              performs a <code class="literal">CHECKIN</code> resource, or
              sends a <code class="literal">MERGE</code> request to check in
              all resources at once.</p></dd><dt><span class="term">Configurations</span></dt><dd><p>DeltaV allows you define flexible collections of
              resources called «<span class="quote">configurations</span>», which
              don't necessarily correspond to particular
              directories.  A configuration can be made to point to
              specific versions of files, and then a
              «<span class="quote">baseline</span>» snapshot can be made, much
              like a tag.</p></dd><dt><span class="term">Extensibility</span></dt><dd><p>DeltaV defines a new method,
              <code class="literal">REPORT</code>, which allows the client and
              server to perform customized data exchanges.  While
              DeltaV defines a number of standardized history reports
              that a client can request, the server is also free
              to define custom reports.  The client sends a
              <code class="literal">REPORT</code> request with a
              properly-labeled XML body full of custom data; assuming
              the server understands the specific report-type, it
              responds with an equally custom XML body.  This
              technique is very similar to XML-RPC.</p></dd></dl></div></div></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.webdav.svn-and-deltav"></a>Subversion and DeltaV</h2></div></div></div><p>The original WebDAV standard has been widely successful.
      Every modern computer operating system has a general WebDAV
      client built-in (details to follow), and a number of popular
      standalone applications are also able to speak WebDAV —
      Microsoft Office, Dreamweaver, and Photoshop to name a few.  On
      the server end, the Apache webserver has been able to provide
      WebDAV services since 1998 and is considered the de-facto
      open-source standard.  There are several other commercial WebDAV
      servers available, including Microsoft's own IIS.</p><p>DeltaV, unfortunately, has not been so successful.  It's
      very difficult to find any DeltaV clients or servers.  The few
      that do exist are relatively unknown commercial products, and
      thus it's very difficult to test interoperability.  It's not
      entirely clear as to why DeltaV has remained stagnant.  Some
      argue that the specification is just too complex, others argue
      that while WebDAV's features have mass appeal (even the least
      technical users appreciate network file-sharing), version
      control features aren't interesting or necessary for most users.
      Finally, some have argued that DeltaV remains unpopular because
      there's still no open-source server product which implements
      it.</p><p>When Subversion was still in its design phase, it seemed
      like a great idea to use Apache httpd as the main network
      server.  It already had a module to provide WebDAV services.
      DeltaV was a relatively new specification.  The hope was that
      the Subversion server module (mod_dav_svn) would eventually
      evolve into an open-source DeltaV reference implementation.
      Unfortunately, DeltaV has a very specific versioning model that
      doesn't quite line up with Subversion's model.  Some concepts
      were mappable, others were not.</p><p>The upshot is that</p><div class="orderedlist"><ol type="1"><li><p>The Subversion client is not a fully-implemented DeltaV
          client.</p><p>The client needs certain things from the server that
          DeltaV cannot provide, and thus is largely dependent on a
          number of Subversion-specific <code class="literal">REPORT</code>
          requests that only mod_dav_svn understands.</p></li><li><p>mod_dav_svn is not a fully-implemented DeltaV server.</p><p>Many portions of the DeltaV specification were irrelevant to
          Subversion, and thus left unimplemented.</p></li></ol></div><p>There is still some debate in the developer community as to
      whether or not it's worthwhile to remedy either of these
      situations.  It's fairly unrealistic to change Subversion's
      design to match DeltaV, so there's probably no way the client
      can ever learn to get everything it needs from a general DeltaV
      server.  On the other hand,
      mod_dav_svn <span class="emphasis"><em>could</em></span> be further developed to
      implement all of DeltaV, but it's hard to find motivation to do
      so—there are almost no DeltaV clients to interoperate
      with.</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.webdav.autoversioning"></a>Autoversioning</h2></div></div></div><p>While the Subversion client is not a full DeltaV client, nor
      the Subversion server a full DeltaV server, there's still a
      glimmer of WebDAV interoperability to be happy about:  it's
      called autoversioning.</p><p>Autoversioning is an optional feature defined in the DeltaV
      standard.  A typical DeltaV server will reject an ignorant
      WebDAV client attempting to do a <code class="literal">PUT</code> to a
      file that's under version control.  To change a
      version-controlled file, the server expects a series proper
      versioning requests: something like
      <code class="literal">MKACTIVITY</code>, <code class="literal">CHECKOUT</code>,
      <code class="literal">PUT</code>, <code class="literal">CHECKIN</code>.  But if the
      DeltaV server supports autoversioning, then write-requests from
      basic WebDAV clients are accepted.  The server behaves as if the
      client had issued the proper series of versioning requests,
      performing a commit under the hood.  In other words, it allows a
      DeltaV server to interoperate with ordinary WebDAV
      clients that don't understand versioning.</p><p>Because so many operating systems already have integrated
      WebDAV clients, the use case for this feature borders on
      fantastical: imagine an office of ordinary users running
      Microsoft Windows or Mac OS.  Each user «<span class="quote">mounts</span>»
      the Subversion repository, which appears to be an ordinary
      network folder.  They use the shared folder as they always do:
      open files, edit them, save them.  Meanwhile, the server is
      automatically versioning everything.  Any administrator (or
      knowledgeable user) can still use a Subversion client to search
      history and retrieve older versions of data.</p><p>This scenario isn't fiction: it's real and it works, as of
      Subversion 1.2 and later.  To activate autoversioning in
      mod_dav_svn, use the <code class="literal">SVNAutoversioning</code>
      directive within the <code class="filename">httpd.conf</code> Location
      block, like so:</p><pre class="screen">
&lt;Location /repos&gt;
  DAV svn
  SVNPath /path/to/repository
  SVNAutoversioning on
&lt;/Location&gt;
</pre><p>When SVNAutoversioning is active, write requests from WebDAV
      clients result in automatic commits.  A generic log message is
      auto-generated and attached to each revision.</p><p>Before activating this feature, however, understand what
      you're getting into.  WebDAV clients tend to do
      <span class="emphasis"><em>many</em></span> write requests, resulting in a huge
      number of automatically committed revisions.  For example, when
      saving data, many clients will do a <code class="literal">PUT</code> of a
      0-byte file (as a way of reserving a name) followed by another
      <code class="literal">PUT</code> with the real filedata.  The single
      file-write results in two separate commits.  Also consider that
      many applications auto-save every few minutes, resulting in even
      more commits.</p><p>If you have a post-commit hook program that sends email, you
      may want to disable email generation either altogether, or on
      certain sections of the repository; it depends on whether you
      think the influx of emails will still prove to be valuable
      notifications or not.  Also, a smart post-commit hook program
      can distinguish between a transaction created via autoversioning
      and one created through a normal <span><strong class="command">svn commit</strong></span>.
      The trick is to look for a revision property
      named <code class="literal">svn:autoversioned</code>.  If present, the
      commit was made by a generic WebDAV client.</p><p>Another feature that may be a useful complement
      for <code class="literal">SVNAutoversioning</code> comes from
      Apache's <code class="literal">mod_mime</code> module.  If a generic
      WebDAV client adds a new file to the repository, there's no
      opportunity for the user to set the
      the <code class="literal">svn:mime-type</code> property.  This might cause
      the file to appear as «<span class="quote">generic</span>» icon when viewed
      within a WebDAV shared folder, not having an association with
      any application.  One remedy is to have a sysadmin (or other
      Subversion-knowledgable person) check out a working copy and
      manually set the <code class="literal">svn:mime-type</code> property on
      necessary files. But there's potentially no end to such cleanup
      tasks.  Instead, you can use
      the <code class="literal">ModMimeUsePathInfo</code> directive in
      your Subversion <code class="literal">&lt;Location&gt;</code>
      block:</p><pre class="screen">
&lt;Location /repos&gt;
  DAV svn
  SVNPath /path/to/repository
  SVNAutoversioning on

  ModMimeUsePathInfo on

&lt;/Location&gt;
</pre><p>This directive allows <code class="literal">mod_mime</code> to attempt
      automatic deduction of the mime-type on new files that enter the
      repository via autoversioning.  The module looks at the file's
      named extension and possibly the contents as well; if the file
      matches some common patterns, then the the
      file's <code class="literal">svn;mime-type</code> property will be set
      automatically.</p></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.webdav.clients"></a>Client Interoperability</h2></div></div></div><p>All WebDAV clients fall into one of three
      categories—standalone applications, file-explorer
      extensions, or filesystem implementations.  These categories
      broadly define the types of WebDAV functionality available to
      users.  <a href="#svn.webdav.clients.tbl-1" title="Tabella&#xA0;B.1.&#xA0;Common WebDAV Clients">Tabella B.1, «Common WebDAV Clients»</a> gives our
      categorization and a quick description of some common pieces of
      WebDAV-enabled software.  More details about these software
      offerings, as well as their general category, can be found in
      the sections that follow.</p><div class="table"><a id="svn.webdav.clients.tbl-1"></a><p class="title"><b>Tabella B.1. Common WebDAV Clients</b></p><div class="table-contents"><table summary="Common WebDAV Clients" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Software</th><th>Category</th><th>Description</th></tr></thead><tbody><tr><td>Adobe Photoshop</td><td>Standalone WebDAV applications</td><td>Image editing software, allowing direct opening
              from, and writing to, WebDAV URLs</td></tr><tr><td>Cadaver</td><td>Standalone WebDAV applications</td><td>Command-line WebDAV client supporting file
              transfer, tree, and locking operations</td></tr><tr><td>DAV Explorer</td><td>Standalone WebDAV applications</td><td>GUI tool for exploring WebDAV shares</td></tr><tr><td>davfs2</td><td>WebDAV filesystem implementation</td><td>Linux file system driver that allows you to mount a
              WebDAV share</td></tr><tr><td>GNOME Nautilus</td><td>File-explorer WebDAV extensions</td><td>GUI file explorer able to perform tree
              operations on a WebDAV share</td></tr><tr><td>KDE Konqueror</td><td>File-explorer WebDAV extensions</td><td>GUI file explorer able to perform tree
              operations on a WebDAV share</td></tr><tr><td>Mac OS X</td><td>WebDAV filesystem implementation</td><td>Operating system with built-in support for mounting
              WebDAV shares locally</td></tr><tr><td>Macromedia Dreamweaver</td><td>Standalone WebDAV applications</td><td>Web production software able to directly read from
              and write to WebDAV URLs</td></tr><tr><td>Microsoft Office</td><td>Standalone WebDAV applications</td><td>Office productivity suite with several components
              able to directly read from and write to WebDAV
              URLs</td></tr><tr><td>Microsoft Web Folders</td><td>File-explorer WebDAV extensions</td><td>GUI file explorer program able to perform tree
              operations on a WebDAV share</td></tr><tr><td>Novell NetDrive</td><td>WebDAV filesystem implementation</td><td>Drive-mapping program for assigning Windows drive
              letters to a mounted remote WebDAV share</td></tr><tr><td>SRT WebDrive</td><td>WebDAV filesystem implementation</td><td>File transfer software which, among other things,
              allows the assignment of Windows drive letters to a
              mounted remote WebDAV share</td></tr></tbody></table></div></div><br class="table-break" /><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.webdav.clients.standalone"></a>Standalone WebDAV applications</h3></div></div></div><p>A WebDAV application is a program which contains built-in
        functionality for speaking WebDAV protocols with a WebDAV
        server.  We'll cover some of the most popular programs with
        this kind of WebDAV support.</p><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.webdav.clients.standalone.windows"></a>Microsoft Office, Dreamweaver, Photoshop</h4></div></div></div><p>On Windows, there are several well-known applications
          that contain integrated WebDAV client functionality, such as
          Microsoft's Office,
          <sup>[<a id="id4778490" href="#ftn.id4778490">52</a>]</sup>
          Adobe's Photoshop, and Macromedia's Dreamweaver programs.
          They're able to directly open and save to URLs, and tend to
          make heavy use of WebDAV locks when editing a file.</p><p>Note that while many of these programs also exist for
          the Mac OS X, they do not appear to support WebDAV directly
          on that platform.  In fact, on Mac OS X, the
          <span class="guimenu">File-&gt;Open</span> dialog box doesn't allow
          one to type a path or URL at all.  It's likely that the
          WebDAV features were deliberately left out of Macintosh
          versions of these programs, since OS X already provides such
          excellent low-level filesystem support for WebDAV.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.webdav.clients.standalone.free"></a>Cadaver, DAV Explorer</h4></div></div></div><p>Cadaver is a bare-bones Unix commandline program for
          browsing and changing WebDAV shares.  Like the Subversion
          client, it uses the neon HTTP library—not surprisingly,
          both neon and cadaver are written by the same author.  Cadaver
          is free software (GPL license) and is available at <a href="http://www.webdav.org/cadaver/" target="_top">http://www.webdav.org/cadaver/</a>.</p><p>Using cadaver is similar to using a commandline FTP
          program, and thus it's extremely useful for basic WebDAV
          debugging.  It can be used to upload or download files in a
          pinch, and also to examine properties, copy, move, lock or
          unlock files:</p><pre class="screen">
$ cadaver http://host/repos
dav:/repos/&gt; ls
Listing collection `/repos/': succeeded.
Coll: &gt; foobar                                 0  May 10 16:19
      &gt; playwright.el                       2864  May  4 16:18
      &gt; proofbypoem.txt                     1461  May  5 15:09
      &gt; westcoast.jpg                      66737  May  5 15:09

dav:/repos/&gt; put README
Uploading README to `/repos/README':
Progress: [=============================&gt;] 100.0% of 357 bytes succeeded.

dav:/repos/&gt; get proofbypoem.txt
Downloading `/repos/proofbypoem.txt' to proofbypoem.txt:
Progress: [=============================&gt;] 100.0% of 1461 bytes succeeded.
</pre><p>DAV Explorer is another standalone WebDAV client, written
          in Java.  It's under a free Apache-like license and is
          available at <a href="http://www.ics.uci.edu/~webdav/" target="_top">http://www.ics.uci.edu/~webdav/</a>.
          DAV Explorer does everything cadaver does, but has the
          advantages of being portable and being more user-friendly GUI
          application.  It's also one of the first clients to support
          the new WebDAV Access Control Protocol (RFC 3744).</p><p>Of course, DAV Explorer's ACL support is useless in this
          case, since mod_dav_svn doesn't support it.  The fact that
          both Cadaver and DAV Explorer support some limited DeltaV
          commands isn't particularly useful either, since they don't
          allow <code class="literal">MKACTIVITY</code> requests.  But it's not
          relevant anyway; we're assuming all of these clients are
          operating against an autoversioning repository.</p></div></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.webdav.clients.file-explorer-extensions"></a>File-explorer WebDAV extensions</h3></div></div></div><p>Some popular file explorer GUI programs support WebDAV
        extensions which allow a user to browse a DAV share as if it
        was just another directory on the local computer, and allowing
        basic tree editing operations on the items in that share.  For
        example, Windows Explorer is able to browse a WebDAV server as
        a «<span class="quote">network place</span>».  Users can drag files to and
        from the desktop, or can rename, copy, or delete files in the
        usual way.  But because it's only a feature of the
        file-explorer, the DAV share isn't visible to ordinary
        applications.  All DAV interaction must happen through the
        explorer interface.</p><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.webdav.clients.file-explorer-extensions.windows"></a>Microsoft Web Folders</h4></div></div></div><p>Microsoft was one of the original backers of the WebDAV
          specification, and first started shipping a client in Windows
          98, known as «<span class="quote">Web Folders</span>».  This client was also
          shipped in Windows NT4 and 2000.</p><p>The original Web Folders client was an extension to
          Explorer, the main GUI program used to browse filesystems.  It
          works well enough.  In Windows 98, the feature might need to
          be explicitly installed if Web Folders aren't already visible
          inside «<span class="quote">My Computer</span>».  In Windows 2000, simply
          add a new «<span class="quote">network place</span>», enter the URL, and the
          WebDAV share will pop up for browsing.</p><p>With the release of Windows XP, Microsoft started shipping
          a new implementation of Web Folders, known as the «<span class="quote">WebDAV
          mini-redirector</span>».  The new implementation is a
          filesystem-level client, allowing WebDAV shares to be mounted
          as drive letters.  Unfortunately, this implementation is
          incredibly buggy.  The client usually tries to convert http
          URLs (<code class="literal">http://host/repos</code>) into UNC share
          notation (<code class="literal">\\host\repos</code>); it also often
          tries to use Windows Domain authentication to respond to
          basic-auth HTTP challenges, sending usernames as
          <code class="literal">HOST\username</code>.  These interoperability
          problems are severe and documented in numerous places around
          the web, to the frustration of many users.  Even Greg Stein,
          the original author of Apache's WebDAV module, recommends
          against trying to use XP Web Folders against an Apache
          server.</p><p>It turns out that the original
          «<span class="quote">Explorer-only</span>» Web Folders implementation isn't
          dead in XP, it's just buried.  It's still possible to find it
          by using this technique:</p><div class="orderedlist"><ol type="1"><li><p>Go to 'Network Places'.</p></li><li><p>Add a new network place.</p></li><li><p>When prompted, enter the URL of the repository, but
              <span class="emphasis"><em>include a port number</em></span> in the URL.
              For example, <code class="literal">http://host/repos</code> would be
              entered as <code class="literal">http://host:80/repos</code> instead.
            </p></li><li><p>Respond to any authentication prompts.</p></li></ol></div><p>There are a number of other rumored workarounds to the
          problems, but none of them seem to work on all versions and
          patchlevels of Windows XP.  In our tests, only the previous
          algorithm seems to work consistently on every system.  The
          general consensus of the WebDAV community is that you should
          avoid the new Web Folders implementation and use the old one
          instead, and that if you need real a real filesystem-level
          client for Windows XP, then use a third-party program like
          WebDrive or NetDrive.</p><p>A final tip: if you're attempting to use XP Web Folders,
          make sure you have the absolute latest version from
          Microsoft.  For example, Microsoft released a bug-fixed
          version in January 2005, available at
          <a href="http://support.microsoft.com/?kbid=892211" target="_top">http://support.microsoft.com/?kbid=892211</a>.
          In particular, this release is known to fix a bug whereby
          browsing a DAV share shows an unexpected infinite
          recursion.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.webdav.clients.file-explorer-extensions.linux-de"></a>Nautilus, Konqueror</h4></div></div></div><p>Nautilus is the official file manager/browser for the
          GNOME desktop (<a href="http://www.gnome.org" target="_top">http://www.gnome.org</a>), and
          Konqueror is the manager/browser for KDE desktop (<a href="http://www.kde.org" target="_top">http://www.kde.org</a>).  Both of these applications have
          an explorer-level WebDAV client built-in, and operate just
          fine against an autoversioning repository.</p><p>In GNOME's Nautilus, from the <span class="guimenu">File
          menu</span>, select <span class="guimenuitem">Open
          location</span> and enter the URL.  The repository
          should then be displayed like any other filesystem.</p><p>In KDE's Konqueror, you need to use the
          <code class="literal">webdav://</code> scheme when entering the URL in
          the location bar.  If you enter an <code class="literal">http://</code>
          URL, Konqueror will behave like an ordinary web browser.
          You'll likely see the generic HTML directory listing produced
          by mod_dav_svn.  By entering
          <code class="literal">webdav://host/repos</code> instead of
          <code class="literal">http://host/repos</code>, Konqueror becomes a
          WebDAV client and displays the repository as a
          filesystem.</p></div></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.webdav.clients.fs-impl"></a>WebDAV filesystem implementation</h3></div></div></div><p>The WebDAV filesystem implementation is arguably the best
        sort of WebDAV client.  It's implemented as a low-level
        filesystem module, typically within the operating system's
        kernel.  This means that the DAV share is mounted like any
        other network filesystem, similar to mounting an NFS share on
        Unix, or attaching an SMB share as drive-letter in Windows.
        As a result, this sort of client provides completely
        transparent read/write WebDAV access to all programs.
        Applications aren't even aware that WebDAV requests are
        happening.</p><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.webdav.clients.fs-impl.windows"></a>WebDrive, NetDrive</h4></div></div></div><p>Both WebDrive and NetDrive are excellent commercial
          products which allows a WebDAV share to be attached as drive
          letters in Windows.  We've had nothing but success with
          these products.  At the time of writing, WebDrive can be
          purchased from South River Technologies (<a href="http://www.southrivertech.com" target="_top">http://www.southrivertech.com</a>).  NetDrive ships with
          Netware, is free of charge, and can be found by searching
          the web for «<span class="quote">netdrive.exe</span>».  Though it is
          freely available online, users are required to have a
          Netware license.  (If any of that sounds odd to you, you're
          not alone.  See this page on Novell's website: <a href="http://www.novell.com/coolsolutions/qna/999.html" target="_top">http://www.novell.com/coolsolutions/qna/999.html</a>)</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.webdav.clients.fs-impl.macosx"></a>Mac OS X</h4></div></div></div><p>Apple's OS X operating system has an integrated
          filesystem-level WebDAV client.  From the Finder, select the
          <span class="guimenuitem">Connect to Server</span> item from the
          <span class="guimenu">Go menu</span>.  Enter a WebDAV URL, and it
          appears as a disk on the desktop, just like any other mounted
          volume.<sup>[<a id="id4778974" href="#ftn.id4778974">53</a>]</sup>.</p><p>Note that if your mod_dav_svn is older than version 1.2,
          OS X will refuse to mount the share as read-write; it will
          appear as read-only.  This is because the OS X insists on
          locking support for read-write shares, and the ability to lock
          files first appeared in Subversion 1.2.</p><p>One more word of warning: OS X's WebDAV client can
          sometimes be overly sensitive to HTTP redirects.  If OS X is
          unable to mount the repository at all, you may need to enable
          the BrowserMatch directive in the Apache server's
          <code class="filename">httpd.conf</code>:</p><pre class="screen">
BrowserMatch "^WebDAVFS/1.[012]" redirect-carefully
</pre></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.webdav.clients.fs-impl.linux"></a>Linux davfs2</h4></div></div></div><p>Linux davfs2 is a filesystem module for the Linux kernel,
          whose development is located at <a href="http://dav.sourceforge.net/" target="_top">http://dav.sourceforge.net/</a>.  Once installed, a WebDAV
          network share can be mounted with the usual Linux mount
          command:</p><pre class="screen">
$ mount.davfs http://host/repos /mnt/dav
</pre></div></div></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.id4778490" href="#id4778490">52</a>] </sup>WebDAV support was removed from Microsoft Access for
              some reason, but exists in the rest of the Office
              suite.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4778974" href="#id4778974">53</a>] </sup>From the Darwin terminal, one can also
          run <code class="literal">mount -t webdav URL
          /mountpoint</code></p></div></div></div><div class="appendix" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title"><a id="svn.3rdparty"></a>Appendice C. Third Party Tools</h2></div></div></div><div class="simplesect" lang="it" xml:lang="it"><div class="titlepage"></div><p>Subversion's modular design (covered in <a href="#svn.developer.layerlib" title="Layered Library Design">la sezione chiamata «Layered Library Design»</a>) and the availability of
      language bindings (as described in <a href="#svn.developer.usingapi.otherlangs" title="Using Languages Other than C and C++">la sezione chiamata «Using Languages Other than C and C++»</a>) make it a likely
      candidate for use as an extension or backend to other pieces of
      software.  For a listing of many third-party tools that are using
      Subversion functionality under-the-hood, check out the Links page on the
      Subversion website (<a href="http://subversion.tigris.org/project_links.html" target="_top">http://subversion.tigris.org/project_links.html</a>).</p></div></div><div class="appendix" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title"><a id="svn.copyright"></a>Appendice D. Copyright</h2></div></div></div><div class="simplesect" lang="it" xml:lang="it"><div class="titlepage"></div><pre class="programlisting">

Copyright (c) 2002-2005
Ben Collins-Sussman, Brian W. Fitzpatrick, C. Michael Pilato.  

Questo lavoro è licenziato sotto la licenza Creative Commons Attribution.
Per vedere una copia di questa licenza consultare il sito
http://creativecommons.org/licenses/by/2.0/ od inviate una lettera
a 
Creative Commons, 559 Nathan Abbott Way, Stanford, California 94305,
USA.

Nel seguito viene fornita una sintesi della licenza, seguita dal testo legale integrale.

--------------------------------------------------------------------

Siete liberi di:

    * copiare, distribuire, visualizzare e svolgere del lavoro
    * realizzare dei lavori derivati
    * fare uso commerciale del lavoro

Sotto le seguenti condizioni:
	
Attribuzione. Dovete fornire l'attribuzione all'autore originale.

    * In ogni caso di riuso o distribuzione, dovete chiarire agli altri i termini
      di licenza di questo lavoro.

    * Qualsiasi di queste condzioni possono essere rilassate se ottenete il permesso
      dell'autore

Il vostro giusto utilizzo e gli altri diritti non sono toccati in alcun modo da quanto
suddetto

Quanto sopra è una sintesi del seguente testo integrale della licenza.

====================================================================

Creative Commons Legal Code
Attribution 2.0

CREATIVE COMMONS CORPORATION IS NOT A LAW FIRM AND DOES NOT PROVIDE
LEGAL SERVICES. DISTRIBUTION OF THIS LICENSE DOES NOT CREATE AN
ATTORNEY-CLIENT RELATIONSHIP. CREATIVE COMMONS PROVIDES THIS
INFORMATION ON AN "AS-IS" BASIS. CREATIVE COMMONS MAKES NO WARRANTIES
REGARDING THE INFORMATION PROVIDED, AND DISCLAIMS LIABILITY FOR
DAMAGES RESULTING FROM ITS USE.

License

THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS
CREATIVE COMMONS PUBLIC LICENSE ("CCPL" OR "LICENSE"). THE WORK IS
PROTECTED BY COPYRIGHT AND/OR OTHER APPLICABLE LAW. ANY USE OF THE
WORK OTHER THAN AS AUTHORIZED UNDER THIS LICENSE OR COPYRIGHT LAW IS
PROHIBITED.

BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND
AGREE TO BE BOUND BY THE TERMS OF THIS LICENSE. THE LICENSOR GRANTS
YOU THE RIGHTS CONTAINED HERE IN CONSIDERATION OF YOUR ACCEPTANCE OF
SUCH TERMS AND CONDITIONS.

1. Definitions

   a. "Collective Work" means a work, such as a periodical issue,
      anthology or encyclopedia, in which the Work in its entirety in
      unmodified form, along with a number of other contributions,
      constituting separate and independent works in themselves, are
      assembled into a collective whole. A work that constitutes a
      Collective Work will not be considered a Derivative Work (as
      defined below) for the purposes of this License.

   b. "Derivative Work" means a work based upon the Work or upon the
      Work and other pre-existing works, such as a translation,
      musical arrangement, dramatization, fictionalization, motion
      picture version, sound recording, art reproduction, abridgment,
      condensation, or any other form in which the Work may be recast,
      transformed, or adapted, except that a work that constitutes a
      Collective Work will not be considered a Derivative Work for the
      purpose of this License. For the avoidance of doubt, where the
      Work is a musical composition or sound recording, the
      synchronization of the Work in timed-relation with a moving
      image ("synching") will be considered a Derivative Work for the
      purpose of this License.

   c. "Licensor" means the individual or entity that offers the Work
      under the terms of this License.

   d. "Original Author" means the individual or entity who created the Work.

   e. "Work" means the copyrightable work of authorship offered under
      the terms of this License.

   f. "You" means an individual or entity exercising rights under this
      License who has not previously violated the terms of this
      License with respect to the Work, or who has received express
      permission from the Licensor to exercise rights under this
      License despite a previous violation.

2. Fair Use Rights. Nothing in this license is intended to reduce,
   limit, or restrict any rights arising from fair use, first sale or
   other limitations on the exclusive rights of the copyright owner
   under copyright law or other applicable laws.

3. License Grant. Subject to the terms and conditions of this License,
   Licensor hereby grants You a worldwide, royalty-free,
   non-exclusive, perpetual (for the duration of the applicable
   copyright) license to exercise the rights in the Work as stated
   below:

   a. to reproduce the Work, to incorporate the Work into one or more
      Collective Works, and to reproduce the Work as incorporated in
      the Collective Works;

   b. to create and reproduce Derivative Works;

   c. to distribute copies or phonorecords of, display publicly,
      perform publicly, and perform publicly by means of a digital
      audio transmission the Work including as incorporated in
      Collective Works;

   d. to distribute copies or phonorecords of, display publicly,
      perform publicly, and perform publicly by means of a digital
      audio transmission Derivative Works.

   e.

      For the avoidance of doubt, where the work is a musical composition:

         i. Performance Royalties Under Blanket Licenses. Licensor
            waives the exclusive right to collect, whether
            individually or via a performance rights society
            (e.g. ASCAP, BMI, SESAC), royalties for the public
            performance or public digital performance (e.g. webcast)
            of the Work.

        ii. Mechanical Rights and Statutory Royalties. Licensor waives
            the exclusive right to collect, whether individually or
            via a music rights agency or designated agent (e.g. Harry
            Fox Agency), royalties for any phonorecord You create from
            the Work ("cover version") and distribute, subject to the
            compulsory license created by 17 USC Section 115 of the US
            Copyright Act (or the equivalent in other jurisdictions).

   f. Webcasting Rights and Statutory Royalties. For the avoidance of
      doubt, where the Work is a sound recording, Licensor waives the
      exclusive right to collect, whether individually or via a
      performance-rights society (e.g. SoundExchange), royalties for
      the public digital performance (e.g. webcast) of the Work,
      subject to the compulsory license created by 17 USC Section 114
      of the US Copyright Act (or the equivalent in other
      jurisdictions).

The above rights may be exercised in all media and formats whether now
known or hereafter devised. The above rights include the right to make
such modifications as are technically necessary to exercise the rights
in other media and formats. All rights not expressly granted by
Licensor are hereby reserved.

4. Restrictions.The license granted in Section 3 above is expressly
   made subject to and limited by the following restrictions:

   a. You may distribute, publicly display, publicly perform, or
      publicly digitally perform the Work only under the terms of this
      License, and You must include a copy of, or the Uniform Resource
      Identifier for, this License with every copy or phonorecord of
      the Work You distribute, publicly display, publicly perform, or
      publicly digitally perform. You may not offer or impose any
      terms on the Work that alter or restrict the terms of this
      License or the recipients' exercise of the rights granted
      hereunder. You may not sublicense the Work. You must keep intact
      all notices that refer to this License and to the disclaimer of
      warranties. You may not distribute, publicly display, publicly
      perform, or publicly digitally perform the Work with any
      technological measures that control access or use of the Work in
      a manner inconsistent with the terms of this License
      Agreement. The above applies to the Work as incorporated in a
      Collective Work, but this does not require the Collective Work
      apart from the Work itself to be made subject to the terms of
      this License. If You create a Collective Work, upon notice from
      any Licensor You must, to the extent practicable, remove from
      the Collective Work any reference to such Licensor or the
      Original Author, as requested. If You create a Derivative Work,
      upon notice from any Licensor You must, to the extent
      practicable, remove from the Derivative Work any reference to
      such Licensor or the Original Author, as requested.

   b. If you distribute, publicly display, publicly perform, or
      publicly digitally perform the Work or any Derivative Works or
      Collective Works, You must keep intact all copyright notices for
      the Work and give the Original Author credit reasonable to the
      medium or means You are utilizing by conveying the name (or
      pseudonym if applicable) of the Original Author if supplied; the
      title of the Work if supplied; to the extent reasonably
      practicable, the Uniform Resource Identifier, if any, that
      Licensor specifies to be associated with the Work, unless such
      URI does not refer to the copyright notice or licensing
      information for the Work; and in the case of a Derivative Work,
      a credit identifying the use of the Work in the Derivative Work
      (e.g., "French translation of the Work by Original Author," or
      "Screenplay based on original Work by Original Author"). Such
      credit may be implemented in any reasonable manner; provided,
      however, that in the case of a Derivative Work or Collective
      Work, at a minimum such credit will appear where any other
      comparable authorship credit appears and in a manner at least as
      prominent as such other comparable authorship credit.

5. Representations, Warranties and Disclaimer

UNLESS OTHERWISE MUTUALLY AGREED TO BY THE PARTIES IN WRITING,
LICENSOR OFFERS THE WORK AS-IS AND MAKES NO REPRESENTATIONS OR
WARRANTIES OF ANY KIND CONCERNING THE WORK, EXPRESS, IMPLIED,
STATUTORY OR OTHERWISE, INCLUDING, WITHOUT LIMITATION, WARRANTIES OF
TITLE, MERCHANTIBILITY, FITNESS FOR A PARTICULAR PURPOSE,
NONINFRINGEMENT, OR THE ABSENCE OF LATENT OR OTHER DEFECTS, ACCURACY,
OR THE PRESENCE OF ABSENCE OF ERRORS, WHETHER OR NOT
DISCOVERABLE. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OF IMPLIED
WARRANTIES, SO SUCH EXCLUSION MAY NOT APPLY TO YOU.

6. Limitation on Liability. EXCEPT TO THE EXTENT REQUIRED BY
   APPLICABLE LAW, IN NO EVENT WILL LICENSOR BE LIABLE TO YOU ON ANY
   LEGAL THEORY FOR ANY SPECIAL, INCIDENTAL, CONSEQUENTIAL, PUNITIVE
   OR EXEMPLARY DAMAGES ARISING OUT OF THIS LICENSE OR THE USE OF THE
   WORK, EVEN IF LICENSOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
   DAMAGES.

7. Termination

   a. This License and the rights granted hereunder will terminate
      automatically upon any breach by You of the terms of this
      License. Individuals or entities who have received Derivative
      Works or Collective Works from You under this License, however,
      will not have their licenses terminated provided such
      individuals or entities remain in full compliance with those
      licenses. Sections 1, 2, 5, 6, 7, and 8 will survive any
      termination of this License.

   b. Subject to the above terms and conditions, the license granted
      here is perpetual (for the duration of the applicable copyright
      in the Work). Notwithstanding the above, Licensor reserves the
      right to release the Work under different license terms or to
      stop distributing the Work at any time; provided, however that
      any such election will not serve to withdraw this License (or
      any other license that has been, or is required to be, granted
      under the terms of this License), and this License will continue
      in full force and effect unless terminated as stated above.

8. Miscellaneous

   a. Each time You distribute or publicly digitally perform the Work
      or a Collective Work, the Licensor offers to the recipient a
      license to the Work on the same terms and conditions as the
      license granted to You under this License.

   b. Each time You distribute or publicly digitally perform a
      Derivative Work, Licensor offers to the recipient a license to
      the original Work on the same terms and conditions as the
      license granted to You under this License.

   c. If any provision of this License is invalid or unenforceable
      under applicable law, it shall not affect the validity or
      enforceability of the remainder of the terms of this License,
      and without further action by the parties to this agreement,
      such provision shall be reformed to the minimum extent necessary
      to make such provision valid and enforceable.

   d. No term or provision of this License shall be deemed waived and
      no breach consented to unless such waiver or consent shall be in
      writing and signed by the party to be charged with such waiver
      or consent.

   e. This License constitutes the entire agreement between the
      parties with respect to the Work licensed here. There are no
      understandings, agreements or representations with respect to
      the Work not specified here. Licensor shall not be bound by any
      additional provisions that may appear in any communication from
      You. This License may not be modified without the mutual written
      agreement of the Licensor and You.

Creative Commons is not a party to this License, and makes no warranty
whatsoever in connection with the Work. Creative Commons will not be
liable to You or any party on any legal theory for any damages
whatsoever, including without limitation any general, special,
incidental or consequential damages arising in connection to this
license. Notwithstanding the foregoing two (2) sentences, if Creative
Commons has expressly identified itself as the Licensor hereunder, it
shall have all rights and obligations of Licensor.

Except for the limited purpose of indicating to the public that the
Work is licensed under the CCPL, neither party will use the trademark
"Creative Commons" or any related trademark or logo of Creative
Commons without the prior written consent of Creative Commons. Any
permitted use will be in compliance with Creative Commons'
then-current trademark usage guidelines, as may be published on its
website or otherwise made available upon request from time to time.

Creative Commons may be contacted at http://creativecommons.org/.

====================================================================
</pre></div></div></div></body></html>
