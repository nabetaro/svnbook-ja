<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Properties</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.70.1" /><link rel="start" href="index.html" title="Controllo di Versione con Subversion" /><link rel="up" href="svn.advanced.html" title="Capitolo 7. Advanced Topics" /><link rel="prev" href="svn.advanced.html" title="Capitolo 7. Advanced Topics" /><link rel="next" href="svn.advanced.locking.html" title="Locking" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Properties</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="svn.advanced.html">Indietro</a> </td><th width="60%" align="center">Capitolo 7. Advanced Topics</th><td width="20%" align="right"> <a accesskey="n" href="svn.advanced.locking.html">Avanti</a></td></tr></table><hr /></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.advanced.props"></a>Properties</h2></div></div></div><p>We've already covered in detail how Subversion stores and
      retrieves various versions of files and directories in its
      repository.  Whole chapters have been devoted to this most
      fundamental piece of functionality provided by the tool.  And
      if the versioning support stopped there, Subversion would still
      be complete from a version control perspective.  But it
      doesn't stop there.</p><p>In addition to versioning your directories and files,
      Subversion provides interfaces for adding, modifying, and
      removing versioned metadata on each of your versioned
      directories and files.  We refer to this metadata as
      <em class="firstterm">properties</em>, and they can be thought of as
      two-column tables that map property names to arbitrary values
      attached to each item in your working copy.  Generally speaking,
      the names and values of the properties can be whatever you want
      them to be, with the constraint that the names must be
      human-readable text.  And the best part about these properties
      is that they, too, are versioned, just like the textual contents
      of your files.  You can modify, commit, and revert property
      changes as easily as committing textual changes.  And you
      receive other people's property changes as you update your
      working copy.</p><div class="sidebar"><p class="title"><b>Other Properties in Subversion</b></p><p>Properties show up elsewhere in Subversion, too.  Just as
        files and directories may have arbitrary property names and
        values attached to them, each revision as a whole may have
        arbitrary properties attached to it.  The same constraints
        apply—human-readable, text names and anything-you-want,
        binary values—except that revision properties are not
        versioned.  See <a href="svn.reposadmin.html#svn.reposadmin.basics.revprops" title="Unversioned Properties">la sezione chiamata «Unversioned Properties»</a> for more
        information on these unversioned properties.</p></div><p>In this section, we will examine the utility—both to
      users of Subversion, and to Subversion itself—of property
      support.  You'll learn about the property-related
      <span><strong class="command">svn</strong></span> subcommands, and how property
      modifications affect your normal Subversion workflow.
      Hopefully, you'll be convinced that Subversion properties can
      enhance your version control experience.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.props.why"></a>Why Properties?</h3></div></div></div><p>Properties can be very useful additions to your working
        copy.  In fact, Subversion itself uses properties to house
        special information, and as a way to denote that certain
        special processing might be needed.  Likewise, you can use
        properties for your own purposes.  Of course, anything you can
        do with properties you could also do using regular versioned
        files, but consider the following example of Subversion
        property use.</p><p>Say you wish to design a website that houses many digital
        photos, and displays them with captions and a datestamp.  Now,
        your set of photos is constantly changing, so you'd like to
        have as much of this site automated as possible.  These photos
        can be quite large, so as is common with sites of this nature,
        you want to provide smaller thumbnail images to your site
        visitors.  You can do this with traditional files.  That is,
        you can have your <code class="filename">image123.jpg</code> and an
        <code class="filename">image123-thumbnail.jpg</code> side-by-side in a
        directory.  Or if you want to keep the filenames the same, you
        might have your thumbnails in a different directory, like
        <code class="filename">thumbnails/image123.jpg</code>.  You can also
        store your captions and datestamps in a similar fashion, again
        separated from the original image file.  Soon, your tree of
        files is a mess, and grows in multiples with each new photo
        added to the site.</p><p>Now consider the same setup using Subversion's file
        properties.  Imagine having a single image file,
        <code class="filename">image123.jpg</code>, and then properties set on
        that file named <code class="literal">caption</code>,
        <code class="literal">datestamp</code>, and even
        <code class="literal">thumbnail</code>.  Now your working copy directory
        looks much more manageable—in fact, it looks like there
        are nothing but image files in it.  But your automation
        scripts know better.  They know that they can use
        <span><strong class="command">svn</strong></span> (or better yet, they can use the
        Subversion language bindings—see <a href="svn.developer.usingapi.html#svn.developer.usingapi.otherlangs" title="Using Languages Other than C and C++">la sezione chiamata «Using Languages Other than C and C++»</a>) to dig out the extra
        information that your site needs to display without having to
        read an index file or play path manipulation games.</p><p>How (and if) you use Subversion properties is up to you.
        As we mentioned, Subversion has it own uses for properties,
        which we'll discuss a little later in this chapter.  But
        first, let's discuss how to manipulate properties using the
        <span><strong class="command">svn</strong></span> program.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.props.manip"></a>Manipulating Properties</h3></div></div></div><p>The <span><strong class="command">svn</strong></span> command affords a few ways to
        add or modify file and directory properties.  For properties
        with short, human-readable values, perhaps the simplest way to
        add a new property is to specify the property name and value
        on the command-line of the <span><strong class="command">propset</strong></span>
        subcommand.</p><pre class="screen">
$ svn propset copyright '(c) 2003 Red-Bean Software' calc/button.c
property 'copyright' set on 'calc/button.c'
$
</pre><p>But we've been touting the flexibility that Subversion
        offers for your property values.  And if you are planning to
        have a multi-line textual, or even binary, property value, you
        probably do not want to supply that value on the command-line.
        So the <span><strong class="command">propset</strong></span> subcommand takes a
        <code class="option">--file</code> (<code class="option">-F</code>) option for
        specifying the name of
        a file which contains the new property value.</p><pre class="screen">
$ svn propset license -F /path/to/LICENSE calc/button.c
property 'license' set on 'calc/button.c'
$
</pre><p>There are some restrictions on the names you can use for
        properties.  A property name must start with a letter, a colon
        (<code class="literal">:</code>), or an underscore
        (<code class="literal">_</code>); after that, you can also use digits,
        hyphens (<code class="literal">-</code>), and periods
        (<code class="literal">.</code>).
          <sup>[<a id="id4850503" href="#ftn.id4850503">33</a>]</sup>
      </p><p>In addition to the <span><strong class="command">propset</strong></span> command, the
        <span><strong class="command">svn</strong></span> program supplies the
        <span><strong class="command">propedit</strong></span> command.  This command uses the
        configured editor program (see <a href="svn.advanced.html#svn.advanced.confarea.opts.config" title="Config">la sezione chiamata «Config»</a>) to add or modify properties.
        When you run the command, <span><strong class="command">svn</strong></span> invokes your
        editor program on a temporary file that contains the current
        value of the property (or which is empty, if you are adding a
        new property).  Then, you just modify that value in your
        editor program until it represents the new value you wish to
        store for the property, save the temporary file, and then exit
        the editor program.  If Subversion detects that you've
        actually changed the existing value of the property, it will
        accept that as the new property value.  If you exit your
        editor without making any changes, no property modification
        will occur.</p><pre class="screen">
$ svn propedit copyright calc/button.c  ### exit the editor without changes
No changes to property 'copyright' on 'calc/button.c'
$
</pre><p>We should note that, as with other <span><strong class="command">svn</strong></span>
        subcommands, those related to properties can act on multiple
        paths at once.  This enables you to modify properties on whole
        sets of files with a single command.  For example, we could
        have done:</p><pre class="screen">
$ svn propset copyright '(c) 2002 Red-Bean Software' calc/*
property 'copyright' set on 'calc/Makefile'
property 'copyright' set on 'calc/button.c'
property 'copyright' set on 'calc/integer.c'
…
$
</pre><p>All of this property adding and editing isn't really very
        useful if you can't easily get the stored property value.  So
        the <span><strong class="command">svn</strong></span> program supplies two subcommands
        for displaying the names and values of properties stored on
        files and directories.  The <span><strong class="command">svn proplist</strong></span>
        command will list the names of properties that exist on a
        path.  Once you know the names of the properties on the node,
        you can request their values individually using <span><strong class="command">svn
        propget</strong></span>.  This command will, given a path (or set of
        paths) and a property name, print the value of the property to
        the standard output stream.</p><pre class="screen">
$ svn proplist calc/button.c
Properties on 'calc/button.c':
  copyright
  license
$ svn propget copyright calc/button.c
(c) 2003 Red-Bean Software
</pre><p>There's even a variation of the
        <span><strong class="command">proplist</strong></span> command that will list both the
        name and value of all of the properties.  Simply supply the
        <code class="option">--verbose</code> (<code class="option">-v</code>) option.</p><pre class="screen">
$ svn proplist --verbose calc/button.c
Properties on 'calc/button.c':
  copyright : (c) 2003 Red-Bean Software
  license : ================================================================
Copyright (c) 2003 Red-Bean Software.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions 
are met:

1. Redistributions of source code must retain the above copyright
notice, this list of conditions, and the recipe for Fitz's famous
red-beans-and-rice.
…
</pre><p>The last property-related subcommand is
        <span><strong class="command">propdel</strong></span>.  Since Subversion allows you to
        store properties with empty values, you can't remove a
        property altogether using <span><strong class="command">propedit</strong></span> or
        <span><strong class="command">propset</strong></span>.  For example, this command will
        <span class="emphasis"><em>not</em></span> yield the desired effect:</p><pre class="screen">
$ svn propset license '' calc/button.c
property 'license' set on 'calc/button.c'
$ svn proplist --verbose calc/button.c
Properties on 'calc/button.c':
  copyright : (c) 2003 Red-Bean Software
  license : 
$
</pre><p>You need to use the <span><strong class="command">propdel</strong></span> command to
        delete properties altogether.  The syntax is similar to the
        other property commands:</p><pre class="screen">
$ svn propdel license calc/button.c
property 'license' deleted from 'calc/button.c'.
$ svn proplist --verbose calc/button.c
Properties on 'calc/button.c':
  copyright : (c) 2003 Red-Bean Software
$
</pre><p>Now that you are familiar with all of the
        property-related <span><strong class="command">svn</strong></span> subcommands, let's see
        how property modifications affect the usual Subversion
        workflow.  As we mentioned earlier, file and directory
        properties are versioned, just like your file contents.  As a
        result, Subversion provides the same opportunities for
        merging—in cleanly or conflicting fashions—someone
        else's modifications into your own.</p><div class="sidebar"><p class="title"><b>Modifying Revision Properties</b></p><p>Remember those unversioned revision properties?  You can
          modify those, too, with the <span><strong class="command">svn</strong></span> program.
          Simply add the <code class="option">--revprop</code> command-line
          parameter, and specify the revision whose property you wish
          to modify.  Since revisions are global, you don't need to
          specify a path in this case as long as you are positioned in
          the working copy of the repository whose revision property
          you wish to modify.  For example, you might want to replace
          the commit log message of an existing revision.
          <sup>[<a id="id4850805" href="#ftn.id4850805">34</a>]</sup></p><pre class="screen">
$ svn propset svn:log '* button.c: Fix a compiler warning.' -r11 --revprop
property 'svn:log' set on repository revision '11'
$
</pre><p>Note that the ability to modify these unversioned
          properties must be explicitly added by the repository
          administrator (see <a href="svn.reposadmin.create.html#svn.reposadmin.create.hooks" title="Hook Scripts">la sezione chiamata «Hook Scripts»</a>).
          Since the properties aren't versioned, you run the risk of
          losing information if you aren't careful with your edits.
          The repository administrator can setup methods to protect
          against this loss, and by default, modification of
          unversioned properties is disabled.</p></div><p>And as with file contents, your property changes are local
        modifications, only made permanent when you commit them to the
        repository with <span><strong class="command">svn commit</strong></span>.  Your property
        changes can be easily unmade, too—the <span><strong class="command">svn
        revert</strong></span> command will restore your files and
        directories to their un-edited states, contents, properties,
        and all.  Also, you can receive interesting information about
        the state of your file and directory properties by using the
        <span><strong class="command">svn status</strong></span> and <span><strong class="command">svn diff</strong></span>
        commands.</p><pre class="screen">
$ svn status calc/button.c
 M     calc/button.c
$ svn diff calc/button.c
Property changes on: calc/button.c
___________________________________________________________________
Name: copyright
   + (c) 2003 Red-Bean Software

$
</pre><p>Notice how the <span><strong class="command">status</strong></span> subcommand
        displays <code class="literal">M</code> in the second column instead of
        the first.  That is because we have modified the properties on
        <code class="filename">calc/button.c</code>, but not modified its
        textual contents.  Had we changed both, we would have seen
        <code class="literal">M</code> in the first column, too (see <a href="svn.tour.cycle.html#svn.tour.cycle.examine.status" title="svn status">la sezione chiamata «<span><strong class="command">svn status</strong></span>»</a>).</p><div class="sidebar"><p class="title"><b>Property Conflicts</b></p><p>As with file contents, local property modifications can
          conflict with changes committed by someone else.  If you
          update your working copy directory and receive property
          changes on a versioned resource that clash with your own,
          Subversion will report that the resource is in a conflicted
          state.</p><pre class="screen">
% svn update calc
M  calc/Makefile.in
 C calc/button.c
Updated to revision 143.
$ 
</pre><p>Subversion will also create, in the same directory as
          the conflicted resource, a file with a
          <code class="filename">.prej</code> extension which contains the
          details of the conflict.  You should examine the contents of
          this file so you can decide how to resolve the conflict.
          Until the conflict is resolved, you will see a
          <code class="literal">C</code> in the second column of <span><strong class="command">svn
          status</strong></span> output for that resource, and attempts to
          commit your local modifications will fail.</p><pre class="screen">
$ svn status calc
 C     calc/button.c
?      calc/button.c.prej
$ cat calc/button.c.prej 
prop 'linecount': user set to '1256', but update set to '1301'.
$
</pre><p>To resolve property conflicts, simply ensure that the
          conflicting properties contain the values that they should,
          and then use the <span><strong class="command">svn resolved</strong></span> command to
          alert Subversion that you have manually resolved the
          problem.</p></div><p>You might also have noticed the non-standard way that
        Subversion currently displays property differences.  You can
        still run <span><strong class="command">svn diff</strong></span> and redirect the output
        to create a usable patch file.  The <span><strong class="command">patch</strong></span>
        program will ignore property patches—as a rule, it
        ignores any noise it can't understand.  This does
        unfortunately mean that to fully apply a patch generated by
        <span><strong class="command">svn diff</strong></span>, any property modifications will
        need to be applied by hand.</p><p>As you can see, the presence of property modifications has
        no outstanding effect on the typical Subversion workflow.
        Your general patterns of updating your working copy, checking
        the status of your files and directories, reporting on the
        modifications you have made, and committing those
        modifications to the repository are completely immune to the
        presence or absence of properties.  The <span><strong class="command">svn</strong></span>
        program has some additional subcommands for actually making
        property changes, but that is the only noticeable asymmetry.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.props.special"></a>Special Properties</h3></div></div></div><p>Subversion has no particular policy regarding
        properties—you can use them for any purpose.  Subversion
        asks only that you not use property names that begin with the
        prefix <code class="literal">svn:</code>.  That's the namespace that it
        sets aside for its own use.  In fact, Subversion defines
        certain properties that have magical effects on the files and
        directories to which they are attached.  In this section,
        we'll untangle the mystery, and describe how these special
        properties make your life just a little easier.</p><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.advanced.props.special.executable"></a><code class="literal">svn:executable</code></h4></div></div></div><p>The <code class="literal">svn:executable</code> property is used
          to control a versioned file's filesystem-level execute
          permission bit in a semi-automated way.  This property has
          no defined values—its mere presence indicates a desire
          that the execute permission bit be kept enabled by Subversion.
          Removing this property will restore full control of the
          execute bit back to the operating system.</p><p>On many operating systems, the ability to execute a file
          as a command is governed by the presence of an execute
          permission bit.  This bit usually defaults to being
          disabled, and must be explicitly enabled by the user for
          each file that needs it.  In a working copy, new files are
          being created all the time as new versions of existing files
          are received during an update.  This means that you might
          enable the execute bit on a file, then update your working
          copy, and if that file was changed as part of the update,
          its execute bit might get disabled.  So, Subversion provides
          the <code class="literal">svn:executable</code> property as a way to
          keep the execute bit enabled.</p><p>This property has no effect on filesystems that have no
          concept of an executable permission bit, such as FAT32 and
          NTFS.
          <sup>[<a id="id4851208" href="#ftn.id4851208">35</a>]</sup>
          Also, although it has no defined values, Subversion will force
          its value to <code class="literal">*</code> when setting this property.
          Finally, this property is valid only on files, not on
          directories.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.advanced.props.special.mime-type"></a><code class="literal">svn:mime-type</code></h4></div></div></div><p>The <code class="literal">svn:mime-type</code> property serves
          many purposes in Subversion.  Besides being a
          general-purpose storage location for a file's Multipurpose
          Internet Mail Extensions (MIME) classification, the value of
          this property determines some behavioral characteristics
          of Subversion itself.</p><p>For example, if a file's
          <code class="literal">svn:mime-type</code> property is set to a
          non-text MIME type (generally, something that doesn't begin
          with <code class="literal">text/</code>, though there are exceptions),
          Subversion will assume that the file contains
          binary—that is, not human-readable—data.  One of
          the benefits that Subversion typically provides is
          contextual, line-based merging of changes received from the
          server during an update into your working file.  But for
          files believed to contain binary data, there is no concept
          of a «<span class="quote">line</span>».  So, for those files, Subversion
          does not attempt to perform contextual merges during
          updates.  Instead, any time you have locally modified a
          binary working copy file that is also being updated, your
          file is renamed with a <code class="filename">.orig</code> extension,
          and then Subversion stores a new working copy file that
          contains the changes received during the update, but not
          your own local modifications, at the original filename.
          This behavior is really for the protection of the user
          against failed attempts at performing contextual merges on
          files that simply cannot be contextually merged.</p><p>Also, if the <code class="literal">svn:mime-type</code>
          property is set, then the Subversion Apache module will use
          its value to populate the <code class="literal">Content-type:</code>
          HTTP header when responding to GET requests.  This gives a
          crucial clue about how to display a file when perusing
          your repository with a web browser.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.advanced.props.special.ignore"></a><code class="literal">svn:ignore</code></h4></div></div></div><p>The <code class="literal">svn:ignore</code> property contains a
          list of file patterns which certain Subversion operations
          will ignore.  Perhaps the most commonly used special
          property, it works in conjunction with the
          <code class="literal">global-ignores</code> run-time configuration
          option (see <a href="svn.advanced.html#svn.advanced.confarea.opts.config" title="Config">la sezione chiamata «Config»</a>) to
          filter unversioned files and directories out of commands
          <span><strong class="command">svn status</strong></span>, <span><strong class="command">svn
          add</strong></span>, and <span><strong class="command">svn import</strong></span>.</p><p>The rationale behind the <code class="literal">svn:ignore</code>
          property is easily explained.  Subversion does not assume
          that every file or subdirectory in a working copy directory
          is intended for version control.  Resources must be
          explicitly placed under Subversion's management using the
          <span><strong class="command">svn add</strong></span> or <span><strong class="command">svn import</strong></span>
          commands.  As a result, there are often many resources in a
          working copy that are not versioned.</p><p>Now, the <span><strong class="command">svn status</strong></span> command displays
          as part of its output every unversioned file or subdirectory
          in a working copy that is not already filtered out by the
          <code class="literal">global-ignores</code> option (or its built-in
          default value).  This is done so that users can see if
          perhaps they've forgotten to add a resource to version
          control.</p><p>But Subversion cannot possibly guess the names of
          every resource that should be ignored.  Also, quite often
          there are things that should be ignored in
          <span class="emphasis"><em>every</em></span> working copy of a particular
          repository.  To force every user of that repository to add
          patterns for those resources to their run-time configuration
          areas would be not just a burden, but has the potential to
          clash with the configuration needs of other working copies
          that the user has checked out.</p><p>The solution is to store ignore patterns that are unique
          to the resources likely to appear in a given directory with
          the directory itself.  Common examples of unversioned
          resources that are basically unique to a directory, yet
          likely to appear there, include output from program
          compilations.  Or—to use an example more appropriate
          to this book—the HTML, PDF, or PostScript files
          generated as the result of a conversion of some source
          DocBook XML files to a more legible output format.</p><div class="sidebar"><p class="title"><b>Ignore Patterns for CVS Users</b></p><p>The Subversion <code class="literal">svn:ignore</code> property
            is very similar in syntax and function to the CVS
            <code class="filename">.cvsignore</code> file.  In fact, if you are
            migrating a CVS working copy to Subversion, you can
            directly migrate the ignore patterns by using the
            <code class="filename">.cvsignore</code> file as input file to the
            <span><strong class="command">svn propset</strong></span> command:</p><pre class="screen">
$ svn propset svn:ignore -F .cvsignore .
property 'svn:ignore' set on '.'
$
</pre><p>There are, however, some differences in the ways that
            CVS and Subversion handle ignore patterns.  The two systems
            use the ignore patterns at some different times, and there
            are slight discrepancies in what the ignore patterns apply
            to.  Also, Subversion does not recognize the use of the
            <code class="literal">!</code> pattern as a reset back to having no
            ignore patterns at all.</p></div><p>For this purpose, the <code class="literal">svn:ignore</code>
          property is the solution.  Its value is a multi-line
          collection of file patterns, one pattern per line.  The
          property is set on the directory in which you wish the
          patterns to be applied.
          <sup>[<a id="id4851615" href="#ftn.id4851615">36</a>]</sup>
          For example, say you have the following output from
          <span><strong class="command">svn status</strong></span>:</p><pre class="screen">
$ svn status calc
 M     calc/button.c
?      calc/calculator
?      calc/data.c
?      calc/debug_log
?      calc/debug_log.1
?      calc/debug_log.2.gz
?      calc/debug_log.3.gz
</pre><p>In this example, you have made some property
          modifications to <code class="filename">button.c</code>, but in your
          working copy you also have some unversioned files:
          the latest <code class="filename">calculator</code> program
          that you've compiled from your source code, a source file
          named <code class="filename">data.c</code>, and a set of debugging
          output log files.  Now, you know that your build system
          always results in the <code class="filename">calculator</code>
          program being generated.
          <sup>[<a id="id4851680" href="#ftn.id4851680">37</a>]</sup>
          And you know that your test suite always leaves those
          debugging log files lying around.  These facts are true for
          all working copies, not just your own.  And you know that
          you aren't interested in seeing those things every time you
          run <span><strong class="command">svn status</strong></span>.  So you use <span><strong class="command">svn
          propedit svn:ignore calc</strong></span> to add some ignore
          patterns to the <code class="filename">calc</code> directory.  For
          example, you might add this as the new value of the
          <code class="literal">svn:ignore</code> property:</p><pre class="programlisting">
calculator
debug_log*
</pre><p>After you've added this property, you will now have a
          local property modification on the <code class="filename">calc</code>
          directory.  But notice what else is different about your
          <span><strong class="command">svn status</strong></span> output:</p><pre class="screen">
$ svn status
 M     calc
 M     calc/button.c
?      calc/data.c
</pre><p>Now, all the cruft is missing from the output!  Of
          course, those files are still in your working copy.
          Subversion is simply not reminding you that they are present
          and unversioned.  And now with all the trivial noise removed
          from the display, you are left with more interesting
          items—such as that source code file that you probably
          forgot to add to version control.</p><p>If you want to see the ignored files, you can pass the 
          <code class="option">--no-ignore</code> option to Subversion:</p><pre class="screen">
$ svn status --no-ignore
 M     calc/button.c
I      calc/calculator
?      calc/data.c
I      calc/debug_log
I      calc/debug_log.1
I      calc/debug_log.2.gz
I      calc/debug_log.3.gz
</pre><p>The list of patterns to ignore is also used by
          <span><strong class="command">svn add</strong></span> and <span><strong class="command">svn
          import</strong></span>.  Both of these operations involve asking
          Subversion to begin managing some set of files and
          directories.  Rather than force the user to pick and choose
          which files in a tree she wishes to start versioning,
          Subversion uses the ignore patterns to determine which files
          should not be swept into the version control system as part
          of a larger recursive addition or import operation.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.advanced.props.special.keywords"></a><code class="literal">svn:keywords</code></h4></div></div></div><p>Subversion has the ability to substitute
          <em class="firstterm">keywords</em>—pieces of useful,
          dynamic information about a versioned file—into the
          contents of the file itself.  Keywords generally describe
          information about the last time the file was known to be
          modified.  Because this information changes each time the
          file changes, and more importantly, just
          <span class="emphasis"><em>after</em></span> the file changes, it is a hassle
          for any process except the version control system to keep
          the data completely up-to-date.  Left to human authors, the
          information would inevitably grow stale.</p><p>For example, say you have a document in which you would
          like to display the last date on which it was modified.  You
          could burden every author of that document to, just before
          committing their changes, also tweak the part of the
          document that describes when it was last changed.  But
          sooner or later, someone would forget to do that.  Instead
          simply ask Subversion to perform keyword substitution on the
          <code class="literal">LastChangedDate</code> keyword.  You control
          where the keyword is inserted into your document by placing
          a <em class="firstterm">keyword anchor</em> at the desired
          location in the file.  This anchor is just a string of text
          formatted as
          <code class="literal">$</code><em class="replaceable"><code>KeywordName</code></em><code class="literal">$</code>.</p><p>All keywords are case-sensitive where they appear as
          anchors in files: you must use the correct capitalization in
          order for the keyword to be expanded.  You should consider the
          value of the <code class="literal">svn:keywords</code> property to be
          case-sensitive too—certain keyword names will be recognized
          regardless of case, but this behavior is deprecated.</p><p>Subversion defines the list of keywords available for
          substitution.  That list contains the following five keywords, 
          some of which have aliases that you can also use:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">Date</code></span></dt><dd><p>This keyword describes the last time the file was
                known to have been changed in the repository, and
                looks something like <code class="literal">$Date:
                2002-07-22 21:42:37 -0700 (Mon, 22 Jul 2002)
                $</code>.  It may also be specified as
                <code class="literal">LastChangedDate</code>.</p></dd><dt><span class="term"><code class="literal">Revision</code></span></dt><dd><p>This keyword describes the last known revision in
                which this file changed in the repository, and looks
                something like <code class="literal">$Revision: 144 $</code>.  
                It may also be specified as
                <code class="literal">LastChangedRevision</code> or
                <code class="literal">Rev</code>.</p></dd><dt><span class="term"><code class="literal">Author</code></span></dt><dd><p>This keyword describes the last known user to
                change this file in the repository, and looks
                something like <code class="literal">$Author: harry $</code>.  
                It may also be specified as 
                <code class="literal">LastChangedBy</code>.</p></dd><dt><span class="term"><code class="literal">HeadURL</code></span></dt><dd><p>This keyword describes the full URL to the latest
                version of the file in the repository, and looks
                something like <code class="literal">$HeadURL:
                http://svn.collab.net/repos/trunk/README $</code>.
                It may be abbreviated as
                <code class="literal">URL</code>.</p></dd><dt><span class="term"><code class="literal">Id</code></span></dt><dd><p>This keyword is a compressed combination of the
                other keywords.  Its substitution looks something like
                <code class="literal">$Id: calc.c 148 2002-07-28 21:30:43Z sally
                $</code>, and is interpreted to mean that the file
                <code class="filename">calc.c</code> was last changed in revision
                148 on the evening of July 28, 2002 by the user
                <code class="literal">sally</code>.</p></dd></dl></div><p>Simply adding keyword anchor text to your file does
          nothing special.  Subversion will never attempt to perform
          textual substitutions on your file contents unless
          explicitly asked to do so.  After all, you might be writing
          a document
          <sup>[<a id="id4852147" href="#ftn.id4852147">38</a>]</sup> 
          about how to use keywords, and you don't want Subversion to
          substitute your beautiful examples of un-substituted keyword
          anchors!</p><p>To tell Subversion whether or not to substitute keywords
          on a particular file, we again turn to the property-related
          subcommands.  The <code class="literal">svn:keywords</code> property,
          when set on a versioned file, controls which keywords will
          be substituted on that file.  The value is a space-delimited
          list of the keyword names or aliases found in the previous
          table.</p><p>For example, say you have a versioned file named
          <code class="filename">weather.txt</code> that looks like
          this:</p><pre class="programlisting">
Here is the latest report from the front lines.
$LastChangedDate$
$Rev$
Cumulus clouds are appearing more frequently as summer approaches.
</pre><p>With no <code class="literal">svn:keywords</code> property set on
          that file, Subversion will do nothing special.  Now, let's
          enable substitution of the
          <code class="literal">LastChangedDate</code> keyword.</p><pre class="screen">
$ svn propset svn:keywords "Date Author" weather.txt
property 'svn:keywords' set on 'weather.txt'
$
</pre><p>Now you have made a local property modification on the
          <code class="filename">weather.txt</code> file.  You will see no
          changes to the file's contents (unless you made some of your
          own prior to setting the property).  Notice that the file
          contained a keyword anchor for the <code class="literal">Rev</code>
          keyword, yet we did not include that keyword in the property
          value we set.  Subversion will happily ignore requests to
          substitute keywords that are not present in the file, and
          will not substitute keywords that are not present in the
          <code class="literal">svn:keywords</code> property value.</p><div class="sidebar"><p class="title"><b>Keywords and Spurious Differences</b></p><p>The user-visible result of keyword substitution might
            lead you to think that every version of a file with that
            feature in use differs from the previous version in at
            least the area where the keyword anchor was placed.
            However, this is actually not the case.  While checking
            for local modifications during <span><strong class="command">svn
            diff</strong></span>, and before transmitting those local
            modifications during <span><strong class="command">svn commit</strong></span>,
            Subversion «<span class="quote">un-substitutes</span>» any keywords that
            it previously substituted.  The result is that the
            versions of the file that are stored in the repository
            contain only the real modifications that users make to the
            file.</p></div><p>Immediately after you commit this property change,
          Subversion will update your working file with the new
          substitute text.  Instead of seeing your keyword anchor
          <code class="literal">$LastChangedDate$</code>, you'll see its
          substituted result.  That result also contains the name of
          the keyword, and continues to be bounded by the dollar sign
          (<code class="literal">$</code>) characters.  And as we predicted, the
          <code class="literal">Rev</code> keyword was not substituted because
          we didn't ask for it to be.</p><p>Note also that we set the <code class="literal">svn:keywords</code>
          property to «<span class="quote">Date Author</span>» yet the keyword
          anchor used the alias <code class="literal">$LastChangedDate$</code>
          and still expanded correctly.</p><pre class="screen">
Here is the latest report from the front lines.
$LastChangedDate: 2002-07-22 21:42:37 -0700 (Mon, 22 Jul 2002) $
$Rev$
Cumulus clouds are appearing more frequently as summer approaches.
</pre><p>If someone else now commits a change to
          <code class="filename">weather.txt</code>, your copy of that file
          will continue to display the same substituted keyword value
          as before—until you update your working copy.  At that
          time the keywords in your <code class="filename">weather.txt</code>
          file will be re-substituted with information that
          reflects the most recent known commit to that file.</p><p>Subversion 1.2 introduced a new variant of the keyword
          syntax which brought additional, useful—though perhaps
          atypical—functionality.  You can now tell Subversion
          to maintain a fixed length (in terms of the number of bytes
          consumed) for the substituted keyword.  By using a
          double-colon (<code class="literal">::</code>) after the keyword name,
          followed by a number of space characters, you define that
          fixed width.  When Subversion goes to substitute your
          keyword for the keyword and its value, it will essentially
          replace only those space characters, leaving the overall
          width of the keyword field unchanged.  If the substituted
          value is shorter than the defined field width, there will be
          extra padding characters (spaces) at the end of the
          substituted field; if it is too long, it is truncated with a
          special hash (<code class="literal">#</code>) character just before
          the final dollar sign terminator.</p><p>For example, say you have a document in which you have
          some section of tabular data reflecting the document's
          Subversion keywords.  Using the original Subversion keyword
          substitution syntax, your file might look something
          like:</p><pre class="screen">
$Rev$:     Revision of last commit
$Author$:  Author of last commit
$Date$:    Date of last commit
</pre><p>Now, that looks nice and tabular at the start of things.
          But when you then commit that file (with keyword substitution
          enabled, of course), you see:</p><pre class="screen">
$Rev: 12 $:     Revision of last commit
$Author: harry $:  Author of last commit
$Date: 2006-03-15 02:33:03 -0500 (Wed, 15 Mar 2006) $:    Date of last commit
</pre><p>The result is not so beautiful.  And you might be
          tempted to then adjust the file after the substitution so
          that it again looks tabular.  But that only holds as long as
          the keyword values are the same width.  If the last
          committed revision rolls into a new place value (say, from
          99 to 100), or if another person with a longer username
          commits the file, stuff gets all crooked again.  However, if
          you are using Subversion 1.2 or better, you can use the new
          fixed-length keyword syntax, define some field widths that
          seem sane, and now your file might look like this:</p><pre class="screen">
$Rev::               $:  Revision of last commit
$Author::            $:  Author of last commit
$Date::              $:  Date of last commit
</pre><p>You commit this change to your file.  This time,
          Subversion notices the new fixed-length keyword syntax, and
          maintains the width of the fields as defined by the padding
          you placed between the double-colon and the trailing dollar
          sign.  After substitution, the width of the fields is
          completely unchanged—the short values for
          <code class="literal">Rev</code> and <code class="literal">Author</code> are
          padded with spaces, and the long <code class="literal">Date</code>
          field is truncated by a hash character:</p><pre class="screen">
$Rev:: 13            $:  Revision of last commit
$Author:: harry      $:  Author of last commit
$Date:: 2006-03-15 0#$:  Date of last commit
</pre><p>The use of fixed-length keywords is especially handy
          when performing substitutions into complex file formats that
          themselves use fixed-length fields for data, or for which
          the stored size of a given data field is overbearingly
          difficult to modify from outside the format's native
          application (such as for Microsoft Office documents).</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Avvertimento</h3><p>Be aware that because the width of a keyword field is
            measured in bytes, the potential for corruption of
            multi-byte values exists.  For example, a username which
            contains some multi-byte UTF-8 characters might suffer
            truncation in the middle of the string of bytes which make
            up one of those characters.  The result will be a mere
            truncation when viewed at the byte level, but will likely
            appear as a string with an incorrect or garbled final
            character when viewed as UTF-8 text.  It is conceivable
            that certain applications, when asked to load the file,
            would notice the broken UTF-8 text and deem the entire
            file corrupt, refusing to operate on the file
            altogether.</p></div></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.advanced.props.special.eol-style"></a><code class="literal">svn:eol-style</code></h4></div></div></div><p>Unless otherwise noted using a versioned file's
          <code class="literal">svn:mime-type</code> property, Subversion
          assumes the file contains human-readable data.  Generally
          speaking, Subversion only uses this knowledge to determine
          if contextual difference reports for that file are
          possible.  Otherwise, to Subversion, bytes are bytes.</p><p>This means that by default, Subversion doesn't pay any
          attention to the type of <em class="firstterm">end-of-line (EOL)
          markers</em> used in your files.  Unfortunately,
          different operating systems use different tokens to represent
          the end of a line of text in a file.  For example, the usual
          line ending token used by software on the Windows platform
          is a pair of ASCII control characters—carriage return
          (<code class="literal">CR</code>) and line feed
          (<code class="literal">LF</code>).  Unix software, however, just uses
          the <code class="literal">LF</code> character to denote the end of a
          line.</p><p>Not all of the various tools on these operating systems
          are prepared to understand files that contain line endings
          in a format that differs from the <em class="firstterm">native line
          ending style</em> of the operating system on which
          they are running.  Common results are that Unix programs
          treat the <code class="literal">CR</code> character present in Windows
          files as a regular character (usually rendered as
          <code class="literal">^M</code>), and that Windows programs combine
          all of the lines of a Unix file into one giant line because
          no carriage return-linefeed (or <code class="literal">CRLF</code>)
          character combination was found to denote the end of
          line.</p><p>This sensitivity to foreign EOL markers can become
          frustrating for folks who share a file across different
          operating systems.  For example, consider a source code
          file, and developers that edit this file on both Windows and
          Unix systems.  If all the developers always use tools which
          preserve the line ending style of the file, no problems
          occur.</p><p>But in practice, many common tools either fail to
          properly read a file with foreign EOL markers, or they
          convert the file's line endings to the native style when the
          file is saved.  If the former is true for a developer, he
          has to use an external conversion utility (such as
          <span><strong class="command">dos2unix</strong></span> or its companion,
          <span><strong class="command">unix2dos</strong></span>) to prepare the file for
          editing.  The latter case requires no extra preparation.
          But both cases result in a file that differs from the
          original quite literally on every line!  Prior to committing
          his changes, the user has two choices.  Either he can use a
          conversion utility to restore the modified file to the same
          line ending style that it was in before his edits were made.
          Or, he can simply commit the file—new EOL markers and
          all.</p><p>The result of scenarios like these include wasted time
          and unnecessary modifications to committed files.  Wasted
          time is painful enough.  But when commits change every line
          in a file, this complicates the job of determining which of
          those lines were changed in a non-trivial way.  Where was
          that bug really fixed?  On what line was a syntax error
          introduced?</p><p>The solution to this problem is the
          <code class="literal">svn:eol-style</code> property.  When this
          property is set to a valid value, Subversion uses it to
          determine what special processing to perform on the file so
          that the file's line ending style isn't flip-flopping with
          every commit that comes from a different operating
          system.  The valid values are:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">native</code></span></dt><dd><p>This causes the file to contain the EOL markers
                that are native to the operating system on which
                Subversion was run.  In other words, if a user on a
                Windows machine checks out a working copy that
                contains a file with an
                <code class="literal">svn:eol-style</code> property set to
                <code class="literal">native</code>, that file will contain
                <code class="literal">CRLF</code> EOL markers.  A Unix user
                checking out a working copy which contains the same
                file will see <code class="literal">LF</code> EOL markers in his
                copy of the file.</p><p>Note that Subversion will actually store the file
                in the repository using normalized
                <code class="literal">LF</code> EOL markers regardless of the
                operating system.  This is basically transparent to
                the user, though.</p></dd><dt><span class="term"><code class="literal">CRLF</code></span></dt><dd><p>This causes the file to contain
                <code class="literal">CRLF</code> sequences for EOL markers,
                regardless of the operating system in use.</p></dd><dt><span class="term"><code class="literal">LF</code></span></dt><dd><p>This causes the file to contain
                <code class="literal">LF</code> characters for EOL markers,
                regardless of the operating system in use.</p></dd><dt><span class="term"><code class="literal">CR</code></span></dt><dd><p>This causes the file to contain
                <code class="literal">CR</code> characters for EOL markers,
                regardless of the operating system in use.  This line
                ending style is not very common.  It was used on older
                Macintosh platforms (on which Subversion doesn't even
                run).</p></dd></dl></div></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.advanced.props.special.externals"></a><code class="literal">svn:externals</code></h4></div></div></div><p>The <code class="literal">svn:externals</code> property contains
          instructions for Subversion to populate a versioned
          directory with one or more other checked-out Subversion
          working copies.  For more information on this keyword and
          its use, see <a href="svn.advanced.externals.html" title="Externals Definitions">la sezione chiamata «Externals Definitions»</a>.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.advanced.props.special.special"></a><code class="literal">svn:special</code></h4></div></div></div><p>The <code class="literal">svn:special</code> property is the only
          <code class="literal">svn:</code> property that isn't meant to be
          directly set or modified by users.  Subversion automatically
          sets this property whenever a «<span class="quote">special</span>» object
          is scheduled for addition, such as a symbolic link.  The
          repository stores an <code class="literal">svn:special</code> object as
          an ordinary file.  However, when a client sees this property
          during checkouts or updates, it interprets the contents of
          the file and translates the item back into the special type
          of object.  In versions of Subversion current at the time of
          writing, only versioned symbolic links have this property
          attached, but in future versions of Subversion other special
          types of nodes will probably use this property as
          well.</p><p>Note: Windows clients don't have symbolic links, and
          thus ignore any <code class="literal">svn:special</code> files coming
          from a repository that claim to be symbolic links.  On
          Windows, the user ends up with an ordinary versioned file in
          the working copy.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.advanced.props.special.needs-lock"></a><code class="literal">svn:needs-lock</code></h4></div></div></div><p>This property is used to signify that the file it's
          attached to ought to be locked before editing.  The value of
          the property is irrelevant; Subversion will normalize its
          value to <code class="literal">*</code>.  When present, the file will
          be read-only <span class="emphasis"><em>unless</em></span> the user has
          explicitly locked the file.  When a lock-token is present
          (as a result of running <span><strong class="command">svn lock</strong></span>), the
          file becomes read-write.  When the lock is released, the
          file becomes read-only again.</p><p>To learn more about how, when, and why this property
          should be used, see
          <a href="svn.advanced.locking.html#svn.advanced.locking.lock-communication" title="Lock Communication">la sezione chiamata «Lock Communication»</a>.</p></div></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.props.auto"></a>Automatic Property Setting</h3></div></div></div><p>Properties are a powerful feature of Subversion, acting as
        key components of many Subversion features discussed elsewhere
        in this and other chapters—textual diff and merge
        support, keyword substitution, newline translation, etc.  But
        to get the full benefit of properties, they must be set on the
        right files and directories.  Unfortunately, that can be a
        step easily forgotten in the routine of things, especially
        since failing to set a property doesn't usually result in an
        obvious error condition (at least compared to, say, failing to
        add a file to version control).  To help your properties get
        applied to the places that need them, Subversion provides a
        couple of simple but useful features.</p><p>Whenever you introduce a file to version control using the
        <span><strong class="command">svn add</strong></span> or <span><strong class="command">svn import</strong></span>
        commands, Subversion runs a very basic heuristic to determine
        if that file consists of human-readable or non-human-readable
        content.  If the latter is the decision made, Subversion will
        automatically set the <code class="literal">svn:mime-type</code>
        property on that file to
        <code class="literal">application/octet-stream</code> (the generic
        «<span class="quote">this is a collection of bytes</span>» MIME type).  Of
        course, if Subversion guesses incorrectly, or if you wish to
        set the <code class="literal">svn:mime-type</code> property to something
        more precise—perhaps <code class="literal">image/png</code> or
        <code class="literal">application/x-shockwave-flash</code>—you can
        always remove or edit that property.</p><p>Subversion also provides the auto-props feature, which
        allows you to create mappings of filename patterns to property
        names and values.  These mappings are made in your runtime
        configuration area.  They again affect adds and imports, and
        not only can override any default MIME type decision made by
        Subversion during those operations, they can also set
        additional Subversion or custom properties, too.  For example,
        you might create a mapping that says that any time you add
        JPEG files—ones that match the pattern
        <code class="literal">*.jpg</code>—Subversion should automatically
        set the <code class="literal">svn:mime-type</code> property on those
        files to <code class="literal">image/jpeg</code>.  Or perhaps any files
        that match <code class="literal">*.cpp</code> should have
        <code class="literal">svn:eol-style</code> set to
        <code class="literal">native</code>, and <code class="literal">svn:keywords</code>
        set to <code class="literal">Id</code>.  Auto-prop support is perhaps
        the handiest property related tool in the Subversion toolbox.
        See <a href="svn.advanced.html#svn.advanced.confarea.opts.config" title="Config">la sezione chiamata «Config»</a> for more about
        configuring that support.</p></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.id4850503" href="#id4850503">33</a>] </sup>If you're familiar with XML, this is pretty much the
            ASCII subset of the syntax for XML "Name".</p></div><div class="footnote"><p><sup>[<a id="ftn.id4850805" href="#id4850805">34</a>] </sup>Fixing spelling errors, grammatical gotchas, and
              «<span class="quote">just-plain-wrongness</span>» in commit log
              messages is perhaps the most common use case for the
              <code class="option">--revprop</code> option.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4851208" href="#id4851208">35</a>] </sup>The Windows filesystems use file extensions (such as
              <code class="literal">.EXE</code>, <code class="literal">.BAT</code>, and
              <code class="literal">.COM</code>) to denote executable
              files.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4851615" href="#id4851615">36</a>] </sup>The patterns are strictly for that
              directory—they do not carry recursively into
              subdirectories.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4851680" href="#id4851680">37</a>] </sup>Isn't that the whole point of a build system?</p></div><div class="footnote"><p><sup>[<a id="ftn.id4852147" href="#id4852147">38</a>] </sup>… or maybe even a section of a book …</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="svn.advanced.html">Indietro</a> </td><td width="20%" align="center"><a accesskey="u" href="svn.advanced.html">Risali</a></td><td width="40%" align="right"> <a accesskey="n" href="svn.advanced.locking.html">Avanti</a></td></tr><tr><td width="40%" align="left" valign="top">Capitolo 7. Advanced Topics </td><td width="20%" align="center"><a accesskey="h" href="index.html">Partenza</a></td><td width="40%" align="right" valign="top"> Locking</td></tr></table></div></body></html>
