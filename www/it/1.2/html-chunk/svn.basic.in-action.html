<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Subversion in Action</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.70.1" /><link rel="start" href="index.html" title="Controllo di Versione con Subversion" /><link rel="up" href="svn.basic.html" title="Capitolo 2. Basic Concepts" /><link rel="prev" href="svn.basic.vsn-models.html" title="Versioning Models" /><link rel="next" href="svn.basic.summary.html" title="Sommario" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Subversion in Action</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="svn.basic.vsn-models.html">Indietro</a> </td><th width="60%" align="center">Capitolo 2. Basic Concepts</th><td width="20%" align="right"> <a accesskey="n" href="svn.basic.summary.html">Avanti</a></td></tr></table><hr /></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.basic.in-action"></a>Subversion in Action</h2></div></div></div><p>It's time to move from the abstract to the concrete.  In
      this section, we'll show real examples of Subversion being
      used.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.basic.in-action.wc"></a>Working Copies</h3></div></div></div><p>You've already read about working copies; now we'll
        demonstrate how the Subversion client creates and uses
        them.</p><p>A Subversion working copy is an ordinary directory tree on
        your local system, containing a collection of files.  You can
        edit these files however you wish, and if they're source code
        files, you can compile your program from them in the usual
        way.  Your working copy is your own private work area:
        Subversion will never incorporate other people's changes, nor
        make your own changes available to others, until you
        explicitly tell it to do so.  You can even have multiple
        working copies of the same project.</p><p>After you've made some changes to the files in your
        working copy and verified that they work properly, Subversion
        provides you with commands to «<span class="quote">publish</span>» your
        changes to the other people working with you on your project
        (by writing to the repository).  If other people publish their
        own changes, Subversion provides you with commands to merge
        those changes into your working directory (by reading from the
        repository).</p><p>A working copy also contains some extra files, created and
        maintained by Subversion, to help it carry out these commands.
        In particular, each directory in your working copy contains a
        subdirectory named <code class="filename">.svn</code>, also known as
        the working copy <em class="firstterm">administrative
        directory</em>.  The files in each administrative
        directory help Subversion recognize which files contain
        unpublished changes, and which files are out-of-date with
        respect to others' work.</p><p>A typical Subversion repository often holds the files (or
        source code) for several projects; usually, each project is a
        subdirectory in the repository's filesystem tree.  In this
        arrangement, a user's working copy will usually correspond to
        a particular subtree of the repository.</p><p>For example, suppose you have a repository that contains
        two software projects, <code class="literal">paint</code> and
        <code class="literal">calc</code>.  Each project lives in its own
        top-level subdirectory, as shown in <a href="svn.basic.in-action.html#svn.basic.in-action.wc.dia-1" title="Figura 2.6. The repository's filesystem">Figura 2.6, «The repository's filesystem»</a>.</p><div class="figure"><a id="svn.basic.in-action.wc.dia-1"></a><p class="title"><b>Figura 2.6. The repository's filesystem</b></p><div class="figure-contents"><div><img src="images/ch02dia6.png" alt="The repository's filesystem" /></div></div></div><br class="figure-break" /><p>To get a working copy, you must <em class="firstterm">check
        out</em> some subtree of the repository.  (The term
        «<span class="quote">check out</span>» may sound like it has something to do
        with locking or reserving resources, but it doesn't; it simply
        creates a private copy of the project for you.) For example,
        if you check out <code class="filename">/calc</code>, you will get a
        working copy like this:</p><pre class="screen">
$ svn checkout http://svn.example.com/repos/calc
A    calc/Makefile
A    calc/integer.c
A    calc/button.c
Checked out revision 56.

$ ls -A calc
Makefile  integer.c  button.c  .svn/
</pre><p>The list of letter A's indicates that Subversion is adding
        a number of items to your working copy.  You now have a
        personal copy of the repository's <code class="filename">/calc</code>
        directory, with one additional
        entry—<code class="filename">.svn</code>—which holds the
        extra information needed by Subversion, as mentioned
        earlier.</p><div class="sidebar"><a id="svn.basic.in-action.wc.sb-1"></a><p class="title"><b>Repository URLs</b></p><p>Subversion repositories can be accessed through many
          different methods—on local disk, or through various
          network protocols.  A repository location, however, is
          always a URL.  <a href="svn.basic.in-action.html#svn.basic.in-action.wc.tbl-1" title="Tabella 2.1. Repository Access URLs">Tabella 2.1, «Repository Access URLs»</a> describes how
          different URL schemas map to the available access methods.</p><div class="table"><a id="svn.basic.in-action.wc.tbl-1"></a><p class="title"><b>Tabella 2.1. Repository Access URLs</b></p><div class="table-contents"><table summary="Repository Access URLs" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Schema</th><th>Access Method</th></tr></thead><tbody><tr><td><code class="literal">file:///</code></td><td>direct repository access (on local disk)</td></tr><tr><td><code class="literal">http://</code></td><td>access via WebDAV protocol to Subversion-aware
                  Apache server</td></tr><tr><td><code class="literal">https://</code></td><td>same as <code class="literal">http://</code>, but with
                  SSL encryption.</td></tr><tr><td><code class="literal">svn://</code></td><td>access via custom protocol to an
                  <code class="literal">svnserve</code> server</td></tr><tr><td><code class="literal">svn+ssh://</code></td><td>same as <code class="literal">svn://</code>, but through
                  an SSH tunnel.</td></tr></tbody></table></div></div><br class="table-break" /><p>For more information on how Subversion parses URLs, see
        <a href="svn.advanced.reposurls.html" title="Subversion Repository URLs">la sezione chiamata «Subversion Repository URLs»</a>.</p></div><p>Suppose you make changes to <code class="filename">button.c</code>.
        Since the <code class="filename">.svn</code> directory remembers the
        file's modification date and original contents, Subversion can
        tell that you've changed the file.  However, Subversion does
        not make your changes public until you explicitly tell it to.
        The act of publishing your changes is more commonly known as
        <em class="firstterm">committing</em> (or <em class="firstterm">checking
        in</em>) changes to the repository.</p><p>To publish your changes to others, you can use
        Subversion's <span><strong class="command">commit</strong></span> command:</p><pre class="screen">
$ svn commit button.c
Sending        button.c
Transmitting file data .
Committed revision 57.
</pre><p>Now your changes to <code class="filename">button.c</code> have
        been committed to the repository; if another user checks out a
        working copy of <code class="filename">/calc</code>, they will see
        your changes in the latest version of the file.</p><p>Suppose you have a collaborator, Sally, who checked out a
        working copy of <code class="filename">/calc</code> at the same time
        you did.  When you commit your change to
        <code class="filename">button.c</code>, Sally's working copy is left
        unchanged; Subversion only modifies working copies at the
        user's request.</p><p>To bring her project up to date, Sally can ask
        Subversion to <em class="firstterm">update</em> her working copy,
        by using the Subversion <span><strong class="command">update</strong></span> command.
        This will incorporate your changes into her working copy, as
        well as any others that have been committed since she checked
        it out.</p><pre class="screen">
$ pwd
/home/sally/calc

$ ls -A 
.svn/ Makefile integer.c button.c

$ svn update
U    button.c
Updated to revision 57.
</pre><p>The output from the <span><strong class="command">svn update</strong></span> command
        indicates that Subversion updated the contents of
        <code class="filename">button.c</code>.  Note that Sally didn't need to
        specify which files to update; Subversion uses the information
        in the <code class="filename">.svn</code> directory, and further
        information in the repository, to decide which files need to
        be brought up to date.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.basic.in-action.revs"></a>Revisions</h3></div></div></div><p>An <span><strong class="command">svn commit</strong></span> operation can publish
        changes to any number of files and directories as a single
        atomic transaction.  In your working copy, you can change
        files' contents, create, delete, rename and copy files and
        directories, and then commit the complete set of changes as a
        unit.</p><p>In the repository, each commit is treated as an atomic
        transaction: either all the commit's changes take place, or
        none of them take place.  Subversion tries to retain this
        atomicity in the face of program crashes, system crashes,
        network problems, and other users' actions.</p><p>Each time the repository accepts a commit, this creates a
        new state of the filesystem tree, called a
        <em class="firstterm">revision</em>.  Each revision is assigned a
        unique natural number, one greater than the number of the
        previous revision.  The initial revision of a freshly created
        repository is numbered zero, and consists of nothing but an
        empty root directory.</p><p><a href="svn.basic.in-action.html#svn.basic.in-action.revs.dia-1" title="Figura 2.7. The repository">Figura 2.7, «The repository»</a> illustrates a nice way to
        visualize the repository.  Imagine an array of revision
        numbers, starting at 0, stretching from left to right.  Each
        revision number has a filesystem tree hanging below it, and
        each tree is a «<span class="quote">snapshot</span>» of the way the
        repository looked after a commit.</p><div class="figure"><a id="svn.basic.in-action.revs.dia-1"></a><p class="title"><b>Figura 2.7. The repository</b></p><div class="figure-contents"><div><img src="images/ch02dia7.png" alt="The repository" /></div></div></div><br class="figure-break" /><div class="sidebar"><p class="title"><b>Global Revision Numbers</b></p><p>Unlike those of many other version control systems,
          Subversion's revision numbers apply to <span class="emphasis"><em>entire
          trees</em></span>, not individual files.  Each revision
          number selects an entire tree, a particular state of the
          repository after some committed change.  Another way to
          think about it is that revision N represents the state of
          the repository filesystem after the Nth commit.  When
          Subversion users talk about «<span class="quote">revision 5 of
          <code class="filename">foo.c</code></span>», they really mean
          «<span class="quote"><code class="filename">foo.c</code> as it appears in revision
          5.</span>» Notice that in general, revisions N and M of a
          file do <span class="emphasis"><em>not</em></span> necessarily differ!  Because
          CVS uses per-file revision numbers, CVS users might want to
          see <a href="svn.forcvs.html" title="Appendice A. Subversion for CVS Users">Appendice A, <i>Subversion for CVS Users</i></a> for more details.</p></div><p>It's important to note that working copies do not always
        correspond to any single revision in the repository; they may
        contain files from several different revisions.  For example,
        suppose you check out a working copy from a repository whose
        most recent revision is 4:</p><pre class="screen">
calc/Makefile:4
     integer.c:4
     button.c:4
</pre><p>At the moment, this working directory corresponds exactly
        to revision 4 in the repository.  However, suppose you make a
        change to <code class="filename">button.c</code>, and commit that
        change.  Assuming no other commits have taken place, your
        commit will create revision 5 of the repository, and your
        working copy will now look like this:</p><pre class="screen">
calc/Makefile:4
     integer.c:4
     button.c:5
</pre><p>Suppose that, at this point, Sally commits a change to
        <code class="filename">integer.c</code>, creating revision 6.  If you
        use <span><strong class="command">svn update</strong></span> to bring your working copy
        up to date, then it will look like this:</p><pre class="screen">
calc/Makefile:6
     integer.c:6
     button.c:6
</pre><p>Sally's change to <code class="filename">integer.c</code> will
        appear in your working copy, and your change will still be
        present in <code class="filename">button.c</code>.  In this example,
        the text of <code class="filename">Makefile</code> is identical in
        revisions 4, 5, and 6, but Subversion will mark your working
        copy of <code class="filename">Makefile</code> with revision 6 to
        indicate that it is still current.  So, after you do a clean
        update at the top of your working copy, it will generally
        correspond to exactly one revision in the repository.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.basic.in-action.track-repos"></a>Come le copie di lavoro sono in relazione con il repository</h3></div></div></div><p>For each file in a working directory, Subversion records
        two essential pieces of information in the
        <code class="filename">.svn/</code> administrative area:</p><p>Per ogni file nella direcotory di lavoro, Subversion registra due porzioni di informazione essenziali nell' area di amministrazione <code class="filename">.svn/</code> :</p><div class="itemizedlist"><ul type="disc"><li><p>what revision your working file is based on (this is
            called the file's <em class="firstterm">working 
              revision</em>), and</p><p>il numero di revisione su cui è basata la copia di lavoro  (detta <em class="firstterm">revisione di lavoro</em> del file), e </p></li><li><p>a timestamp recording when the local copy was last
            updated by the repository.</p><p>una marca temporale relativa a quando la copia locale è stata aggiornata con il repository</p></li></ul></div><p>Given this information, by talking to the repository,
        Subversion can tell which of the following four states a
        working file is in:</p><p>Date queste informazioni, comunicando con il repository, Subversion può decidere in quale dei seguenti quattro stati si trova un file nella copia di lavoro: </p><div class="variablelist"><dl><dt><span class="term">Unchanged, and current, </span><span class="term">Non modificato e aggiornato</span></dt><dd><p>The file is unchanged in the working directory, and
              no changes to that file have been committed to the
              repository since its working revision.  An <span><strong class="command">svn
              commit</strong></span> of the file will do nothing, and an
              <span><strong class="command">svn update</strong></span> of the file will do
              nothing.</p><p>Il file non è stato modificato nella directory di lavoro e nessun cambiamento è stato sottomesso al repository dalla sua revisione di lavoro. 
              Un comando <span><strong class="command">svn commit</strong></span> del file non farà nulla, e un comando <span><strong class="command">svn update</strong></span> del file non farà nulla.</p></dd><dt><span class="term">Locally changed, and current, </span><span class="term">Localmente modificato e aggiornato</span></dt><dd><p>The file has been changed in the working directory,
              and no changes to that file have been committed to the
              repository since its base revision.  There are local
              changes that have not been committed to the repository,
              thus an <span><strong class="command">svn commit</strong></span> of the file will
              succeed in publishing your changes, and an <span><strong class="command">svn
                update</strong></span> of the file will do nothing.</p><p>Il file è stato modificato nella directory di lavoro, e nessun cambiamento è stato sottomesso al repository dalla sua revisione di lavoro.
              Ci sono delle modifiche locali che devono essere salvate sul repository, quindi un <span><strong class="command">svn commit</strong></span> 
              del file pubblicherà con successo le modifiche, e un <span><strong class="command">svn update</strong></span> del file non farà nulla.</p></dd><dt><span class="term">Unchanged, and out-of-date, </span><span class="term">Non modificato e scaduto</span></dt><dd><p>The file has not been changed in the working
              directory, but it has been changed in the repository.
              The file should eventually be updated, to make it
              current with the public revision.  An <span><strong class="command">svn
              commit</strong></span> of the file will do nothing, and an
              <span><strong class="command">svn update</strong></span> of the file will fold the
              latest changes into your working copy.</p><p>Il file non è stato modificato nella directory di lavoro, me ha subito dei cambiamenti nel repository.
            Il file dovrebbe essere aggiornato per renderlo sincronizzato con l'attuale revisione pubblica.
              Un <span><strong class="command">svn commit</strong></span> del file non farà nulla, 
              e un <span><strong class="command">svn commit</strong></span> del file caricherà gli ultimi cambiamenti nella copia di lavoro.</p></dd><dt><span class="term">Locally changed, and out-of-date, </span><span class="term">Localmente modificato e scaduto</span></dt><dd><p>The file has been changed both in the working
              directory, and in the repository.  An <span><strong class="command">svn
              commit</strong></span> of the file will fail with an
              “<span class="quote">out-of-date</span>” error.  The file should be
              updated first; an <span><strong class="command">svn update</strong></span> command
              will attempt to merge the public changes with the local
              changes.  If Subversion can't complete the merge in a
              plausible way automatically, it leaves it to the user to
              resolve the conflict.</p><p>Il file è stato cambiato sia nella directory di lavoro, sia nel repository. Un comando <span><strong class="command">svn commit</strong></span>
              del file fallirà con un errore di «<span class="quote">out-of-date</span>». Il file dovrebbe prima essere aggoirnato; un comando <span><strong class="command">svn update</strong></span> tenterà di incorporare le modifiche pubbliche con le modifiche locali. 
              Se Subversion non può completare la fusione automatica in un modo coerente, lascerà all'utente il compito di risolvere il conflitto.  
             </p></dd></dl></div><p>This may sound like a lot to keep track of, but the
        <span><strong class="command">svn status</strong></span> command will show you the state
        of any item in your working copy.  For more information on
        that command, see <a href="svn.tour.cycle.html#svn.tour.cycle.examine.status" title="svn status">la sezione chiamata «<span><strong class="command">svn status</strong></span>»</a>.</p><p>Potrebbe sembrare eccessivo tenter tracca di tutto questo, ma il comando <span><strong class="command">svn status</strong></span> mostrerà la stato di ogni elemento nella copia di lavoro.
        Per altre informazioni su questo comando, si veda <a href="svn.tour.cycle.html#svn.tour.cycle.examine.status" title="svn status">la sezione chiamata «<span><strong class="command">svn status</strong></span>»</a>.
      </p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.basic.in-action.mixedrevs"></a>Copie di lavoro con revisioni miste</h3></div></div></div><p>As a general principle, Subversion tries to be as flexible
        as possible.  One special kind of flexibility is the ability
        to have a working copy containing files and directories with a
        mix of different working revision numbers.  Unfortunately,
        this flexibility tends to confuse a number of new users.  If
        the earlier example showing mixed revisions perplexed you,
        here's a primer on both why the feature exists and how to make
        use of it.</p><p>Come principio generale, Subversion vuole essere il più flessibile possibile. Una particolare flessibilità deriva dalla possibilità
        di avere una copia di lavoro contenente file e directory con un MIX di differenti numeri di revisione. 
        Sfortunatamente questa flessibilità tende a confondere alcuni utenti. Segue quindi un'introduzione sul perchè esiste questa caratteristica e su come utilizzarla.
      </p><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.basic.in-action.mixedrevs.update-commit"></a>Update e commit sono azioni separate</h4></div></div></div><p>One of the fundamental rules of Subversion is that
          a “<span class="quote">push</span>” action does not cause
          a “<span class="quote">pull</span>”, nor the other way around.  Just
          because you're ready to submit new changes to the repository
          doesn't mean you're ready to receive changes from other
          people.  And if you have new changes still in progress,
          then <span><strong class="command">svn update</strong></span> should gracefully merge
          repository changes into your own, rather than forcing you to
          publish them.</p><p>Una delle regole fondamentali di Subversion è che un'azione di «<span class="quote">invio</span>» non causa una «<span class="quote">ricezione</span>», nè viceversa.
          Il fatto che ci siano le condizioni per inviare nuove modifiche al repository non significa che si sia pronti per ricevere quelle apportate dagli altri utenti.
          Se si sta lavorando a delle modifiche, il comando <span><strong class="command">svn update</strong></span> deve integrare le eventali modifiche avvenute sul repository
          in quelle sui cui si sta lavroando, piuttosto che forzare a pubblicarle. 
           
        </p><p>The main side-effect of this rule is that it means a
          working copy has to do extra bookkeeping to track mixed
          revisions, and be tolerant of the mixture as well.  It's
          made more complicated by the fact that directories
          themselves are versioned.</p><p>La conseguenza principale di questa regola è che implica che una copia di lavoro deve fare un lavoro in più per tener traccia 
        delle diverse revisioni, e deve anche tollerare le le diversità stesse. Ciò inoltre è reso più complicato dal fatto che anche le directory stesse sono versionate. 
        </p><p>For example, suppose you have a working copy entirely at
          revision 10.  You edit the
          file <code class="filename">foo.html</code> and then perform
          an <span><strong class="command">svn commit</strong></span>, which creates revision 15
          in the repository.  After the commit succeeds, many new
          users would expect the working copy to be entirely at
          revision 15, but that's not the case!  Any number of changes
          might have happened in the repository between revisions 10
          and 15.  The client knows nothing of those changes in the
          repository, since you haven't yet run <span><strong class="command">svn
          update</strong></span>, and <span><strong class="command">svn commit</strong></span> doesn't
          pull down new changes.  If, on the other hand,
          <span><strong class="command">svn commit</strong></span> <span class="emphasis"><em>were</em></span> to
          automatically download the newest changes, then it would be
          possible to set the entire working copy to revision
          15—but then we'd be breaking the fundamental rule
          of “<span class="quote">push</span>” and “<span class="quote">pull</span>” remaining
          separate actions.  Therefore the only safe thing the
          Subversion client can do is mark the one
          file—<code class="filename">foo.html</code>—as being at
          revision 15.  The rest of the working copy remains at
          revision 10.  Only by running <span><strong class="command">svn update</strong></span>
          can the latest changes be downloaded, and the whole working
          copy be marked as revision 15.</p><p>Ad esempio, si suppone di avere una copia di lavoro completamente allineata alla revisione 10. Il file <code class="filename">foo.html</code>
          viene modificato e successivamente viene eseguito un <span><strong class="command">svn commit</strong></span> il quale crea la revisione numero 15 nel repository. 
          Visto l'esito positivo del comando di commit, molti utenti potrebbero pensare che la copia di lavorazione sia interamente allineata con la revisione 15, ma non è cosiì! 
          Molti cambiamenti potrebbero essersi verificati nel repository tra la revisione 10 e la 15. Il client non sa nulla di questi cambiamenti in quanto
          non si è ancora eseguito il comando <span><strong class="command">svn update</strong></span>, e il comando <span><strong class="command">svn commit</strong></span> non riceve nessun cambiamento.
          D'altronde, se il comando <span><strong class="command">svn commit</strong></span> scaricasse automaticamente le nuove modifiche dal repository, allora sarebbe possibile 
          allineare tutta la copia di lavoro alla revisone 15— ma si verrebbe così ad infrangere la regola fondamentale che impone a "PUSH" E "PULL"
          di essere azioni separate. Quindi l'unica cosa sicura che il client di Subversion può fare è ricordare che il file — <code class="filename">foo.html</code>— 
          è della revisione 15. Il resto della copia di lavorazione rimane alla revisione 10. Solo eseguendo un <span><strong class="command">svn update</strong></span> si possono scaricare 
          gli utlimissim cambiamenti, e tutta la copia di lavorazione sarà contrassegnata alla revisone 15.
        </p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.basic.in-action.mixedrevs.normal"></a>E' normale avere reivisioni mischiate</h4></div></div></div><p>The fact is, <span class="emphasis"><em>every time</em></span> you
            run <span><strong class="command">svn commit</strong></span>, your working copy ends
            up with some mixture of revisions.  The things you just
            committed are marked as having larger working revisions
            than everything else.  After several commits (with no
            updates in-between) your working copy will contain a whole
            mixture of revisions.  Even if you're the only person
            using the repository, you will still see this phenomenon.
            To examine your mixture of working revisions, use
            the <span><strong class="command">svn status --verbose</strong></span> command (see
            <a href="svn.tour.cycle.html#svn.tour.cycle.examine.status" title="svn status">la sezione chiamata «<span><strong class="command">svn status</strong></span>»</a> for more
            information.)</p><p>Di fatto <span class="emphasis"><em>ogni volta</em></span> che si esegue il comando <span><strong class="command">svn commit</strong></span>
            la copia di lavorazione si viene a trovare in un insieme misto di revisioni. Gli elementi che sono appena stati inviati al repository avranno 
            la revisione di lavorazione più alta di ogni altro. Dopo diversi commit (senza operazioni di aggiornamento intermedie) la copia di lavorazione 
            conterrà una vasta combinazione di revisioni. Anche se una sola persona sta usando il repository, si continuerà a verficare questo fenomeno.
            Per esaminare la miscela delle revisioni di lavorazione, si può usare il comando <span><strong class="command">svn status --verbose</strong></span> 
            (per maggiori informazioni vedere <a href="svn.tour.cycle.html#svn.tour.cycle.examine.status" title="svn status">la sezione chiamata «<span><strong class="command">svn status</strong></span>»</a>).
          </p><p>Often, new users are completely unaware that their
            working copy contains mixed revisions.  This can be
            confusing, because many client commands are sensitive to
            the working revision of the item they're examining.  For
            example, the <span><strong class="command">svn log</strong></span> command is used to
            display the history of changes to a file or directory (see
            <a href="svn.tour.history.html#svn.tour.history.log" title="svn log">la sezione chiamata «<span><strong class="command">svn log</strong></span>»</a>).  When the user
            invokes this command on a working copy object, they expect
            to see the entire history of the object.  But if the
            object's working revision is quite old (often
            because <span><strong class="command">svn update</strong></span> hasn't been run in a
            long time), then the history of
            the <span class="emphasis"><em>older</em></span> version of the object is
            shown.</p><p>
            Spesso i nuovi utenti ignorano completamente che la loro copia di lavorazione contiene diverse revisioni. Ciò può generare confusione,
            perchè molti comandi sono sensibili alla revisione di lavorazione degli oggetti che devono esminare. Per esempio, il comando <span><strong class="command">svn log</strong></span>
            viene utilizzato per mostrare la storia dei cambiamenti di un file o una directory (vedere <a href="svn.tour.history.html#svn.tour.history.log" title="svn log">la sezione chiamata «<span><strong class="command">svn log</strong></span>»</a>).
            Quando un utente invoca questo comando sulla copia di lavorazione di un oggetto, si aspetta di vedere l'intera storia dell'oggetto stesso. 
            In realtà se la revisione di lavorazione è puittosto vecchia (solitamente perchè non si è usato il comando <span><strong class="command">svn update</strong></span> da molto tempo), 
            allora viene mostrata la storia della <span class="emphasis"><em>precedente</em></span> versione dell'oggetto.
            
          </p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.basic.in-action.mixedrevs.useful"></a>Le revisioni miste sono utili</h4></div></div></div><p>If your project is sufficiently complex, you'll
            discover that it's sometimes nice to forcibly
            “<span class="quote">backdate</span>” portions of your working copy to
            an earlier revision; you'll learn how to do that in
            Chapter 3.  Perhaps you'd like to test an earlier version
            of a sub-module contained in a subdirectory, or perhaps
            you'd like to figure out when a bug first came into
            existence in a specific file.  This is the “<span class="quote">time
            machine</span>” aspect of a version control system —
            the feature which allows you to move any portion of your
            working copy forward and backward in history.</p><p>Se il progetto è piuttosto complesso, a volte è meglio forzare alcune porzioni della copia di lavorazione a «<span class="quote">retrocedere</span>» a versioni precedenti;
            nel Capitolo 3 si potrà vedere come fare. Si potrebbe voler testare una versione precedete di qualche componente contenuta in una sotto directory; 
            oppure si vorrebbe capire quando un bug è comparso per la prima volta in un certo file. Questo è l'aspetto di un sistema di controllo delle versioni 
            che lo caratterizza come una «<span class="quote">macchina del tempo</span>» — questa è caratteristica che permette di muovere ogni porzione della copia di lavorazione
            avanti e indietro nella storia.
          </p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.basic.in-action.mixedrevs.limits"></a>Le revisioni miste hanno dei limiti</h4></div></div></div><p>However you make use of mixed revisions in your
            working copy, there are limitations to this
            flexibility.</p><p>Qualunque uso si faccia delle revisioni miste nella copia di lavorazione, ci sono sempre delle limitazioni a questa flessibilità.</p><p>First, you cannot commit the deletion of a file or
            directory which isn't fully up-to-date.  If a newer
            version of the item exists in the repository, your attempt
            to delete will be rejected, to prevent you from
            accidentally destroying changes you've not yet
            seen.</p><p>Primo, non si può effettuare la commit della cancellazione di un file o directory che non sia completamente aggiornato.
          Se nel repository esiste una versione più recente, il tentativo di elimnazione verrà rifiutato, per evitare la distruzione accidentale 
          di modifiche che non si sono ancora viste.</p><p>Second, you cannot commit a metadata change to a
            directory unless it's fully up-to-date.  You'll learn
            about attaching
            “<span class="quote">properties</span>” to items in Chapter 6.  A
            directory's working revision defines a specific set of
            entries and properties, and thus committing a property
            change to an out-of-date directory may destroy properties
            you've not yet seen.</p><p>Secondo, non è possibile effettuare la commit della modifica di un metadato su una directory senza che questa 
            sia completamente aggiornata. Nel capitolo 6 si imparerà ad assegnare le «<span class="quote">proprietà</span>» agli oggetti.
            La revisione di lavorazione di una directory definisce un insieme specifico di voci e proprietà, quindi effettuare la commit della modifica di una proprietà
            a una directory non aggiornata potrebbe distruggere qualche proprietà che non è ancora stata vista.
          </p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="svn.basic.vsn-models.html">Indietro</a> </td><td width="20%" align="center"><a accesskey="u" href="svn.basic.html">Risali</a></td><td width="40%" align="right"> <a accesskey="n" href="svn.basic.summary.html">Avanti</a></td></tr><tr><td width="40%" align="left" valign="top">Versioning Models </td><td width="20%" align="center"><a accesskey="h" href="index.html">Partenza</a></td><td width="40%" align="right" valign="top"> Sommario</td></tr></table></div></body></html>
