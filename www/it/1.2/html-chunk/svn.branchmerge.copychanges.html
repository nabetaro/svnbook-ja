<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Copying Changes Between Branches</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.70.1" /><link rel="start" href="index.html" title="Controllo di Versione con Subversion" /><link rel="up" href="svn.branchmerge.html" title="Capitolo 4. Branching and Merging" /><link rel="prev" href="svn.branchmerge.using.html" title="Using Branches" /><link rel="next" href="svn.branchmerge.commonuses.html" title="Common Use-Cases" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Copying Changes Between Branches</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="svn.branchmerge.using.html">Indietro</a> </td><th width="60%" align="center">Capitolo 4. Branching and Merging</th><td width="20%" align="right"> <a accesskey="n" href="svn.branchmerge.commonuses.html">Avanti</a></td></tr></table><hr /></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.branchmerge.copychanges"></a>Copying Changes Between Branches</h2></div></div></div><p>Now you and Sally are working on parallel branches of the
      project: you're working on a private branch, and Sally is
      working on the <em class="firstterm">trunk</em>, or main line of
      development.</p><p>For projects that have a large number of contributors, it's
      common for most people to have working copies of the trunk.
      Whenever someone needs to make a long-running change that is
      likely to disrupt the trunk, a standard procedure is to create a
      private branch and commit changes there until all the work is
      complete.</p><p>So, the good news is that you and Sally aren't interfering
      with each other.  The bad news is that it's very easy to drift
      <span class="emphasis"><em>too</em></span> far apart.  Remember that one of the
      problems with the «<span class="quote">crawl in a hole</span>» strategy is
      that by the time you're finished with your branch, it may be
      near-impossible to merge your changes back into the trunk
      without a huge number of conflicts.</p><p>Instead, you and Sally might continue to share changes as
      you work.  It's up to you to decide which changes are worth
      sharing; Subversion gives you the ability to selectively
      «<span class="quote">copy</span>» changes between branches.  And when you're
      completely finished with your branch, your entire set of branch
      changes can be copied back into the trunk.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.copychanges.specific"></a>Copying Specific Changes</h3></div></div></div><p>In the previous section, we mentioned that both you and
        Sally made changes to <code class="filename">integer.c</code> on
        different branches.  If you look at Sally's log message for
        revision 344, you can see that she fixed some spelling errors.
        No doubt, your copy of the same file still has the same spelling
        errors.  It's likely that your future changes to this file will
        be affecting the same areas that have the spelling errors, so
        you're in for some potential conflicts when you merge your
        branch someday.  It's better, then, to receive Sally's change
        now, <span class="emphasis"><em>before</em></span> you start working too heavily
        in the same places.</p><p>It's time to use the <span><strong class="command">svn merge</strong></span> command.
        This command, it turns out, is a very close cousin to the
        <span><strong class="command">svn diff</strong></span> command (which you read about in
        Chapter 3).  Both commands are able to compare any two objects
        in the repository and describe the differences.  For example,
        you can ask <span><strong class="command">svn diff</strong></span> to show you the exact
        change made by Sally in revision 344:</p><pre class="screen">
$ svn diff -r 343:344 http://svn.example.com/repos/calc/trunk

Index: integer.c
===================================================================
--- integer.c	(revision 343)
+++ integer.c	(revision 344)
@@ -147,7 +147,7 @@
     case 6:  sprintf(info-&gt;operating_system, "HPFS (OS/2 or NT)"); break;
     case 7:  sprintf(info-&gt;operating_system, "Macintosh"); break;
     case 8:  sprintf(info-&gt;operating_system, "Z-System"); break;
-    case 9:  sprintf(info-&gt;operating_system, "CPM"); break;
+    case 9:  sprintf(info-&gt;operating_system, "CP/M"); break;
     case 10:  sprintf(info-&gt;operating_system, "TOPS-20"); break;
     case 11:  sprintf(info-&gt;operating_system, "NTFS (Windows NT)"); break;
     case 12:  sprintf(info-&gt;operating_system, "QDOS"); break;
@@ -164,7 +164,7 @@
     low = (unsigned short) read_byte(gzfile);  /* read LSB */
     high = (unsigned short) read_byte(gzfile); /* read MSB */
     high = high &lt;&lt; 8;  /* interpret MSB correctly */
-    total = low + high; /* add them togethe for correct total */
+    total = low + high; /* add them together for correct total */
 
     info-&gt;extra_header = (unsigned char *) my_malloc(total);
     fread(info-&gt;extra_header, total, 1, gzfile);
@@ -241,7 +241,7 @@
      Store the offset with ftell() ! */
 
   if ((info-&gt;data_offset = ftell(gzfile))== -1) {
-    printf("error: ftell() retturned -1.\n");
+    printf("error: ftell() returned -1.\n");
     exit(1);
   }
 
@@ -249,7 +249,7 @@
   printf("I believe start of compressed data is %u\n", info-&gt;data_offset);
   #endif
   
-  /* Set postion eight bytes from the end of the file. */
+  /* Set position eight bytes from the end of the file. */
 
   if (fseek(gzfile, -8, SEEK_END)) {
     printf("error: fseek() returned non-zero\n");
</pre><p>The <span><strong class="command">svn merge</strong></span> command is almost exactly
        the same.  Instead of printing the differences to your
        terminal, however, it applies them directly to your working
        copy as <span class="emphasis"><em>local modifications</em></span>:</p><pre class="screen">
$ svn merge -r 343:344 http://svn.example.com/repos/calc/trunk
U  integer.c

$ svn status
M  integer.c
</pre><p>The output of <span><strong class="command">svn merge</strong></span> shows that your
        copy of <code class="filename">integer.c</code> was patched.  It now
        contains Sally's change—the change has been
        «<span class="quote">copied</span>» from the trunk to your working copy of
        your private branch, and now exists as a local modification.
        At this point, it's up to you to review the local modification
        and make sure it works correctly.</p><p>In another scenario, it's possible that things may not have
        gone so well, and that <code class="filename">integer.c</code> may have
        entered a conflicted state.  You might need to resolve the
        conflict using standard procedures (see Chapter 3), or if you
        decide that the merge was a bad idea altogether, simply give up
        and <span><strong class="command">svn revert</strong></span> the local change.</p><p>But assuming that you've reviewed the merged change, you can
        <span><strong class="command">svn commit</strong></span> the change as usual.  At that
        point, the change has been merged into your repository branch.
        In version control terminology, this act of copying changes
        between branches is commonly called
        <em class="firstterm">porting</em> changes.</p><p>When you commit the local modification, make sure your log
        message mentions that you're porting a specific change from
        one branch to another.  For example:</p><pre class="screen">
$ svn commit -m "integer.c: ported r344 (spelling fixes) from trunk."
Sending        integer.c
Transmitting file data .
Committed revision 360.
</pre><p>As you'll see in the next sections, this is a very
        important «<span class="quote">best practice</span>» to follow.</p><div class="sidebar"><p class="title"><b>Why Not Use Patches Instead?</b></p><p>A question may be on your mind, especially if you're a
          Unix user: why bother to use <span><strong class="command">svn merge</strong></span> at
          all?  Why not simply use the operating system's
          <span><strong class="command">patch</strong></span> command to accomplish the same job?
          For example:</p><pre class="screen">
$ svn diff -r 343:344 http://svn.example.com/repos/calc/trunk &gt; patchfile
$ patch -p0  &lt; patchfile
Patching file integer.c using Plan A...
Hunk #1 succeeded at 147.
Hunk #2 succeeded at 164.
Hunk #3 succeeded at 241.
Hunk #4 succeeded at 249.
done
</pre><p>In this particular case, yes, there really is no
          difference.  But <span><strong class="command">svn merge</strong></span> has special
          abilities that surpass the <span><strong class="command">patch</strong></span> program.
          The file format used by <span><strong class="command">patch</strong></span> is quite
          limited; it's only able to tweak file contents.  There's no
          way to represent changes to <span class="emphasis"><em>trees</em></span>, such
          as the addition, removal, or renaming of files and
          directories.  If Sally's change had, say, added a new
          directory, the output of <span><strong class="command">svn diff</strong></span>
          wouldn't have mentioned it at all.  <span><strong class="command">svn
          diff</strong></span> only outputs the limited patch-format, so
          there are some ideas it simply can't express.
          <sup>[<a id="id4815623" href="#ftn.id4815623">11</a>]</sup>
          The <span><strong class="command">svn merge</strong></span> command, however, can express
          changes in tree structure and properties by directly applying
          them to your working copy.</p></div><p>A word of warning: while <span><strong class="command">svn diff</strong></span> and
        <span><strong class="command">svn merge</strong></span> are very similar in concept, they
        do have different syntax in many cases.  Be sure to read about
        them in Chapter 9 for details, or ask <span><strong class="command">svn
        help</strong></span>.  For example, <span><strong class="command">svn merge</strong></span>
        requires a working-copy path as a target, i.e. a place where
        it should apply the tree-changes.  If the target isn't
        specified, it assumes you are trying to perform one of the
        following common operations:</p><div class="orderedlist"><ol type="1"><li><p>You want to merge directory changes into your current
            working directory.</p></li><li><p>You want to merge the changes in a specific file into
            a file by the same name which exists in your current working 
            directory.</p></li></ol></div><p>If you are merging a directory and haven't specified a
        target path, <span><strong class="command">svn merge</strong></span> assumes the first case
        above and tries to apply the changes into your current
        directory.  If you are merging a file, and that file (or a file
        by the same name) exists in your current working directory,
        <span><strong class="command">svn merge</strong></span> assumes the second case and tries
        to apply the changes to a local file with the same name.</p><p>If you want changes applied somewhere else, you'll
        need to say so.  For example, if you're sitting in the parent
        directory of your working copy, you'll have to specify the
        target directory to receive the changes:</p><pre class="screen">
$ svn merge -r 343:344 http://svn.example.com/repos/calc/trunk my-calc-branch
U   my-calc-branch/integer.c
</pre></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.copychanges.keyconcept"></a>The Key Concept Behind Merging</h3></div></div></div><p>You've now seen an example of the <span><strong class="command">svn
          merge</strong></span> command, and you're about to see several
          more.  If you're feeling confused about exactly how merging
          works, you're not alone.  Many users (especially those new
          to version control) are initially perplexed about the proper
          syntax of the command, and about how and when the feature
          should be used.  But fear not, this command is actually much
          simpler than you think!  There's a very easy technique for
          understanding exactly how <span><strong class="command">svn merge</strong></span>
          behaves.</p><p>The main source of confusion is the
        <span class="emphasis"><em>name</em></span> of the command.  The term
        «<span class="quote">merge</span>» somehow denotes that branches are
        combined together, or that there's some sort of mysterious
        blending of data going on.  That's not the case.  A better
        name for the command might have been <span><strong class="command">svn
        diff-and-apply</strong></span>, because that's all that happens:
        two repository trees are compared, and the differences are
        applied to a working copy.</p><p>The command takes three arguments:</p><div class="orderedlist"><ol type="1"><li><p>An initial repository tree (often called the
        <em class="firstterm">left side</em> of the
        comparison),</p></li><li><p>A final repository tree (often called the
        <em class="firstterm">right side</em> of the
        comparison),</p></li><li><p>A working copy to accept the differences as
        local changes (often called the <em class="firstterm">target</em>
        of the merge).</p></li></ol></div><p>Once these three arguments are specified, the two trees
        are compared, and the resulting differences are applied to the
        target working copy as local modifications.  When the command
        is done, the results are no different than if you had
        hand-edited the files, or run various <span><strong class="command">svn
        add</strong></span> or <span><strong class="command">svn delete</strong></span> commands
        yourself.  If you like the results, you can commit them.  If
        you don't like the results, you can simply <span><strong class="command">svn
        revert</strong></span> all of the changes.</p><p>The syntax of <span><strong class="command">svn merge</strong></span> allows you to
        specify the three necessary arguments rather flexibly.  Here
        are some examples:</p><pre class="screen">      
$ svn merge http://svn.example.com/repos/branch1@150 \
            http://svn.example.com/repos/branch2@212 \
            my-working-copy
            
$ svn merge -r 100:200 http://svn.example.com/repos/trunk my-working-copy

$ svn merge -r 100:200 http://svn.example.com/repos/trunk
</pre><p>The first syntax lays out all three arguments explicitly,
        naming each tree in the form <span class="emphasis"><em>URL@REV</em></span> and
        naming the working copy target.  The second syntax can be used
        as a shorthand for situations when you're comparing two
        different revisions of the same URL.  The last syntax shows
        how the working-copy argument is optional; if omitted, it
        defaults to the current directory.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.copychanges.bestprac"></a>Best Practices for Merging</h3></div></div></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.branchmerge.copychanges.bestprac.track"></a>Tracking Merges Manually</h4></div></div></div><p>Merging changes sounds simple enough, but in practice it
          can become a headache.  The problem is that if you
          repeatedly merge changes from one branch to another, you
          might accidentally merge the same change
          <span class="emphasis"><em>twice</em></span>.  When this happens, sometimes
          things will work fine.  When patching a file, Subversion
          typically notices if the file already has the change, and
          does nothing.  But if the already-existing change has been
          modified in any way, you'll get a conflict.</p><p>Ideally, your version control system should prevent the
          double-application of changes to a branch.  It should
          automatically remember which changes a branch has already
          received, and be able to list them for you.  It should use
          this information to help automate merges as much as
          possible.</p><p>Unfortunately, Subversion is not such a system.  Like
          CVS, Subversion does not yet record any information about
          merge operations.  When you commit local modifications, the
          repository has no idea whether those changes came from
          running <span><strong class="command">svn merge</strong></span>, or from just
          hand-editing the files.</p><p>What does this mean to you, the user?  It means that
          until the day Subversion grows this feature, you'll have to
          track merge information yourself.  The best place to do this
          is in the commit log-message.  As demonstrated in the
          earlier example, it's recommended that your log-message
          mention a specific revision number (or range of revisions)
          that are being merged into your branch.  Later on, you can
          run <span><strong class="command">svn log</strong></span> to review which changes your
          branch already contains.  This will allow you to carefully
          construct a subsequent <span><strong class="command">svn merge</strong></span> command
          that won't be redundant with previously ported
          changes.</p><p>In the next section, we'll show some examples of this
          technique in action.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.branchmerge.copychanges.bestprac.preview"></a>Previewing Merges</h4></div></div></div><p>Because merging only results in local modifications,
          it's not usually a high-risk operation.  If you get the
          merge wrong the first time, simply <span><strong class="command">svn
          revert</strong></span> the changes and try again.</p><p>It's possible, however, that your working copy might
          already have local modifications.  The changes applied by a
          merge will be mixed with your pre-existing ones, and running
          <span><strong class="command">svn revert</strong></span> is no longer an option.  The
          two sets of changes may be impossible to separate.</p><p>In cases like this, people take comfort in being able to
          predict or examine merges before they happen.  One simple
          way to do that is to run <span><strong class="command">svn diff</strong></span> with
          the same arguments you plan to pass to <span><strong class="command">svn
          merge</strong></span>, as we already showed in our first example
          of merging.  Another method of previewing is to pass the
          <code class="option">--dry-run</code> option to the merge
          command:</p><pre class="screen">
$ svn merge --dry-run -r 343:344 http://svn.example.com/repos/calc/trunk
U  integer.c

$ svn status
#  nothing printed, working copy is still unchanged.
</pre><p>The <code class="option">--dry-run</code> option doesn't actually
          apply any local changes to the working copy.  It only shows
          status codes that <span class="emphasis"><em>would</em></span> be printed in a
          real merge.  It's useful for getting a «<span class="quote">high
          level</span>» preview of the potential merge, for those
          times when running <span><strong class="command">svn diff</strong></span> gives too
          much detail.</p></div><div class="sidebar"><p class="title"><b>Subversion and Changesets</b></p><p>Everyone seems to have a slightly different definition
          of «<span class="quote">changeset</span>», or at least a different
          expectation of what it means for a version control system to
          have «<span class="quote">changeset features</span>».  For our purpose,
          let's say that a changeset is just a collection of changes
          with a unique name.  The changes might include textual edits
          to file contents, modifications to tree structure, or tweaks
          to metadata.  In more common speak, a changeset is just a
          patch with a name you can refer to.</p><p>In Subversion, a global revision number N names a tree
          in the repository: it's the way the repository looked after
          the Nth commit.  It's also the name of an implicit
          changeset: if you compare tree N with tree N-1, you can
          derive the exact patch that was committed.  For this reason,
          it's easy to think of «<span class="quote">revision N</span>» as not just
          a tree, but a changeset as well.  If you use an issue
          tracker to manage bugs, you can use the revision numbers to
          refer to particular patches that fix bugs—for example,
          «<span class="quote">this issue was fixed by revision 9238.</span>».
          Somebody can then run <span><strong class="command">svn log -r9238</strong></span> to
          read about the exact changeset which fixed the bug, and run
          <span><strong class="command">svn diff -r9237:9238</strong></span> to see the patch
          itself.  And Subversion's <code class="literal">merge</code> command
          also uses revision numbers.  You can merge specific changesets
          from one branch to another by naming them in the merge
          arguments: <span><strong class="command">svn merge -r9237:9238</strong></span> would
          merge changeset #9238 into your working copy.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.branchmerge.copychanges.bestprac.merge"></a>Merge Conflicts</h4></div></div></div><p>Just like the <span><strong class="command">svn update</strong></span> command,
          <span><strong class="command">svn merge</strong></span> applies changes to your working
          copy.  And therefore it's also capable of creating
          conflicts.  The conflicts produced by <span><strong class="command">svn
          merge</strong></span>, however, are sometimes different, and this
          section explains those differences.</p><p>To begin with, assume that your working copy has no
          local edits.  When you <span><strong class="command">svn update</strong></span> to a
          particular revision, the changes sent by the server will
          always apply «<span class="quote">cleanly</span>» to your working copy.
          The server produces the delta by comparing two trees: a
          virtual snapshot of your working copy, and the revision tree
          you're interested in.  Because the left-hand side of the
          comparison is exactly equal to what you already have, the
          delta is guaranteed to correctly convert your working copy
          into the right-hand tree.</p><p>But <span><strong class="command">svn merge</strong></span> has no such guarantees
          and can be much more chaotic: the user can ask the server to
          compare <span class="emphasis"><em>any</em></span> two trees at all, even ones
          that are unrelated to the working copy!  This means there's
          large potential for human error.  Users will sometimes
          compare the wrong two trees, creating a delta that doesn't
          apply cleanly.  <span><strong class="command">svn merge</strong></span> will do its
          best to apply as much of the delta as possible, but some
          parts may be impossible.  Just like the Unix
          <span><strong class="command">patch</strong></span> command sometimes complains about
          «<span class="quote">failed hunks</span>», <span><strong class="command">svn merge</strong></span>
          will complain about «<span class="quote">skipped targets</span>»:</p><pre class="screen">
$ svn merge -r 1288:1351 http://svn.example.com/repos/branch
U  foo.c
U  bar.c
Skipped missing target: 'baz.c'
U  glub.c
C  glorb.h

$
</pre><p>In the previous example it might be the case that
          <code class="filename">baz.c</code> exists in both snapshots of the
          branch being compared, and the resulting delta wants to
          change the file's contents, but the file doesn't exist in
          the working copy.  Whatever the case, the
          «<span class="quote">skipped</span>» message means that the user is most
          likely comparing the wrong two trees; they're the classic
          sign of driver error.  When this happens, it's easy to
          recursively revert all the changes created by the merge
          (<span><strong class="command">svn revert --recursive</strong></span>), delete any
          unversioned files or directories left behind after the
          revert, and re-run <span><strong class="command">svn merge</strong></span> with
          different arguments.</p><p>Also notice that the previous example shows a conflict
          happening on <code class="filename">glorb.h</code>.  We already
          stated that the working copy has no local edits: how can a
          conflict possibly happen?  Again, because the user can use
          <span><strong class="command">svn merge</strong></span> to define and apply any old
          delta to the working copy, that delta may contain textual
          changes that don't cleanly apply to a working file, even if
          the file has no local modifications.</p><p>Another small difference between <span><strong class="command">svn
          update</strong></span> and <span><strong class="command">svn merge</strong></span> are the
          names of the full-text files created when a conflict
          happens.  In <a href="svn.tour.cycle.html#svn.tour.cycle.resolve" title="Resolve Conflicts (Merging Others' Changes)">la sezione chiamata «Resolve Conflicts (Merging Others' Changes)»</a>, we saw
          that an update produces files named
          <code class="filename">filename.mine</code>,
          <code class="filename">filename.rOLDREV</code>, and
          <code class="filename">filename.rNEWREV</code>.  When <span><strong class="command">svn
          merge</strong></span> produces a conflict, though, it creates
          three files named <code class="filename">filename.working</code>,
          <code class="filename">filename.left</code>, and
          <code class="filename">filename.right</code>.  In this case, the
          terms «<span class="quote">left</span>» and «<span class="quote">right</span>» are
          describing which side of the double-tree comparison the file
          came from.  In any case, these differing names will help you
          distinguish between conflicts that happened as a result of an
          update versus ones that happened as a result of a
          merge.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.branchmerge.copychanges.bestprac.ancestry"></a>Noticing or Ignoring Ancestry</h4></div></div></div><p>When conversing with a Subversion developer, you might
          very likely hear reference to the term
          <em class="firstterm">ancestry</em>.  This word is used to
          describe the relationship between two objects in a
          repository: if they're related to each other, then one
          object is said to be an ancestor of the other.</p><p>For example, suppose you commit revision 100, which
          includes a change to a file <code class="filename">foo.c</code>.
          Then <code class="filename">foo.c@99</code> is an
          «<span class="quote">ancestor</span>» of <code class="filename">foo.c@100</code>.
          On the other hand, suppose you commit the deletion of
          <code class="filename">foo.c</code> in revision 101, and then add a
          new file by the same name in revision 102.  In this case,
          <code class="filename">foo.c@99</code> and
          <code class="filename">foo.c@102</code> may appear to be related
          (they have the same path), but in fact are completely
          different objects in the repository.  They share no history
          or «<span class="quote">ancestry</span>».</p><p>The reason for bringing this up is to point out an
          important difference between <span><strong class="command">svn diff</strong></span> and
          <span><strong class="command">svn merge</strong></span>.  The former command ignores
          ancestry, while the latter command is quite sensitive to it.
          For example, if you asked <span><strong class="command">svn diff</strong></span> to
          compare revisions 99 and 102 of <code class="filename">foo.c</code>,
          you would see line-based diffs; the <code class="literal">diff</code>
          command is blindly comparing two paths.  But if you asked
          <span><strong class="command">svn merge</strong></span> to compare the same two objects,
          it would notice that they're unrelated and first attempt to
          delete the old file, then add the new file;  the output would
          indicate a deletion followed by an add:</p><pre class="screen">
D  foo.c
A  foo.c
</pre><p>Most merges involve comparing trees that are ancestrally
          related to one another, and therefore <span><strong class="command">svn
          merge</strong></span> defaults to this behavior.  Occasionally,
          however, you may want the <code class="literal">merge</code> command to
          compare two unrelated trees.  For example, you may have
          imported two source-code trees representing different vendor
          releases of a software project (see <a href="svn.advanced.vendorbr.html" title="Vendor branches">la sezione chiamata «Vendor branches»</a>).
          If you asked <span><strong class="command">svn merge</strong></span> to compare the two
          trees, you'd see the entire first tree being deleted,
          followed by an add of the entire second tree!</p><p>In these situations, you'll want <span><strong class="command">svn
          merge</strong></span> to do a path-based comparison only, ignoring
          any relations between files and directories.  Add the
          <code class="option">--ignore-ancestry</code> option to your merge
          command, and it will behave just like <span><strong class="command">svn
          diff</strong></span>.  (And conversely, the
          <code class="option">--notice-ancestry</code> option will cause
          <span><strong class="command">svn diff</strong></span> to behave like the
          <code class="literal">merge</code> command.)</p></div></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.id4815623" href="#id4815623">11</a>] </sup>In the future, the Subversion project plans to use
              (or invent) an expanded patch format that describes
              changes in tree structure and properties.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="svn.branchmerge.using.html">Indietro</a> </td><td width="20%" align="center"><a accesskey="u" href="svn.branchmerge.html">Risali</a></td><td width="40%" align="right"> <a accesskey="n" href="svn.branchmerge.commonuses.html">Avanti</a></td></tr><tr><td width="40%" align="left" valign="top">Using Branches </td><td width="20%" align="center"><a accesskey="h" href="index.html">Partenza</a></td><td width="40%" align="right" valign="top"> Common Use-Cases</td></tr></table></div></body></html>
