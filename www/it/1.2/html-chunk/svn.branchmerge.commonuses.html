<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Common Use-Cases</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.70.1" /><link rel="start" href="index.html" title="Controllo di Versione con Subversion" /><link rel="up" href="svn.branchmerge.html" title="Capitolo 4. Branching and Merging" /><link rel="prev" href="svn.branchmerge.copychanges.html" title="Copying Changes Between Branches" /><link rel="next" href="svn.branchmerge.switchwc.html" title="Switching a Working Copy" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Common Use-Cases</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="svn.branchmerge.copychanges.html">Indietro</a> </td><th width="60%" align="center">Capitolo 4. Branching and Merging</th><td width="20%" align="right"> <a accesskey="n" href="svn.branchmerge.switchwc.html">Avanti</a></td></tr></table><hr /></div><div class="sect1" lang="it" xml:lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.branchmerge.commonuses"></a>Common Use-Cases</h2></div></div></div><p>There are many different uses for branching and <span><strong class="command">svn
      merge</strong></span>, and this section describes the most common ones
      you're likely to run into.</p><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.commonuses.wholebr"></a>Merging a Whole Branch to Another</h3></div></div></div><p>To complete our running example, we'll move forward in
        time.  Suppose several days have passed, and many changes have
        happened on both the trunk and your private branch.  Suppose
        that you've finished working on your private branch; the
        feature or bug fix is finally complete, and now you want to
        merge all of your branch changes back into the trunk for
        others to enjoy.</p><p>So how do we use <span><strong class="command">svn merge</strong></span> in this
        scenario?  Remember that this command compares two trees, and
        applies the differences to a working copy.  So to receive the
        changes, you need to have a working copy of the trunk.  We'll
        assume that either you still have your original one lying
        around (fully updated), or that you recently checked out a
        fresh working copy of <code class="filename">/calc/trunk</code>.</p><p>But which two trees should be compared?  At first glance,
        the answer may seem obvious: just compare the latest trunk
        tree with your latest branch tree.  But beware—this
        assumption is <span class="emphasis"><em>wrong</em></span>, and has burned many
        a new user!  Since <span><strong class="command">svn merge</strong></span> operates like
        <span><strong class="command">svn diff</strong></span>, comparing the latest trunk and 
        branch trees will <span class="emphasis"><em>not</em></span> merely describe
        the set of changes you made to your branch.  Such a comparison
        shows too many changes: it would not only show the addition of
        your branch changes, but also the <span class="emphasis"><em>removal</em></span>
        of trunk changes that never happened on your branch.</p><p>To express only the changes that happened on your branch,
        you need to compare the initial state of your branch to its
        final state.  Using <span><strong class="command">svn log</strong></span> on your branch,
        you can see that your branch was created in revision 341.  And
        the final state of your branch is simply a matter of using the
        <code class="literal">HEAD</code> revision.  That means you want to
        compare revisions 341 and <code class="literal">HEAD</code> of your
        branch directory, and apply those differences to a working
        copy of the trunk.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Suggerimento</h3><p>A nice way of finding the revision in which a branch was
          created (the «<span class="quote">base</span>» of the branch) is to use the
          <code class="option">--stop-on-copy</code> option to <span><strong class="command">svn
          log</strong></span>.  The log subcommand will normally show every
          change ever made to the branch, including tracing back
          through the copy which created the branch.  So normally,
          you'll see history from the trunk as well.  The
          <code class="option">--stop-on-copy</code> will halt log output as soon
          as <span><strong class="command">svn log</strong></span> detects that its target was
          copied or renamed.</p><p>So in our continuing example,</p><pre class="screen">
$ svn log --verbose --stop-on-copy \
          http://svn.example.com/repos/calc/branches/my-calc-branch
…
------------------------------------------------------------------------
r341 | user | 2002-11-03 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)

$
</pre><p>As expected, the final revision printed by this command
          is the revision in which <code class="filename">my-calc-branch</code>
          was created by copying.</p></div><p>Here's the final merging procedure, then:</p><pre class="screen">
$ cd calc/trunk
$ svn update
At revision 405.

$ svn merge -r 341:405 http://svn.example.com/repos/calc/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile

$ svn status
M   integer.c
M   button.c
M   Makefile

# ...examine the diffs, compile, test, etc...

$ svn commit -m "Merged my-calc-branch changes r341:405 into the trunk."
Sending        integer.c
Sending        button.c
Sending        Makefile
Transmitting file data ...
Committed revision 406.
</pre><p>Again, notice that the commit log message very
        specifically mentions the range of changes that was merged
        into the trunk.  Always remember to do this, because it's
        critical information you'll need later on.</p><p>For example, suppose you decide to keep working on your
        branch for another week, in order to complete an enhancement
        to your original feature or bug fix.  The repository's
        <code class="literal">HEAD</code> revision is now 480, and you're ready
        to do another merge from your private branch to the trunk.
        But as discussed in <a href="svn.branchmerge.copychanges.html#svn.branchmerge.copychanges.bestprac" title="Best Practices for Merging">la sezione chiamata «Best Practices for Merging»</a>, you
        don't want to merge the changes you've already merged before;
        you only want to merge everything «<span class="quote">new</span>» on your
        branch since the last time you merged.  The trick is to figure
        out what's new.</p><p>The first step is to run <span><strong class="command">svn log</strong></span> on the
        trunk, and look for a log message about the last time you
        merged from the branch:</p><pre class="screen">
$ cd calc/trunk
$ svn log
…
------------------------------------------------------------------------
r406 | user | 2004-02-08 11:17:26 -0600 (Sun, 08 Feb 2004) | 1 line

Merged my-calc-branch changes r341:405 into the trunk.
------------------------------------------------------------------------
…
</pre><p>Aha!  Since all branch-changes that happened between
        revisions 341 and 405 were previously merged to the trunk as
        revision 406, you now know that you want to merge only the
        branch changes after that—by comparing revisions 406 and
        <code class="literal">HEAD</code>.</p><pre class="screen">
$ cd calc/trunk
$ svn update
At revision 480.

# We notice that HEAD is currently 480, so we use it to do the merge:

$ svn merge -r 406:480 http://svn.example.com/repos/calc/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile

$ svn commit -m "Merged my-calc-branch changes r406:480 into the trunk."
Sending        integer.c
Sending        button.c
Sending        Makefile
Transmitting file data ...
Committed revision 481.
</pre><p>Now the trunk contains the complete second wave of changes
        made to the branch.  At this point, you can either delete your
        branch (we'll discuss this later on), or continue working on
        your branch and repeat this procedure for subsequent
        merges.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.commonuses.undo"></a>Undoing Changes</h3></div></div></div><p>Another common use for <span><strong class="command">svn merge</strong></span> is to
        roll back a change that has already been committed.  Suppose
        you're working away happily on a working copy of
        <code class="filename">/calc/trunk</code>, and you discover that the
        change made way back in revision 303, which changed
        <code class="filename">integer.c</code>, is completely wrong.  It never
        should have been committed.  You can use <span><strong class="command">svn
        merge</strong></span> to «<span class="quote">undo</span>» the change in your
        working copy, and then commit the local modification to the
        repository.  All you need to do is to specify a
        <span class="emphasis"><em>reverse</em></span> difference:</p><pre class="screen">
$ svn merge -r 303:302 http://svn.example.com/repos/calc/trunk
U  integer.c

$ svn status
M  integer.c

$ svn diff
…
# verify that the change is removed
…

$ svn commit -m "Undoing change committed in r303."
Sending        integer.c
Transmitting file data .
Committed revision 350.
</pre><p>One way to think about a repository revision is as a
        specific group of changes (some version control systems call
        these <em class="firstterm">changesets</em>).  By using the
        <code class="option">-r</code> switch, you can ask <span><strong class="command">svn
        merge</strong></span> to apply a changeset, or whole range of
        changesets, to your working copy.  In our case of undoing a
        change, we're asking <span><strong class="command">svn merge</strong></span> to apply
        changeset #303 to our working copy
        <span class="emphasis"><em>backwards</em></span>.</p><p>Keep in mind that rolling back a change like this is just
        like any other <span><strong class="command">svn merge</strong></span> operation, so you
        should use <span><strong class="command">svn status</strong></span> and <span><strong class="command">svn
        diff</strong></span> to confirm that your work is in the state you
        want it to be in, and then use <span><strong class="command">svn commit</strong></span>
        to send the final version to the repository.  After
        committing, this particular changeset is no longer reflected
        in the <code class="literal">HEAD</code> revision.</p><p>Again, you may be thinking: well, that really didn't undo
        the commit, did it?  The change still exists in revision 303.
        If somebody checks out a version of the
        <code class="filename">calc</code> project between revisions 303 and
        349, they'll still see the bad change, right?</p><p>Yes, that's true.  When we talk about
        «<span class="quote">removing</span>» a change, we're really talking about
        removing it from <code class="literal">HEAD</code>.  The original change
        still exists in the repository's history.  For most
        situations, this is good enough.  Most people are only
        interested in tracking the <code class="literal">HEAD</code> of a
        project anyway.  There are special cases, however, where you
        really might want to destroy all evidence of the commit.
        (Perhaps somebody accidentally committed a confidential
        document.)  This isn't so easy, it turns out, because
        Subversion was deliberately designed to never lose
        information.  Revisions are immutable trees which build upon
        one another.  Removing a revision from history would cause a
        domino effect, creating chaos in all subsequent revisions and
        possibly invalidating all working copies.
        <sup>[<a id="id4817420" href="#ftn.id4817420">12</a>]</sup>
      </p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.commonuses.resurrect"></a>Resurrecting Deleted Items</h3></div></div></div><p>The great thing about version control systems is that
        information is never lost.  Even when you delete a file or
        directory, it may be gone from the <code class="literal">HEAD</code>
        revision, but the object still exists in earlier revisions.
        One of the most common questions new users ask is, «<span class="quote">How
        do I get my old file or directory back?</span>».</p><p>The first step is to define exactly <span class="bold"><strong>which</strong></span> item you're trying to resurrect.
        Here's a useful metaphor: you can think of every object in the
        repository as existing in a sort of two-dimensional coordinate
        system.  The first coordinate is a particular revision tree,
        and the second coordinate is a path within that tree.  So
        every version of your file or directory can be defined by a
        specific coordinate pair.</p><p>Subversion has no <code class="filename">Attic</code> directory
        like CVS does,
        <sup>[<a id="id4817516" href="#ftn.id4817516">13</a>]</sup>
        so you need to use <span><strong class="command">svn
        log</strong></span> to discover the exact coordinate pair you wish
        to resurrect.  A good strategy is to run <span><strong class="command">svn log
        --verbose</strong></span> in a directory which used to contain your
        deleted item.  The <code class="option">--verbose</code> option shows a
        list of all changed items in each revision; all you need to do
        is find the revision in which you deleted the file or
        directory.  You can do this visually, or by using another tool
        to examine the log output (via <span><strong class="command">grep</strong></span>, or
        perhaps via an incremental search in an editor).</p><pre class="screen">
$ cd parent-dir
$ svn log --verbose
…
------------------------------------------------------------------------
r808 | joe | 2003-12-26 14:29:40 -0600 (Fri, 26 Dec 2003) | 3 lines
Changed paths:
   D /calc/trunk/real.c
   M /calc/trunk/integer.c

Added fast fourier transform functions to integer.c.
Removed real.c because code now in double.c.
…
</pre><p>In the example, we're assuming that you're looking for a
        deleted file <code class="filename">real.c</code>.  By looking through
        the logs of a parent directory, you've spotted that this file
        was deleted in revision 808.  Therefore, the last version of
        the file to exist was in the revision right before that.
        Conclusion: you want to resurrect the path
        <code class="filename">/calc/trunk/real.c</code> from revision
        807.</p><p>That was the hard part—the research.  Now that you
        know what you want to restore, you have two different
        choices.</p><p>One option is to use <span><strong class="command">svn merge</strong></span> to apply
        revision 808 «<span class="quote">in reverse</span>».  (We've already
        discussed how to undo changes, see <a href="svn.branchmerge.commonuses.html#svn.branchmerge.commonuses.undo" title="Undoing Changes">la sezione chiamata «Undoing Changes»</a>.)  This would have the effect of
        re-adding <code class="filename">real.c</code> as a local modification.
        The file would be scheduled for addition, and after a commit,
        the file would again exist in <code class="literal">HEAD</code>.</p><p>In this particular example, however, this is probably not
        the best strategy.  Reverse-applying revision 808 would not
        only schedule <code class="filename">real.c</code> for addition, but
        the log message indicates that it would also undo certain
        changes to <code class="filename">integer.c</code>, which you don't
        want.  Certainly, you could reverse-merge revision 808 and
        then <span><strong class="command">svn revert</strong></span> the local modifications to
        <code class="filename">integer.c</code>, but this technique doesn't
        scale well.  What if there were 90 files changed in revision
        808?</p><p>A second, more targeted strategy is not to use
        <span><strong class="command">svn merge</strong></span> at all, but rather the
        <span><strong class="command">svn copy</strong></span> command.  Simply copy the exact
        revision and path «<span class="quote">coordinate pair</span>» from the
        repository to your working copy:</p><pre class="screen">
$ svn copy --revision 807 \
           http://svn.example.com/repos/calc/trunk/real.c ./real.c

$ svn status
A  +   real.c

$ svn commit -m "Resurrected real.c from revision 807, /calc/trunk/real.c."
Adding         real.c
Transmitting file data .
Committed revision 1390.
</pre><p>The plus sign in the status output indicates that the item
        isn't merely scheduled for addition, but scheduled for
        addition «<span class="quote">with history</span>».  Subversion remembers
        where it was copied from.  In the future, running <span><strong class="command">svn
        log</strong></span> on this file will traverse back through the
        file's resurrection and through all the history it had prior
        to revision 807.  In other words, this new
        <code class="filename">real.c</code> isn't really new; it's a direct
        descendant of the original, deleted file.</p><p>Although our example shows us resurrecting a file, note
        that these same techniques work just as well for resurrecting
        deleted directories.</p></div><div class="sect2" lang="it" xml:lang="it"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.commonuses.patterns"></a>Common Branching Patterns</h3></div></div></div><p>Version control is most often used for software
        development, so here's a quick peek at two of the most common
        branching/merging patterns used by teams of programmers.  If
        you're not using Subversion for software development, feel
        free to skip this section.  If you're a software developer
        using version control for the first time, pay close attention,
        as these patterns are often considered best practices by
        experienced folk.  These processes aren't specific to
        Subversion; they're applicable to any version control system.
        Still, it may help to see them described in Subversion
        terms.</p><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.branchmerge.commonuses.patterns.release"></a>Release Branches</h4></div></div></div><p>Most software has a typical lifecycle: code, test,
          release, repeat.  There are two problems with this process.
          First, developers need to keep writing new features while
          quality-assurance teams take time to test supposedly-stable
          versions of the software.  New work cannot halt while the
          software is tested.  Second, the team almost always needs to
          support older, released versions of software; if a bug is
          discovered in the latest code, it most likely exists in
          released versions as well, and customers will want to get
          that bugfix without having to wait for a major new
          release.</p><p>Here's where version control can help.  The typical
          procedure looks like this:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Developers commit all new work to the
                trunk.</em></span>

              Day-to-day changes are committed to
              <code class="filename">/trunk</code>: new features, bugfixes, and
              so on.</p></li><li><p><span class="emphasis"><em>The trunk is copied to a
                «<span class="quote">release</span>» branch.</em></span>

              When the team thinks the software is ready for release
              (say, a 1.0 release), then <code class="filename">/trunk</code>
              might be copied to
              <code class="filename">/branches/1.0</code>.</p></li><li><p><span class="emphasis"><em>Teams continue to work in parallel.</em></span>

              One team begins rigorous testing of the release branch,
              while another team continues new work (say, for version
              2.0) on <code class="filename">/trunk</code>.  If bugs are
              discovered in either location, fixes are ported back and
              forth as necessary.  At some point, however, even that
              process stops.  The branch is «<span class="quote">frozen</span>» for
              final testing right before a release.</p></li><li><p><span class="emphasis"><em>The branch is tagged and released.</em></span>

              When testing is complete,
              <code class="filename">/branches/1.0</code> is copied to
              <code class="filename">/tags/1.0.0</code> as a reference
              snapshot.  The tag is packaged and released to
              customers.</p></li><li><p><span class="emphasis"><em>The branch is maintained over time.</em></span>

              While work continues on <code class="filename">/trunk</code> for
              version 2.0, bugfixes continue to be ported from
              <code class="filename">/trunk</code> to
              <code class="filename">/branches/1.0</code>.  When enough
              bugfixes have accumulated, management may decide to do a
              1.0.1 release: <code class="filename">/branches/1.0</code> is
              copied to <code class="filename">/tags/1.0.1</code>, and the tag
              is packaged and released.</p></li></ul></div><p>This entire process repeats as the software matures:
          when the 2.0 work is complete, a new 2.0 release branch is
          created, tested, tagged, and eventually released.  After
          some years, the repository ends up with a number of release
          branches in «<span class="quote">maintenance</span>» mode, and a number
          of tags representing final shipped versions.</p></div><div class="sect3" lang="it" xml:lang="it"><div class="titlepage"><div><div><h4 class="title"><a id="svn.branchmerge.commonuses.patterns.feature"></a>Feature Branches</h4></div></div></div><p>A <em class="firstterm">feature branch</em> is the sort of
          branch that's been the dominant example in this chapter, the
          one you've been working on while Sally continues to work on
          <code class="filename">/trunk</code>.  It's a temporary branch
          created to work on a complex change without interfering with
          the stability of <code class="filename">/trunk</code>.  Unlike
          release branches (which may need to be supported forever),
          feature branches are born, used for a while, merged back to
          the trunk, then ultimately deleted.  They have a finite span
          of usefulness.</p><p>Again, project policies vary widely concerning exactly
          when it's appropriate to create a feature branch.  Some
          projects never use feature branches at all: commits to
          <code class="filename">/trunk</code> are a free-for-all.  The
          advantage to this system is that it's simple—nobody
          needs to learn about branching or merging.  The disadvantage
          is that the trunk code is often unstable or unusable.  Other
          projects use branches to an extreme: no change is
          <span class="emphasis"><em>ever</em></span> committed to the trunk directly.
          Even the most trivial changes are created on a short-lived
          branch, carefully reviewed and merged to the trunk.  Then
          the branch is deleted.  This system guarantees an
          exceptionally stable and usable trunk at all times, but at
          the cost of tremendous process overhead.</p><p>Most projects take a middle-of-the-road approach.  They
          commonly insist that <code class="filename">/trunk</code> compile and
          pass regression tests at all times.  A feature branch is
          only required when a change requires a large number of
          destabilizing commits.  A good rule of thumb is to ask this
          question: if the developer worked for days in isolation and
          then committed the large change all at once (so that
          <code class="filename">/trunk</code> were never destabilized), would
          it be too large a change to review?  If the answer to that
          question is «<span class="quote">yes</span>», then the change should be
          developed on a feature branch.  As the developer commits
          incremental changes to the branch, they can be easily
          reviewed by peers.</p><p>Finally, there's the issue of how to best keep a feature
          branch in «<span class="quote">sync</span>» with the trunk as work
          progresses.  As we mentioned earlier, there's a great risk
          to working on a branch for weeks or months; trunk changes
          may continue to pour in, to the point where the two lines of
          development differ so greatly that it may become a nightmare
          trying to merge the branch back to the trunk.</p><p>This situation is best avoided by regularly merging
          trunk changes to the branch.  Make up a policy: once a week,
          merge the last week's worth of trunk changes to the branch.
          Take care when doing this; the merging needs to be
          hand-tracked to avoid the problem of repeated merges (as
          described in <a href="svn.branchmerge.copychanges.html#svn.branchmerge.copychanges.bestprac.track" title="Tracking Merges Manually">la sezione chiamata «Tracking Merges Manually»</a>).  You'll
          need to write careful log messages detailing exactly which
          revision ranges have been merged already (as
          demonstrated in <a href="svn.branchmerge.commonuses.html#svn.branchmerge.commonuses.wholebr" title="Merging a Whole Branch to Another">la sezione chiamata «Merging a Whole Branch to Another»</a>).  It
          may sound intimidating, but it's actually pretty easy to
          do.</p><p>At some point, you'll be ready to merge the
          «<span class="quote">synchronized</span>» feature branch back to the
          trunk.  To do this, begin by doing a final merge of the
          latest trunk changes to the branch.  When that's done, the
          latest versions of branch and trunk will be absolutely
          identical except for your branch changes.  So in this
          special case, you would merge by comparing the branch with
          the trunk:</p><pre class="screen">
$ cd trunk-working-copy

$ svn update
At revision 1910.

$ svn merge http://svn.example.com/repos/calc/trunk@1910 \
            http://svn.example.com/repos/calc/branches/mybranch@1910
U  real.c
U  integer.c
A  newdirectory
A  newdirectory/newfile
…
</pre><p>By comparing the <code class="literal">HEAD</code> revision of the
          trunk with the <code class="literal">HEAD</code> revision of the
          branch, you're defining a delta that describes only the
          changes you made to the branch; both lines of development
          already have all of the trunk changes.</p><p>Another way of thinking about this pattern is that your
          weekly sync of trunk to branch is analogous to running
          <span><strong class="command">svn update</strong></span> in a working copy, while the
          final merge step is analogous to running <span><strong class="command">svn
          commit</strong></span> from a working copy.  After all, what else
          <span class="emphasis"><em>is</em></span> a working copy but a very shallow
          private branch?  It's a branch that's only capable of
          storing one change at a time.</p></div></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.id4817420" href="#id4817420">12</a>] </sup>The Subversion project has plans, however, to someday
            implement an <span><strong class="command">svnadmin obliterate</strong></span>
            command that would accomplish the task of permanently
            deleting information.  In the meantime, see <a href="svn.reposadmin.maint.html#svn.reposadmin.maint.tk.svndumpfilter" title="svndumpfilter">la sezione chiamata «svndumpfilter»</a> for a possible
            workaround.</p></div><div class="footnote"><p><sup>[<a id="ftn.id4817516" href="#id4817516">13</a>] </sup>Because CVS doesn't version trees, it creates an
            <code class="filename">Attic</code> area within each repository
            directory as a way of remembering deleted files.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="svn.branchmerge.copychanges.html">Indietro</a> </td><td width="20%" align="center"><a accesskey="u" href="svn.branchmerge.html">Risali</a></td><td width="40%" align="right"> <a accesskey="n" href="svn.branchmerge.switchwc.html">Avanti</a></td></tr><tr><td width="40%" align="left" valign="top">Copying Changes Between Branches </td><td width="20%" align="center"><a accesskey="h" href="index.html">Partenza</a></td><td width="40%" align="right" valign="top"> Switching a Working Copy</td></tr></table></div></body></html>
