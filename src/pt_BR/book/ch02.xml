<chapter id="svn.basic">
  <title>Conceitos Básicos</title>

  <simplesect>
    <para>Este capítulo é uma breve e casual introdução ao Subversion.
      Se você é um principiante em relação ao tema controle de versão,
      este capítulo é definitivamente escrito para você. Começaremos
      discutindo as máximas sobre controle de versão, seguiremos com
      os conceitos específicos por trás do Subversion, e mostraremos
      alguns exemplos simples dele em ação.</para>
    
    <para>Embora os exemplos deste capítulo mostrem pessoas
      compartilhando coleções de código-fonte, tenha em mente que o
      Subversion pode gerenciar qualquer coleção de arquivos&mdash;não
      é destinado apenas aos programadores de sistemas de
      computador.</para>
  </simplesect>
  
  
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.repository">
    <title>O Repositório</title>  
    
    <para>O Subversion é um sistema centralizado para compartilhamento de
      informações. Em seu núcleo está o repositório, o qual é um centro
      armazenador de dados. O repositório guarda as informações na
      forma de uma <firstterm>árvore de sistema de arquivos</firstterm>
      &mdash;uma típica hierarquia de arquivos e diretórios. Qualquer
      número de <firstterm>clientes</firstterm> se conecta ao repositório para
      ler e escrever nesses arquivos. Ao escrever dados, um cliente coloca as
      informações disponíveis para os outros; ao ler dados, ele recebe as
      informações de outros clientes. <xref
      linkend="svn.basic.repository.dia-1"/> ilustra isso.</para>

    <figure id="svn.basic.repository.dia-1">
      <title>Um sistema cliente/servidor típico</title>
      <graphic fileref="images/ch02dia1.png"/>
    </figure>
    
    <para>Mas o que isso tem de interessante? Olhando assim, parece a
      definição de um simples servidor de arquivos. E, claramente, o
      repositório <emphasis>é</emphasis> um tipo de servidor de arquivos,
      mas é mais do que isso. O que o faz especial é a sua <emphasis>capacidade
      de lembrar todas as alterações</emphasis> feitas nele: qualquer
      modificação nos arquivos, inclusive na árvore de diretórios, como
      adição, remoção e reorganização dos mesmos.</para>

    <para>Quando um cliente lê dados do repositório, normalmente vê
      apenas a última versão gravada na árvore do sistema de arquivos.
      Mas também tem a possibilidade de ver quaisquer dos estados
      <emphasis>anteriores</emphasis>. Por exemplo, pode-se fazer
      perguntas ao histórico como, <quote>o que este diretório continha na
      última quarta-feira?</quote> ou <quote>quem foi a última pessoa que alterou
      este arquivo, e que mudanças fez?</quote> Esses são os tipos de perguntas
      que podem ser feitas a qualquer <firstterm>sistema de controle de
      versão</firstterm>: sistemas projetados para guardar e rastrear
      alterações de dados ao longo do tempo.</para>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.vsn-models">
    <title>Modelos de Controle de Versão</title>

    <para>A principal missão de um sistema de controle de versão é 
      permitir a edição colaborativa e o compartilhamento de dados. Mas
      diferentes sistemas usam diferentes estratégias para alcançar isso.</para>
    
    <!-- =============================================================== -->
    <sect2 id="svn.basic.vsn-models.problem-sharing">
      <title>O Problema de Compartilhar Arquivos</title>
      
      <para>Todo sistema de controle de versão tem que resolver o mesmo
        problema fundamental: como permitir que os usuários tenham
        acesso às informações garantindo que não se atrapalhem
        mutuamente? É muito fácil sobrescrever acidentalmente as
        alterações enviadas por outros ao repositório.</para>

      <para>Considere a situação mostrada em <xref
        linkend="svn.basic.vsn-models.problem-sharing.dia-1"/>.
        Suponha dois co-editores, Harry e Sally. Ambos decidem editar o
        mesmo arquivo armazenado, ao mesmo tempo. Se Harry salva sua
        alteração primeiro, então é possível que (a qualquer momento)
        Sally a sobrescreva acidentalmente com sua própria versão do
        arquivo. Enquanto a versão de Harry não será perdida para
        sempre (porque o sistema se lembra de qualquer mudança), essas
        alterações <emphasis>não</emphasis> fazem parte da versão de
        Sally, porque simplesmente não existiam quando ela obteve o
        arquivo. O trabalho de Harry está efetivamente perdido&mdash;ou
        pelo menos não consta na última versão&mdash;e provavelmente por
        acidente. Essa é definitivamente uma situação que nós desejamos
        evitar!</para>

      <figure id="svn.basic.vsn-models.problem-sharing.dia-1">
        <title>O problema a se evitar</title>
        <graphic fileref="images/ch02dia2.png"/>
      </figure>

      </sect2>
    
    <!-- =============================================================== -->
    <sect2 id="svn.basic.vsn-models.lock-unlock">
      <title>A Solução Travar-Modificar-Destravar</title>
      
      <para>Muitos sistemas de controle de versão usam o modelo
        <firstterm>travar-modificar-destravar</firstterm>
        (<firstterm>lock-modify-unlock</firstterm>, em inglês) destinado
        a evitar o problema de autores terem seus trabalhos sobrescritos
        por terceiros. Nesse modelo, o repositório permite um arquivo
        ser editado apenas por uma pessoa de cada vez. Essa ação de
        exclusividade é conseguida através de travas. Harry deve
        <quote>travar</quote> um arquivo antes de começar a alterá-lo.
        Se Harry está com este arquivo travado, então Sally não poderá
        travá-lo, e nem alterá-lo. Tudo o que ela pode fazer é ler o
        arquivo, e esperar que Harry termine sua edição e o destrave.
        Depois que Harry liberou o arquivo, Sally pode travar e
        alterar o mesmo. <xref
        linkend="svn.basic.vsn-models.lock-unlock.dia-1"/>
        demonstra esta simples solução.</para>
      
      <figure id="svn.basic.vsn-models.lock-unlock.dia-1">
        <title>A Solução travar-modificar-destravar</title>
        <graphic fileref="images/ch02dia3.png"/>
      </figure>
      
      <para>O problema do modelo travar-modificar-destravar
        é ser muito restritivo, o que acaba sendo uma barreira para os
        usuários:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>A trava pode causar problemas administrativos.
            </emphasis>

            Às vezes, Harry travará um arquivo e se esquecerá disso.
            Enquanto isso, Sally está esperando para editá-lo, de mãos
            atadas. E então Harry sai de férias. Agora Sally tem que
            procurar um administrador do sistema para liberar o arquivo
            travado por Harry. A situação acaba causando atraso desnecessário
            e perda de tempo.</para>
        </listitem>
        
        <listitem>
          <!-- TODO: Colocar nota de rodapé esclarecendo o que é sistematização neste contexto. -->
          <para><emphasis>A trava pode causar sistematização
            desnecessária.</emphasis>

            E se Harry estiver editando o começo de um texto e Sally
            simplesmente deseja alterar o final do mesmo arquivo? Essas
            mudanças não se sobrepõem. Eles poderiam facilmente
            alterá-lo simultaneamente e nenhum grande dano aconteceria,
            assumindo que as mudanças foram corretamente fundidas. Não
            há necessidade alguma de cada um esperar a sua vez de alterar
            o arquivo nessa situação.</para>
        </listitem>

        <listitem>
          <para><emphasis>A trava pode causar um falso senso de
            segurança</emphasis>

            Imagine Harry travando e editando o arquivo A, enquanto
            simultaneamente Sally trava e edita o arquivo B. Também
            suponha que os arquivos A e B são dependentes entre si e que
            as mudanças feitas a cada um deles são semanticamente
            imcompatíveis. De repente, A e B não mais funcionam juntos.
            O sistema de travamento não foi capaz de impedir o problema
            &mdash;contudo, forneceu, de algum modo, um falso senso de
            segurança. É fácil para Harry e Sally imaginarem que,
            travando os arquivos, estarão a salvo, cada um com sua
            tarefa isolada e não se preocupando em discutir suas
            alterações incompatíveis antecipadamente.</para>
        </listitem>
      </itemizedlist>

      </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.vsn-models.copy-merge">
      <title>A Solução Copiar-Modificar-Fundir</title>
      
      <para>Subversion, CVS e outros sistemas de controle de versão usam
        o modelo <firstterm>Copiar-Modificar-Fundir</firstterm>
        (<firstterm>copy-modify-merge</firstterm>, em inglês) como uma
        alternativa ao sistema detravamento. Nesse modelo, cada cliente
        de usuário contata o repositório e cria uma <firstterm>cópia de
        trabalho</firstterm> (<firstterm>working copy</firstterm>, em
        inglês) pessoal&mdash;uma réplica local dos arquivos e
        diretórios do repositório. Os usuários trabalham então em
        paralelo, modificando suas cópias particulares. Finalmente, as
        cópias particulares são fundidas em uma nova versão final. O sistema
        de controle de versão frequentemente auxilia na fusão, mas o ser
        humano é o responsável de fazê-la funcionar corretamente.</para>
      
      <para>Aqui está um exemplo. Diga para Harry e Sally
        criarem cópias de trabalho do mesmo projeto, trazidas do
        repositório. Ambos trabalham simultaneamente e fazem mudanças no
        mesmo arquivo A em suas cópias. Sally envia suas mudanças ao
        repositório primeiro. Quando Harry tenta salvar mais tarde as
        suas, é informado que o arquivo A está <firstterm>
        desatualizado</firstterm> (<firstterm>out-of-date</firstterm>,
        em inglês). Ou seja, o arquivo A no repositório foi de alguma
        forma alterado desde quando foi copiado. Assim, Harry solicita ao
        seu cliente para <firstterm>fundir</firstterm> (<firstterm>merge
        </firstterm>, em inglês) todas as novas mudanças no repositório
        em sua cópia de trabalho do arquivo A. Grandes são as chances de
        as alterações de Sally não sobreporem as de Harry; uma vez que
        ambos os conjuntos de mudanças estão integrados, ele salva sua cópia de
        trabalho no repositório. <xref
        linkend="svn.basic.vsn-models.copy-merge.dia-1"/> e 
        <xref linkend="svn.basic.vsn-models.copy-merge.dia-2"/>
        demonstra esse processo.</para>

      <figure id="svn.basic.vsn-models.copy-merge.dia-1">
        <title>A solução copiar-modificar-fundir</title>
        <graphic fileref="images/ch02dia4.png"/>
      </figure>
      
      <figure id="svn.basic.vsn-models.copy-merge.dia-2">
        <title>A solução copiar-modificar-fundir
        (continuação)</title>
        <graphic fileref="images/ch02dia5.png"/>
      </figure>

      <para>Mas e se as mudanças de Sally <emphasis>sobrepuserem
        </emphasis> as de Harry? E então? Essa situação é chamada de
        <firstterm>conflito</firstterm> (<firstterm>conflict
        </firstterm>, em inglês) e geralmente não é um muito
        problemática. Quando Harry pede ao seu cliente para fundir as
        últimas alterações do repositório em sua cópia de trabalho, sua
        cópia do arquivo A é de algum modo marcada como em estado de
        conflito: ele poderá ver ambos os conjuntos de mudanças conflitantes
        e escolher manualmente entre eles. Note que o <foreignphrase>software
        </foreignphrase> não pode resolver automaticamente os conflitos;
        apenas os seres humanos são capazes de compreender e de fazerem
        as escolhas necessárias com inteligência. Uma vez que Harry
        resolveu manualmente as sobreposições&mdash;talvez após uma
        conversa com Sally&mdash;pôde salvar com segurança o arquivo
        fundido no repositório.</para>

      <para>O modelo copiar-modificar-fundir pode
        parecer um tanto confuso, mas na prática funciona extremamente
        bem. Os usuários podem trabalhar em paralelo, não tendo que
        esperar um pelo outro. Quando trabalham com os mesmos
        arquivos, a maioria das mudanças não se sobrepõem de modo algum; conflitos
        são infrequentes. E o tempo gasto para resolver conflitos é bem
        menor que o tempo perdido em um sistema de travamento.</para>

      <para>No final, tudo gira em torno de um fator crítico:
        comunicação entre usuários. Quando os usuários se comunicam mal,
        os conflitos sintáticos e semânticos são mais frequentes. Nenhum
        sistema pode forçar seus usuários a se comunicarem bem, e nem
        detectar conflitos semânticos. Sendo assim, não há sentido algum
        em deixar-se iludir por uma falsa promessa de que um sistema
        baseado em travas possa impedir de algum modo os conflitos; na
        prática, travar parece inibir a produtividade mais do que
        qualquer outra coisa.</para>
      
      <sidebar id="svn.basic.vsn-models.copy-merge.sb-1">
        <title>Quando o Travamento é Necesário</title>
        
        <para>Mesmo o modelo travar-modificar-destravar
          sendo considerado geralmente prejudicial ao trabalho
          colaborativo, há momentos em que ele é apropriado.</para>

        <para>O modelo <emphasis>copy-modify-merge</emphasis> é baseado
          na suposição de que os arquivos são contextualmente passíveis
          de fusão: isso é, que a maioria dos arquivos no repositório
          são do tipo texto puro (como os códigos-fonte de programas).
          Mas em arquivos de formato binário, como os de arte-final e
          de som, é frequentemente impossível fundir mudanças conflitantes.
          Nesses casos, é realmente necessário que os usuários estritamente
          esperem cada um a sua vez de alterar o arquivo.
          <!-- TODO: Colocar nota de rodapé esclarecendo o que é sistematização neste contexto. -->
          Sem um acesso sistematizado, alguém acaba por desperdiçar
          tempo em mudanças que serão finalmente rejeitadas.</para>

        <para>Mesmo CVS e Subversion sendo principalmente sistemas do
          tipo copiar-modificar-fundir, ambos reconhecem
          a necessidade de se travar um arquivo ocasionalmente e
          oferecem mecanismos para isso. Veja <xref 
          linkend="svn.advanced.locking"/>.</para>

      </sidebar>


    </sect2>
    
  </sect1>
  
  <!-- How svn implements the philosophy -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.in-action">
    <title>Subversion in Action</title>
    
    <para>It's time to move from the abstract to the concrete.  In
      this section, we'll show real examples of Subversion being
      used.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.wc">
      <title>Working Copies</title>
      
      <para>You've already read about working copies; now we'll
        demonstrate how the Subversion client creates and uses
        them.</para>
      
      <para>A Subversion working copy is an ordinary directory tree on
        your local system, containing a collection of files.  You can
        edit these files however you wish, and if they're source code
        files, you can compile your program from them in the usual
        way.  Your working copy is your own private work area:
        Subversion will never incorporate other people's changes, nor
        make your own changes available to others, until you
        explicitly tell it to do so.  You can even have multiple
        working copies of the same project.</para>

      <para>After you've made some changes to the files in your
        working copy and verified that they work properly, Subversion
        provides you with commands to <quote>publish</quote> your
        changes to the other people working with you on your project
        (by writing to the repository).  If other people publish their
        own changes, Subversion provides you with commands to merge
        those changes into your working directory (by reading from the
        repository).</para>

      <para>A working copy also contains some extra files, created and
        maintained by Subversion, to help it carry out these commands.
        In particular, each directory in your working copy contains a
        subdirectory named <filename>.svn</filename>, also known as
        the working copy <firstterm>administrative
        directory</firstterm>.  The files in each administrative
        directory help Subversion recognize which files contain
        unpublished changes, and which files are out-of-date with
        respect to others' work.</para>
      
      <para>A typical Subversion repository often holds the files (or
        source code) for several projects; usually, each project is a
        subdirectory in the repository's filesystem tree.  In this
        arrangement, a user's working copy will usually correspond to
        a particular subtree of the repository.</para>
      
      <para>For example, suppose you have a repository that contains
        two software projects, <literal>paint</literal> and
        <literal>calc</literal>.  Each project lives in its own
        top-level subdirectory, as shown in <xref
        linkend="svn.basic.in-action.wc.dia-1"/>.</para>

      <figure id="svn.basic.in-action.wc.dia-1">
        <title>The repository's filesystem</title>
        <graphic fileref="images/ch02dia6.png"/>
      </figure>
      
      <para>To get a working copy, you must <firstterm>check
        out</firstterm> some subtree of the repository.  (The term
        <quote>check out</quote> may sound like it has something to do
        with locking or reserving resources, but it doesn't; it simply
        creates a private copy of the project for you.) For example,
        if you check out <filename>/calc</filename>, you will get a
        working copy like this:</para>

      <screen>
$ svn checkout http://svn.example.com/repos/calc
A    calc/Makefile
A    calc/integer.c
A    calc/button.c
Checked out revision 56.

$ ls -A calc
Makefile  integer.c  button.c  .svn/
</screen>

      <para>The list of letter A's indicates that Subversion is adding
        a number of items to your working copy.  You now have a
        personal copy of the repository's <filename>/calc</filename>
        directory, with one additional
        entry&mdash;<filename>.svn</filename>&mdash;which holds the
        extra information needed by Subversion, as mentioned
        earlier.</para>

      <sidebar id="svn.basic.in-action.wc.sb-1">
        <title>Repository URLs</title>

        <para>Subversion repositories can be accessed through many
          different methods&mdash;on local disk, or through various
          network protocols.  A repository location, however, is
          always a URL.  <xref linkend="svn.basic.in-action.wc.tbl-1"/> describes how
          different URL schemas map to the available access methods.</para>

        <table id="svn.basic.in-action.wc.tbl-1">
          <title>Repository Access URLs</title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Schema</entry>
                <entry>Access Method</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><literal>file:///</literal></entry>
                <entry>direct repository access (on local disk)</entry>
              </row>
              <row>
                <entry><literal>http://</literal></entry>
                <entry>access via WebDAV protocol to Subversion-aware
                  Apache server</entry>
              </row>
              <row>
                <entry><literal>https://</literal></entry>
                <entry>same as <literal>http://</literal>, but with
                  SSL encryption.</entry>
              </row>
              <row>
                <entry><literal>svn://</literal></entry>
                <entry>access via custom protocol to an
                  <literal>svnserve</literal> server</entry>
              </row>
              <row>
                <entry><literal>svn+ssh://</literal></entry>
                <entry>same as <literal>svn://</literal>, but through
                  an SSH tunnel.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>For more information on how Subversion parses URLs, see
        <xref linkend="svn.advanced.reposurls"/>.</para>

      </sidebar>
 
      <para>Suppose you make changes to <filename>button.c</filename>.
        Since the <filename>.svn</filename> directory remembers the
        file's modification date and original contents, Subversion can
        tell that you've changed the file.  However, Subversion does
        not make your changes public until you explicitly tell it to.
        The act of publishing your changes is more commonly known as
        <firstterm>committing</firstterm> (or <firstterm>checking
        in</firstterm>) changes to the repository.</para>

      <para>To publish your changes to others, you can use
        Subversion's <command>commit</command> command:</para>

      <screen>
$ svn commit button.c
Sending        button.c
Transmitting file data .
Committed revision 57.
</screen>

      <para>Now your changes to <filename>button.c</filename> have
        been committed to the repository; if another user checks out a
        working copy of <filename>/calc</filename>, they will see
        your changes in the latest version of the file.</para>

      <para>Suppose you have a collaborator, Sally, who checked out a
        working copy of <filename>/calc</filename> at the same time
        you did.  When you commit your change to
        <filename>button.c</filename>, Sally's working copy is left
        unchanged; Subversion only modifies working copies at the
        user's request.</para>

      <para>To bring her project up to date, Sally can ask
        Subversion to <firstterm>update</firstterm> her working copy,
        by using the Subversion <command>update</command> command.
        This will incorporate your changes into her working copy, as
        well as any others that have been committed since she checked
        it out.</para>

      <screen>
$ pwd
/home/sally/calc

$ ls -A 
.svn/ Makefile integer.c button.c

$ svn update
U    button.c
Updated to revision 57.
</screen>

      <para>The output from the <command>svn update</command> command
        indicates that Subversion updated the contents of
        <filename>button.c</filename>.  Note that Sally didn't need to
        specify which files to update; Subversion uses the information
        in the <filename>.svn</filename> directory, and further
        information in the repository, to decide which files need to
        be brought up to date.</para>
      
    </sect2>
    
    
    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.revs">
      <title>Revisions</title>

      <para>An <command>svn commit</command> operation can publish
        changes to any number of files and directories as a single
        atomic transaction.  In your working copy, you can change
        files' contents, create, delete, rename and copy files and
        directories, and then commit the complete set of changes as a
        unit.</para>

      <para>In the repository, each commit is treated as an atomic
        transaction: either all the commit's changes take place, or
        none of them take place.  Subversion tries to retain this
        atomicity in the face of program crashes, system crashes,
        network problems, and other users' actions.</para>

      <para>Each time the repository accepts a commit, this creates a
        new state of the filesystem tree, called a
        <firstterm>revision</firstterm>.  Each revision is assigned a
        unique natural number, one greater than the number of the
        previous revision.  The initial revision of a freshly created
        repository is numbered zero, and consists of nothing but an
        empty root directory.</para>
      
      <para><xref linkend="svn.basic.in-action.revs.dia-1"/> illustrates a nice way to
        visualize the repository.  Imagine an array of revision
        numbers, starting at 0, stretching from left to right.  Each
        revision number has a filesystem tree hanging below it, and
        each tree is a <quote>snapshot</quote> of the way the
        repository looked after a commit.</para>
      
      <figure id="svn.basic.in-action.revs.dia-1">
        <title>The repository</title>
        <graphic fileref="images/ch02dia7.png"/>
      </figure>

      <sidebar>
        <title>Global Revision Numbers</title>
         
        <para>Unlike those of many other version control systems,
          Subversion's revision numbers apply to <emphasis>entire
          trees</emphasis>, not individual files.  Each revision
          number selects an entire tree, a particular state of the
          repository after some committed change.  Another way to
          think about it is that revision N represents the state of
          the repository filesystem after the Nth commit.  When
          Subversion users talk about <quote>revision 5 of
          <filename>foo.c</filename></quote>, they really mean
          <quote><filename>foo.c</filename> as it appears in revision
          5.</quote> Notice that in general, revisions N and M of a
          file do <emphasis>not</emphasis> necessarily differ!  Because
          CVS uses per-file revision numbers, CVS users might want to
          see <xref linkend="svn.forcvs"/> for more details.</para>
      </sidebar>

      <para>It's important to note that working copies do not always
        correspond to any single revision in the repository; they may
        contain files from several different revisions.  For example,
        suppose you check out a working copy from a repository whose
        most recent revision is 4:</para>

      <screen>
calc/Makefile:4
     integer.c:4
     button.c:4
</screen>

      <para>At the moment, this working directory corresponds exactly
        to revision 4 in the repository.  However, suppose you make a
        change to <filename>button.c</filename>, and commit that
        change.  Assuming no other commits have taken place, your
        commit will create revision 5 of the repository, and your
        working copy will now look like this:</para>

      <screen>
calc/Makefile:4
     integer.c:4
     button.c:5
</screen>

      <para>Suppose that, at this point, Sally commits a change to
        <filename>integer.c</filename>, creating revision 6.  If you
        use <command>svn update</command> to bring your working copy
        up to date, then it will look like this:</para>

      <screen>
calc/Makefile:6
     integer.c:6
     button.c:6
</screen>

      <para>Sally's change to <filename>integer.c</filename> will
        appear in your working copy, and your change will still be
        present in <filename>button.c</filename>.  In this example,
        the text of <filename>Makefile</filename> is identical in
        revisions 4, 5, and 6, but Subversion will mark your working
        copy of <filename>Makefile</filename> with revision 6 to
        indicate that it is still current.  So, after you do a clean
        update at the top of your working copy, it will generally
        correspond to exactly one revision in the repository.</para>

    </sect2>
    
    
    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.track-repos">
      <title>How Working Copies Track the Repository</title>
      
      <para>For each file in a working directory, Subversion records
        two essential pieces of information in the
        <filename>.svn/</filename> administrative area:</para>
      
      
      <itemizedlist>
        <listitem>
          <para>what revision your working file is based on (this is
            called the file's <firstterm>working
            revision</firstterm>), and</para>
        </listitem>
        
        <listitem>
          <para>a timestamp recording when the local copy was last
            updated by the repository.</para>
        </listitem>
      </itemizedlist>

      <para>Given this information, by talking to the repository,
        Subversion can tell which of the following four states a
        working file is in:</para>

      <variablelist>
        <varlistentry>
          <term>Unchanged, and current</term> 

          <listitem>
            <para>The file is unchanged in the working directory, and
              no changes to that file have been committed to the
              repository since its working revision.  An <command>svn
              commit</command> of the file will do nothing, and an
              <command>svn update</command> of the file will do
              nothing.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term>Locally changed, and current</term>

          <listitem>
            <para>The file has been changed in the working directory,
              and no changes to that file have been committed to the
              repository since its base revision.  There are local
              changes that have not been committed to the repository,
              thus an <command>svn commit</command> of the file will
              succeed in publishing your changes, and an <command>svn
              update</command> of the file will do nothing.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term>Unchanged, and out-of-date</term> 

          <listitem>
            <para>The file has not been changed in the working
              directory, but it has been changed in the repository.
              The file should eventually be updated, to make it
              current with the public revision.  An <command>svn
              commit</command> of the file will do nothing, and an
              <command>svn update</command> of the file will fold the
              latest changes into your working copy.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term>Locally changed, and out-of-date</term>

          <listitem>
            <para>The file has been changed both in the working
              directory, and in the repository.  An <command>svn
              commit</command> of the file will fail with an
              <quote>out-of-date</quote> error.  The file should be
              updated first; an <command>svn update</command> command
              will attempt to merge the public changes with the local
              changes.  If Subversion can't complete the merge in a
              plausible way automatically, it leaves it to the user to
              resolve the conflict.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      
      
      <para>This may sound like a lot to keep track of, but the
        <command>svn status</command> command will show you the state
        of any item in your working copy.  For more information on
        that command, see <xref linkend="svn.tour.cycle.examine.status" />.</para>
     
    </sect2>
    
    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.mixedrevs">
      <title>Mixed Revision Working Copies</title>

      <para>As a general principle, Subversion tries to be as flexible
        as possible.  One special kind of flexibility is the ability
        to have a working copy containing files and directories with a
        mix of different working revision numbers.  Unfortunately,
        this flexibility tends to confuse a number of new users.  If
        the earlier example showing mixed revisions perplexed you,
        here's a primer on both why the feature exists and how to make
        use of it.</para>

      <sect3 id="svn.basic.in-action.mixedrevs.update-commit">
        <title>Updates and Commits are Separate</title>

        <para>One of the fundamental rules of Subversion is that
          a <quote>push</quote> action does not cause
          a <quote>pull</quote>, nor the other way around.  Just
          because you're ready to submit new changes to the repository
          doesn't mean you're ready to receive changes from other
          people.  And if you have new changes still in progress,
          then <command>svn update</command> should gracefully merge
          repository changes into your own, rather than forcing you to
          publish them.</para>

        <para>The main side-effect of this rule is that it means a
          working copy has to do extra bookkeeping to track mixed
          revisions, and be tolerant of the mixture as well.  It's
          made more complicated by the fact that directories
          themselves are versioned.</para>

        <para>For example, suppose you have a working copy entirely at
          revision 10.  You edit the
          file <filename>foo.html</filename> and then perform
          an <command>svn commit</command>, which creates revision 15
          in the repository.  After the commit succeeds, many new
          users would expect the working copy to be entirely at
          revision 15, but that's not the case!  Any number of changes
          might have happened in the repository between revisions 10
          and 15.  The client knows nothing of those changes in the
          repository, since you haven't yet run <command>svn
          update</command>, and <command>svn commit</command> doesn't
          pull down new changes.  If, on the other hand,
          <command>svn commit</command> <emphasis>were</emphasis> to
          automatically download the newest changes, then it would be
          possible to set the entire working copy to revision
          15&mdash;but then we'd be breaking the fundamental rule
          of <quote>push</quote> and <quote>pull</quote> remaining
          separate actions.  Therefore the only safe thing the
          Subversion client can do is mark the one
          file&mdash;<filename>foo.html</filename>&mdash;as being at
          revision 15.  The rest of the working copy remains at
          revision 10.  Only by running <command>svn update</command>
          can the latest changes be downloaded, and the whole working
          copy be marked as revision 15.</para>

        </sect3>

        <sect3 id="svn.basic.in-action.mixedrevs.normal">
          <title>Mixed revisions are normal</title>
          
          <para>The fact is, <emphasis>every time</emphasis> you
            run <command>svn commit</command>, your working copy ends
            up with some mixture of revisions.  The things you just
            committed are marked as having larger working revisions
            than everything else.  After several commits (with no
            updates in-between) your working copy will contain a whole
            mixture of revisions.  Even if you're the only person
            using the repository, you will still see this phenomenon.
            To examine your mixture of working revisions, use
            the <command>svn status --verbose</command> command (see
            <xref linkend="svn.tour.cycle.examine.status"/> for more
            information.)</para>

          <para>Often, new users are completely unaware that their
            working copy contains mixed revisions.  This can be
            confusing, because many client commands are sensitive to
            the working revision of the item they're examining.  For
            example, the <command>svn log</command> command is used to
            display the history of changes to a file or directory (see
            <xref linkend="svn.tour.history.log"/>).  When the user
            invokes this command on a working copy object, they expect
            to see the entire history of the object.  But if the
            object's working revision is quite old (often
            because <command>svn update</command> hasn't been run in a
            long time), then the history of
            the <emphasis>older</emphasis> version of the object is
            shown.</para>
        </sect3>

        <sect3 id="svn.basic.in-action.mixedrevs.useful">
          <title>Mixed revisions are useful</title>

          <para>If your project is sufficiently complex, you'll
            discover that it's sometimes nice to forcibly
            <quote>backdate</quote> portions of your working copy to
            an earlier revision; you'll learn how to do that in
            Chapter 3.  Perhaps you'd like to test an earlier version
            of a sub-module contained in a subdirectory, or perhaps
            you'd like to figure out when a bug first came into
            existence in a specific file.  This is the <quote>time
            machine</quote> aspect of a version control system &mdash;
            the feature which allows you to move any portion of your
            working copy forward and backward in history.</para>

        </sect3>

        <sect3 id="svn.basic.in-action.mixedrevs.limits">
          <title>Mixed revisions have limitations</title>

          <para>However you make use of mixed revisions in your
            working copy, there are limitations to this
            flexibility.</para>
          
          <para>First, you cannot commit the deletion of a file or
            directory which isn't fully up-to-date.  If a newer
            version of the item exists in the repository, your attempt
            to delete will be rejected, to prevent you from
            accidentally destroying changes you've not yet
            seen.</para>

          <para>Second, you cannot commit a metadata change to a
            directory unless it's fully up-to-date.  You'll learn
            about attaching
            <quote>properties</quote> to items in Chapter 6.  A
            directory's working revision defines a specific set of
            entries and properties, and thus committing a property
            change to an out-of-date directory may destroy properties
            you've not yet seen.</para>

        </sect3>


    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.summary">
    <title>Summary</title>
    
    <para>We've covered a number of fundamental Subversion concepts in
      this chapter:</para>

    <itemizedlist>
      <listitem>
        <para>We've introduced the notions of the central repository,
          the client working copy, and the array of repository
          revision trees.</para>
      </listitem>

      <listitem>
        <para>We've seen some simple examples of how two collaborators
          can use Subversion to publish and receive changes from one
          another, using the <quote>copy-modify-merge</quote>
          model.</para>
      </listitem>

      <listitem>
        <para>We've talked a bit about the way Subversion tracks and
          manages information in a working copy.</para>
      </listitem>

    </itemizedlist>
    
    <para>At this point, you should have a good idea of how Subversion
      works in the most general sense.  Armed with this knowledge, you
      should now be ready to jump into the next chapter, which is a
      detailed tour of Subversion's commands and features.</para>
      
  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
