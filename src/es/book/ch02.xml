<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- originated from English revision 652 -->
<!-- Modeline para usuarios del editor vim
vim: set expandtab tabstop=2 shiftwidth=2 textwidth=78:
-->
<chapter id="svn-ch-2">
  <title>Conceptos Básicos</title>

  <simplesect>
    <para>Este capítulo es una introducción breve e informal a Subversion.
      Si es nuevo en el tema del control de versiones, este capítulo es
      definitivamente para usted. Empezaremos tratando los conceptos
      generales en el control de versiones, seguiremos con las ideas específicas
      detrás de Subversion, y mostraremos algunos ejemplos simples de Subversion
      en acción.</para>
    
    <para>Aunque los ejemplos de este capítulo muestran a gente
      compartiendo colecciones de archivos de código fuente, tenga en mente
      que Subversion puede manejar cualquier tipo de colección de
      archivos&mdash;no está limitado a asistir a programadores de
      ordenadores.</para>
  </simplesect>
  
  
  <sect1 id="svn-ch-2-sect-1" > 
    <title>El Repositorio</title>  
    
    <para>Subversion es un sistema centralizado para compartir información.
      La parte principal de Subversion es el repositorio, el cual es un 
      almacén central de datos.
      El repositorio guarda información en forma de
      <firstterm>árbol de archivos</firstterm>&mdash;una típica jerarquía
      de archivos y directorios. Cualquier número de <firstterm>clientes</firstterm>
      puede conectarse al repositorio y luego leer o escribir en esos archivos.
      Al escribir datos, un cliente pone a disposición de otros la información;
      al leer datos, el cliente recibe información de otros.  
      La figura <xref linkend="svn-ch-2-dia-1"/> ilustra ésto.</para>

    <figure id="svn-ch-2-dia-1">
      <title>Un sistema cliente/servidor típico</title>
      <graphic fileref="images/ch02dia1.png"/>
    </figure>
    
    <para>Entonces, ¿qué tiene ésto de interesante?. Hasta ahora, 
      suena como la definición del típico servidor de archivos.
      Y, de hecho, el repositorio <emphasis>es</emphasis> una especie de
      servidor de archivos, pero no del tipo habitual. Lo que hace 
      especial al repositorio de Subversion es que <emphasis>recuerda
      todos los cambios</emphasis> hechos sobre él: cada cambio a cada
      archivo, e inclusive cambios al propio árbol de directorios, tales
      como la adición, borrado y reubicación de archivos y directorios.</para>

    <para>Cuando un cliente lee datos del repositorio, normalmente sólo ve
      la ultima versión del árbol de archivos. Sin embargo, el cliente
      también tiene la posibilidad de ver estados <emphasis>previos</emphasis>
      del sistema de archivos. Por ejemplo, un cliente puede hacer
      consultas históricas como, <quote>¿Qué contenía este directorio 
      el miércoles pasado?</quote> Esta es la clase de preguntas que resulta
      esencial en cualquier <firstterm>sistema de control de versiones</firstterm>:
      sistemas que están diseñados para registrar y seguir los cambios en
      los datos a través del tiempo.
    </para>

  </sect1>

  <sect1 id="svn-ch-2-sect-2">
    <title>Modelos de Versionamiento</title>

    <para>La misión principal de un sistema de control de versiones
      es permitir la edición colaborativa y la compartición de los datos.
      Sin embargo, existen diferentes sistemas que utilizan diferentes 
      estrategias para alcanzar este objetivo.</para>
    
    <sect2 id="svn-ch-2-sect-2.1">
      <title>El Problema de Compartir Archivos</title>
      
      <para>Todos los sistemas de control de versiones tienen que resolver
        un problema fundamental: ¿Cómo permitirá el sistema a los usuarios
        el compartir información, pero al mismo tiempo impedirá que se pisen 
        los callos mutuamente de forma accidental? Es muy sencillo para los 
        usuarios el sobreescribir accidentalmente los cambios de los demás en el
        repositorio.</para>

      <para>Considere el escenario mostrado en <xref linkend="svn-ch-2-dia-2"/>.
        Suponga que tenemos dos colaboradores, Harry y Sally. Cada uno de
        ellos decide editar el mismo archivo del repositorio al mismo tiempo.
        Si Harry guarda sus cambios en el repositorio en primer lugar, es 
        posible que (unos momentos más tarde) Sally los sobreescriba 
        accidentalmente con su propia versión del archivo. Si bien es
        cierto que la versión de Harry no se ha perdido para siempre (porque el
        sistema recuerda cada cambio), cualquier cambio que Harry haya hecho
        <emphasis>no</emphasis> estará presente en la versión más reciente de Sally
        porque, para empezar, ella nunca vio los cambios de Harry. El
        trabajo de Harry sigue efectivamente perdido&mdash;o al menos
        ausente en la última versión del archivo&mdash;y probablemente por
        accidente. ¡Esta es definitivamente una situación que queremos evitar!</para>

      <figure id="svn-ch-2-dia-2">
        <title>El problema a evitar</title>
        <graphic fileref="images/ch02dia2.png"/>
      </figure>

      </sect2>
    
    <sect2 id="svn-ch-2-sect-2.2">
      <title>La solución Bloqueo-Modificación-Desbloqueo</title>
      
      <para>Muchos sistemas de control de versiones utilizan un modelo de
        <firstterm>bloqueo-modificación-desbloqueo</firstterm> para atacar
        este problema. En un sistema como éste, el repositorio sólo permite
        a una persona modificar un archivo al mismo tiempo. Harry debe
        <quote>bloquear</quote> primero el archivo para luego empezar a
        hacerle cambios. Bloquear un archivo se parece mucho a pedir prestado un
        libro de la biblioteca; si Harry ha bloqueado el archivo, entonces
        Sally no puede hacerle cambios. Por consiguiente, si ella intenta bloquear 
        el archivo, el repositorio rechazará la petición. Todo lo que puede hacer 
        es leer el archivo y esperar a que Harry termine sus cambios y deshaga el
        bloqueo. Tras desbloquear Harry el archivo, Sally puede aprovechar su turno
        bloqueando y editando el archivo. La figura
        <xref linkend="svn-ch-2-dia-3"/> demuestra esta sencilla solución.</para>
      
      <figure id="svn-ch-2-dia-3">
        <title>La solucion bloqueo-modificación-desbloqueo</title>
        <graphic fileref="images/ch02dia3.png"/>
      </figure>
      
      <para>El problema con el modelo bloqueo-modificación-desbloqueo es que
        es un tanto restrictivo y a menudo se convierte en un obstáculo para
        los usuarios:</para>

      <itemizedlist>
        <listitem><para>
            <emphasis>Bloquear puede causar problemas administrativos.</emphasis>


            En ocasiones Harry bloqueará un archivo y se olvidará de él. Mientras
            tanto, como Sally está aún esperando para editar el archivo, sus
            manos están atadas. Y luego Harry se va de vacaciones. Ahora Sally
            debe conseguir que un administrador deshaga el bloqueo de Harry.
            La situación termina causando muchas demoras innecesarias y
            pérdida de tiempo.
            </para></listitem>
        
        <listitem><para>
            <emphasis>Bloquear puede causar una serialización innecesaria.</emphasis>

            ¿Qué sucede si Harry está editando el inicio de un archivo de texto
            y Sally simplemente quiere editar el final del mismo archivo?
            Estos cambios no se solapan en absoluto. Ambos podrían editar el
            archivo simultáneamente sin grandes perjuicios, suponiendo
            que los cambios se combinaran correctamente. No hay necesidad
            de turnarse en esta situación.
            </para></listitem>
    
        <listitem><para>
            <emphasis>Bloquear puede causar una falsa sensación de seguridad.</emphasis>

            Imaginemos que Harry bloquea y edita el archivo A, mientras que
            Sally bloquea y edita el archivo B al mismo tiempo. Pero suponga
            que A y B dependen uno del otro y que los cambios hechos a cada
            uno de ellos son semánticamente incompatibles. Súbitamente A y B ya no
            funcionan juntos. El sistema de bloqueo se mostró ineficaz a la hora de
            evitar el problema&mdash;sin embargo, y de algún modo, ofreció
            una falsa sensación de seguridad. Es fácil para Harry y Sally
            imaginar que al bloquear archivos, cada uno está empezando una
            tarea segura y aislada, lo cual les inhibe de discutir sus cambios
            incompatibles desde un principio.
            </para></listitem>
      </itemizedlist>

      </sect2>

    <sect2 id="svn-ch-2-sect-2.3">
      <title>La solución Copiar-Modificar-Mezclar</title>
      
      <para>Subversion, CVS y otros sistemas de control de versiones
        utilizan un modelo del tipo
        <firstterm>copiar-modificar-mezclar</firstterm> como alternativa
        al bloqueo. En este modelo, el cliente de cada usuario se conecta al
        repositorio del proyecto y crea una <firstterm>copia de
          trabajo</firstterm> personal&mdash;una réplica local de los
        archivos y directorios del repositorio. Los usuarios pueden entonces
        trabajar en paralelo, modificando sus copias privadas. Finalmente, todas
        las copias privadas se combinan (o mezclan) en una nueva versión final. 
        El sistema de control de versiones a menudo ayuda con la mezcla, pero en 
        última instancia es un ser humano el responsable de hacer que ésto suceda 
        correctamente.
      </para>
      
      <para>He aquí un ejemplo. Digamos que Harry y Sally crean sendas copias
        de trabajo del mismo proyecto, extraídas del repositorio. Ambos
        trabajan concurrentemente y hacen cambios a un mismo archivo A dentro de 
        sus copias. Sally guarda sus cambios en el repositorio primero. Cuando Harry
        intenta guardar sus cambios más tarde, el repositorio le informa de que
        su archivo A está <firstterm>desactualizado</firstterm>. En otras
        palabras, que el archivo A en el repositorio ha sufrido algún cambio
        desde que lo copió por última vez. Por tanto, Harry le pide a su cliente
        que <firstterm>mezcle</firstterm> cualquier cambio nuevo del
        repositorio con su copia de trabajo del archivo A. Es probable que los
        cambios de Sally no se solapen con los suyos; así que una vez que tiene
        ambos juegos de cambios integrados, Harry guarda su copia de trabajo
        de nuevo en el repositorio. Las figuras <xref
        linkend="svn-ch-2-dia-4"/> y <xref linkend="svn-ch-2-dia-5"/>
        muestran este proceso.</para>

      <figure id="svn-ch-2-dia-4">
        <title>La solución copiar-modificar-mezclar</title>
        <graphic fileref="images/ch02dia4.png"/>
      </figure>
      
      <figure id="svn-ch-2-dia-5">
        <title>La solución copiar-modificar-mezclar (continuación)</title>
        <graphic fileref="images/ch02dia5.png"/>
      </figure>

      <para>¿Pero qué ocurre si los cambios de Sally <emphasis>sí</emphasis>
        se solapan con los de Harry? ¿Entonces qué? Esta situación se conoce
        como <firstterm>conflicto</firstterm> y no suele suponer un gran problema. 
        Cuando Harry le pide a su cliente que mezcle los últimos
        cambios del repositorio en su copia de trabajo, su copia del archivo A
        se marca de algún modo para indicar que está en estado de conflicto: 
        Harry podrá ver ambos conjuntos de cambios conflictivos y escoger manualmente
        entre ellos. Observe que el programa no puede resolver automáticamente
        los conflictos; sólo los humanos son capaces de entender y tomar las
        decisiones inteligentes oportunas. Una vez que Harry ha resuelto
        manualmente los cambios solapados&mdash;posiblemente después de
        discutirlos con Sally&mdash;ya podrá guardar con seguridad el archivo
        mezclado en el repositorio.</para>

      <para>La solución copiar-modificar-mezclar puede sonar un tanto caótica,
        pero en la práctica funciona extremadamente bien. Los usuarios pueden
        trabajar en paralelo, sin tener que esperarse el uno al otro. Cuando
        trabajan en los mismos archivos, sucede que la mayoría de sus cambios
        concurrentes no se solapan en absoluto; los conflictos son poco
        frecuentes. El tiempo que toma resolver los conflictos es mucho menor
        que el tiempo perdido por un sistema de bloqueos.</para>

      <para>Al final, todo desemboca en un factor crítico: la comunicación
        entre los usuarios. Cuando los usuarios se comunican pobremente, los
        conflictos tanto sintácticos como semánticos aumentan. Ningún sistema
        puede forzar a los usuarios a comunicarse perfectamente, y ningún
        sistema puede detectar conflictos semánticos. Por consiguiente, no
        tiene sentido dejarse adormecer por la falsa promesa de que un
        sistema de bloqueos evitará de algún modo los conflictos; en
        la práctica, el bloqueo parece inhibir la productividad más que otra cosa.
        </para>
      
    </sect2>
    
  </sect1>
  
  <!-- Cómo svn implementa esta filosofía -->
  <sect1 id="svn-ch-2-sect-3">
    <title>Subversion en Acción</title>
    
    <para>Es hora de movernos de lo abstracto a lo concreto. En esta sección
      mostraremos ejemplos reales de Subversion en la práctica.</para>

    <sect2 id="svn-ch-2-sect-3.1">
      <title>Copias de Trabajo</title>
      
      <para>Ya ha leído acerca de las copias de trabajo; ahora demostraremos 
        cómo las crea y las usa el cliente de Subversion.</para>
      
      <para>Una copia de trabajo de Subversion es un árbol de directorios
        corriente de su sistema de archivos local, conteniendo una colección
        de archivos. Usted puede editar estos archivos del modo que prefiera y
        si se trata de archivos de código fuente, podrá compilar su
        programa a partir de ellos de la manera habitual. Su copia de trabajo 
        es su área de trabajo privada: Subversion nunca incorporará los cambios 
        de otra gente o pondrá a disposición de otros sus cambios hasta que 
        usted le indique explícitamente que lo haga.</para>

      <para>Tras hacer algunos cambios a los archivos en su copia
        de trabajo y verificar que funcionan correctamente, Subversion le
        proporciona comandos para <quote>publicar</quote> sus cambios al
        resto de personas que trabajan con usted en su proyecto 
        (escribiendo en el repositorio). Si las demás personas publican sus 
        propios cambios, Subversion le proporciona comandos para mezclar 
        estos cambios en su directorio de trabajo (leyendo del repositorio).</para>

      <para>Una copia de trabajo también contiene algunos archivos extra,
        creados y mantenidos por Subversion para ayudarle a ejecutar estos
        comandos. En particular, cada directorio de su copia de trabajo
        contiene un subdirectorio llamado <filename>.svn</filename>, también
        conocido como el <firstterm>directorio administrativo</firstterm> de
        la copia de trabajo. Los archivos en cada directorio administrativo 
        ayudan a Subversion a reconocer qué archivos contienen cambios no
        publicados y qué archivos estan desactualizados con respecto al
        trabajo hecho por los demás.</para>
      
      <para>Un repositorio típico de Subversion contiene a menudo los archivos
        (o el código fuente) de varios proyectos; normalmente, cada proyecto es
        un subdirectorio en el árbol del sistema de archivos del repositorio.
        En esta disposición, la copia de trabajo de un usuario se corresponde 
        habitualmente con un subárbol particular del repositorio.</para>
      
      <para>Por ejemplo, suponga que usted tiene un repositorio que contiene
        dos proyectos de software, <literal>paint</literal> y
        <literal>calc</literal>. Cada proyecto reside en su propio subdirectorio
        dentro del directorio raíz, tal como se muestra en <xref
        linkend="svn-ch-2-dia-6"/>.</para>

      <figure id="svn-ch-2-dia-6">
        <title>El sistema de archivos del repositorio</title>
        <graphic fileref="images/ch02dia6.png"/>
      </figure>
      
      <!--TODO: buscar un mejor termino en castellano para explicar 'check
      out'-->
      <para>Para conseguir una copia de trabajo, debe ejecutar primero
        un <firstterm>check out</firstterm> de algún subárbol del
        repositorio. (El término inglés <quote>check out</quote> puede sonar como 
        si tuviera algo que ver con bloquear o reservar recursos, pero no es así; 
        tan sólo crea una copia privada del proyecto para usted). Por ejemplo, si 
        usted hace un check out de <filename>/calc</filename>, obtendrá una copia de
        trabajo como ésta:</para>

<screen>
$ svn checkout http://svn.example.com/repos/calc
A  calc
A  calc/Makefile
A  calc/integer.c
A  calc/button.c

$ ls -A calc
Makefile  integer.c  button.c  .svn/
</screen>


      <para>La lista de letras A indica que Subversion está añadiendo una
        serie de elementos a su copia de trabajo. Usted ahora tiene una copia
        personal del directorio <filename>/calc</filename> del repositorio,
        con una entrada adicional&mdash;<filename>.svn</filename>&mdash;que
        contiene la información extra que Subversion necesita, tal y como se
        mencionó anteriormente.</para>

      <sidebar id="svn-ch-2-sidebar-1">
        <title>URLs del Repositorio</title>

        <para>A los repositorios de Subversion se puede acceder a través de
          diferentes métodos&mdash;en el disco local, o a través de varios
          protocolos de red. Sin embargo, la ubicación de un repositorio es siempre
          un URL. La tabla 2-1 describe la correspondencia entre los diferentes 
          esquemas de URL y los métodos de acceso disponibles.</para>

        <table id="svn-ch-2-table-1">
          <title>URLs de Acceso al Repositorio</title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Esquema</entry>
                <entry>Método de acceso</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><literal>file:///</literal></entry>
                <entry>acceso directo al repositorio (en disco local)</entry>
              </row>
              <row>
                <entry><literal>http://</literal></entry>
                <entry>acceso vía protocolo WebDAV a un servidor
                  Apache que entiende de Subversion</entry>
              </row>
              <row>
                <entry><literal>https://</literal></entry>
                <entry>igual que <literal>http://</literal>, pero con
                  encriptación SSL.</entry>
              </row>
              <row>
                <entry><literal>svn://</literal></entry>
                <entry>acceso vía un protocolo personalizado a un servidor
                  <literal>svnserve</literal>.</entry>
              </row>
              <row>
                <entry><literal>svn+ssh://</literal></entry>
                <entry>igual que <literal>svn://</literal>, pero a través de 
                  un túnel SSH.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
 
        <para>En general, los URLs de Subversion utilizan la sintaxis
          estándar, permitiendo la especificación de nombres de servidores 
          y números de puertos como parte del URL. Recuerde que el método
          de acceso <literal>file:</literal> es válido sólo para ubicaciones
          en el mismo servidor donde se ejecuta el cliente&mdash;de hecho, se
          requiere por convención que la parte del URL con el nombre del 
          servidor esté ausente o sea <literal>localhost</literal>:</para>

        <screen>
$ svn checkout file:///ruta/a/repositorio
&hellip;
$ svn checkout file://localhost/ruta/a/repositorio
&hellip;
</screen>

        <para>Además, los usuarios del esquema <literal>file:</literal> en
          plataformas Windows necesitarán usar una sintaxis
          <quote>estándar</quote> extraoficial para acceder  a repositorios
          que están en la misma máquina, pero en una unidad de disco distinta
          de la que el cliente esté utilizando en el momento. Cualquiera de
          las dos siguientes sintaxis para rutas de URL funcionarán siendo
          <literal>X</literal> la unidad donde reside el repositorio:</para>

        <screen>
C:\> svn checkout file:///X:/ruta/a/repositorio
&hellip;
C:\> svn checkout "file:///X|/ruta/a/repositorio"
&hellip;
</screen>
 
        <para>En la segunda sintaxis, es necesario encerrar el URL entre comillas
          para que la barra vertical no sea interpretada como una tubería.</para>

        <para>Nótese que un URL usa barras de separación ordinarias aún cuando 
          la forma de ruta nativa (no para URLs) en Windows utiliza barras
          invertidas.</para>

      </sidebar>

      <!--TODO: revisar para agregar notas del traductor para 'commit' y
      'check in' -->
      <para>Suponga que hace cambios a <filename>button.c</filename>. Puesto
        que el directorio <filename>.svn</filename> recuerda la fecha de
        modificación del archivo y su contenido original, Subversion es capaz de 
        darse cuenta de que el archivo ha cambiado. Sin embargo, Subversion no hará
        públicos sus cambios hasta que usted no le diga explícitamente que lo haga. 
        El acto de publicar sus cambios es conocido comúnmente como 
        <firstterm>consignar</firstterm> (o <firstterm>registrar</firstterm>)
        los cambios al repositorio.</para>

      <para>Para publicar sus cambios a otros, usted puede utilizar el comando
        <command>commit</command> de Subversion:</para>

<screen>
$ svn commit button.c
Sending        button.c
Transmitting file data .
Committed revision 57.
</screen>

      <para>Ahora sus cambios a <filename>button.c</filename> han sido
        consignados al repositorio; si otro usuario obtiene una copia de trabajo
        de <filename>/calc</filename>, podrá ver sus cambios en la última
        versión del archivo.</para>

      <para>Suponga que tiene un colaborador, Sally, quien obtuvo una
        copia de trabajo de <filename>/calc</filename> al mismo tiempo
        que usted. Cuando usted envía sus cambios sobre
        <filename>button.c</filename>, la copia de trabajo de Sally se deja
        sin cambios; Subversion solo modifica las copias de trabajo a
        petición del usuario.</para>

      <para>Para tener su proyecto actualizado, Sally puede pedir a
        Subversion que proceda a <firstterm>actualizar</firstterm> su copia de 
        trabajo, usando para ello el comando <command>update</command> de Subversion.
        Ésto incorporará los cambios hechos por usted en la copia de trabajo de Sally, 
        así como otros cambios consignados desde que ella hizo el check out.</para>

<screen>
$ pwd
/home/sally/calc

$ ls -A 
.svn/ Makefile integer.c button.c

$ svn update
U button.c
</screen>

      <para>La salida del comando <command>svn update</command>
        indica que Subversion actualizó el contenido de
        <filename>button.c</filename>. Observe que Sally no necesitó
        especificar qué archivos actualizar; Subversion usa la información
        del directorio <filename>.svn</filename>, junto con 
        información adicional del repositorio, para decidir qué archivos 
        necesitan una actualización.</para>
      
    </sect2>
    
    
    <sect2 id="svn-ch-2-sect-3.2">
      <title>Revisions</title>

      <para>An <command>svn commit</command> operation can publish
        changes to any number of files and directories as a single
        atomic transaction.  In your working copy, you can change
        files' contents, create, delete, rename and copy files and
        directories, and then commit the complete set of changes as a
        unit.</para>

      <para>In the repository, each commit is treated as an atomic
        transaction: either all the commit's changes take place, or
        none of them take place.  Subversion tries to retain this
        atomicity in the face of program crashes, system crashes,
        network problems, and other users' actions.</para>

      <para>Each time the repository accepts a commit, this creates a
        new state of the filesystem tree, called a
        <firstterm>revision</firstterm>.  Each revision is assigned a
        unique natural number, one greater than the number of the
        previous revision.  The initial revision of a freshly created
        repository is numbered zero, and consists of nothing but an
        empty root directory.</para>
      
      <para><xref linkend="svn-ch-2-dia-7"/> illustrates a nice way to
        visualize the repository.  Imagine an array of revision
        numbers, starting at 0, stretching from left to right.  Each
        revision number has a filesystem tree hanging below it, and
        each tree is a <quote>snapshot</quote> of the way the
        repository looked after each commit. </para>
      
      <figure id="svn-ch-2-dia-7">
        <title>The repository</title>
        <graphic fileref="images/ch02dia7.png"/>
      </figure>

      <sidebar>
        <title>Global Revision Numbers</title>
         
        <para>Unlike those of many other version control systems,
          Subversion's revision numbers apply to <emphasis>entire
          trees</emphasis>, not individual files.  Each revision
          number selects an entire tree, a particular state of the
          repository after some committed change.  Another way to
          think about it is that revision N represents the state of
          the repository filesystem after the Nth commit.  When a
          Subversion user talks about <quote>revision 5 of
          <filename>foo.c</filename></quote>, they really mean
          <quote><filename>foo.c</filename> as it appears in revision 5.</quote>
          Notice that in general, revisions N and M of a file do
          <emphasis>not</emphasis> necessarily differ!  Because CVS
          uses per-file revisions numbers, CVS users might want to see
          <xref linkend="svn-ap-a"/> for more details.</para>
      </sidebar>

      <para>It's important to note that working copies do not always
        correspond to any single revision in the repository; they may
        contain files from several different revisions.  For example,
        suppose you check out a working copy from a repository whose
        most recent revision is 4:</para>

<screen>
calc/Makefile:4
     integer.c:4
     button.c:4
</screen>

      <para>At the moment, this working directory corresponds exactly
        to revision 4 in the repository.  However, suppose you make a
        change to <filename>button.c</filename>, and commit that
        change.  Assuming no other commits have taken place, your
        commit will create revision 5 of the repository, and your
        working copy will now look like this:</para>

<screen>
calc/Makefile:4
     integer.c:4
     button.c:5
</screen>

      <para>Suppose that, at this point, Sally commits a change to
        <filename>integer.c</filename>, creating revision 6.  If you
        use <command>svn update</command> to bring your working copy
        up to date, then it will look like this:</para>

<screen>
calc/Makefile:6
     integer.c:6
     button.c:6
</screen>

      <para>Sally's changes to <filename>integer.c</filename> will
        appear in your working copy, and your change will still be
        present in <filename>button.c</filename>.  In this example,
        the text of <filename>Makefile</filename> is identical in
        revisions 4, 5, and 6, but Subversion will mark your working
        copy of <filename>Makefile</filename> with revision 6 to
        indicate that it is still current.  So, after you do a clean
        update at the top of your working copy, it will generally
        correspond to exactly one revision in the repository.</para>

    </sect2>
    
    
    <sect2 id="svn-ch-2-sect-3.3">
      <title>How Working Copies Track the Repository</title>
      
      <para>For each file in a working directory, Subversion records
        two essential pieces of information in the
        <filename>.svn/</filename> administrative area:</para>
      
      
      <itemizedlist>
        <listitem><para>what revision your working file is based on
            (this is called the file's <firstterm>working
             revision</firstterm>), and</para></listitem>
        
        <listitem><para>a timestamp recording when the local copy was
            last updated by the repository.</para></listitem>
      </itemizedlist>

      <para>Given this information, by talking to the repository,
        Subversion can tell which of the following four states a
        working file is in:</para>

      <variablelist>
        <varlistentry>
          <term>Unchanged, and current</term> 

          <listitem><para>The file is unchanged in the working
          directory, and no changes to that file have been committed
          to the repository since its working revision.  A
          <command>svn commit</command> of the file will do nothing,
          and an <command>svn update</command> of the file will do
          nothing. </para></listitem>
        </varlistentry>
        
        <varlistentry>
          <term>Locally changed, and current</term>

          <listitem><para>The file has been changed in the working
          directory, and no changes to that file have been committed
          to the repository since its base revision.  There are local
          changes that have not been committed to the repository, thus
          an <command>svn commit</command> of the file will succeed in
          publishing your changes, and an <command>svn update</command>
          of the file will do nothing.</para></listitem>
        </varlistentry>
        
        <varlistentry>
          <term>Unchanged, and out-of-date</term> 

          <listitem><para>The file has not been changed in the working
          directory, but it has been changed in the repository.  The
          file should eventually be updated, to make it current with
          the public revision.  An <command>svn commit</command> of the
          file will do nothing, and an <command>svn update</command> of
          the file will fold the latest changes into your working
          copy.</para></listitem>
        </varlistentry>
        
        <varlistentry>
          <term>Locally changed, and out-of-date</term>

          <listitem><para>The file has been changed both in the
          working directory, and in the repository.  An <command>svn
          commit</command> of the file will fail with an
          <quote>out-of-date</quote> error.  The file should be
          updated first; an <command>svn update</command> command will
          attempt to merge the public changes with the local changes.
          If Subversion can't complete the merge in a plausible way
          automatically, it leaves it to the user to resolve the
          conflict.</para></listitem>
        </varlistentry>
      </variablelist>
      
      
      <para>This may sound like a lot to keep track of, but the
        <command>svn status</command> command will show you the state
        of any item in your working copy.  For more information on
        that command, see <xref linkend="svn-ch-3-sect-4.3.1" />.</para>
     
    </sect2>
    
    <sect2 id="svn-ch-2-sect-3.4">
      <title>The Limitations of Mixed Revisions</title>

      <para>As a general principle, Subversion tries to be as flexible
        as possible.  One special kind of flexibility is the ability
        to have a working copy containing mixed revision
        numbers.</para>

      <para>At first, it may not be entirely clear why this sort of
        flexibility is considered a feature, and not a liability.
        After completing a commit to the repository, the freshly
        committed files and directories are at a more recent working
        revision than the rest of the working copy.  It looks like a
        bit of a mess.  As demonstrated earlier, the working copy can
        always be brought to a single working revision by running
        <command>svn update</command>.  Why would someone
        <emphasis>deliberately</emphasis> want a mixture of working
        revisions?</para>

      <para>Assuming your project is sufficiently complex, you'll
        discover that it's sometimes nice to forcibly
        <quote>backdate</quote> portions of your working copy to an
        earlier revision; you'll learn how to do that in Chapter 3.
        Perhaps you'd like to test an earlier version of a sub-module,
        contained in a subdirectory, or perhaps you'd like to examine
        a number of previous versions of a file in the context of the
        latest tree.</para>
        
      <para>However you make use of mixed-revisions in your working
        copy, there are limitations to this flexibility.</para>

      <para>First, you cannot commit the deletion of a file or
        directory which isn't fully up-to-date.  If a newer version of
        the item exists in the repository, your attempt to delete will
        be rejected, to prevent you from accidentally
        destroying changes you've not yet seen.</para>

      <para>Second, you cannot commit a metadata change to a directory
        unless it's fully up-to-date.  You'll learn about attaching
        <quote>properties</quote> to items in Chapter 6.  A
        directory's working revision defines a specific set of entries
        and properties, and thus committing a property change to an
        out-of-date directory may destroy properties you've not yet
        seen.</para>

    </sect2>

  </sect1>

  <sect1 id="svn-ch-2-sect-4">
    <title>Summary</title>
    
    <para>We've covered a number of fundamental Subversion concepts in
    this chapter:</para>

    <itemizedlist>
      <listitem>
        <para>We've introduced the notions of the central repository,
          the client working copy, and the array of repository
          revision trees.</para>
      </listitem>

      <listitem>
        <para>We've seen some simple examples of how two collaborators
        can use Subversion to publish and receive changes from one
        another, using the 'copy-modify-merge' model.</para>
      </listitem>

      <listitem>
        <para>We've talked a bit about the way Subversion tracks and
          manages information in a working copy.</para>
      </listitem>

    </itemizedlist>
    
    <para>At this point, you should have a good idea of how Subversion
    works in the most general sense.  Armed with this knowledge, you
    should now be ready to jump into the next chapter, which is a
    detailed tour of Subversion's commands and features. </para>
      
  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
