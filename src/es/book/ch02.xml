<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- originated from English revision 652 -->
<!-- Modeline para usuarios del editor vim
vim: set expandtab tabstop=2 shiftwidth=2 textwidth=78:
-->
<chapter id="svn-ch-2">
  <title>Conceptos básicos</title>

  <simplesect>
    <para>Este capítulo es una introducción breve e informal a Subversion.
      Si es nuevo en el tema del control de versiones, este capítulo es
      definitivamente para usted. Empezaremos tratando los conceptos
      generales en el control de versiones, seguiremos con las ideas específicas
      detrás de Subversion, y mostraremos algunos ejemplos simples de Subversion
      en acción.</para>
    
    <para>Aunque los ejemplos de este capítulo muestran a gente
      compartiendo colecciones de archivos de código fuente, tenga en mente
      que Subversion puede manejar cualquier tipo de colección de
      archivos&mdash;no está limitado a asistir a programadores de
      ordenadores.</para>
  </simplesect>
  
  
  <sect1 id="svn-ch-2-sect-1" > 
    <title>El repositorio</title>  
    
    <para>Subversion es un sistema centralizado para compartir información.
      La parte principal de Subversion es el repositorio, el cual es un 
      almacén central de datos.
      El repositorio guarda información en forma de
      <firstterm>árbol de archivos</firstterm>&mdash;una típica jerarquía
      de archivos y directorios. Cualquier número de <firstterm>clientes</firstterm>
      puede conectarse al repositorio y luego leer o escribir en esos archivos.
      Al escribir datos, un cliente pone a disposición de otros la información;
      al leer datos, el cliente recibe información de otros.  
      La figura <xref linkend="svn-ch-2-dia-1"/> ilustra ésto.</para>

    <figure id="svn-ch-2-dia-1">
      <title>Un sistema cliente/servidor típico</title>
      <graphic fileref="images/ch02dia1.png"/>
    </figure>
    
    <para>Entonces, ¿qué tiene ésto de interesante?. Hasta ahora, 
      suena como la definición del típico servidor de archivos.
      Y, de hecho, el repositorio <emphasis>es</emphasis> una especie de
      servidor de archivos, pero no del tipo habitual. Lo que hace 
      especial al repositorio de Subversion es que <emphasis>recuerda
      todos los cambios</emphasis> hechos sobre él: cada cambio a cada
      archivo, e inclusive cambios al propio árbol de directorios, tales
      como la adición, borrado y reubicación de archivos y directorios.</para>

    <para>Cuando un cliente lee datos del repositorio, normalmente sólo ve
      la ultima versión del árbol de archivos. Sin embargo, el cliente
      también tiene la posibilidad de ver estados <emphasis>previos</emphasis>
      del sistema de archivos. Por ejemplo, un cliente puede hacer
      consultas históricas como, <quote>¿Qué contenía este directorio 
      el miércoles pasado?</quote> Esta es la clase de preguntas que resulta
      esencial en cualquier <firstterm>sistema de control de versiones</firstterm>:
      sistemas que están diseñados para registrar y seguir los cambios en
      los datos a través del tiempo.
    </para>

  </sect1>

  <sect1 id="svn-ch-2-sect-2">
    <title>Modelos de versionamiento</title>

    <para>La misión principal de un sistema de control de versiones
      es permitir la edición colaborativa y la compartición de los datos.
      Sin embargo, existen diferentes sistemas que utilizan diferentes 
      estrategias para alcanzar este objetivo.</para>
    
    <sect2 id="svn-ch-2-sect-2.1">
      <title>El problema de compartir archivos</title>
      
      <para>Todos los sistemas de control de versiones tienen que resolver
        un problema fundamental: ¿Cómo permitirá el sistema a los usuarios
        el compartir información, pero al mismo tiempo impedirá que se pisen 
        los callos mutuamente de forma accidental? Es muy sencillo para los 
        usuarios el sobreescribir accidentalmente los cambios de los demás en el
        repositorio.</para>

      <para>Considere el escenario mostrado en <xref linkend="svn-ch-2-dia-2"/>.
        Suponga que tenemos dos colaboradores, Harry y Sally. Cada uno de
        ellos decide editar el mismo archivo del repositorio al mismo tiempo.
        Si Harry guarda sus cambios en el repositorio en primer lugar, es 
        posible que (unos momentos más tarde) Sally los sobreescriba 
        accidentalmente con su propia versión del archivo. Si bien es
        cierto que la versión de Harry no se ha perdido para siempre (porque el
        sistema recuerda cada cambio), cualquier cambio que Harry haya hecho
        <emphasis>no</emphasis> estará presente en la versión más reciente de Sally
        porque, para empezar, ella nunca vio los cambios de Harry. El
        trabajo de Harry sigue efectivamente perdido&mdash;o al menos
        ausente en la última versión del archivo&mdash;y probablemente por
        accidente. ¡Esta es definitivamente una situación que queremos evitar!</para>

      <figure id="svn-ch-2-dia-2">
        <title>El problema a evitar</title>
        <graphic fileref="images/ch02dia2.png"/>
      </figure>

      </sect2>
    
    <sect2 id="svn-ch-2-sect-2.2">
      <title>La solución bloqueo-modificación-desbloqueo</title>
      
      <para>Muchos sistemas de control de versiones utilizan un modelo de
        <firstterm>bloqueo-modificación-desbloqueo</firstterm> para atacar
        este problema. En un sistema como éste, el repositorio sólo permite
        a una persona modificar un archivo al mismo tiempo. Harry debe
        <quote>bloquear</quote> primero el archivo para luego empezar a
        hacerle cambios. Bloquear un archivo se parece mucho a pedir prestado un
        libro de la biblioteca; si Harry ha bloqueado el archivo, entonces
        Sally no puede hacerle cambios. Por consiguiente, si ella intenta bloquear 
        el archivo, el repositorio rechazará la petición. Todo lo que puede hacer 
        es leer el archivo y esperar a que Harry termine sus cambios y deshaga el
        bloqueo. Tras desbloquear Harry el archivo, Sally puede aprovechar su turno
        bloqueando y editando el archivo. La figura
        <xref linkend="svn-ch-2-dia-3"/> demuestra esta sencilla solución.</para>
      
      <figure id="svn-ch-2-dia-3">
        <title>La solucion bloqueo-modificación-desbloqueo</title>
        <graphic fileref="images/ch02dia3.png"/>
      </figure>
      
      <para>El problema con el modelo bloqueo-modificación-desbloqueo es que
        es un tanto restrictivo y a menudo se convierte en un obstáculo para
        los usuarios:</para>

      <itemizedlist>
        <listitem><para>
            <emphasis>Bloquear puede causar problemas administrativos.</emphasis>


            En ocasiones Harry bloqueará un archivo y se olvidará de él. Mientras
            tanto, como Sally está aún esperando para editar el archivo, sus
            manos están atadas. Y luego Harry se va de vacaciones. Ahora Sally
            debe conseguir que un administrador deshaga el bloqueo de Harry.
            La situación termina causando muchas demoras innecesarias y
            pérdida de tiempo.
            </para></listitem>
        
        <listitem><para>
            <emphasis>Bloquear puede causar una serialización innecesaria.</emphasis>

            ¿Qué sucede si Harry está editando el inicio de un archivo de texto
            y Sally simplemente quiere editar el final del mismo archivo?
            Estos cambios no se solapan en absoluto. Ambos podrían editar el
            archivo simultáneamente sin grandes perjuicios, suponiendo
            que los cambios se combinaran correctamente. No hay necesidad
            de turnarse en esta situación.
            </para></listitem>
    
        <listitem><para>
            <emphasis>Bloquear puede causar una falsa sensación de seguridad.</emphasis>

            Imaginemos que Harry bloquea y edita el archivo A, mientras que
            Sally bloquea y edita el archivo B al mismo tiempo. Pero suponga
            que A y B dependen uno del otro y que los cambios hechos a cada
            uno de ellos son semánticamente incompatibles. Súbitamente A y B ya no
            funcionan juntos. El sistema de bloqueo se mostró ineficaz a la hora de
            evitar el problema&mdash;sin embargo, y de algún modo, ofreció
            una falsa sensación de seguridad. Es fácil para Harry y Sally
            imaginar que al bloquear archivos, cada uno está empezando una
            tarea segura y aislada, lo cual les inhibe de discutir sus cambios
            incompatibles desde un principio.
            </para></listitem>
      </itemizedlist>

      </sect2>

    <sect2 id="svn-ch-2-sect-2.3">
      <title>La solución copiar-modificar-mezclar</title>
      
      <para>Subversion, CVS y otros sistemas de control de versiones
        utilizan un modelo del tipo
        <firstterm>copiar-modificar-mezclar</firstterm> como alternativa
        al bloqueo. En este modelo, el cliente de cada usuario se conecta al
        repositorio del proyecto y crea una <firstterm>copia de
          trabajo</firstterm> personal&mdash;una réplica local de los
        archivos y directorios del repositorio. Los usuarios pueden entonces
        trabajar en paralelo, modificando sus copias privadas. Finalmente, todas
        las copias privadas se combinan (o mezclan) en una nueva versión final. 
        El sistema de control de versiones a menudo ayuda con la mezcla, pero en 
        última instancia es un ser humano el responsable de hacer que ésto suceda 
        correctamente.
      </para>
      
      <para>He aquí un ejemplo. Digamos que Harry y Sally crean sendas copias
        de trabajo del mismo proyecto, extraídas del repositorio. Ambos
        trabajan concurrentemente y hacen cambios a un mismo archivo A dentro de 
        sus copias. Sally guarda sus cambios en el repositorio primero. Cuando Harry
        intenta guardar sus cambios más tarde, el repositorio le informa de que
        su archivo A está <firstterm>desactualizado</firstterm>. En otras
        palabras, que el archivo A en el repositorio ha sufrido algún cambio
        desde que lo copió por última vez. Por tanto, Harry le pide a su cliente
        que <firstterm>mezcle</firstterm> cualquier cambio nuevo del
        repositorio con su copia de trabajo del archivo A. Es probable que los
        cambios de Sally no se solapen con los suyos; así que una vez que tiene
        ambos juegos de cambios integrados, Harry guarda su copia de trabajo
        de nuevo en el repositorio. Las figuras <xref
        linkend="svn-ch-2-dia-4"/> y <xref linkend="svn-ch-2-dia-5"/>
        muestran este proceso.</para>

      <figure id="svn-ch-2-dia-4">
        <title>La solución copiar-modificar-mezclar</title>
        <graphic fileref="images/ch02dia4.png"/>
      </figure>
      
      <figure id="svn-ch-2-dia-5">
        <title>La solución copiar-modificar-mezclar (continuación)</title>
        <graphic fileref="images/ch02dia5.png"/>
      </figure>

      <para>¿Pero qué ocurre si los cambios de Sally <emphasis>sí</emphasis>
        se solapan con los de Harry? ¿Entonces qué? Esta situación se conoce
        como <firstterm>conflicto</firstterm> y no suele suponer un gran problema. 
        Cuando Harry le pide a su cliente que mezcle los últimos
        cambios del repositorio en su copia de trabajo, su copia del archivo A
        se marca de algún modo para indicar que está en estado de conflicto: 
        Harry podrá ver ambos conjuntos de cambios conflictivos y escoger manualmente
        entre ellos. Observe que el programa no puede resolver automáticamente
        los conflictos; sólo los humanos son capaces de entender y tomar las
        decisiones inteligentes oportunas. Una vez que Harry ha resuelto
        manualmente los cambios solapados&mdash;posiblemente después de
        discutirlos con Sally&mdash;ya podrá guardar con seguridad el archivo
        mezclado en el repositorio.</para>

      <para>La solución copiar-modificar-mezclar puede sonar un tanto caótica,
        pero en la práctica funciona extremadamente bien. Los usuarios pueden
        trabajar en paralelo, sin tener que esperarse el uno al otro. Cuando
        trabajan en los mismos archivos, sucede que la mayoría de sus cambios
        concurrentes no se solapan en absoluto; los conflictos son poco
        frecuentes. El tiempo que toma resolver los conflictos es mucho menor
        que el tiempo perdido por un sistema de bloqueos.</para>

      <para>Al final, todo desemboca en un factor crítico: la comunicación
        entre los usuarios. Cuando los usuarios se comunican pobremente, los
        conflictos tanto sintácticos como semánticos aumentan. Ningún sistema
        puede forzar a los usuarios a comunicarse perfectamente, y ningún
        sistema puede detectar conflictos semánticos. Por consiguiente, no
        tiene sentido dejarse adormecer por la falsa promesa de que un
        sistema de bloqueos evitará de algún modo los conflictos; en
        la práctica, el bloqueo parece inhibir la productividad más que otra cosa.
        </para>
      
    </sect2>
    
  </sect1>
  
  <!-- Cómo svn implementa esta filosofía -->
  <sect1 id="svn-ch-2-sect-3">
    <title>Subversion en acción</title>
    
    <para>Es hora de movernos de lo abstracto a lo concreto. En esta sección
      mostraremos ejemplos reales de Subversion en la práctica.</para>

    <sect2 id="svn-ch-2-sect-3.1">
      <title>Copias de trabajo</title>
      
      <para>Ya ha leído acerca de las copias de trabajo; ahora demostraremos 
        cómo las crea y las usa el cliente de Subversion.</para>
      
      <para>Una copia de trabajo de Subversion es un árbol de directorios
        corriente de su sistema de archivos local, conteniendo una colección
        de archivos. Usted puede editar estos archivos del modo que prefiera y
        si se trata de archivos de código fuente, podrá compilar su
        programa a partir de ellos de la manera habitual. Su copia de trabajo 
        es su área de trabajo privada: Subversion nunca incorporará los cambios 
        de otra gente o pondrá a disposición de otros sus cambios hasta que 
        usted le indique explícitamente que lo haga.</para>

      <para>Tras hacer algunos cambios a los archivos en su copia
        de trabajo y verificar que funcionan correctamente, Subversion le
        proporciona comandos para <quote>publicar</quote> sus cambios al
        resto de personas que trabajan con usted en su proyecto 
        (escribiendo en el repositorio). Si las demás personas publican sus 
        propios cambios, Subversion le proporciona comandos para mezclar 
        estos cambios en su directorio de trabajo (leyendo del repositorio).</para>

      <para>Una copia de trabajo también contiene algunos archivos extra,
        creados y mantenidos por Subversion para ayudarle a ejecutar estos
        comandos. En particular, cada directorio de su copia de trabajo
        contiene un subdirectorio llamado <filename>.svn</filename>, también
        conocido como el <firstterm>directorio administrativo</firstterm> de
        la copia de trabajo. Los archivos en cada directorio administrativo 
        ayudan a Subversion a reconocer qué archivos contienen cambios no
        publicados y qué archivos estan desactualizados con respecto al
        trabajo hecho por los demás.</para>
      
      <para>Un repositorio típico de Subversion contiene a menudo los archivos
        (o el código fuente) de varios proyectos; normalmente, cada proyecto es
        un subdirectorio en el árbol del sistema de archivos del repositorio.
        En esta disposición, la copia de trabajo de un usuario se corresponde 
        habitualmente con un subárbol particular del repositorio.</para>
      
      <para>Por ejemplo, suponga que usted tiene un repositorio que contiene
        dos proyectos de software, <literal>paint</literal> y
        <literal>calc</literal>. Cada proyecto reside en su propio subdirectorio
        dentro del directorio raíz, tal como se muestra en <xref
        linkend="svn-ch-2-dia-6"/>.</para>

      <figure id="svn-ch-2-dia-6">
        <title>El sistema de archivos del repositorio</title>
        <graphic fileref="images/ch02dia6.png"/>
      </figure>
      
      <!--TODO: buscar un mejor termino en castellano para explicar 'check
      out'-->
      <para>Para conseguir una copia de trabajo, debe ejecutar primero
        un <firstterm>check out</firstterm> de algún subárbol del
        repositorio. (El término inglés <quote>check out</quote> puede sonar como 
        si tuviera algo que ver con bloquear o reservar recursos, pero no es así; 
        tan sólo crea una copia privada del proyecto para usted). Por ejemplo, si 
        usted hace un check out de <filename>/calc</filename>, obtendrá una copia de
        trabajo como ésta:</para>

<screen>
$ svn checkout http://svn.example.com/repos/calc
A  calc
A  calc/Makefile
A  calc/integer.c
A  calc/button.c

$ ls -A calc
Makefile  integer.c  button.c  .svn/
</screen>


      <para>La lista de letras A indica que Subversion está añadiendo una
        serie de elementos a su copia de trabajo. Usted ahora tiene una copia
        personal del directorio <filename>/calc</filename> del repositorio,
        con una entrada adicional&mdash;<filename>.svn</filename>&mdash;que
        contiene la información extra que Subversion necesita, tal y como se
        mencionó anteriormente.</para>

      <sidebar id="svn-ch-2-sidebar-1">
        <title>URLs del repositorio</title>

        <para>A los repositorios de Subversion se puede acceder a través de
          diferentes métodos&mdash;en el disco local, o a través de varios
          protocolos de red. Sin embargo, la ubicación de un repositorio es siempre
          un URL. La tabla 2-1 describe la correspondencia entre los diferentes 
          esquemas de URL y los métodos de acceso disponibles.</para>

        <table id="svn-ch-2-table-1">
          <title>URLs de Acceso al Repositorio</title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Esquema</entry>
                <entry>Método de acceso</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><literal>file:///</literal></entry>
                <entry>acceso directo al repositorio (en disco local)</entry>
              </row>
              <row>
                <entry><literal>http://</literal></entry>
                <entry>acceso vía protocolo WebDAV a un servidor
                  Apache que entiende de Subversion</entry>
              </row>
              <row>
                <entry><literal>https://</literal></entry>
                <entry>igual que <literal>http://</literal>, pero con
                  encriptación SSL.</entry>
              </row>
              <row>
                <entry><literal>svn://</literal></entry>
                <entry>acceso vía un protocolo personalizado a un servidor
                  <literal>svnserve</literal>.</entry>
              </row>
              <row>
                <entry><literal>svn+ssh://</literal></entry>
                <entry>igual que <literal>svn://</literal>, pero a través de 
                  un túnel SSH.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
 
        <para>En general, los URLs de Subversion utilizan la sintaxis
          estándar, permitiendo la especificación de nombres de servidores 
          y números de puertos como parte del URL. Recuerde que el método
          de acceso <literal>file:</literal> es válido sólo para ubicaciones
          en el mismo servidor donde se ejecuta el cliente&mdash;de hecho, se
          requiere por convención que la parte del URL con el nombre del 
          servidor esté ausente o sea <literal>localhost</literal>:</para>

        <screen>
$ svn checkout file:///ruta/a/repositorio
&hellip;
$ svn checkout file://localhost/ruta/a/repositorio
&hellip;
</screen>

        <para>Además, los usuarios del esquema <literal>file:</literal> en
          plataformas Windows necesitarán usar una sintaxis
          <quote>estándar</quote> extraoficial para acceder  a repositorios
          que están en la misma máquina, pero en una unidad de disco distinta
          de la que el cliente esté utilizando en el momento. Cualquiera de
          las dos siguientes sintaxis para rutas de URL funcionarán siendo
          <literal>X</literal> la unidad donde reside el repositorio:</para>

        <screen>
C:\> svn checkout file:///X:/ruta/a/repositorio
&hellip;
C:\> svn checkout "file:///X|/ruta/a/repositorio"
&hellip;
</screen>
 
        <para>En la segunda sintaxis, es necesario encerrar el URL entre comillas
          para que la barra vertical no sea interpretada como una tubería.</para>

        <para>Nótese que un URL usa barras de separación ordinarias aún cuando 
          la forma de ruta nativa (no para URLs) en Windows utiliza barras
          invertidas.</para>

      </sidebar>

      <!--TODO: revisar para agregar notas del traductor para 'commit' y
      'check in' -->
      <para>Suponga que hace cambios a <filename>button.c</filename>. Puesto
        que el directorio <filename>.svn</filename> recuerda la fecha de
        modificación del archivo y su contenido original, Subversion es capaz de 
        darse cuenta de que el archivo ha cambiado. Sin embargo, Subversion no hará
        públicos sus cambios hasta que usted no le diga explícitamente que lo haga. 
        El acto de publicar sus cambios es conocido comúnmente como 
        <firstterm>consignar</firstterm> (o <firstterm>registrar</firstterm>)
        los cambios al repositorio.</para>

      <para>Para publicar sus cambios a otros, usted puede utilizar el comando
        <command>commit</command> de Subversion:</para>

<screen>
$ svn commit button.c
Sending        button.c
Transmitting file data .
Committed revision 57.
</screen>

      <para>Ahora sus cambios a <filename>button.c</filename> han sido
        consignados al repositorio; si otro usuario obtiene una copia de trabajo
        de <filename>/calc</filename>, podrá ver sus cambios en la última
        versión del archivo.</para>

      <para>Suponga que tiene un colaborador, Sally, quien obtuvo una
        copia de trabajo de <filename>/calc</filename> al mismo tiempo
        que usted. Cuando usted envía sus cambios sobre
        <filename>button.c</filename>, la copia de trabajo de Sally se deja
        sin cambios; Subversion solo modifica las copias de trabajo a
        petición del usuario.</para>

      <para>Para tener su proyecto actualizado, Sally puede pedir a
        Subversion que proceda a <firstterm>actualizar</firstterm> su copia de 
        trabajo, usando para ello el comando <command>update</command> de Subversion.
        Ésto incorporará los cambios hechos por usted en la copia de trabajo de Sally, 
        así como otros cambios consignados desde que ella hizo el check out.</para>

<screen>
$ pwd
/home/sally/calc

$ ls -A 
.svn/ Makefile integer.c button.c

$ svn update
U button.c
</screen>

      <para>La salida del comando <command>svn update</command>
        indica que Subversion actualizó el contenido de
        <filename>button.c</filename>. Observe que Sally no necesitó
        especificar qué archivos actualizar; Subversion usa la información
        del directorio <filename>.svn</filename>, junto con 
        información adicional del repositorio, para decidir qué archivos 
        necesitan una actualización.</para>
      
    </sect2>
    
    
    <sect2 id="svn-ch-2-sect-3.2">
      <title>Revisiones</title>

      <para>Una operación <command>svn commit</command> puede publicar
        los cambios sobre cualquier número de ficheros y directorios
        como una única transacción atómica. En su copia privada, usted
        puede cambiar el contenido de los ficheros, crear, borrar, 
        renombrar y copiar ficheros y directorios, y luego enviar
        el conjunto entero de cambios como si se tratara de una 
        unidad.</para>
      
      <para>En el repositorio, cada cambio es tratado como una transacción
        atómica: o bien se realizan todos los cambios, o no se realiza
        ninguno. Subversion trata de conservar esta atomicidad para
        hacer frente a posibles fallos del programa, fallos del sistema,
        problemas con la red, y otras acciones del usuario.</para>

      <para>Cada vez que el repositorio acepta un envío, éste da lugar
        a un nuevo estado del árbol de ficheros llamado
        <firstterm>revisión</firstterm>. A cada revisión se le asigna
        un número natural único, una unidad mayor que el número de
        la revisión anterior. La revisión inicial de un repositorio
        recién creado se numera con el cero, y consiste únicamente
        en un directorio raíz vacío.</para>
      
      <para>La <xref linkend="svn-ch-2-dia-7"/> ilustra una manera
        interesante de ver el repositorio. Imagine un array de números
        de revisión, comenzando por el 0, que se extiende de izquierda
        a derecha. Cada número de revisión tiene un árbol de ficheros
        colgando debajo de él, y cada árbol es una <quote>instantánea</quote>
        del aspecto del repositorio tras cada envío.</para>
      
      <figure id="svn-ch-2-dia-7">
        <title>El repositorio</title>
        <graphic fileref="images/ch02dia7.png"/>
      </figure>

      <sidebar>
        <title>Números de revisión global</title>
         
        <para>A diferencia de muchos otros sistemas de control de
          versiones, los números de revisión de Subversion se aplican
          a <emphasis>árboles enteros</emphasis>, no a ficheros 
          individuales. Cada número de revisión selecciona un árbol
          completo, un estado particular del repositorio tras
          algún cambio publicado. Otra manera de ver ésto es que
          la revisión N representa el estado del sistema de ficheros
          del repositorio tras el envío de cambios N-ésimo. Cuando 
          un usuario de Subversion habla de la <quote>revisión 5 de
          <filename>foo.c</filename></quote>, lo que realmente quiere
          decir es <quote><filename>foo.c</filename> tal como aparece en
          la revisión 5.</quote> Observe que en general, ¡las revisiones
          N y M de un fichero <emphasis>no</emphasis> tienen por qué
          ser diferentes necesariamente! Dado que CVS utiliza números
          de revisión para cada fichero, los usuarios de CVS pueden querer
          echar un vistazo a <xref linkend="svn-ap-a"/> 
          para más detalles.</para>
      </sidebar>

      <para>Es importante observar que las copias de trabajo no siempre se
        corresponden con una revisión en particular del repositorio; 
        pueden contener ficheros de varias revisiones diferentes. Por 
        ejemplo, suponga que obtiene una copia de trabajo de un
        repositorio cuya revisión más reciente es la 4:</para>

<screen>
calc/Makefile:4
     integer.c:4
     button.c:4
</screen>

      <para>Por el momento, esta copia de trabajo se corresponde
        exactamente con la revisión 4 del repositorio. Sin embargo,
        suponga que realiza un cambio a <filename>button.c</filename>
        y lo publica. Suponiendo que no se han realizado otros envíos,
        el suyo creará la revisión 5 del repositorio, y su copia 
        de trabajo aparecerá ahora así:</para>

<screen>
calc/Makefile:4
     integer.c:4
     button.c:5
</screen>
    
      <para>Suponga que, en este punto, Sally envía un cambio a
        <filename>integer.c</filename>, creando la revisión 6. Si
        usted usa <command>svn update</command> para actualizar
        su copia de trabajo, ésta se verá ahora como:</para>

<screen>
calc/Makefile:6
     integer.c:6
     button.c:6
</screen>

      <para>Los cambios de Sally sobre <filename>integer.c</filename>
        aparecerán en su copia de trabajo y las modificaciones hechas
        por usted seguirán presentes en <filename>button.c</filename>.  
        En este ejemplo, el texto de <filename>Makefile</filename> es
        idéntico en las revisiones 4, 5 y 6, aunque Subversion marcará
        su copia de trabajo de Makefile con la revisión 6 para indicar
        que ya está actualizada. Por lo tanto, después de hacer una
        actualización limpia en el directorio raíz de su copia
        de trabajo, ésta se corresponderá generalmente con una
        revisión del repositorio exactamente.</para>

    </sect2>
    
    
    <sect2 id="svn-ch-2-sect-3.3">
      <title>Cómo las copias de trabajo siguen la pista al repositorio</title>
      
      <para>Para cada fichero de una copia de trabajo, Subversion registra
        dos datos esenciales en el área administrativa 
        <filename>.svn/</filename>:</para>
      
      <itemizedlist>
        <listitem><para>revisión en la que está basado el fichero de la
            copia de trabajo (ésto se llama la <firstterm>revisión
              de trabajo</firstterm> del fichero), y</para></listitem>
        
        <listitem><para>una marca de tiempo con la fecha de la
            última actualización del fichero desde el repositorio.</para>
        </listitem>
      </itemizedlist>

      <para>Con esta información, y comunicándose con el repositorio,
        Subversion puede conocer en cuál de los cuatro estados siguientes
        se encuentra el fichero de la copia de trabajo:</para>

      <variablelist>
        <varlistentry>
          <term>Sin cambios y actualizado</term> 

          <listitem><para>El fichero no ha sido modificado en la copia
          de trabajo ni se ha enviado ningún cambio sobre ese fichero al
          repositorio desde su revisión de trabajo. Un
          <command>svn commit</command> de ese fichero no hará nada,
          y un <command>svn update</command> del fichero tampoco hará 
          nada. </para></listitem>
        </varlistentry>
        
        <varlistentry>
          <term>Modificado localmente y actualizado</term>

          <listitem><para>El fichero ha sido modificado en la copia de
          trabajo pero no se ha enviado ningún cambio sobre ese fichero al
          repositorio desde su revisión base. Hay cambios locales
          que no han sido enviados al repositorio, por lo que un
          <command>svn commit</command> del fichero publicará con éxito
          sus cambios, y un <command>svn update</command> del
          fichero no hará nada.</para></listitem>
        </varlistentry>
        
        <varlistentry>
          <term>Sin cambios y desactualizado</term> 

          <listitem><para>El fichero no ha sido modificado en la
          copia de trabajo, pero sí en el repositorio.  El fichero 
          debería ser actualizado para sincronizarlo con la revisión
          pública.  Un <command>svn commit</command> del fichero no 
          hará nada, y un <command>svn update</command> del fichero
          introducirá los últimos cambios en su copia de trabajo.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term>Modificado localmente y desactualizado</term>

          <listitem><para>El fichero ha sido modificado tanto en la
          copia de trabajo como en el repositorio.  Un <command>svn
          commit</command> del fichero fallará dando un error de 
          <quote>desactualizado</quote>.  El fichero debe ser
          actualizado primero; un <command>svn update</command>
          intentará mezclar los cambios públicos con los cambios
          locales. Si Subversion no puede combinar los cambios
          de manera convincente automáticamente, dejará que sea
          el usuario el que resuelva el conflicto.</para></listitem>
        </varlistentry>
      </variablelist>
      
      
      <para>Todo ésto puede parecer un montón de cosas a tener en cuenta,
        pero el comando <command>svn status</command> le mostrará el estado
        de cualquier elemento de su copia de trabajo. Para obtener más 
        información acerca de ese comando, vea 
        <xref linkend="svn-ch-3-sect-4.3.1" />.</para>
     
    </sect2>
    
    <sect2 id="svn-ch-2-sect-3.4">
      <title>Las limitaciones de las revisiones mixtas</title>

      <para>Por norma general, Subversion trata de ser tan flexible
        como sea posible. Un tipo especial de flexibilidad es la habilidad
        para tener dentro de una copia de trabajo números de revisión
        mixtos.</para>

      <para>Para comenzar, puede que no esté completamente claro el 
        por qué este tipo de flexibilidad se considera una característica
        y no un problema. Después de completar un envío al repositorio,
        los ficheros y directorios recién enviados se encuentran
        en una revisión de trabajo más reciente que el resto de la copia
        de trabajo. Parece un poco lioso. Tal como se mostró
        anteriormente, siempre se puede dejar una copia de trabajo
        en una única revisión de trabajo ejecutando 
        <command>svn update</command>. ¿Por qué querría alguien
        <emphasis>deliberadamente</emphasis> tener una mezcla
        de revisiones de trabajo?</para>

      <para>Suponiendo que su proyecto es lo suficientemente complejo,
        descubrirá que a veces es conveniente forzar la
        <quote>desactualización</quote> de ciertas partes de su copia
        de trabajo a una versión anterior; aprenderá cómo hacer ésto en el 
        capítulo 3. Quizás quiera probar una versión anterior de un submódulo
        contenido en un subdirectorio, o tal vez quiera examinar
        una serie de versiones previas de un fichero en el contexto
        del último árbol.</para>
        
      <para>Por mucho que usted haga uso de revisiones mixtas en 
        su copia de trabajo, hay ciertas limitaciones asociadas a esta
        flexibilidad.</para>

      <para>Primero, usted no puede publicar la eliminación de un fichero
        o directorio que no esté completamente actualizado. Si existe 
        una versión más reciente en el repositorio, su intento de 
        eliminación será rechazado para impedir que destruya accidentalmente
        cambios que aún no ha visto.</para>

      <para>Segundo, usted no puede publicar los cambios en los metadatos
        de un directorio a menos que esté completamente actualizado. 
        Aprenderá cómo adjuntar <quote>propiedades</quote> a elementos
        en el capítulo 6. Una revisión de trabajo de un directorio define
        un conjunto específico de entradas y propiedades, y por tanto
        enviar un cambio a una propiedad de un directorio desactualizado
        puede destruir las propiedades que no haya visto todavía.</para>

    </sect2>

  </sect1>

  <sect1 id="svn-ch-2-sect-4">
    <title>Resumen</title>
    
    <para>A lo largo de este capítulo hemos tratado una serie de conceptos 
    fundamentales acerca de Subversion:</para>

    <itemizedlist>
      <listitem>
        <para>Hemos introducido las nociones de repositorio central,
          la copia de trabajo del cliente, y el array de árboles de
          revisiones del repositorio.</para>
      </listitem>

      <listitem>
        <para>Hemos visto algunos ejemplos sencillos de cómo dos
        colaboradores pueden usar Subversion para publicar y recibir
        cambios uno del otro usando el modelo 'copiar-modificar-mezclar'.
        </para>
      </listitem>

      <listitem>
        <para>Hemos hablado un poco sobre la manera en que Subversion
        sigue y maneja la información de una copia de trabajo.</para>
      </listitem>

    </itemizedlist>
    
    <para>A estas alturas usted ya debería tener una idea más o menos clara
    de cómo funciona Subversion a nivel general. Armado con este conocimiento, 
    debería estar listo para pasar al siguiente capítulo, el cual es un
    recorrido detallado por los comandos y características de Subversion. </para>
      
  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
