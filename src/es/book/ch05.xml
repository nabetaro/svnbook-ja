<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- originated from English revision 10817 -->
<chapter id="svn-ch-5">
<title>Administración del Repositorio</title>

  <simplesect>

    <para>El repositorio de Subversion es el almacén central
      de datos y versiones para un número indeterminado de proyectos;
      de esta manera se convierte en el destinatario obvio
      de todo el amor y atención que un administrador puede ofrecer.
      Aunque el repositorio es, en general, un elemento de bajo
      mantenimiento, es importante entender cómo configurarlo
      y cuidarlo correctamente para evitar problemas potenciales
      y para solucionar los problemas actuales de forma segura.</para>

    <para>En este capítulo, explicaremos cómo crear y configurar
      un repositorio Subversion, y cómo publicarlo para acceder a él
      por red. También hablaremos acerca del mantenimiento del
      repositorio, incluyendo el uso de las herramientas
      <command>svnlook</command> y <command>svnadmin</command>
      ( que están disponibles junto con Subversion ). 
      Trataremos también algunas preguntas y errores comunes,
      y haremos sugerencias sobre la forma de 
      <!--TODO: arrange how to arrange the data in ... -->
      arreglar los datos en el repositorio.</para>

    <para>Si planea acceder al repositorio Subversion sólo desde el
      punto de vista de un usuario cuyos datos están bajo control
      de versiones ( es decir, un cliente Subversion ), puede saltarse
      este capítulo en conjunto.
      Sin embargo, si vd. es, o quiere convertirse en un administrador
      de repositorios Subversion,
      <footnote>
        <para>Puede sonar realmente prestigioso y <!--TODO: lofty: alto?
        This may sound really prestigious and lofty -->, pero sólo
        estamos hablando de cualquier personal que esté interesada en 
        el misterioso reino más allá de la copia de trabajo, donde
        los datos de todos <!--TODO: hang out?
        where everyone's data hangs out. --></para>
      </footnote>
      debería sin lugar a dudas prestar atención a este capítulo.</para>

  </simplesect>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 1:  REPOSITORY BASICS                               *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-5-sect-1">
    <title>Cuestiones básicas acerca de el repositorio</title>

    <para>Antes de entrar en el tema principal de la administración
      del repositorio, vamos a definir con más detalla qué es un repositorio.
      ¿Qué pinta tiene? ¿Cómo se siente? ¿Se toma el té caliente o helado,
      dulce, y con limón? Como administrador, necesitará entender la
      composición de un repositorio desde una perspectiva lógica&mdash;
      <!--TODO: deal-->dealing con cómo se representa la información
      dentro del repositorio&mdash;y desde una perspectiva <!--TODO:
      nuts-and-bolts-->&mdash;qué apariencia tiene y cómo actúa un
      repositorio con respecto a herramientas no pertenecientes a Subversion.
      La siguiente sección se ocupa de algunos de estos conceptos básicos
      a un nivel muy alto.</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-1.1">
      <title>Entendiendo las Transacciones y Revisiones</title>
        
      <para>Hablando conceptualmente, un repositorio Subversion es
        una secuencia de árboles de directorios. Cada árbol es una
  <!--TODO:snapshot=¿fotografía?-->fotografía de cómo eran 
  los ficheros y directorios versionados en tu repositorio en
  un momento determinado. Estas fotografías son generadas como
  resultado de operaciones de programas cliente, y son llamadas
  revisiones.</para>

      <para>Cada revisión nace como un árbol de transacciones. Cuando se
        envían cambios al repositorio, el programa cliente construye
        una transacción de Subversion que copia los cambios locales
        ( junto a cualquier cambio adicional que haya podido tener lugar
        desde el comienzo del proceso de envío de datos),
        y luego pide al repositorio que guarde ese árbol como la próxima
        <!--TODO: snapshot=fotografía -->fotograría en la secuencia.
        Si el envío de datos no da error, la transacción se convierte
        en una nueva revisión del árbol, y se le asigna un nuevo número de
        revisión. Si el envío de datos fallara por alguna razón,
  la transacción se destruye, y se le informa al cliente del error.</para>
        
      <para>Las actualizaciones funcionan de una manera parecida. El Cliente
        prepara un árbol de transacción temporal que <!--mirrors=copia?-->copia el estado
        de la copia de trabajo. El repositorio compara entonces ese
        árbol de transacción con el árbol de la revisión solicitada
        (normalmente la más reciente, o el árbol <quote>youngest</quote>), e
        informa al cliente acerca de qué cambios son necesario para
        convertir su copia local de trabajo en una réplica de ese árbol
        de revisión. Tras completarse la actualización, se borra la transacción 
        temporal.</para>
          
      <para>El uso de árboles de transacción es la única manera
        de hacer cambio permanentes en un repositorio de sistema
        de ficheros versionados. De todas maneras, es importante
        entender que el tiempo de vidad de una transacción es completamente
        flexible. En el caso de actualizaciones, las transacciones con árboles
        temporales que se destruyen inmediatamente. En el caso de <!--TODO commits-->
        commits, las transacciones son transformadas en revisiones
        permanentes ( o borradas si el <!--TODO--> falla ). En el 
        caso de un error, es posible que una transacción permanezca 
        accidentalmente suelta en el repositorio ( sin que afecte
        en realidad a nada, pero ocupando espacio).</para>
     
     <para>En teoría, un día los programas de flujo de trabajo completo
        deberán girar hacia un control más fino del tiempo de vida de
        la transacción. Es factible imaginar un sistema por el que
        cada transacción <!--TODO slated???--> que se convierta en
        revisión permanezca en <!--TODO: stasis?? --> bastante después
        de que el cliente termine de describir sus cambios al repositorio.
        Esto permitiría que cada nuevo <!--commit --> sea revisado
        por alguna otra persona, quizás un <!--manager-->director o 
        <!--TODO:engineering QA team-->, que pueda elegir entre promoverla
        a una revisión, o cancelarla.</para>
            
    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-1.2">
      <title>Propieades no versionadas</title>

      <para>Las transacciones y las revisiones en el repositorio
        subversion pueden tener propiedades adjuntas. Estas propiedades
        son mapeos genéricos clave-valor, y generalmente se usan
        para guardar información acerca del árbol al que están adjuntas.
        Los nombres y valores de estas propiedades se guardan en el
        sistema de ficheros del repositorio, junto con el resto de
        los datos de tu árbol.</para>

      <para>Las propiedades de revisiones y transacciones son útiles para
        asociar información con un árbol que no está estríctamente
        relacionada con los ficheros y directorios de ese árbol&mdash;el
        tipo de información que no es gestiona por las copias de trabajo
        de cliente. Por ejemplo, cuando una nueva transacción commit es
        creada en el repositorio, Subversion añade una propiedad a dicha
        transacción llamada <literal>svn:date</literal>&mdash; un
        datestamp <!--TODO: ¿traducir esto?--> que representa el momento
        en que la transacción se creó. En el momento que el proceso
        de commit termina, el árbol también ha recibido una propiedad
        para guardar el nombre del usuario que es autor de la revisión
        (<literal>svn:author</literal>) y una propiedad para guardar
        el mensaje de log <!--TODO: ¿traducir?--> adjunto a dicha
        revisión (<literal>svn:log</literal>).</para>

      <para>Las propiedades de revisiones y transacciones son
        <firstterm>propiedades no versinada</firstterm>&mdash;cuando
        son modificadas, sus valores previos se descartan definitivamente.
        Asímismo, mientras los árboles de revisiones en sí son inmutables,
        las propiedades adjuntas de dichos árboles no lo son. Puedes añadir,
        borrar, y modificar propiedades de revisiones en cualquier momento
        más adelante. Si envías al repositorio una nueva revisión y más tarde
        te das cuenta de alguna información incorrecta o un error sintáctico
        en tu mensaje de log, puedes simplemente sustituir el valor de
        la propiedad <literal>svn:log</literal> con un nuevo y corregido
        mensaje de log.</para>
  
    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-1.3">
      <title>Berkeley DB</title>

        <para>Los datos almacenados dentro de repositorios Subversion,
          realmente se encuentran en una base de datos, más concretamente,
          un fichero de base de datos Berkley DB. Durante la fase inicial
          de diseño de Subversion, los desarrolladores decicieron usar
          una base de datos Berkeley por una serie de razones, como
          su licencia open-source, soporte de transacciones, ser de confianza,
          funcionamiento, simplicidad de su API, soporte de hilos, cursores,
          y más.</para> 
  
        <para>La base de datos Berkely tiene un soporte real de transacciones
          &mdash;probablemente es su característica más poderosa.
          Muchos procesos que accede a tus repositorios Subversion
          not tienen que preocuparse por <!--TODO: ¿clobbering? --> los
          datos de otros. El aislamiento provisto por el sistema de
          transacciones es tal que por cada operación dada, el código
          de repositorio Subversion tiene una vista estática de la base
          de datos&mdash;no una base de datos que está constantemente
          cambiando de la mano de algunos otros procesos&mdash;y puede
          tomar decisiones basándose en esa vista. Si dicha decisión
          está en conflicto con lo que otro proceso esté haciendo,
          la operación completa <!--TODO: is rolled back --> como si nunca
          hubiera sucedido, y Subversion <!--TODO:gratefully--> reintenta
          la operación contra una nueva y actualizada ( y estática ) vista
          de la base de datos.</para>

        <para>Otra gran característica de la base de datos Berkeley son las
          <firstterm>copias de seguridad en caliente</firstterm>&mdash;
          la habilidad para hacer una copia de seguridad del entorno
          de la base de datos sin que tenga que estar <quote><!--TODO:offline--></quote>.
          Hablaremos sobre cómo hacer copias de seguridad de tu repositorio
          en <xref linkend="svn-ch-5-sect-3.6" />, pero los beneficios
          de ser capaz de hacer copias completas y funcionales de tus
          repositorios sin <!--TODO:downtime--> debería ser obvia.</para>

        <para>La base de datos Berkely también es un sistema de bases de
          datos de mucha confianza. Subversuion utiliza las utilidades
          de registro de las BD Berkeley, lo que significa
          que la base datos primero escribe una descripción de cualquier
          modificación que vaya a hacer en ficheros de registros, para luego
          hace la propia modificación. Esto es para asegurar que si
          algo fuese mal, el sistema de base de datos pueda retroceder
          a un <!--TODO:checkpoint--><firstterm>checkpoint</firstterm>&mdash;una
          posición en los ficheros de registro que se sabe que no están
          corruptas&mdash;y repetir transacciones hasta que los datos estén
          en un estado usable. Ver <xref linkend="svn-ch-5-sect-3.3"/>
          si quieres más información acerca de los ficheros de registro
    de las BD Berkeley.</para>

        <para>Pero toda rosa tiene su espina, así que tenemos que
          hablar sobre algunas conocidas limitaciones de la BD Berkeley.
          Primero, los entornos de BD Berkeley no son portables. No puedes
          copiar simplemente un repositorio Subversion que fue creado
          en un sistema Unix a un sistema Windows y esperar que funcione.
          Mientras mucho del formato de base de datos de la BD Berkeley
          es independiente de la arquitectura, hay otros aspectos del
    entorno que no lo son.
          Segundo, Subversion usa BD Berkeley de una manera que no puede
          funcionar en sistemas Windows 95/98&mdash;si necesita almacenar
          un repositorio en una máquina windows, <!--TODO stick-->utilice
          Windows 2000 o Windows XP. Finalmente, no deberías mantener un
          repositorio Subversion en una unidad compartida por red. Mientras
          las BD Berkeley prometen un comportamiento correcto en unidades
          compartidas por red que cumplan un grupo particular de especificaciones,
          casi ningún sistema de compartición conocico cumple con todas
          esas especificaciones.</para>

    </sect2>
  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 2:  REPOSITORY CREATION AND CONFIGURATION           *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-5-sect-2">
    <title>Creación y Configuración de Repositorios</title>

    <para>Crear un repositorio Subversion es una tarea increíblemente
      simple. La utilidad <command>svnadmin</command>, provista con 
      Subversion, tiene un subcomando justo para esto. Para crear un
      nuevo repositorio, ejecuta:</para>
          
    <screen>
$ svnadmin create /path/to/repos
</screen>
          
    <para>Crea un nuevo repositorio en el directorio
      <filename>/path/to/repos</filename>. Dicho nuevo repositorio comienza
      su vida en la revisión 0, que se define como nada excepto el directorio raíz
      (<filename>/</filename>) del sistema de ficheros. Inicialmente,
      la revisión 0 tiene también una única propiedad de revisión,
      <literal>svn:date</literal>, que tiene la hora a la que el
      el repositorio fue creado.</para>

    <warning>
      <para>No crees tu repositorio en una unidad de red compartida
        &mdash;no <emphasis>puede</emphasis> existir un un sistema
        de ficheros remoto como NFS, AFS, o Windows SMB. La DB Berkeley
        necesita que el sistema de ficheros subyacente implemente
        estrictamente la semántica de bloqueo POSIX, y más importante,
  la habilidad para mapear ficheros directamente <!--TODO into 
        process memory.--> Casi ningún sistema de ficheros de red
        tiene estas características. Si intentas usar una BD Berkeley
        en una unidad compartida de red, los resultados son impredecibles
        &mdash;puede que veas errores misteriosoo, o pueden pasar meses
        hasta que descubras que la base de datos de tu repositorio está
        sutilmente corrupta.</para>

      <para>Si necesitas que varios ordenadores accedan al repositorio,
        deberías instalar un proceso servidor ( como Apache o <command>svnserve</command>),
        almacenar el repositorio en un sistema de ficheros local al que
        el servidor pueda acceder, y hacer que el repositorio esté
        disponible por la red. <xref linkend="svn-ch-6"/> se ocupa
        de este proceso en detalle.</para>
    </warning>
          
    <para>Te habrás dado cuenta de que el argumento de ruta de
      <command>svnadmin</command> fue sólo una ruta normal del sistema
      de ficheros y no una URL como la que el programa cliente
      <command>svn</command> usa cuando se refiere a los repositorios.
      Tanto  <command>svnadmin</command> como <command>svnlook</command>
      son considerados como utilidades del lado del servidor&mdash;
      se usan en la máquina donde reside el repositorio para examinar
      o modificar aspectos del mismo, y son de hecho, tareas imposibles
      de realizar por red. Un error común hecho por recién llegados a
      Subversion es tratar de pasar URLs ( incluso las  <literal>file:</literal>
      <quote>locales</quote> ) a ambos programas.</para>

    <para>Así, después de que hayas ejecutado el comando <command>svnadmin create</command>,
      tienes un nuevo y brillante repositorio Subversion en su propio
      directorio. Echemos una ojeada a qué es lo que realmente se crea
      dentro de ese subdirectorio.</para>
            
    <screen>
$ ls repos
conf/  dav/  db/  format  hooks/  locks/  README.txt
</screen>
      
    <para>Con la excepción de los ficheros <filename>README.txt</filename> y
      <filename>format</filename>, el directorio del repositorio es un grupo
      de subdirectorios. Al igual que en otras áreas del diseño de Subversion,
      se le tiene mucho respeto a la modularidad, y se prefiere una
      organización jerárquica antes que un caos que estorbe. He aquí una breve
      descripción de todos los objetos que puedes ver en tu nuevo directorio
      de repositorio:</para>

    <variablelist>
     <varlistentry>
        <term>conf</term>
        <listitem>
          <para>Un directorio que contiene los ficheros de configuración del repositorio.</para>
        </listitem>
      </varlistentry>
     <varlistentry>
        <term>dav</term>
        <listitem>
          <para>Un directorio para Apache y mod_dav_svn y su
            economía privada de datos.<!--TODO:comprobar "housekeeping"--></para>    
        </listitem>
      </varlistentry>
     <varlistentry>
        <term>db</term>
        <listitem>
          <para>El entorno principal de la BD Berkeley, lleno de tablas
            que <!--TODO:comprise--> el almacenamiento de datos para
            el sistema de ficheros de Subversion ( donde todos tus
            datos versionados residen.</para>
        </listitem>
      </varlistentry>
     <varlistentry>
        <term>format</term>
        <listitem>
          <para>Un fichero cuyo contenido es un simple valor entero que
            nos dice el número de versión del repositorio <!--TODO:layout--></para>    
        </listitem>
      </varlistentry>
     <varlistentry>
        <term>hooks</term>
        <listitem>
          <para>Un directorio lleno de <!--hook script templates-->
            ( y los mismos <!--TODO: hook scripts-->, una vez que hayas instalados
            algunos.</para>
        </listitem>
      </varlistentry>
     <varlistentry>
        <term>locks</term>
        <listitem>
          <para>Un directorio para el bloqueo de datos de repositorio
            de Subversion, usado para <!--TODO: tracking --> los
            accesos al repositorio.</para>
        </listitem>
      </varlistentry>
     <varlistentry>
        <term>README.txt</term>
        <listitem>
          <para>Un fichero que simplemente informa a sus lectores que
            están mirando un repositorio Subversion.</para>
        </listitem>
      </varlistentry>
    </variablelist>
      
    <para>En general, no deberías <!--TODO: tamper --> con tu repositorio
      <quote>a mano</quote>. La herramienta <command>svnadmin</command>
      debería ser suficiente para cualquier cambio necesarios en tu
      repositorio, o puedes echar una ojeada a herramientas de terceros
      ( como la suite<!--TODO: suite-->de herramientas de la BD Berkeley )
      para <!--TODO: tweaking--> subsectiones relevantes del repositorio.
      Sin embargo, hay algunas excepciones, y las veremos aquí.</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-2.1">
      <title>Hook Scripts</title>

       <!--TODO: párrafo complicado, revisar -->
       <para>Un <firstterm><!--TODO: hook-->hook</firstterm> es un programa
        <!--TODO: triggered --> por algún evento del repositorio, como la
        creación de una nueva revisión o la modificación de una propiedad
        no versionada. A cada hook se le da suficiente información para
        que sepa de qué evento se trata, cuál es su objetivo, y el nombre
        de usuario de la persona que disparó el evento. Dependiendo de
        la salida del hook o de estado de su salida, el programa hook
        puede continuar la acción, pararla, o suspenderla de alguna manera.</para>
            
      <para>El subdirectorio  <filename>hooks</filename> se rellena,
        por defecto, con plantillas para varios hooks de repositorio.</para>
            
      <screen>
$ ls repos/hooks/
post-commit.tmpl          pre-revprop-change.tmpl
post-revprop-change.tmpl  start-commit.tmpl
pre-commit.tmpl           
</screen>
            
      <para>Hay una plantilla por cada hook que implementa el repositorio
        Subversion, y examinando los contenidos de dichas plantillas
        de scripts, puede ver qué <!--TODO triggers><-->triggers ejecuta
        cada script y qué datos se le pasan. También se encuentran
        en muchas de estas plantillas ejemplos de cómo debería usar
        dicho script, conjuntamente con otros programas provistos
        por Subversion, para realizar tareas comunes y útiles. Para instalar
        realmente un hook funcional, sólo necesita colocar algún ejecutable
        o script en el directorio <filename>repos/hooks</filename> que pueda
        ser ejecutado con el nombre del hook ( como <command>start-commit</command>
        o <command>post-commit</command>).</para>

      <para>En plataformas Unix, esto significa proveer un script o
        programa (podría ser un shell script, un programa Python,
        un binario C compilado, o cualquier otra cosa) llamado
        exactamente igual que el nombre del hook. Por supuesto,
        los ficheros de plantillas están presentes para algo más
        que sólo propósitos informativos&mdash;la manera más fácil de
        instalar un hook en plataformas Unix es simplemente copiar
        el fichero de plantilla apropiado en un nuevo fichero sin la
        extensión <literal>.tmpl</literal>, personalizando los contenidos
        del hook, y asegurándose de que el script sea ejecutable.
        Windows, sin embargo, usa extensiones de fichero para determinar
        si un programa es ejecutable o no, así que debería dar poner
        un programa cuyo nombre sea el nombre del hook, y cuya extensión
        sea una de las extensiones especiales reconocidas por Windows
        como ficheros ejecutables, como  <filename>.exe</filename> o
        <filename>.com</filename> para programas, y <filename>.bat</filename>
        para ficheros de scripts.</para>

      <para>Actualmente hay cinco hooks implementados por el 
        repositorio Subversion:</para>

      <variablelist>
        <varlistentry>
          <term><filename>start-commit</filename></term>
          <listitem>
            <para>Se ejecuta antes de la transacción commit haya sido
              creada. Se usa normalmente para decidir si el usuario
              tiene los privilegios suficientes. El repositorio pasa
              dos argumentos a este programa: la ruta al repositorio,
              y el nombre de usuario que intenta realizar el commit.
              Si el programa devuelve algún valor distinto de cero, se
              paraliza el commit antes de haber creado la transacción.</para>
          </listitem>
        </varlistentry>
            
        <varlistentry>
          <term><filename>pre-commit</filename></term>
          <listitem>
            <para>Se ejecuta cuando se completa la transacción, pero
              antes de ser enviados los datos al respositorio. Este hook
              se usa normalmente como protección contra commits que no se
              permiten debido a contenido o localización ( por ejemplo, tu
              sitio puede requerir que todos los commits a una rama
              determinada incluyan un número de ticket del seguimiento de
              fallos, o que el mensaje de log entrante no esté vacío).
              El repositorio pasa dos argumentos a este programa: la ruta
              al repositorio, y el nombre de la transacción que va a sufrir
              el commmit. Si el programa devuelve una salida que no sea cero,
              el commit se aborta y la transacción se borra.</para>

            <para>La distribución Subversion incluye algunos scripts de
              control de acceso ( localizados en el directorio
              <filename>tools/hook-scripts</filename> del árbol de fuentes
              de Subversion ) a los que se puede llamar desde
              <command>pre-commit</command> para implementar un control de
              de acceso más en detalle. En estos momentos, esta es la
              única manera por la cual los administradores pueden controlar
              el acceso más allá de lo que el fichero <filename>httpd.conf</filename>
              de Apache ofrece. En una versión futura de Subversion, planeamos
              implementar listas de control de acceso (ACLs) directamente en el
              sistema de ficheros.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><filename>post-commit</filename></term>
          <listitem>
            <para>Esto se ejecuta después de que la transacción se haya
              confirmado, y una nueva revisión haya sido creada. La mayoría
              de la gente usa este hook para enviar correos descriptivos
              acerca de la confirmación o para hacer una copia de seguridad
              del repositorio. El repositorio pasa dos argumentos a este
              programa: la ruta al repositorio, y el número de la nueva
              revisión creada. El código de salida del programa es ignorado.</para>
                
            <para>La distribución de Subversion incluye un script
              <command>commit-email.pl</command> ( localizado en
              el directorio  <filename>tools/hook-scripts/</filename>
              del árbol de fuentes de Subversion ) que puede ser
              usado para enviar correos electrónicos con ( añadiendo
              o no un fichero de log ) una descripción de la confirmación
              hecha. Este correo contiene una lista de las rutas que
              fueron cambiadas, el mensaje de log adjunto a la confirmación,
              el autor y fecha de la confirmación, así como un informe
              en formato de GNU diff de los cambios hechos en los
              ficheros versionados como parte de la confirmación.</para>

            <para>Otra herramienta útil de Subversion es el script
              <command>hot-backup.py</command> ( localizado en el 
              directorio <filename>tools/backup/</filename> del árbol
              de fuentes de Subversion ). Este script realiza copias
              de seguridad en caliente de su repositorio Subversion
              ( una capacidad soportada por el motor de bases de datos
              Berkeley), y puede ser udada para hacer una foto por cada
              confirmación de su repositorio para archivar, o con el objetivo
              de recuperación de emergencia.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><filename>pre-revprop-change</filename></term>
          <listitem>
            <para>Al no ser versionadas las propiedades de revisión de Subversion,
              hacer modificaciones a una de ellas ( como por ejemplo,
        el mensaje de commit <literal>svn:log</literal> )
        sobreescribirá el valor previo de esa propiedad para siempre.
        Como hay datos aquí que potencialmente se pueden perder,
        Subversion provee este hook ( y su contrapartida,        
              <filename>post-revprop-change</filename>) de tal manera
        que los administradores de repositorios puedan mantener
        con métodos externos si así lo desean, registros de los
        cambios de dichas propiedades. Como precaución contra
        la pérdidad de datos de propiedades no versionadas,
        no se permite a los clientes Subversion modificarlos
        del todo remotamente a no ser que este hook se implemente
        para su repositorio.</para>

      <para>Este hook se ejecuta justo antes de que una modificación
        de este tipo se haga en el repositorio. El repositorio pasa
        cuatro argumentos al hook: la ruta al repositorio, la revisión
        en la cual la propiedad que se va a modificar existe,
        el nombre autenticado de usuario de la persona que va a hacer
        el cambio, y el nombre mismo de la propiedad.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><filename>post-revprop-change</filename></term>
          <listitem>
      <para>Como se ha mencionado antes, este hook es la contrapartida
        del hook <filename>pre-revprop-change</filename>. De hecho,
        por paranoia, este script no se ejecutará a no ser que el 
        hook <filename>pre-revprop-change</filename> exista.
        Cuando ambos están presentes, el hook <filename>post-revprop-change</filename>
        se ejecuta justo después de que una propiedad de revisión
        haya sido modificad, y se usa típicamente para enviar un 
        correo electrónico con el nuevo valor de la propiedad
        cambiada. El repositorio pasa cuatro argumentos al hook:
        la ruta al repositorio, la revisión en la cual la propiedad
        existe, el nombre autenticado de usuario de la persona
        que va a hacer el cambio y el nombre mismo de la propiedad.</para>

      <para>La distribución de Subversion incluye el script
        <command>propchange-email.pl</command> script
        (localizado en el directorio <filename>tools/hook-scripts/</filename>
        del árbol de fuentes de Subversion ) que puede ser usado
        para enviar un correo electrónico con ( y/o añadido a un 
        fichero de log ) los detalles de un cambio en una propiedad
        de revisión. Este correo electrónico contiene la revisión
        y nombre de la propiedad modificada, el usuario que hizo el cambio,
        y el nuevo valor.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Subversión tratará de ejecutar los hooks como el mismo 
        usuario que posee el proces que está accediendo al repositorio
  Subversion. En la mayoría de los casos, el repositorio se 
  accede a través del servidor HTTP Apache y mod_dav_svn, así que
  este usuario es el mismo que el usuario con el que se ejecuta
  Apache. Los mismos hooks necesitarán ser configurados con permisos
  a nivel de sistema operativo que les permitan ser ejecutados
  por dicho usuario. Asimismo, esto significa  que cualquier fichero
  o programas ( incluyendo el repositorio mismo ) al que acceda
  directa o indirectamente el hook, será a través del mismo usuario.
  En otras palabras, esté alerta a problemas potenciales relacionados
  con permisos que impidan al hook realizar las tareas para las cuales
  lo haya escrito.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-2.2">
      <title>Configuración de la Base de Datos Berkeley</title>

      <para>Un entorno de base de datos Berkekely es una encapsulación
        de una o más bases de datos, ficheros de registro, ficheros
        regionales y ficheros de configuración. El entorno de base de datos
        Berkely tiene su propio conjunto de valores de configuración
        por defecto para cosas como el número de bloqueos que se permite eliminar
        de una sóla vez, o el tamaño máximo de los ficheros de registro
	<!--TODO: journaling-->, etc. El código del sistema de ficheros
        de Subversion elige además valores por defecto para algunas
        de las opciones de configuración de la base de datos Berkeley.
	De todas maneras, algunas veces su repositorio particular,
        con su colección única de datos y patrones de acceso, podría
        necesitar un grupo diferente de valores de configuración.</para>

      <para>La gente de Sleepycat ( los progamadores de la base de datos
        Berkeley ) entienden que bases de datos diferentes, tienen
        requerimientos específicos, de tal manera, que nos proveen
        de un mecanismo para sobreescribir en tiempo de ejecución, 
        muchos de los valores de configuración del entorno Berkeley.
        Berkeley comprueba la presencia de un fichero denominado
        <filename>DB_CONFIG</filename> en cada directorio del entorno,
        y <!--TODO: parsers--> las opciones que encuentra en dicho
        fichero para usarlas en ese entorno Berkeley particular.</para>

     <para>El fichero de configuración de Berkeley para su repositorio
        se encuentra en directorio del entorno <filename>db</filename>,
        en <filename>repos/db/DB_CONFIG</filename>. Subversion crea
        por sí mismo el fichero al mismo tiempo que el resto del repositorio.
        El fichero inicialmente contiene algunas opciones por defecto,
        así como enlaces a la documentacion en línea de la BD Berkeley
        de tal manera que pueda saber qué significan dichas opciones.
        Por supuesto, es libre de añadir cualquiera de las opciones soportadas
        por la BD Berkeley a su fichero <filename>DB_CONFIG</filename>.
        Tan sólo tenga cuidado porque mientras Subversion no trata de
        leer o interpretar los contenidos del fichero, y no hace uso
        de sus opciones de configuración, tendrá que evitar cualquier
        cambio en la configuración que pueda causar que la BD Berkeley
        se comporte de una manera inesperada para el resto del código
        de Subversion. Por otra parte, los cambios hechos en
        <filename>DB_CONFIG</filename> no tendrán efecto hasta que
        vuelva a leer en entorno de la base de datos ( usando
        <command>svnadmin recover</command>).</para>
    </sect2>
  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 3:  REPOSITORY MAINTENANCE                          *** -->
  <!-- ******************************************************************* -->

  <sect1 id="svn-ch-5-sect-3">
    <title>Mantenimiento del Repositorio</title>

    <para>El mantenimiento de un repositorio Subversion puede ser una
      tarea que asuste, principalmente debido a las complejidades inherentes
      a sistemas que tienen un motor de base de datos. Para hacer bien
      este trabajo, basta con conocer las herramientas&mdash;qué son y
      cuándo y cómo usarlas. Esta sección le presentará las herramientas
      de administración que provee Subversion, y cómo utilizarlas
      para realizar tareas como migraciones de repositorios, actualizaciones,
      copias de seguridad y limpiezas.</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-3.1">
      <title>Una caja de herramientas del Administrador</title>

      <para>Subversion provee un conjunto de utilidades para crear
        inspecciononar, modificar y reparar sus repositorio.
        Estudiemos más de cerca cada una de estas herramientas.
        Más tarde, examinaremos brevemente otras incluídas en la
        distribución de la BD Berkeley que añaden funcionalidades
        específicas al motor de base de datos de las que no disponen
        las herramientas propias de Subversion.</para>

      <sect3 id="svn-ch-5-sect-3.1.1">
        <title>svnlook</title>
            
        <para><command>svnlook</command> es una herramienta 
          provista por Subversion para examinar las revisiones
          y transacciones realizadas en un repositorio. Este programa
          no intente en ningún momento cambiar el repositorio
          &mdash;es una utilidad de <quote>sólo lectura</quote>.
          <command>svnlook</command> es utilizada normalmente por
          los <!--TODO-->hooks del repositorio para informar acerca
          de los cambios que se van a realizar ( en el caso del
          hook <command>pre-commit</command> ) o que se acaban de
          hacer ( en el caso del hook <command>post-commit</command> )
          en el repositorio. Un administrador del repositorio puede
          usar esta herramienta para diagnosis.</para>
           
        <para><command>svnlook</command> tiene una sintáxis muy simple:</para>
            
        <screen>
$ svnlook help
uso general. svnlook SUBCOMANDO RUTA_REPOS [PARAMS y OPCIONES ...]
Nota: todo subcomando que tome los parámetros '--revision' y '--transaction'
      actuará, si se lo invoca sin una de estas opciones, sobre la versión
      más reciente del repositorio.
Escriba "svn help &lt;subcomando&gt;" para ayuda en un subcomando específico.
&hellip;
</screen>

        <para>Casi cada uno de los subcomandos de <command>svnlook</command>
          puede trabajar sobre una revisión o una transacción,
          imprimiendo información acerca del propio árbol, o de
          sus diferencias con respecto a la revisión anterior del
          repositorio. Usará la opciones <option>--revision</option>
          y <option>--transaction</option> para especificar qué
          revisión o transacción examinar respectivamente. Nótese
          que mientras los números de revisión se ven como números
          naturales, los nombres de transacción son cadenas alfanuméricas.
          Recuerde que el sistema de ficheros sólo permite navegar entre
          transacciones no confirmadas ( transacción que no han tenido
          como resultado una nueva revisión ). La mayoría de los repositorios
          no tendrán ese tipo de transacciones, porque las transacciones
          normalmente son confirmadas ( lo que evita que puedan ser
          examinadas ) o paradas y borradas.</para>

        <para>En ausencia de las opciones <option>--revision</option>
          y <option>--transaction</option>, <command>svnlook</command>
          examinará la última revisión ( o <quote>HEAD</quote> ) del 
          repositorio. Así que las siguientes órdenes hacen exactamente
          lo mismo cuando 19 es la última revisión del repositorio
          localizado en <filename>/path/to/repos</filename>:</para>
	  

        <screen>
$ svnlook info /path/to/repos
$ svnlook info /path/to/repos --revision 19
</screen>

        <para>La única excepción a estas reglas es el subcomando
          <command>svnlook youngest</command>, que no recibe opciones,
          y que simplemente escribe el número de revisión de <literal>HEAD</literal>.</para>

        <screen>
$ svnlook youngest /path/to/repos
19
</screen>
            
        <para>La salida de <command>svnlook</command> está diseñanda para que
          sea, a la vez, legible por humanos y por máquinas. Cojamos como ejemplo
          la salida del subcomando <literal>info</literal>:</para>

        <screen>
$ svnlook info /path/to/repos
sally
2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)
27
Added the usual
Greek tree.
</screen>

        <para>La salida del subcomando <literal>info</literal> está definida como:</para>

	<orderedlist>
          <listitem>
            <para>El autor, seguido por un salto de línea.</para>
          </listitem>
          <listitem>
            <para>La fecha, seguida por un salto de línea.</para>
          </listitem>
          <listitem>
            <para>El número de caracteres en el mensaje de registro,
	      seguido por un salto de línea.</para>
          </listitem>
          <listitem>
            <para>El mensaje de registro, seguido por un salto de línea.</para>
          </listitem>
        </orderedlist>

        <para>Esta salida es legible para humanos, elementos como la
          fecha, se presentan usando una representación de texto
          en lugar de algo más oscuro ( como el número de nanosegundos
          desde que <!--TODO Tasty Freeze guy drove by-->). Pero
          esta salida es también legible por la máquina&mdash;debido a que 
          el registro del mensaje puede contener muchas líneas y no tener
          un límite de tamaño, <command>svnlook</command> informa del 
          tamaño del mensaje antes que el mismo mensaje. Esto permite a los
          <!--TODO scripts--> y otros <!--TODO wrappers--> alrededor de este
          comando, tomar decisiones inteligentes acerca del mensaje de registro,
          como cuánta memoria reserverle, o al menos, cuántos bytes saltarse
          en el evento para que esta salida no sea el último bit de datos en 
          el flujo.</para>

        <para>Otro uso común de <command>svnlook</command> es ver
          realmente los contenidos de un árbol de revisión o de
          transacción. El comando <command>svnlook tree</command>
          presenta los directorios y fichero del árbol solicitado.
          Si añade la opción <option>--show-ids</option>, también 
          enseñará los identificadores de nodos del sistema de ficheros
          de la revisión para cada una de las rutas (que, en general, es más
          útil para los desarrolladores que para los usuarios).</para>
	  
        <screen>
$ svnlook tree /path/to/repos --show-ids
/ &lt;0.0.1&gt;
 A/ &lt;2.0.1&gt;
  B/ &lt;4.0.1&gt;
   lambda &lt;5.0.1&gt;
   E/ &lt;6.0.1&gt;
    alpha &lt;7.0.1&gt;
    beta &lt;8.0.1&gt;
   F/ &lt;9.0.1&gt;
  mu &lt;3.0.1&gt;
  C/ &lt;a.0.1&gt;
  D/ &lt;b.0.1&gt;
   gamma &lt;c.0.1&gt;
   G/ &lt;d.0.1&gt;
    pi &lt;e.0.1&gt;
    rho &lt;f.0.1&gt;
    tau &lt;g.0.1&gt;
   H/ &lt;h.0.1&gt;
    chi &lt;i.0.1&gt;
    omega &lt;k.0.1&gt;
    psi &lt;j.0.1&gt;
 iota &lt;1.0.1&gt;
</screen>

        <para>Una vez que haya visto el esquema de los ficheros y directorios
          de su árbol, podrá usar comandos como <command>svnlook cat</command>,
          <command>svnlook propget</command>, y <command>svnlook proplist</command>
          para profundizar en los detalles dichos elementos.</para>

        <para><command>svnlook</command> puede realizar otros tipos de
          consultas, presentando los subgrupos de información que mencionamos
          antes, informando acerca de qué rutas fueron modificadas en una
          revisión o transacción especificada, mostrando las modificaciones
          de textos o propiedades realizadas, etc ... A continuación
          hay una breve descripción de la actual lista de subcomandos
          aceptados por <command>svnlook</command>, y la salida de los mismos:</para>

        <variablelist>
          <varlistentry>
            <term><literal>author</literal></term>
            <listitem>
              <para>Dice el autor del árbol.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>cat</literal></term>
            <listitem>
              <para>Vuelca los contenidos de un fichero en el árbol.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>changed</literal></term>
            <listitem>
              <para>Da una lista de todos los ficheros y directorios que han sido
                modificados en el árbol.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>date</literal></term>
            <listitem>
              <para>Dice la fecha del árbol.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>diff</literal></term>
            <listitem>
              <para>Vuelca <!--TODO unified diffs --> de ficheros modificados.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>dirs-changed</literal></term>
            <listitem>
              <para>Lista los directorios del árbol que han sido
                modificados, o aquellos en los que alguno de sus ficheros
                han sido modificados.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>history</literal></term>
            <listitem>
              <para>Presenta puntos interesantes en la historia de
                una ruta versionada ( lugares donde ha habido modificaciones
                o copias ).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>info</literal></term>
            <listitem>
              <para>Vuelca el autor, la fecha, el número de caracteres
                del mensaje de registro, y el mensaje de registro.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>log</literal></term>
            <listitem>
              <para>Dice el mensaje de registro del árbol.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>propget</literal></term>
            <listitem>
              <para>Dice el valor de una propiedad de una ruta en el árbol.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>proplist</literal></term>
            <listitem>
              <para>Vuelca los nombres y valores de las propiedades de rutas
                en el árbol.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>tree</literal></term>
            <listitem>
              <para>Vuelca el listado del árbol, revelando opcionalmente
                el identificador de la revisión de nodo de sistema de ficheros
                asociado a cada ruta.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>uuid</literal></term>
            <listitem>
              <para>Dice el identificador único de usuario del árbol.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>youngest</literal></term>
            <listitem>
              <para>Dice el último número de revisión.</para>
            </listitem>
          </varlistentry>
        </variablelist>

      </sect3>

      <sect3 id="svn-ch-5-sect-3.1.2">
        <title>svnadmin</title>

        <para>El programa <command>svnadmin</command> es el mejor amigo
          del administror del repositorio. Además de darle la posibilidad
          de crear repositorios Subversion, le permite realizar
          varias operaciones de mantenimiento en ellos. La sintaxis
          de  <command>svnadmin</command> es parecida a la de
          <command>svnlook</command>:</para>

        <screen>
$ svnadmin help
uso general: svnadmin SUBCOMANDO RUTA_REPOS  [PARAMS y OPCIONES ...]
Escriba "svnadmin help &lt;subcomando&gt;" para ayuda sobre un subcomando.

Subcomandos disponibles:
   create
   deltify
   dump
   help (?, h)
&hellip;
</screen>

        <para>Ya hemos mencionado antes el subcomando <literal>create</literal>
          de <command>svnadmin</command> ( ver <xref linkend="svn-ch-5-sect-2"/>).
          La mayoría de los demás subcomandos los veremos más adelante en 
          en este capítulo. De momento, veamos por encima lo que cada uno de
          ellos nos ofrece.</para>

        <variablelist>
          <varlistentry>
            <term><literal>create</literal></term>
            <listitem>
              <para>Crear un nuevo repositorio Subversion.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>deltify</literal></term>
            <listitem>
              <para>Run over a specified revision range, performing
                predecessor deltification on the paths changed in
                those revisions.  If no revisions are specified, this
                command will simply deltify the
                <literal>HEAD</literal> revision.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>dump</literal></term>
            <listitem>
              <para>Vuelca los contenidos del repositorio, agrupados por
                por un conjunto dado de revisiones, usando un formato portable
                de volcado.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>hotcopy</literal></term>
            <listitem>
              <para>Hace una copia en caliente de un repositorio. Puede
                ejecutar esta comando en cualquier momento, y hacer una copia
                segura del repositorio sin que se vea afectada por el hecho
                de que otros procesos estén accediendo al repositorio.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>list-dblogs</literal></term>
            <listitem>
              <para>Lista las rutas a los ficheros de registro
                de la BD Berkeley asociados al repositorio. Esta lista
                incluye todos los ficheros de registros&mdash;aquellos que
                están todavía en uso por Subversion, así como los que no
                lo están.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>list-unused-dblogs</literal></term>
            <listitem>
              <para>Lista las rutas de los ficheros de registro
                de la BD Berkeley asociados al repositrio, pero que han
                dejado de usarse. Puede borrar de forma segura estos ficheros
                del entorno del repositorio y archivarlos para el caso de tener
                que hacer una recuperación de algún evento catastrófico del repositorio.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>load</literal></term>
            <listitem>
              <para>Carga un grupo de revisiones en un repositorio
                desde un fluno de datos que utilice el mismo formato
                portable de información que el generado por el subcomando
                <literal>dump</literal>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>lstxns</literal></term>
            <listitem>
              <para>Lista los nombres de las transacciones Subversion
                no confirmadas que existen actualmente en el repositorio.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>recover</literal></term>
            <listitem>
              <para>Realiza tareas de recuperación en un repositorio
                que lo necesite, generalmente tras un error fatal
                que haya impedido a un proceso cerrar limpiamente
                su comunicación con el repositorio.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>rmtxns</literal></term>
            <listitem>
              <para>Borra limpiamente del repositorio transacciones
                Subversion ( convenientemente nutrido por la salida
                del subcomando <literal>lstxns</literal>).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>setlog</literal></term>
            <listitem>
              <para>Sustituye el valor actual de la propiedad
                <literal>svn:log</literal> ( mensaje de confirmación )
                de una transacción en particular en el repositorio
                con un nuevo valor.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>verify</literal></term>
            <listitem>
              <para>Verificar los contenidos del repositorio. Esto incluye,
                entre otras cosas, comparaciones de firmas de los datos
                versionados almacenados en el repositorio.</para>
            </listitem>
          </varlistentry>
        </variablelist>

      </sect3>

      <sect3 id="svn-ch-5-sect-3.1.3">
        <title>svndumpfilter</title>

        <para>Since Subversion stores everything in an opaque database
          system, attempting manual tweaks is unwise, if not quite
          difficult.  And once data has been stored in your
          repository, Subversion generally doesn't provide an
          easy way to remove that data.
          <footnote>
            <para>That, by the way, is a <emphasis>feature</emphasis>,
              not a bug.</para>
          </footnote>
          But inevitably, there will be times when you would like to
          manipulate the history of your repository.  You might need
          to strip out all instances of a file that was accidentally
          added to the repository (and shouldn't be there for whatever
          reason).  Or, perhaps you have multiple projects sharing a
          single repository, and you decide to split them up into
          their own repositories.  To accomplish tasks like this,
          administrators need a more manageable and malleable
          representation of the data in their repositories&mdash;the
          Subversion repository dump format.</para>

        <para>The Subversion repository dump format is a
          human-readable representation of the changes that you've
          made to your versioned data over time.  You use the
          <command>svnadmin dump</command> command to generate the
          dump data, and <command>svnadmin load</command> to populate
          a new repository with it (see <xref
          linkend="svn-ch-5-sect-3.5"/>).  The great thing about the
          human-readability aspect of the dump format is that, if you
          aren't careless about it, you can manually inspect and
          modify it.  Of course, the downside is that if you have two
          years' worth of repository activity encapsulated in what is
          likely to be a very large dumpfile, it could take you a
          long, long time to manually inspect and modify it.</para>

        <para>While it won't be the most commonly used tool at the
          administrator's disposal, <command>svndumpfilter</command>
          provides a very particular brand of useful
          functionality&mdash;the ability to quickly and easily modify
          that dumpfile data by acting as a path-based filter.  Simply
          give it either a list of paths you wish to keep, or a list
          of paths you wish to not keep, then pipe your repository
          dump data through this filter.  The result will be a
          modified stream of dump data that contains only the
          versioned paths you (explicitly or implicitly) requested.</para>

        <para>The syntax of <command>svndumpfilter</command> is as
          follows:</para>

        <screen>
$ svndumpfilter help
general usage: svndumpfilter SUBCOMMAND [ARGS &amp; OPTIONS ...]
Type "svndumpfilter help &lt;subcommand&gt;" for help on a specific subcommand.

Available subcommands:
   exclude
   include
   help (?, h)
</screen>

        <para>There are only two interesting subcommands.  They allow
          you to make the choice between explicit or implicit
          inclusion of paths in the stream:</para>

        <variablelist>
          <varlistentry>
            <term><literal>exclude</literal></term>
            <listitem>
              <para>Filter out a set of paths from the dump data
                stream.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>include</literal></term>
            <listitem>
              <para>Allow only the requested set of paths to pass
                through the dump data stream.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Let's look a realistic example of how you might use this
          program.  We discuss elsewhere (see <xref
          linkend="svn-ch-5-sect-6.1"/>) the process of deciding how to
          choose a layout for the data in your
          repositories&mdash;using one repository per project or
          combining them, arranging stuff within your repository, and
          so on.  But sometimes after new revisions start flying in,
          you rethink your layout and would like to make some changes.
          A common change is the decision to move multiple projects
          which are sharing a single repository into separate
          repositories for each project.</para>

        <para>Our imaginary repository contains three projects:
          <literal>calc</literal>, <literal>calendar</literal>, and
          <literal>spreadsheet</literal>.  They have been living
          side-by-side in a layout like this:</para>

        <screen>
/
   calc/
      trunk/
      branches/
      tags/
   calendar/
      trunk/
      branches/
      tags/
   spreadsheet/
      trunk/
      branches/
      tags/
</screen>

        <para>To get these three projects into their own repositories,
          we first make a dumpfile of the whole repository:</para>

        <screen>
$ svnadmin dump /path/to/repos &gt; repos-dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
* Dumped revision 3.
&hellip;
$
</screen>

        <para>Next, run that dumpfile through the filter, each time
          including only one of our top-level directories, and
          resulting in three new dumpfiles:</para>

        <screen>
$ cat repos-dumpfile | svndumpfilter include calc &gt; calc-dumpfile
&hellip;
$ cat repos-dumpfile | svndumpfilter include calendar &gt; cal-dumpfile
&hellip;
$ cat repos-dumpfile | svndumpfilter include spreadsheet &gt; ss-dumpfile
&hellip;
$
</screen>

        <para>At this point, you have to make a decision.  Each of
          your dumpfiles will create a valid repository,
          but will preserve the paths exactly as they were in the
          original repository.  This means that even though you would
          have a repository solely for your <literal>calc</literal>
          project, that repository would still have a top-level
          directory named <filename>calc</filename>.  If you want
          your <filename>trunk</filename>, <filename>tags</filename>,
          and <filename>branches</filename> directories to live in the
          root of your repository, you might wish to edit your
          dumpfiles, tweaking the <literal>Node-path</literal> and
          <literal>Copyfrom-path</literal> headers to no longer have
          that first <filename>calc/</filename> path component.  Also,
          you'll want to remove the section of dump data that creates
          the <filename>calc</filename> directory.  It will look
          something like:</para>

        <screen>
Node-path: calc
Node-action: add
Node-kind: dir
Content-length: 0

</screen>

        <para>All that remains now is to create your three new
          repositories, and load each dumpfile into the right
          repository:</para>

        <screen>
$ svnadmin create calc; svnadmin load calc &lt; calc-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : button.c ... done.
&hellip;
$ svnadmin create calendar; svnadmin load calendar &lt; cal-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : cal.c ... done.
&hellip;
$ svnadmin create spreadsheet; svnadmin load spreadsheet &lt; ss-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : ss.c ... done.
&hellip;
$
</screen>

        <para>Both of <command>svndumpfilter</command>'s subcommands
          accept options for deciding how to deal with
          <quote>empty</quote> revisions.  If a given revision
          contained only changes to paths that were filtered out, that
          now-empty revision could be considered uninteresting or even
          unwanted.  So to give the user control over what to do with
          those revisions, <command>svndumpfilter</command> provides
          the following command-line options:</para>

        <variablelist>
          <varlistentry>
            <term><option>--drop-empty-revs</option></term>
            <listitem>
              <para>Do not generate empty revisions at all&mdash;just
                omit them.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--renumber-revs</option></term>
            <listitem>
              <para>If empty revisions are dropped (using the
                <option>--drop-empty-revs</option> option), change the
                revision numbers of the remaining revisions so that
                there are no gaps in the numeric sequence.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--preserve-revprops</option></term>
            <listitem>
              <para>If empty revisions are not dropped, preserve the
                revision properties (log message, author, date, custom
                properties, etc.) for those empty revisions.
                Otherwise, empty revisions will only contain the
                original datestamp, and a generated log message that
                indicates that this revision was emptied by
                <command>svndumpfilter</command>.</para>
            </listitem>
          </varlistentry>
        </variablelist>
        
        <para>While <command>svndumpfilter</command> can be very
          useful, and a huge timesaver, there are unfortunately a
          couple of gotchas.  First, this utility is overly sensitive
          to path semantics.  Pay attention to whether paths in your
          dumpfile are specified with or without leading slashes.
          You'll want to look at the <literal>Node-path</literal> and
          <literal>Copyfrom-path</literal> headers.</para>

        <screen>
&hellip;
Node-path: spreadsheet/Makefile
&hellip;
</screen>

        <para>If the paths have leading slashes, you should
          include leading slashes in the paths you pass to
          <command>svndumpfilter include</command> and
          <command>svndumpfilter exclude</command> (and if they don't,
          you shouldn't).  Further, if your dumpfile has an inconsistent
          usage of leading slashes for some reason,
          <footnote>
            <para>While <command>svnadmin dump</command> has a
              consistent leading slash policy&mdash;to not include
              them&mdash;other programs which generate dump data might
              not be so consistent.</para>
          </footnote>
          you should probably normalize those paths so they all
          have, or lack, leading slashes.</para>

        <para>Also, copied paths can give you some trouble.
          Subversion supports copy operations in the repository, where
          a new path is created by copying some already existing path.
          It is possible that at some point in the lifetime of your
          repository, you might have copied a file or directory from
          some location that <command>svndumpfilter</command> is
          excluding, to a location that it is including.  In order to
          make the dump data self-sufficient,
          <command>svndumpfilter</command> needs to still show the
          addition of the new path&mdash;including the contents of any
          files created by the copy&mdash;and not represent that
          addition as a copy from a source that won't exist in your
          filtered dump data stream.  But because the Subversion
          repository dump format only shows what was changed in each
          revision, the contents of the copy source might not be
          readily available.  If you suspect that you have any copies
          of this sort in your repository, you might want to rethink
          your set of included/excluded paths.</para>

      </sect3>

      <sect3 id="svn-ch-5-sect-3.1.4">
        <title>svnshell.py</title>

        <para>The Subversion source tree also comes with a shell-like
          interface to the repository.  The
          <command>svnshell.py</command> Python script (located in
          <filename>tools/examples/</filename> in the source tree)
          uses Subversion's language bindings (so you must have
          those properly compiled and installed in order for this
          script to work) to connect to the repository and filesystem
          libraries.</para>

        <para>Once started, the program behaves similarly to a shell
          program, allowing you to browse the various directories in
          your repository.  Initially, you are
          <quote>positioned</quote> in the root directory of the
          <literal>HEAD</literal> revision of the repository, and
          presented with a command prompt.  You can use the
          <literal>help</literal> command at any time to display a
          list of available commands and what they do.</para>

        <screen>
$ svnshell.py /path/to/repos
&lt;rev: 2 /&gt;$  help
Available commands:
  cat FILE     : dump the contents of FILE
  cd DIR       : change the current working directory to DIR
  exit         : exit the shell
  ls [PATH]    : list the contents of the current directory
  lstxns       : list the transactions available for browsing
  setrev REV   : set the current revision to browse
  settxn TXN   : set the current transaction to browse
  youngest     : list the youngest browsable revision number
&lt;rev: 2 /&gt;$
</screen>

        <para>Navigating the directory structure of your repository is
          done in the same way you would navigate a regular Unix or
          Windows shell&mdash;using the <literal>cd</literal> command.
          At all times, the command prompt will show you what revision
          (prefixed by <literal>rev:</literal>) or transaction
          (prefixed by <literal>txn:</literal>) you are currently
          examining, and at what path location in that revision or
          transaction.  You can change your current revision or
          transaction with the <literal>setrev</literal> and
          <literal>settxn</literal> commands, respectively.  As in a
          Unix shell, you can use the <literal>ls</literal> command to
          display the contents of the current directory, and you can
          use the <literal>cat</literal> command to display the
          contents of a file.</para>

        <example id="svn-ch-8-sect-3.1.3-ex-1">
          <title>Using svnshell to Navigate the Repository</title>

          <screen>
&lt;rev: 2 /&gt;$ ls
   REV   AUTHOR  NODE-REV-ID     SIZE         DATE NAME
----------------------------------------------------------------------------
     1    sally &lt;     2.0.1&gt;          Nov 15 11:50 A/
     2    harry &lt;     1.0.2&gt;       56 Nov 19 08:19 iota
&lt;rev: 2 /&gt;$ cd A
&lt;rev: 2 /A&gt;$ ls
   REV   AUTHOR  NODE-REV-ID     SIZE         DATE NAME
----------------------------------------------------------------------------
     1    sally &lt;     4.0.1&gt;          Nov 15 11:50 B/
     1    sally &lt;     a.0.1&gt;          Nov 15 11:50 C/
     1    sally &lt;     b.0.1&gt;          Nov 15 11:50 D/
     1    sally &lt;     3.0.1&gt;       23 Nov 15 11:50 mu
&lt;rev: 2 /A&gt;$ cd D/G 
&lt;rev: 2 /A/D/G&gt;$ ls
   REV   AUTHOR  NODE-REV-ID     SIZE         DATE NAME
----------------------------------------------------------------------------
     1    sally &lt;     e.0.1&gt;       23 Nov 15 11:50 pi
     1    sally &lt;     f.0.1&gt;       24 Nov 15 11:50 rho
     1    sally &lt;     g.0.1&gt;       24 Nov 15 11:50 tau
&lt;rev: 2 /A&gt;$ cd ../..
&lt;rev: 2 /&gt;$ cat iota
This is the file 'iota'.
Added this text in revision 2.

&lt;rev: 2 /&gt;$ setrev 1; cat iota
This is the file 'iota'.

&lt;rev: 1 /&gt;$ exit
$
</screen>
        </example>

        <para>As you can see in the previous example, multiple
          commands may be specified at a single command prompt,
          separated by a semicolon.  Also, the shell understands the
          notions of relative and absolute paths, and will properly
          handle the <literal>.</literal> and
          <literal>..</literal> special path components.</para>

        <para>The <literal>youngest</literal> command displays the
          youngest revision.  This is useful for determining the range
          of valid revisions you can use as arguments to the
          <literal>setrev</literal> command&mdash;you are allowed to
          browse all the revisions (recalling that they are named with
          integers) between 0 and the youngest, inclusively.
          Determining the valid browsable transactions isn't quite as
          pretty.  Use the <command>lstxns</command> command to list
          the transactions that you are able to browse.  The list of
          browsable transactions is the same list that
          <command>svnadmin lstxns</command> returns, and the same
          list that is valid for use with <command>svnlook</command>'s
          <option>--transaction</option> option.</para>

        <para>Once you've finished using the shell, you can exit
          cleanly by using the <command>exit</command> command.
          Alternatively, you can supply an end-of-file
          character&mdash;Control-D (though some Win32 Python
          distributions use the Windows Control-Z convention
          instead).</para>

      </sect3>

      <sect3 id="svn-ch-5-sect-3.1.5">
        <title>Berkeley DB Utilities</title>

        <para>All of your versioned filesystem's structure and data
          live in a set of Berkeley DB database tables within the
          <filename>db</filename> subdirectory of your repository.
          This subdirectory is a regular Berkeley DB environment
          directory, and can therefore be used in conjunction with any
          of the Berkeley database tools (you can see the documentation
          for these tools at SleepyCat's website, <systemitem
          class="url">http://www.sleepycat.com/</systemitem>).</para>

        <para>For day-to-day Subversion use, these tools are
          unnecessary.  Most of the functionality typically needed for
          Subversion repositories has been duplicated in the
          <command>svnadmin</command> tool.  For example,
          <command>svnadmin list-unused-dblogs</command> and
          <command>svnadmin list-dblogs</command> perform a
          subset of what is provided by the Berkeley
          <command>db_archive</command> command, and <command>svnadmin
          recover</command> reflects the common use-cases of the
          <command>db_recover</command> utility.</para>
            
        <para>There are still a few Berkeley DB utilities that you
          might find useful.  The <command>db_dump</command> and
          <command>db_load</command> programs write and read,
          respectively, a custom file format which describes the keys
          and values in a Berkeley DB database.  Since Berkeley
          databases are not portable across machine architectures,
          this format is a useful way to transfer those databases from
          machine to machine, irrespective of architecture or
          operating system.  Also, the <command>db_stat</command>
          utility can provide useful information about the status of
          your Berkeley DB environment, including detailed statistics
          about the locking and storage subsystems.</para>

      </sect3>
    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-3.2">
      <title>Repository Cleanup</title>
            
      <para>Your Subversion repository will generally require very
        little attention once it is configured to your liking.
        However, there are times when some manual assistance from an
        administrator might be in order.  The
        <command>svnadmin</command> utility provides some helpful
        functionality to assist you in performing such tasks as</para>

      <itemizedlist>
        <listitem>
          <para>modifying commit log messages,</para>
        </listitem>
        <listitem>
          <para>removing dead transactions,</para>
        </listitem>
        <listitem>
          <para>recovering <quote>wedged</quote> repositories, and</para>
        </listitem>
        <listitem>
          <para>migrating repository contents to a different
            repository.</para>
        </listitem>
      </itemizedlist>

      <para>Perhaps the most commonly used of
        <command>svnadmin</command>'s subcommands is
        <literal>setlog</literal>.  When a transaction is committed to
        the repository and promoted to a revision, the descriptive log
        message associated with that new revision (and provided by the
        user) is stored as an unversioned property attached to the
        revision itself.  In other words, the repository remembers
        only the latest value of the property, and discards previous
        ones.</para>

      <para>Sometimes a user will have an error in her log message (a
        misspelling or some misinformation, perhaps).  If the
        repository is configured (using the
        <literal>pre-revprop-change</literal> and
        <literal>post-revprop-change</literal> hooks; see <xref
        linkend="svn-ch-5-sect-2.1"/>) to accept changes to this log
        message after the commit is finished, then the user can
        <quote>fix</quote> her log message remotely using the
        <command>svn</command> program's <literal>propset</literal>
        command (see <xref linkend="svn-ch-9"/>).  However, because of
        the potential to lose information forever, Subversion
        repositories are not, by default, configured to allow changes
        to unversioned properties&mdash;except by an administrator.</para>

      <para>If a log message needs to be changed by an administrator,
        this can be done using <command>svnadmin setlog</command>.
        This command changes the log message (the
        <literal>svn:log</literal> property) on a given revision of a
        repository, reading the new value from a provided file.</para>
          
      <screen>
$ echo "Here is the new, correct log message" &gt; newlog.txt
$ svnadmin setlog myrepos newlog.txt -r 388
</screen>
      
      <para>The <command>svnadmin setlog</command> command alone is
        still bound by the same protections against modifying
        unversioned properties as a remote client is&mdash;the
        <literal>pre-</literal> and
        <literal>post-revprop-change</literal> hooks are still
        triggered, and therefore must be setup to accept changes of
        this nature.  But an administrator can get around these
        protections by passing the <option>--bypass-hooks</option>
        option to the <command>svnadmin setlog</command> command.</para>
 
      <warning>
        <para>Remember, though, that by bypassing the hooks, you are
          likely avoiding such things as email notifications of
          property changes, backup systems which track unversioned
          property changes, and so on.  In other words, be very
          careful about what you are changing, and how you change
          it.</para>
       </warning>

      <para>Another common use of <command>svnadmin</command> is to
        query the repository for outstanding&mdash;possibly
        dead&mdash;Subversion transactions.  In the event that a commit
        should fail, the transaction is usually cleaned up.  That is,
        the transaction itself is removed from the repository, and any
        data associated with (and only with) that transaction is
        removed as well.  Occasionally, though, a failure occurs in
        such a way that the cleanup of the transaction never happens.
        This could happen for several reasons: perhaps the client
        operation was inelegantly terminated by the user, or a network
        failure might have occurred in the middle of an operation, etc.
        Regardless of the reason, these dead transactions serve only
        to clutter the repository and consume resources.</para>

      <para>You can use <command>svnadmin</command>'s
        <literal>lstxns</literal> command to list the names of the
        currently outstanding transactions.</para>

      <screen>
$ svnadmin lstxns myrepos
19
3a1
a45
$
</screen>

      <para>Each item in the resultant output can then be used with
        <command>svnlook</command> (and its
        <option>--transaction</option> option) to determine who
        created the transaction, when it was created, what types of
        changes were made in the transaction&mdash;in other words,
        whether or not the transaction is a safe candidate for
        removal!  If so, the transaction's name can be passed to
        <command>svnadmin rmtxns</command>, which will perform the
        cleanup of the transaction.  In fact, the
        <literal>rmtxns</literal> subcommand can take its input
        directly from the output of <literal>lstxns</literal>!</para>

      <screen>
$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`
$
</screen>

      <para>If you use these two subcommands like this, you should
        consider making your repository temporarily inaccessible to
        clients.  That way, no one can begin a legitimate transaction
        before you start your cleanup.  The following is a little bit
        of shell-scripting that can quickly generate information about
        each outstanding transaction in your repository:</para>

      <example id="svn-ch-5-sect-3.2-ex-1">
        <title>txn-info.sh (Reporting Outstanding Transactions)</title>

        <programlisting>
#!/bin/sh

### Generate informational output for all outstanding transactions in
### a Subversion repository.

SVNADMIN=/usr/local/bin/svnadmin
SVNLOOK=/usr/local/bin/svnlook

REPOS="${1}"
if [ "x$REPOS" = x ] ; then
  echo "usage: $0 REPOS_PATH"
  exit
fi

for TXN in `${SVNADMIN} lstxns ${REPOS}`; do 
  echo "---[ Transaction ${TXN} ]-------------------------------------------"
  ${SVNLOOK} info "${REPOS}" --transaction "${TXN}"
done
</programlisting>
      </example>

      <para>You can run the previous script using
        <command>/path/to/txn-info.sh /path/to/repos</command>.  The
        output is basically a concatenation of several chunks of
        <command>svnlook info</command> output (see <xref
        linkend="svn-ch-5-sect-3.1.1"/>), and will look something
        like:</para>

      <screen>
$ txn-info.sh myrepos
---[ Transaction 19 ]-------------------------------------------
sally
2001-09-04 11:57:19 -0500 (Tue, 04 Sep 2001)
0
---[ Transaction 3a1 ]-------------------------------------------
harry
2001-09-10 16:50:30 -0500 (Mon, 10 Sep 2001)
39
Trying to commit over a faulty network.
---[ Transaction a45 ]-------------------------------------------
sally
2001-09-12 11:09:28 -0500 (Wed, 12 Sep 2001)
0
$
</screen>

      <para>Usually, if you see a dead transaction that has no log
        message attached to it, this is the result of a failed update
        (or update-like) operation.  These operations use Subversion
        transactions under the hood to mimic working copy state.
        Since they are never intended to be committed, Subversion
        doesn't require a log message for those transactions.
        Transactions that do have log messages attached are almost
        certainly failed commits of some sort.  Also, a transaction's
        datestamp can provide interesting information&mdash;for
        example, how likely is it that an operation begun nine months
        ago is still active?</para>

      <para>In short, transaction cleanup decisions need not be made
        unwisely.  Various sources of information&mdash;including
        Apache's error and access logs, the logs of successful
        Subversion commits, and so on&mdash;can be employed in the
        decision-making process.  Finally, an administrator can often
        simply communicate with a seemingly dead transaction's owner
        (via email, for example) to verify that the transaction is, in
        fact, in a zombie state.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-3.3">
      <title>Managing Disk Space</title>

        <para>While the cost of storage has dropped incredibly in the
          past few years, disk usage is still a valid concern for
          administrators seeking to version large amounts of data.
          Every additional byte consumed by the live repository is a
          byte that needs to be backed up offsite, perhaps multiple
          times as part of rotating backup schedules.  Since the
          primary storage mechanism of a Subversion repository is a
          complex database system, it is useful to know what pieces of
          data need to remain on the live site, which need to be
          backed up, and which can be safely removed.</para>

        <para>Until recently, the largest offender of disk space usage
          with respect to Subversion repositories was the logfiles to
          which Berkeley DB performs its pre-writes before modifying
          the actual database files.  These files capture all the
          actions taken along the route of changing the database from
          one state to another&mdash;while the database files reflect
          at any given time some state, the logfiles contain all the
          many changes along the way between states.  As such, they
          can start to accumulate quite rapidly.</para>

        <para>Fortunately, beginning with the 4.2 release of Berkeley
          DB, the database environment has the ability to remove its
          own unused logfiles without any external procedures.  Any
          repositories created using an <command>svnadmin</command>
          which is compiled against Berkeley DB version 4.2 or greater
          will be configured for this automatic log file removal.  If
          you don't want this feature enabled, simply pass the
          <option>--bdb-log-keep</option> option to the
          <command>svnadmin create</command> command.  If you forget
          to do this, or change your mind at a later time, simple edit
          the <filename>DB_CONFIG</filename> file found in your
          repository's <filename>db</filename> directory, comment out
          the line which contains the <literal>set_flags
          DB_LOG_AUTOREMOVE</literal> directive, and then run
          <command>svnadmin recover</command> on your repository to
          force the configuration changes to take effect.  See <xref
          linkend="svn-ch-5-sect-2.2"/> for more information about
          database configuration.</para>

        <para>Without some sort of automatic log file removal in
          place, log files will accumulate as you use your repository.
          This is actually somewhat of a feature of the database
          system&mdash;you should be able to recreate your entire
          database using nothing but the log files, so these files can
          be useful for catastrophic database recovery.  But
          typically, you'll want to archive the log files that are no
          longer in use by Berkeley DB, and then remove them from disk
          to conserve space.  Use the <command>svnadmin
          list-unused-dblogs</command> command to list the unused
          logfiles:</para>

      <screen>
$ svnadmin list-unused-dblogs /path/to/repos
/path/to/repos/log.0000000031
/path/to/repos/log.0000000032
/path/to/repos/log.0000000033

$ svnadmin list-unused-dblogs /path/to/repos | xargs rm
## disk space reclaimed!
</screen>

        <para>To keep the size of the repository as small as possible,
          Subversion uses <firstterm>deltification</firstterm> (or,
          <quote>deltified storage</quote>) within the repository
          itself.  Deltification involves encoding the representation
          of a chunk of data as a collection of differences against
          some other chunk of data.  If the two pieces of data are
          very similar, this deltification results in storage savings
          for the deltified chunk&mdash;rather than taking up space
          equal to the size of the original data, it only takes up
          enough space to say, <quote>I look just like this other
          piece of data over here, except for the following couple of
          changes.</quote> Specifically, each time a new version of a
          file is committed to the repository, Subversion encodes the
          previous version (actually, several previous versions) as a
          delta against the new version.  The result is that most of
          the repository data that tends to be sizable&mdash;namely,
          the contents of versioned files&mdash;is stored at a much
          smaller size than the original <quote>fulltext</quote>
          representation of that data.</para>

        <note>
          <para>Because all of the Subversion repository data that is
            subject to deltification is stored in a single Berkeley DB
            database file, reducing the size of the stored values will
            not necessarily reduce the size of the database file
            itself.  Berkeley DB will, however, keep internal records
            of unused areas of the database file, and use those areas
            first before growing the size of the database file.  So
            while deltification doesn't produce immediate space
            savings, it can drastically slow future growth of the
            database.</para>
        </note>

    </sect2>
        
    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-3.4">
      <title>Repository Recovery</title>

      <para>In order to protect the data in your repository, the
        database back-end uses a locking mechanism.  This mechanism
        ensures that portions of the database are not simultaneously
        modified by multiple database accessors, and that each process
        sees the data in the correct state when that data is being
        read from the database.  When a process needs to change
        something in the database, it first checks for the existence
        of a lock on the target data.  If the data is not locked, the
        process locks the data, makes the change it wants to make, and
        then unlocks the data.  Other processes are forced to wait
        until that lock is removed before they are permitted to
        continue accessing that section of the database.</para>

      <para>In the course of using your Subversion repository, fatal
        errors (such as running out of disk space or available memory)
        or interruptions can prevent a process from having the chance to
        remove the locks it has placed in the database.  The result is
        that the back-end database system gets <quote>wedged</quote>.
        When this happens, any attempts to access the repository hang
        indefinitely (since each new accessor is waiting for a lock to
        go away&mdash;which isn't going to happen).</para>

      <para>First, if this happens to your repository, don't panic.
        Subversion's filesystem takes advantage of database
        transactions and checkpoints and pre-write journaling to
        ensure that only the most catastrophic of events
        <footnote>
          <para>E.g.: hard drive + huge electromagnet = disaster.</para>
        </footnote>
        can permanently destroy a database environment.  A
        sufficiently paranoid repository administrator will be making
        off-site backups of the repository data in some fashion, but
        don't call your system administrator to restore a backup tape
        just yet.</para>

      <para>Secondly, use the following recipe to attempt to
        <quote>unwedge</quote> your repository:</para>
   
      <orderedlist>
        <listitem>
          <para>Make sure that there are no processes accessing (or
            attempting to access) the repository.  For networked
            repositories, this means shutting down the Apache HTTP
            Server, too.</para>
        </listitem>
        <listitem> 
          <para>Become the user who owns and manages the repository.
            This is important, as recovering a repository while
            running as the wrong user can tweak the permissions of the
            repository's files in such a way that your repository will
            still be inaccessible even after it is 
            <quote>unwedged</quote>.</para>
        </listitem>
        <listitem>
          <para>Run the command <command>svnadmin recover
            /path/to/repos</command>.  You should see output like
            this:</para>
              
          <screen>
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 19.
</screen>
          <para>This command may take many minutes to complete.</para>
        </listitem>
        <listitem>
          <para>Restart the Subversion server.</para>
        </listitem>
      </orderedlist>
            
      <para>This procedure fixes almost every case of repository
        lock-up.  Make sure that you run this command as the user that
        owns and manages the database, not just as
        <literal>root</literal>.  Part of the recovery process might
        involve recreating from scratch various database files (shared
        memory regions, for example).  Recovering as
        <literal>root</literal> will create those files such that they
        are owned by <literal>root</literal>, which means that even
        after you restore connectivity to your repository, regular
        users will be unable to access it.</para>

      <para>If the previous procedure, for some reason, does not
        successfully unwedge your repository, you should do two
        things.  First, move your broken repository out of the way and
        restore your latest backup of it.  Then, send an email to the
        Subversion user list (at
        <email>users@subversion.tigris.org</email>) describing your
        problem in detail.  Data integrity is an extremely high
        priority to the Subversion developers.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-3.5">
      <title>Migrating a Repository</title>
    
      <para>A Subversion filesystem has its data spread throughout
        various database tables in a fashion generally understood by
        (and of interest to) only the Subversion developers
        themselves.  However, circumstances may arise that call for
        all, or some subset, of that data to be collected into a
        single, portable, flat file format.  Subversion provides such
        a mechanism, implemented in a pair of
        <command>svnadmin</command> subcommands:
        <literal>dump</literal> and <literal>load</literal>.</para>

      <para>The most common reason to dump and load a Subversion
        repository is due to changes in Subversion itself.  As
        Subversion matures, there are times when certain changes made
        to the back-end database schema cause Subversion to be
        incompatible with previous versions of the repository.  The
        recommended course of action when you are upgrading across one
        of those compatibility boundaries is a relatively simple
        process:</para>
  
      <orderedlist>
        <listitem>
          <para>Using your <emphasis>current</emphasis> version of
            <command>svnadmin</command>, dump your repositories to
            dump files.</para>
        </listitem>
        <listitem>
          <para>Upgrade to the new version of Subversion.</para>
        </listitem>
        <listitem>
          <para>Move your old repositories out of the way, and create
            new empty ones in their place using your
            <emphasis>new</emphasis> <command>svnadmin</command>.</para>
        </listitem>
        <listitem>
          <para>Again using your <emphasis>new</emphasis>
            <command>svnadmin</command>, load your dump files into
            their respective, just-created repositories.</para>
        </listitem>
        <listitem>
          <para>Finally, be sure to copy any customizations from your
            old repositories to the new ones, including
            <filename>DB_CONFIG</filename> files and hook scripts.
            You'll want to pay attention to the release notes for the
            new release of Subversion to see if any changes since your
            last upgrade affect those hooks or configuration
            options.</para>
        </listitem>
      </orderedlist>

      <para><command>svnadmin dump</command> will output a range of
        repository revisions that are formatted using Subversion's
        custom filesystem dump format.  The dump format is printed to
        the standard output stream, while informative messages are
        printed to the standard error stream.  This allows you to
        redirect the output stream to a file while watching the status
        output in your terminal window.  For example:</para>

      <screen>
$ svnlook youngest myrepos
26
$ svnadmin dump myrepos &gt; dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
&hellip;
* Dumped revision 25.
* Dumped revision 26.
</screen>

      <para>At the end of the process, you will have a single file
        (<filename>dumpfile</filename> in the previous example) that
        contains all the data stored in your repository in the
        requested range of revisions.  Note that <command>svnadmin
        dump</command> is reading revision trees from the repository
        just like any other <quote>reader</quote> process would
        (<command>svn checkout</command>, for example.)  So it's safe
        to run this command at any time.</para>

      <para>The other subcommand in the pair, <command>svnadmin
        load</command>, parses the standard input stream as a
        Subversion repository dump file, and effectively replays those
        dumped revisions into the target repository for that
        operation.  It also gives informative feedback, this time
        using the standard output stream:</para>

      <screen>
$ svnadmin load newrepos &lt; dumpfile
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : A ... done.
     * adding path : A/B ... done.
     &hellip;
------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 2
     * editing path : A/mu ... done.
     * editing path : A/D/G/rho ... done.

------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;

&hellip;

&lt;&lt;&lt; Started new txn, based on original revision 25
     * editing path : A/D/gamma ... done.

------- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 26
     * adding path : A/Z/zeta ... done.
     * editing path : A/mu ... done.

------- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;

</screen>

      <para>Note that because <command>svnadmin</command> uses
        standard input and output streams for the repository dump and
        load process, people who are feeling especially saucy can try
        things like this (perhaps even using different versions of
        <command>svnadmin</command> on each side of the pipe):</para>
  
      <screen>
$ svnadmin create newrepos
$ svnadmin dump myrepos | svnadmin load newrepos
</screen>

      <para>We mentioned previously that <command>svnadmin
        dump</command> outputs a range of revisions.  Use the
        <option>--revision</option> option to specify a single
        revision to dump, or a range of revisions.  If you omit this
        option, all the existing repository revisions will be
        dumped.</para>

      <screen>
$ svnadmin dump myrepos --revision 23 &gt; rev-23.dumpfile
$ svnadmin dump myrepos --revision 100:200 &gt; revs-100-200.dumpfile
</screen>

      <para>As Subversion dumps each new revision, it outputs only
        enough information to allow a future loader to re-create that
        revision based on the previous one.  In other words, for any
        given revision in the dump file, only the items that were
        changed in that revision will appear in the dump.  The only
        exception to this rule is the first revision that is dumped
        with the current <command>svnadmin dump</command>
        command.</para>

      <para>By default, Subversion will not express the first dumped
        revision as merely differences to be applied to the previous
        revision.  For one thing, there is no previous revision in the
        dump file!  And secondly, Subversion cannot know the state of
        the repository into which the dump data will be loaded (if it
        ever, in fact, occurs).  To ensure that the output of each
        execution of <command>svnadmin dump</command> is
        self-sufficient, the first dumped revision is by default a
        full representation of every directory, file, and property in
        that revision of the repository.</para>

      <para>However, you can change this default behavior.  If you add
        the <option>--incremental</option> option when you dump your
        repository, <command>svnadmin</command> will compare the first
        dumped revision against the previous revision in the
        repository, the same way it treats every other revision that
        gets dumped.  It will then output the first revision exactly
        as it does the rest of the revisions in the dump
        range&mdash;mentioning only the changes that occurred in that
        revision.  The benefit of this is that you can create several
        small dump files that can be loaded in succession, instead of
        one large one, like so:</para>

      <screen>
$ svnadmin dump myrepos --revision 0:1000 &gt; dumpfile1
$ svnadmin dump myrepos --revision 1001:2000 --incremental &gt; dumpfile2
$ svnadmin dump myrepos --revision 2001:3000 --incremental &gt; dumpfile3
</screen>

      <para>These dump files could be loaded into a new repository with
        the following command sequence:</para>

      <screen>
$ svnadmin load newrepos &lt; dumpfile1
$ svnadmin load newrepos &lt; dumpfile2
$ svnadmin load newrepos &lt; dumpfile3
</screen>

      <para>Another neat trick you can perform with this
        <option>--incremental</option> option involves appending to an
        existing dump file a new range of dumped revisions.  For
        example, you might have a <literal>post-commit</literal> hook
        that simply appends the repository dump of the single revision
        that triggered the hook.  Or you might have a script that runs
        nightly to append dump file data for all the revisions that
        were added to the repository since the last time the script
        ran.  Used like this, <command>svnadmin</command>'s
        <literal>dump</literal> and <literal>load</literal> commands
        can be a valuable means by which to backup changes to your
        repository over time in case of a system crash or some other
        catastrophic event.</para>

      <para>The dump format can also be used to merge the contents of
        several different repositories into a single repository.  By
        using the <option>--parent-dir</option> option of <command>svnadmin
        load</command>, you can specify a new virtual root directory
        for the load process.  That means if you have dumpfiles for
        three repositories, say <filename>calc-dumpfile</filename>,
        <filename>cal-dumpfile</filename>, and
        <filename>ss-dumpfile</filename>, you can first create a new
        repository to hold them all:</para>

      <screen>
$ svnadmin create /path/to/projects
$
</screen>

      <para>Then, make new directories in the repository which will
        encapsulate the contents of each of the three previous
        repositories:</para>

      <screen>
$ svn mkdir -m "Initial project roots" \
      file:///path/to/projects/calc \
      file:///path/to/projects/calendar \
      file:///path/to/projects/spreadsheet
Committed revision 1.
$ 
</screen>

      <para>Lastly, load the individual dumpfiles into their
        respective locations in the new repository:</para>

      <screen>
$ svnadmin load /path/to/projects --parent-dir calc &lt; calc-dumpfile
&hellip;
$ svnadmin load /path/to/projects --parent-dir calendar &lt; cal-dumpfile
&hellip;
$ svnadmin load /path/to/projects --parent-dir spreadsheet &lt; ss-dumpfile
&hellip;
$
</screen>

      <para>We'll mention one final way to use the Subversion
        repository dump format&mdash;conversion from a different
        storage mechanism or version control system altogether.
        Because the dump file format is, for the most part,
        human-readable,
        <footnote>
          <para>The Subversion repository dump format resembles
            an RFC-822 format, the same type of format used for most
            email.</para>
        </footnote>
        it should be relatively easy to describe generic sets of
        changes&mdash;each of which should be treated as a new
        revision&mdash;using this file format.  In fact, the
        <command>cvs2svn.py</command> utility (see <xref
        linkend="svn-ap-a-sect-11"/>) uses the dump format to represent the
        contents of a CVS repository so that those contents can be
        moved in a Subversion repository.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-3.6">
      <title>Repository Backup</title>

      <para>Despite numerous advances in technology since the birth of
        the modern computer, one thing unfortunately rings true with
        crystalline clarity&mdash;sometimes, things go very, very
        awry.  Power outages, network connectivity dropouts, corrupt
        RAM and crashed hard drives are but a taste of the evil that
        Fate is poised to unleash on even the most conscientious
        administrator.  And so we arrive at a very important
        topic&mdash;how to make backup copies of your repository
        data.</para>

      <para>There are generally two types of backup methods available
        for Subversion repository administrators&mdash;incremental and
        full.  We discussed in an earlier section of this chapter how
        to use <command>svnadmin dump --incremental</command> to
        perform an incremental backup (see <xref
        linkend="svn-ch-5-sect-3.5"/>).  Essentially, the idea is to
        only backup at a given time the changes to the repository
        since the last time you made a backup.</para>

      <para>A full backup of the repository is quite literally a
        duplication of the entire repository directory (which includes
        the Berkeley database environment).  Now, unless you
        temporarily disable all other access to your repository,
        simply doing a recursive directory copy runs the risk of
        generating a faulty backup, since someone might be currently
        writing to the database.</para>

      <para>Fortunately, Sleepycat's Berkeley DB documents describe a
        certain order in which database files can be copied that will
        guarantee a valid backup copy.  And better still, you don't
        have to implement that algorithm yourself, because the
        Subversion development team has already done so.  The
        <command>hot-backup.py</command> script is found in the
        <filename>tools/backup/</filename> directory of the Subversion
        source distribution.  Given a repository path and a backup
        location, <command>hot-backup.py</command>&mdash;which is
        really just a more intelligent wrapper around the
        <command>svnadmin hotcopy</command> command&mdash;will perform
        the necessary steps for backing up your live
        repository&mdash;without requiring that you bar public
        repository access at all&mdash;and then will clean out the
        dead Berkeley log files from your live repository.</para>

      <para>Even if you also have an incremental backup, you might want to run
        this program on a regular basis.  For example, you might
        consider adding <command>hot-backup.py</command> to a program
        scheduler (such as <command>cron</command> on Unix systems).
        Or, if you prefer fine-grained backup solutions, you could
        have your post-commit hook script call
        <command>hot-backup.py</command> (see <xref
        linkend="svn-ch-5-sect-2.1" />), which will then cause a new
        backup of your repository to occur with every new revision
        created.  Simply add the following to the
        <filename>hooks/post-commit</filename> script in your live
        repository directory:</para>

      <programlisting>
(cd /path/to/hook/scripts; ./hot-backup.py ${REPOS} /path/to/backups &amp;)
</programlisting>

      <para>The resulting backup is a fully functional Subversion
        repository, able to be dropped in as a replacement for your
        live repository should something go horribly wrong.</para>

      <para>There are benefits to both types of backup methods.  The
        easiest is by far the full backup, which will always result in
        a perfect working replica of your repository.  This again
        means that should something bad happen to your live
        repository, you can restore from the backup with a simple
        recursive directory copy.  Unfortunately, if you are
        maintaining multiple backups of your repository, these full
        copies will each eat up just as much disk space as your live
        repository.</para>

      <para>Incremental backups using the repository dump format are
        excellent to have on hand if the database schema changes
        between successive versions of Subversion itself.  Since a
        full repository dump and load are generally required to
        upgrade your repository to the new schema, it's very
        convenient to already have half of that process (the dump
        part) finished.  Unfortunately, the creation of&mdash;and
        restoration from&mdash;incremental backups takes longer, as
        each commit is effectively replayed into either the dumpfile
        or the repository.</para>

      <para>In either backup scenario, repository administrators need
        to be aware of how modifications to unversioned revision
        properties affect their backups.  Since these changes do not
        themselves generate new revisions, they will not trigger
        post-commit hooks, and may not even trigger the
        pre-revprop-change and post-revprop-change hooks.
        <footnote>
          <para><command>svnadmin setlog</command> can be called in a
            way that bypasses the hook interface altogether.</para>
        </footnote>  
        And since you can change revision properties without respect
        to chronological order&mdash;you can change any revision's
        properties at any time&mdash;an incremental backup of the
        latest few revisions might not catch a property modification
        to a revision that was included as part of a previous 
        backup.</para>

      <para>Generally speaking, only the truly paranoid would need to
        backup their entire repository, say, every time a commit
        occurred.  However, assuming that a given repository has some
        other redundancy mechanism in place with relatively fine
        granularity (like per-commit emails), a hot backup of the
        database might be something that a repository administrator
        would want to include as part of a system-wide nightly backup.
        For most repositories, archived commit emails alone provide
        sufficient redundancy as restoration sources, at least for the
        most recent few commits.  But it's your data&mdash;protect it
        as much as you'd like.</para>
            
      <para>Often, the best approach to repository backups is a
        diversified one.  You can leverage combinations of full and
        incremental backups, plus archives of commit emails.  The
        Subversion developers, for example, back up the Subversion
        source code repository after every new revision is created,
        and keep an archive of all the commit and property change
        notification emails.  Your solution might be similar, but
        should be catered to your needs and that delicate balance of
        convenience with paranoia.  And while all of this might not
        save your hardware from the iron fist of Fate,
        <footnote>
          <para>You know&mdash;the collective term for all of her
            <quote>fickle fingers</quote>.</para>
        </footnote>
        it should certainly help you recover from those trying 
        times.</para>

    </sect2>
  </sect1>


  <!-- ******************************************************************* -->
  <!-- *** SECTION 6:  ADDING PROJECTS                                 *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-5-sect-6">
    <title>Adding Projects</title>

    <para>Once your repository is created and configured, all that
      remains is to begin using it.  If you have a collection of
      existing data that is ready to be placed under version control,
      you will more than likely want to use the <command>svn</command>
      client program's <literal>import</literal> subcommand to
      accomplish that.  Before doing this, though, you should
      carefully consider your long-term plans for the repository.  In
      this section, we will offer some advice on how to plan the
      layout of your repository, and how to get your data arranged in
      that layout.</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-6.1">
      <title>Choosing a Repository Layout</title>

      <para>While Subversion allows you to move around versioned files
        and directories without any loss of information, doing so can
        still disrupt the workflow of those who access the repository
        often and come to expect things to be at certain locations.
        Try to peer into the future a bit; plan ahead before placing
        your data under version control.  By <quote>laying out</quote>
        the contents of your repositories in an effective manner the
        first time, you can prevent a load of future headaches.</para>

      <para>There are a few things to consider when setting up
        Subversion repositories.  Let's assume that as repository
        administrator, you will be responsible for supporting the
        version control system for several projects.  The first
        decision is whether to use a single repository for multiple
        projects, or to give each project its own repository, or some
        compromise of these two.</para>

     <para>There are benefits to using a single repository for
       multiple projects, most obviously the lack of duplicated
       maintenance.  A single repository means that there is one set
       of hook scripts, one thing to routinely backup, one thing to
       dump and load if Subversion releases an incompatible new
       version, and so on.  Also, you can move data between
       projects easily, and without losing any historical versioning
       information.</para>

     <para>The downside of using a single repository is that different
       projects may have different commit mailing lists or different
       authentication and authorization requirements.  Also, remember
       that Subversion uses repository-global revision numbers.  Some
       folks don't like the fact that even though no changes have been
       made to their project lately, the youngest revision number for
       the repository keeps climbing because other projects are
       actively adding new revisions.</para>

     <para>A middle-ground approach can be taken, too.  For example,
       projects can be grouped by how well they relate to each other.
       You might have a few repositories with a handful of projects in
       each repository.  That way, projects that are likely to want to
       share data can do so easily, and as new revisions are added to
       the repository, at least the developers know that those new
       revisions are at least remotely related to everyone who uses
       that repository.</para>

     <para>After deciding how to organize your projects with respect
       to repositories, you'll probably want to think about directory
       hierarchies in the repositories themselves.  Because Subversion
       uses regular directory copies for branching and tagging (see
       <xref linkend="svn-ch-4"/>), the Subversion community
       recommends that you choose a repository location for each
       <firstterm>project root</firstterm>&mdash;the
       <quote>top-most</quote> directory which contains data related
       to that project&mdash;and then create three subdirectories
       beneath that root: <filename>trunk</filename>, meaning the
       directory under which the main project development occurs;
       <filename>branches</filename>, which is a directory in which to
       create various named branches of the main development line;
       <filename>tags</filename>, which is a directory of branches
       that are created, and perhaps destroyed, but never
       changed.</para>

     <para>For example, your repository might look like:</para>

     <screen>
/
   calc/
      trunk/
      tags/
      branches/
   calendar/
      trunk/
      tags/
      branches/
   spreadsheet/
      trunk/
      tags/
      branches/
   &hellip;
</screen>

      <para>Note that it doesn't matter where in your repository each
        project root is.  If you have only one project per repository,
        the logical place to put each project root is at the root of
        that project's respective repository.  If you have multiple
        projects, you might want to arrange them in groups inside the
        repository, perhaps putting projects with similar goals or
        shared code in the same subdirectory, or maybe just grouping
        them alphabetically.  Such an arrangement might look
        like:</para>

      <screen>
/
   utils/
      calc/
         trunk/
         tags/
         branches/
      calendar/
         trunk/
         tags/
         branches/
      &hellip;
   office/
      spreadsheet/
         trunk/
         tags/
         branches/
      &hellip;
</screen>

      <para>Lay out your repository in whatever way you see fit.
        Subversion does not expect or enforce a layout schema&mdash;in
        its eyes, a directory is a directory is a directory.
        Ultimately, you should choose the repository arrangement that
        meets the needs of the people who work on the projects that
        live there.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-6.2">
      <title>Creating the Layout, and Importing Initial Data</title>
          
      <para>After deciding how to arrange the projects in your
        repository, you'll probably want to actually populate the
        repository with that layout and with initial project data.
        There are a couple of ways to do this in Subversion.  You
        could use the <command>svn mkdir</command> command (see <xref
        linkend="svn-ch-9"/>) to create each directory in your
        skeletal repository layout, one-by-one.  A quicker way to
        accomplish the same task is to use the <command>svn
        import</command> command (see <xref
        linkend="svn-ch-3-sect-7.3"/>).  By first creating the layout
        in a temporary location on your drive, you can import the
        whole layout tree into the repository in a single
        commit:</para>
            
      <screen>
$ mkdir tmpdir
$ cd tmpdir
$ mkdir projectA
$ mkdir projectA/trunk
$ mkdir projectA/branches
$ mkdir projectA/tags
$ mkdir projectB
$ mkdir projectB/trunk
$ mkdir projectB/branches
$ mkdir projectB/tags
&hellip;
$ svn import . file:///path/to/repos --message 'Initial repository layout'
Adding         projectA
Adding         projectA/trunk
Adding         projectA/branches
Adding         projectA/tags
Adding         projectB
Adding         projectB/trunk
Adding         projectB/branches
Adding         projectB/tags
&hellip;
Committed revision 1.
$ cd ..
$ rm -rf tmpdir
$
</screen>

      <para>You can verify the results of the import by running the
        <command>svn list</command> command:</para>

      <screen>
$ svn list --verbose file:///path/to/repos
      1 harry               May 08 21:48 projectA/
      1 harry               May 08 21:48 projectB/
&hellip;
$
</screen>

      <para>Once you have your skeletal layout in place, you can begin
        importing actual project data into your repository, if any
        such data exists yet.  Once again, there are several ways to
        do this.  You could use the <command>svn import</command>
        command.  You could checkout a working copy from your new
        repository, move and arrange project data inside the working
        copy, and use the <command>svn add</command> and <command>svn
        commit</command> commands.  But once we start talking about
        such things, we're no longer discussing repository
        administration.  If you aren't already familiar with the
        <command>svn</command> client program, see <xref
        linkend="svn-ch-3"/>.</para>

    </sect2>
  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 7:  SUMMARY                                         *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-5-sect-7">
    <title>Summary</title>

    <para>By now you should have a basic understanding of how to
      create, configure, and maintain Subversion repositories.  We've
      introduced you to the various tools that will assist you with
      this task.  Throughout the chapter, we've noted common
      administration pitfalls, and suggestions for avoiding
      them.</para>

    <para>All that remains is for you to decide what exciting data to
      store in your repository, and finally, how to make it available
      over a network.  The next chapter is all about networking.</para>

  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
