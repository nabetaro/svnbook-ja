<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- originated from English revision 10817 -->
<chapter id="svn-ch-5">
<title>Administración del Repositorio</title>

  <simplesect>

    <para>El repositorio de Subversion es el almacén central
      de datos y versiones para un número indeterminado de proyectos;
      de esta manera se convierte en el destinatario obvio
      de todo el amor y atención que un administrador puede ofrecer.
      Aunque el repositorio es, en general, un elemento de bajo
      mantenimiento, es importante entender cómo configurarlo
      y cuidarlo correctamente para evitar problemas potenciales
      y para solucionar los problemas actuales de forma segura.</para>

    <para>En este capítulo, explicaremos cómo crear y configurar
      un repositorio Subversion, y cómo publicarlo para acceder a él por
      red. También hablaremos acerca del mantenimiento del repositorio,
      incluyendo el uso de las herramientas <command>svnlook</command>
      y <command>svnadmin</command> ( que están disponibles junto con
      Subversion ).  Trataremos también algunas preguntas y errores
      comunes, y haremos sugerencias sobre la forma de organizar los
      datos en el repositorio.</para>

    <para>Si planea acceder al repositorio Subversion sólo desde el
      punto de vista de un usuario cuyos datos están bajo control de
      versiones (es decir, un cliente Subversion), puede saltarse este
      capítulo en conjunto.  Sin embargo, si vd. es, o quiere convertirse
      en un administrador de repositorios Subversion,
      <footnote>
        <para>Puede sonar realmente prestigioso y <!--TODO: lofty: alto?
        This may sound really prestigious and lofty -->, pero sólo
        estamos hablando de cualquier personal que esté interesada en 
        el misterioso reino más allá de la copia de trabajo, donde
        los datos de todos <!--TODO: hang out?
        where everyone's data hangs out. --></para>
      </footnote>
      debería sin lugar a dudas prestar atención a este capítulo.</para>

  </simplesect>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 1:  REPOSITORY BASICS                               *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-5-sect-1">
    <title>Cuestiones básicas acerca de el repositorio</title>

    <para>Antes de entrar en el tema principal de la administración
      del repositorio, vamos a definir con más detalle qué es un repositorio.
      ¿Qué pinta tiene? ¿Cómo se siente? ¿Se toma el té caliente o helado,
      dulce, y con limón? Como administrador, necesitará entender la
      composición de un repositorio desde una perspectiva lógica&mdash;
      <!--TODO: deal-->dealing con cómo se representa la información
      dentro del repositorio&mdash;y desde una perspectiva <!--TODO:
      nuts-and-bolts-->&mdash;qué apariencia tiene y cómo actúa un
      repositorio con respecto a herramientas no pertenecientes a Subversion.
      La siguiente sección se ocupa de algunos de estos conceptos básicos
      a un nivel muy alto.</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-1.1">
      <title>Entendiendo las Transacciones y Revisiones</title>

      <para>Hablando conceptualmente, un repositorio Subversion es
        una secuencia de árboles de directorios. Cada árbol es una
  <!--TODO:snapshot=¿fotografía?-->fotografía de cómo eran 
  los ficheros y directorios versionados en tu repositorio en
  un momento determinado. Estas fotografías son generadas como
  resultado de operaciones de programas cliente, y son llamadas
  revisiones.</para>

      <para>Cada revisión nace como un árbol de transacciones. Cuando se
        envían cambios al repositorio, el programa cliente construye
        una transacción de Subversion que copia los cambios locales
        ( junto a cualquier cambio adicional que haya podido tener lugar
        desde el comienzo del proceso de envío de datos),
        y luego pide al repositorio que guarde ese árbol como la próxima
        <!--TODO: snapshot=fotografía -->fotograría en la secuencia.
        Si el envío de datos no da error, la transacción se convierte
        en una nueva revisión del árbol, y se le asigna un nuevo número de
        revisión. Si el envío de datos fallara por alguna razón,
  la transacción se destruye, y se le informa al cliente del error.</para>
        
      <para>Las actualizaciones funcionan de una manera parecida. El Cliente
        prepara un árbol de transacción temporal que <!--mirrors=copia?-->copia el estado
        de la copia de trabajo. El repositorio compara entonces ese
        árbol de transacción con el árbol de la revisión solicitada
        (normalmente la más reciente, o el árbol <quote>youngest</quote>), e
        informa al cliente acerca de qué cambios son necesario para
        convertir su copia local de trabajo en una réplica de ese árbol
        de revisión. Tras completarse la actualización, se borra la transacción 
        temporal.</para>
          
      <para>El uso de árboles de transacción es la única manera
        de hacer cambio permanentes en un repositorio de sistema
        de ficheros versionados. De todas maneras, es importante
        entender que el tiempo de vida de una transacción es completamente
        flexible. En el caso de actualizaciones, las transacciones con árboles
        temporales que se destruyen inmediatamente. En el caso de <!--TODO commits-->
        commits, las transacciones son transformadas en revisiones
        permanentes ( o borradas si el <!--TODO--> falla ). En el 
        caso de un error, es posible que una transacción permanezca 
        accidentalmente suelta en el repositorio ( sin que afecte
        en realidad a nada, pero ocupando espacio).</para>
     
     <para>En teoría, un día los programas de flujo de trabajo completo
        deberán girar hacia un control más fino del tiempo de vida de
        la transacción. Es factible imaginar un sistema por el que
        cada transacción <!--TODO slated???--> que se convierta en
        revisión permanezca en <!--TODO: stasis?? --> bastante después
        de que el cliente termine de describir sus cambios al repositorio.
        Esto permitiría que cada nuevo <!--commit --> sea revisado
        por alguna otra persona, quizás un <!--manager-->director o 
        <!--TODO:engineering QA team-->, que pueda elegir entre promoverla
        a una revisión, o cancelarla.</para>
            
    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-1.2">
      <title>Propiedades no versionadas</title>

      <para>Las transacciones y las revisiones en el repositorio
        subversion pueden tener propiedades adjuntas. Estas propiedades
        son mapeos genéricos clave-valor, y generalmente se usan
        para guardar información acerca del árbol al que están adjuntas.
        Los nombres y valores de estas propiedades se guardan en el
        sistema de ficheros del repositorio, junto con el resto de
        los datos de tu árbol.</para>

      <para>Las propiedades de revisiones y transacciones son útiles para
        asociar información con un árbol que no está estríctamente
        relacionada con los ficheros y directorios de ese árbol&mdash;el
        tipo de información que no es gestiona por las copias de trabajo
        de cliente. Por ejemplo, cuando una nueva transacción commit es
        creada en el repositorio, Subversion añade una propiedad a dicha
        transacción llamada <literal>svn:date</literal>&mdash; un
        datestamp <!--TODO: ¿traducir esto?--> que representa el momento
        en que la transacción se creó. En el momento que el proceso
        de commit termina, el árbol también ha recibido una propiedad
        para guardar el nombre del usuario que es autor de la revisión
        (<literal>svn:author</literal>) y una propiedad para guardar
        el mensaje de log <!--TODO: ¿traducir?--> adjunto a dicha
        revisión (<literal>svn:log</literal>).</para>

      <para>Las propiedades de revisiones y transacciones son
        <firstterm>propiedades no versionada</firstterm>&mdash;cuando
        son modificadas, sus valores previos se descartan definitivamente.
        Asímismo, mientras los árboles de revisiones en sí son inmutables,
        las propiedades adjuntas de dichos árboles no lo son. Puedes añadir,
        borrar, y modificar propiedades de revisiones en cualquier momento
        más adelante. Si envías al repositorio una nueva revisión y más tarde
        te das cuenta de alguna información incorrecta o un error sintáctico
        en tu mensaje de log, puedes simplemente sustituir el valor de
        la propiedad <literal>svn:log</literal> con un nuevo y corregido
        mensaje de log.</para>
  
    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-1.3">
      <title>Berkeley DB</title>

        <para>Los datos almacenados dentro de repositorios Subversion,
          realmente se encuentran en una base de datos, más concretamente,
          un fichero de base de datos Berkley DB. Durante la fase inicial
          de diseño de Subversion, los desarrolladores decicieron usar
          una base de datos Berkeley por una serie de razones, como
          su licencia open-source, soporte de transacciones, ser de confianza,
          funcionamiento, simplicidad de su API, soporte de hilos, cursores,
          y más.</para> 
  
        <para>La base de datos Berkeley tiene un soporte real de transacciones
          &mdash;probablemente es su característica más poderosa.
          Muchos procesos que accede a tus repositorios Subversion
          not tienen que preocuparse por <!--TODO: ¿clobbering? --> los
          datos de otros. El aislamiento provisto por el sistema de
          transacciones es tal que por cada operación dada, el código
          de repositorio Subversion tiene una vista estática de la base
          de datos&mdash;no una base de datos que está constantemente
          cambiando de la mano de algunos otros procesos&mdash;y puede
          tomar decisiones basándose en esa vista. Si dicha decisión
          está en conflicto con lo que otro proceso esté haciendo,
          la operación completa <!--TODO: is rolled back --> como si nunca
          hubiera sucedido, y Subversion <!--TODO:gratefully--> reintenta
          la operación contra una nueva y actualizada ( y estática ) vista
          de la base de datos.</para>

        <para>Otra gran característica de la base de datos Berkeley son las
          <firstterm>copias de seguridad en caliente</firstterm>&mdash;
          la habilidad para hacer una copia de seguridad del entorno
          de la base de datos sin que tenga que estar <quote><!--TODO:offline--></quote>.
          Hablaremos sobre cómo hacer copias de seguridad de tu repositorio
          en <xref linkend="svn-ch-5-sect-3.6" />, pero los beneficios
          de ser capaz de hacer copias completas y funcionales de tus
          repositorios sin <!--TODO:downtime--> debería ser obvia.</para>

        <para>La base de datos Berkely también es un sistema de bases de
          datos de mucha confianza. Subversion utiliza las utilidades
          de registro de las BD Berkeley, lo que significa
          que la base datos primero escribe una descripción de cualquier
          modificación que vaya a hacer en ficheros de registros, para luego
          hace la propia modificación. Esto es para asegurar que si
          algo fuese mal, el sistema de base de datos pueda retroceder
          a un <!--TODO:checkpoint--><firstterm>checkpoint</firstterm>&mdash;una
          posición en los ficheros de registro que se sabe que no están
          corruptas&mdash;y repetir transacciones hasta que los datos estén
          en un estado usable. Ver <xref linkend="svn-ch-5-sect-3.3"/>
          si quieres más información acerca de los ficheros de registro
    de las BD Berkeley.</para>

        <para>Pero toda rosa tiene su espina, así que tenemos que
          hablar sobre algunas conocidas limitaciones de la BD Berkeley.
          Primero, los entornos de BD Berkeley no son portables. No puedes
          copiar simplemente un repositorio Subversion que fue creado
          en un sistema Unix a un sistema Windows y esperar que funcione.
          Mientras mucho del formato de base de datos de la BD Berkeley
          es independiente de la arquitectura, hay otros aspectos del
    entorno que no lo son.
          Segundo, Subversion usa BD Berkeley de una manera que no puede
          funcionar en sistemas Windows 95/98&mdash;si necesita almacenar
          un repositorio en una máquina Windows, <!--TODO stick-->utilice
          Windows 2000 o Windows XP. Finalmente, no deberías mantener un
          repositorio Subversion en una unidad compartida por red. Mientras
          las BD Berkeley prometen un comportamiento correcto en unidades
          compartidas por red que cumplan un grupo particular de especificaciones,
          casi ningún sistema de compartición conocido cumple con todas
          esas especificaciones.</para>

    </sect2>
  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 2:  REPOSITORY CREATION AND CONFIGURATION           *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-5-sect-2">
    <title>Creación y Configuración de Repositorios</title>

    <para>Crear un repositorio Subversion es una tarea increíblemente
      simple. La utilidad <command>svnadmin</command>, provista con 
      Subversion, tiene un subcomando justo para esto. Para crear un
      nuevo repositorio, ejecuta:</para>
          
    <screen>
$ svnadmin create /path/to/repos
</screen>
          
    <para>Crea un nuevo repositorio en el directorio
      <filename>/path/to/repos</filename>. Dicho nuevo repositorio comienza
      su vida en la revisión 0, que se define como nada excepto el directorio raíz
      (<filename>/</filename>) del sistema de ficheros. Inicialmente,
      la revisión 0 tiene también una única propiedad de revisión,
      <literal>svn:date</literal>, que tiene la hora a la que el
      el repositorio fue creado.</para>

    <warning>
      <para>No crees tu repositorio en una unidad de red compartida
        &mdash;no <emphasis>puede</emphasis> existir un un sistema
        de ficheros remoto como NFS, AFS, o Windows SMB. La DB Berkeley
        necesita que el sistema de ficheros subyacente implemente
        estrictamente la semántica de bloqueo POSIX, y más importante,
  la habilidad para mapear ficheros directamente <!--TODO into 
        process memory.--> Casi ningún sistema de ficheros de red
        tiene estas características. Si intentas usar una BD Berkeley
        en una unidad compartida de red, los resultados son impredecibles
        &mdash;puede que veas errores misteriosos, o pueden pasar meses
        hasta que descubras que la base de datos de tu repositorio está
        sutilmente corrupta.</para>

      <para>Si necesitas que varios ordenadores accedan al repositorio,
        deberías instalar un proceso servidor ( como Apache o <command>svnserve</command>),
        almacenar el repositorio en un sistema de ficheros local al que
        el servidor pueda acceder, y hacer que el repositorio esté
        disponible por la red. <xref linkend="svn-ch-6"/> se ocupa
        de este proceso en detalle.</para>
    </warning>
          
    <para>Te habrás dado cuenta de que el argumento de ruta de
      <command>svnadmin</command> fue sólo una ruta normal del sistema
      de ficheros y no una URL como la que el programa cliente
      <command>svn</command> usa cuando se refiere a los repositorios.
      Tanto  <command>svnadmin</command> como <command>svnlook</command>
      son considerados como utilidades del lado del servidor&mdash;
      se usan en la máquina donde reside el repositorio para examinar
      o modificar aspectos del mismo, y son de hecho, tareas imposibles
      de realizar por red. Un error común hecho por recién llegados a
      Subversion es tratar de pasar URLs ( incluso las  <literal>file:</literal>
      <quote>locales</quote> ) a ambos programas.</para>

    <para>Así, después de que hayas ejecutado el comando <command>svnadmin create</command>,
      tienes un nuevo y brillante repositorio Subversion en su propio
      directorio. Echemos una ojeada a qué es lo que realmente se crea
      dentro de ese subdirectorio.</para>
            
    <screen>
$ ls repos
conf/  dav/  db/  format  hooks/  locks/  README.txt
</screen>
      
    <para>Con la excepción de los ficheros <filename>README.txt</filename> y
      <filename>format</filename>, el directorio del repositorio es un grupo
      de subdirectorios. Al igual que en otras áreas del diseño de Subversion,
      se le tiene mucho respeto a la modularidad, y se prefiere una
      organización jerárquica antes que un caos que estorbe. He aquí una breve
      descripción de todos los objetos que puedes ver en tu nuevo directorio
      de repositorio:</para>

    <variablelist>
     <varlistentry>
        <term>conf</term>
        <listitem>
          <para>Un directorio que contiene los ficheros de configuración del repositorio.</para>
        </listitem>
      </varlistentry>
     <varlistentry>
        <term>dav</term>
        <listitem>
          <para>Un directorio para Apache y mod_dav_svn y su
            economía privada de datos.<!--TODO:comprobar "housekeeping"--></para>    
        </listitem>
      </varlistentry>
     <varlistentry>
        <term>db</term>
        <listitem>
          <para>El entorno principal de la BD Berkeley, lleno de tablas
            que <!--TODO:comprise--> el almacenamiento de datos para
            el sistema de ficheros de Subversion ( donde todos tus
            datos versionados residen.</para>
        </listitem>
      </varlistentry>
     <varlistentry>
        <term>format</term>
        <listitem>
          <para>Un fichero cuyo contenido es un simple valor entero que
            nos dice el número de versión del repositorio <!--TODO:layout--></para>    
        </listitem>
      </varlistentry>
     <varlistentry>
        <term>hooks</term>
        <listitem>
          <para>Un directorio lleno de <!--hook script templates-->
            ( y los mismos <!--TODO: hook scripts-->, una vez que hayas instalados
            algunos.</para>
        </listitem>
      </varlistentry>
     <varlistentry>
        <term>locks</term>
        <listitem>
          <para>Un directorio para el bloqueo de datos de repositorio
            de Subversion, usado para <!--TODO: tracking --> los
            accesos al repositorio.</para>
        </listitem>
      </varlistentry>
     <varlistentry>
        <term>README.txt</term>
        <listitem>
          <para>Un fichero que simplemente informa a sus lectores que
            están mirando un repositorio Subversion.</para>
        </listitem>
      </varlistentry>
    </variablelist>
      
    <para>En general, no deberías <!--TODO: tamper --> con tu repositorio
      <quote>a mano</quote>. La herramienta <command>svnadmin</command>
      debería ser suficiente para cualquier cambio necesarios en tu
      repositorio, o puedes echar una ojeada a herramientas de terceros
      ( como la suite<!--TODO: suite-->de herramientas de la BD Berkeley )
      para <!--TODO: tweaking--> subsecciones relevantes del repositorio.
      Sin embargo, hay algunas excepciones, y las veremos aquí.</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-2.1">
      <title>Hook Scripts</title>

       <!--TODO: párrafo complicado, revisar -->
       <para>Un <firstterm><!--TODO: hook-->hook</firstterm> es un programa
        <!--TODO: triggered --> por algún evento del repositorio, como la
        creación de una nueva revisión o la modificación de una propiedad
        no versionada. A cada hook se le da suficiente información para
        que sepa de qué evento se trata, cuál es su objetivo, y el nombre
        de usuario de la persona que disparó el evento. Dependiendo de
        la salida del hook o de estado de su salida, el programa hook
        puede continuar la acción, pararla, o suspenderla de alguna manera.</para>
            
      <para>El subdirectorio  <filename>hooks</filename> se rellena,
        por defecto, con plantillas para varios hooks de repositorio.</para>
            
      <screen>
$ ls repos/hooks/
post-commit.tmpl          pre-revprop-change.tmpl
post-revprop-change.tmpl  start-commit.tmpl
pre-commit.tmpl           
</screen>
            
      <para>Hay una plantilla por cada hook que implementa el repositorio
        Subversion, y examinando los contenidos de dichas plantillas
        de scripts, puede ver qué <!--TODO triggers><-->triggers ejecuta
        cada script y qué datos se le pasan. También se encuentran
        en muchas de estas plantillas ejemplos de cómo debería usar
        dicho script, conjuntamente con otros programas provistos
        por Subversion, para realizar tareas comunes y útiles. Para instalar
        realmente un hook funcional, sólo necesita colocar algún ejecutable
        o script en el directorio <filename>repos/hooks</filename> que pueda
        ser ejecutado con el nombre del hook ( como <command>start-commit</command>
        o <command>post-commit</command>).</para>

      <para>En plataformas Unix, esto significa proveer un script o
        programa (podría ser un shell script, un programa Python,
        un binario C compilado, o cualquier otra cosa) llamado
        exactamente igual que el nombre del hook. Por supuesto,
        los ficheros de plantillas están presentes para algo más
        que sólo propósitos informativos&mdash;la manera más fácil de
        instalar un hook en plataformas Unix es simplemente copiar
        el fichero de plantilla apropiado en un nuevo fichero sin la
        extensión <literal>.tmpl</literal>, personalizando los contenidos
        del hook, y asegurándose de que el script sea ejecutable.
        Windows, sin embargo, usa extensiones de fichero para determinar
        si un programa es ejecutable o no, así que debería dar poner
        un programa cuyo nombre sea el nombre del hook, y cuya extensión
        sea una de las extensiones especiales reconocidas por Windows
        como ficheros ejecutables, como  <filename>.exe</filename> o
        <filename>.com</filename> para programas, y <filename>.bat</filename>
        para ficheros de scripts.</para>

      <para>Actualmente hay cinco hooks implementados por el 
        repositorio Subversion:</para>

      <variablelist>
        <varlistentry>
          <term><filename>start-commit</filename></term>
          <listitem>
            <para>Se ejecuta antes de la transacción commit haya sido
              creada. Se usa normalmente para decidir si el usuario
              tiene los privilegios suficientes. El repositorio pasa
              dos argumentos a este programa: la ruta al repositorio,
              y el nombre de usuario que intenta realizar el commit.
              Si el programa devuelve algún valor distinto de cero, se
              paraliza el commit antes de haber creado la transacción.</para>
          </listitem>
        </varlistentry>
            
        <varlistentry>
          <term><filename>pre-commit</filename></term>
          <listitem>
            <para>Se ejecuta cuando se completa la transacción, pero
              antes de ser enviados los datos al respositorio. Este hook
              se usa normalmente como protección contra commits que no se
              permiten debido a contenido o ubicación ( por ejemplo, tu
              sitio puede requerir que todos los commits a una rama
              determinada incluyan un número de ticket del seguimiento de
              fallos, o que el mensaje de log entrante no esté vacío).
              El repositorio pasa dos argumentos a este programa: la ruta
              al repositorio, y el nombre de la transacción que va a sufrir
              el commmit. Si el programa devuelve una salida que no sea cero,
              el commit se aborta y la transacción se borra.</para>

            <para>La distribución Subversion incluye algunos scripts de
              control de acceso ( ubicados en el directorio
              <filename>tools/hook-scripts</filename> del árbol de fuentes
              de Subversion ) a los que se puede llamar desde
              <command>pre-commit</command> para implementar un control de
              de acceso más en detalle. En estos momentos, esta es la
              única manera por la cual los administradores pueden controlar
              el acceso más allá de lo que el fichero <filename>httpd.conf</filename>
              de Apache ofrece. En una versión futura de Subversion, planeamos
              implementar listas de control de acceso (ACLs) directamente en el
              sistema de ficheros.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><filename>post-commit</filename></term>
          <listitem>
            <para>Esto se ejecuta después de que la transacción se haya
              confirmado, y una nueva revisión haya sido creada. La mayoría
              de la gente usa este hook para enviar correos descriptivos
              acerca de la confirmación o para hacer una copia de seguridad
              del repositorio. El repositorio pasa dos argumentos a este
              programa: la ruta al repositorio, y el número de la nueva
              revisión creada. El código de salida del programa es ignorado.</para>
                
            <para>La distribución de Subversion incluye un script
              <command>commit-email.pl</command> ( ubicado en
              el directorio  <filename>tools/hook-scripts/</filename>
              del árbol de fuentes de Subversion ) que puede ser
              usado para enviar correos electrónicos con ( añadiendo
              o no un fichero de log ) una descripción de la confirmación
              hecha. Este correo contiene una lista de las rutas que
              fueron cambiadas, el mensaje de log adjunto a la confirmación,
              el autor y fecha de la confirmación, así como un informe
              en formato de GNU diff de los cambios hechos en los
              ficheros versionados como parte de la confirmación.</para>

            <para>Otra herramienta útil de Subversion es el script
              <command>hot-backup.py</command> ( ubicado en el
              directorio <filename>tools/backup/</filename> del árbol
              de fuentes de Subversion ). Este script realiza copias
              de seguridad en caliente de su repositorio Subversion
              ( una capacidad soportada por el motor de bases de datos
              Berkeley), y puede ser usada para hacer una foto por cada
              confirmación de su repositorio para archivar, o con el objetivo
              de recuperación de emergencia.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><filename>pre-revprop-change</filename></term>
          <listitem>
            <para>Al no ser versionadas las propiedades de revisión de Subversion,
              hacer modificaciones a una de ellas ( como por ejemplo,
        el mensaje de commit <literal>svn:log</literal> )
        sobreescribirá el valor previo de esa propiedad para siempre.
        Como hay datos aquí que potencialmente se pueden perder,
        Subversion provee este hook ( y su contrapartida,        
              <filename>post-revprop-change</filename>) de tal manera
        que los administradores de repositorios puedan mantener
        con métodos externos si así lo desean, registros de los
        cambios de dichas propiedades. Como precaución contra
        la pérdidad de datos de propiedades no versionadas,
        no se permite a los clientes Subversion modificarlos
        del todo remotamente a no ser que este hook se implemente
        para su repositorio.</para>

      <para>Este hook se ejecuta justo antes de que una modificación
        de este tipo se haga en el repositorio. El repositorio pasa
        cuatro argumentos al hook: la ruta al repositorio, la revisión
        en la cual la propiedad que se va a modificar existe,
        el nombre autenticado de usuario de la persona que va a hacer
        el cambio, y el nombre mismo de la propiedad.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><filename>post-revprop-change</filename></term>
          <listitem>
      <para>Como se ha mencionado antes, este hook es la contrapartida
        del hook <filename>pre-revprop-change</filename>. De hecho,
        por paranoia, este script no se ejecutará a no ser que el 
        hook <filename>pre-revprop-change</filename> exista.
        Cuando ambos están presentes, el hook <filename>post-revprop-change</filename>
        se ejecuta justo después de que una propiedad de revisión
        haya sido modificad, y se usa típicamente para enviar un 
        correo electrónico con el nuevo valor de la propiedad
        cambiada. El repositorio pasa cuatro argumentos al hook:
        la ruta al repositorio, la revisión en la cual la propiedad
        existe, el nombre autenticado de usuario de la persona
        que va a hacer el cambio y el nombre mismo de la propiedad.</para>

      <para>La distribución de Subversion incluye el script
        <command>propchange-email.pl</command> script
        (ubicado en el directorio <filename>tools/hook-scripts/</filename>
        del árbol de fuentes de Subversion ) que puede ser usado
        para enviar un correo electrónico con ( y/o añadido a un 
        fichero de log ) los detalles de un cambio en una propiedad
        de revisión. Este correo electrónico contiene la revisión
        y nombre de la propiedad modificada, el usuario que hizo el cambio,
        y el nuevo valor.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Subversión tratará de ejecutar los hooks como el mismo 
        usuario que posee el proces que está accediendo al repositorio
  Subversion. En la mayoría de los casos, el repositorio se 
  accede a través del servidor HTTP Apache y mod_dav_svn, así que
  este usuario es el mismo que el usuario con el que se ejecuta
  Apache. Los mismos hooks necesitarán ser configurados con permisos
  a nivel de sistema operativo que les permitan ser ejecutados
  por dicho usuario. Asimismo, esto significa  que cualquier fichero
  o programas ( incluyendo el repositorio mismo ) al que acceda
  directa o indirectamente el hook, será a través del mismo usuario.
  En otras palabras, esté alerta a problemas potenciales relacionados
  con permisos que impidan al hook realizar las tareas para las cuales
  lo haya escrito.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-2.2">
      <title>Configuración de la Base de Datos Berkeley</title>

      <para>Un entorno de base de datos Berkekely es una encapsulación
        de una o más bases de datos, ficheros de registro, ficheros
        regionales y ficheros de configuración. El entorno de base de datos
        Berkely tiene su propio conjunto de valores de configuración
        por defecto para cosas como el número de bloqueos que se permite eliminar
        de una sóla vez, o el tamaño máximo de los ficheros de registro
	<!--TODO: journaling-->, etc. El código del sistema de ficheros
        de Subversion elige además valores por defecto para algunas
        de las opciones de configuración de la base de datos Berkeley.
	De todas maneras, algunas veces su repositorio particular,
        con su colección única de datos y patrones de acceso, podría
        necesitar un grupo diferente de valores de configuración.</para>

      <para>La gente de Sleepycat ( los progamadores de la base de datos
        Berkeley ) entienden que bases de datos diferentes, tienen
        requerimientos específicos, de tal manera, que nos proveen
        de un mecanismo para sobreescribir en tiempo de ejecución, 
        muchos de los valores de configuración del entorno Berkeley.
        Berkeley comprueba la presencia de un fichero denominado
        <filename>DB_CONFIG</filename> en cada directorio del entorno,
        y <!--TODO: parsers--> las opciones que encuentra en dicho
        fichero para usarlas en ese entorno Berkeley particular.</para>

     <para>El fichero de configuración de Berkeley para su repositorio
        se encuentra en directorio del entorno <filename>db</filename>,
        en <filename>repos/db/DB_CONFIG</filename>. Subversion crea
        por sí mismo el fichero al mismo tiempo que el resto del repositorio.
        El fichero inicialmente contiene algunas opciones por defecto,
        así como enlaces a la documentacion en línea de la BD Berkeley
        de tal manera que pueda saber qué significan dichas opciones.
        Por supuesto, es libre de añadir cualquiera de las opciones soportadas
        por la BD Berkeley a su fichero <filename>DB_CONFIG</filename>.
        Tan sólo tenga cuidado porque mientras Subversion no trata de
        leer o interpretar los contenidos del fichero, y no hace uso
        de sus opciones de configuración, tendrá que evitar cualquier
        cambio en la configuración que pueda causar que la BD Berkeley
        se comporte de una manera inesperada para el resto del código
        de Subversion. Por otra parte, los cambios hechos en
        <filename>DB_CONFIG</filename> no tendrán efecto hasta que
        vuelva a leer en entorno de la base de datos ( usando
        <command>svnadmin recover</command>).</para>
    </sect2>
  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 3:  REPOSITORY MAINTENANCE                          *** -->
  <!-- ******************************************************************* -->

  <sect1 id="svn-ch-5-sect-3">
    <title>Mantenimiento del Repositorio</title>

    <para>El mantenimiento de un repositorio Subversion puede ser una
      tarea que asuste, principalmente debido a las complejidades inherentes
      a sistemas que tienen un motor de base de datos. Para hacer bien
      este trabajo, basta con conocer las herramientas&mdash;qué son y
      cuándo y cómo usarlas. Esta sección le presentará las herramientas
      de administración que provee Subversion, y cómo utilizarlas
      para realizar tareas como migraciones de repositorios, actualizaciones,
      copias de seguridad y limpiezas.</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-3.1">
      <title>Una caja de herramientas del Administrador</title>

      <para>Subversion provee un conjunto de utilidades para crear
        inspecciononar, modificar y reparar sus repositorio.
        Estudiemos más de cerca cada una de estas herramientas.
        Más tarde, examinaremos brevemente otras incluídas en la
        distribución de la BD Berkeley que añaden funcionalidades
        específicas al motor de base de datos de las que no disponen
        las herramientas propias de Subversion.</para>

      <sect3 id="svn-ch-5-sect-3.1.1">
        <title>svnlook</title>
            
        <para><command>svnlook</command> es una herramienta 
          provista por Subversion para examinar las revisiones
          y transacciones realizadas en un repositorio. Este programa
          no intente en ningún momento cambiar el repositorio
          &mdash;es una utilidad de <quote>sólo lectura</quote>.
          <command>svnlook</command> es utilizada normalmente por
          los <!--TODO-->hooks del repositorio para informar acerca
          de los cambios que se van a realizar ( en el caso del
          hook <command>pre-commit</command> ) o que se acaban de
          hacer ( en el caso del hook <command>post-commit</command> )
          en el repositorio. Un administrador del repositorio puede
          usar esta herramienta para diagnosis.</para>
           
        <para><command>svnlook</command> tiene una sintáxis muy simple:</para>
            
        <screen>
$ svnlook help
uso general. svnlook SUBCOMANDO RUTA_REPOS [PARAMS y OPCIONES ...]
Nota: todo subcomando que tome los parámetros '--revision' y '--transaction'
      actuará, si se lo invoca sin una de estas opciones, sobre la versión
      más reciente del repositorio.
Escriba "svn help &lt;subcomando&gt;" para ayuda en un subcomando específico.
&hellip;
</screen>

        <para>Casi cada uno de los subcomandos de <command>svnlook</command>
          puede trabajar sobre una revisión o una transacción,
          imprimiendo información acerca del propio árbol, o de
          sus diferencias con respecto a la revisión anterior del
          repositorio. Usará la opciones <option>--revision</option>
          y <option>--transaction</option> para especificar qué
          revisión o transacción examinar respectivamente. Nótese
          que mientras los números de revisión se ven como números
          naturales, los nombres de transacción son cadenas alfanuméricas.
          Recuerde que el sistema de ficheros sólo permite navegar entre
          transacciones no confirmadas ( transacción que no han tenido
          como resultado una nueva revisión ). La mayoría de los repositorios
          no tendrán ese tipo de transacciones, porque las transacciones
          normalmente son confirmadas ( lo que evita que puedan ser
          examinadas ) o paradas y borradas.</para>

        <para>En ausencia de las opciones <option>--revision</option>
          y <option>--transaction</option>, <command>svnlook</command>
          examinará la última revisión ( o <quote>HEAD</quote> ) del 
          repositorio. Así que las siguientes órdenes hacen exactamente
          lo mismo cuando 19 es la última revisión del repositorio
          ubicado en <filename>/path/to/repos</filename>:</para>


        <screen>
$ svnlook info /path/to/repos
$ svnlook info /path/to/repos --revision 19
</screen>

        <para>La única excepción a estas reglas es el subcomando
          <command>svnlook youngest</command>, que no recibe opciones,
          y que simplemente escribe el número de revisión de <literal>HEAD</literal>.</para>

        <screen>
$ svnlook youngest /path/to/repos
19
</screen>
            
        <para>La salida de <command>svnlook</command> está diseñanda para que
          sea, a la vez, legible por humanos y por máquinas. Cojamos como ejemplo
          la salida del subcomando <literal>info</literal>:</para>

        <screen>
$ svnlook info /path/to/repos
sally
2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)
27
Added the usual
Greek tree.
</screen>

        <para>La salida del subcomando <literal>info</literal> está definida como:</para>

	<orderedlist>
          <listitem>
            <para>El autor, seguido por un salto de línea.</para>
          </listitem>
          <listitem>
            <para>La fecha, seguida por un salto de línea.</para>
          </listitem>
          <listitem>
            <para>El número de caracteres en el mensaje de registro,
	      seguido por un salto de línea.</para>
          </listitem>
          <listitem>
            <para>El mensaje de registro, seguido por un salto de línea.</para>
          </listitem>
        </orderedlist>

        <para>Esta salida es legible para humanos, elementos como la
          fecha, se presentan usando una representación de texto
          en lugar de algo más oscuro ( como el número de nanosegundos
          desde que <!--TODO Tasty Freeze guy drove by-->). Pero
          esta salida es también legible por la máquina&mdash;debido a que 
          el registro del mensaje puede contener muchas líneas y no tener
          un límite de tamaño, <command>svnlook</command> informa del 
          tamaño del mensaje antes que el mismo mensaje. Esto permite a los
          <!--TODO scripts--> y otros <!--TODO wrappers--> alrededor de este
          comando, tomar decisiones inteligentes acerca del mensaje de registro,
          como cuánta memoria reserverle, o al menos, cuántos bytes saltarse
          en el evento para que esta salida no sea el último bit de datos en 
          el flujo.</para>

        <para>Otro uso común de <command>svnlook</command> es ver
          realmente los contenidos de un árbol de revisión o de
          transacción. El comando <command>svnlook tree</command>
          presenta los directorios y fichero del árbol solicitado.
          Si añade la opción <option>--show-ids</option>, también 
          enseñará los identificadores de nodos del sistema de ficheros
          de la revisión para cada una de las rutas (que, en general, es más
          útil para los desarrolladores que para los usuarios).</para>
	  
        <screen>
$ svnlook tree /path/to/repos --show-ids
/ &lt;0.0.1&gt;
 A/ &lt;2.0.1&gt;
  B/ &lt;4.0.1&gt;
   lambda &lt;5.0.1&gt;
   E/ &lt;6.0.1&gt;
    alpha &lt;7.0.1&gt;
    beta &lt;8.0.1&gt;
   F/ &lt;9.0.1&gt;
  mu &lt;3.0.1&gt;
  C/ &lt;a.0.1&gt;
  D/ &lt;b.0.1&gt;
   gamma &lt;c.0.1&gt;
   G/ &lt;d.0.1&gt;
    pi &lt;e.0.1&gt;
    rho &lt;f.0.1&gt;
    tau &lt;g.0.1&gt;
   H/ &lt;h.0.1&gt;
    chi &lt;i.0.1&gt;
    omega &lt;k.0.1&gt;
    psi &lt;j.0.1&gt;
 iota &lt;1.0.1&gt;
</screen>

        <para>Una vez que haya visto el esquema de los ficheros y directorios
          de su árbol, podrá usar comandos como <command>svnlook cat</command>,
          <command>svnlook propget</command>, y <command>svnlook proplist</command>
          para profundizar en los detalles dichos elementos.</para>

        <para><command>svnlook</command> puede realizar otros tipos de
          consultas, presentando los subgrupos de información que mencionamos
          antes, informando acerca de qué rutas fueron modificadas en una
          revisión o transacción especificada, mostrando las modificaciones
          de textos o propiedades realizadas, etc ... A continuación
          hay una breve descripción de la actual lista de subcomandos
          aceptados por <command>svnlook</command>, y la salida de los mismos:</para>

        <variablelist>
          <varlistentry>
            <term><literal>author</literal></term>
            <listitem>
              <para>Dice el autor del árbol.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>cat</literal></term>
            <listitem>
              <para>Vuelca los contenidos de un fichero en el árbol.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>changed</literal></term>
            <listitem>
              <para>Da una lista de todos los ficheros y directorios que han sido
                modificados en el árbol.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>date</literal></term>
            <listitem>
              <para>Dice la fecha del árbol.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>diff</literal></term>
            <listitem>
              <para>Vuelca <!--TODO unified diffs --> de ficheros modificados.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>dirs-changed</literal></term>
            <listitem>
              <para>Lista los directorios del árbol que han sido
                modificados, o aquellos en los que alguno de sus ficheros
                han sido modificados.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>history</literal></term>
            <listitem>
              <para>Presenta puntos interesantes en la historia de
                una ruta versionada ( lugares donde ha habido modificaciones
                o copias ).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>info</literal></term>
            <listitem>
              <para>Vuelca el autor, la fecha, el número de caracteres
                del mensaje de registro, y el mensaje de registro.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>log</literal></term>
            <listitem>
              <para>Dice el mensaje de registro del árbol.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>propget</literal></term>
            <listitem>
              <para>Dice el valor de una propiedad de una ruta en el árbol.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>proplist</literal></term>
            <listitem>
              <para>Vuelca los nombres y valores de las propiedades de rutas
                en el árbol.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>tree</literal></term>
            <listitem>
              <para>Vuelca el listado del árbol, revelando opcionalmente
                el identificador de la revisión de nodo de sistema de ficheros
                asociado a cada ruta.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>uuid</literal></term>
            <listitem>
              <para>Dice el identificador único de usuario del árbol.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>youngest</literal></term>
            <listitem>
              <para>Dice el último número de revisión.</para>
            </listitem>
          </varlistentry>
        </variablelist>

      </sect3>

      <sect3 id="svn-ch-5-sect-3.1.2">
        <title>svnadmin</title>

        <para>El programa <command>svnadmin</command> es el mejor amigo
          del administror del repositorio. Además de darle la posibilidad
          de crear repositorios Subversion, le permite realizar
          varias operaciones de mantenimiento en ellos. La sintaxis
          de  <command>svnadmin</command> es parecida a la de
          <command>svnlook</command>:</para>

        <screen>
$ svnadmin help
uso general: svnadmin SUBCOMANDO RUTA_REPOS  [PARAMS y OPCIONES ...]
Escriba "svnadmin help &lt;subcomando&gt;" para ayuda sobre un subcomando.

Subcomandos disponibles:
   create
   deltify
   dump
   help (?, h)
&hellip;
</screen>

        <para>Ya hemos mencionado antes el subcomando <literal>create</literal>
          de <command>svnadmin</command> ( ver <xref linkend="svn-ch-5-sect-2"/>).
          La mayoría de los demás subcomandos los veremos más adelante en 
          en este capítulo. De momento, veamos por encima lo que cada uno de
          ellos nos ofrece.</para>

        <variablelist>
          <varlistentry>
            <term><literal>create</literal></term>
            <listitem>
              <para>Crear un nuevo repositorio Subversion.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>deltify</literal></term>
            <listitem>
              <para>Run over a specified revision range, performing
                predecessor deltification on the paths changed in
                those revisions.  If no revisions are specified, this
                command will simply deltify the
                <literal>HEAD</literal> revision.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>dump</literal></term>
            <listitem>
              <para>Vuelca los contenidos del repositorio, agrupados por
                por un conjunto dado de revisiones, usando un formato portable
                de volcado.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>hotcopy</literal></term>
            <listitem>
              <para>Hace una copia en caliente de un repositorio. Puede
                ejecutar esta comando en cualquier momento, y hacer una copia
                segura del repositorio sin que se vea afectada por el hecho
                de que otros procesos estén accediendo al repositorio.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>list-dblogs</literal></term>
            <listitem>
              <para>Lista las rutas a los ficheros de registro
                de la BD Berkeley asociados al repositorio. Esta lista
                incluye todos los ficheros de registros&mdash;aquellos que
                están todavía en uso por Subversion, así como los que no
                lo están.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>list-unused-dblogs</literal></term>
            <listitem>
              <para>Lista las rutas de los ficheros de registro
                de la BD Berkeley asociados al repositrio, pero que han
                dejado de usarse. Puede borrar de forma segura estos ficheros
                del entorno del repositorio y archivarlos para el caso de tener
                que hacer una recuperación de algún evento catastrófico del repositorio.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>load</literal></term>
            <listitem>
              <para>Carga un grupo de revisiones en un repositorio
                desde un fluno de datos que utilice el mismo formato
                portable de información que el generado por el subcomando
                <literal>dump</literal>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>lstxns</literal></term>
            <listitem>
              <para>Lista los nombres de las transacciones Subversion
                no confirmadas que existen actualmente en el repositorio.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>recover</literal></term>
            <listitem>
              <para>Realiza tareas de recuperación en un repositorio
                que lo necesite, generalmente tras un error fatal
                que haya impedido a un proceso cerrar limpiamente
                su comunicación con el repositorio.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>rmtxns</literal></term>
            <listitem>
              <para>Borra limpiamente del repositorio transacciones
                Subversion ( convenientemente nutrido por la salida
                del subcomando <literal>lstxns</literal>).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>setlog</literal></term>
            <listitem>
              <para>Sustituye el valor actual de la propiedad
                <literal>svn:log</literal> ( mensaje de confirmación )
                de una transacción en particular en el repositorio
                con un nuevo valor.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>verify</literal></term>
            <listitem>
              <para>Verificar los contenidos del repositorio. Esto incluye,
                entre otras cosas, comparaciones de firmas de los datos
                versionados almacenados en el repositorio.</para>
            </listitem>
          </varlistentry>
        </variablelist>

      </sect3>

      <sect3 id="svn-ch-5-sect-3.1.3">
        <title>svndumpfilter</title>

        <para>Debido a que Subversion almacena toda la información en un
          sistema de bases de datos opaco, intentar hacer cambios a mano
          no es nada recomendable, además de ser bastante complicado.
          Además, una vez que la información ha sido guardada en su
          repositorio, Subversion, en general, no tiene ninguna manera
          cómoda de borrarla.
          <footnote>
            <para>Esto, de todas maneras, es una <emphasis>característica</emphasis>,
              y no un error.</para>
          </footnote>
          Inevitablemente, habrá veces que querrá manipular el histórico de
          su repositorio. Podría necesitar eliminar todas la versiones
          de un fichero que se añadió accidentalmente ( y que no debería estar
          ahí por alguna razón). O quizás tiene varios proyectos compartiendo
          el mismo repositorio, y ha decidido separarlos cada uno en su propio
          repositorio. Para realizar este tipo de tareas, los administradores necesitan
          una representación de los datos más manejable&mdash;el formato
          de volcado.</para>

        <para>El formato de volcado del repositorio Subversion es
          una representación legible por humanos de los cambios
          hechos a tus datos versionados a lo largo del tiempo.
          Utiliza el comando <command>svnadmin dump</command>
          para generar el volcado, y <command>svnadmin load</command>
          para poblar un nuevo repositorio con ellos ( ver <xref linkend="svn-ch-5-sect-3.5"/>).
          Lo mejor del hecho de que el formato sea legible es que,
          si no te asusta, puedes revisarlo y modificarlo manualmente.
          Por supuesto, lo pero que es si tienes dos años de trabajo
          en un repositorio encapsulado en lo que se supone que será
          un fichero de volcado muy grande, llevará mucho, mucho tiempo
          el revisarlo y modificarlo.</para>

        <para>A pesar de que no será la herramienta más usada a disposición
          del administrador, <command>svndumpfilter</command> tiene un producto
          muy peculiar con una funcionalidad muy útil&mdash;la posibilidad de 
          modificar rápida y fácilmente esos datos de volcado actuando como un 
          filtro basado en las rutas. Simplemente, di una lista de rutas que 
          quieres mantener, o una lista de rutas que no quieres mantener, luego,
          dirige tu volcado a través de este filtro. El resultado será un volcado
          modificado que contendrá sólo las rutas versionadas que ( explícita
          o implícitamente ) pediste.</para>

        <para>La sintaxis de <command>svndumpfilter</command> es así:</para>

        <screen>
$ svndumpfilter help
uso general: svndumpfilter SUBCOMANDO [ARGS &amp; OPCIONES ...]
Escriba "svndumpfilter help &lt;subcommand&gt;" para obtener información sobre un subcomando específico.

Subcomandos disponibles:
   exclude
   include
   help (?, h)
</screen>

        <para>Hay sólo dos subcomandos interesantes. Te permiten
          elegir entre una inclusión explícita o implícita de rutas
          en el flujo de información:</para>

        <variablelist>
          <varlistentry>
            <term><literal>exclude</literal></term>
            <listitem>
              <para>Excluye del flujo de datos del volcado a un grupo de rutas.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>include</literal></term>
            <listitem>
              <para>Permite sólo al grupo de rutas solicitado, pasar al
                flujo de datos del volcado.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Veamos un ejemplo realista acerca de qué uso le podría dar
          a este programa. Más tarde hablaremos ( ver
          <xref linkend="svn-ch-5-sect-6.1"/>) del proceso de decisión
          del modelo de datos para su repositorio&mdash;un repositorio por
          proyecto o combinándolos, organizar todo el material dentro de su
          repositorio. A veces, después de que las nuevas revisiones
          comienzan a volar, te vuelves a pensar el modelo, y querrías hacer
          algunos cambios. Un cambiio común es la decisión de mover proyectos
          que están compartiendo un sólo repositorio en un repositorio separado
          para cada proyecto.</para>

        <para>Nuestro repositorio imaginario contiene tres proyectos:
          <literal>calc</literal>, <literal>calendar</literal>, y
          <literal>spreadsheet</literal>. Han estado en una modelo
          como este:</para>

        <screen>
/
   calc/
      trunk/
      branches/
      tags/
   calendar/
      trunk/
      branches/
      tags/
   spreadsheet/
      trunk/
      branches/
      tags/
</screen>

        <para>Para meter cada uno de estos tres proyectos en su
          repositorio respectivo, debemos primero hacer un fichero
          de volcado del repositorio completo:</para>

        <screen>
$ svnadmin dump /path/to/repos &gt; repos-dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
* Dumped revision 3.
&hellip;
$
</screen>

        <para>Luego, pasar ese fichero de volcado a través del filtro,
          incluyendo cada vez, sólo uno de los directorios superiores,
          dando como resultado tres nuevos ficheros de volcado:</para>

        <screen>
$ cat repos-dumpfile | svndumpfilter include calc &gt; calc-dumpfile
&hellip;
$ cat repos-dumpfile | svndumpfilter include calendar &gt; cal-dumpfile
&hellip;
$ cat repos-dumpfile | svndumpfilter include spreadsheet &gt; ss-dumpfile
&hellip;
$
</screen>

        <para>En este momento, debe tomar una decisión. Cada uno de
          sus ficheros de volcado creará un repositorio válido,
          pero mantendrá las rutas exactamente como estaban en el 
          repositorio original. Esto significa que aunque tenga un 
          repositorio exclusivamente para su proyecto <literal>calc</literal>,
          dicho repositorio tendrá todavía un directorio superior
          llamado <filename>calc</filename>. Si quiere que los directorios
          <filename>trunk</filename>, <filename>tags</filename>,
          y <filename>branches</filename> estén en la raíz del repositorio,
          necesitará editar los ficheros de volcado, cambiando las cabeceras
          <literal>Node-path</literal> y <literal>Copyfrom-path</literal>
          para conseguir que esa primera ruta <filename>calc/</filename>
          no aparezca; además, deberá borrar la sección del volcado
          que crea el directorio <filename>calc</filename>. Será algo como:</para>

        <screen>
Node-path: calc
Node-action: add
Node-kind: dir
Content-length: 0

</screen>

        <para>Todo lo que queda por hacer ahora es crear sus 
          tres nuevos repositorios, y cargar cada fichero de volcado
          en el repositorio correcto:</para>

        <screen>
$ svnadmin create calc; svnadmin load calc &lt; calc-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : button.c ... done.
&hellip;
$ svnadmin create calendar; svnadmin load calendar &lt; cal-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : cal.c ... done.
&hellip;
$ svnadmin create spreadsheet; svnadmin load spreadsheet &lt; ss-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : ss.c ... done.
&hellip;
$
</screen>

        <para>Ambos subcomandos de <command>svndumpfilter</command>
          aceptan opciones para decidir cómo tratar las revisiones
	  <quote>vacías</quote>. Si una revisión dada sólo contenía
          cambios a rutas que fueron excluídas al filtrarlas, podría
          ser considerada como no interesante o incluso ignorada.
          Así que, para darle al usuario el control sobre qué hacer con
          esas revisiones, <command>svndumpfilter</command> tiene las
          siguientes opciones:</para>

        <variablelist>
          <varlistentry>
            <term><option>--drop-empty-revs</option></term>
            <listitem>
              <para>No generar ninguna revisión vacía&mdash; tan sólo ignorarlas.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--renumber-revs</option></term>
            <listitem>
              <para>Si las revisiones vacías son descartadas ( usando
                la opción <option>--drop-empty-revs</option>), cambiar
                los números de revisión de las restantes de tal manera
                que no haya huecos en la secuencia numérica.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--preserve-revprops</option></term>
            <listitem>
              <para>Si las revisiones vacías no son descartadas, preservar
                las propiedades de revisión ( mensaje de registro, autor,
                fecha, propiedades personalizadas, etc ... ) de dichas
                revisiones vacías.
                Por otra parte, las revisiones vacías sólo contendrán
                la marca de tiempo original, y un mensaje de registro generado
                indicando que esta revisión fue vaciada por <command>svndumpfilter</command>.</para>
            </listitem>
          </varlistentry>
        </variablelist>
        
        <para>Mientras <command>svndumpfilter</command> puede ser muy útil,
          y un gran ahorrador de tiempo, desafortunadamente hay un par de
          problemas. Primero, esta utilidad es <!--TODO overly to path semantics.-->.
          Preste atención a si las rutas en su fichero de volcado se
          especifican con o sin barras al principio. Necesitará mirar
          las cabeceras <literal>Node-path</literal> y <literal>Copyfrom-path</literal>.</para>

        <screen>
&hellip;
Node-path: spreadsheet/Makefile
&hellip;
</screen>

        <para>Si las rutas tienen barras al principio, deberá
          incluir barras al principio en las rutas que quiera
          pasar a <command>svndumpfilter include</command> y
          <command>svndumpfilter exclude</command> ( si no las tienen,
          no debería incluirlas). Además, si su fichero de volcado
          tiene un uso inconsistente de estas barras por alguna razón,
          <footnote>
            <para>Mientras <command>svnadmin dump</command> tiene una
              política consistente de barras&mdash;no incluirlas&mdash;
              otros programas que generan datos de volcado puede no ser
              tan consistentes.</para>
          </footnote>
          probablemente debería normalizar esas rutas de tal manera que
          todas ellas tengan, o no tengan, barras al principio.</para>

        <para>También las rutas copiadas pueden darle algunos problemas.
          Subversion soporta operaciones de copia en el repositorio, donde
          una nueva ruta se crea copiando otra ruta ya existente.
          Es posible que en algún momento de la vida de su repositorio, 
          vd. haya copiado un fichero o un directorio desde alguna ubicación
          que <command>svndumpfilter</command> esté excluyendo a alguna otra 
          que se esté incluyendo. Para conseguir que los datos volcados
          sean autosuficientes, <command>svndumpfilter</command> todavía
          necesita enseñar la adición de la nueva ruta&mdash;incluyento los
          contenidos de los ficheros creados por la copia&mdash;y no representar
          dicha adición como una copia de una fuente que no existirá
          en el flujo filtrado de los datos de volcado. Pero debido a que
          el formato de volcado de repositorios Subversion sólo presenta
          lo modificado en cada revisión, los contenidos del origen de la copia
          podrían no estar disponibles para su lectura. Si sospechase que
          tiene alguna copia de este tipo en su repositorio, deberá repensar
          su grupo de rutas incluyentes y/o excluyentes.</para>
      </sect3>

      <sect3 id="svn-ch-5-sect-3.1.4">
        <title>svnshell.py</title>

        <para>El árbol de código fuente de Subversion también
          trae una interfaz al repositorio tipo línea de comando. El
          script en Python <command>svnshell.py</command> (ubicado
          en <filename>tools/examples/</filename> en el árbol de
          fuentes) usa las interfaces de lenguaje de Subversion (así
          que debe tenerlas correctamente compiladas e instaladas
          para que este script funcione) para conectar al repositorio
          y las librerías de sistema de ficheros.</para>

        <para>Una vez iniciado, el programa se comporta de manera
          similar a una línea de comando, permitiéndole navegar a
          través de los directorios de su repositorio. Inicialmente
          se le <quote>posiciona</quote> en el directorio raíz de
          la revisión <literal>HEAD</literal> del repositorio, y
          se le muestra la línea de comando. Puede usar el comando
          <literal>help</literal> en cualquier momento para leer un
          listado de los comandos disponibles y su propósito.</para>

        <screen>
$ svnshell.py /path/to/repos
&lt;rev: 2 /&gt;$  help
Available commands:
  cat FILE     : dump the contents of FILE
  cd DIR       : change the current working directory to DIR
  exit         : exit the shell
  ls [PATH]    : list the contents of the current directory
  lstxns       : list the transactions available for browsing
  setrev REV   : set the current revision to browse
  settxn TXN   : set the current transaction to browse
  youngest     : list the youngest browsable revision number
&lt;rev: 2 /&gt;$
</screen>

        <para>Puede navegar por la estructura de directorios de su
          repositorio del mimo modo que lo haría con la línea
          de comando de Unix o Windows&mdash;usando el comando
          <literal>cd</literal>. En todo momento la línea
          de comando le mostrará qué revisión (prefijada por
          <literal>rev:</literal>) o transacción (prefijada por
          <literal>txn:</literal>) está examinando, y la ruta
          dentro de esa revisión o transacción.  Puede cambiar
          la revisión o transacción actual con los comandos
          <literal>setrev</literal> y <literal>settxn</literal>
          respectivamente.  Al igual que en una línea de comando
          de Unix, puede usar el comando <literal>ls</literal>
          para mostrar el contenido del directorio actual, y puede
          usar el comando <literal>cat</literal> para mostrar el
          contenido de un fichero.</para>

        <example id="svn-ch-8-sect-3.1.3-ex-1">
          <title>Usando svnshell para navegar por el repositorio</title>

          <screen>
&lt;rev: 2 /&gt;$ ls
   REV   AUTHOR  NODE-REV-ID     SIZE         DATE NAME
----------------------------------------------------------------------------
     1    sally &lt;     2.0.1&gt;          Nov 15 11:50 A/
     2    harry &lt;     1.0.2&gt;       56 Nov 19 08:19 iota
&lt;rev: 2 /&gt;$ cd A
&lt;rev: 2 /A&gt;$ ls
   REV   AUTHOR  NODE-REV-ID     SIZE         DATE NAME
----------------------------------------------------------------------------
     1    sally &lt;     4.0.1&gt;          Nov 15 11:50 B/
     1    sally &lt;     a.0.1&gt;          Nov 15 11:50 C/
     1    sally &lt;     b.0.1&gt;          Nov 15 11:50 D/
     1    sally &lt;     3.0.1&gt;       23 Nov 15 11:50 mu
&lt;rev: 2 /A&gt;$ cd D/G 
&lt;rev: 2 /A/D/G&gt;$ ls
   REV   AUTHOR  NODE-REV-ID     SIZE         DATE NAME
----------------------------------------------------------------------------
     1    sally &lt;     e.0.1&gt;       23 Nov 15 11:50 pi
     1    sally &lt;     f.0.1&gt;       24 Nov 15 11:50 rho
     1    sally &lt;     g.0.1&gt;       24 Nov 15 11:50 tau
&lt;rev: 2 /A&gt;$ cd ../..
&lt;rev: 2 /&gt;$ cat iota
This is the file 'iota'.
Added this text in revision 2.

&lt;rev: 2 /&gt;$ setrev 1; cat iota
This is the file 'iota'.

&lt;rev: 1 /&gt;$ exit
$
</screen>
        </example>

        <para>Como puede ver en el ejemplo anterior, puede indicar
          múltiples comandos en una única línea separados por
          puntos y comas. Además, la línea de comando entiende los
          conceptos de rutas relativas y absolutas, y entenderá
          los componentes de ruta especiales <literal>.</literal>
          y <literal>..</literal>.</para>

        <para>El comando <literal>youngest</literal> muestra la
          versión más joven.  Lo cual es útil para determinar el
          rango válido de revisiones que puede usar como argumentos
          del comando <literal>setrev</literal>&mdash;se le permite
          navegar por todas las revisiones (le recordamos que son
          nombradas por números) entre 0 y la más joven inclusive.
          Determinar la transacción navegable válida no es
          tan bonito. Use el comando <command>lstxns</command>
          para obtener un listado de las transacciones que puede
          consultar. El listado de las transacciones navegables es
          el mismo listado que el devuelto por <command>svnadmin
          lstxns</command> y el mismo listado que es válido para
          ser usado con la opción <option>--transaction</option>
          de <command>svnlook</command>.</para>

        <para>Una vez haya acabado de usar la línea de comando, puede
          salir de manera límpia usando el comando
          <command>exit</command>. Alternativamente, puede mandar un
          carácter de fin de línea&mdash;Control-D (aunque algunas
          distribuciones de Python para Win32 usan en su lugar la
          convención de Windows de Control-Z).</para>

      </sect3>

      <sect3 id="svn-ch-5-sect-3.1.5">
        <title>Utilidades de la BD Berkeley</title>

        <para>Toda la estructura y datos versionados de su sistema
          de ficheros viven en un conjunto de tablas de la
          base de datos Berkeley dentro del subdirectorio
          <filename>db</filename> de su repositorio.  Este
          subdirectorio es un directorio de entorno de base
          de datos Berkeley habitual, y por lo tanto puede
          ser usado con cualquiera de las herramientas de la
          base de datos Berkeley (puede ver su documentación
          en la página web de SleepyCat, <systemitem
          class="url">http://www.sleepycat.com/</systemitem>).</para>

        <para>Para un uso diario de Subversion, estas herramientas
          son innecesarias.  La mayor parte de la funcionalidad
          típicamente requerida por los repositorios
          Subversion ha sido duplicada en la herramienta
          <command>svnadmin</command>. Por ejemplo, <command>svnadmin
          list-unused-dblogs</command> y <command>svnadmin
          list-dblogs</command> realizan un conjunto de lo que
          proporciona el comando <command>db_archive</command>
          de Berkeley, y <command>svnadmin recover</command>
          engloba los casos de uso habituales de la utilidad
          <command>db_recover</command>.</para>
            
        <para>Aunque todavía hay algunas herramientas de la BD de
          Berkeley que puede encontrar útiles. Los programas
          <command>db_dump</command> y <command>db_load</command>
          escriben y leen, respectivamente, un fichero de
          formato propio que describe las claves y valores
          de la base de datos Berkeley. Dado que las bases de
          datos Berkeley no son portables entre arquitecturas
          diferentes, este formato es útil para transferir las
          bases de datos de una máquina a otra, sin importar su
          arquitectura o sistema operativo. Además, la utilidad
          <command>db_stat</command> proporciona información útil
          sobre el estado de su entorno de base de datos Berkeley,
          incluyendo estadísticas detalladas sobre los bloqueos y
          subsistemas de almacenamiento.</para>

      </sect3>
    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-3.2">
      <title>Limpieza del repositorio</title>
            
      <para>En general su repositorio Subversion requerirá poca
        atención una vez lo haya configurado a su gusto. No
        obstante, hay ocasiones en las que podría necesitar la
        asistencia manual de un administrador. La utilidad
        <command>svnadmin</command> proporciona algunas
        funcionalidades provechosas para realizar tareas como</para>

      <itemizedlist>
        <listitem>
          <para>modificar mensajes de informes de cambios,</para>
        </listitem>
        <listitem>
          <para>eliminar transacciones muertas,</para>
        </listitem>
        <listitem>
          <para>recuperar repositorios <quote>tocados</quote><!--
            traducción libre de wedged -->, y</para>
        </listitem>
        <listitem>
          <para>migrar el contenido de un repositorio a otro.</para>
        </listitem>
      </itemizedlist>

      <para>Quizás el subcomando de <command>svnadmin</command>
        más usado sea <literal>setlog</literal>. Cuando una
        transacción es guardada en el repositorio y ascendida a
        categoría de revisión, el mensaje del informe de cambios
        asociado con esa nueva revisión (y proporcionado por el
        usuario) se almacena como una propiedad no versionada adjunta
        a la propia revisión. En otras palabras, el repositorio
        sólo recuerda el último valor de la propiedad, y descarta
        valores anteriores.</para>

      <para>A veces el usuario cometerá errores (ortográficos o
        quizás información equivocada) en sus informes de
        cambios. Si configura el repositorio (usando los
        ganchos <literal>pre-revprop-change</literal>
        y <literal>post-revprop-change</literal>; vea
        <xref linkend="svn-ch-5-sect-2.1"/>) para permitir
        modificaciones sobre el mensaje de informe de cambios
        de revisiones existentes, entonces el usuario puede
        <quote>corregir</quote> su informe remotamente usando
        el comando <literal>propset</literal> del programa
        <command>svn</command> (vea <xref linkend="svn-ch-9"/>).
        No obstante, debido al peligro potencial de perder
        información para siempre, los repositorios Subversion se
        configuran por defecto para impedir cambios a propiedades
        no versionadas&mdash;excepto para el administrador.</para>

      <para>Si un informe de cambios necesita ser cambiado por un
        administrador, puede ejecutar <command>svnadmin
        setlog</command>.  Éste comando modifica el mensaje de
        informe de cambios (la propiedad <literal>svn:log</literal>)
        de una revisión concreta de un repositorio, leyendo el
        nuevo valor del fichero proporcionado.</para>

      <screen>
$ echo "Here is the new, correct log message" &gt; newlog.txt
$ svnadmin setlog myrepos newlog.txt -r 388
</screen>
      
      <para>El comando <command>svnadmin setlog</command> a secas
        sigue estando limitado por las mismas protecciones que
        impiden a los usuarios remotos modificar propiedades no
        versionadas&mdash;los ganchos <literal>pre-</literal> y
        <literal>post-revprop-change</literal> siguen ejecutándose,
        y por lo tanto debe configurar el repositorio para permitir
        cambios de esta naturaleza.  Pero un administrador
        puede saltarse estas protecciones pasando el parámetro
        <option>--bypass-hooks</option> al comando <command>svnadmin
        setlog</command>.</para>
 
      <warning>
        <para>Recuerde, no obstante, que al ignorar los ganchos,
          probablemente esté evitando acciones como notificaciones
          automáticas por correo informando de cambios a propiedades,
          sistemas de copias de seguridad que siguen los cambios de
          propiedades sin versionar, etc, etc. En otras palabras,
          sea muy cuidadoso con lo que vaya a cambiar, y cómo lo
          cambia.</para>
       </warning>

      <para>Otro uso habitual de <command>svnadmin</command> es
        comprobar que en el repositorio no hay transacciones
        pendientes&mdash;posiblemente muertas. En el caso de que
        una transacción falle, ésta normalmente se anula.  Es decir,
        la propia transacción y cualquier dato asociado con ella (y
        sólo con ella) es eliminada del repositorio.  No obstante,
        ocasionalmente ocurre un fallo de tal modo que la limpieza
        de la transacción no se llega a realizar nunca. Esto podría
        pasar por varias razones: quizás la operación del cliente
        fue terminada de manera poco elegante por el usuario,
        quizás ocurrió un fallo de red durante la operación, etc.
        En cualquier caso, estas transacciones muertas sólo molestan
        en el repositorio y consumen recursos.</para>

      <para>Puede usar el comando <literal>lstxns</literal> de
        <command>svnadmin</command>'s para obtener un listado de los
        nombres de las transacciones actuales de relevancia.</para>

      <screen>
$ svnadmin lstxns myrepos
19
3a1
a45
$
</screen>

      <para>Cada elemento del listado mostrado puede ser usado con
        <command>svnlook</command> (y su opción
        <option>--transaction</option>) para determinar quién creó
        la transacción, cuándo fue creada, qué tipos de cambios
        fueron realizados en la transacción&mdash;en otras palabras,
        si la transacción es o nó una candidata segura para ser
        eliminada. En caso de serlo, el nombre de la transacción
        puede ser usado con <command>svnadmin rmtxns</command>,
        que realizará la limpieza de la transacción. ¡De hecho, el
        subcomando <literal>rmtxns</literal> puede usar directamente
        como entrada la salida de <literal>lstxns</literal>!</para>

      <screen>
$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`
$
</screen>

      <para>Si usa estos subcomandos de éste modo, debería considerar
        desactivar temporalmente el acceso al repositorio por parte
        de sus clientes. Así, nadie podrá comenzar una transacción
        legítima antes de que comience con la limpieza. Lo que
        viene a continuación es un poco de shell-scripting que puede
        generar rápidamente la información sobre cada transacción
        pendiente de su repositorio:</para>

      <example id="svn-ch-5-sect-3.2-ex-1">
        <title>txn-info.sh (Informe de transacciones pendientes)</title>

        <programlisting>
#!/bin/sh

### Generate informational output for all outstanding transactions in
### a Subversion repository.

SVNADMIN=/usr/local/bin/svnadmin
SVNLOOK=/usr/local/bin/svnlook

REPOS="${1}"
if [ "x$REPOS" = x ] ; then
  echo "usage: $0 REPOS_PATH"
  exit
fi

for TXN in `${SVNADMIN} lstxns ${REPOS}`; do 
  echo "---[ Transaction ${TXN} ]-------------------------------------------"
  ${SVNLOOK} info "${REPOS}" --transaction "${TXN}"
done
</programlisting>
      </example>

      <para>Puede ejecutar el script anterior usando
        <command>/ruta/a/txn-info.sh /ruta/al/repositorio</command>.
        La salida es básicamente la concatenación de varios bloques
        de salida de <command>svnlook info</command> (vea <xref
        linkend="svn-ch-5-sect-3.1.1"/>), y tendrá el siguiente
        aspecto:</para>

      <screen>
$ txn-info.sh myrepos
---[ Transaction 19 ]-------------------------------------------
sally
2001-09-04 11:57:19 -0500 (Tue, 04 Sep 2001)
0
---[ Transaction 3a1 ]-------------------------------------------
harry
2001-09-10 16:50:30 -0500 (Mon, 10 Sep 2001)
39
Trying to commit over a faulty network.
---[ Transaction a45 ]-------------------------------------------
sally
2001-09-12 11:09:28 -0500 (Wed, 12 Sep 2001)
0
$
</screen>

      <para>Habitualmente, si descubre una transacción muerta que
        no tiene adjunto un informe de cambios, se trata del
        resultado de una operación fallida de actualización (o de
        estilo similar). Estas operaciones usan transacciones de
        Subversion internamente para emular el estado de una copia
        de trabajo local. Dado que éstas transacciones no tienen
        como propósito ser almacenadas, Subversion no requiere que
        tengan un mensaje de informe de cambios. Las transacciones
        que tienen informes de cambios son casi con total seguridad
        algún tipo de operación de almacenamiento fallida. Además,
        la fecha de una transacción puede proporcionar información
        interesante&mdash;por ejemplo, ¿qué probabilidades hay de
        que una operación que comenzase hace nueve meses todavía
        esté activa?</para>

      <para>En resumen, no debe tomar a la ligera las decisión de
        limpieza de transacciones. Puede emplear varias fuentes
        de información&mdash;incluyendo los registros de acceso y
        errores de Apache, los registros de transacciones Subversion
        completadas con éxito, etc&mdash; durante la toma de
        decisiones. Finalmente, un administrador siempre puede
        comunicarse con el autor de una transacción aparentemente
        muerta (via email, por ejemplo) para verificar que la
        transacción está, de hecho, en un estado zombi.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-3.3">
      <title>Gestionando el espacio de almacenamiento</title>

        <para>Mientras que el coste del almacenamiento ha caído
          de manera increíble durante los últimos años, el espacio
          en disco sigue siendo un motivo de preocupación válido
          para los administradores que buscan versionar grandes
          cantidades de datos. Cada byte adicional consumido por el
          repositorio en vivo es un byte que debe ser almacenado
          en una copia de seguridad, quizás múltiples veces como
          parte de una política de rotado periódico de copias de
          seguridad. Dado que el principal medio de almacenamiento
          de un repositorio de Subversion es un complejo sistema de
          bases de datos, es útil saber qué piezas deben permanecer
          en el servidor activo, cuáles deben ser almacenadas en una
          copia de seguridad, y cuáles pueden ser eliminadas.</para>

        <para>Hasta hace poco, el mayor culpable en cuanto al uso
          de disco duro por parte de un repositorio de Subversion
          eran los fichero de registro que usaba la base de
          datos Berkeley para realizar sus pre-escrituras antes de
          modificar realmente los ficheros de la base de datos. Éstos
          ficheros capturan todas las acciones tomadas durante la
          ruta que modifica el estado de la base de datos&mdash;
          si los ficheros de la base de datos reflejan en cualquier
          momento un estado determinado, los ficheros de registro
          contienen todos los cambios entre diferentes estados. Como
          tales, pueden comenzar a acumularse rápidamente.</para>

        <para>Afortunadamente, y comenzando con la versión 4.2 de
          la base de datos Berkeley, el entorno de la base de datos
          tiene la capacidad para borrar sus propios ficheros de
          registro obsoletos sin necesidad de procedimientos
          externos. Cualquier repositorio creado usando
          <command>svnadmin</command>, el cual se compila contra
          la versión 4.2 o superior de la base de datos Berkeley,
          será configurado automáticamente para borrar sus ficheros
          de registros. Si no quiere activar esta característica,
          simplemente pase la opción <option>--bdb-log-keep</option>
          al comando <command>svnadmin create</command>.
          Si olvida hacer esto, o cambia de opinión posteriormente,
          puede editar el fichero <filename>DB_CONFIG</filename>
          ubicado en el directorio <filename>db</filename> de su
          repositorio, comentar la línea que contiene la directiva
          <literal>set_flags DB_LOG_AUTOREMOVE</literal>, y entonces
          ejecutar <command>svnadmin recover</command> sobre su
          repositorio para forzar los cambios de configuración. Vea
          <xref linkend="svn-ch-5-sect-2.2"/> para más información
          sobre la configuración de la base de datos.</para>

        <para>Sin mecanismo de algún tipo que elimine los ficheros
          de registro, éstos se acumularán a medida que use el
          repositorio. Esto es en cierto sentido una característica
          del sistema de base de datos&mdash;debería ser capaz
          de recrear su base de datos por completo sin usar nada
          más que los ficheros de registro, así que éstos pueden
          ser útiles en recuperaciones de la base de datos tras una
          catástrofe. Pero habitualmente querrá archivar los ficheros
          de registro que la base de datos Berkeley ya no usa, y
          entonces eliminarlos del disco para conservar espacio. Use
          el comando <command>svnadmin list-unused-dblogs</command>
          para obtener un listado de los ficheros de registro no
          usados:</para>

      <screen>
$ svnadmin list-unused-dblogs /path/to/repos
/path/to/repos/log.0000000031
/path/to/repos/log.0000000032
/path/to/repos/log.0000000033

$ svnadmin list-unused-dblogs /path/to/repos | xargs rm
## disk space reclaimed!
</screen>

        <para>Para mantener el tamaño del repositorio tan pequeño
          como sea posible, Subversion usa la
          <firstterm>deltificación</firstterm> (o bien,
          <quote>almacenamiento deltificado</quote>) dentro
          del propio repositorio.  La deltificación conlleva
          codificar la representación de un bloque de datos como
          una colección de diferencias contra otro bloque de
          datos. Si dos piezas son muy similares, la deltificación
          proporcionará ganancias de almacenamiento para los bloques
          deltificados&mdash;en lugar de tomar tanto espacio como el
          tamaño de los datos originales, tomará justo lo necesario
          para decir, <quote>tengo casi el mismo aspecto de este
          otro bloque de datos de ahí, excepto por las siguientes
          diferencias.</quote> De manera más específica, cada vez que
          una nueva versión de un fichero es enviada al repositorio,
          Subversion codifica la versión anterior (en realidad,
          varias versiones anteriores) como un delta contra la
          nueva versión. El resultado es que la mayor parte de los
          datos que suelen ocupar espacio&mdash;en concreto, los
          contenidos de los ficheros versionados&mdash;se almacenan
          con un tamaño mucho menor que la representación original
          completa (<quote>fulltext</quote>) de esos datos.</para>

        <note>
          <para>Dado que todos los datos del repositorio Subversion
            sujetos a la deltificación se almacenan en un único
            fichero de base de datos Berlekey, reducir el tamaño
            de los valores almacenados no reducirá necesariamente
            el tamaño de éste fichero. La base de datos Berkeley no
            obstante mantendrá un registro interno de áreas internas
            sin usar de la base de datos, y usará esas áreas primero
            antes de volver a redimensionar el tamaño del fichero
            de la base de datos. Así que aunque la deltificación
            no produce ganancias de espacio inmediatas, puede
            enlentecer drásticamente el crecimiento futuro de la
            base de datos.</para>
        </note>

    </sect2>
        
    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-3.4">
      <title>Restauración del repositorio</title>

      <para>Para poder proteger sus datos en el repositorio, el
        motor de la base de datos usa un mecanismo de bloqueo. Éste
        se asegura de que no hay porciones de la base de datos
        modificadas simultáneamente por múltiples clientes de
        la base de datos, y que cada proceso ve los datos en un
        estado correcto cuando éstos son leídos. Cuando un proceso
        necesita cambiar algo en la base de datos, primero comprueba
        la existencia de un bloqueo en los datos objetivo.  Si los
        datos no están bloqueados, el proceso los bloquea, hace los
        cambios que desea realizar, y desbloquea los datos. Esto
        obliga a otros procesos a esperar hasta que se elimine el
        bloqueo antes de que se les permita continuar accediendo
        a esa sección de la base de datos.</para>

      <para>A lo largo del uso de su repositorio Subversion, los errores
        fatales (como quedarse sin espacio en disco duro o sin memoria)
        o las interrupciones pueden evitar que un proceso tenga la
        oportunidad de eliminar los bloqueos que inició sobre la base
        de datos. El resultado es que el motor de la base de datos del
        sistema se <quote>wedged</quote><!-- TODO buscar término para
        esto -->.  Cuando esto ocurre, cualquier intento de acceso al
        repositorio se bloqueará de manera indefinida (dado que cada nuevo
        cliente estará esperando a que los bloqueos desaparezcan&mdash;lo
        cual no va a ocurrir).</para>

      <para>Primero, si esto ocurre en su repositorio, no se preocupe.
        El sistema de ficheros de Subversio ntiene la ventaja de
        usar transacciones, puntos de control y ficheros de registro
        pre-escritura para asegurarse de que sólo los eventos más
        catastróficos
        <footnote>
          <para>Ej: disco duro + enorme electroimán = desastre.</para>
        </footnote>
        pueden destruir de manera permanente el entorno de la base de
        datos. Un administrador de repositorio suficientemente paranóico
        estará haciendo copias de seguridad del repositorio en otra
        máquina separada de alguna manera, pero todavía no es el momento
        de llamarle para que realice la restauración de una cinta.</para>

      <para>En segundo lugar, use la siguiente receta para intentar
        <quote>unwedge</quote> su repositorio:</para>

      <orderedlist>
        <listitem>
          <para>Asegúrese de que no hay procesos accediendo (o intentando
            acceder) al repositorio.  Para repositorios en red, esto
            también sigifica tener que desconectar el servidor HTTP
            Apache.</para>
        </listitem>
        <listitem>
          <para>Conviértase en el usuario que posee y gestiona el
            repositorio.  Esto es importante, dado que recuperar el
            repositorio poseyendo el usuario erróneo puede alterar
            los permisos de los ficheros del repositorio de tal
            modo que será inaccesible incluso después de haberlo
            <quote>unwedged</quote>.</para>
        </listitem>
        <listitem>
          <para>Ejecute el comando <command>svnadmin recover
            /ruta/al/repositorio</command>. Debería ver algo como
            esto:</para>

          <screen>
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 19.
</screen>
          <para>Este comando puede tardar muchos minutos en completar
            su tarea.</para>
        </listitem>
        <listitem>
          <para>Rearranque el servidor Subversion.</para>
        </listitem>
      </orderedlist>

      <para>Este prodecimiento corrige casi todos los casos de bloqueos
        del repositorio. Asegúrese de ejecutar este comando como el
        usuario a quien le pertenece la base de datos y la gestiona,
        no basta con ser <literal>root</literal>.  Parte del proceso de
        recuperación puede conllevar la regeneración de varios ficheros de
        bases de datos (por ejemplo, regiones de memoria compartidas). Al
        realizar la recuperación como <literal>root</literal>, éstos
        ficheros tendrán sus permisos, lo cual significa que incluso
        cuando recupere la conexión con el repositorio, los usuarios
        normales no serán capaces de acceder a él.</para>

      <para>Si el procedimiento anterior, por alguna razón, no consigue
        desbloquear su repositorio, debería hacer dos cosas. En primer
        lugar, mueva su repositorio estropeado a otro lugar y recupere
        la última copia de seguridad que tenga del mismo. Entonces,
        envíe un correo electrónico a la lista de usuarios de Subversion
        (en <email>users@subversion.tigris.org</email>) describiendo
        su problema con todo detalle. Para los desarrolladores de
        SUbversion mantener la integridad de los datos es una prioridad
        extremadamente alta.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-3.5">
      <title>Migrando un repositorio</title>

      <para>Un sistema de ficheros de Subversion almacena sus datos
        repartidos por varias tablas de bases de datos de una forma
        generalmente comprensible (y sólo de interés) para los propios
        desarrolladores de Subversion. No obstante, pueden darse
        las circunstancias adecuadas que requieran que todos los datos,
        o un subconjunto de los mismos, sean recopilados en un fichero
        único, portable, y de formato simple. Subversion proporciona
        tal mecanismo implementado como la pareja de subcomandos
        de <command>svnadmin</command>: <literal>dump</literal> y
        <literal>load</literal>.</para>

      <para>La razón más comun para volcar y recargar un repositorio
        de Subversion es por cambios en el propio Subversion. A medida
        que Subversion madura, hay momentos en los que hace falta
        realizar cambios al esquema del motor de la base de datos que
        hacen a Subversion incompatible con versiones anteriores de su
        repositorio. La acción recomendada para actualizarse atravesando
        una de estas barreras de incompatiblidad es relativamente
        simple:</para>

      <orderedlist>
        <listitem>
          <para>Usando su <emphasis>actual</emphasis> versión de
            <command>svnadmin</command>, vuelque su repositorio a
            ficheros de volcado.</para>
        </listitem>
        <listitem>
          <para>Actualicese a la nueva versión de Subversion.</para>
        </listitem>
        <listitem>
          <para>Mueva sus viejos repositorios a otra parte, y
            crée nuevos repositorios vacíos en su lugar usando su
            <emphasis>nuevo</emphasis> <command>svnadmin</command>.</para>
        </listitem>
        <listitem>
          <para>Otra vez con su <command>svnadmin</command>
            <emphasis>nuevo</emphasis>, cargue sus ficheros de volcado
            en sus repositorios recién creados respectivamente.</para>
        </listitem>
        <listitem>
          <para>Finalmente, asegúrese de copiar en los nuevos repositorios
            cualquier personalización realizada en los antiguos,
            incluyendo los ficheros <filename>DB_CONFIG</filename> y los
            ficheros de ganchos. Le recomendamos que preste atención a las
            notas de lanzamiento de la nueva versión de Subversion para
            comprobar si algún cambio desde su última actualización afecta
            a esos ficheros de ganchos u opciones de configuración.</para>
        </listitem>
      </orderedlist>

      <para><command>svnadmin dump</command> generará en su salida un
        rango de revisiones del repositorio usando el formato propio
        de Subvesion para volcar el sistema de ficheros.  El volcado
        formateado será enviado al flujo estándar de salida, mientras
        que los mensajes informativos son enviados al flujo estándar de
        errores. Esto le permite redirigir el flujo de salida estándar
        a un fichero mientras observa el estado del volcado en su
        terminal. Por ejemplo:</para>

      <screen>
$ svnlook youngest myrepos
26
$ svnadmin dump myrepos &gt; dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
&hellip;
* Dumped revision 25.
* Dumped revision 26.
</screen>

      <para>Al final del proceso tendrá un único fichero
        (<filename>dumpfile</filename> según el ejemplo anterior)
        que contendrá todos los datos almacenados en su repositorio
        en el rango de revisiones especificado. Tenga en cuenta que
        <command>svnadmin dump</command> lee los árboles de versiones del
        repositorio igual que cualquier otro proceso <quote>lector</quote>
        (por ejemplo, <command>svn checkout</command>). Así que es seguro
        ejecutar este comando en cualquier momento.</para>

      <para>El otro subcomando de la pareja, <command>svnadmin
        load</command>, procesa el flujo estándar de entrada como un
        fichero de volcado de repositorio de Subversion, y reproduce de
        manera efectiva esas revisiones volcadas en el repositorio destino
        durante la operación. También proporciona mensajes informativos,
        esta vez usando el flujo de salida estándar:</para>

      <screen>
$ svnadmin load newrepos &lt; dumpfile
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : A ... done.
     * adding path : A/B ... done.
     &hellip;
------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 2
     * editing path : A/mu ... done.
     * editing path : A/D/G/rho ... done.

------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;

&hellip;

&lt;&lt;&lt; Started new txn, based on original revision 25
     * editing path : A/D/gamma ... done.

------- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 26
     * adding path : A/Z/zeta ... done.
     * editing path : A/mu ... done.

------- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;

</screen>

      <para>Dado que <command>svnadmin</command> usa la los flujos
        estándar de entrada y salida para el volcado de repositorio y el
        proceso de carga, las personas que se sientan atrevidas pueden
        probar algo como ésto (quizás usando diferentes versiones de
        <command>svnadmin</command> en cada lado de la tubería):</para>

      <screen>
$ svnadmin create newrepos
$ svnadmin dump myrepos | svnadmin load newrepos
</screen>

      <para>Hemos mencionado anteriormente que <command>svnadmin
        dump</command> genera un rango de revisiones. Use la opción
        <option>--revision</option> para indicar que quiere volcar una
        revisión concreta, o un rango. Si omite esta opción, todas las
        revisiones existentes del repositorio serán volcadas.</para>

      <screen>
$ svnadmin dump myrepos --revision 23 &gt; rev-23.dumpfile
$ svnadmin dump myrepos --revision 100:200 &gt; revs-100-200.dumpfile
</screen>

      <para>A medida que Subversion vuelca cada revisión nueva, muestra
        la información justa para permitir a un cargador futuro recrear
        esa revisión basándose en la anterior. En otras palabras,
        para cualquier revisión dada en el fichero de volcado, sólo
        aparecerán los elementos que cambiaron en ella. La única
        excepción a esta regla es la primera revisión volcada por el
        comando <command>svnadmin dump</command> actual.</para>

      <para>Por defecto, Subverion no expresará la primera revisión
        volcada como las meras diferencias aplicables sobre la revisión
        anterior.  Para empezar, ¡es que no hay revisión anterior
        alguna en el fichero de volcado! Y en segundo lugar, Subversion
        no puede saber el estado del repositorio en el cual los datos
        volcados serán cargados (si este hecho llega a producirse). Para
        asegurarse de que la salida de cada ejecución de <command>svnadmin
        dump</command> es autosuficiente, la primera revisión volcada
        es por defecto una representación completa de cada directorio,
        fichero, y propiedad en esa revisión del repositorio.</para>

      <para>No obstante, puede cambiar este comportamiento por defecto. Si
        añade la opción <option>--incremental</option> cuando vuelque su
        repositorio, <command>svnadmin</command> comparará la primera
        versión volcada del repositorio contra la revisión anterior del
        repositorio, igual que trata cualquier otra revisión volcada.
        Entonces mostrará la primera revisión exáctamente igual que el
        resto de las revisiones del rango de volcado&mdash;mencionando
        únicamente los cambios ocurridos en esa revisión. El beneficio
        de esto es que puede crear varios ficheros de volcado menores
        que pueden ser cargados secuencialmente, en lugar de un único
        fichero grande, siguiendo estos pasos:</para>

      <screen>
$ svnadmin dump myrepos --revision 0:1000 &gt; dumpfile1
$ svnadmin dump myrepos --revision 1001:2000 --incremental &gt; dumpfile2
$ svnadmin dump myrepos --revision 2001:3000 --incremental &gt; dumpfile3
</screen>

      <para>Estos ficheros de volcado podrían ser cargados en un nuevo
        repositorio usando la siguiente secuencia de comandos:</para>

      <screen>
$ svnadmin load newrepos &lt; dumpfile1
$ svnadmin load newrepos &lt; dumpfile2

$ svnadmin load newrepos &lt; dumpfile3
</screen>

      <para>Otro truco interesante que puede realizar con la opción
        <option>--incremental</option> consiste en añadir a un
        fichero de volcado existente un nuevo rango de revisiones
        volcadas. Por ejemplo, digamos que tiene un gancho
        <literal>post-commit</literal> que simplemente añade el volcado
        del repositorio de la versión única que despertó la ejecución
        del gancho. O quizás tenga un script que se ejecute por las
        noches para añadir los datos del fichero de volcado de todas
        las revisiones que fueron añadidas al repositorio desde la
        última vez que fue ejecutado el script. Usados de este modo,
        los comandos <command>svnadmin</command> <literal>dump</literal>
        y <literal>load</literal> pueden ser valiosos aliados para
        realizar copias de seguridad de su repositorio a lo largo
        del tiempo en caso de un fallo de sistema o algún otro eveno
        catastrófico.</para>

      <para>El formato de volcado también puede ser usado para fusionar
        los contenidos de varios repositorios diferentes en uno
        único.  Al usar la opción <option>--parent-dir</option>
        de <command>svnadmin load</command>, puede especificar
        un nuevo directorio virtual para el proceso de carga. Lo
        cual significa que si tiene ficheros de volcados para tres
        repositorios, digamos <filename>calc-dumpfile</filename>,
        <filename>cal-dumpfile</filename>, y
        <filename>ss-dumpfile</filename>, puede crear primero un nuevo
        repositorio para almacenarlos todos:</para>

      <screen>
$ svnadmin create /path/to/projects
$
</screen>

      <para>Entonces, crée nuevos directorios en el repositorio que
        encapsularán los contenidos de cada uno de los tres repositorios
        anteriores:</para>

      <screen>
$ svn mkdir -m "Initial project roots" \
      file:///path/to/projects/calc \
      file:///path/to/projects/calendar \
      file:///path/to/projects/spreadsheet
Committed revision 1.
$ 
</screen>

      <para>Por último, cargue los ficheros de volcado individuales en
        sus ubicaciones respectivas del nuevo repositorio:</para>

      <screen>
$ svnadmin load /path/to/projects --parent-dir calc &lt; calc-dumpfile
&hellip;
$ svnadmin load /path/to/projects --parent-dir calendar &lt; cal-dumpfile
&hellip;
$ svnadmin load /path/to/projects --parent-dir spreadsheet &lt; ss-dumpfile
&hellip;
$
</screen>

      <para>Mencionaremos un último uso del formato de volcado de
        repositorio de Subversion&mdash;conversión desde un formato de
        almacenamiento diferente o sistema de control de versiones.
        Dado que el fichero de volcado es, en su mayor parte, legible
        por un humano,
        <footnote>
          <para>El formato de volcado de repositorio de Subversion
            recuerda al formato RFC-822, el mismo tipo de formato usado
            para la mayor parte del correo electrónico.</para>
        </footnote>
        debería ser relativamente sencillo describir un conjungo genérico
        de cambios&mdash;cada uno de ellos debería ser descrito como
        una nueva revisión&mdash;usando este formato de fichero.
        De hecho, la ultilidad <command>cvs2svn.py</command> (véa
        <xref linkend="svn-ap-a-sect-11"/>) usa el formato de volcado
        para representar el contenido de un repositorio CVS para
        que sus contenidos pueden ser trasladados a un repositorio
        Subversion.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-3.6">
      <title>Copias de seguridad del repositorio</title>

      <para>A pesar de numerosos avances tecnológicos desde el nacimiento
        de la computadora moderna, hay una cosa que se entiende con
        cristalina claridad&mdash;a veces, las cosas van muy, pero
        que muy mal. Pérdidas de corriente, fallos de conectividad en
        la red, RAM corrupta y discos duros estropeados son un mero
        avance del mal que el Destino puede desatar sobre incluso el
        administrador más concienzudo.  Y por lo tanto, llegamos a un
        tema muy importante&mdash;cómo hacer copias de seguridad de los
        datos de su repositorio.</para>

      <para>En general hay dos tipos de métodos de copia de seguridad
        disponibles para los administradores de repositorios de
        Subversion&mdash;incrementales y completos. Hemos discutido en
        una sección anterior de este capítulo cómo usar <command>svnadmin
        dump --incremental</command> para realizar copias de seguridad
        incrementales (vea <xref linkend="svn-ch-5-sect-3.5"/>).
        Esencialmente, la idea es realizar en un momento dado copias de
        seguridad de los cambios realizados desde la última vez que se
        hizo la copia de seguridad anterior.</para>

      <para>Una copia de seguridad completa del repositorio es casi una
        copia literal del directorio que contiene todo el repositorio (lo
        cual incluye el entorno de la base de datos Berkeley). Ahora, a no
        ser que desactive temporalmente todo el acceso a su repositorio,
        ejecutar un simple copiado recursivo del directorio conlleva
        el riesgo de generar una copia de seguridad errónea, dado que
        alguien podría estar modificando la base de datos.</para>

      <para>Afortunadamente, los documentos de la base de datos
        Berkeley DB de Sleepycat describen un orden concreto
        en el cual se pueden copiar los ficheros de la base de
        datos de tal modo que se garantice una copia de seguridad
        válida. Y aun mejor, usted no necesita implementar
        ese algoritmo por su cuenta, porque el equipo de
        desarrolladores de Subversion ya lo ha hecho. El script
        <command>hot-backup.py</command> que puede encontrar
        en el directorio <filename>tools/backup/</filename>
        de la distribución de código fuente de Subversion.
        Usando como parámetros la ruta al repositorio
        y a la ubicación de la copia de seguridad,
        <command>hot-backup.py</command>&mdash;que realmente no
        es más que un envoltorio más inteligente sobre el comando
        <command>svnadmin hotcopy</command>&mdash; realizará los
        pasos necesarios para realizar una copia de seguridad en
        caliente del repositorio&mdash;sin necesitar en absoluto
        tener que impedir el acceso al mismo&mdash;y después
        borrará los ficheros de registro sin usar de Berkeley de
        su repositorio activo actual.</para>

      <para>Incluso si también dispone de una copia de seguridad
        incremental, quizás quiera ejecutar también este programa
        de manera habitual. Por ejemplo, podría considerar
        añadir <command>hot-backup.py</command> a un programa de
        planificación (como por ejemplo <command>cron</command>
        en sistemas Unix). O, si prefiere soluciones de copias de
        seguridad con alta granularidad, podría hacer que su gancho
        post-commit llame <command>hot-backup.py</command> (vea <xref
        linkend="svn-ch-5-sect-2.1" />), lo cual provocará una nueva copia
        de seguridad de su repositorio con cada nueva versión. Simplemente
        añada el script <filename>hooks/post-commit</filename> a su
        directorio activo del repositorio:</para>

      <programlisting>
(cd /path/to/hook/scripts; ./hot-backup.py ${REPOS} /path/to/backups &amp;)
</programlisting>

      <para>La copia de seguridad resultante es un repositorio de
        Subversion completamente funcional, capaz de reemplazas su
        repositorio activo en caso de que algo vaya muy mal.</para>

      <para>Ambos métodos de copias de seguridad son beneficiosos. La
        copia de seguridad completa es de lejos la más sencilla,
        la que siempre resultará ser una réplica de su repositorio
        perfectamente funcional. Le recordamos que esto significa que si
        algo malo le ocurre a su repositorio activo, puede recuperar
        su copia de seguridad con un simple copiado recursivo de
        directorios. Desafortunadamente, si está manteniendo múltiples
        copias de seguridad de su repositorio, estas copias completas
        acabarán ocupando la misma cantidad de espacio de disco que su
        repositorio activo.</para>

      <para>Las copias de seguridad incrementales usando el formato de
        volcado del repositorio son excelentes para tener a mano si el
        esquema de la base de datos cambia entre sucesivas versiones del
        propio Subversion. Dado que para actualizar su repositorio al
        nuevo esquema es necesario que haga un volcado y carga completa
        del repositorio, es muy conveniente tener la mitad de ese
        proceso (la parte del volcado) realizada.  Desafortunadamente,
        la creación&mdash;y recuperación&mdash;de copias de seguridad
        incrementales tarda mucho más, dado que cada revisión es
        reproducida en el fichero de volcado o el repositorio.</para>

      <para>En ambos escenarios, los administradores del repositorio
        necesitan estar atentos a cómo las modificaciones de propiedades
        de revisión no versionadas afectan a sus copias de seguridad. Dado
        que estos cambios no generan por sí mismos nuevas revisiones,
        no activarán ganchos post-commit, y quizás ni siquiera los
        ganchos pre-revprop-change y post-revprop-change.
        <footnote>
          <para><command>svnadmin setlog</command> puede ser invocado
            de un modo que evita por completo el mecanismo de
            ganchos.</para>
        </footnote>
        Y dado que puede cambiar las propiedade de revisión sin respetar
        su orden cronológico&mdash;puede cambiar cualquier propiedad
        de revisión en cualquier momento&mdash;una copia de seguridad
        incremental de las últimas pocas revisiones quizás no capture
        la modificación de una propiedad de revisión que fue incluida
        como parte de una copia de seguridad anterior.</para>

      <para>Hablando de manera general, sólo los realmente paranóicos
        necesitarían hacer una copia de seguridad de su repositorio
        completo, digamos que, cada vez que se realiza un cambio. No
        obstante, asumiendo que un repositorio determinado tiene
        funcionando otros mecanismos de redundancia con relativa
        granularidad (como correos electrónicos por modificación), una
        copia de seguridad en caliente de la base de datos sería algo que
        un administrador de repositorio querría incluir como parte de una
        copia de seguridad de sistema nocturna. Para la mayoría de los
        repositorios, los correos archivados con cambios son suficiente
        fuente de redundancia, al menos para los últimos cambios. Pero
        son sus datos&mdash;protéjalos tanto como desee.</para>

      <para>A menudo, la mejor estrategia para realizar copias de seguridad es
        aquella que diversifique. Puede aprovechar combinaciones de copias
        de seguridad completas e incrementales, y adicionalmente archivos
        de correo con los cambios. Los desarrolladores de Subversion,
        por ejemplo, realizan una copia de seguridad del repositorio de
        código fuente tras cada nueva revisión, y mantienen un archivo
        de todas las notificaciones por correo electrónico de cambios y
        modificaciones de propiedades.  Su solución podría ser similar,
        pero debería estar orientada a las necesidades y ese delicado
        balance entre la conveniencia y la paranoia.  Y aunque nada
        de todo esto le ayude a salvar su hardware del puño de hierro
        del Destino,
        <footnote>
          <para>Ya sabe&mdash;el término genérico para sus 
            <quote>erráticos dedos</quote>.</para>
        </footnote>
        ciertamente debería ayudarle a recuperarse tras uno de esos
        momentos.</para>

    </sect2>
  </sect1>


  <!-- ******************************************************************* -->
  <!-- *** SECTION 6:  ADDING PROJECTS                                 *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-5-sect-6">
    <title>Añadiendo proyectos</title>

    <para>Una vez haya creado y configurado su repositorio, todo lo que
      queda es comenzar a usarlo. Si tiene una colección de datos
      existentes listos para ser puestos bajo control de versiones, es
      muy probable que desee usar el subcomando <literal>import</literal>
      del programa cliente <command>svn</command>.  No obstante, antes
      de hacer esto debería considerar con cuidado los planes a largo
      plazo de su repositorio. En esta sección le ofreceremos algunos
      consejos sobre la planificación del esquema de su repositorio,
      y cómo reorganizar sus datos de acuerdo con éste.</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-6.1">
      <title>Escogiendo el esquema de repositorio</title>

      <para>Aunque Subversion le permite desplazar los ficheros y
        directorios versionados sin pérdida de información de
        cualquier tipo, al hacerlo puede entorpecer el flujo
        de trabajo de aquellos quienes acceden al repositorio
        con frecuencia y esperan encontrar algunas cosas en
        ubicaciones determinadas.  Intente asomarse un poco al
        futuro; planifique antes de poner sus datos bajo control
        de versiones. Al <quote>organizar</quote> el contenido de
        sus repositorios de una manera efectiva la primera vez,
        podrá evitar un montón de futuros dolores de cabeza.</para>

      <para>Hay algunas cosas que deberá considerar al configurar
        repositorios con Subversion.  Asumamos que como administrador
        de repositorio será responsable de dar soporte del sistema de
        control de versiones a varios proyectos. La primera decisión
        consiste en decidir si usará un único repositorio para múltiples
        proyectos, o le dará un repositorio a cada proyecto, o una mezcla
        de cambos.</para>


      <para>Hay múltiples beneficios en el uso de un único repositorio
        para múltiples projectos, siendo el más obvio evitar duplicar el
        trabajo de mantenimiento.  Tener un único repositorio significa
        que sólo hay un conjunto de scripts de enganche, un elemento del
        que hacer rutinariamente copias de seguridad, un único volcado y
        recarga si Subversion lanza alguna nueva versión incompatible,
        y así con todo. Además, puede mover datos entre proyectos
        muy fácilmente, y sin perder ninguna información histórica de
        versionado.</para>

      <para>Las desventajas de usar un único repositorio son que los
        diferentes proyectos pueden tener diferentes listas de correo
        que reciben notificaciones de los cambios realizados o diferentes
        requisitos de autenticación y autorización. Además, recuerde que
        Subversion usa números de revisión globales por repositorio. Hay
        gente a la que no le gusta el hecho de que incluso sin haber
        realizado cambios recientes en sus proyectos, el número de la
        revisión más reciente sigue subiendo porque otros proyectos
        siguen añadiendo revisiones de manera activa.</para>

      <para>También puede diseñar una solución híbrida. Por ejemplo,
        los proyectos pueden ser agrupados en función de las relaciones
        que tengan entre ellos. Quizás tenga varios repositorios con un
        puñado de projectos en cada uno. De ese modo, los proyectos más
        propensos a compartir sus datos pueden hacerlo de manera sencilla, y
        a medida que se añaden revisiones al repositorio, al menos los
        desarrolladores del mismo saben que están relacionadas remotamente
        con todo aquél que usa ese repositorio.</para>

      <para>Tras decidir cómo desea organizar sus proyectos con respecto
        a los repositorios, probablemente querrá decidir las jerarquías
        de los directorios almacenados en ellos. Dado que Subversion
        usa copias de directorio normales para hacer ramas y etiquetas
        (vea <xref linkend="svn-ch-4"/>), la comunidad de Subversion
        recomienda que elija una ubicación en el repositorio para cada
        <firstterm>raíz de proyecto</firstterm>&mdash; el directorio
        <quote>superior</quote> que contiene todos los datos relacionados
        con el mismo&mdash;y crée tres nuevos subdirectorios en esa
        raíz: <filename>trunk</filename>, que sería el directorio
        bajo el cual se lleva el desarrollo principal del proyecto;
        <filename>branches</filename>, que sería el directorio que
        alojaría las diferentes ramas con nombre de la línea principal
        de desarrollo; <filename>tags</filename>, que es el directorio
        donde las ramas son creadas, y quizás destruidas, pero nunca
        modificadas.</para>

      <para>Por ejemplo, su repositorio podría tener este aspecto:</para>

     <screen>
/
   calc/
      trunk/
      tags/
      branches/
   calendar/
      trunk/
      tags/
      branches/
   spreadsheet/
      trunk/
      tags/
      branches/
   &hellip;
</screen>

      <para>Tenga en cuenta que no importa dónde está la raíz de cada
        proyecto en su repositorio. Si sólo tiene un proyecto por
        repositorio, el lugar lógico para poner la raíz de cada proyecto
        es en la raíz del repositorio respectivo.  Si tiene múltiples
        proyectos, quizás desée organizarlos en grupos dentro del
        repositorio, quizás ubicando proyectos con fines similares o
        código compartido en el mismo subdirectorio, o quizás simplemente
        prefiera agruparlos alfabéticamente. Tal esquema podría tener
        el siguiente aspecto:</para>

      <screen>
/
   utils/
      calc/
         trunk/
         tags/
         branches/
      calendar/
         trunk/
         tags/
         branches/
      &hellip;
   office/
      spreadsheet/
         trunk/
         tags/
         branches/
      &hellip;
</screen>

      <para>Despliegue su repositorio de la manera que crea más
        conveniente.  Subversion no espera ni obliga un esquema de
        directorios concreto&mdash;a sus ojos, un directorio es un
        directorio es un directorio. Por último, debería elegir la
        organización del repositorio de manera que satisfaga las
        necesidades de aquellos que trabajen en los proyectos ahí
        alojados.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-6.2">
      <title>Creando el esquema, importando los datos iniciales</title>

      <para>Tras decidir cómo organizar los proyectos de su repositorio,
        probablemente quiera poblarlo con ese esquema y los datos
        iniciales de los proyectos.  Hay varios modos de hacer esto en
        Subversion. Podría usar el comando <command>svn mkdir</command>
        (vea <xref linkend="svn-ch-9"/>) para crear cada directorio en
        su esquema esquelético, uno tras otro. Una forma más rápida
        de realizar esta misma tarea es usar el comando <command>svn
        import</command> (vea <xref linkend="svn-ch-3-sect-7.3"/>).
        Al crear el esquema en una ubicación temporal de su disco,
        puede importarlo por completo en un único cambio:</para>

      <screen>
$ mkdir tmpdir
$ cd tmpdir
$ mkdir projectA
$ mkdir projectA/trunk
$ mkdir projectA/branches
$ mkdir projectA/tags
$ mkdir projectB
$ mkdir projectB/trunk
$ mkdir projectB/branches
$ mkdir projectB/tags
&hellip;
$ svn import . file:///path/to/repos --message 'Initial repository layout'
Adding         projectA
Adding         projectA/trunk
Adding         projectA/branches
Adding         projectA/tags
Adding         projectB
Adding         projectB/trunk
Adding         projectB/branches
Adding         projectB/tags
&hellip;
Committed revision 1.
$ cd ..
$ rm -rf tmpdir
$
</screen>

      <para>Puede comprobar los resultados de la operación de importado
        ejecutando el comando <command>svn list</command>:</para>

      <screen>
$ svn list --verbose file:///path/to/repos
      1 harry               May 08 21:48 projectA/
      1 harry               May 08 21:48 projectB/
&hellip;
$
</screen>

      <para>Una vez tenga la estructura de su esquema en lugar, puede
        comenzar a importar los del projecto en su repositorio, si
        es que tales datos existen. De nuevo, hay varios métodos
        para hacer esto.  Puede usar el comando <command>svn
        import</command>. Podría obtener una copia de trabajo local
        de su reciente repositorio, mover y organizar los datos de su
        proyecto dentro, y usar los comandos <command>svn add</command>
        y <command>svn commit</command>. Pero una vez comenzamos a hablar
        de tales cosas, ya no estamos discutiendo la administración del
        repositorio.  Si no está familiarizado con el programa cliente
        <command>svn</command>, vea <xref linkend="svn-ch-3"/>.</para>

    </sect2>
  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 7:  SUMMARY                                         *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-5-sect-7">
    <title>Sumario</title>

    <para>A estas alturas debería tener un conocimiento básico sobre
      cómo crear, configurar, y mantener repositorios de Subversion. Le
      hemos introducido a varias herramientas que le asistirán con estas
      tareas. A lo largo del capítulo hemos avisado sobre los posibles
      problemas, y proporcionado sugerencias para evitarlos.</para>

    <para>Todo lo que queda es decidir qué datos excitantes
      almacenará en su repositorio, y finalmente, cómo hacerlos
      disponibles por red. El siguiente capítulo está dedicado a
      todo lo relacionado con la red.</para>

  </sect1>
</chapter>

<!--
local variables:
sgml-parent-document: ("book.xml" "chapter")
end:
-->
