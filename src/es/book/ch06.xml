<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- originated from English revision 652 -->
<chapter id="svn-ch-6">
  <!--REMOVE:<title>Server Configuration</title>-->
  <title>Configuración del servidor</title>
  <simplesect>
    
    <para>Un repositorio Subversion puede ser accedido simultáneamente
      por clientes que son ejecutados en la misma máquina en la que reside
      el repositorio usando el método <literal>file:///</literal>. Pero una
      típica configuración de Subversion implica a un servidor al que acceden
      clientes desde sus computadoras en el entorno de una oficina&mdash; o
      quizás, alrededor del mundo.</para>
    
    <!--REMOVE:<para>A Subversion repository can be accessed simultaneously by
      clients running on the same machine on which the repository
      resides using the <literal>file:///</literal> method.  But the
      typical Subversion setup involves a single server machine being
      accessed from clients on computers all over the office&mdash;or,
      perhaps, all over the world.</para>-->

    <para>Esta sección describe como publicar su repositorio Subversion
      para ser accedido por clientes remotos.
      <!--TODO: Es correcta la simplificación del término "...outside its host
      machine for use by remote clients"--> Cubriremos los tipos
      de mecanismos de servidor disponibles actualmente <!--TODO: Es correcto?
      "...currently available server mechanisms"-->, debatiendo la configuración
      y uso de cada uno de éstos. Después de que haya leído está sección,
      usted debería estar capacitado para decidir que tipo de configuración
      de red es la apropiada para sus necesidades, y comprender como realizar
      la instalación en su computadora.</para>
      
    <!--REMOVE:<para>This section describes how to get your Subversion repository
      exposed outside its host machine for use by remote clients.  We
      will cover Subversion's currently available server mechanisms,
      discussing the configuration and use of each.  After reading
      this section, you should be able to decide which networking
      setup is right for your needs, and understand how to enable such
      a setup on your host computer.</para>-->
    
  </simplesect>
  
  <!-- ================================================================= -->
  <!-- ======================== SECTION 1 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-6-sect-1">
    
    <title>Introducción <!--TODO: Introducción-Visión general--></title>
    <!--REMOVE:<title>Overview</title>-->
    
    <para>Subversion cuenta con un diseño de la capa de red abstracto.<!--TODO: Subversion was designed with an abstract network layer.-->
      Esto significa que el repositorio puede ser accedido por cualquier
      clase de proceso de servidor y el API<footnote><para>N.T.: Application programmmers interface, o interfaz de programación de aplicaciones. Este acrónimo se considera reconocido internacionalmente motivo por el cuál no será traducido.</para></footnote> de <quote>acceso al repositorio</quote> cliente
      permite a los programadores escribir componentes que se comuniquen<!--TODO: "...and the client <quote>repository access</quote> API"-->
      a través de su protocolo de red pertinente. En teoría, Subversion puede
      lucir <!--TODO: sports = lucir?--> una infinidad de implementaciones de red. En la
      práctica, sólo existen dos tipos de servidores al momento de escribirse
      este documento.</para>
      
    <!--REMOVE:<para>Subversion was designed with an abstract network layer.
      This means that a repository can be programmatically accessed by
      any sort of server process, and the client <quote>repository
      access</quote> API allows programmers to write plugins that
      speak relevant network protocols.  In theory, Subversion can
      sport an infinite number of network implementations.  In
      practice, there are only two servers at the time of
      writing.</para>-->
    
    <para>Apache es un servidor web extremadamente <!--TODO: altamente-sumamente-extremadamente--> popular; utilizando
     el módulo <command>mod_dav_svn</command>, Apache puede acceder a
     un repositorio y hacerlo disponible a los clientes a través del
     protocolo WebDAV/DeltaV, el cuál es una extensión del HTTP. En la
     otra esquina se encuentra <command>svnserve</command>: un pequeño programa
     servidor independiente que se comunica a través de un <!--TODO: Sería mejor si custom = propietario? --> protocolo personalizado con los clientes.
     La Tabla 6-1 presenta una comparación de ambos tipos de servidores.</para>
     
    <!--REMOVE:<para>Apache is an extremely popular webserver; using the
      <command>mod_dav_svn</command> module, Apache can access a
      repository and make it available to clients via the WebDAV/DeltaV
      protocol, which is an extension of HTTP.  In the other corner is
      <command>svnserve</command>: a small, standalone server
      program that speaks a custom protocol with clients.  Table 6-1
      presents a comparison of the two servers.</para>-->

    <para>Observe que Subversion, siendo un proyecto de código abierto, no
      apoya oficialmente a ningún servidor como opción <quote>primaria</quote>
      u <quote>oficial</quote>. Ninguna de las implementaciones de red es
      considerada como un ciudadano de segunda clase; <!--TODO: traducir second-class citizen-->cada servidor
      posee ventajas y desventajas distintivas. De hecho, es posible ejecutar
      los diferentes servidores en paralelo, cada uno accediendo a sus
      repositorios a su modo y sin obstaculizar al otro (ver
      <xref linkend="svn-ch-6-sect-5"/>). A continuación una breve
      visión general y comparación de los servidores Subversion
      disponibles&mdash;es tiempo de que elija la instalación que sea
      mejor para usted y sus usuarios.</para>
      
    <!--REMOVE:<para>Note that Subversion, as an open-source project, does not
      officially endorse any server as <quote>primary</quote> or
      <quote>official</quote>.  Neither network implementation is
      treated as a second-class citizen; each server has distinct
      advantages and disadvantages.  In fact, it's possible for
      different servers to run in parallel, each accessing your
      repositories in its own way, and each without hindering the
      other (see <xref linkend="svn-ch-6-sect-5"/>).  Here's a brief
      overview and comparison of the two available Subversion
      servers&mdash;as an administrator, it's up to you to choose
      whatever works best for you and your users.</para>-->
      
    <table id="svn-ch-6-table-1">
      <title>Comparación de tipos de servidores de red</title>
      <tgroup cols="3">
        <thead>
          <row>
            <entry>Característica</entry>
            <entry>Apache + mod_dav_svn</entry>
            <entry>svnserve</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>Opciones de autenticación</entry>
            
            <entry>Autorización básica HTTP(S), Certificados X.509, LDAP, NTLM, o
              cualquier otro mecanismo disponible por Apache httpd</entry>
            
            <entry>CRAM-MD5 o SSH</entry>
          </row>
          
          <row>
            <entry>Opciones de cuenta de usuario</entry>
            
            <entry>archivo privado de usuarios 'users'</entry>
            
            <entry>archivo privado de usuarios 'users', o cuentas (SSH)
              existentes en el sistema</entry>
          </row>
          
          <row>
            <entry>Opciones de autorización</entry>
            
            <entry>acceso general de lectura/escritura,<!--TODO: blanket read/write access--> o control de acceso
              por directorios</entry>
            
            <entry>acceso general de lectura/escritura</entry>
          </row>
          
          <row>
            <entry>Cifrado</entry>
            
            <entry>a través de SSL (opcional)</entry>

            <entry>a través de un túnel SSH (opcional)</entry>
          </row>

          <row>
            <entry>Interoperabilidad</entry>
            
            <entry>disponible parcialmente por otros clientes WebDAV</entry>

            <entry>no posee interoperabilidad</entry>
          </row>

          <row>
            <entry>Ver a través de la web<!--TODO:Web viewing--></entry>
            
            <entry>soporte integrado limitado, o a través de herramientas de terceras
            partes tales como ViewCVS</entry>

            <entry>a través de herramientas de terceras partes tales como ViewCVS</entry>
          </row>

          <row>
            <entry>Velocidad</entry>
            
            <entry>algo lento</entry>

            <entry>algo rápido</entry>
          </row>

          <row>
            <entry>Configuración inicial</entry>
            
            <entry>algo compleja</entry>

            <entry>bastante simple</entry>
          </row>

        </tbody>
      </tgroup>      
    </table>

    <!--REMOVE:<table id="svn-ch-6-table-1">
      <title>Network Server Comparison</title>
      <tgroup cols="3">
        <thead>
          <row>
            <entry>Feature</entry>
            <entry>Apache + mod_dav_svn</entry>
            <entry>svnserve</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>Authentication options</entry>
            
            <entry>HTTP(S) basic auth, X.509 certificates, LDAP, NTLM, or
              any other mechanism available to Apache httpd</entry>
            
            <entry>CRAM-MD5 or SSH</entry>
          </row>
          
          <row>
            <entry>User account options</entry>
            
            <entry>private 'users' file</entry>
            
            <entry>private 'users' file, or existing system (SSH)
              accounts</entry>
          </row>
          
          <row>
            <entry>Authorization options</entry>
            
            <entry>blanket read/write access, or per-directory access
              control</entry>
            
            <entry>blanket read/write access</entry>
          </row>
          
          <row>
            <entry>Encryption</entry>
            
            <entry>via optional SSL</entry>

            <entry>via optional SSH tunnel</entry>
          </row>

          <row>
            <entry>Interoperability</entry>
            
            <entry>partially usable by other WebDAV clients</entry>

            <entry>not interoperable</entry>
          </row>

          <row>
            <entry>Web viewing</entry>
            
            <entry>limited built-in support, or via 3rd-party tools
              such as ViewCVS</entry>

            <entry>via 3rd-party tools such as ViewCVS</entry>
          </row>

          <row>
            <entry>Speed</entry>
            
            <entry>somewhat slower</entry>

            <entry>somewhat faster</entry>
          </row>

          <row>
            <entry>Initial setup</entry>
            
            <entry>somewhat complex</entry>

            <entry>fairly simple</entry>
          </row>

        </tbody>
      </tgroup>      
    </table>-->
    
  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 2 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-6-sect-2">

    <title>Modelo de red</title>
    <!--REMOVE:<title>Network Model</title>-->

    <para>En esta sección se debate en términos generales como interactúan
      el cliente y servidor Subversión entre sí, independientemente de la
      implementación de red que esté utilizando. A su término, usted
      comprenderá como se comporta un servidor y las diferentes
      formas en que un cliente puede ser configurado para responder.</para>
    
    <!--REMOVE:<para>This section is a general discussion of how a Subversion
      client and server interact with one another, regardless of the
      network implementation you're using.  After reading, you'll have
      a good understanding of how a server can behave and the
      different ways in which a client can be configured to
      respond.</para>-->

    <sect2 id="svn-ch-6-sect-2.1">
      <title>Solicitudes y Respuestas</title>
      <!--REMOVE:<title>Requests and Responses</title>-->

      <para>El cliente Subversion insume la mayor parte de su tiempo
        manejando copias de trabajo. No obstante, cuando necesita
        información del repositorio efectúa una solicitud a través de
        la red, y el servidor responde apropiadamente. Los detalles del
        protocolo de red son ocultados por el usuario; el cliente<!--TODO: "The details of the network protocol are hidden from the user" son ocultados por el usuario o son ocultados al usuario?-->
        intenta acceder a una URL, y dependiendo del esquema URL,
        utiliza un protocolo particular para contactar al servidor
        (ver <xref linkend="svn-ch-2-sidebar-1"/>). Los usuarios pueden
        ejecutar <command>svn --version</command> para ver que esquemas
        URL y protocolos que comprende el cliente.</para>
        
      <!--REMOVE:<para>The Subversion client spends most of its time managing
        working copies.  When it needs information from a repository,
        however, it makes a network request, and the server responds
        with an appropriate answer.  The details of the network
        protocol are hidden from the user; the client attempts to
        access a URL, and depending on the URL schema, a particular
        protocol is used to contact the server (see <xref
        linkend="svn-ch-2-sidebar-1"/>).  Users can run <command>svn
        -version</command> to see which URL schemas and protocols the
        client knows how to use.</para>-->

      <para>Cuando el proceso del servidor recibe una solicitud
        del cliente, típicamente demanda que el cliente se
        identifique. Este solicita la autenticación al cliente <!--TODO: "It issues an authentication challenge to the cliente"-->,
        y el cliente responde proporcionando las <firstterm>credenciales</firstterm> al servidor.
        Una vez completado ésto,<!--TODO: "Once authentication is complete"--> el servidor responde con
        la información que el cliente solicitó originalmente. Observe
        que este método se diferencia de sistemas como CVS, dónde el
        cliente por cuenta propia <!--TODO: apropiada? "pre-emptively" no sé que significa?-->ofrece las
        credenciales (<quote>de acceso al sistema</quote>), antes de realizar 
        una solicitud. En Subversion, el servidor <quote>exige tomar</quote><!-- TODO: pulls? --> las credenciales
        a través de la negociación con el cliente en el momento apropiado,
        en lugar de que el cliente las <quote>impulse</quote><!--TODO: pushing?-->.
        Esto asegura<!--TODO: "This makes certain"--> operaciones más elegantes. Por ejemplo,
        si se configura un servidor para que permita acceso de lectura
        al repositorio a todo el mundo, nunca demandará a un cliente
        que se autentique cuando intente realizar un <command>svn checkout</command>.</para>
        
      <!--REMOVE:<para>When the server process receives a client request, it
        typically demands that the client identify itself.  It issues
        an authentication challenge to the client, and the client
        responds by providing <firstterm>credentials</firstterm> back
        to the server.  Once authentication is complete, the server
        responds with the original information the client asked for.
        Notice that this system is different from systems like CVS,
        where the client pre-emptively offers credentials (<quote>logs
        in</quote>) to the server before ever making a request.  In
        Subversion, the server <quote>pulls</quote> credentials by
        challenging the client at the appropriate moment, rather than
        the client <quote>pushing</quote> them.  This makes certain
        operations more elegant.  For example, if a server is
        configured to allow anyone in the world to read a repository,
        then the server will never issue an authentication challenge
        when a client attempts to <command>svn
        checkout</command>.</para>-->

      <para>Si la solicitud de red del cliente escribe datos nuevos
        en el repositorio (por ejemplo: <command>svn commit</command>), un nuevo
        árbol de revisión es creado. Si la solicitud del cliente fue
        autenticada, el nombre del usuario es guardado como valor de la
        propiedad <literal>svn:author</literal> en la nueva revisión
        (ver <xref linkend="svn-ch-5-sect-1.2"/>). Si el cliente no
        fue autenticado (en otras palabras, si el servidor nunca
        promulgó la autenticación), la propiedad <literal>svn:author</literal>
        de la revisión está en blanco.<footnote><para>Este problema es actualmente
        una FAQ, como resultado de una configuración equivocada de la
        instalación.</para></footnote></para>
    
      <!--REMOVE:<para>If the client's network request writes new data to the
        repository (e.g. <command>svn commit</command>), then a new
        revision tree is created.  If the client's request was
        authenticated, then the authenticated user's name is stored as
        the value of the <literal>svn:author</literal> property on the
        new revision (see <xref linkend="svn-ch-5-sect-1.2"/>).  If
        the client was not authenticated (in other words, the server
        never issued an authentication challenge), then the revision's
        <literal>svn:author</literal> property is empty.
        <footnote><para>This problem is actually a FAQ, resulting from
        a misconfigured server setup.</para></footnote></para>-->

    </sect2>

    <sect2 id="svn-ch-6-sect-2.2">
      <title>Client Credentials Caching</title><!--TODO: Cómo traducir "Caching"?-->

      <para>Muchos servidores son configurados para requerir
        autenticación por cada solicitud que reciban. Esto puede
        convertirse en una gran molestia para los usuarios, quienes son
        forzados a escribir sus contraseñas una y otra vez.</para>
        
      <!--REMOVE:<para>Many servers are configured to require authentication on
        every request.  This can become a big annoyance to users, who
        are forced to type their passwords over and over again.</para>-->

      <para>Afortunadamente, el cliente Subversion ha remediado ésto: un
        sistema incorporado para ocultar las credenciales en el disco.
        Por defecto, en el momento en que el cliente se autentica
        satisfactoriamente con un servidor, éste guarda las credenciales
        en el área de configuración de ejecución privada del usuario&mdash; en
        <filename>~/.subversion/auth/</filename> en los sistemas tipo
        Unix o <filename>%APPDATA%/Subversion/auth/</filename> en Windows.
        (El área de ejecución es cubierto con mayor detalle en <xref
        linkend="svn-ch-7-sect-1"/>.) Con éxito las credenciales son
        ocultadas en el disco, encerradas en una combinación de hostname,<!--TODO: hostname? ORCA dice: "nombre de anfitrión", pero resulta más que confuso a mi entender-->
        puerto y realm<!--TODO: realm? reino-esfera-par de usuario/clave?--> de autenticación.</para>

      <!--REMOVE:<para>Happily, the Subversion client has a remedy for this: a
        built-in system for caching authentication credentials on
        disk.  By default, whenever the commandline client
        successfully authenticates itself to a server, it saves the
        credentials in the user's private runtime configuration
        area&mdash;in <filename>~/.subversion/auth/</filename> on
        Unix-like systems or
        <filename>%APPDATA%/Subversion/auth/</filename> on Windows.
        (The runtime area is covered in more detail in <xref
        linkend="svn-ch-7-sect-1"/>.)  Successful credentials are
        cached on disk, keyed on a combination of hostname, port, and
        authentication realm.</para>--> 

      <para>Cuando el cliente recibe la solicitud para que se autentique,<!--TODO: When the cliente receives an authentication challenge-->
        primero busca las credenciales apropiadas en el caché de disco;
        sino existen, o si las credenciales fallan en la autenticación,
        el cliente simplemente pregunta al usuario por la información.</para>
      
      <!--REMOVE:<para>When the client receives an authentication challenge, it
        first looks for the appropriate credentials in the disk cache;
        if not present, or if the cached credentials fail to
        authenticate, then the client simply prompts the user for the
        information.</para>-->

      <para>Las personas que sufren de paranoia sobre asuntos de
        seguridad<!--TODO: The security-paranoid people--> pueden estar pensando,
        <quote>Contraseñas ocultas en el disco? Eso es terrible!</quote> Pero
        por favor conserve la calma. Primero, el área de caché <!--TODO: caching area--><filename>auth/</filename>
        se encuentra protegida por permisos<!--TODO: permission-protected--> a fin de que sólo el
        usuario (dueño) puede leer la información que se encuentra en
        ella, evitando que otros puedan acceder.<!--TODO: "so that only the user (owner) can read data from it, not the world at large."--> Si
        eso no es lo suficientemente seguro para usted, puede deshabilitar
        el caché de credenciales.<!--TODO: disable credential caching--> Para
        lograrlo, sólo basta con un único comando, pasando la opción
        <option>--no-auth-cache</option>:</para>
      
      <!--REMOVE:<para>The security-paranoid people may be thinking to
        themselves, <quote>Caching passwords on disk?  That's
        terrible!  You should never do that!</quote>  But please remain
        calm.  First, the <filename>auth/</filename> caching area is
        permission-protected so that only the user (owner) can read
        data from it, not the world at large.  If that's still not
        safe enough for you, you can disable credential caching.  To
        disable caching for a single command, pass the
        <option>-no-auth-cache</option> option:</para>-->

<screen>
$ svn commit -F log_msg.txt --no-auth-cache
Authentication realm: &lt;svn://host.example.com:3690&gt; example realm
Username:  joe
Password for 'joe':

Adding         newfile
Transmitting file data .
Committed revision 2324.

# password was not cached, so a second commit still prompts us

$ svn rm newfile
$ svn commit -F new_msg.txt
Authentication realm: &lt;svn://host.example.com:3690&gt; example realm
Username:  joe
[...]
</screen>

      <para>O, si usted desea deshabilitar el caché de credenciales en forma
        permanente, puede editar su archivo de configuración <filename>config</filename>
        (ubicado dentro del directorio <filename>auth/</filename>).
        Simplemente coloque <literal>no</literal> a <literal>store-auth-creds</literal>,
        y las credenciales no serán guardadas en el caché nunca más.</para>
      
      <!--REMOVE:<para>Or, if you want to disable credential caching permanently,
        you can edit your runtime <filename>config</filename> file
        (located next to the <filename>auth/</filename> directory).
        Simply set <literal>store-auth-creds</literal> to
        <literal>no</literal>, and no credentials will be cached on
        disk, ever.</para>-->

<screen>
[auth]
store-auth-creds = no
</screen>

      <para>Algunas veces los usuario desearán eliminar credenciales
        específicas del caché de disco.<!--TODO: disk cache?--> Para hacer ésto, necesitará
        navegar dentro del área <filename>auth/</filename> y eliminar
        el archivo de caché <!--TODO: cache?-->apropiado en forma manual. Las credenciales
        son almacenadas en el área de caché en archivos individuales; si
        usted mira dentro de cada archivo, verá claves y valores. La clave
        <literal>svn:realmstreng</literal> describe el "realm"<!--TODO: realm?--> servidor
        particular con el que que el archivo es asociado:<!--TODO: "...key describes
        the particular server realm that the file is associated
        with:"--></para>
        
      <!--REMOVE:<para>Sometimes users will want to remove specific credentials
        from the disk cache.  To do this, you need to navigate into
        the <filename>auth/</filename> area and manually delete the
        appropriate cache file.  Credentials are cached in individual
        files;  if you look inside each file, you will see keys and
        values.  The <literal>svn:realmstring</literal> key describes
        the particular server realm that the file is associated
        with:</para>-->

<screen>
$ ls ~/.subversion/auth/svn.simple/
5671adf2865e267db74f09ba6f872c28        
3893ed123b39500bca8a0b382839198e
5c3c22968347b390f349ff340196ed39

$ cat ~/.subversion/auth/svn.simple/5671adf2865e267db74f09ba6f872c28

K 8
username
V 3
joe
K 8
password
V 4
blah
K 15
svn:realmstring
V 45
&lt;https://svn.domain.com:443&gt; Joe's repository
END
</screen>

      <para>Una vez que haya localizado el archivo de caché apropiado,
        sencillamente elimínelo.</para>
      <!--REMOVE:<para>Once you have located the proper cache file, just delete
        it.</para>-->

      <para>Una última palabra acerca del comportamiento de autenticación
        del cliente: es necesaria una pequeña explicación respecto de
        las opciones <option>--username</option> y <option>--pasword</option>.
        Muchos sub-comandos del cliente aceptan estas opciones; sin embargo,
        es importante comprender que la utilización de las mismas
        <emphasis>no</emphasis> envía automáticamente las credenciales
        al servidor. Como se dijo anteriormente, el servidor
        <quote>exige tomar</quote><!--TODO: pulls?--> las credenciales del cliente cuando lo
        considera necesario; el cliente no puede <quote>impulsarlas</quote><!--TODO: push?-->
        a voluntad. Si un usuario y/o contraseña son pasados como opción,
        ellos serán presentados al servidor <emphasis>sólo</emphasis> si este
        así lo demanda.
        
          <footnote><para>Una vez más, un error frecuente es
            configurar de forma equivocada el servidor para que este
            nunca emita una demanda de autenticación. Cuando los usuarios pasen
            la opción <option>--username</option> y <option>--pasword</option>
            al cliente, ellos se sorprenderán al ver que éstos nunca son
            utilizados, es decir, a pesar de aparecer una nueva revisión, ha sido enviada
            anónimamente!<!--TODO: new revisions still appear to have been commited anonymously!--></para></footnote>
        
      Típicamente, estas opciones son utilizadas cuando:
      </para>
      
      <!--REMOVE:<para>One last word about client authentication behavior: a bit
        of explanation about the <option>-username</option> and
        <option>-password</option> options is needed.  Many client
        subcommands accept these options; however it is important to
        understand using these options <emphasis>does not</emphasis>
        automatically send credentials to the server.  As discussed
        earlier, the server <quote>pulls</quote> credentials from the
        client when it deems necessary; the client cannot
        <quote>push</quote> them at will.  If a username and/or
        password are passed as options, they will
        <emphasis>only</emphasis> be presented to the server if the
        server requests them.

          <footnote><para>Again, a common mistake is to misconfigure a
           server so that it never issues an authentication challenge.
           When users pass <option>-username</option> and
           <option>-password</option> options to the client,
           they're surprised to see that they're never used, i.e. new
           revisions still appear to have been committed
           anonymously!</para></footnote>
        
        Typically, these options are used when:
      </para>-->

      <itemizedlist>
        <listitem><para>el usuario desea autenticarse con un
            nombre diferente a su usuario de sistema, o</para>
        </listitem>
        <listitem><para>un guión desea autenticarse sin utilizar
            las credenciales del caché.<!--TODO: using cached credentials--></para>
        </listitem>
      </itemizedlist>
      
      <!--REMOVE:<itemizedlist>
        <listitem><para>the user wants to authenticate as a
            different user than her system login name, or</para>
        </listitem>
        <listitem><para>a script wants to authenticate without
            using cached credentials.</para>
        </listitem>
      </itemizedlist>-->
          
      <para>Aquí hay un resumen final que describe como se comporta un
        cliente Subversion cuando recibe la demanda de autenticación:</para>
        
      <!--REMOVE:<para>Here is a final summary that describes how a Subversion
        client behaves when it receives an authentication
        challenge:</para>-->


      <orderedlist>
        <listitem>
          <para>Verifica si el usuario ha especificado algunas credenciales
            como opción de línea de comando, a través de la opción
            <option>--username</option> y/o <option>--pasword</option>. Sino, o
            si esas opciones no pertenecen a una autenticación válida, entonces</para>
        </listitem>

        <listitem>
          <para>Busca en el "realm" del servidor en el área de ejecución
            <filename>auth/</filename>, para ver si el usuario ya dispone de credenciales
            apropiadas en el caché. Sino, o si las credenciales del caché fallan
             en la autenticación, entonces</para>
        </listitem>

        <listitem>
          <para>Recurre a preguntarle al usuario.</para>
        </listitem>
      </orderedlist>
      <!--REMOVE<orderedlist>
        <listitem>
          <para>Check whether the user specified any credentials as
            commandline options, via <option>-username</option>
            and/or <option>-password</option>.  If not, or if these
            options fail to authenticate successfully, then</para>
        </listitem>

        <listitem>
          <para>Look up the server's realm in the runtime
            <filename>auth/</filename> area, to see if the user already
            has the appropriate credentials cached.  If not, or if the
            cached credentials fail to authenticate, then</para>
        </listitem>

        <listitem>
          <para>Resort to prompting the user.</para>
        </listitem>
      </orderedlist>-->

      <para>Si el cliente se autentica correctamente a través de alguno
        de los métodos listados aquí arriba, éste intentará guardar en
        las credenciales en el caché de disco (a no ser que el usuario haya
        deshabilitado ese funcionamiento, como hemos mencionado
        anteriormente.)</para>
      
      <!--REMOVE:<para>If the client successfully authenticates by any of the
        methods listed above, it will attempt to cache the credentials
        on disk (unless the user has disabled this behavior, as
        mentioned earlier.)</para>-->

    </sect2>

  </sect1>


  <!-- ================================================================= -->
  <!-- ======================== SECTION 3 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-6-sect-3">
    
    <title>svnserve, un servidor personalizado</title>
    <!--REMOVE:<title>svnserve, a custom server</title>-->

    <para>El programa <command>svnserve</command> es un servidor ligero,
      capaz de hablar a clientes sobre TCP/IP utilizando un
      protocolo con estado <!--TODO: stateful? matiene el estado de la
      interaccion o sesion. como se traduece?--> personalizado.
      Los clientes contactan un servidor <command>svnserve</command>
      utilizando URLs que comienzan con el esquema <literal>svn://</literal>
      o <literal>svn+ssh://</literal>. Esta sección explica las
      diferentes maneras de ejecutar un <command>svnserve</command>, cómo
      los clientes se autentican ellos mismos con el servidor, y cómo
      se configura un control de acceso apropiado a su repositorio.</para>

    <!--REMOVE:<para>The <command>svnserve</command> program is a lightweight
      server, capable of speaking to clients over TCP/IP using a
      custom, stateful protocol.  Clients contact an
      <command>svnserve</command> server by using URLs that begin with
      the <literal>svn://</literal> or <literal>svn+ssh://</literal>
      schema.  This section will explain the different ways of running
      <command>svnserve</command>, how clients authenticate themselves
      to the server, and how to configure appropriate access control
      to your repositories.</para>-->

    <sect2 id="svn-ch-6-sect-3.1">
      <title>Invocando el Servidor</title>
      <!--REMOVE:<title>Invoking the Server</title>-->

      <para>Existen unas cuantas maneras diferentes de invocar
        el programa <command>svnserve</command>. Si se lo invoca
        sin argumentos, usted no verá nada más que un mensaje de
        ayuda. No obstante, si planea que <command>inetd</command>
        dispare el proceso, puede pasar la opción <option>-i</option>
        (<option>--inetd</option>):</para>
        
      <!--REMOVE:<para>There a few different ways to invoke the
        <command>svnserve</command> program.  If invoked with no
        options, you'll see nothing but a help message.  However, if
        you're planning to have <command>inetd</command> launch the
        process, then you can pass the <option>-i</option>
        (<option>-inetd</option>) option:</para>-->

<screen>
$ svnserve -i
( success ( 1 2 ( ANONYMOUS ) ( edit-pipeline ) ) )
</screen>

      <para>Cuando es invocado con la opción <option>--inetd</option>,
        <command>svnserve</command> intenta comunicarse con un
        cliente Subversion a través de <emphasis>stdin</emphasis> y
        <emphasis>stdout</emphasis> utilizando un protocolo
        personalizado. Este es un comportamiento estándar de los
        programas que son ejecutados a través de <command>inetd</command>.
        El IANA <!--TODO: se agrega alguna nota sobre el IANA?-->
        ha reservado el puerto 3690 para el protocolo
        Subversion, por lo tanto en un sistema tipo Unix usted puede
        agregar líneas a <filename>/etc/services</filename> como éstas
        (si es que no existen todavía):</para>
        
      <!--REMOVE:<para>When invoked with the <option>-inetd</option> option,
        <command>svnserve</command> attempts to speak with a
        Subversion client via <emphasis>stdin</emphasis> and
        <emphasis>stdout</emphasis> using a custom protocol.  This is
        the standard behavior for a program being run via
        <command>inetd</command>.  The IANA has reserved port 3690
        for the Subversion protocol, so on a Unix-like system you can
        add lines to <filename>/etc/services</filename> like these (if
        they don't already exist):</para>-->

<screen>
svn           3690/tcp   # Subversion
svn           3690/udp   # Subversion
</screen>

      <para>Y si su sistema utiliza un demonio <command>inetd</command>
        tipo Unix clásico, puede agregar esta línea a
        <filename>/etc/inetd.conf</filename>:</para>
      
      <!--REMOVE:<para>And if your system is using a classic Unix-like
        <command>inetd</command> daemon, you can add this line to
        <filename>/etc/inetd.conf</filename>:</para>-->

<screen>
svn stream tcp nowait svnowner /usr/local/bin/svnserve svnserve -i
</screen>

      <para>Asegúrese que <quote>svnowner</quote> es un usuario que
       posee permisos apropiados para acceder a su repositorio.
       Ahora, cuando una conexión cliente ingrese a su servidor en
       el puerto 3690, <command>inetd</command> disparará un proceso
       <command>svnserve</command> para servirlo.</para>
       
      <!--REMOVE:<para>Make sure <quote>svnowner</quote> is a user which has
        appropriate permissions to access your repositories.  Now, when
        a client connection comes into your server on port 3690,
        <command>inetd</command> will spawn an
        <command>svnserve</command> process to service it.  </para>-->

      <para>Una segunda opción es ejecutar <command>svnserve</command>
        un proceso <quote>demonio</quote> independiente. Para esto,
        utilice la opción <option>-d</option>:</para>
      
      <!--REMOVE:<para>A second option is to run <command>svnserve</command> as a
        standalone <quote>daemon</quote> process.  Use the
        <option>-d</option> option for this:</para>-->

        <screen>
$ svnserve -d
$               # svnserve is now running, listening on port 3690
</screen>

      <para>Cuando <command>svnserve</command> ejecute en modo demonio,
        usted puede utilizar las opciones <option>--listen-port=</option>
        y <option>--listen-host=</option> para personalizar el puerto
        y nombre exacto en el cual <quote>escuchará</quote>.
        <!--TODO: port and hostname to <quote>bind</quote>--></para>
      
      <!--REMOVE:<para>When running <command>svnserve</command> in daemon mode,
        you can use the <option>-listen-port=</option> and
        <option>-listen-host=</option> options to customize the exact
        port and hostname to <quote>bind</quote> to.</para>-->

      <para>Aún queda una tercera forma de invocar a <command>svnserve</command>,
        y esa es en <quote>modo túnel</quote>, con la opción <option>-t</option>.
        Este modo supone que un programa de servicio remoto tal como
        <command>RSH</command> o <command>SSH</command> ha autenticado un
        cliente exitosamente y ahora está invocando un proceso privado
        <command>svnserve</command> <emphasis>como tal usuario</emphasis>.
        El programa <command>svnserve</command> se comporta normalmente
        (comunicándose a través de <emphasis>stdin</emphasis> y
        <emphasis>stdout</emphasis>), y asume que el tráfico está siendo
        redirigido automáticamente a través de algún tipo de túnel
        de vuelta al cliente. Cuando <command>svnserve</command> es
        invocado por un agente túnel como éste, está seguro que el usuario
        autenticado posee acceso total de lectura y escritura a los archivos
        de la base de datos del repositorio. (Ver <xref
        linkend="svn-ch-6-sidebar-1"/>.) Esencialmente es lo mismo que
        un usuario local accediendo al repositorio a través de
        las URLs <literal>file:///</literal>.</para>
                
      <!--REMOVE: <para>There's still a third way to invoke
        <command>svnserve</command>, and that's in <quote>tunnel
        mode</quote>, with the <option>-t</option> option.  This mode
        assumes that a remote-service program such as
        <command>RSH</command> or <command>SSH</command> has
        successfully authenticated a user and is now invoking a
        private <command>svnserve</command> process <emphasis>as that
        user</emphasis>.  The <command>svnserve</command> program
        behaves normally (communicating via <emphasis>stdin</emphasis>
        and <emphasis>stdout</emphasis>), and assumes that the traffic
        is being automatically redirected over some sort of tunnel
        back to the client.  When <command>svnserve</command> is
        invoked by a tunnel agent like this, be sure that the
        authenticated user has full read and write access to the
        repository database files. (See <xref
        linkend="svn-ch-6-sidebar-1"/>.)  It's essentially the same as
        a local user accessing the repository via
        <literal>file:///</literal> URLs. </para>-->

      <sidebar id="svn-ch-6-sidebar-1">
        <title>Servidores y Permisos:  Una Palabra de Advertencia</title>        
        <!--REMOVE:<title>Servers and Permissions:  A Word of Warning</title>-->

        <para>Primero, recuerde que un repositorio Subversion es una
          colección de archivos de la base de datos BerkeleyDB; cualquier
          proceso que acceda al repositorio en forma directa necesita tener
          permisos apropiados de lectura y escritura sobre el repositorio
          entero. Si usted no es cuidadoso, puede causarle grandes
          dolores de cabeza. Siéntase seguro de haber leído <xref
          linkend="svn-ch-6-sect-5"/>.</para>
          
        <!--REMOVE: <para>First, remember that a Subversion repository is a
          collection of BerkeleyDB database files; any process which
          accesses the repository directly needs to have proper read
          and write permissions on the entire repository.  If you're
          not careful, this can lead to a number of headaches.  Be
          sure to read <xref linkend="svn-ch-6-sect-5"/>.</para>-->

      <para>En segundo lugar, cuando configure <command>svnserve</command>,
        Apache <command>httpd</command>, o cualquier otro proceso servidor,
        tenga en mente que podrá no querer ejecutar el proceso de servidor
        como el usuario <literal>root</literal> (o como cualquier otro usuario
        que tenga permisos ilimitados). Dependiendo con el propietario y los
        permisos del repositorio con los que lo haya exportado, con
        frecuencia es prudente utilizar un usuario diferente&mdash;quizás
        personalizado&mdash;. Por ejemplo, muchos administradores crean un
        usuario llamado <literal>svn</literal>, otorgándole la propiedad y
        derechos exclusivos sobre los repositorios de Subversion exportados,
        y únicamente se ejecutará los procesos de servidor con ese usuario.</para>
      
      <!--REMOVE:<para>Secondly, when configuring <command>svnserve</command>, Apache
          <command>httpd</command>, or any other server process, keep in
          mind that you might not want to launch the server process as
          the user <literal>root</literal> (or as any other user with
          unlimited permissions).  Depending on the ownership and
          permissions of the repositories you're exporting, it's often
          prudent to use a different&mdash;perhaps custom&mdash;user.
          For example, many administrators create a new user named
          <literal>svn</literal>, grant that user exclusive ownership
          and rights to the exported Subversion repositories, and only
          run their server processes as that user.</para>-->
      </sidebar>

      <para>Una vez el programa <command>svnserve</command> se esté
        ejecutando, hace que cada repositorio en su sistema se
        encuentre disponibles a la red. Un cliente necesita especificar
        una ruta <emphasis>absoluta</emphasis> en la URL del repositorio.
        Por ejemplo, si un repositorio se encuentra ubicado en
        <filename>/usr/local/repositories/project1</filename>, el cliente
        accederá a través de <systemitem
        class="url">svn://host.example.com/usr/local/repositories/project1
        </systemitem>. Para incrementar la seguridad, usted puede pasar
        la opción <option>-r</option> a <command>svnserve</command>,
        que limita a exportar sólo los repositorios debajo de esa
        ruta:</para>
        
      <!--REMOVE:<para>Once the <command>svnserve</command> program is running,
        it makes every repository on your system available to the
        network.  A client needs to specify an
        <emphasis>absolute</emphasis> path in the repository URL.  For
        example, if a repository is located at
        <filename>/usr/local/repositories/project1</filename>, then a
        client would reach it via <systemitem
        class="url">svn://host.example.com/usr/local/repositories/project1
        </systemitem>.  To increase security, you can pass the
        <option>-r</option> option to <command>svnserve</command>,
        which restricts it to exporting only repositories below that
        path:</para>-->
      
<screen>
$ svnserve -d -r /usr/local/repositories
&hellip;
</screen>

      <para>En efecto, utilizando la opción <option>-r</option>
        modifica la ubicación que el programa tratará como raíz del
        espacio de sistema de archivos remoto. En consecuencia,
        los clientes utilizarán URLs que tengan la porción que
        le ha sido removida de la ruta, dejando URLs mucho más cortas
        (y mucho menos reveladoras):</para>
      
      <!--REMOVE:<para>Using the <option>-r</option> option effectively
        modifies the location that the program treats as the root of
        the remote filesystem space.  Clients then use URLs that
        have that path portion removed from them, leaving much
        shorter (and much less revealing) URLs:</para>-->
      
<screen>
$ svn checkout svn://host.example.com/project1
&hellip;
</screen>
 
    </sect2>

    <sect2 id="svn-ch-6-sect-3.2">
      <title>Autenticación y autorización integradas</title>
      <!--REMOVE:<title>Built-in authentication and authorization</title>-->

      <para>Cuando un cliente se conecta a un proceso
      <command>svnserve</command>, las siguientes cosas suceden:</para>
      
      <!--REMOVE:<para>When a client connects to an <command>svnserve</command>
        process, the following things happen:</para>-->

      <itemizedlist>
        <listitem><para>El cliente selecciona un repositorio
          específico.</para></listitem>

        <listitem><para>El servidor procesa el archivo
        <filename>conf/svnserve.conf</filename> del repositorio, y comienza
        a poner en ejecución cualquier política de autenticación y autorización
        definida en éste.</para></listitem>

        <listitem><para>Dependiendo de la situación y las políticas de autorización,</para>

          <itemizedlist>
            <listitem><para>se le puede permitir al cliente realizar pedidos de forma anónima,
              y sin haber recibido la demanda de autenticación, O</para></listitem>

            <listitem><para>el cliente puede ser consultado por la autenticación
              en cualquier momento, O</para></listitem>

            <listitem><para>si opera en el <quote>modo túnel</quote>, el cliente
              se anuncia a sí mismo que ya ha sido autenticado externamente.
              </para></listitem>
          </itemizedlist>
        </listitem>

      </itemizedlist>

      <!--REMOVE:
      <itemizedlist>
        <listitem><para>The client selects a specific
        repository.</para></listitem>

        <listitem><para>The server processes the repository's
        <filename>conf/svnserve.conf</filename> file, and begins to
        enforce any authentication and authorization policies defined
        therein.</para></listitem>

        <listitem><para>Depending on the situation and authorization
        policies,</para>

          <itemizedlist>
            <listitem><para>the client may be allowed to make requests
              anonymously, without ever receiving an authentication
              challenge, OR</para></listitem>

            <listitem><para>the client may be challenged for
              authentication at any time, OR</para></listitem>

            <listitem><para>if operating in <quote>tunnel
              mode</quote>, the client will declare itself to be
              already externally authenticated.</para></listitem>
          </itemizedlist>
        </listitem>

      </itemizedlist>
      -->

      <para>En el momento de escribir estas líneas, el servidor
        sólo sabe cómo realizar la autenticación por CRAM-MD5
        <footnote><para>Vea el RFC 2195.</para></footnote>.
        En esencia, el servidor envía unos pocos datos al cliente. El
        cliente usa el algoritmo hash MD5 para crear una huella
        digital de los datos y la palabra clave combinados, y envía
        la huella digital como respuesta. El servidor realiza el
        mismo cálculo con la palabra clave almacenada para verificar
        que el resultado es idéntico.  <emphasis>En ningún momento
        el password real viaja a través de la red.</emphasis></para>

      <para>También es posible, por supuesto, que el cliente se
        autentifique externamente vía agente de túnel <!--
        TODO tunnel agent suena muy mal -->, como por ejemplo
        <command>SSH</command>.  En este caso, el servidor
        simplemente examina el usuario bajo el cual se está
        ejecutando, y lo usa durante la autenticación.</para>

      <para>Tal y como habrá imaginado, el fichero
        <filename>svnserve.conf</filename> es el mecanismo
        central de un repositorio para controlar las políticas de
        autenticación y autorización. El fichero sigue el mismo
        formato que otros ficheros de configuración (vea <xref
        linkend="svn-ch-7-sect-1"/>): los nombres de sección
        están enmarcados por corchetes (<literal>[</literal>
        y <literal>]</literal>), los comentarios comienzan
        con almohadillas (<literal>#</literal>), y cada sección
        contiene variables específicas que pueden ser modificadas
        (<literal>variable = valor</literal>). Démonos un paseo
        por este fichero para aprender a usarlas.</para>

      <sect3 id="svn-ch-6-sect-3.2.1">
        <title>Crear un fichero 'users' y <!-- TODO dejo por
          ahora como realm como hizo Federico. -->realm</title>

        <para>Por ahora, la sección <literal>[general]</literal> de
          <filename>svnserve.conf</filename> tiene todas las
          variables que usted necesita.  Comencemos definiendo un
          fichero que contenga nombres de usuario y palabras clave,
          y una realm de autenticación:</para>

<screen>
[general]
password-db = userfile
realm = example realm
</screen>

        <para>El nombre <literal>realm</literal> es algo que
          define usted.  Le dice a los clientes a qué tipo de
          <quote>espacio de nombres de autenticación</quote> se están
          conectando; el cliente de Subversion lo muestra durante
          las preguntas <!-- TODO sustitución no muy ingeniosa
          de prompt, que esta vez no es el prompt de la línea de
          comando... -->de autenticación, y lo usa como palabra clave
          (junto con el nombre y puerto del servidor) para cachear
          <!-- TODO arggh, cache --> las credenciales en disco
          (vea <xref linkend="svn-ch-6-sect-2.2"/>.)  La variable
          <literal>password-db</literal> apunta a un fichero separado
          que contiene una lista de nombres de usuario y claves,
          usando el mismo formato familiar.  Por ejemplo:</para>

<screen>
[users]
harry = foopassword
sally = barpassword
</screen>

        <para>El valor de <literal>password-db</literal> puede ser
          una ruta absoluta o relativa al fichero de usuarios. Para
          muchos administradores, es sencillo guardar el
          fichero justo en el área <filename>conf/</filename> del
          repositorio, junto a <filename>svnserve.conf</filename>.
          Por otra parte, es posible querer compartir el mismo
          fichero de usuarios entre dos o más repositorios; en este
          caso, el fichero probablemente debería ubicarse en un lugar
          más público.  Los repositorios que compartan el fichero
          de usuarios también deberían estar configurados para
          usar la misma realm, dado que la lista de usuarios define
          esencialmente un realm de autenticación. Esté donde esté el
          fichero, asegúrese de ajustar apropiadamente los permisos
          de lectura y escritura. Si sabe bajo qué usuario(s) se
          ejecutará <command>svnserve</command>, restrinja el acceso
          de lectura al fichero correspondientemente.</para>

      </sect3>

      <sect3 id="svn-ch-6-sect-3.2.2">
        <title>Activar control de acceso</title>

        <para>Hay dos variables más en el fichero
          <filename>svnserve.conf</filename>: determinan qué
          pueden hacer los usuarios autenticados y sin autenticar
          (anónimos). Las variables <literal>anon-access</literal>
          y <literal>auth-access</literal> pueden tener los valores
          <literal>none</literal>, <literal>read</literal>,
          o <literal>write</literal>.  Poner el valor a
          <literal>none</literal> restringe el acceso de todo tipo;
          <literal>read</literal> permite únicamente el acceso de
          sólo lectura al repositorio, y <literal>write</literal>
          permite acceso completo de lectura y escritura.
          Por ejemplo:</para>

<screen>
[general]
password-db = userfile
realm = example realm

# anonymous users can only read the repository
anon-access = read

# authenticated users can both read and write
auth-access = write
</screen>

        <para>Los parámetros del ejemplo, son de hecho los valores
          por defecto de las variables, en caso de que olvide
          definirlas. Si desea ser aun más conservativo, puede
          bloquear el acceso anónimo completamente:</para>

<screen>
[general]
password-db = userfile
realm = example realm

# anonymous users aren't allowed
anon-access = none

# authenticated users can both read and write
auth-access = write
</screen>

        <para>Fíjese que <command>svnserve</command> sólo entiende
          de control de acceso <quote>básico<!-- TODO buscar
          mejor traducción de blanket--></quote>.  Un usuario
          tiene acceso universal de lectura escritura, acceso
          universal de lectura, o ningún tipo de acceso. No hay
          control detallado del acceso a rutas específicas dentro
          del repositorio. Para muchos proyectos y equipos<!--
          TODO site != equipo-->, este nivel de control de acceso
          es más que suficiente.  No obstante, si necesita control
          de acceso por directorio, tendrá que usar Apache en
          lugar de <command>svnserve</command> como su proceso
          servidor.</para>

      </sect3>

    </sect2>
    
    <sect2 id="svn-ch-6-sect-3.3">
      <title>Autenticación y autorización SSH</title>

      <para>La autenticación de serie de <command>svnserve</command>
        puede ser muy útil, porque evita tener que crear cuentas
        de sistema reales. Por otro lado, algunos administradores
        ya tienen entornos de autenticación SSH bien establecidos
        y funcionando. En estas situaciones, todos los usuarios
        del proyecto tienen cuentas en el sistema y la habilidad
        para conectarse con SSH <!-- TODO quitada la expresión con
        "quote" por no tener traducción directa--> a la máquina
        servidora.</para>

      <para>Es fácil usar SSH junto con
        <command>svnserve</command>. El cliente simplemente usa
        el esquema de URL <literal>svn+ssh://</literal> para
        conectar:</para>

<screen>
$ whoami
harry

$ svn list svn+ssh://host.example.com/repos/project
harry@host.example.com's password:  *****

foo
bar
baz
&hellip;
</screen>

      <para>Lo que sucede en esta situación es que el cliente de
        Subversion invoca el proceso local <command>ssh</command>,
        conectándolo con <literal>host.example.com</literal>,
        autenticándose como el usuario <literal>juan</literal>, y
        entonces lanzando un proceso <command>svnserve</command>
        privado en la máquina remota, que se ejecuta como
        el usuario <literal>juan</literal>.  El comando
        <command>svnserve</command> se invoca en modo túnel
        (<option>-t</option>) y todo el protocolo de red es
        canalizado a través <quote>tunneled</quote> de la conexión
        cifrada por <command>ssh</command>, el agente del túnel.
        <command>svnserve</command> se da cuenta de que se está
        ejecutando como el usuario <literal>juan</literal>, y si
        el cliente realiza cambios en el repositorio, el nombre de
        usuario autenticado será usado para atribuir la autoría de
        la nueva revisión.</para>

      <para>Cuando se usa un túnel, la autorización es principalmente
        controlada por los permisos del sistema operativo a los
        ficheros de la base de datos del repositorio; es casi
        igual que si Juan estuviese accediendo al repositorio
        directamente vía URL <literal>file:///</literal>. Si
        necesita que múltiples usuarios del sistema accedan al
        repositorio directamente, podría ponerlos en un mismo grupo,
        y ajustar cuidadosamente sus umasks<!-- TODO poner nota
        sobre umask y traducir?-->.  (Asegúrese de haber leído <xref
        linkend="svn-ch-6-sect-5"/>.) Pero incluso en el caso de usar
        túneles, el fichero <filename>svnserve.conf</filename>
        todavía puede ser usado para bloquear el acceso,
        simplemente usando <literal>auth-access = read</literal>
        o <literal>auth-access = none</literal>.</para>
      
      <para>Podría pensar que la historia del túnel por SSH acabaría
        aquí, pero no lo hace.  Subversion le permite
        personalizar el comportamiento de los túneles en su
        fichero de configuración <filename>config</filename>
        (vea <xref linkend="svn-ch-7-sect-1"/>.)  Por ejemplo,
        supongamos que desea usar RSH en lugar de SSH. En
        la sección <literal>[tunnels]</literal> de su fichero
        <filename>config</filename>, defina lo siguiente:</para>

<screen>
[tunnels]
rsh = rsh
</screen>

      <para>Y ahora, usted puede usar esta nueva definición de
        túnel usando un esquema URL que concuerde
        con el nombre de su nueva variable:
        <literal>svn+rsh://host/path</literal>. Cuando
        use el nuevo esquema URL, el cliente Subversion
        estará ejecutando realmente el comando <command>rsh
        host svnserve -t</command> tras las cortinas. Si
        incluye un nombre de usuario en la URL (por ejemplo,
        <literal>svn+rsh://nombreusuario@host/path</literal>) el
        cliente también lo incluirá en su comando (<command>rsh
        nombreusuario@host svnserve -t</command>.)  Pero puede
        definir nuevos esquemas de túneles mucho más elaborados
        que eso:</para>

<screen>
[tunnels]
joessh = $JOESSH /opt/alternate/ssh -p 29934
</screen>

      <para>Este ejemplo muestra varias cosas. Primero, enseña cómo
        hacer que el cliente de Subversion lance un
        binario de túnel muy específico (uno ubicado
        en <filename>/opt/alternate/ssh</filename>) con
        opciones específicas. En este caso, acceder a la
        URL <literal>svn+joessh://</literal> invocaría este
        particular binario de SSH con <option>-p 29934</option>
        como parámetro&mdash;útil si desea que el programa de túnel
        se conecte a un puerto no estándar.</para>

      <para>Segundo, enseña cómo definir una nueva variable de
        entorno personalizada que puede reemplazar el nombre de
        un programa de túnel. Modificar la variable de entorno
        <literal>SVN_SSH</literal> es un modo conveniente de
        reemplazar el agente de túneles SSH por defecto. Pero
        si necesita tener diferentes reemplazos para servidores
        diferentes, cada uno de ellos conectando quizás a un
        puerto diferente o usando un conjunto diferente de
        opciones, puede usar el mecanismo demostrado en este
        ejemplo.  Ahora, si fuese a crear la variable de entorno
        <literal>JOESSH</literal>, su valor reemplazaría el valor
        completo de la variable del túnel&mdash;se ejecutaría
        $JOESSH en lugar de <filename>/opt/alternate/ssh -p
        29934</filename>.</para>

    </sect2>

  </sect1>


  <!-- ================================================================= -->
  <!-- ======================== SECTION 4 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-6-sect-4">
    
    <title>httpd, el servidor HTTP Apache</title>

    <para>El servidor HTTP apache es un servidor de red <quote>heavy
      duty</quote> <!-- TODO ni idea --> que Subversion
      puede aprovechar. A través de un módulo propio,
      <command>httpd</command> permite servir a clientes
      repositorios Subversion por el protocolo WebDAV/DeltaV,
      el cual es una extensión sobre HTTP 1.1 (vea <systemitem
      class="url">http://www.webdav.org/</systemitem> para más
      información.)  Este protocolo coge el ubicuo protocolo
      HTTP, núcleo de la World Wide Web, y añade la capacidad de
      escritura&mdash;específicamente el versionado de la misma.
      El resultado es un sistema robusto, estandarizado, empaquetado
      convenientemente como parte del software Apache 2.0, soportado
      por numerosos sistemas operativos y productos de terceros,
      y no necesita que sus administradores de red abran otro
      puerto adicional.
      <footnote>
        <para>Realmente odian hacer eso.</para>
      </footnote>
      Si bien el servidor Apache-Subversion tiene más características
      que <command>svnserve</command>, también es más difícil de
      configurar.  La flexibilidad a menudo se paga en complejidad.
    </para>

    <para>Buena parte del texto siguiente incluye referencias a
      las directivas de configuración de Apache. Aunque
      proporcionamos algunos ejemplos que muestran el uso
      de estas directivas, describirlas con todo detalle
      está fuera del alcance de este capítulo. El equipo
      de Apache mantiene una documentación excelente,
      disponible públicamente en su página web en <systemitem
      class="url">http://httpd.apache.org</systemitem>.
      Por ejemplo, una referencia general de las directivas de
      configuración está ubicada en <systemitem class="url">
      http://httpd.apache.org/docs-2.0/mod/directives.html</systemitem>.</para>
    
    <para>También, a medida que vaya realizando cambios en su
      configuración de Apache, es probable que en alguna parte
      cometerá algún fallo. Si no está familiarizado con el
      subsistema de archivos de registro de Apache, debería dedicarle
      un tiempo. En su fichero <filename>httpd.conf</filename>
      hay directivas que especifican ubicaciones físicas de
      los archivos de registro de acceso y error generados
      por apache (las directivas <literal>CustomLog</literal>
      y <literal>ErrorLog</literal> respectivamente). El módulo
      mod_dav_svn de Subversion usa también la interfaz de registro
      de mensajes de error de Apache. Siempre puede explorar
      el contenido de esos ficheros para encontrar información
      que podría revelar la fuente de un problema difícilmente
      discernible de otro modo.</para>
    
    <sidebar>
      <title>¿Por qué Apache 2?</title>

      <para>Si usted es un administrador de sistemas, es muy probable
        que ya tenga funcionando un servidor web Apache y cuente con
        algo de experiencia con él. En el momento de escribir estas
        líneas, Apache 1.3 es de largo la versión más popular. El
        mundo ha sido algo lento en la actualización a las series
        2.X por varias razones: algunas personas temen los cambios,
        especialmente cambiar algo tan crítico como un servidor
        web.  Otras personas demandan los módulos plug-in que sólo
        funcionan con la API de Apache 1.3, y están esperando que
        sean portados a la 2.X. Sea la razón que sea, muchas personas
        comienzan a preocuparse cuando descubren por primera vez
        que el módulo Subversion de Apache está escrito para la
        API 2 de Apache.</para>

      <para>La respuesta correcta a este problema es: no se preocupe
        por ello.  Es fácil ejecutar Apache 1.3 y Apache 2
        simultáneamente; simplemente instálelos en lugares
        diferentes, y use Apache 2 como un servidor dedicado a
        Subversion que se ejecuta en un puerto diferente al 80. Los
        clientes podrán acceder al repositorio indicando el puerto
        en la URL:</para>

      <screen>
$ svn checkout http://host.example.com:7382/repos/project
&hellip;
</screen>
    </sidebar>


    <sect2 id="svn-ch-6-sect-4.1">
      <title>Requisitos previos</title>
      
      <para>Para hacer disponible su repositorio por HTTP,
        básicamente necesita cuatro componentes disponibles en dos
        paquetes. Necesita el comando <command>httpd</command>
        de Apache 2.0, el módulo DAV <command>mod_dav</command>
        que viene con él, Subversion, y el módulo
        <command>mod_dav_svn</command>, que proporciona sistemas
        de ficheros<!-- TODO == filesystem? -->, distribuido
        con Subversion.  Una vez tenga todos estos componentes,
        el proceso para hacer disponible su repositorio es tan
        simple como:</para>
      
      <itemizedlist>
        <listitem>
          <para>preparar y ejecutar httpd 2.0 con el módulo mod_dav,</para>
        </listitem>
        <listitem>
          <para>instalar el plug-in mod_dav_svn para mod_dav, el cual
            usa las librerías de Subversion para acceder a un
            repositorio, y</para>
        </listitem>
        <listitem>
          <para>configurar su fichero <filename>httpd.conf</filename>
            para exportar (o exponer) el repositorio.</para>
        </listitem>
      </itemizedlist>
      
      <para>Puede realizar los dos primeros pasos ya sea compilando
        <command>httpd</command> y Subversion a partir del código
        fuente, o instalando paquetes binarios precompilados en su
        sistema. Puede encontrar la información más actualizada sobre
        cómo compilar Subversion para su uso con el servidor HTTP
        Apache, al igual que cómo compilar y configurar Apache para
        este propósito, en el fichero <filename>INSTALL</filename>
        en el directorio raíz del código fuente de Subversion.</para>
      
    </sect2>

    <sect2 id="svn-ch-6-sect-4.2">
      <title>Configuración básica de Apache</title>
      
      <para>Una vez tenga todos los componentes necesarios instalados
        en su sistema, todo lo que queda por hacer
        es configurar Apache mediante su fichero
        <filename>httpd.conf</filename>. Ordene a Apache que
        cargue el módulo mod_dav_svn module usando la directiva
        <literal>LoadModule</literal>. La directiva debe preceder
        cualquier otro elemento de configuración relacionado con
        Subversion. Si su Apache fue instalado usando el esquema
        por defecto, su módulo <command>mod_dav_svn</command>
        debería haber sido instalado en el subdirectorio
        <filename>modules</filename> de la instalación (a menudo
        <filename>/usr/local/apache2</filename>). La directiva
        <literal>LoadModule</literal> tiene una sintaxis sencilla,
        relacionando el nombre de un módulo con la ubicación de
        una librería dinámica en disco: disk:</para>
    
        <screen>
LoadModule dav_svn_module     modules/mod_dav_svn.so
</screen>

      <para>Tenga en cuenta que si <command>mod_dav</command>
        fue compilado como un objeto compartido (en lugar de
        haber sido enlazado de manera estática con el binario
        <command>httpd</command>), necesitará también una
        línea <literal>LoadModule</literal> similar para
        él. Asegúrese de que aparece antes de la línea
        <command>mod_dav_svn</command>:</para>

        <screen>
LoadModule dav_module         modules/mod_dav.so
LoadModule dav_svn_module     modules/mod_dav_svn.so
</screen>

    
      <para>En un lugar posterior de su fichero de configuración,
        necesita indicarle a Apache dónde guardará su
        repositorio (o repositorios) de Subversion. La directiva
        <literal>Location</literal> sigue una notación tipo XML,
        comenzando con una etiqueta de apertura y terminando
        con una de cierre, con varias otras directivas de
        configuración en medio. El propósito de la directiva
        <literal>Location</literal> es indicar a Apache que debe
        realizar algo especial cuando tenga que procesar peticiones
        dirigidas a una URL determinada o a una hija suya.  En el
        caso de Subversion, quiere que Apache simplemente le pase
        el control a la capa DAV de todas las URLs que apunten a
        recursos versionados. Puede ordenar a Apache que delegue el
        control de todas las URLs cuyas porciones de rutas (aquella
        parte de la URL que sigue el nombre del servidor y número de
        puerto opcional) empiecen con <filename>/repos/</filename>
        a un proveedor DAV cuyo repositorio se encuentre en
        <filename>/ruta/absoluta/al/repositorio</filename> usando la
        siguiente sintaxis de <filename>httpd.conf</filename>:</para>
                
        <screen>
&lt;Location /repos&gt;
  DAV svn
  SVNPath /ruta/absoluta/al/repositorio
&lt;/Location&gt;
</screen>
            
      <para>Si planea soportar múltiples repositorios de Subversion
        que residirán en el mismo directorio padre de su
        disco local, puede usar una directiva alternativa,
        la directiva <literal>SVNParentPath</literal>, para
        indicar ese directorio padre común.  Por ejemplo,
        si sabe que creará múltiples repositorios Subversion
        en el directorio <filename>/usr/local/svn</filename>
        que sería accesible mediante URLs como <systemitem
        class="url">http://my.server.com/svn/repos1</systemitem>,
        <systemitem
        class="url">http://my.server.com/svn/repos2</systemitem>,
        y así en adelante, podría usar la sintaxis de configuración
        <filename>httpd.conf</filename> del siguiente ejemplo:</para>
              
        <screen>
&lt;Location /svn&gt;
  DAV svn

  # any "/svn/foo" URL will map to a repository /usr/local/svn/foo
  SVNParentPath /usr/local/svn
&lt;/Location&gt;
</screen>
            
      <para>Usando la sintaxis anterior, Apache delegará el control
        de todas las URLs cuyas porciones comiencen con
        <filename>/svn/</filename> al proveedor DAV de
        Subversion, quien asumirá que todos los elementos
        en el directorio especificado por la directiva
        <literal>SVNParentPath</literal> son en realidad repositorios
        de Subversion.  Esta es una sintaxis particularmente
        conveniente, ya que a diferencia de la directiva
        <filename>SVNPath</filename>, no necesita reiniciar Apache
        para crear y hacer disponibles nuevos repositorios.</para>

      <para>Asegúrese de que cuando defina su nuevo
        <literal>Location</literal>, no se solapa con
        otras ubicaciones exportadas.  Por ejemplo,
        si su <literal>DocumentRoot</literal> principal
        es <filename>/www</filename>, no exporte ningún
        repositorio Subversion en <literal>&lt;Location
        /www/repos&gt;</literal>. En caso de recibir una petición
        para la URI <filename>/www/repos/foo.c</filename>,
        Apache no sabrá si tiene que buscar el
        fichero <filename>repos/foo.c</filename> en
        <literal>DocumentRoot</literal>, o si debe delegar
        en <command>mod_dav_svn</command> para que devuelva
        <filename>foo.c</filename> del repositorio Subversion.</para>

      <sidebar>
        <title>Nombres de servidor y peticiones COPY</title>
        
        <para>Subversion hace uso del tipo de petición
          <literal>COPY</literal> para realizar copias de ficheros
          y directorios en el lado del servidor.  Como parte de
          los chequeos de seguridad realizados por los módulos
          Apache, se espera que el origen de la copia esté ubicado
          en la misma máquina que el destino. Para satisfacer
          este requisito, podría necesitar decirle a mod_dav el
          nombre de servidor que usa para su máquina. En general,
          puede usar la directiva <literal>ServerName</literal>
          de <filename>httpd.conf</filename> para lograr esto.</para>
        
        <screen>
ServerName svn.example.com
</screen>
            
        <para>Si está usando el soporte de hosting virtual de Apache
          por medio de la directiva
          <literal>NameVirtualHost</literal>, puede que necesite
          usar la directiva <literal>ServerAlias</literal> para
          especificar nombres adicionales bajo los cuales es conocido
          su servidor. De nuevo, busque en la documentación de Apache
          los detalles de la misma.</para>
      </sidebar>

      <para>En este punto, debería considerar seriamente el tema
        de los permisos.  Si ha estado ejecutando Apache durante
        algún tiempo como su servidor de web habitual, probablemente
        ya tenga una colección de contenido&mdash;páginas web,
        scripts y demás. Estos elementos ya han sido configurados
        con un conjunto de permisos que les permite funcionar con
        Apache, o de manera más apropiada, le permite a Apache
        funcionar con esos ficheros.  Apache, cuando es usado como
        servidor de Subversion, también necesitará los permisos
        adecuados de lectura y escritura a su repositorio Subversion.
        (Vea <xref linkend="svn-ch-6-sidebar-1"/>.) </para>
    
      <para>Tendrá que encontrar una configuración de permisos de
        sistema que satisfaga los requisitos de Subversion
        sin estropear instalaciones ya existentes de páginas
        web o scripts. Esto podría significar cambiar los
        permisos de su repositorio Subversion para que encajen
        con aquellos usados por otras elementos servidos
        por Apache, o podría significar usar las directivas
        <literal>User</literal> y <literal>Group</literal> del
        fichero <filename>httpd.conf</filename> para especificar
        que Apache debe ejecutarse con el usuario y grupo a
        quien pertenece su repositorio Subversion. No hay una
        única manera correcta de configurar sus permisos, y cada
        administrador tendrá diferentes razones para hacer las
        cosas a su manera. Sólo tenga presente que los problemas
        relacionados con los permisos son quizás el fallo más
        común cuando se configura un repositorio Subversion para
        ser usado con Apache.</para>

    </sect2>

    <sect2 id="svn-ch-6-sect-4.3">
      <title>Opciones de autenticación</title>

      <para>En este punto, si ha configurado
        <filename>httpd.conf</filename> para que contenga algo
        como</para>

      <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
&lt;/Location&gt;
</screen>

      <para>...entonces su repositorio es accesible al mundo de
        manera <quote>anónima</quote>.  Hasta que configure
        algunas políticas de autenticación y autorización,
        los repositorios Subversion que haga disponibles con la
        directiva <filename>Location</filename> serán generalmente
        accesibles por cualquiera.  En otras palabras,</para>
      
      <itemizedlist>
        <listitem>
          <para>cualquiera puede usar su cliente de Subversion para
            obtener una copia local de la URL de un repositorio
            (o cualquiera de sus subdirectorios),</para>
        </listitem>
        <listitem>
          <para>cualquiera puede navegar de manera interactiva las
            últimas revisiones del repositorio simplemente usando
            la URL del repositorio con su navegador web, y</para>
        </listitem>
        <listitem>
          <para>cualquiera puede enviar cambios al
            repositorio.</para>
        </listitem>
      </itemizedlist>

      <sect3 id="svn-ch-6-sect-4.3.1">
        <title>Autenticación HTTP básica</title>
        
        <para>La forma más sencilla de autenticar a un cliente es
          mediante el mecanismo de autenticación HTTP básico, que
          simplemente usa un nombre de usuario y clave para verificar
          que el usuario es quien dice ser. Apache proporciona
          la utilidad <command>htpasswd</command> para gestionar
          la lista de nombres de usuarios y claves aceptables,
          aquellos a quienes desea proporcionar acceso especial a
          su repositorio Subversion. Permitamos el acceso de escritura a
          Juan y Carmen. Primero, necesitamos añadirlos al fichero
          de claves.</para>
    
        <screen>
$ ### First time: use -c to create the file
$ ### Use -m to use MD5 encryption of the password, which is more secure
$ htpasswd -cm /etc/svn-auth-file harry
New password: ***** 
Re-type new password: *****
Adding password for user harry
$ htpasswd /etc/svn-auth-file -m sally
New password: *******
Re-type new password: *******
Adding password for user sally
$
</screen>

        <para>Ahora, necesitamos añadir algunas directivas
          <filename>httpd.conf</filename> más dentro del bloque
          <literal>Location</literal> para decirle a Apache qué
          hacer con su nuevo fichero de claves. La directiva
          <literal>AuthType</literal> especifica el tipo
          del sistema de autenticación que va a usar. En este
          caso, queremos especificar el sistema de autenticación
          <literal>Basic</literal>.  <literal>AuthName</literal> es
          un nombre arbitrario que usted proporciona para el dominio
          de autenticación. La mayoría de los navegadores mostrarán
          este nombre en una ventana de diálogo emergente cuando
          el navegador le pregunte su nombre y clave. Finalmente,
          use la directiva <literal>AuthUserFile</literal> para
          especificar la ubicación del fichero de claves creado
          usando <command>htpasswd</command>.</para>
    
        <para>Tras añadir estas tres directivas, su bloque
          <literal>&lt;Location&gt;</literal> debería tener un
          aspecto similar a este:</para>
    
        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /etc/svn-auth-file
&lt;/Location&gt;
</screen>

        <para>Este bloque <literal>&lt;Location&gt;</literal>
          todavía no está completo, y no hará nada útil. Meramente
          indica a Apache que cuando requiera autorización, Apache
          debe obtener el nombre de usuario y clave del cliente
          Subversion. Lo que falta aquí, no obstante, son las
          directivas que le dicen a Apache <emphasis>qué</emphasis>
          tipos de solicitudes por parte de los clientes requieren
          autorización. Donde se requiera autorización, Apache
          demandará también autenticación. Lo mas sencillo es
          proteger todas las peticiones. Añadir <literal>Require
          valid-user</literal> indica a Apache que todas las
          peticiones requieren un usuario autenticado:</para>

        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /etc/svn-auth-file
  Require valid-user
&lt;/Location&gt;
</screen>

        <para>Asegúrese de leer la siguiente sección (<xref
          linkend="svn-ch-6-sect-4.4"/>) para más detalles sobre
          la directiva <literal>Require</literal> y otros modos de
          establecer políticas de autorización.</para>

        <para>Una advertencia: en la autenticación básica por HTTP
          las palabras claves viajan por la red casi como
          texto simple, y son por lo tanto extremadamente
          inseguras. Si está preocupado por la existencia
          de un rastreador de claves, lo mejor sería usar
          algún tipo de cifrado SSL, para que los clientes se
          autentiquen vía <literal>https://</literal> en lugar de
          <literal>http://</literal>; como mínimo podrá configurar
          Apache para que use use un certificado firmado por
          sí mismo.
          <footnote>
            <para>Aunque los certificados de servidor auto firmados
              siguen siendo vulnerables a ataques del <quote>hombre
              en medio</quote> <!-- TODO buscar traducción de
              man in the middle en literatura de seguridad -->,
              tal ataque es todavía más difícil de conseguir por
              un observador casual, comparado con el rastreado de
              claves desprotegidas.</para>
          </footnote>
          Consulte la documentación de Apache (y la de OpenSSL)
          para saber cómo hacer esto.</para>

      </sect3>


      <sect3 id="svn-ch-6-sect-4.3.2">
        <title>Gestión de certificados SSL</title>
        
        <para>Las empresas que necesitan exponer sus repositorios
          a un acceso externo al firewall de la compañía deberían
          ser conscientes de que grupos <!-- TODO parties? -->no
          autorizados podrían estar <quote>rastreando</quote> su
          tráfico de red. SSL consigue que ese tipo de atención
          no deseada desemboque con menor probabilidad en fugas de
          datos sensitivos.</para>

        <para>Si se compila un cliente de Subversion para que use
          OpenSSL, entonces ganará la habilidad de hablar con un
          servidor Apache vía URLs <literal>https://</literal>. La
          librería Neon usada por el cliente Subversion no solo es
          capaz de verificar los certificados de servidor, sino
          que también puede proporcionar certificados de cliente
          cuando sean solicitados.  Una vez el cliente y servidor
          hayan intercambiado sus certificados SSL y realizado una
          autenticación mutua con éxito, todas sus comunicaciones
          siguientes serán cifradas con una clave de sesión.</para>

        <para>Está fuera del alcance de este libro describir la
          generación de certificados de cliente y servidor, y cómo
          configurar Apache para usarlos. Muchos otros libros,
          incluyendo la propia documentación de Apache, describen
          esta tarea. Pero lo que <emphasis>podemos</emphasis>
          cubrir aquí es cómo gestionar los certificados de cliente
          y servidor desde un cliente Subversion ordinario.</para>

        <para>Cuando un cliente Subversion se comunica con Apache
          vía <literal>https://</literal>, puede recibir dos tipos
          diferentes de información:</para>

        <itemizedlist>
          <listitem><para>un certificado de servidor</para></listitem>
          <listitem><para>una demanda de un certificado de cliente</para></listitem>
        </itemizedlist>

        <para>Si el cliente recibe un certificado de servidor,
          necesita verificar que confía en el certificado: ¿es
          realmente el servidor quien dice ser?  La librería
          OpenSSL realiza esto examinando al firmante del
          certificado de servidor o la <firstterm>autoridad
          certificadora</firstterm> (CA).  Si OpenSSL no es capaz de
          confiar automáticamente en la CA, o bien ocurre algún otro
          problema (como que el certificado expiró o no concuerda
          con el nombre del servidor), el cliente de línea de
          comando de Subversion le preguntará si quiere confiar en
          el certificado del servidor de todas maneras:</para>

        <screen>
$ svn list https://host.example.com/repos/project

Error validating server certificate for 'https://home.example.com:443':
 - The certificate is not issued by a trusted authority. Use the
   fingerprint to validate the certificate manually!
Certificate information:
 - Hostname: host.example.com
 - Valid: from Jan 30 19:23:56 2004 GMT until Jan 30 19:23:56 2006 GMT
 - Issuer: CA, example.com, Sometown, California, US
 - Fingerprint: 7d:e1:a9:34:33:39:ba:6a:e9:a5:c4:22:98:7b:76:5c:92:a0:9c:7b

(R)eject, accept (t)emporarily or accept (p)ermanently?
</screen>

        <para>Este diálogo debería parecerle familiar; es
          esencialmente la misma pregunta que ha observado
          proveniente de su navegador web (¡que es meramente
          otro cliente HTTP como Subversion!). Si elige la opción
          (p)ermanente, el certificado de servidor será guardado en
          el área <filename>auth/</filename> de su fichero privado
          de configuración de parámetros de ejecución, del mismo
          modo que es guardado su nombre de usuario y clave (vea
          <xref linkend="svn-ch-6-sect-2.2"/>.)  Si se cachea<!--
          TODO oh, declinación de un anglicismo, perfecto-->,
          Subversion recordará confiar de manera automática en este
          certificado en futuras negociaciones.</para>

        <para>Su fichero <filename>servers</filename> del área de
          la configuración de parámetros de ejecución también
          le permite a su cliente de Subversion confiar de
          manera automática en CAs específicos, ya sea de manera
          global o individual. Simplemente modifique la variable
          <literal>ssl-authority-files</literal> para que sea una
          lista de certificados de CA con codificación PEM <!-- TODO
          PEM-encoded, ver qué es PEM, posible N.T. --> separados
          por punto y coma:</para>

        <screen>
[global]
ssl-authority-files = /path/to/CAcert1.pem;/path/to/CAcert2.pem
</screen>
        
        <para>Muchas instalaciones de OpenSSL confían <quote>por
          defecto</quote> de manera casi universal en un conjunto
          predefinido de CAs. para hacer que el cliente Subversion
          confíe de manera automática en estas autoridades estándar,
          cambie la variable <literal>ssl-trust-default-ca</literal>
          a <literal>true</literal>.</para>

        <para>Cuando dialoga con Apache, un cliente de Subversion
          también podría recibir una petición de certificado
          de cliente. Apache está solicitando al cliente que
          se identifique: ¿es el cliente realmente quien dice
          ser? Si todo va bien, el cliente de Subversion devuelve
          un certificado privado firmado por la CA en quien confía
          Apache. El certificado de cliente habitualmente se almacena
          cifrado en el disco, protegido por una palabra clave local.
          Cuando Subversion recibe esta petición, le preguntará tanto
          por la ruta al certificado como por la palabra clave que
          lo protege:</para>

        <screen>
$ svn list https://host.example.com/repos/project

Authentication realm: https://host.example.com:443
Client certificate filename: /path/to/my/cert.p12
Passphrase for '/path/to/my/cert.p12':  ********
&hellip;
</screen>

        <para>Tenga que el certificado de un cliente es un fichero
          <quote>p12</quote>.  Para usar un certificado de cliente
          con Subversion, debe estar en el formato PKCS#12, que
          es un estándar portable. La mayoría de los navegadores
          son capaces de importar y exportar certificados en este
          formato. Otra opción es usar las herramientas de línea de
          comando de OpenSSL para convertir certificados existentes
          a PKCS#12.</para>

        <para>De nuevo, el fichero <filename>servers</filename>
          del área de configuración de parámetros de ejecución le
          permite automatizar este proceso por cada máquina.  Una o
          ambas informaciones pueden ser descritas en variables
          de ejecución:</para>

        <screen>
[groups]
examplehost = host.example.com

[examplehost]
ssl-client-cert-file = /path/to/my/cert.p12
ssl-client-cert-password = somepassword
</screen>

        <para>Una vez creadas las variables
          <literal>ssl-client-cert-file</literal> y
          <literal>ssl-client-cert-password</literal>, el cliente
          Subversion responderá automáticamente a peticiones de
          certificado de cliente sin tener que preguntarle.
          <footnote>
            <para>Aquellos más conscientes de la seguridad quizás
              no deseen almacenar la clave del certificado de cliente
              en el fichero <filename>servers</filename> del área
              de configuración de parámetros de ejecución.</para>
          </footnote>
        </para>

      </sect3>

    </sect2>
    
    <sect2 id="svn-ch-6-sect-4.4">
      <title>Opciones de autorización</title>

      <para>En este punto, ya ha configurado la autenticación,
        pero no la autorización.  Apache es capaz de cuestionar a
        los clientes y confirmar sus identidades, pero todavía no
        sabe cómo permitir o restringir el acceso a los clientes
        con esas identidades.  Esta sección describe dos estrategias
        para controlar el acceso a sus repositorios.</para>

      <sect3 id="svn-ch-6-sect-4.4.1">
        <title>Control de acceso simple</title>

        <para>La forma de control de acceso más simple a un
          repositorio es autorizar a ciertos usuarios el acceso de
          sólo lectura, o lectura y escritura.</para>

        <para>Puede restringir el acceso sobre todas las operaciones
          del repositorio añadiendo la directiva
          <literal>Require valid-user</literal> al bloque
          <literal>&lt;Location&gt;</literal>. Usando nuestro
          ejemplo anterior, esto equivaldría a que sólo los
          clientes que clamasen ser <literal>juan</literal>
          o <literal>carmen</literal>, y proporcionan la clave
          correcta para su usuario correspondiente, podrían hacer
          operaciones con el repositorio Subversion:</para>

        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # how to authenticate a user
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file
  
  # only authenticated users may access the repository
  Require valid-user
&lt;/Location&gt;
</screen>

        <para>A veces no necesita extremar tanto la seguridad. Por
          ejemplo, el propio repositorio de código
          fuente de Subversion ubicado en <systemitem
          class="url">http://svn.collab.net/repos/svn</systemitem>
          permite a cualquiera realizar operaciones de sólo lectura
          (como por ejemplo obtener copias locales y explorar el
          repositorio con un navegador web), pero restringe todas
          las operaciones de escritura a usuarios autenticados. Para
          realizar este tipo de selección restrictiva, puede usar
          las directivas de configuración <literal>Limit</literal>
          y <literal>LimitExcept</literal>. Igual que la directiva
          <literal>Location</literal>, estos bloques tienen etiquetas
          de comienzo y final, y las anidaría dentro de su bloque
          <filename>&lt;Location&gt;</filename>.</para>
  
        <para>Los parámetros presentes en las directivas
          <literal>Limit</literal> y <literal>LimitExcept</literal>
          son los tipos de peticiones HTTP afectadas por
          ese bloque. Por ejemplo, si quisiese prohibir todo
          el acceso a su repositorio excepto las operaciones
          actualmente soportadas de sólo lectura, podría usar la
          directiva <literal>LimitExcept</literal> incluyendo
          los tipos de peticiones <literal>GET</literal>,
          <literal>PROPFIND</literal>, <literal>OPTIONS</literal>, y
          <literal>REPORT</literal>. Entonces la directiva
          anteriormente mencionada <literal>Require
          valid-user</literal> sería colocada dentro del bloque
          <literal>&lt;LimitExcept&gt;</literal> en lugar del
          bloque.</para>
    
        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # how to authenticate a user
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file

  # For any operations other than these, require an authenticated user.
  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;
    Require valid-user
  &lt;/LimitExcept&gt;
&lt;/Location&gt;
</screen>

        <para>Estos son sólo unos pocos ejemplos simples. Para más
          información detallada sobre el control de acceso de
          Apache y la directiva <literal>Require</literal>, échele
          un vistazo a la sección <literal>Security</literal>
          de la colección de tutoriales en la sección
          de documentación de Apache en <systemitem
          class="url">http://httpd.apache.org/docs-2.0/misc/tutorials.html</systemitem>.</para>
              

      </sect3>

      <sect3 id="svn-ch-6-sect-4.4.2">
        <title>Control de acceso por directorio</title>

        <para>Es posible establecer permisos más precisos <!--
          TODO pierde significado de finer-grained
          --> usando el segundo módulo de Apache httpd,
          <command>mod_authz_svn</command>. Este módulo coge las
          diversas URLs opacas del cliente al servidor, solicita
          a <command>mod_dav_svn</command> que las decodifique, y
          entonces posiblemente veta estas peticiones basándose en
          la política definida en un fichero de configuración.</para>

        <para>Si ha instalado Subversion a partir del código fuente,
          <command>mod_authz_svn</command> habrá
          sido instalado automáticamente junto a
          <command>mod_dav_svn</command>. Muchas
          distribuciones binarias también lo instalan
          automáticamente. Para verificar que está instalado
          correctamente, asegúrese de que viene justo tras
          la directiva <literal>LoadModule</literal>
          de <command>mod_dav_svn</command> en
          <filename>httpd.conf</filename>:</para>

        <screen>
LoadModule dav_module         modules/mod_dav.so
LoadModule dav_svn_module     modules/mod_dav_svn.so
LoadModule authz_svn_module   modules/mod_authz_svn.so
</screen>

        <para>Para activar este módulo, necesita configurar su bloque
          <literal>Location</literal> para que use la directiva
          <literal>AuthzSVNAccessFile</literal>, la cual especifica
          el fichero que contiene la política de permisos para las
          rutas en sus repositorios.  (Discutiremos el formato de
          este fichero dentro de unos momentos.)</para>

        <para>Apache es flexible, así que tiene la opción de
          configurar su bloque con uno de estos tres patrones
          generales. Para comenzar, escoja uno de estos patrones
          básicos de configuración. (Los ejemplos que vienen a
          continuación son muy simples; vea la documentación
          de Apache para más detalles sobre las opciones de
          autenticación y autorización.)</para>

        <para>El bloque más simple es permitir el acceso a
          cualquiera.  En este escenario, Apache nunca envía
          solicitudes de autenticación, así que todos los usuarios
          son tratados como <quote>anónimos</quote>.</para>

        <example id="svn-ch-6-sect-4.4.2-ex-1">
          <title>A sample configuration for anonymous access.</title>
          <programlisting>
            &lt;Location /repos&gt;
              DAV svn
              SVNParentPath /usr/local/svn

              # our access control policy
              AuthzSVNAccessFile /path/to/access/file                 
            &lt;/Location&gt;
          </programlisting>
        </example>

        <para>En el lado opuesto de la escala de paranoia, puede
          configurar su bloque para demandar la autenticación de
          todo el mundo. Todos los clientes deberán proporcionar
          credenciales para identificarse. Su bloque requiere
          de manera incondicional la autenticación vía directiva
          <literal>Require valid-user</literal>, y define un método
          de autenticación.</para>

        <example id="svn-ch-6-sect-4.4.2-ex-2">
          <title>A sample configuration for authenticated access.</title>
          <programlisting>
            &lt;Location /repos&gt;
              DAV svn
              SVNParentPath /usr/local/svn
            
              # our access control policy
              AuthzSVNAccessFile /path/to/access/file                 
            
              # only authenticated users may access the repository
              Require valid-user
            
              # how to authenticate a user
              AuthType Basic
              AuthName "Subversion repository"
              AuthUserFile /path/to/users/file                  
            &lt;/Location&gt;
          </programlisting>
        </example>

        <para>Un tercer patrón muy popular es permitir una
          combinación de acceso autenticado y anónimo.  Por ejemplo,
          muchos administradores quieren que los usuarios anónimos
          puedan leer ciertos directorios del repositorio,
          pero restringen la lectura (o escritura) de otras
          áreas más sensibles a usuarios autenticados. Con esta
          configuración, todos los usuarios comienzan accediendo al
          repositorio de manera anónima.  Si su política de control
          de acceso requiere un nombre de usuario real en algún
          punto, Apache demandará una autenticación del cliente.
          Para hacer esto, use tanto la directiva <literal>Satisfy
          Any</literal> como <literal>Require valid-user</literal>
          simultáneamente.</para>

        <example id="svn-ch-6-sect-4.4.2-ex-3">
          <title>A sample configuration for mixed
            authenticated/anonymous access.</title>
          <programlisting>
            &lt;Location /repos&gt;
              DAV svn
              SVNParentPath /usr/local/svn
            
              # our access control policy
              AuthzSVNAccessFile /path/to/access/file                 
            
              # try anonymous access first, resort to real 
              # authentication if necessary.
              Satisfy Any
              Require valid-user
            
              # how to authenticate a user
              AuthType Basic
              AuthName "Subversion repository"
              AuthUserFile /path/to/users/file                  
            &lt;/Location&gt;
          </programlisting>
        </example>
        
        <para>Una vez tenga configurado su bloque
          <literal>Location</literal> básico, puede crear un
          fichero de acceso y definir en él algunas reglas de
          autorización.</para>

        <para>La sintaxis del fichero de acceso es la misma que
          la usada por <command>svnserve.conf</command> y los
          ficheros del área de configuración de parámetros de
          ejecución. Las líneas que comienzan con una almohadilla
          (<literal>#</literal>) son ignoradas. En su forma más
          simple, cada sección nombra a un repositorio y ruta dentro
          del mismo, y los nombres de usuario autenticados son los
          nombres de las opciones dentro de cada sección. El valor
          de cada opción describe el nivel de acceso del usuario
          a la ruta del repositorio: ya sea <literal>r</literal>
          (sólo lectura) o <literal>rw</literal> (lectura-escritura).
          Si el nombre de un usuario no se menciona, no se le permite
          el acceso.</para>

        <para>Para ser más específicos, el valor de los nombres de
          sección tienen la forma
          <literal>[repositorio-nombre:ruta]</literal> o la
          forma <literal>[ruta]</literal>. Si está usando la
          directiva <literal>SVNParentPath</literal>, entonces
          es importante especificar los nombres de repositorio
          en sus secciones. Si los omite, una sección como
          <literal>[/algún/directorio]</literal> coincidirá
          con la ruta <filename>/algún/directorio</filename> en
          <emphasis>cada</emphasis> repositorio. No obstante si está
          usando la directiva <literal>SVNPath</literal>, entonces
          está bien definir rutas en sus secciones&mdash;después de
          todo, sólo hay un repositorio.</para>
          
        <screen>
[calc:/branches/calc/bug-142]
harry = rw
sally = r
</screen>

        <para>En este primer ejemplo, el usuario
          <literal>juan</literal> tiene permisos
          de lectura y escritura sobre el directorio
          <filename>/branches/calc/bug-142</filename> del
          repositorio <literal>calc</literal>, pero el usuario
          <literal>carmen</literal> sólo tiene permisos de
          lectura. Cualquier otro usuario tendrá bloqueado el acceso
          a este directorio.</para>

        <para>Por supuesto, los permisos son heredados del directorio
          padre al hijo. Esto significa que puede especificar un
          subdirectorio con una política de acceso diferente para
          Carmen:</para>

        <screen>
[calc:/branches/calc/bug-142]
harry = rw
sally = r

# give sally write access only to the 'testing' subdir
[calc:/branches/calc/bug-142/testing]
sally = rw
</screen>

        <para>Ahora Carmen puede escribir en el subdirectorio
          <filename>testing</filename> de la rama, pero sigue
          accediendo con permisos de sólo lectura a otras
          ubicaciones. Mientras tanto, Juan continua con permisos
          de lectura-escritura para toda la rama.</para>

        <para>También es posible denegarle los permisos a alguien de
          manera explícita mediante reglas de herencia, ajustando
          su variable de nombre de usuario a nada:</para>

        <screen>
[calc:/branches/calc/bug-142]
harry = rw
sally = r

[calc:/branches/calc/bug-142/secret]
harry =
</screen>
        
        <para>En este ejemplo, Juan tiene acceso de lectura-escritura
          a todo el árbol <filename>bug-142</filename>,
          pero no tiene acceso en absoluto al subdirectorio
          <filename>secret</filename> dentro del mismo.</para>

        <para>Por defecto, nadie tiene acceso en absoluto al
          repositorio.  Esto significa que si comienza con un fichero
          vacío, probablemente querrá permitir el acceso de lectura
          la raíz del repositorio a todos los usuarios.  Puede hacer
          esto con la variable asterisco (<literal>*</literal>),
          la cual significa <quote>todos los usuarios</quote>:</para>

        <screen>
[/]
* = r
</screen>

        <para>Ésta es una configuración común; fíjese que no hay
          nombre de repositorio nombrado en el nombre de la
          sección. Esto hace todos los repositorios legibles por
          todos los usuarios, usando tanto <literal>SVNPath</literal>
          como <literal>SVNParentPath</literal>. Una vez todos los
          usuarios tienen acceso de lectura a los repositorios,
          puede dar permisos explícitos <literal>rw</literal>
          a determinados usuarios en subdirectorios específicos
          dentro de repositorios específicos.</para>

        <para>La variable asterisco (<literal>*</literal>) también
          merece aquí una mención especial: es el
          <emphasis>único</emphasis> patrón que coincide con
          el usuario anónimo.  Si ha configurado su bloque
          <literal>Location</literal> para permitir una mezcla
          de acceso anónimo y autenticado, todos los usuarios
          comienzan accediendo a Apache de forma anónima.
          <command>mod_authz_svn</command> busca el valor
          <literal>*</literal> definido para la ruta que se está
          accediendo; si no puede encontrar uno, entonces Apache
          demanda una autenticación real del cliente.</para>

        <para>El fichero de acceso también le permite definir
          grupos enteros de usuarios, de manera muy similar al
          fichero <filename>/etc/group</filename> Unix:</para>

        <screen>
[groups]
calc-developers = harry, sally, joe
paint-developers = frank, sally, jane
everyone = harry, sally, joe, frank, sally, jane
</screen>

        <para>A los grupos se les puede facilitar el acceso igual que
          a los usuarios.  Distíngalos con el prefijo
          <quote>arroba</quote> (<literal>@</literal>):</para>

        <screen>
[calc:/projects/calc]
@calc-developers = rw

[paint:/projects/paint]
@paint-developers = rw
jane = r 
</screen>

        <para>...y eso es prácticamente todo lo que hay que
          hacer.</para>

      </sect3>

    </sect2>

    <sect2 id="svn-ch-6-sect-4.5">
      <title>Regalitos extra</title>

      <para>Hemos cubierto la mayoría de las opciones de
        autenticación y autorización para Apache y mod_dav_svn. Pero
        Apache proporciona algunas otras características
        interesantes.</para>

      <sect3 id="svn-ch-6-sect-4.5.1">
        <title>Navegar por el repositorio</title>
        
        <para>Uno de los beneficios más útiles de una configuración
          Apache/WebDAV de su repositorio Subversion es que las
          revisiones más recientes de sus ficheros y directorios
          versionados están disponibles inmediatamente para
          ser visualizados con un navegador web normal. Dado que
          Subversion usa URLs para identificar recursos versionados,
          aquellas URLs basadas en HTTP para acceder al repositorio
          pueden teclearse directamente en un navegador. Su navegador
          realizará una petición <literal>GET</literal> para esta
          URL, y dependiendo de que ésta represente un directorio o
          fichero versionado, mod_dav_svn responderá con un listado
          de directorio o con el contenido del fichero.</para>

        <para>Dado que las URLs no contienen información sobre qué
          versión del recurso desea ver, mod_dav_svn responderá
          siempre con la versión más reciente. Esta funcionalidad
          tiene el maravilloso efecto secundario de que puede pasar a
          sus colegas referencias a documentos, y esas URLs siempre
          apuntarán a la última manifestación de los mismos. Por
          supuesto, también puede usar las URLs como hiperenlaces
          desde otras páginas web.</para>

        <para>Generalmente obtendrá más utilidad del uso de URLs
          a ficheros versionados&mdash;después de todo, ahí
          es donde suele estar el contenido interesante. Pero
          quizás disponga de la ocasión de navegar por un listado
          de directorio de Subversion, y percibir que el HTML
          generado para mostrar el listado es muy básico, y
          desde luego no está pensado para ser estéticamente
          agradable (o incluso interesante).  Para permitir
          la personalización de estas muestras de directorio,
          Subversion proporciona una característica de indexado
          XML. Una única directiva <literal>SVNIndexXSLT</literal>
          en el bloque <literal>Location</literal> de
          <filename>httpd.conf</filename> indicará a mod_dav_svn
          que genere la salida del listado de directorio en un
          XML, usando como referencia una hoja de estilo XSLT de
          su elección:</para>
 
        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  SVNIndexXSLT "/svnindex.xsl"
  &hellip;
&lt;/Location&gt;
</screen>

        <para>Usando la directiva <literal>SVNIndexXSLT</literal>
          y una hoja de estilo XSLT creativa, puede hacer que sus
          listados de directorio concuerden con los esquemas de color
          e imágenes usados en otras partes de su página web.  O, si
          lo prefiere, puede usar las hojas de estilo de ejemplo que
          proporciona la distribución de código fuente de Subversion
          en el directorio <filename>tools/xslt/</filename>. Tenga
          en cuenta que la ruta que apunta al directorio
          <literal>SVNIndexXSLT</literal> es en realidad una
          URL&mdash;¡los navegadores deben poder leer sus hojas de
          estilo para poder usarlas!</para>

        <sidebar>
          <title>¿Puedo ver revisiones antiguas?</title>

          <para>¿Con un navegador web ordinario? En una palabra:
            no. Al menos, no con <command>mod_dav_svn</command>
            como su única herramienta.</para>

          <para>Su navegador web sólo sabe hablar HTTP ordinario. Eso
            significa que sólo sabe cómo hacer GET de URLs públicas,
            las cuales representan las últimas versiones de
            ficheros y directorios. De acuerdo con la especificación
            WebDAV/DeltaV, cada servidor define una sintaxis privada
            de URLs para versiones antiguas de los recursos, y ésta
            es opaca a los clientes. Para encontrar una versión
            anterior de un fichero, un cliente debe seguir un
            procedimiento específico para <quote>descubrir</quote>
            la URL correcta; el proceso conlleva realizar una serie
            de peticiones WebDAV PROPFIND y entender los conceptos
            DeltaV. Esto es algo que su navegador web simplemente
            no es capaz de hacer.</para>

          <para>Así que para responder a su pregunta, una manera
            obvia para ver revisiones antiguas de ficheros
            y directorios es pasando el parámetro
            <option>--revision</option> a los comandos
            <command>svn list</command> y <command>svn
            cat</command>.  No obstante, para ver revisiones
            antiguas con su navegador, puede usar software de
            terceros. Un buen ejemplo es ViewCVS (<systemitem
            class="url">http://viewcvs.sourceforge.net/</systemitem>).
            Originalmente ViewCVS fue escrito para mostrar
            repositorios CVS por la web, y las últimas versiones de
            desarrollo (en el momento de escribir estas palabras)
            son capaces de entender también repositorios de
            Subversion.</para>
        </sidebar>

      </sect3>

      <sect3 id="svn-ch-6-sect-4.5.2">
        <title>Otras características</title>
        
        <para>Algunas de las características proporcionadas por
          Apache en su rol de servidor web robusto también pueden
          ser aprovechadas para incrementar la funcionalidad o
          seguridad en Subversion.  Subversion se comunica con
          Apache usando Neon, que es una librería HTTP/WebDAV
          genérica con soporte para mecanismos tales como SSL (Secure
          Socket Layer<!-- TODO ¿NT de ssl? ¿cuándo sale antes?-->,
          discutidos anteriormente) y compresión Deflate (el mismo
          algoritmo usado por los programas <command>gzip</command>
          y <command>PKZIP</command> para <quote>reducir</quote>
          ficheros en bloques de datos de tamaño menor). Sólo
          necesita compilar el soporte de las características
          que desea tener en Subversion y Apache, y configurar
          adecuadamente estos programas para que las usen.</para>
    
        <para>La compresión Deflate carga ligeramente al cliente
          y al servidor para comprimir y descomprimir transmisiones
          por red para minimizar el tamaño de los datos. En aquellos
          casos donde el ancho de banda de red es escaso, este
          tipo de compresión puede incrementar sustancialmente la
          velocidad con la que se comunican el servidor y el cliente.
          En casos extremos, la minimización de la transmisión por
          red puede marcar la diferencia entre una operación cuyo
          tiempo de espera es agotado o termina con éxito.</para>
  
        <para>Menos interesantes, pero igualmente útiles, son otras
          características de la relación entre Apache y Subversion,
          como la capacidad de especificar un puerto específico
          (en lugar del puerto 80 por defecto de HTTP) o un nombre
          de dominio virtual mediante el cual se pueda acceder a
          un repositorio de Subversion, o la capacidad de acceder
          al repositorio a través de un proxy. Estas cosas las
          soporta Neon, así que Subversion las obtiene de manera
          gratuita.</para>

        <para>Por último, dado que <command>mod_dav_svn</command>
          habla un dialecto semi completo de WebDAV/DeltaV, es
          posible acceder al repositorio mediante clientes DAV de
          terceros. La mayoría de los sistemas operativos modernos
          (Win32, OS X, y Linux) tienen soporte para montar un
          servidor DAV como un <quote>recurso</quote> estándar
          de red.  Ésto es un tema complicado; para más detalles,
          lea <xref linkend="svn-ap-c"/>.</para>

        
      </sect3>

    </sect2>

  </sect1>


  <!-- ================================================================= -->
  <!-- ======================== SECTION 5 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-6-sect-5">
    
    <title>Ofrecer múltiples métodos de acceso al repositorio</title>

    <para>Le hemos enseñado a acceder a un repositorio de muchas
      maneras diferentes.  Pero, ¿es posible&mdash;o
      seguro&mdash;acceder a su repositorio mediante múltiples
      métodos simultáneamente? La respuesta es afirmativa, siempre
      y cuando planifique un poco las cosas.</para>
    
    <para>En cualquier instante, estos procesos pueden requerir
      acceso de lectura y escritura a su repositorio:</para>
    
    <itemizedlist>
      <listitem>
        <para>usuarios normales del sistema (que se identifican
          como ellos mismos) usando un cliente de Subversion
          para acceder a los repositorios directamente vía URLs
          <literal>file:///</literal>;</para>
      </listitem>
      <listitem>
        <para>usuarios normales del sistema (que se identifican
          como ellos mismos) conectándose a procesos
          <command>svnserve</command> privados mediante sesiones SSH,
          los cuales acceden al repositorio;</para>
      </listitem>
      <listitem>
        <para>un proceso <command>svnserve</command>&mdash;ya sea un
          demonio o uno invocado por
          <command>inetd</command>&mdash;ejecutándose como un usuario
          particular invariable;</para>
      </listitem>
      <listitem>
        <para>un proceso <command>httpd</command> de Apache,
          ejecutándose como un usuario particular invariable.</para>
      </listitem>
    </itemizedlist>
    
    <para>El problema más común que se encuentran los administradores
      es con la propiedad y permisos del repositorio. ¿Tiene cada
      proceso (o usuario) en la lista anterior permisos para leer y
      escribir los ficheros de la base de datos Berkeley? Asumiendo
      que tiene un sistema operativo tipo Unix, una opción simple
      sería colocar a cada usuario potencial del repositorio
      en un nuevo grupo <literal>svn</literal>, y hacer que el
      repositorio al completo esté poseído por este grupo. Pero
      ni si quiera eso es suficiente, porque un proceso puede
      escribir los ficheros de la base de datos usando una máscara
      de permisos hostil&mdash;aquella que impida el acceso a
      otros usuarios.</para>

    <para>Así que el siguiente paso tras el establecimiento de
      un grupo común para los usuarios del repositorio es forzar
      a todos los procesos que acceden al repositorio a usar una
      máscara de permisos aceptable. Para los usuarios que acceden
      al repositorio directamente, puede envolver el programa
      <command>svn</command> en un script cuyo primer paso sea
      ejecutar <command>umask 002</command> y después ejecute
      el programa cliente <command>svn</command> auténtico.
      Puede escribir un script de envoltorio similar para el
      programa <command>svnserve</command>, y añadir el comando
      <command>umask 002</command> al propio fichero de arranque
      de Apache, <filename>apachectl</filename>.  Por ejemplo:</para>

    <screen>
$ cat /usr/local/bin/svn

#!/bin/sh

umask 002
/usr/local/subversion/bin/svn "$@"

</screen>

    <para>Hay otro problema común en sistemas tipo Unix.
      A medida que se usa un repositorio, la base de datos Berkeley
      ocasionalmente crea nuevos ficheros de registro para sus
      transacciones. Incluso si el repositorio completo pertenece
      al grupo <command>svn</command>, estos nuevos ficheros no
      pertenecerán necesariamente al mismo grupo, lo cual crea
      de nuevo problemas de permisos para sus usuarios. Un buen
      método para corregir esto es activar el bit de grupo SUID
      en el directorio <filename>db</filename> del repositorio.
      Esto causa que todos los ficheros de registros creados tengan
      el mismo grupo que el directorio padre..</para>

    <para>Una vez haya saltado por estos aros, su repositorio
      debería ser accesible por todos los procesos necesarios. Puede
      que parezca un poco lioso y complicado, pero los problemas
      de tener múltiples usuarios compartiendo acceso de escritura
      a ficheros comunes son clásicos, pocas veces solucionados de
      manera elegante.</para>
    
    <para>Afortunadamente, la mayoría de los administradores de
      repositorios no tendrán nunca la <emphasis>necesidad
      </emphasis> de tener configuraciones tan complejas.
      Los usuarios que desean acceder a repositorios que residen
      en la misma máquina no están limitados a usar el las URLs
      de acceso <literal>file://</literal>&mdash;típicamente
      pueden contactar con el servidor HTTP de Apache
      o <command>svnserve</command> usando el nombre de
      servidor <literal>localhost</literal> en sus URLs
      <literal>http://</literal> o <literal>svn://</literal>.
      Y mantener múltiples procesos servidores para sus repositorios
      de Subversion es probablemente un dolo de cabeza más que
      algo necesario. ¡Le recomendamos que escoja el servidor que
      se ajuste mejor a sus necesidades y que se limite a él!</para>

    <sidebar>
      <title>Lista de tareas para servidor svn+ssh://</title>

      <para>Puede ser complicado hacer que un grupo de usuarios con
        cuentas SSH existentes compartan un repositorio sin
        problemas de permisos. Si se siente confuso respecto a
        todas las cosas que usted (como administrador) necesita
        realizar en un sistema tipo Unix, aquí tiene una lista
        de tareas que resumen algunas de las cosas discutidas en
        esta sección:</para>

      <itemizedlist>
        <listitem>
          <para>Todos sus usuarios SSH necesitan ser capaces de leer
            y escribir en el repositorio. Ponga a todos los usuarios
            SSH en un único grupo.  Haga que el propietario del
            repositorio sea ese grupo, y active los permisos de
            lectura/escritura para el mismo.</para>
        </listitem>

        <listitem>
          <para>Sus usuarios deben usar una máscara de permisos
            aceptable al acceder al repositorio. Asegúrese
            de que <command>svnserve</command>
            (<filename>/usr/local/bin/svnserve</filename>, o
            donde quiera que esté en <literal>$PATH</literal>)
            es en realidad un script envoltorio que ejecuta
            <command>umask 002</command> y luego el binario
            <command>svnserve</command> auténtico. Tome
            medidas similares con <command>svnlook</command> y
            <command>svnadmin</command>. Es decir, ejecútelos con
            una máscara de permisos aceptable, o envuélvalos tal y
            como se describe anteriormente.</para>
        </listitem>

        <listitem>
          <para>Cuando la base de datos Berkeley crea nuevos
            ficheros de registros, también necesitan pertenecer
            al mismo grupo, así que asegúrese de que ejecuta
            <command>chmod g+s</command> en el directorio
            <filename>db</filename> del repositorio.</para>
        </listitem>
      </itemizedlist>

    </sidebar>

  </sect1>




</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
