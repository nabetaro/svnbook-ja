<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- originated from English revision 652 -->
<appendix id="svn-ap-c">
  <title>WebDAV y autoversionado</title>
  <simplesect>

    <para>
      WebDAV es una extensión a HTTP, y se está haciendo más y
      más  popular como estándar para compartir archivos. Los sistemas 
      operativos actuales se están haciendo cada vez más compatibles
      con la web, y muchos de ellos tienen soporte interno para montar
      directorios compartidos exportados por servidores WebDAV.
    </para>

    <para>
      Si usted usa Apache/mod_dav_svn como su servidor de red para 
      Subversion, entonces, hasta cierto punto, usted también está
      usando un servidor WebDAV. Este apéndice brinda nociones básicas
      sobre la naturaleza de este protocolo, cómo lo usa Subversion,
      y qué tan bien interopera Subversion con otros programas compatibles
      con WebDAV.
    </para>

  </simplesect>

  <sect1 id="svn-ap-c-sect-1">
    <title>Conceptos básicos de WebDAV</title> 

    <para>
      Esta sección da una introducción muy corta y muy general a las
      ideas detrás de WebDAV. Debería sentar las bases para entender
      los problemas de compatibilidad entre los clientes y servidores.
    </para>

    <sect2 id="svn-ap-c-sect-1.1">
      <title>WebDAV sencillo</title>

      <para>
        El RFC 2518 define un conjunto de conceptos y métodos de 
        extensión acompañantes a HTTP 1.1 que hacen de la web un 
        medio de lectura/escritura más universal. La idea básica 
        es que un servidor web compatible con WebDAV puede actuar como 
        un servidor genérico de archivos; los clientes pueden montar 
        directorios compartidos que se comportan de manera muy similar 
        a los directorios compartidos de NFS o SMB.
      </para>

      <para>
        Sin embargo, es importante notar que el RFC 2518 <emphasis>no</emphasis>  
        provee ningún tipo de modelo para control de versiones, a pesar de
        la <quote>V</quote> en DAV. Los clientes y servidores de
        WebDAV básico asumen que sólo existe una versión de cada archivo
        o directorio, y puede ser sobreescrita repetidamente.
        <footnote><para>Por esta razón, algunas personas se refieren en broma
            <!--No, no escribí mal, en el libro originalmente dice WebDA (debe
            ser algo como clientes  "güevas")-->
            a los clientes genéricos de WebDAV como clientes <quote>WebDA</quote></para></footnote>
      </para>

      <para>
        Aquí están los conceptos y métodos nuevos introducidos en 
        el WebDAV básico.
      </para>

      <variablelist>

        <varlistentry>
          <term>Nuevos métodos de escritura</term>
          <listitem>
            <para>
              Más allá del método <literal>PUT</literal> del HTTP 
              estándar (que crea o sobreescribe un recurso web),
              WebDAV define los nuevos métodos <literal>COPY</literal>
              y <literal>MOVE</literal> para duplicar o reacomodar 
              recursos.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Colecciones</term>
          <listitem>
            <para>
              Este es simplemente el término usado en WebDAV para
              el agrupamiento de recursos (URI's). En la mayoría de
              los casos, es el análogo a un <quote>directorio</quote>.
              Se puede decir que algo es una colección si termina con 
              un <quote>/</quote>. De la misma manera que los archivos 
              pueden ser creadoscon el método <literal>PUT</literal>,
              las colecciones son creadas con el nuevo método <literal>MKCOL</literal>.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Propiedades</term>
          <listitem>
            <para>
              Es la misma idea que está presente en Subversion&mdash;metadatos
              asociados a archivos y colecciones. Un cliente puede
              mostrar u obtener las propiedades asociadas a un recurso
              con el nuevo método <literal>PROPFIND</literal>, y puede 
              cambiarlas con el método <literal>PROPPATCH</literal>. Algunas 
              propiedades son completamente creadas y controladas por los
              usuarios (por ejemplo, una propiedad llamada <quote>color</quote>),
              y otras creadas y administradas por el servidor WebDAV (por ejemplo,
              la propiedad que contiene la última fecha de modificación de un 
              archivo). Las primeras son llamadas propiedades <quote>muertas</quote>
              y las segundas propiedades <quote>vivas</quote>.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Bloqueo</term>
          <listitem>
            <para>
              Un servidor WebDAV puede decidir ofrecer una característica de 
              bloqueo a los clientes&mdash; esta parte de la especificación es 
              opcional, aunque muchos servidores WebDAV ofrecen esta característica.
              Si está presente los clientes pueden usar los nuevos métodos <literal>LOCK</literal>
              y <literal>UNLOCK</literal> para mediar el acceso a un recurso. En la 
              mayoría de los casos estos métodos son usados para crear bloqueos 
              de escritura exclusivos (como se discutió en <xref linkend="svn-ch-2-sect-2.2"/>),
              aunque también es posible tener bloqueos de escritura compartidos.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>

    </sect2>

    <sect2 id="svn-ap-c-sect-1.2">
      <title>Extensiones DeltaV</title>

      <para>
        Dado que el RFC 2518 dejó por fuera concetos de versionado,
        se dejó a otro grupo  la responsabilidad de escribir el RFC 3253,
        que añade el versionado a WebDAV. Los clientes y servidores de
        WebDAV/DeltaV a menudo son llamados sólo clientes y servidores
        <quote>DeltaV</quote>, ya que DeltaV implica la existencia de 
        WebDAV básico.
      </para>

      <para>
        <!--TODO:a whole slew of new acronyms-->
        DeltaV introduce una gran cantidad de acrónimos, pero no deje que 
        eso lo intimide. Las ideas son bastante directas. Aquí están los nuevos
        conceptos y métodos presentados en DeltaV. 
      </para>

      <variablelist>

        <varlistentry>
          <term>Versionado por recurso</term>
          <listitem>
            <para>
              Como CVS y otros sistemas de control de versiones, DeltaV
              asume que cada recurso tiene un número de estados potencialmente
              infinito. Un cliente empieza poniendo un recurso bajo control de 
              versiones usando el nuevo método <literal>VERSION-CONTROL</literal>.
              Éste crea un nuevo recurso de versión controlada (VCR, por sus siglas en inglés).
              Cada vez que usted cambia el VCR (vía <literal>PUT</literal>,<literal>PROPPATCH</literal>,
              etc.), un nuevo estado del recurso es creado, llamado recurso de versión (VR por sus 
              siglas en inglés). Los VRs y VCRs son recursos web ordinarios, 
              definidos por URLs. Los VRs específicos también pueden tener nombres
              amables con el usuario.
              <!--TODO:human-friendly. no me termina de gustar lo de amable (o amigable) con el usuario
              otra cosa es la traducción del "as well", que puse como también
              -->
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Modelo copia de trabajo del lado del servidor</term>
          <listitem>
            <para>
              <!--TODO: el original dice ...servers support the ability
              ??? soportan la habilidad? eso no suena
              -->
              Algunos servidores DeltaV tienen la habilidad de crear un
              <quote>espacio de trabajo</quote> virtual en el servidor, donde se
              ejecuta todo el trabajo. Los clientes usan el método
              <literal>MKWORKSPACE</literal> para crear un área privada, luego
              indican que quieren cambiar VCRs específicos editándolos, y
              <quote>registrando su entrada</quote> de nuevo. En términos de
              HTTP, la secuencia de métodos sería <literal>CHECKOUT</literal>,
              <literal>PUT</literal>, <literal>CHECKIN</literal>. Después de
              cada <literal>CHECKIN</literal>, se crea un nuevo VR,y los
              contenidos de los VCR's editados ahora <quote>apuntan</quote> al
              <!--TODO:a history resource-->
              último VR. Cada VCR tiene también un recurso
              <quote>historia</quote>, que hace el seguimiento y ordenamiento de
              varios estados VR.

            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Modelo copia de trabajo del lado del cliente</term>
          <!--TODO:El título era Client-side working-copy model-->
          <listitem>
            <para>
              Algunos servidores DeltaV también soportan la idea de que el
              cliente pueda tener una copia privada de trabajo llena de VRs
              específicos. (Así es como CVS y Subversion trabajan.) Cuando el
              cliente quiere enviar cambios al servidor, empieza creando una
              transacción tamporal al servidor (llamada una actividad)con el
              método <literal>MKACTIVITY</literal>. El cliente ejecuta entonces
              un <literal>CHECKOUT</literal> sobre caad VR que desea cambiar, lo
              que crea un número de <quote>recursos de trabajo</quote>
              temporales en la actividad, que pueden ser modificados usando los
              métodos <literal>PUT</literal> y <literal>PROPPATCH</literal>.
              Finalmente, el cliente ejecuta un <literal>CHECKIN</literal> en
              cad recurso de trabajo, lo que crea un nuevo VR dentro de cada
              VCR, y la actividad completa es borrada.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Configuraciones</term>
          <listitem>
            <para>
              DeltaV le permite definir colecciones flexibles de VCRs llamadas
              <quote>configuraciones</quote>, que no necesariamente corresponden
              a directorios particulares. El contenido de cada VCR puede hacerse
              apuntar a un VR específico usando el método
              <literal>UPDATE</literal>. Una vez la configuración es perfecta,
              el cliente puede crear un <quote>snapshot</quote> de toda la
              configuración, llamado <quote>baseline</quote>. Los clientes usan
              los métodos <literal>CHECKOUT</literal> y
              <literal>CHECKIN</literal> para capturar estados específicos de
              las configuraciones, de manera muy similar a cuando usan estos
              métodos para crear estados VR específicos de VCRs.
              <!--TODO:la ultima frase del párrafo
              TODO:like they use these methods to create specific VR states
              of VCRs.-->
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Extensibilidad</term>
          <listitem>
            <para>
              DeltaV define un nuevo método, <literal>REPORT</literal>, que
              permite al clienet y al servidor llevar a cabo intercambios
              personalizados de datos. El cliente envía una solicitud
              <literal>REPORT</literal> con un cuerpo XML adecuadamente
              etiquetado y lleno de datos personalizados; asumiendo que el
              servidor entiende el tipo específico del reporte, responde con un
              cuerpo XML igualmente personalizado. Esta técnica es muy similar a
              XML-RPC.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Autoversionado</term>
          <listitem>
            <para>
              Para muchos, esta es la aplicación <quote>estrella</quote> de
              DeltaV. Si el servidor DeltaV soporta esta característica,
              entonces los clientes WebDAV básico (por ejemplo, aquellos que no
              son compatibles con versionado) aún pueden escribir en el
              servidor, y el servidor silenciosamente hará el versionado.
              <!--TODO: perform versioning anyway-->
              En el ejemplo más simple, un <literal>PUT</literal> ignorante de
              parte de un cliente WebDAV básico puede ser traducido por el
              servidor como un <literal>CHECKOUT</literal>,
              <literal>PUT</literal>, <literal>CHECKIN</literal>.
            </para>
          </listitem>
        </varlistentry>

      </variablelist>

    </sect2>

  </sect1>

  <sect1 id="svn-ap-c-sect-2">
    <title>Subversion y DeltaV</title> 

    <para>
      Así que ¿qué tan <quote>compatible</quote> es Subversion con otro software DeltaV? En dos
      palabras: no mucho. Al menos no aún, no en Subversion 1.0.
    </para>

    <para>
      Mientras que libsvn_ra_dav envía solicitudes DeltaV al servidor, el
      cliente de Subversion <emphasis>no</emphasis> es un cliente DeltaV de
      propósito general. De hecho, espera ciertas características particulares
      (especialmente a través de solicitudes <literal>REPORT</literal>
      personalizadas). Además, mod_dav_svn <emphasis>no</emphasis> es
      un servidor DeltaV de propósito general. Sólo implementa un subconjunto
      estricto de la especificación DeltaV. Un cliente WebDAV o DeltaV más
      general puede interoperar bastante bien con él, pero sólo si el cliente
      opera dentro de los estrechos confines de aquéllas caractrísticas que el
      servidor ha implementado. El equipo de desarrollo de Subversion planea
      completar la interoperabilidad general con WebDAV en un lanzamiento futuro
      de Subversion.
    </para>

    <sect2 id="svn-ap-c-sect-2.1">
      <title>Mapping Subversion to DeltaV</title>

      <para>
        Aquí se presenta una descripción muy general de cómo varias operaciones
        del cliente de Subversion usan DeltaV. En muchos casos, estas
        explicaciones son simplificaciones groseras. <emphasis>No</emphasis>
        deberían ser tomadas como un sustituto frente a leer el código fuente de
        Subversion o hablar con sus desarrolladores.
      </para>

      <variablelist>

        <varlistentry>
          <term>svn checkout/list</term>
          <listitem>
            <para>
              Ejecuta un <literal>PROPFIND</literal> de profundidad 1 en la
              <!--TODO:que se está traduciendo por collecction-->
              colección para obtener una lista de los hijos inmediatos. Ejecuta
              un <literal>GET</literal>(y posiblemente un
              <literal>PROPFIND</literal>) en cada hijo. Avanza recursivamente
              dentro de las colecciones y repite.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>svn commit</term>
          <listitem>
            <para>
              Crea una actividad con <literal>NKACTIVITY</literal>, y hace un
              <literal>CHECKOUT</literal> de cada ítem que ha cambiado, seguido
              de un <literal>PUT</literal> de datos nuevos. Finalmente, una
              solicitud de <literal>MERGE</literal>provoca un
              <literal>CHECKIN</literal> implícito de todos los recursos de
              trabajo.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>svn update/switch/status/merge/diff</term>
          <listitem>
            <para>
              Envía una petición personalizada <literal>REPORT</literal> que 
              describe 
              <!--TODO: no entiendo este pedazo-->
              Send a custom <literal>REPORT</literal> request that
              describes the mixed-revision (and mixed-url) state of
              the working copy.  The server sends a custom response
              that describes which items need updating.  The client
              loops over the response, performing
              <literal>GET</literal> and <literal>PROPFIND</literal>
              requests as needed.  For updates and switches, install
              the new data in the working copy.  For diff and merge
              commands, compare the data to the working copy, possibly
              applying changes as local modifications.
            </para>
          </listitem>
        </varlistentry>

      </variablelist>

    </sect2>

    <sect2 id="svn-ap-c-sect-2.2">
      <title>Soporte de autoversionado</title>

      <para>
        En el momento de escribir esto, la verdad es que hay muy pocos clientes
        DeltaV en el mundo; el RFC 3253 aún es relativamente nuevo. Sin embargo,
        los usuario tienen acceso a clientes <quote>genéricos</quote>, porque
        casi cada sistema operativo moderno tiene integrado un cliente básico
        WebDAV. Con esto en mente, los desarrolladores de Subversion se dieron
        cuenta de que si Subversion 1.0 iba a tener
        <emphasis>cualquier</emphasis> característica de interoperabilidad, el
        soporte para autoversionado DeltaV sería la mejor aproximación.
      </para>

      <para>
        Para activar el auotversionado en mod_dav_svn, use la directiva
        <literal>SVNAutoversioning</literal> dentro del bloque
        <literal>Location</literal> en el archivo
        <filename>httpd.conf</filename>, así:
      </para>

      <screen>
        &lt;Location /repos&gt;
        DAV svn
        SVNPath /absolute/path/to/repository
        SVNAutoversioning on
        &lt;/Location&gt;
      </screen>

      <para>
        Normalmente, si un  cliente WebDAV genérico intentó un
        <literal>PUT</literal> a una ruta dentro de la ubicación de su
        repositorio, mod_dav_svn rechazaría la petición.
        <!--TODO:location, mod_dav_svn would outright reject the request.  (It-->
        (Normalmente sólo permite este tipo de operaciones en <quote>recursos de
          trabajo</quote> dentro de <quote>actividades</quote> DeltaV.) Con la
        opción <literal>SVNAutoversioning</literal> activada, sin embargo, el
        servidor interpreta la petición <literal>PUT</literal> como un
        <literal>MKACTIVITY</literal>, <literal>CHECKOUT</literal>,
        <literal>PUT</literal> y <literal>CHECKIN</literal>. Un mensaje de
        registro genérico se genera automáticamente, y se crea además una nueva 
        revisión del sistema de archivos
      </para>

      <para>
        Dado que muchos sistemas operativos ya tienen integradas habilidades
        WebDAV, el caso de uso para esta característica raya en lo fantástico:
        imagine una oficina de usuarios ordinarios ejecutando Windows o Mac OS.
        Cada computador <quote>monta</quote> el repositorio de Subversion, que
        aparece como una unidad compartida de red cualquiera. Usan el servidor
        como siempre lo hacen: abren archivos del servidor, los editan, y los
        guardan de vuelta en el servidor. Pero en esta fantasía, el servidor
        está versionando todo automáticamente. Después, un administrador del
        sistema puede usar un cliente de Subversion para buscar y recuperar
        todas las versiones antigüas.

      </para>

      <para>
        ¿Es esta fantasía real? No mucho. El problema principal es que
        Subversion 1.0 no tiene ningún tipo de soporte para los métodos
        <literal>LOCK</literal> o <literal>UNLOCK</literal>. Muchos clientes DAV
        de sistemas operativos intentan hacer un <literal>LOCK</literal> sobre
        un recurso abierto directamente de una unidad compartida montada
        mediante DAV. Por ahora, los usuarios pueden tener que copiar un archivo
        de la unidad DAV al disco local, etidar el archivo, y copiarlo de
        vuelta. No es el autoversionado ideal, pero aún hacible.
        <!--Mi novia dice que hacible existe como verbo, a pesar de lo mal que
        suene-->
      </para>

    </sect2>

    <sect2 id="svn-ap-c-sect-2.3">
      <title>La Alternativa mod_dav_lock</title>

      <para>
        El módulo mod_dav de Apache es una bestia compleja: entiende y analiza
        sintácticamente todos los métodos WebDAV y DeltaV, pero depende de un
        proveedor externo para acceder a los recursos en sí.
      </para>

      <para>
        En su encarnación más simple, un usuario puede usar mod_dav_sf como un
        proveedor para mod_dav. mod_dav_fs usa el sistema de archivos ordinario
        para guardar archivos y directorios, y sólo entiende métodos WebDAV
        puros, no DeltaV.
      </para>

      <para>
        Subversion, por otra parte, usa mod_dav_svn como un proveedor para
        mod_dav. mod_dav_svn entiende todos los métodos WebDAV excepto
        <literal>LOCK</literal>, y entiende un subconjunto medible de métodos
        DeltaV. Él accesa los datos en el repositorio Subversion, en vez de
        hacerlo en el sistema de archivos real.
        Subversion 1.0 no soporta bloqueo, porque sería realmente difícil de
        implementar, dado que Subversion usa el modelo copiar-modificar-mezclar.
        <footnote><para>Tal vez algún día Subversion desarrolle un modelo de
            checkout reservado con bloqueo que pueda vivir en paz con
            copiar-modificar-mezclar, pero probablemente esto no pase pronto.</para></footnote>

      </para>

      <para>
        En Apache httpd-2.0, mod_dav soporta el método <literal>LOCK</literal>
        llevando la cuenta de los bloqueos en una base de datos privada,
        asumiendo que el proveedor quiera aceptar esto. En Apache httpd-2.1 o
        posterior, sin embargo, el soporte de bloqueo se ha puesto en un módulo
        independiente, mod_dav_lock. Esto le permite a cualquier proveedor de
        mod_dav hacer uso de la base de datos de bloqueos, incluyendo a
        mod_dav_svn, aún cuando mod_dav_svn no sabe nada de bloqueo actualmente.
      </para>

      <para>¿Confundido aún?</para>

      <para>
        Resumiendo, mod_dav_lock puede usarse en Apache httpd-2.1
        <!--TODO:cómo carajos se traduce "in a nutshell"?-->
        (o posterior) para crear la <emphasis>ilusión</emphasis> de que
        mod_dav_svn está cumpliendo las peticiones <literal>LOCK</literal>.
        <!--TODO:mod_dav_svn is honoring--> 
        Asegúrese de que mod_dav_lock esté compilado en httpd, o de que está
        siendo cargado en su <filename>httpd.conf</filename>. Luego simplemente
        añada la directiva <literal>DAVGenericLockDB</literal> a su archivo 
        de manera similar a ésta:
      </para>

      <screen>
        &lt;Location /repos&gt;
        DAV svn
        SVNPath /absolute/path/to/repository
        SVNAutoversioning on
        DavGenericLockDB /path/to/store/locks
        &lt;/Location&gt;
      </screen>

      <para>
        Esta técnica es un negocio peligroso; de cierta manera, mod_dav_svn le
        está mintiendo ahora al cliente WebDAV. El módulo dice aceptar las
        solicitudes <literal>LOCK</literal>, pero en realidad el bloqueo 
        no está siendo forzado en todos los niveles. Si un segundo cliente
        WebDAV intenta hacer un <literal>LOCK</literal> sobre el mismo recurso,
        entonces mod_dav_lock se dará cuenta de ello y denegará (correctamente)
        la solicitud.
        Pero no hay absolutamente nada que evite que un cliente Subversion
        ordinario cambie el archivo vía el comando <command>svn
          commit</command>!. Si usted usa esta técnica, le está dando a los
        usuarios la oprtunidad de pisotear los cambios de otros.
        En paticular, un cliente WebDAV podría sobreescribir accidentalmente un
        cambio enviado por cliente svn normal.
      </para>

      <para>
        Por otra parte, si usted prepara su entorno cuidadosamente, puede
        mitigar el riesgo. Por ejemplo, si <emphasis>todos</emphasis> sus
        usuarios están trabajando a través de clientes WebDAV básicos (en vez de
        clientes svn), entonces todo debería estar bien.
        <!--TODO: parece que hay un typo en el libro original
        carefully, you may mitigate the risk.  For example, if
        <emphasis>all</emphasis> of your users are working THOUGH-->
      </para>

    </sect2>

  </sect1>

  <sect1 id="svn-ap-c-sect-3">
    <title>Interoperabilidad de autoversionado</title> 

    <para>
      En esta sección describiremos los clientes WebDAV genéricos más comunes
      (al momento de escribir esto), y qué tan bien operan con un servidor
      mod_dav_svn usando la directiva <literal>SVNAutoversioning</literal>. El
      RFC 2518 es un poco largo, y tal vez demasiado flexible. Cada cliente
      WebDAV se comporta ligeramente diferente, y esto crea problemas
      ligeramente diferentes.
    </para>

    <!-- list of subsections goes here. -->

    <sect2 id="svn-ap-c-sect-3.1">
      <title>WebFolders Win32</title>

      <para>
        Windows 98, 2000, y XP tienen un cliente integrado WebDAV conocido como
        <quote>WebFolders</quote>. En Windows 98, esta característica puede
        necesitar ser instalada de manera explícita; si está presente, un
        directorio <quote>WebFolders</quote> aparece directamente dentro de Mi
        <!--TODO: debería dejar my computer en vez de mi pc?-->
        PC. En Windows 2000 y XP, simplemente abra Mis Sitios de Red, y ejecute
        el icono Añadir Sitio de Red.
        <!--TODO: me dan ganas de decir haga clic sobre el icono tal, pero mejor
        espero...-->
        Cuando se le solicite, ingrese la URL WebDAV. La carpeta compartida
        aparecerá dentro de Mis Sitios de Red.
      </para>

      <para>
        Muchas de las operaciones de escritura funcionan bien con un servidor de
        autoversionado mod_dav_svn, pero hay unos cuantos problemas:
      </para>

      <itemizedlist>

        <listitem>
          <para>
            Si un computador Windows XP es miembro de un dominio NT, parece ser
            incapaz de conectarse a la carpeta compartida WebDAV. Pide
            repetidamente el nombre y contraseña, aún cuando el servidor Apache
            no está presentando un reto de autenticación!
            <!--TODO: me gustaría dejar esto como "no está solicitando
            autenticación", pero es lo que dice el libro-->
            Si la máquina no es parte de un dominio NT, entonces la carpeta
            compartida es montada sin ningún problema.
          </para>

          <para>
            Este problema parece surgir de los cambios en la manera en que
            Windows XP crea accesos directos WebFolder (archivos
            <!--TODO: traduje shortcut como acceso directo, aunque sé que se
            usan términos como atajo, si bien menos conocidos que el que uso
            aquí-->
            <filename>.lnk</filename>). Algunas veces reemplaza
            la URL de la carpeta compartida WebDAV con una ruta Windows
            <quote>UNC</quote> (Universal Naming Convention). Esto hace que
            Explorer intente hacer la conexión usando SMB en vez de HTTP.
          </para>

          <para>
            Una manera de resolver el problema es crear el acceso directo
            <filename>.lnk</filename> en un computador Windows 2000 y luego
            copiar el acceso directo  al computador  Windows XP. Porbablemente
            también sería posible <quote>arreglar</quote> el acceso directo
            usando un editor HEX, si se fuera a hacer ingeniería inversa sobre
            el formato de archivo <filename>.lnk</filename>.
          </para>
        </listitem>

        <listitem>
          <para>
            Un archivo no puede ser abierto para edición directamente sobre la
            carpeta compartida; siempre es de sólo lectura. La técnica
            mod_dav_lock no ayuda, porque los WebFolders no usan el método
            <literal>LOCK</literal> en absoluto. Sin embargo, el método <literal>copiar,
              editar, re-copiar</literal>, mencionado anteriormente, funciona.
            El archivo en la carpeta compartida puede ser sobreescrito
            exitosamente por una copia editada localmente.
          </para>
        </listitem>

      </itemizedlist>

    </sect2>

    <sect2 id="svn-ap-c-sect-3.2">
      <title>Mac OS X</title>

      <para>
        El sistema operativo de Apple, OS X, tiene un cliente WebDAV integrado.
        Desde Finder, seleccione el ítem <quote>Conectar a servidor</quote>
        desde el menú Ir. Ingrese una URL WebDAV, y ésta aparecerá como un disco
        en el escritorio, como cualquier servidor de archivos.
        <footnote><para>Los usuarios de Unix también pueden ejecutar
            <command>mount -t webdav URL /mountpoint</command>.</para></footnote>
      </para>

      <para>
        Desafortunadamente, este cliente se rehúsa a trabajar con autoversionado
        mod_dav_svn debido a la falta de soporte de <literal>LOCK</literal>. Mac
        OS X descubre la falta de <literal>LOCK</literal> durante el intercambio
        de las características HTTP <literal>OPTIONS</literal>, y debido a esto
        monta el repositorio Subversion como una carpeta compartida de sólo
        lectura. Desupés de esto, no es posible hacer operaciones de escritura
        en absoluto. Para montar el repositorio como una carpeta compartida de
        lectura-escritura, usted <emphasis>debe</emphasis> usar el truco con
        mod_dav_lock como se discutión previamente. Una vez el bloqueo parezca
        trabajar, la carpeta compartida se comporta bastante bien: los archivos
        pueden abrirse directamente para lectura/escritura, aunque cada
        operación de guardado hará que el cliente haga un <literal>PUT</literal>
        a una ubicación temporal, un <literal>DELETE</literal> del archivo
        original, y un <literal>MOVE</literal> del recurso temporal al nombre de
        archivo original. ¡Ésas son tres revisiones Subversion nuevas en cada
        guardado!
      </para>

      <para>
        Una palabra de advertencia: El cliente WebDAV de OS X puede ser
        demasiado sensitivo a las redirecciones HTTP. Si usted no puede montar
        el repositorio en absoluto, puede que necesite habilitar la directiva
        <literal>BrowserMatch</literal> en su <filename>httpd.conf</filename>:
      </para>

      <screen>
        BrowserMatch "^WebDAVFS/1.[012]" redirect-carefully
      </screen>

    </sect2>

    <sect2 id="svn-ap-c-sect-3.3">
      <title>Unix: Nautilus 2</title>

      <para>
        Nautilus es el administrador/explorador de archivos oficial del
        escritorio GNOME. Su página principal está en 
        <systemitem class="url">http://www.gnome.org/projects/nautilus/</systemitem>.
        Sólo con escribir una URL WebDAV en la ventana de Nautilus, la carpeta
        DAV aparece como un sistema de archivos local.
      </para>

      <para>
        En general, Nautilus 2 trabaja razonablemente bien con un mod_dav_svn
        que haga autoversionado, con las siguientes precauciones:
      </para>

      <itemizedlist>

        <listitem>
          <para>
            Cualquier archivo abierto directamente desde la carpeta compartida
            es tratado como de sólo lectura. Aún el truco con mod_dav_lock
            parece no tener efecto. Parece que Nautilus nunca llama
            <!--TODO:traduje issue como llamar. No es lo más correcto pero suena
            bastante bien :) 
            no effect.  It seems that Nautilus never issues the-->
            el método <literal>LOCK</literal> en absoluto. El truco
            <quote>copiar localmente, editar, copiar de vuelta</quote> funciona,
            sin embargo. Desafortunadamente, Nautilus sobreescribe el archivo
            viejo llamando a <literal>DELETE</literal> primero, lo que crea una
            revisión extra.
          </para>
        </listitem>

        <listitem>
          <para>
            Cuando se sobreescribe o se crea un archivo, Nautilus hace primero
            un <literal>PUT</literal> de un archivo vacío, y luego lo
            sobreescribe con un segundo <literal>PUT</literal>. Esto crea dos
            revisiones en el sistema de archivos Subversion, en vez de una sola.
          </para>
        </listitem>

        <listitem>
          <para>
            Cuando se borra una colección, se llama un <literal>DELETE</literal>
            HTTP en cada hijo individual en vez de hacerlo sobre toda la
            colección. Esto crea un montón de revisiones nuevas.
          </para>
        </listitem>

      </itemizedlist>

    </sect2>

    <sect2 id="svn-ap-c-sect-3.4">
      <title>Linux davfs2</title>

      <para>Linux davfs2 es un módulo de sistema de archivos para el kernel de
        Linux, cuyo desarrollo se ubica en 
        <systemitem class="url">http://dav.sourceforge.net/</systemitem>. Una
        vez instalado, una carpeta WebDAV compartida puede ser montada con el
        comando estándar de Linux <command>mount</command>.
        <!--TODO: tal vez me excedo un poco en el ajuste de forma, pero suena
        mejor que la traducción literal al español
        
        installed, a WebDAV network share can be mounted with the
        usual Linux <command>mount</command> command.
        -->
      </para>

      <para>
        Se dice en las calles que este cliente DAV no funciona en absoluto con
        el autoversionado de mod_dav_svn. Cada intento de escribir al servidor
        es precedido por una solicitud <literal>LOCK</literal>, que mod_dav_svn,
        no soporta. En este momento, no hay datos que indiquen si el uso de
        mod_dav_lock resuelva este problema.
      </para>

    </sect2>

  </sect1>

</appendix>

<!--
local variables: 
sgml-parent-document: ("book.xml" "appendix")
end:
-->
