#!/usr/bin/perl -w

#=======================================================================
# $Id$
# Generate translation status information. Used in the 
# TRANSLATION-STATUS file, but can also be run on single/multiple files 
# specified on the command line. All output goes to stdout.
#
# Character set: UTF-8
# License: GNU General Public License version 2 or later, see end of 
# file for legal stuff.
#=======================================================================

use strict;
use Getopt::Long;

$| = 1;

our $Debug = 0;
my $STD_PRECISION = 2;

our %Opt = (
    # {{{
    'debug' => 0,
    'directory' => "",
    'full' => 0,
    'help' => 0,
    'precision' => $STD_PRECISION,
    'verbose' => 0,
    'version' => 0,
    # }}}
);

our $progname = $0;
$progname =~ s#^.*/(.*?)$#$1#;

my $rcs_id = '$Id$';
my $id_date = $rcs_id;
$id_date =~ s/^.*?\d+ (\d\d\d\d-.*?\d\d:\d\d:\d\d\S+).*/$1/;

Getopt::Long::Configure("bundling");
GetOptions(
    # {{{
    "debug" => \$Opt{'debug'},
    "directory|d=s" => \$Opt{'directory'},
    "full|f" => \$Opt{'full'},
    "help|h" => \$Opt{'help'},
    "precision|p=i" => \$Opt{'precision'},
    "verbose|v+" => \$Opt{'verbose'},
    "version" => \$Opt{'version'},
    # }}}
) || die("$progname: Option error. Use -h for help.\n");

$Opt{'debug'} && ($Debug = 1);
$Opt{'precision'} =~ /[^\d]/ &&
    die("$progname: Invalid character in --precision (-p) argument\n");
$Opt{'help'} && usage(0);
$Opt{'version'} && print_version();

my @Files = @ARGV;
if (!scalar(@Files)) {
    die("$progname: No file names specified\n");
}
my %All = (
    'total' => 0,
    'CHK' => 0,
    'TR' => 0,
);

exit(main(@Files));

sub main {
    # {{{
    my @Files = @_;
    my $Retval = 0;
    # Print header {{{
    print(<<END) if ($Opt{'full'});
TRANSLATION-STATUS for the Norwegian svnbook
============================================

Status of the Norwegian translation of the Subversion documentation. 
This file is generated and should not be edited manually, update the 
bin/genstat script instead.

\x24Id\$

END
    # }}}

    for my $Curr (@Files) {
        $Curr = length($Opt{'directory'}) ? ("$Opt{'directory'}/$Curr")
                                          : ($Curr);
        D("Curr = '$Curr'");
        read_file($Curr);
    }

    my ($total_translated, $total_chk) = (0, 0);

    if ($All{'total'} != 0) {
        $total_translated = sprintf(
            "%.$Opt{'precision'}f",
            ($All{'total'} - $All{'TR'}) / $All{'total'} * 100.0
        );
        $total_chk = sprintf(
            "%.$Opt{'precision'}f",
            $All{'CHK'} / $All{'total'} * 100.0
        );
    }
    print("\nSumma summarum: $total_translated% translated, $total_chk% need proofreading\n");
    return($Retval);
    # }}}
} # main()

sub read_file {
    # Read a file and print all translation information about it. {{{
    # Format:
    # ----
    # * book/ch-advanced-topics.xml - 109485 bytes, 2339 lines
    #     Untranslated: 80.92% - 3 blocks
    #         Line 570-587 (16)
    #         Line 887-896 (8)
    #         Line 962-2813 (1850)
    #     Need proofreading: 19.71% - 1 block
    #         Line 1-957 (955)
    # ----
    my $File = shift;

    if (open(FileFP, "<", $File eq "-" ? *STDIN : $File)) {
        my $Data = join("", <FileFP>);
        close(FileFP);
        my $total_lines = count_lines(strip_english($Data));
        my $est_size = length(strip_english($Data));
        $All{'total'} += $est_size;
        printf("* %s - %u byte%s, %u line%s\n",
            $File,
            $est_size,
            $est_size == 1 ? "" : "s",
            $total_lines,
            $total_lines == 1 ? "" : "s"
        );
        print(file_entry($Data, "Untranslated", "TR"));
        print(file_entry($Data, "Need proofreading", "CHK"));
    } else {
        warn("$progname: $File: Cannot open file for read: $!\n");
    }
    # }}}
} # read_file()

sub file_entry {
    # Return block information for a specific marker type {{{
    my ($Data, $Title, $Marker) = @_;
    D("Entering file_entry(Data, '$Title', '$Marker')");
    my $Retval = "";
    my $perc_untrans = block("percent", strip_english($Data), $Marker);
    D("perc_untrans = '$perc_untrans'");
    my $block_count = block("count", strip_english($Data), $Marker);
    my $block_size = block("size", strip_english($Data), $Marker);
    $All{$Marker} += $block_size;
    if ($perc_untrans != 0) {
        $Retval .= sprintf("    $Title: %.$Opt{'precision'}f%% - %u block%s\n",
            $perc_untrans,
            $block_count,
            $block_count == 1 ? "" : "s"
        );
        $Retval .= line_numbers($Data, $Marker);
    } else {
        $Retval .= ("    Translation complete\n") if ($Marker eq "TR");
    }
    return($Retval);
    # }}}
} # file_entry()

sub line_numbers {
    # Return a list of line numbers for start/end of blocks {{{
    my ($Data, $Marker) = @_;
    my $Retval = "";
    my $Total = 0;

    while ($Data =~
        /^
            (.*?)
            (<!--\s\@$Marker\s{{\s-->)
            (.*?)
            (<!--\s\@$Marker\s}}\s-->)
            (.*)
        $/sx
    ) {
        $Retval .= line_range($1, $2, $3, $4, $Total);
        $Data = $5;
        $Total += count_lines(join("", $1, $2, $3, $4));
    }
    return($Retval);
    # }}}
} # line_numbers()

sub line_range {
    # Return a line number range {{{
    my ($Pre, $First, $Content, $Second, $Offset) = @_;
    my $Retval = "";
    my %Lines = (
        'Pre'     => count_lines($Pre),
        'First'   => count_lines($First),
        'Content' => count_lines($Content),
        'Second'  => count_lines($Second)
    );
    D("Lines: " . join("|", %Lines));
    my $start_line = $Offset + $Lines{'Pre'};
    D("start_line = '$start_line'");
    my $end_line = $start_line + $Lines{'Content'};
    D("Content \x7B\x7B\x7B\n$Content\nContent \x7D\x7D\x7D", 3);
    D("end_line = '$end_line'");
    my $line_count = $end_line - $start_line;

    $Retval .= sprintf("        Line %u-%u (%u)\n",
                       $start_line + 1, $end_line + 1,
                       ($line_count > 2) ? $line_count - 1 : 1
    );
    return($Retval);
    # }}}
} # line_range()

sub block {
    # Return various block info for a specific marker type {{{
    my ($What, $Txt, $Marker) = @_;
    D("Entering block('$What', '" . substr($Txt, 0, 20) . "...', '$Marker')");
    my $Retval = "";

    my $Total = length($Txt);
    if ($What eq "percent") {
        # Return percent of the total size the blocks occupy
        $Txt =~ s/( \@$Marker }} -->)\n$/$1/s;
        $Txt =~ s/<!-- \@$Marker {{ .*? \@$Marker }} -->//gs;
        $Retval = $Total ? ($Total - length($Txt)) / $Total * 100.0 : 0;
        D("block('percent'): Retval = '$Retval', Total = '$Total'");
    } elsif ($What eq "count") {
        # Return number of blocks
        $Retval = ($Txt =~ s/<!-- \@$Marker {{ .*? \@$Marker }} -->//gs);
    } elsif ($What eq "size") {
        # Return number of bytes the blocks occupy
        $Txt =~ s/<!-- \@$Marker {{ .*? \@$Marker }} -->//gs;
        $Retval = $Total - length($Txt);
    } else {
        die("block(): '$What': Invalid value in \$What");
    }
    return($Retval);
    # }}}
} # block()

sub strip_english {
    my $Txt = shift;
    # Strip @ENGLISH sections from data {{{
    # The following regexp removes the @ENGLISH sections from $Txt 
    # before the size and percent calculation begins. This is to prevent 
    # skew in the result caused by the extra volume of the translated 
    # files versus the English master files. This is the least intrusive 
    # way of calculating this without also checking out a copy of the 
    # English files. Weâ€™re not _that_ picky.
    $Txt =~ s/\n *?<!-- \@ENGLISH {{{.*?\@ENGLISH }}} -->\s*?\n/\n/gs;
    return($Txt);
    # }}}
} # strip_english()

sub count_lines {
    # Count number of lines in data {{{
    my $Txt = shift;
    my $Retval = ($Txt =~ s/\n//g);
    length($Retval) || ($Retval = 0);
    D("count_lines(): Retval = '$Retval'");
    return($Retval);
    # }}}
} # count_lines()

sub print_version {
    # Print program version {{{
    print("$rcs_id\n");
    exit(0);
    # }}}
} # print_version()

sub usage {
    # Send the help message to stdout {{{
    my $Retval = shift;

    print(<<END);

Generate translation status information. Used in the TRANSLATION-STATUS 
file, but can also be run on single/multiple files specified on the 
command line. All output goes to stdout.

$rcs_id

Usage: $progname [options] file [...]

Options:

  -d, --directory x
    File names are relative to directory x.
  -f, --full
    Generate full output with header for storage in the 
    TRANSLATION-STATUS file.
  -h, --help
    Show this help.
  -p, --precision x
    Use x decimal places in percent calculations. Default: $STD_PRECISION.
  -v, --verbose
    Increase level of verbosity. Can be repeated.
  --version
    Print version information.
  --debug
    Print debugging messages.

END
    exit($Retval);
    # }}}
} # usage()

sub D {
    # Print a debugging message {{{
    $Debug || return;
    my @call_info = caller;
    chomp(my $Txt = shift);
    my $verbose_level = shift;
    $Txt =~ s/\n/\\n/gs;
    defined($verbose_level) || ($verbose_level = 0);
    if ($Opt{'verbose'} >= $verbose_level) {
        my $File = $call_info[1];
        $File =~ s#\\#/#g;
        $File =~ s#^.*/(.*?)$#$1#;
        print(STDERR "$File:$call_info[2] $$ $Txt\n");
    }
    return("");
    # }}}
} # D()

__END__

# vim: set fenc=UTF-8 ft=perl fdm=marker ts=4 sw=4 sts=4 et fo+=w :
# End of file $Id$
