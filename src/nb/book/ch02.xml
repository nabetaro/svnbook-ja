<chapter id="svn.basic">
  <!-- @ENGLISH {{{
  <title>Basic Concepts</title>
  @ENGLISH }}} -->
  <title>Grunnleggende konsepter</title>

  <simplesect>
    <!-- @ENGLISH {{{
    <para>This chapter is a short, casual introduction to Subversion.
      If you're new to version control, this chapter is definitely for
      you.  We begin with a discussion of general version control
      concepts, work our way into the specific ideas behind
      Subversion, and show some simple examples of Subversion in
      use.</para>
    @ENGLISH }}} -->
    <para>Dette kapittelet er en kort, lettvint introduksjon til 
      Subversion.
      Hvis du er ny innen versjonskontroll, er dette kapittelet 
      definitivt for deg.
      Vi begynner med en diskusjon om generelle konsepter innen 
      versjonskontroll, jobber oss gjennom de spesifikke idéene bak 
      Subversion, og viser noen enkle eksempler på bruk av 
      Subversion.</para>
    
    <!-- @ENGLISH {{{
    <para>Even though the examples in this chapter show people sharing
      collections of program source code, keep in mind that Subversion
      can manage any sort of file collection&mdash;it's not limited to
      helping computer programmers.</para>
    @ENGLISH }}} -->
    <para>Selv om eksemplene i dette kapittelet viser personer som deler 
      samlinger av kildekode til programmer, husk at Subversion kan 
      behandle alle typer filsamlinger – det er ikke begrenset til å 
      hjelpe dataprogrammerere.</para>
  </simplesect>
  
  
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.repository">
    <!-- @ENGLISH {{{
    <title>The Repository</title>  
    @ENGLISH }}} -->
    <title>Depotet</title>
    
    <!-- @ENGLISH {{{
    <para>Subversion is a centralized system for sharing information.
      At its core is a repository, which is a central store of data.
      The repository stores information in the form of a
      <firstterm>filesystem tree</firstterm>&mdash;a typical hierarchy
      of files and directories.  Any number of
      <firstterm>clients</firstterm> connect to the repository, and
      then read or write to these files.  By writing data, a client
      makes the information available to others; by reading data, the
      client receives information from others.  <xref
      linkend="svn.basic.repository.dia-1"/> illustrates this.</para>
    @ENGLISH }}} -->
    <para>Subversion er et sentralisert system for å dele informasjon.
      Dens kjerne er et depot, som er et sentralt lager av data.
      Depotet lagrer informasjon i form av et 
      <firstterm>filsystemtre</firstterm> – et typisk hierarki av filer 
      og kataloger.
      Ethvert antall <firstterm>klienter</firstterm> kobler seg til 
      depotet, og leser eller skriver deretter til disse filene.
      Ved å skrive data, gjør klienten informasjonen tilgjengelig for 
      andre; ved å lese data henter klienten informasjon fra andre. 
      <xref linkend="svn.basic.repository.dia-1"/> illustrerer 
      dette.</para>

    <figure id="svn.basic.repository.dia-1">
      <!-- @ENGLISH {{{
      <title>A typical client/server system</title>
      @ENGLISH }}} -->
      <title>Et typisk klient/&server;-system</title>
      <graphic fileref="images/ch02dia1.png"/>
    </figure>
    
    <!-- @ENGLISH {{{
    <para>So why is this interesting?  So far, this sounds like the
      definition of a typical file server.  And indeed, the repository
      <emphasis>is</emphasis> a kind of file server, but it's not your
      usual breed.  What makes the Subversion repository special is
      that <emphasis>it remembers every change</emphasis> ever written
      to it: every change to every file, and even changes to the
      directory tree itself, such as the addition, deletion, and
      rearrangement of files and directories.</para>
    @ENGLISH }}} -->
    <para>Så hvorfor er dette interessant?
      Så langt høres dette ut som definisjonen av en typisk fil&server;.
      Og det stemmer, depotet <emphasis>er</emphasis> en slags 
      fil&server;, men ikke den typen du vanligvis kommer ut for.
      Det som gjør Subversiondepotet spesielt er at <emphasis>det husker 
      hver eneste forandring</emphasis> noensinne skrevet til det: Hver 
      forandring til hver eneste fil, og til og med forandringer i selve 
      katalogtreet, som opprettelser, slettinger og ommøbleringer i 
      filer og kataloger.</para>

    <!-- @ENGLISH {{{
    <para>When a client reads data from the repository, it normally
      sees only the latest version of the filesystem tree.  But the
      client also has the ability to view
      <emphasis>previous</emphasis> states of the filesystem.  For
      example, a client can ask historical questions like, <quote>What
      did this directory contain last Wednesday?</quote> or <quote>Who
      was the last person to change this file, and what changes did
      he make?</quote> These are the sorts of questions that are at
      the heart of any <firstterm>version control system</firstterm>:
      systems that are designed to record and track changes to data
      over time.
    </para>
    @ENGLISH }}} -->
    <para>Når en klient leser data fra depotet, ser den vanligvis bare 
      den siste versjonen av filsystemtreet.
      Men klienten har også muligheten til å se 
      <emphasis>tidligere</emphasis> tilstander av filsystemet.
      For eksempel, en klient kan spørre historiske spørsmål som:
      <quote>Hva inneholdt denne katalogen forrige onsdag?</quote> eller 
      <quote>Hvem var den siste personen som forandret denne filen, og 
      hvilke forandringer gjorde vedkommende?</quote>
      Dette er typen spørsmål som er hjertet av ethvert 
      <firstterm>versjonskontrollsystem</firstterm>:
      Systemer som er designet for å lagre og følge forandringer i data 
      over tid.</para>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.vsn-models">
    <!-- @ENGLISH {{{
    <title>Versioning Models</title>
    @ENGLISH }}} -->
    <title>Versjoneringsmodeller</title>

    <!-- @ENGLISH {{{
    <para>The core mission of a version control system is to enable
      collaborative editing and sharing of data.  But different
      systems use different strategies to achieve this.</para>
    @ENGLISH }}} -->
    <para>Hovedmålet for et versjonskontrollsystem er å muliggjøre 
      samarbeidsredigering og deling av data.
      Men forskjellige systemer bruker forskjellige strategier for å 
      oppnå dette.</para>
    
    <!-- =============================================================== -->
    <sect2 id="svn.basic.vsn-models.problem-sharing">
      <!-- @ENGLISH {{{
      <title>The Problem of File-Sharing</title>
      @ENGLISH }}} -->
      <title>Problemet med fildeling</title>
      
      <!-- @ENGLISH {{{
      <para>All version control systems have to solve the same
        fundamental problem: how will the system allow users to share
        information, but prevent them from accidentally stepping on
        each other's feet?  It's all too easy for users to
        accidentally overwrite each other's changes in the
        repository.</para>
      @ENGLISH }}} -->
      <para>Alle versjonskontrollsystemer må løse det samme fundamentale 
        problemet:
        Hvordan vil systemet tillate brukere å dele informasjon, men 
        forhindre dem fra å tråkke hverandre på tærne?
        Det er alt for lett for brukere å overskrive hverandres 
        forandringer i depotet ved en ulykke.</para>

      <!-- @ENGLISH {{{
      <para>Consider the scenario shown in <xref
        linkend="svn.basic.vsn-models.problem-sharing.dia-1"/>.
        Suppose we have two co-workers, Harry and Sally.  They each
        decide to edit the same repository file at the same time.  If
        Harry saves his changes to the repository first, then it's
        possible that (a few moments later) Sally could accidentally
        overwrite them with her own new version of the file.  While
        Harry's version of the file won't be lost forever (because the
        system remembers every change), any changes Harry made
        <emphasis>won't</emphasis> be present in Sally's newer version
        of the file, because she never saw Harry's changes to begin
        with.  Harry's work is still effectively lost&mdash;or at
        least missing from the latest version of the file&mdash;and
        probably by accident.  This is definitely a situation we want
        to avoid!</para>
      @ENGLISH }}} -->
      <para>Tenk over scenariet vist i <xref 
        linkend="svn.basic.vsn-models.problem-sharing.dia-1"/>.
        Sett at vi har to arbeidskolleger, Harry og Sally.
        De bestemmer seg begge for å redigere den samme filen i depotet 
        samtidig.
        Hvis Harry lagrer sine forandringer til depotet først, er det 
        (noen øyeblikk senere) mulig at Sally feilaktig overskriver dem 
        med hennes egen nye versjon av filen.
        Selv om Harrys versjon av filen ikke vil være tapt for alltid 
        (fordi systemet husker hver eneste forandring), vil alle 
        forandringene Harry gjorde <emphasis>ikke</emphasis> være med i 
        Sallys nyere versjon av filen, fordi hun så aldri Harrys 
        forandringer til å begynne med.
        Harrys arbeid er fortsatt borte – eller i det minste borte fra 
        den siste versjonen av filen – og sannsynligvis ved en ulykke.
        Dette er definitivt en situasjon vi vil unngå!</para>

      <figure id="svn.basic.vsn-models.problem-sharing.dia-1">
        <!-- @ENGLISH {{{
        <title>The problem to avoid</title>
        @ENGLISH }}} -->
        <title>Problemet som må unngås</title>
        <graphic fileref="images/ch02dia2.png"/>
      </figure>

      </sect2>
    
    <!-- =============================================================== -->
    <sect2 id="svn.basic.vsn-models.lock-unlock">
      <!-- @ENGLISH {{{
      <title>The Lock-Modify-Unlock Solution</title>
      @ENGLISH }}} -->
      <title><quote>Lås-rediger-lås opp</quote>-løsningen</title>
      
      <!-- @ENGLISH {{{
      <para>Many version control systems use a
        <firstterm>lock-modify-unlock</firstterm> model to address the
        problem of many authors clobbering each other's work.  In this
        model, the repository allows only one person to change a file
        at a time.  This exclusivity policy is managed using locks.
        Harry must <quote>lock</quote> a file before he can begin
        making changes to it.  If Harry has locked a file, then Sally
        cannot also lock it, and therefore cannot make any changes to
        that file.  All she can do is read the file, and wait for
        Harry to finish his changes and release his lock.  After Harry
        unlocks the file, Sally can take her turn by locking and
        editing the file.  <xref
        linkend="svn.basic.vsn-models.lock-unlock.dia-1"/>
        demonstrates this simple solution.</para>
      @ENGLISH }}} -->
      <para>Mange versjonskontrollsystemer bruker en modell av typen
        <firstterm>lås-rediger-lås opp</firstterm> når de tar for seg 
        problemet med at mange forfattere roter til hverandres arbeid.
        I denne modellen tillater depotet bare en person å forandre en 
        fil om gangen.
        Denne eksklusive arbeidsmåten styres ved bruk av låser.
        Harry må <quote>låse</quote> en fil før han kan begynne å gjøre 
        forandringer i den.
        Hvis Harry har låst en fil, kan ikke Sally også låse den, og kan 
        derfor ikke gjøre noen forandringer i denne filen.
        Alt hun kan gjøre er å lese filen og vente på at Harry gjør seg 
        ferdig med sine forandringer og så slipper låsen han har satt 
        opp.
        Etter at Harry låser opp filen kan Sally ta sin runde med å låse 
        og redigere filen.
        <xref linkend="svn.basic.vsn-models.lock-unlock.dia-1"/> 
        demonstrerer denne enkle løsningen.</para>
      
      <figure id="svn.basic.vsn-models.lock-unlock.dia-1">
        <!-- @ENGLISH {{{
        <title>The lock-modify-unlock solution</title>
        @ENGLISH }}} -->
        <title><quote>Lås-rediger-lås opp</quote>-løsningen</title>
        <graphic fileref="images/ch02dia3.png"/>
      </figure>
      
      <!-- @ENGLISH {{{
      <para>The problem with the lock-modify-unlock model is that it's
        a bit restrictive, and often becomes a roadblock for
        users:</para>
      @ENGLISH }}} -->
      <para>Problemet med <quote>lås-rediger-lås opp</quote>-metoden er 
        at den er ganske restriktiv, og blir ofte en hindring for 
        brukerne:</para>

      <itemizedlist>
        <!-- @ENGLISH {{{
        <listitem>
          <para><emphasis>Locking may cause administrative
            problems.</emphasis>

            Sometimes Harry will lock a file and then forget about it.
            Meanwhile, because Sally is still waiting to edit the file,
            her hands are tied.  And then Harry goes on vacation.  Now
            Sally has to get an administrator to release Harry's lock.
            The situation ends up causing a lot of unnecessary delay
            and wasted time.</para>
        </listitem>
        @ENGLISH }}} -->
        <listitem>
          <para><emphasis>Låsing kan medføre administrative 
            problemer.</emphasis>

            Noen ganger hender det at Harry låser en fil og glemmer den.
            I mellomtiden, fordi Sally fortsatt venter på å få redigere 
            filen, har hun hendene bundet.
            Og så drar Harry på ferie.
            Nå må Sally få en administrator til å fjerne Harrys lås.
            Situasjonen ender opp med mange forsinkelser og mye 
            bortkastet tid.</para>
        </listitem>
        
        <!-- @ENGLISH {{{
        <listitem>
          <para><emphasis>Locking may cause unnecessary
            serialization.</emphasis>

            What if Harry is editing the beginning of a text file,
            and Sally simply wants to edit the end of the same file?
            These changes don't overlap at all.  They could easily
            edit the file simultaneously, and no great harm would
            come, assuming the changes were properly merged together.
            There's no need for them to take turns in this
            situation.</para>
        </listitem>
        @ENGLISH }}} -->
        <listitem>
          <para><emphasis>Låsing kan forårsake unødvendig 
            serialisering.</emphasis>

            Hva hvis Harry redigerer begynnelsen av en tekstfil, og 
            Sally rett og slett bare vil redigere slutten av den samme 
            filen?
            Disse forandringene overlapper ikke i det hele tatt.
            De kan enkelt redigere filen samtidig, og ingen stor skade 
            vil skje, såfremt forandringene ble flettet fint sammen.
            Det er ingen vits i at de må vente på tur i denne 
            situasjonen.</para>
        </listitem>
    
        <!-- @ENGLISH {{{
        <listitem>
          <para><emphasis>Locking may create a false sense of
            security.</emphasis>

            Pretend that Harry locks and edits file A, while
            Sally simultaneously locks and edits file B.  But suppose
            that A and B depend on one another, and the changes made
            to each are semantically incompatible.  Suddenly A and B
            don't work together anymore.  The locking system was
            powerless to prevent the problem&mdash;yet it somehow
            provided a false sense of security.  It's easy for Harry and
            Sally to imagine that by locking files, each is beginning a
            safe, insulated task, and thus not bother
            discussing their incompatible changes early
            on.</para>
        </listitem>
        @ENGLISH }}} -->
        <listitem>
          <para><emphasis>Låsing kan skape en falsk følelse av 
            trygghet.</emphasis>

            Tenk deg at Harry låser og redigerer fil A, mens Sally 
            samtidig redigerer fil B.
            Tenk deg også at A og B er avhengig av hverandre, og 
            forandringene er hver for seg inkompatible med hverandre.
            Plutselig virker ikke A og B sammen mer.
            Låsesystemet var ikke i stand til å forhindre problemet – 
            men skapte likevel en falsk følelse av trygghet.
            Det er lett for Harry og Sally å tenke seg at ved å låse 
            filer, starter hver av dem en trygg, isolert oppgave, og de 
            bryr seg dermed ikke med å diskutere deres inkompatible 
            forandringer på et tidligere tidspunkt.</para>
        </listitem>
      </itemizedlist>

      </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.vsn-models.copy-merge">
      <!-- @ENGLISH {{{
      <title>The Copy-Modify-Merge Solution</title>
      @ENGLISH }}} -->
      <title><quote>Kopier-rediger-flett</quote>-løsningen</title>
      
      <!-- @ENGLISH {{{
      <para>Subversion, CVS, and other version control systems use a
        <firstterm>copy-modify-merge</firstterm> model as an
        alternative to locking.  In this model, each user's client
        contacts the project repository and creates a personal
        <firstterm>working copy</firstterm>&mdash;a local reflection
        of the repository's files and directories.  Users then work in
        parallel, modifying their private copies.  Finally, the
        private copies are merged together into a new, final version.
        The version control system often assists with the merging, but
        ultimately a human being is responsible for making it happen
        correctly.</para>
      @ENGLISH }}} -->
      <para>Subversion, CVS og andre versjonskontrollsystemer bruker en 
        modell av typen <firstterm>kopier-rediger-flett</firstterm> som 
        et alternativ til låsing.
        I denne modellen kontakter klienten til hver bruker 
        prosjektdepotet og lager en personlig 
        <firstterm>arbeidskopi</firstterm> – et lokalt speil av depotets 
        filer og kataloger.
        Brukere arbeider så parallelt ved å modifisere deres private 
        kopier.
        Til slutt blir de private kopiene flettet inn i en ny, endelig 
        versjon.
        Versjonskontrollsystemet hjelper ofte til med flettingen, men 
        til syvende og sist er det et menneske som er ansvarlig for å la 
        det skje skikkelig.</para>
      
      <!-- @ENGLISH {{{
      <para>Here's an example.  Say that Harry and Sally each create
        working copies of the same project, copied from the
        repository.  They work concurrently, and make changes to the
        same file A within their copies.  Sally saves her changes to
        the repository first.  When Harry attempts to save his changes
        later, the repository informs him that his file A is
        <firstterm>out-of-date</firstterm>.  In other words, that file
        A in the repository has somehow changed since he last copied
        it.  So Harry asks his client to <firstterm>merge</firstterm>
        any new changes from the repository into his working copy of
        file A.  Chances are that Sally's changes don't overlap with
        his own; so once he has both sets of changes integrated, he
        saves his working copy back to the repository.  <xref
        linkend="svn.basic.vsn-models.copy-merge.dia-1"/> and <xref linkend="svn.basic.vsn-models.copy-merge.dia-2"/>
        show this process.</para>
      @ENGLISH }}} -->
      <para>Her er et eksempel.
        La oss si at Harry og Sally hver for seg lager arbeidskopier av 
        det samme prosjektet, kopiert fra depotet.
        De arbeider samtidig, og gjør forandringer i den samme filen A 
        innenfor sine kopier.
        Sally lagrer sine forandringer til depotet først.
        Når Harry prøver å lagre sine forandringer senere, informerer 
        depotet ham om at hans fil A er <firstterm>utdatert</firstterm>.
        Med andre ord, filen A i depotet har på en eller annen måte 
        forandret seg siden han kopierte den sist.
        Så Harry ber klienten sin om å <firstterm>flette</firstterm> 
        alle nye forandringer fra depotet inn i hans arbeidskopi av fil 
        A.
        Sjansene for at Sallys forandringer ikke overlapper med hans 
        egne er store; så når begges forandringer er lagt inn i filen, 
        lagrer han sin egen arbeidskopi til depotet. <xref 
        linkend="svn.basic.vsn-models.copy-merge.dia-1"/> og <xref 
        linkend="svn.basic.vsn-models.copy-merge.dia-2"/> viser denne 
        prosessen.</para>

      <figure id="svn.basic.vsn-models.copy-merge.dia-1">
        <!-- @ENGLISH {{{
        <title>The copy-modify-merge solution</title>
        @ENGLISH }}} -->
        <title><quote>Kopier-rediger-flett</quote>-løsningen</title>
        <graphic fileref="images/ch02dia4.png"/>
      </figure>
      
      <figure id="svn.basic.vsn-models.copy-merge.dia-2">
        <!-- @ENGLISH {{{
        <title>The copy-modify-merge solution (continued)</title>
        @ENGLISH }}} -->
        <title><quote>Kopier-rediger-flett</quote>-løsningen 
          (forts.)</title>
        <graphic fileref="images/ch02dia5.png"/>
      </figure>

      <!-- @ENGLISH {{{
      <para>But what if Sally's changes <emphasis>do</emphasis> overlap
        with Harry's changes?  What then?  This situation is called a
        <firstterm>conflict</firstterm>, and it's usually not much of
        a problem.  When Harry asks his client to merge the latest
        repository changes into his working copy, his copy of file A
        is somehow flagged as being in a state of conflict: he'll be
        able to see both sets of conflicting changes, and manually
        choose between them.  Note that software can't automatically
        resolve conflicts; only humans are capable of understanding
        and making the necessary intelligent choices.  Once Harry has
        manually resolved the overlapping changes&mdash;perhaps after
        a discussion with Sally&mdash;he can safely save the
        merged file back to the repository.</para>
      @ENGLISH }}} -->
      <para>Men hva hvis Sallys forandringer 
        <emphasis>likevel</emphasis> overlapper med Harrys forandringer?
        Hva da?
        Denne situasjonen kalles en <firstterm>konflikt</firstterm>, og 
        er vanligvis ikke mye til problem.
        Når Harry ber klienten sin om å flette sammen de nyeste 
        forandringene i depotet inn i hans arbeidskopi, blir det vist at 
        hans kopi av fil A er i konflikt:
        Han vil være i stand til å se begge settene av konfliktskapende 
        forandringer, og velge mellom dem manuelt.
        Legg merke til at programvare ikke kan løse konflikter 
        automatisk; bare mennesker er i stand til å forstå og gjøre de 
        nødvendige intelligente valgene.
        Når Harry har løst de overlappende forandringene manuelt – 
        kanskje etter en diskusjon med Sally – kan han trygt lagre den 
        flettede filen tilbake til depotet.</para>

      <!-- @ENGLISH {{{
      <para>The copy-modify-merge model may sound a bit chaotic, but
        in practice, it runs extremely smoothly.  Users can work in
        parallel, never waiting for one another.  When they work on
        the same files, it turns out that most of their concurrent
        changes don't overlap at all; conflicts are infrequent.  And
        the amount of time it takes to resolve conflicts is far less
        than the time lost by a locking system.</para>
      @ENGLISH }}} -->
      <para><quote>Kopier-rediger-flett</quote>-modellen kan høres litt 
        kaotisk ut, men i praksis går det ekstremt glatt.
        Brukere kan jobbe parallelt, og aldri vente på hverandre.
        Når de arbeider på de samme filene, viser det seg at mesteparten 
        av de samtidige forandringene ikke overlapper i det hele tatt; 
        konflikter er sjeldne.
        Og tiden det tar å løse konflikter er langt mindre enn tiden 
        tapt med et låsesystem.</para>

      <!-- @ENGLISH {{{
      <para>In the end, it all comes down to one critical factor: user
        communication.  When users communicate poorly, both syntactic
        and semantic conflicts increase.  No system can force users to
        communicate perfectly, and no system can detect semantic
        conflicts.  So there's no point in being lulled into a false
        promise that a locking system will somehow prevent conflicts;
        in practice, locking seems to inhibit productivity more than
        anything else.</para>
      @ENGLISH }}} -->
      <para>Til sist koker det hele ned til en kritisk faktor:
        Brukerkommunikasjon.
        Når brukerne kommuniserer dårlig, øker antallet av både <!-- ¤ 
        -->programmessige og <!-- ¤ -->språkmessige konflikter.
        Ingen systemer kan tvinge brukerne til å kommunisere perfekt, og 
        ingen systemer kan oppdage <!-- ¤ -->språkmessige konflikter.
        Så, det er ikke mye poeng i å bli lurt av et falskt løfte om at 
        et låsesystem på en eller annen måte vil forhindre konflikter;
        i praksis ser låsing ut til å hemme produktiviteten mer enn noe 
        annet.</para>
      
      <sidebar id="svn.basic.vsn-models.copy-merge.sb-1">
        <!-- @ENGLISH {{{
        <title>When Locking is Necessary</title>
        @ENGLISH }}} -->
        <title>Når låsing er nødvendig</title>
        
        <!-- @ENGLISH {{{
        <para>While the lock-modify-unlock model is considered
          generally harmful to collaboration, there are still times
          when locking is appropriate.</para>
        @ENGLISH }}} -->
        <para>Selv om <quote>lås-rediger-lås opp</quote>-modellen er 
          ansett som generelt skadelig for samarbeidet, passer det noen 
          ganger å bruke låsing.</para>

        <!-- @ENGLISH {{{
        <para>The copy-modify-merge model is based on the assumption
          that files are contextually mergeable: that is, that the
          majority of the files in the repository are line-based text
          files (such as program source code).  But for files with
          binary formats, such as artwork or sound, it's often
          impossible to merge conflicting changes.  In these
          situations, it really is necessary to users to take strict
          turns when changing the file.  Without serialized access,
          somebody ends up wasting time on changes that are ultimately
          discarded.</para>
        @ENGLISH }}} -->
        <para>Modellen kopier-rediger-flett er basert på forutsetningen 
          om at filer er flettbare, det vil si at majoriteten av filene 
          i depotet er linjebaserte tekstfiler (som for eksempel 
          kildekode).
          Men filer som inneholder binære data, som for eksempel bilder 
          eller lyd, er det det ofte umulig å flette inn forandringer 
          som lager konflikt.
          I disse situasjonene er det faktisk nødvendig at brukerne 
          forandrer filen etter tur.
          Uten en køordning i disse tilfellene vil noen ende opp med å 
          kaste bort tid på forandringer som noen andre har 
          forkastet.</para>

        <!-- @ENGLISH {{{
        <para>While CVS and Subversion are still primarily
          copy-modify-merge systems, they both recognize the need to
          lock an occasional file and provide mechanisms for this.
          See <xref linkend="svn.advanced.locking"/>.</para>
        @ENGLISH }}} -->
        <para>Selv om CVS og Subversion fortsatt hovedsaklig er 
          <quote>kopier-rediger-flett</quote>-systemer, ser begge 
          systemene nødvendigheten av å låse en fil nå og da og har 
          mekanismer for dette.
          Se <xref linkend="svn.advanced.locking"/>.</para>

      </sidebar>


    </sect2>
    
  </sect1>
  
  <!-- How svn implements the philosophy -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.in-action">
    <!-- @ENGLISH {{{
    <title>Subversion in Action</title>
    @ENGLISH }}} -->
    <title>Subversion i aksjon</title>
    
    <!-- @ENGLISH {{{
    <para>It's time to move from the abstract to the concrete.  In
      this section, we'll show real examples of Subversion being
      used.</para>
    @ENGLISH }}} -->
    <para>Det er på tide å gå fra det abstrakte til det konkrete.
      I denne seksjonen vil vi vise reelle eksempler på bruk av 
      Subversion.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.wc">
      <!-- @ENGLISH {{{
      <title>Working Copies</title>
      @ENGLISH }}} -->
      <title>Arbeidskopier</title>
      
      <!-- @ENGLISH {{{
      <para>You've already read about working copies; now we'll
        demonstrate how the Subversion client creates and uses
        them.</para>
      @ENGLISH }}} -->
      <para>Du har allerede lest om arbeidskopier; nå skal vi 
        demonstrere hvordan Subversionklienten lager og bruker 
        dem.</para>
      
      <!-- @ENGLISH {{{
      <para>A Subversion working copy is an ordinary directory tree on
        your local system, containing a collection of files.  You can
        edit these files however you wish, and if they're source code
        files, you can compile your program from them in the usual
        way.  Your working copy is your own private work area:
        Subversion will never incorporate other people's changes, nor
        make your own changes available to others, until you
        explicitly tell it to do so.  You can even have multiple
        working copies of the same project.</para>
      @ENGLISH }}} -->
      <para>En arbeidskopi i Subversion er et vanlig katalogtre på ditt 
        lokale system, og inneholder en samling filer.
        Du kan redigere disse filene sånn som du vil, og hvis det er 
        kildekode, kan du kompilere programmet på den vanlige måten.
        Arbeidskopien din er ditt eget private arbeidsområde:
        Subversion vil aldri legge inn andre folks forandringer, heller 
        ikke gjøre dine egne forandringer tilgjengelig for andre før du 
        eksplisitt ber programmet om å gjøre det.
        Du kan til og med ha flere arbeidskopier av det samme 
        prosjektet.</para>

      <!-- @ENGLISH {{{
      <para>After you've made some changes to the files in your
        working copy and verified that they work properly, Subversion
        provides you with commands to <quote>publish</quote> your
        changes to the other people working with you on your project
        (by writing to the repository).  If other people publish their
        own changes, Subversion provides you with commands to merge
        those changes into your working directory (by reading from the
        repository).</para>
      @ENGLISH }}} -->
      <para>Etter at du har gjort noen forandringer i filene i 
        arbeidskopien og sjekket at de virker skikkelig, gir Subversion 
        deg kommandoer så du kan <quote>publisere</quote> forandringene 
        dine til de andre som arbeider med deg på prosjektet ditt (ved å 
        skrive til depotet).
        Hvis andre personer publiserer deres egne forandringer, gir 
        Subversion deg kommandoer for å flette disse forandringene inn i 
        din arbeidskopi (ved å lese fra depotet).</para>

      <!-- @ENGLISH {{{
      <para>A working copy also contains some extra files, created and
        maintained by Subversion, to help it carry out these commands.
        In particular, each directory in your working copy contains a
        subdirectory named <filename>.svn</filename>, also known as
        the working copy <firstterm>administrative
        directory</firstterm>.  The files in each administrative
        directory help Subversion recognize which files contain
        unpublished changes, and which files are out-of-date with
        respect to others' work.</para>
      @ENGLISH }}} -->
      <para>En arbeidskopi inneholder også noen ekstra filer, opprettet 
        og vedlikeholdt av Subversion, for å hjelpe seg med å utføre 
        disse kommandoene.
        Hver katalog i arbeidskopien inneholder en underkatalog kalt 
        <filename>.svn</filename>, også kjent som arbeidskopiens 
        <firstterm>administrative katalog</firstterm>.
        Filene i hver administrative katalog hjelper Subversion til å se 
        hvilke filer som inneholder upubliserte forandringer, og hvilke 
        filer som er utdaterte i forhold til andres arbeid.</para>
      
      <!-- @ENGLISH {{{
      <para>A typical Subversion repository often holds the files (or
        source code) for several projects; usually, each project is a
        subdirectory in the repository's filesystem tree.  In this
        arrangement, a user's working copy will usually correspond to
        a particular subtree of the repository.</para>
      @ENGLISH }}} -->
      <para>Et typisk Subversiondepot inneholder ofte filene (eller 
        kildekoden) for flere prosjekter;
        vanligvis har hvert prosjekt sin egen underkatalog i depotets 
        filsystemtre.
        Med dette arrangementet vil en brukers arbeidskopi samsvare med 
        et spesielt deltre av depotet.</para>
      
      <!-- @ENGLISH {{{
      <para>For example, suppose you have a repository that contains
        two software projects, <literal>paint</literal> and
        <literal>calc</literal>.  Each project lives in its own
        top-level subdirectory, as shown in <xref
        linkend="svn.basic.in-action.wc.dia-1"/>.</para>
      @ENGLISH }}} -->
      <para>For eksempel, tenk deg at du har et depot som består av to 
        programprosjekter, <literal>paint</literal> og 
        <literal>calc</literal>.
        Hvert prosjekt bor i hver sin toppkatalog, som vist i <xref 
        linkend="svn.basic.in-action.wc.dia-1"/>.</para>

      <figure id="svn.basic.in-action.wc.dia-1">
        <!-- @ENGLISH {{{
        <title>The repository's filesystem</title>
        @ENGLISH }}} -->
        <title>Depotets filsystem</title>
        <graphic fileref="images/ch02dia6.png"/>
      </figure>
      
      <!-- @ENGLISH {{{
      <para>To get a working copy, you must <firstterm>check
        out</firstterm> some subtree of the repository.  (The term
        <quote>check out</quote> may sound like it has something to do
        with locking or reserving resources, but it doesn't; it simply
        creates a private copy of the project for you.) For example,
        if you check out <filename>/calc</filename>, you will get a
        working copy like this:</para>
      @ENGLISH }}} -->
      <para>For å få deg en arbeidskopi, må du først <firstterm>hente 
        ut</firstterm> (<foreignphrase>check out</foreignphrase>) et del 
        av et katalogtre fra depotet.
        (Det engelske uttrykket <quote>check out</quote> kan høres ut 
        som det har noe å gjøre med låsing eller reservering av 
        ressurser, men det har ikke det;
        det lager bare en privat kopi av prosjektet for deg.)
        For eksempel, hvis du henter ut <filename>/calc</filename>, vil 
        du få en arbeidskopi som dette:</para>

      <screen>
$ svn checkout http://svn.example.com/repos/calc
A    calc/Makefile
A    calc/integer.c
A    calc/button.c
Checked out revision 56.

$ ls -A calc
Makefile  integer.c  button.c  .svn/
</screen>

      <!-- @ENGLISH {{{
      <para>The list of letter A's indicates that Subversion is adding
        a number of items to your working copy.  You now have a
        personal copy of the repository's <filename>/calc</filename>
        directory, with one additional
        entry&mdash;<filename>.svn</filename>&mdash;which holds the
        extra information needed by Subversion, as mentioned
        earlier.</para>
      @ENGLISH }}} -->
      <para>Listen med bokstaven A indikerer at Subversion legger til et 
        antall elementer i arbeidskopien din.
        Du har nå en personlig kopi av depotets 
        <filename>/calc</filename>-katalog, med en ekstra komponent – 
        <filename>.svn</filename> – som tidligere nevnt inneholder den 
        ekstra informasjonen som Subversion trenger.</para>

      <sidebar id="svn.basic.in-action.wc.sb-1">
        <!-- @ENGLISH {{{
        <title>Repository URLs</title>
        @ENGLISH }}} -->
        <title>Depot-URLer</title>

        <!-- @ENGLISH {{{
        <para>Subversion repositories can be accessed through many
          different methods&mdash;on local disk, or through various
          network protocols.  A repository location, however, is
          always a URL.  <xref linkend="svn.basic.in-action.wc.tbl-1"/> describes how
          different URL schemas map to the available access methods.</para>
        @ENGLISH }}} -->
        <para>Subversiondepot kan bli aksessert ved hjelp av mange 
          forskjellige metoder – på en lokal disk, eller gjennom diverse 
          nettverksprotokoller.
          Beliggenheten til et depot er imidlertid alltid en URL.
          <xref linkend="svn.basic.in-action.wc.tbl-1"/> viser hvordan 
          forskjellige URL-skjemaer står i forhold til de forskjellige 
          aksessmetodene.</para>

        <table id="svn.basic.in-action.wc.tbl-1">
          <!-- @ENGLISH {{{
          <title>Repository Access URLs</title>
          @ENGLISH }}} -->
          <title>URLer for tilgang til et depot</title>
          <tgroup cols="2">
            <thead>
              <row>
                <!-- @ENGLISH {{{
                <entry>Schema</entry>
                <entry>Access Method</entry>
                @ENGLISH }}} -->
                <entry>Skjema</entry>
                <entry>Tilgangsmetode</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><literal>file:///</literal></entry>
                <!-- @ENGLISH {{{
                <entry>direct repository access (on local disk)</entry>
                @ENGLISH }}} -->
                <entry>direkte depottilgang (på lokal disk)</entry>
              </row>
              <row>
                <entry><literal>http://</literal></entry>
                <!-- @ENGLISH {{{
                <entry>access via WebDAV protocol to Subversion-aware
                  Apache server</entry>
                @ENGLISH }}} -->
                <entry>tilgang via WebDAV-protokollen til en 
                  Apache-server som kjenner til Subversion</entry>
              </row>
              <row>
                <entry><literal>https://</literal></entry>
                <!-- @ENGLISH {{{
                <entry>same as <literal>http://</literal>, but with
                  SSL encryption.</entry>
                @ENGLISH }}} -->
                <entry>samme som <literal>http://</literal>, men med 
                  SSL-kryptering.</entry>
              </row>
              <row>
                <entry><literal>svn://</literal></entry>
                <!-- @ENGLISH {{{
                <entry>access via custom protocol to an
                  <literal>svnserve</literal> server</entry>
                @ENGLISH }}} -->
                <entry>tilgang gjennom en tilpasset protokoll til en 
                  <literal>svnserve</literal>-&server;</entry>
              </row>
              <row>
                <entry><literal>svn+ssh://</literal></entry>
                <!-- @ENGLISH {{{
                <entry>same as <literal>svn://</literal>, but through
                  an SSH tunnel.</entry>
                @ENGLISH }}} -->
                <entry>samme som <literal>svn://</literal>, men gjennom 
                  en SSH-tunnel.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <!-- @ENGLISH {{{
        <para>For more information on how Subversion parses URLs, see
        <xref linkend="svn.advanced.reposurls"/>.</para>
        @ENGLISH }}} -->
        <para>For mer informasjon om hvordan Subversion tolker URLer, se 
          <xref linkend="svn.advanced.reposurls"/>.</para>

      </sidebar>
 
      <!-- @ENGLISH {{{
      <para>Suppose you make changes to <filename>button.c</filename>.
        Since the <filename>.svn</filename> directory remembers the
        file's modification date and original contents, Subversion can
        tell that you've changed the file.  However, Subversion does
        not make your changes public until you explicitly tell it to.
        The act of publishing your changes is more commonly known as
        <firstterm>committing</firstterm> (or <firstterm>checking
        in</firstterm>) changes to the repository.</para>
      @ENGLISH }}} -->
      <para>Tenk at du gjør forandringer til 
        <filename>button.c</filename>.
        Siden <filename>.svn</filename>-katalogen husker filens 
        modifiseringsdato og originale innhold, kan Subversion se at du 
        har forandret filen.
        Men Subversion offentliggjør ikke dine forandringer før du 
        eksplisitt ber programmet om å gjøre det.
        Prosessen når du publiserer dine forandringer blir vanligvis 
        omtalt som å <firstterm>legge inn</firstterm> (eller 
        <firstterm>sende/sjekke inn</firstterm>) forandringer til 
        depotet.</para>

      <!-- @ENGLISH {{{
      <para>To publish your changes to others, you can use
        Subversion's <command>commit</command> command:</para>
      @ENGLISH }}} -->
      <para>For å publisere dine forandringer til andre, kan du bruke 
        Subversions <command>commit</command>-kommando:</para>

      <!-- @ENGLISH {{{
      <screen>
$ svn commit button.c
Sending        button.c
Transmitting file data .
Committed revision 57.
</screen>
      @ENGLISH }}} -->
      <screen>
$ svn commit button.c
Sender        button.c
Sender fildata .
La inn revisjon 57.
</screen>

      <!-- @ENGLISH {{{
      <para>Now your changes to <filename>button.c</filename> have
        been committed to the repository; if another user checks out a
        working copy of <filename>/calc</filename>, they will see
        your changes in the latest version of the file.</para>
      @ENGLISH }}} -->
      <para>Nå er dine forandringer til <filename>button.c</filename> 
        lagt inn i depotet;
        hvis en annen bruker henter ut en arbeidskopi av 
        <filename>/calc</filename>, vil de se dine forandringer i den 
        seneste versjonen av filen.</para>

      <!-- @ENGLISH {{{
      <para>Suppose you have a collaborator, Sally, who checked out a
        working copy of <filename>/calc</filename> at the same time
        you did.  When you commit your change to
        <filename>button.c</filename>, Sally's working copy is left
        unchanged; Subversion only modifies working copies at the
        user's request.</para>
      @ENGLISH }}} -->
      <para>Tenk deg at du har en samarbeidspartner, Sally, som hentet 
        ut en arbeidskopi av <filename>/calc</filename> samtidig med 
        deg.
        Når du legger inn din forandring til 
        <filename>button.c</filename>, er Sallys arbeidskopi uforandret;
        Subversion modifiserer bare arbeidskopier etter brukerens 
        ønske.</para>

      <!-- @ENGLISH {{{
      <para>To bring her project up to date, Sally can ask
        Subversion to <firstterm>update</firstterm> her working copy,
        by using the Subversion <command>update</command> command.
        This will incorporate your changes into her working copy, as
        well as any others that have been committed since she checked
        it out.</para>
      @ENGLISH }}} -->
      <para>For å få sitt prosjekt oppdatert, kan Sally be Subversion om 
        å <firstterm>oppdatere</firstterm> hennes arbeidskopi, ved å 
        bruke Subversionkommandoen <command>update</command>.
        Dette vil legge inn dine forandringer inn i hennes arbeidskopi, 
        så vel som alle andre forandringer som er blitt lagt inn i 
        depotet siden hun sist hentet det ut.</para>

      <screen>
$ pwd
/home/sally/calc

$ ls -A 
.svn/ Makefile integer.c button.c

$ svn update
U    button.c
Updated to revision 57.
</screen>

      <!-- @ENGLISH {{{
      <para>The output from the <command>svn update</command> command
        indicates that Subversion updated the contents of
        <filename>button.c</filename>.  Note that Sally didn't need to
        specify which files to update; Subversion uses the information
        in the <filename>.svn</filename> directory, and further
        information in the repository, to decide which files need to
        be brought up to date.</para>
      @ENGLISH }}} -->
      <para>Utdataene fra kommandoen <command>svn update</command> 
        indikerer at Subversion oppdaterte innholdet av 
        <filename>button.c</filename>.
        Legg merke til at Sally ikke trengte å spesifisere hvilke filer 
        som skulle oppdateres, Subversion bruker informasjonen i 
        <filename>.svn</filename>-katalogen sammen med annen informasjon 
        i depotet for å bestemme hvilke filer som trenger en 
        oppdatering.</para>
      
    </sect2>
    
    
    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.revs">
      <!-- @ENGLISH {{{
      <title>Revisions</title>
      @ENGLISH }}} -->
      <title>Revisjoner</title>

      <!-- @ENGLISH {{{
      <para>An <command>svn commit</command> operation can publish
        changes to any number of files and directories as a single
        atomic transaction.  In your working copy, you can change
        files' contents, create, delete, rename and copy files and
        directories, and then commit the complete set of changes as a
        unit.</para>
      @ENGLISH }}} -->
      <para>En <command>svn commit</command>-operasjon kan publisere 
        forandringer til ethvert antall filer og kataloger som en 
        enkeltstående atomisk transaksjon.
        I arbeidskopien din kan du forandre filenes innhold, opprette, 
        slette, skifte navn og kopiere filer og kataloger, og så legge 
        inn det komplette settet med forandringer som en samlet 
        enhet.</para>

      <!-- @ENGLISH {{{
      <para>In the repository, each commit is treated as an atomic
        transaction: either all the commit's changes take place, or
        none of them take place.  Subversion tries to retain this
        atomicity in the face of program crashes, system crashes,
        network problems, and other users' actions.</para>
      @ENGLISH }}} -->
      <para>I depotet blir hver innlegging behandlet som en atomisk 
        transaksjon:
        Enten blir alle forandringene lagt inn, eller så blir ingen lagt 
        inn.
        Subversion prøver å beholde denne atomiteten stilt opp mot <!-- 
        ¤ «kræsj» er vel et koselig ord å bruke, eller har det en 
        useriøs schwong over seg? -->programkræsj, systemkræsj, 
        nettverksproblemer og andre brukeres aktiviteter.</para>

      <!-- @ENGLISH {{{
      <para>Each time the repository accepts a commit, this creates a
        new state of the filesystem tree, called a
        <firstterm>revision</firstterm>.  Each revision is assigned a
        unique natural number, one greater than the number of the
        previous revision.  The initial revision of a freshly created
        repository is numbered zero, and consists of nothing but an
        empty root directory.</para>
      @ENGLISH }}} -->
      <para>Hver gang depotet aksepterer en innlegging, opprettes det en 
        ny tilstand i filsystemtreet, kalt en 
        <firstterm>revisjon</firstterm>.
        Hver revisjon blir tildelt et unikt naturlig tall, ett større 
        enn nummeret på den forrige revisjonen.
        Den første revisjonen i et nyopprettet depot har nummeret null, 
        og inneholder ingenting annet enn en tom rotkatalog.</para>
      
      <!-- @ENGLISH {{{
      <para><xref linkend="svn.basic.in-action.revs.dia-1"/> illustrates a nice way to
        visualize the repository.  Imagine an array of revision
        numbers, starting at 0, stretching from left to right.  Each
        revision number has a filesystem tree hanging below it, and
        each tree is a <quote>snapshot</quote> of the way the
        repository looked after a commit.</para>
      @ENGLISH }}} -->
      <para><xref linkend="svn.basic.in-action.revs.dia-1"/> illustrerer 
        en fin måte å visualisere depotet på.
        Tenk deg en rekke av revisjonsnumre som starter på 0 og strekker 
        seg fra venstre mot høyre.
        Hvert revisjonsnummer har et filsystemtre hengende under seg, og 
        hvert tre er et <quote>øyeblikksbilde</quote> av hvordan depotet 
        så ut etter en innlegging.</para>
      
      <figure id="svn.basic.in-action.revs.dia-1">
        <!-- @ENGLISH {{{
        <title>The repository</title>
        @ENGLISH }}} -->
        <title>Depotet</title>
        <graphic fileref="images/ch02dia7.png"/>
      </figure>

      <sidebar>
        <!-- @ENGLISH {{{
        <title>Global Revision Numbers</title>
        @ENGLISH }}} -->
        <title>Globale revisjonsnumre</title>
         
        <!-- @ENGLISH {{{
        <para>Unlike those of many other version control systems,
          Subversion's revision numbers apply to <emphasis>entire
          trees</emphasis>, not individual files.  Each revision
          number selects an entire tree, a particular state of the
          repository after some committed change.  Another way to
          think about it is that revision N represents the state of
          the repository filesystem after the Nth commit.  When
          Subversion users talk about <quote>revision 5 of
          <filename>foo.c</filename></quote>, they really mean
          <quote><filename>foo.c</filename> as it appears in revision
          5.</quote> Notice that in general, revisions N and M of a
          file do <emphasis>not</emphasis> necessarily differ!  Because
          CVS uses per-file revision numbers, CVS users might want to
          see <xref linkend="svn.forcvs"/> for more details.</para>
        @ENGLISH }}} -->
        <para>Ulikt mange av de andre versjonskontrollsystemene, gjelder 
          Subversions revisjonsnumre for <emphasis>hele trær</emphasis>, 
          ikke individuelle filer.
          Hvert revisjonsnummer velger et helt tre, en spesifikk 
          tilstand til depotet etter at noen la inn en forandring.
          En annen måte å tenke seg det er at revisjon N representerer 
          tilstanden til depotfilsystemet etter den Nte innleggingen.
          Når Subversionbrukere snakker om <quote>revisjon 5 av 
          <filename>foo.c</filename></quote>, mener de egentlig 
          <quote><filename>foo.c</filename> som den fremstår i revisjon 
          5</quote>.
          Legg merke til at vanligvis vil innholdet av en fil for 
          revisjonene N og M <emphasis>ikke</emphasis> være forskjellig!
          Fordi CVS bruker egne revisjonsnumre for hver fil, vil kanskje 
          CVS-brukere ta en kikk på <xref linkend="svn.forcvs"/> for 
          flere detaljer.</para>
      </sidebar>

      <!-- @ENGLISH {{{
      <para>It's important to note that working copies do not always
        correspond to any single revision in the repository; they may
        contain files from several different revisions.  For example,
        suppose you check out a working copy from a repository whose
        most recent revision is 4:</para>
      @ENGLISH }}} -->
      <para>Det er viktig å notere seg at arbeidskopier ikke bestandig 
        samsvarer med en enkelt revisjon i depotet;
        de kan inneholde filer fra flere forskjellige revisjoner.
        For eksempel, tenk at du henter ut en arbeidskopi fra et depot 
        der den siste revisjonen er 4:</para>

      <screen>
calc/Makefile:4
     integer.c:4
     button.c:4
</screen>

      <!-- @ENGLISH {{{
      <para>At the moment, this working directory corresponds exactly
        to revision 4 in the repository.  However, suppose you make a
        change to <filename>button.c</filename>, and commit that
        change.  Assuming no other commits have taken place, your
        commit will create revision 5 of the repository, and your
        working copy will now look like this:</para>
      @ENGLISH }}} -->
      <para>For øyeblikket samsvarer arbeidskopien nøyaktig med revisjon 
        4 i depotet.
        Men tenk deg så at du gjør en forandring i 
        <filename>button.c</filename>, og legger inn denne forandringen.
        Forutsatt at ingen andre innlegginger har forekommet, vil din 
        innlegging opprette revisjon 5 i depotet, og arbeidskopien din 
        vil se ut som dette:</para>

      <screen>
calc/Makefile:4
     integer.c:4
     button.c:5
</screen>

      <!-- @ENGLISH {{{
      <para>Suppose that, at this point, Sally commits a change to
        <filename>integer.c</filename>, creating revision 6.  If you
        use <command>svn update</command> to bring your working copy
        up to date, then it will look like this:</para>
      @ENGLISH }}} -->
      <para>Så sier vi at Sally på dette tidspunktet legger inn en 
        forandring til <filename>integer.c</filename>, som lager 
        revisjon 6.
        Hvis du bruker <command>svn update</command> for å oppdatere 
        arbeidskopien, vil den se ut som dette:</para>

      <screen>
calc/Makefile:6
     integer.c:6
     button.c:6
</screen>

      <!-- @ENGLISH {{{
      <para>Sally's change to <filename>integer.c</filename> will
        appear in your working copy, and your change will still be
        present in <filename>button.c</filename>.  In this example,
        the text of <filename>Makefile</filename> is identical in
        revisions 4, 5, and 6, but Subversion will mark your working
        copy of <filename>Makefile</filename> with revision 6 to
        indicate that it is still current.  So, after you do a clean
        update at the top of your working copy, it will generally
        correspond to exactly one revision in the repository.</para>
      @ENGLISH }}} -->
      <para>Sallys forandring i <filename>integer.c</filename> vil komme 
        til syne i arbeidskopien din, og din forandring vil fortsatt 
        være til stede i <filename>button.c</filename>.
        I dette eksempelet er teksten i <filename>Makefile</filename> 
        identisk i revisjon 4, 5 og 6, men Subversion vil merke kopien 
        av <filename>Makefile</filename> med revisjon 6 for å indikere 
        at den fortsatt gjelder.
        Så, etter at du gjør en ren oppdatering fra toppen av 
        arbeidskopien din, vil den vanligvis samsvare med en eksakt 
        revisjon i depotet.</para>

    </sect2>
    
    
    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.track-repos">
      <!-- @ENGLISH {{{
      <title>How Working Copies Track the Repository</title>
      @ENGLISH }}} -->
      <title>Hvordan arbeidskopier holder følge med depotet</title>
      
      <!-- @ENGLISH {{{
      <para>For each file in a working directory, Subversion records
        two essential pieces of information in the
        <filename>.svn/</filename> administrative area:</para>
      @ENGLISH }}} -->
      <para>For hver fil i en arbeidskatalog, lagrer Subversion to 
        essensielle deler informasjon i det administrative 
        <filename>.svn</filename>-området:</para>
      
      
      <itemizedlist>
        <!-- @ENGLISH {{{
        <listitem>
          <para>what revision your working file is based on (this is
            called the file's <firstterm>working
            revision</firstterm>), and</para>
        </listitem>
        @ENGLISH }}} -->
        <listitem>
          <para>Hvilken revisjon arbeidsfilen din er basert på (dette 
            kalles filens <firstterm>arbeidsrevisjon</firstterm>), 
            og</para>
        </listitem>
        
        <!-- @ENGLISH {{{
        <listitem>
          <para>a timestamp recording when the local copy was last
            updated by the repository.</para>
        </listitem>
        @ENGLISH }}} -->
        <listitem>
          <para>et tidsmerke fra da den lokale kopien sist ble oppdatert 
            av depotet.</para>
        </listitem>
      </itemizedlist>

      <!-- @ENGLISH {{{
      <para>Given this information, by talking to the repository,
        Subversion can tell which of the following four states a
        working file is in:</para>
      @ENGLISH }}} -->
      <para>Ved hjelp av denne informasjonen kan Subversion ved å 
        kommunisere med depotet se hvilke fire tilstander en arbeidsfil 
        er i:</para>

      <variablelist>
        <varlistentry>
          <!-- @ENGLISH {{{
          <term>Unchanged, and current</term> 

          <listitem>
            <para>The file is unchanged in the working directory, and
              no changes to that file have been committed to the
              repository since its working revision.  An <command>svn
              commit</command> of the file will do nothing, and an
              <command>svn update</command> of the file will do
              nothing.</para>
          </listitem>
          @ENGLISH }}} -->
          <term>Uforandret og oppdatert</term>

          <listitem>
            <para>Filen er uforandret i arbeidskopien, og ingen 
              forandringer til denne filen er blitt lagt inn i depotet 
              siden arbeidskopien ble lagt inn.
              En <command>svn commit</command> på filen vil ikke gjøre 
              noe som helst, og en <command>svn update</command> på 
              filen vil heller ikke gjøre noe.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <!-- @ENGLISH {{{
          <term>Locally changed, and current</term>

          <listitem>
            <para>The file has been changed in the working directory,
              and no changes to that file have been committed to the
              repository since its base revision.  There are local
              changes that have not been committed to the repository,
              thus an <command>svn commit</command> of the file will
              succeed in publishing your changes, and an <command>svn
              update</command> of the file will do nothing.</para>
          </listitem>
          @ENGLISH }}} -->
          <term>Forandret lokalt og samtidig gjeldende</term>

          <listitem>
            <para>Filen er blitt forandret i arbeidskopien, og ingen 
              forandringer i denne filen er blitt lagt inn i depotet 
              siden stamrevisjonen.
              Det er lokale forandringer som ikke er blitt lagt inn i 
              depotet, så en <command>svn commit</command> av filen vil 
              lykkes i å publisere forandringene dine, og en 
              <command>svn update</command> på filen vil ikke gjøre noen 
              ting.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <!-- @ENGLISH {{{
          <term>Unchanged, and out-of-date</term> 

          <listitem>
            <para>The file has not been changed in the working
              directory, but it has been changed in the repository.
              The file should eventually be updated, to make it
              current with the public revision.  An <command>svn
              commit</command> of the file will do nothing, and an
              <command>svn update</command> of the file will fold the
              latest changes into your working copy.</para>
          </listitem>
          @ENGLISH }}} -->
          <term>Uforandret og utdatert</term>

          <listitem>
            <para>Filen er ikke blitt forandret i arbeidskopien, men har 
              forandret seg i depotet.
              Filen må etterhvert bli oppdatert, for å få den til å 
              samsvare med den offentlige revisjonen.
              En <command>svn commit</command> på filen vil ikke gjøre 
              noe, og en <command>svn update</command> på filen vil 
              legge de seneste forandringene inn i arbeidskopien 
              din.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <!-- @ENGLISH {{{
          <term>Locally changed, and out-of-date</term>

          <listitem>
            <para>The file has been changed both in the working
              directory, and in the repository.  An <command>svn
              commit</command> of the file will fail with an
              <quote>out-of-date</quote> error.  The file should be
              updated first; an <command>svn update</command> command
              will attempt to merge the public changes with the local
              changes.  If Subversion can't complete the merge in a
              plausible way automatically, it leaves it to the user to
              resolve the conflict.</para>
          </listitem>
          @ENGLISH }}} -->
          <term>Forandret lokalt og samtidig utdatert</term>

          <listitem>
            <para>Filen er blitt forandret både i arbeidskopien og 
              depotet.
              En <command>svn commit</command> av filen vil feile med en 
              <quote>out-of-date</quote>-feilmelding.
              Filen må oppdateres først; en <command>svn 
              update</command>-kommando vil prøve å flette inn de 
              offentlige forandringene med de lokale forandringene.
              Hvis Subversion ikke kan fullføre flettingen automatisk på 
              en skikkelig måte, blir det opp til brukeren å løse 
              konflikten.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      
      
      <!-- @ENGLISH {{{
      <para>This may sound like a lot to keep track of, but the
        <command>svn status</command> command will show you the state
        of any item in your working copy.  For more information on
        that command, see <xref linkend="svn.tour.cycle.examine.status" />.</para>
      @ENGLISH }}} -->
      <para>Dette kan høres ut som mye å holde greie på, men 
        <command>svn status</command>-kommandoen vil vise deg tilstanden 
        til ethvert element i arbeidskopien din.
        For mer informasjon om denne kommandoen, se <xref 
        linkend="svn.tour.cycle.examine.status" />.</para>
     
    </sect2>
    
    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.mixedrevs">
      <!-- @ENGLISH {{{
      <title>Mixed Revision Working Copies</title>
      @ENGLISH }}} -->
      <title>Arbeidskopier med blandede revisjonsnumre</title>

      <!-- @ENGLISH {{{
      <para>As a general principle, Subversion tries to be as flexible
        as possible.  One special kind of flexibility is the ability
        to have a working copy containing files and directories with a
        mix of different working revision numbers.  Unfortunately,
        this flexibility tends to confuse a number of new users.  If
        the earlier example showing mixed revisions perplexed you,
        here's a primer on both why the feature exists and how to make
        use of it.</para>
      @ENGLISH }}} -->
      <para>Som et generelt prinsipp prøver Subversion å være så 
        fleksibel som mulig.
        En spesiell type fleksibilitet er muligheten til å ha en 
        arbeidskopi som inneholder filer og kataloger med en blanding av 
        forskjellige arbeidsrevisjonsnumre.
        Uheldigvis har denne fleksibiliteten en tendens til å forvirre 
        en del nye brukere.
        Hvis det tidligere eksempelet som viser blandede revisjoner gjør 
        deg litt perpleks, her kommer en forklaring på hvorfor denne 
        funksjonaliteten finnes og hvordan du gjør bruk av den.</para>

      <sect3 id="svn.basic.in-action.mixedrevs.update-commit">
        <!-- @ENGLISH {{{
        <title>Updates and Commits are Separate</title>
        @ENGLISH }}} -->
        <title>Oppdateringer og innlegginger er separate</title>

        <!-- @ENGLISH {{{
        <para>One of the fundamental rules of Subversion is that
          a <quote>push</quote> action does not cause
          a <quote>pull</quote>, nor the other way around.  Just
          because you're ready to submit new changes to the repository
          doesn't mean you're ready to receive changes from other
          people.  And if you have new changes still in progress,
          then <command>svn update</command> should gracefully merge
          repository changes into your own, rather than forcing you to
          publish them.</para>
        @ENGLISH }}} -->
        <para>En av de fundamentale reglene til Subversion er at en <!-- 
          ¤ --><quote>skyveoperasjon</quote> ikke forårsaker en 
          <quote>trekkoperasjon</quote>, heller ikke den andre veien.
          Det at du er klar til å legge inn nye forandringer i depotet 
          betyr ikke at du er klar til å motta forandringer fra andre 
          folk.
          Og hvis du har nye forandringer som fortsatt er under 
          utvikling, bør <command>svn update</command> flette 
          forandringer i depotet fint og forsiktig inn i dine egne 
          istedenfor å tvinge deg til å publisere dem.</para>

        <!-- @ENGLISH {{{
        <para>The main side-effect of this rule is that it means a
          working copy has to do extra bookkeeping to track mixed
          revisions, and be tolerant of the mixture as well.  It's
          made more complicated by the fact that directories
          themselves are versioned.</para>
        @ENGLISH }}} -->
        <para>Den største sideeffekten av denne regelen er at det betyr 
          at arbeidskopien må holde ekstra regnskap for å følge med på 
          miksede revisjoner, og også være tolerant i forhold til 
          blandingen.
          Det blir ytterligere komplisert fordi også selve katalogene er 
          versjonerte.</para>

        <!-- @ENGLISH {{{
        <para>For example, suppose you have a working copy entirely at
          revision 10.  You edit the
          file <filename>foo.html</filename> and then perform
          an <command>svn commit</command>, which creates revision 15
          in the repository.  After the commit succeeds, many new
          users would expect the working copy to be entirely at
          revision 15, but that's not the case!  Any number of changes
          might have happened in the repository between revisions 10
          and 15.  The client knows nothing of those changes in the
          repository, since you haven't yet run <command>svn
          update</command>, and <command>svn commit</command> doesn't
          pull down new changes.  If, on the other hand,
          <command>svn commit</command> <emphasis>were</emphasis> to
          automatically download the newest changes, then it would be
          possible to set the entire working copy to revision
          15&mdash;but then we'd be breaking the fundamental rule
          of <quote>push</quote> and <quote>pull</quote> remaining
          separate actions.  Therefore the only safe thing the
          Subversion client can do is mark the one
          file&mdash;<filename>foo.html</filename>&mdash;as being at
          revision 15.  The rest of the working copy remains at
          revision 10.  Only by running <command>svn update</command>
          can the latest changes be downloaded, and the whole working
          copy be marked as revision 15.</para>
        @ENGLISH }}} -->
        <para>For eksempel, tenk deg at du har en arbeidskopi der alle 
          elementene er på revisjon 10.
          Du redigerer filen <filename>foo.html</filename> og utfører 
          deretter en <command>svn commit</command> som lager revisjon 
          15 i depotet.
          Etter at innleggingen er fullført, vil mange brukere forvente 
          at hele arbeidskopien er på revisjon 15, men det er ikke 
          tilfellet!
          Alle mulige forandringer kan ha skjedd mellom revisjonene 10 
          og 15.
          Klienten vet ingenting om disse forandringene i depotet, siden 
          du ikke har kjørt <command>svn update</command> enda, og 
          <command>svn commit</command> ikke henter nye forandringer.
          <emphasis>Hvis</emphasis> <command>svn commit</command> på den 
          annen side hentet de nyeste forandringene automatisk, ville 
          det være mulig å sette hele arbeidskopien til revisjon 15 – 
          men da ville vi brutt den fundamentale regelen om at <!-- ¤ 
          --><quote>skyveoperasjoner</quote> og 
          <quote>trekkoperasjoner</quote> skal være separate handlinger.
          Derfor, den eneste trygge tingen som Subversionklienten kan 
          gjøre er å kun merke den ene fila – 
          <filename>foo.html</filename> – som å være på revisjon 15.
          Resten av arbeidskopien forblir på revisjon 10.
          Bare ved å kjøre <command>svn update</command> kan de nyeste 
          forandringene bli hentet, og hele arbeidskopien kan merkes som 
          revisjon 15.</para>

        </sect3>

        <sect3 id="svn.basic.in-action.mixedrevs.normal">
          <!-- @ENGLISH {{{
          <title>Mixed revisions are normal</title>
          @ENGLISH }}} -->
          <title>Blandede revisjoner er normalt</title>
          
          <!-- @ENGLISH {{{
          <para>The fact is, <emphasis>every time</emphasis> you
            run <command>svn commit</command>, your working copy ends
            up with some mixture of revisions.  The things you just
            committed are marked as having larger working revisions
            than everything else.  After several commits (with no
            updates in-between) your working copy will contain a whole
            mixture of revisions.  Even if you're the only person
            using the repository, you will still see this phenomenon.
            To examine your mixture of working revisions, use
            the <command>svn status -&#64738;-verbose</command> command (see
            <xref linkend="svn.tour.cycle.examine.status"/> for more
            information.)</para>
          @ENGLISH }}} -->
          <para>Faktum er at <emphasis>hver gang</emphasis> du kjører 
            <command>svn commit</command> ender arbeidskopien din opp 
            med en form for blanding av revisjoner.
            Det elementet som du akkurat la inn er merket som om det har 
            et større revisjonsnummer enn alt det andre.
            Etter flere innlegginger (uten noen oppdateringer i 
            mellomtiden) vil arbeidskopien din inneholde en stor 
            blanding av revisjoner.
            Selv om du er den eneste personen som bruker depotet vil du 
            fortsatt se dette fenomenet.
            For å utforske blandingen din av blandede revisjoner kan du 
            bruke kommandoen <command>svn status --verbose</command> (se 
            <xref linkend="svn.tour.cycle.examine.status"/> for mer 
            informasjon).</para>

          <!-- @ENGLISH {{{
          <para>Often, new users are completely unaware that their
            working copy contains mixed revisions.  This can be
            confusing, because many client commands are sensitive to
            the working revision of the item they're examining.  For
            example, the <command>svn log</command> command is used to
            display the history of changes to a file or directory (see
            <xref linkend="svn.tour.history.log"/>).  When the user
            invokes this command on a working copy object, they expect
            to see the entire history of the object.  But if the
            object's working revision is quite old (often
            because <command>svn update</command> hasn't been run in a
            long time), then the history of
            the <emphasis>older</emphasis> version of the object is
            shown.</para>
          @ENGLISH }}} -->
          <para>Ofte er nye brukere ikke klar over at arbeidskopiene 
            deres inneholder miksede revisjoner.
            Dette kan være forvirrende, fordi mange klientkommandoer er 
            sensitiv ovenfor arbeidsrevisjonen til elementet som de 
            utforsker.
            For eksempel, <command>svn log</command>-kommandoen blir 
            brukt til å vise historien til en fil eller katalog (se 
            <xref linkend="svn.tour.history.log"/>).
            Når brukeren kjører denne kommandoen på et objekt i 
            arbeidskopien, forventer de å se hele historien til 
            objektet.
            Men hvis objektets arbeidsrevisjon er ganske gammel (ofte 
            fordi <command>svn update</command> ikke har vært kjørt på 
            aldri så lenge), blir historien til den 
            <emphasis>eldre</emphasis> versjonen av objektet 
            vist.</para>
        </sect3>

        <sect3 id="svn.basic.in-action.mixedrevs.useful">
          <!-- @ENGLISH {{{
          <title>Mixed revisions are useful</title>
          @ENGLISH }}} -->
          <title>Blandede revisjoner er nyttige</title>

          <!-- @ENGLISH {{{
          <para>If your project is sufficiently complex, you'll
            discover that it's sometimes nice to forcibly
            <quote>backdate</quote> portions of your working copy to
            an earlier revision; you'll learn how to do that in
            Chapter 3.  Perhaps you'd like to test an earlier version
            of a sub-module contained in a subdirectory, or perhaps
            you'd like to figure out when a bug first came into
            existence in a specific file.  This is the <quote>time
            machine</quote> aspect of a version control system &mdash;
            the feature which allows you to move any portion of your
            working copy forward and backward in history.</para>
          @ENGLISH }}} -->
          <para>Forutsatt at prosjektet ditt er komplekst nok, vil du 
            oppdage at det noen ganger er fint å kunne 
            <quote>tilbakedatere</quote> deler av arbeidskopien til en 
            tidligere revisjon; du vil lære hvordan du gjør dette i 
            kapittel 3.
            Kanskje vil du prøve en tidligere versjon av en delmodul som 
            ligger i en underkatalog lagret i en underkatalog, eller 
            kanskje du vil finne ut når en feil først oppsto i en 
            spesiell fil.
            Dette er <quote>tidsmaskin-aspektet</quote> i et 
            versjonskontrollsystem – funksjonaliteten som lar deg flytte 
            alle deler av arbeidskopien din framover og bakover i 
            historien.</para>

        </sect3>

        <sect3 id="svn.basic.in-action.mixedrevs.limits">
          <!-- @ENGLISH {{{
          <title>Mixed revisions have limitations</title>
          @ENGLISH }}} -->
          <title>Blandede revisjoner har begrensninger</title>

          <!-- @ENGLISH {{{
          <para>However you make use of mixed revisions in your
            working copy, there are limitations to this
            flexibility.</para>
          @ENGLISH }}} -->
          <para>Hvordan du enn gjør bruk av blandede revisjoner i 
            arbeidskopien din, er det begrensninger i denne 
            fleksibiliteten.</para>
          
          <!-- @ENGLISH {{{
          <para>First, you cannot commit the deletion of a file or
            directory which isn't fully up-to-date.  If a newer
            version of the item exists in the repository, your attempt
            to delete will be rejected, to prevent you from
            accidentally destroying changes you've not yet
            seen.</para>
          @ENGLISH }}} -->
          <para>For det første kan du ikke legge inn sletting av en fil 
            eller katalog som ikke er fullstendig oppdatert.
            Hvis en nyere versjon av elementet eksisterer i depotet, vil 
            forsøket ditt på å slette bli avslått, for å forhindre deg å 
            feilaktig ødelegge forandringer som du enda ikke har 
            sett.</para>

          <!-- @ENGLISH {{{
          <para>Second, you cannot commit a metadata change to a
            directory unless it's fully up-to-date.  You'll learn
            about attaching
            <quote>properties</quote> to items in Chapter 6.  A
            directory's working revision defines a specific set of
            entries and properties, and thus committing a property
            change to an out-of-date directory may destroy properties
            you've not yet seen.</para>
          @ENGLISH }}} -->
          <para>For det andre kan du ikke legge inn en 
            metadata-forandring til en katalog hvis den ikke er 
            fullstendig oppdatert.
            Du vil få lære om å legge til <quote>egenskaper</quote> til 
            elementer i kapittel 6.
            En katalogs arbeidsrevisjon definerer et spesifikt sett med 
            poster og egenskaper, og en innlegging av forandringer i en 
            egenskap for en utdatert katalog kan ødelegge egenskaper som 
            du enda ikke har sett.</para>

        </sect3>


    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.summary">
    <!-- @ENGLISH {{{
    <title>Summary</title>
    @ENGLISH }}} -->
    <title>Oppsummering</title>
    
    <!-- @ENGLISH {{{
    <para>We've covered a number of fundamental Subversion concepts in
      this chapter:</para>
    @ENGLISH }}} -->
    <para>Vi har dekket flere fundamentale konsepter for Subversion i 
      dette kapitlet:</para>

    <itemizedlist>
      <listitem>
        <!-- @ENGLISH {{{
        <para>We've introduced the notions of the central repository,
          the client working copy, and the array of repository
          revision trees.</para>
        @ENGLISH }}} -->
        <para>Vi har introdusert begrepene om et sentralt depot, 
          arbeidskopien til klienten, og rekken av revisjonstrær i 
          depotet.</para>
      </listitem>

      <listitem>
        <!-- @ENGLISH {{{
        <para>We've seen some simple examples of how two collaborators
          can use Subversion to publish and receive changes from one
          another, using the <quote>copy-modify-merge</quote>
          model.</para>
        @ENGLISH }}} -->
        <para>Vi har sett noen enkle eksempler på hvordan to 
          arbeidskolleger kan bruke Subversion til å publisere og motta 
          forandringer til og fra hverandre, ved å bruke 
          <quote>kopier-rediger-flett</quote>-modellen.</para>
      </listitem>

      <listitem>
        <!-- @ENGLISH {{{
        <para>We've talked a bit about the way Subversion tracks and
          manages information in a working copy.</para>
        @ENGLISH }}} -->
        <para>Vi har snakket litt om måten Subversion følger og 
          behandler informasjon i en arbeidskopi.</para>
      </listitem>


    </itemizedlist>
    
    <!-- @ENGLISH {{{
    <para>At this point, you should have a good idea of how Subversion
      works in the most general sense.  Armed with this knowledge, you
      should now be ready to jump into the next chapter, which is a
      detailed tour of Subversion's commands and features.</para>
    @ENGLISH }}} -->
    <para>Så langt skal du ha en god oversikt om hvordan Subversion 
      arbeider generelt sett.
      Bevæpnet med kunnskap er du nå klar til å hoppe inn i neste 
      kapittel, som er en detaljert gjennomgang av Subversions 
      kommandoer og funksjoner.</para>
      
  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
vim: set ft=svnbook :
-->
