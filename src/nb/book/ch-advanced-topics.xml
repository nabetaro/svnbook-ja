<chapter id="svn.advanced">
  <!-- @ENGLISH {{{
  <title>Advanced Topics</title>
  @ENGLISH }}} -->
  <title>Avanserte emner</title>

  <simplesect>

    <!-- @ENGLISH {{{
    <para>If you've been reading this book chapter by chapter, from
      start to finish, you should by now have acquired enough
      knowledge to use the Subversion client to perform the most
      common version control operations.  You understand how to
      checkout a working copy from a Subversion repository.  You are
      comfortable with submitting and receiving changes using the
      <command>svn commit</command> and <command>svn update</command>
      functions.  You've probably even developed a reflex which causes
      you to run the <command>svn status</command> command almost
      unconsciously.  For all intents and purposes, you are ready to
      use Subversion in a typical environment.</para>
    @ENGLISH }}} -->
    <para>Hvis du har lest denne boka kapittel for kapittel, fra start 
      til slutt, skal du nå ha samlet opp nok kunnskap til å kunne bruke 
      Subversionklienten til å utføre de vanligste operasjonene innen 
      versjonskontroll.
      Du forstår hvordan du henter ut en arbeidskopi fra et 
      Subversiondepot.
      Du er komfortabel med å legge inn og hente ut forandringer ved å 
      bruke kommandoene <command>svn commit</command> og <command>svn 
      update</command>.
      Du har til og med kanskje utviklet en refleks som gjør at du 
      kjører <command>svn status</command> nærmest ubevisst.
      Hva oppgaven enn er, er du klar til å bruke Subversion i et typisk 
      arbeidsmiljø.</para>

    <!-- @ENGLISH {{{
    <para>But the Subversion feature set doesn't stop at <quote>common
      version control operations</quote>.</para>
    @ENGLISH }}} -->
    <para>Men funksjonaliteten til Subversion stopper ikke ved 
      <quote>vanlige versjonskontrolloperasjoner</quote>.</para>

    <!-- @ENGLISH {{{
    <para>This chapter highlights some of Subversion's features that
      aren't quite so regularly used.  In it, we will discuss
      Subversion's property (or <quote>metadata</quote>) support, and
      how to modify Subversion's default behaviors by tweaking its
      run-time configuration area.  We will describe how you can use
      externals definitions to instruct Subversion to pull data from
      multiple repositories.  We'll cover in detail some of the
      additional client- and server-side tools that are part of the
      Subversion distribution.</para>
    @ENGLISH }}} -->
    <para>Dette kapittelet setter fokus på litt av funksjonaliteten til 
      Subversion som ikke blir brukt i like stor grad.
      Her vil vi diskutere Subversions støtte for egenskaper (eller 
      <quote>metadata</quote>) og hvordan standardoppførselen til 
      Subversion kan forandres ved å gjøre forandringer i 
      konfigurasjonsområdet.
      Vi vil beskrive hvordan du kan bruke eksterne defineringer for å 
      instruere Subversion til å hente data fra flere depoter.
      Vi vil dekke i detalj noen av de verktøyene som er med i 
      Subversiondistribusjonen for bruk på klient- og 
      &server;siden.</para>

    <!-- @ENGLISH {{{
    <para>Before reading this chapter, you should be familiar with the
      basic file and directory versioning capabilities of Subversion.
      If you haven't already read about those, or if you need a
      refresher, we recommend that you check out <xref
      linkend="svn.basic" /> and <xref linkend="svn.tour" />.  Once
      you've mastered the basics and consumed this chapter, you'll be
      a Subversion power-user!
    </para>
    @ENGLISH }}} -->
    <para>Før du leser dette kapittelet bør du gjøre deg kjent med de 
      grunnleggende mulighetene Subversion har for versjonering av filer 
      og kataloger.
      Hvis du ikke allerede har lest om dette, eller hvis du trenger å 
      friske det opp, anbefaler vi at du leser <xref linkend="svn.basic" 
      /> og <xref linkend="svn.tour" />.
      Når du mestrer de grunnleggende tingene og har fordøyd dette 
      kapittelet, vil du være en <!-- ¤ 
      -->Subversionmuskelbruker!</para>

  </simplesect>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.props">
    <!-- @ENGLISH {{{
    <title>Properties</title>
    @ENGLISH }}} -->
    <title>Egenskaper</title>

    <!-- @ENGLISH {{{
    <para>We've already covered in detail how Subversion stores and
      retrieves various versions of files and directories in its
      repository.  Whole chapters have been devoted to this most
      fundamental piece of functionality provided by the tool.  And
      if the versioning support stopped there, Subversion would still
      be complete from a version control perspective.  But it
      doesn't stop there.</para>
    @ENGLISH }}} -->
    <para>Vi har allerede dekket i detalj hvordan Subversion lagrer og 
      henter diverse versjoner av filer og kataloger i depotet.
      Hele kapitler er viet til disse mest fundamentale delene av 
      funksjonalitet som verktøyet har.
      Og hvis versjoneringsmulighetene stoppet der, ville Subversion 
      fortsatt være komplett sett fra et versjonskontrollsynspunkt.
      Men det stopper ikke der.</para>

    <!-- @ENGLISH {{{
    <para>In addition to versioning your directories and files,
      Subversion provides interfaces for adding, modifying, and
      removing versioned metadata on each of your versioned
      directories and files.  We refer to this metadata as
      <firstterm>properties</firstterm>, and they can be thought of as
      two-column tables that map property names to arbitrary values
      attached to each item in your working copy.  Generally speaking,
      the names and values of the properties can be whatever you want
      them to be, with the constraint that the names must be
      human-readable text.  And the best part about these properties
      is that they, too, are versioned, just like the textual contents
      of your files.  You can modify, commit, and revert property
      changes as easily as committing textual changes.  And you
      receive other people's property changes as you update your
      working copy.</para>
    @ENGLISH }}} -->
    <para>I tillegg til å versjonere kataloger og filer, har Subversion 
      grensesnitt for å legge til, forandre og fjerne versjonerte 
      metadata på alle versjonerte kataloger og filer.
      Vi refererer til disse metadataene som 
      <firstterm>egenskaper</firstterm> (engelsk: 
      <foreignphrase>properties</foreignphrase>), og du kan tenke på dem 
      som en tabell med to kolonner som forbinder egenskapsnavn med 
      vilkårlige verdier som ligger sammen med hvert element i 
      arbeidskopien din.
      Generelt sett kan navnene og verdiene til egenskapene være hva du 
      vil at de skal være, med den begrensningen at navnene må være 
      lesbar for mennesker.
      Og det beste med disse egenskapene er at de også er versjonerte, 
      akkurat som det tekstbaserte innholdet i filene dine.
      Du kan forandre, legge inn og reversere egenskapsforandringer like 
      lett som å legge inn tekstforandringer.
      Du vil også motta forandringer i egenskaper gjort av andre brukere 
      når du oppdaterer arbeidskopien.</para>

    <sidebar>
      <!-- @ENGLISH {{{
      <title>Other Properties in Subversion</title>
      @ENGLISH }}} -->
      <title>Andre egenskaper i Subversion</title>

      <!-- @ENGLISH {{{
      <para>Properties show up elsewhere in Subversion, too.  Just as
        files and directories may have arbitrary property names and
        values attached to them, each revision as a whole may have
        arbitrary properties attached to it.  The same constraints
        apply&mdash;human-readable, text names and anything-you-want,
        binary values&mdash;except that revision properties are not
        versioned.  See <xref linkend="svn.reposadmin.basics.revprops" /> for more
        information on these unversioned properties.</para>
      @ENGLISH }}} -->
      <para>Egenskaper finnes også andre steder i Subversion.
        Akkurat som filer og kataloger kan ha vilkårlige egenskapsnavn 
        og verdier vedlagt, kan hver revisjon som helhet ha vilkårlige 
        egenskaper lagt ved.
        De samme begrensningene gjelder også her – <!-- ¤ Kanskje den 
        engelske setninga bør skrues litt på. Omskrives litt. -->navnene 
        må være lesbare for mennesker – unntatt at revisjonsegenskaper 
        ikke er versjonerte.
        Se <xref linkend="svn.reposadmin.basics.revprops" /> for mer 
        informasjon om disse uversjonerte egenskapene.</para>
    </sidebar>

    <!-- @ENGLISH {{{
    <para>In this section, we will examine the utility&mdash;both to
      users of Subversion, and to Subversion itself&mdash;of property
      support.  You'll learn about the property-related
      <command>svn</command> subcommands, and how property
      modifications affect your normal Subversion workflow.
      Hopefully, you'll be convinced that Subversion properties can
      enhance your version control experience.</para>
    @ENGLISH }}} -->
    <para>I denne seksjonen vil vi studere <!-- ¤ -->nyttigheten – både 
      for Subversionbrukere og Subversion selv – av støtte for 
      egenskaper.
      Du vil lære om de egenskapsrelaterte 
      <command>svn</command>-delkommandoene og hvordan forandring av 
      egenskaper påvirker den normale arbeidsflyten i Subversion.
      Forhåpentligvis vil du bli overbevist om at Subversionegenskaper 
      kan forbedre <!-- ¤ «Opplevelsen» høres litt pompøst ut, men 
      kanskje det er det greieste å bruke. -->bruken din av 
      versjonskontroll.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.why">
      <!-- @ENGLISH {{{
      <title>Why Properties?</title>
      @ENGLISH }}} -->
      <title>Hvorfor bruke egenskaper?</title>

      <!-- @ENGLISH {{{
      <para>Properties can be very useful additions to your working
        copy.  In fact, Subversion itself uses properties to house
        special information, and as a way to denote that certain
        special processing might be needed.  Likewise, you can use
        properties for your own purposes.  Of course, anything you can
        do with properties you could also do using regular versioned
        files, but consider the following example of Subversion
        property use.</para>
      @ENGLISH }}} -->
      <para>Egenskaper kan være meget nyttige tillegg til arbeidskopien 
        din.
        Faktisk bruker Subversion selv egenskaper til å lagre spesiell 
        informasjon og finne ut når det er nødvendig med spesielle 
        fremgangsmåter.
        På samme måte kan du bruke egenskaper til ditt eget bruk.
        Selvfølgelig, alt du kan gjøre med egenskaper kan du også gjøre 
        med vanlige versjonerte filer, men se for deg det følgende 
        eksempelet på bruk av Subversionegenskaper.</para>

      <!-- @ENGLISH {{{
      <para>Say you wish to design a website that houses many digital
        photos, and displays them with captions and a datestamp.  Now,
        your set of photos is constantly changing, so you'd like to
        have as much of this site automated as possible.  These photos
        can be quite large, so as is common with sites of this nature,
        you want to provide smaller thumbnail images to your site
        visitors.  You can do this with traditional files.  That is,
        you can have your <filename>image123.jpg</filename> and an
        <filename>image123-thumbnail.jpg</filename> side-by-side in a
        directory.  Or if you want to keep the filenames the same, you
        might have your thumbnails in a different directory, like
        <filename>thumbnails/image123.jpg</filename>.  You can also
        store your captions and datestamps in a similar fashion, again
        separated from the original image file.  Soon, your tree of
        files is a mess, and grows in multiples with each new photo
        added to the site.</para>
      @ENGLISH }}} -->
      <para>Tenk deg at du vil sette opp en hjemmeside som inneholder 
        mange digitale bilder, og viser dem med tittel og tidspunkt.
        Fotosamlingen forandrer seg i ett sett, så du vil helst 
        automatisere så mye som mulig.
        Disse bildene kan være ganske store, så du vil i likhet med 
        andre hjemmesider av denne typen vise miniatyrbilder til de 
        besøkende.
        Du kan gjøre dette med tradisjonelle bilder, det vil si at du 
        kan ha bildet <filename>bilde123.jpg</filename> og en 
        <filename>bilde123-mini.jpg</filename> side ved side i en 
        katalog.
        Eller hvis du vil bruke det samme filnavnet, kan du ha 
        miniatyrbildene i en annen katalog, for eksempel 
        <filename>mini/bilde123.jpg</filename>.
        Du kan også lagre titlene og tidspunktene på en lignende måte, 
        separert fra den originale bildefila.
        Snart blir katalogtreet med filene et salig rot, og for hver ny 
        fil øker størrelsen <!-- ¤ multiples -->flere ganger.</para>

      <!-- @ENGLISH {{{
      <para>Now consider the same setup using Subversion's file
        properties.  Imagine having a single image file,
        <filename>image123.jpg</filename>, and then properties set on
        that file named <literal>caption</literal>,
        <literal>datestamp</literal>, and even
        <literal>thumbnail</literal>.  Now your working copy directory
        looks much more manageable&mdash;in fact, it looks like there
        are nothing but image files in it.  But your automation
        scripts know better.  They know that they can use
        <command>svn</command> (or better yet, they can use the
        Subversion language bindings&mdash;see <xref
        linkend="svn.developer.usingapi.otherlangs" />) to dig out the extra
        information that your site needs to display without having to
        read an index file or play path manipulation games.</para>
      @ENGLISH }}} -->
      <para>Så kan du se for deg det samme oppsettet der filegenskapene 
        til Subversion brukes.
        Du kan ha en enkelt bildefil, <filename>bilde123.jpg</filename>, 
        med egenskaper på denne fila som er kalt 
        <literal>tittel</literal>, <literal>tidspunkt</literal> og 
        <literal>miniatyr</literal>.
        Nå ser arbeidskopien din mye mer oversiktlig ut – faktisk ser 
        det ut som det bare er bildefiler i den.
        Men de automatiserte skriptene dine vet bedre.
        De vet at de kan bruke <command>svn</command> (eller enda bedre, 
        de kan bruke <!-- ¤ -->språkbindingene i Subversion – se <xref 
        linkend="svn.developer.usingapi.otherlangs" />) for å hente ut 
        den ekstra informasjonen som hjemmesiden trenger å vise uten å 
        måtte lese en indeksfil eller trikse med filstier.</para>

      <!-- @ENGLISH {{{
      <para>How (and if) you use Subversion properties is up to you.
        As we mentioned, Subversion has it own uses for properties,
        which we'll discuss a little later in this chapter.  But
        first, let's discuss how to manipulate properties using the
        <command>svn</command> program.</para>
      @ENGLISH }}} -->
      <para>Hvordan (og om) du bruker Subversionegenskaper er opp til 
        deg.
        Som vi nevnte, har Subversion sine egne bruksområder for 
        egenskaper, som vi vil diskutere litt senere i dette kapittelet.
        Men først ser vi på hvordan vi kan manipulere egenskaper ved å 
        bruke <command>svn</command>-programmet.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.manip">
      <!-- @ENGLISH {{{
      <title>Manipulating Properties</title>
      @ENGLISH }}} -->
      <title>Manipulering av egenskaper</title>

      <!-- @ENGLISH {{{
      <para>The <command>svn</command> command affords a few ways to
        add or modify file and directory properties.  For properties
        with short, human-readable values, perhaps the simplest way to
        add a new property is to specify the property name and value
        on the command-line of the <command>propset</command>
        subcommand.</para>
      @ENGLISH }}} -->
      <para><command>svn</command>-kommandoen har flere måter å legge 
        til og modifisere fil- og katalogegenskaper.
        For egenskaper med korte egenskaper som er leselig for folk 
        flest, er kanskje den enkleste måten å legge til en ny egenskap 
        å spesifisere navnet på egenskapen med verdien dens på 
        kommandolinja med 
        <command>propset</command>-delkommandoen.</para>

      <!-- @ENGLISH {{{
      <screen>
$ svn propset copyright '(c) 2003 Red-Bean Software' calc/button.c
property 'copyright' set on 'calc/button.c'
$
</screen>
      @ENGLISH }}} -->
      <screen>
$ svn propset copyright '(c) 2003 Red-Bean Software' calc/button.c
Egenskapen «copyright» satt på «calc/button.c»
$
</screen>
       
      <!-- @ENGLISH {{{
      <para>But we've been touting the flexibility that Subversion
        offers for your property values.  And if you are planning to
        have a multi-line textual, or even binary, property value, you
        probably do not want to supply that value on the command-line.
        So the <command>propset</command> subcommand takes a
        <option>-&#64738;-file</option> (<option>-F</option>) option for
        specifying the name of
        a file which contains the new property value.</para>
      @ENGLISH }}} -->
      <para>Men vi har fremhevet fleksibiliteten som Subversion har for 
        egenskapsverdier.
        Og hvis du har en tekstbasert, eller til og med binær 
        egenskapsverdi som går over flere linjer, vil du sannsynligvis 
        ikke oppgi denne verdien på kommandolinja.
        Derfor kan <command>propset</command>-delkommandoen bruke valget 
        <option>--file</option> (<option>-F</option>) for å spesifisere 
        navnet på en fil som inneholder den nye verdien til 
        egenskapen.</para>

      <!-- @ENGLISH {{{
      <screen>
$ svn propset license -F /path/to/LICENSE calc/button.c
property 'license' set on 'calc/button.c'
$
</screen>
      @ENGLISH }}} -->
      <screen>
$ svn propset license -F /sti/til/LISENS calc/button.c
Egenskapen «license» satt på «calc/button.c»
$
</screen>

      <!-- @ENGLISH {{{
      <para>There are some restrictions on the names you can use for
        properties.  A property name must start with a letter, a colon
        (<literal>:</literal>), or an underscore
        (<literal>_</literal>); after that, you can also use digits,
        hyphens (<literal>-</literal>), and periods
        (<literal>.</literal>).
          <footnote>
            <para>If you're familiar with XML, this is pretty much the
            ASCII subset of the syntax for XML "Name".</para>
          </footnote>
      </para>
      @ENGLISH }}} -->
      <para>Det er noen restriksjoner på navnene du kan bruke på 
        egenskaper.
        Et egenskapsnavn må starte med en bokstav, kolon 
        (<literal>:</literal>) eller understrek (<literal>_</literal>).
        Etter dette kan du også bruke siffer, bindestrek 
        (<literal>-</literal>) og punktum 
        (<literal>.</literal>).<footnote>
          <para>Hvis du kjenner til XML, er dette mye det samme som 
            ASCII-delen av syntaksen for XML <!-- ¤ Oversette den? 
            -->"Name".</para>
        </footnote></para>

      <!-- @ENGLISH {{{
      <para>In addition to the <command>propset</command> command, the
        <command>svn</command> program supplies the
        <command>propedit</command> command.  This command uses the
        configured editor program (see <xref
        linkend="svn.advanced.confarea.opts.config" />) to add or modify properties.
        When you run the command, <command>svn</command> invokes your
        editor program on a temporary file that contains the current
        value of the property (or which is empty, if you are adding a
        new property).  Then, you just modify that value in your
        editor program until it represents the new value you wish to
        store for the property, save the temporary file, and then exit
        the editor program.  If Subversion detects that you've
        actually changed the existing value of the property, it will
        accept that as the new property value.  If you exit your
        editor without making any changes, no property modification
        will occur.</para>
      @ENGLISH }}} -->
      <para>I tillegg til <command>propset</command>-kommandoen, har 
        <command>svn</command>-programmet kommandoen 
        <command>propedit</command>.
        Denne kommandoen bruker tekstbehandleren som er spesifisert i 
        konfigurasjonen (se <xref 
        linkend="svn.advanced.confarea.opts.config" />) for å legge til 
        eller modifisere egenskaper.
        Når du kjører kommandoen, kjører <command>svn</command> 
        tekstbehandleren mot en midlertidig fil som inneholder den 
        nåværende verdien til egenskapen (eller starter uten tekst hvis 
        du legger til en ny egenskap).
        Deretter forandrer du på verdien i tekstbehandleren til den er 
        lik den nye verdien du vil lagre i egenskapen, lagrer den 
        midlertidige fila og avslutter tekstbehandleren.
        Hvis Subversion finner ut at du faktisk har forandret den 
        nåværende egenskapsverdien, vil den godta det som den nye 
        verdien til egenskapen.
        Hvis du avslutter tekstbehandleren uten å gjøre noen 
        forandringer, vil det ikke bli gjort noen forandringer i 
        egenskapen.</para>

      <!-- @ENGLISH {{{
      <screen>
$ svn propedit copyright calc/button.c  ### exit the editor without changes
No changes to property 'copyright' on 'calc/button.c'
$
</screen>
      @ENGLISH }}} -->
      <screen>
$ svn propedit copyright calc/button.c
### tekstbehandleren avsluttes uten at noe er forandret
Ingen endring for egenskap «copyright» på «calc/button.c»
$
</screen>

      <!-- @ENGLISH {{{
      <para>We should note that, as with other <command>svn</command>
        subcommands, those related to properties can act on multiple
        paths at once.  This enables you to modify properties on whole
        sets of files with a single command.  For example, we could
        have done:</para>
      @ENGLISH }}} -->
      <para>Vi skal legge merke til at i likhet med andre 
        <command>svn</command>-kommandoer kan de som har med egenskaper 
        å gjøre utføre handlinger på flere stier på en gang.
        Dette lar deg forandre egenskaper på hele sett av filer med en 
        enkelt kommando.
        For eksempel kunne vi ha gjort dette:</para>

      <!-- @ENGLISH {{{
      <screen>
$ svn propset copyright '(c) 2002 Red-Bean Software' calc/*
property 'copyright' set on 'calc/Makefile'
property 'copyright' set on 'calc/button.c'
property 'copyright' set on 'calc/integer.c'
&hellip;
$
</screen>
      @ENGLISH }}} -->
      <screen>
$ svn propset copyright '(c) 2002 Red-Bean Software' calc/*
Egenskapen «copyright» satt på «calc/Makefile»
Egenskapen «copyright» satt på «calc/button.c»
Egenskapen «copyright» satt på «calc/integer.c»
…
$
</screen>

      <!-- @ENGLISH {{{
      <para>All of this property adding and editing isn't really very
        useful if you can't easily get the stored property value.  So
        the <command>svn</command> program supplies two subcommands
        for displaying the names and values of properties stored on
        files and directories.  The <command>svn proplist</command>
        command will list the names of properties that exist on a
        path.  Once you know the names of the properties on the node,
        you can request their values individually using <command>svn
        propget</command>.  This command will, given a path (or set of
        paths) and a property name, print the value of the property to
        the standard output stream.</para>
      @ENGLISH }}} -->
      <para>Alt dette med å legge til og redigere egenskaper hadde 
        egentlig ikke vært særlig nyttig hvis du ikke hadde hatt en måte 
        å få tak i den lagrede egenskapsverdien.
        Til dette har <command>svn</command>-programmet to delkommandoer 
        for å vise navnene og verdiene til egenskaper som er lagret i 
        filer og kataloger.
        Kommandoen <command>svn proplist</command> vil liste ut navnene 
        på egenskapene som eksisterer i en sti.
        Når du vet navnene til egenskapene på noden, kan du be om 
        verdiene individuelt ved å bruke <command>svn propget</command>.
        Denne kommandoen vil, når den får en sti (eller sett av stier) 
        og et egenskapsnavn, skrive verdien av egenskapen til standard 
        ut-strømmen.</para>

      <!-- @ENGLISH {{{
      <screen>
$ svn proplist calc/button.c
Properties on 'calc/button.c':
  copyright
  license
$ svn propget copyright calc/button.c
(c) 2003 Red-Bean Software
</screen>
      @ENGLISH }}} -->
      <screen>
$ svn proplist calc/button.c
Egenskaper for «calc/button.c»:
  copyright
  license
$ svn propget copyright calc/button.c
(c) 2003 Red-Bean Software
</screen>

      <!-- @ENGLISH {{{
      <para>There's even a variation of the
        <command>proplist</command> command that will list both the
        name and value of all of the properties.  Simply supply the
        <option>-&#64738;-verbose</option> (<option>-v</option>) option.</para>
      @ENGLISH }}} -->
      <para>Det er til og med en variant av 
        <command>proplist</command>-kommandoen som vil liste både navnet 
        og verdien til alle egenskapene.
        Bare legg til valget <option>--verbose</option> 
        (<option>-v</option>).</para>

      <!-- @ENGLISH {{{
      <screen>
$ svn proplist -&#64738;-verbose calc/button.c
Properties on 'calc/button.c':
  copyright : (c) 2003 Red-Bean Software
  license : ================================================================
Copyright (c) 2003 Red-Bean Software.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions 
are met:

1. Redistributions of source code must retain the above copyright
notice, this list of conditions, and the recipe for Fitz's famous
red-beans-and-rice.
&hellip;
</screen>
      @ENGLISH }}} -->
      <screen>
$ svn proplist --verbose calc/button.c
Egenskaper for «calc/button.c»:
  copyright : (c) 2003 Red-Bean Software
  license : ================================================================
Copyright (c) 2003 Red-Bean Software.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions 
are met:

1. Redistributions of source code must retain the above copyright
notice, this list of conditions, and the recipe for Fitz's famous
red-beans-and-rice.
…
</screen>

      <!-- @ENGLISH {{{
      <para>The last property-related subcommand is
        <command>propdel</command>.  Since Subversion allows you to
        store properties with empty values, you can't remove a
        property altogether using <command>propedit</command> or
        <command>propset</command>.  For example, this command will
        <emphasis>not</emphasis> yield the desired effect:</para>
      @ENGLISH }}} -->
      <para>Den siste delkommandoen relatert til egenskaper er 
        <command>propdel</command>.
        Siden Subversion lar deg lagre egenskaper med tomme verdier, kan 
        du ikke fjerne en egenskap helt ved å bruke 
        <command>propedit</command> eller <command>propset</command>.
        For eksempel, denne kommandoen vil <emphasis>ikke</emphasis> 
        gjøre det du ønsker:</para>

      <!-- @ENGLISH {{{
      <screen>
$ svn propset license '' calc/button.c
property 'license' set on 'calc/button.c'
$ svn proplist -&#64738;-verbose calc/button.c
Properties on 'calc/button.c':
  copyright : (c) 2003 Red-Bean Software
  license : 
$
</screen>
      @ENGLISH }}} -->
      <screen>
$ svn propset license '' calc/button.c
Egenskapen «license» satt på «calc/button.c»
$ svn proplist --verbose calc/button.c
Egenskaper for «calc/button.c»:
  copyright : (c) 2003 Red-Bean Software
  license : 
$
</screen>

      <!-- @ENGLISH {{{
      <para>You need to use the <command>propdel</command> command to
        delete properties altogether.  The syntax is similar to the
        other property commands:</para>
      @ENGLISH }}} -->
      <para>Du må bruke <command>propdel</command>-kommandoen for å 
        fjerne egenskaper helt.
        Syntaksen er lik de andre egenskapskommandoene:</para>

      <!-- @ENGLISH {{{
      <screen>
$ svn propdel license calc/button.c
property 'license' deleted from 'calc/button.c'.
$ svn proplist -&#64738;-verbose calc/button.c
Properties on 'calc/button.c':
  copyright : (c) 2003 Red-Bean Software
$
</screen>
      @ENGLISH }}} -->
      <screen>
$ svn propdel license calc/button.c
Egenskapen «license» slettet fra «calc/button.c».
$ svn proplist --verbose calc/button.c
Egenskaper for 'calc/button.c':
  copyright : (c) 2003 Red-Bean Software
$
</screen>

      <!-- @ENGLISH {{{
      <para>Now that you are familiar with all of the
        property-related <command>svn</command> subcommands, let's see
        how property modifications affect the usual Subversion
        workflow.  As we mentioned earlier, file and directory
        properties are versioned, just like your file contents.  As a
        result, Subversion provides the same opportunities for
        merging&mdash;in cleanly or conflicting fashions&mdash;someone
        else's modifications into your own.</para>
      @ENGLISH }}} -->
      <para>Nå som du er kjent med alle 
        <command>svn</command>-kommandoene som er relatert til 
        egenskaper, la oss se hvordan forandringer i egenskaper påvirker 
        den vanlige arbeidsflyten i Subversion.
        Som vi nevnte tidligere, er fil- og katalogegenskaper 
        versjonerte, akkurat som innholdet i filene dine.
        Dette betyr at Subversion har de samme mulighetene for fletting 
        – med dertil potensielle konflikter – av andres forandringer inn 
        i dine egne.</para>

      <sidebar>
        <!-- @ENGLISH {{{
        <title>Modifying Revision Properties</title>
        @ENGLISH }}} -->
        <title>Forandre revisjonsegenskaper</title>

        <!-- @ENGLISH {{{
        <para>Remember those unversioned revision properties?  You can
          modify those, too, with the <command>svn</command> program.
          Simply add the <option>-&#64738;-revprop</option> command-line
          parameter, and specify the revision whose property you wish
          to modify.  Since revisions are global, you don't need to
          specify a path in this case as long as you are positioned in
          the working copy of the repository whose revision property
          you wish to modify.  For example, you might want to replace
          the commit log message of an existing revision.
          <footnote>
            <para>Fixing spelling errors, grammatical gotchas, and
              <quote>just-plain-wrongness</quote> in commit log
              messages is perhaps the most common use case for the
              <option>-&#64738;-revprop</option> option.</para>
          </footnote></para>
        @ENGLISH }}} -->
        <para>Husker du de uversjonerte revisjonsegenskapene?
          Du kan modifisere disse også ved hjelp av 
          <command>svn</command>-programmet.
          Bare legg til <option>--revprop</option>-valget på 
          kommandolinja og spesifiser revisjonen som har den egenskapen 
          du vil forandre.
          Siden revisjoner er globale, trenger du ikke å spesifisere en 
          sti i dette tilfellet så lenge du står i arbeidskopien til 
          depotet som har revisjonsegenskapen som du vil forandre.
          Du vil for eksempel forandre loggmeldingen for en eksisterende 
          revisjon.<footnote>
            <para>Retting av skrivefeil, grammatiske flauser og ting som 
              er direkte feil i loggmeldinger er kanskje det vanligste 
              bruksområdet for <option>--revprop</option>-valget.</para>
          </footnote></para>

        <!-- @ENGLISH {{{
        <screen>
$ svn propset svn:log '* button.c: Fix a compiler warning.' -r11 -&#64738;-revprop
property 'svn:log' set on repository revision '11'
$
</screen>
        @ENGLISH }}} -->
        <screen>
$ svn propset svn:log '* button.c: Fix a compiler warning.' -r11 --revprop
Egenskapen «svn:log» satt på depotrevisjon «11»
$
</screen>

        <!-- @ENGLISH {{{
        <para>Note that the ability to modify these unversioned
          properties must be explicitly added by the repository
          administrator (see <xref linkend="svn.reposadmin.create.hooks" />).
          Since the properties aren't versioned, you run the risk of
          losing information if you aren't careful with your edits.
          The repository administrator can setup methods to protect
          against this loss, and by default, modification of
          unversioned properties is disabled.</para>
        @ENGLISH }}} -->
        <para>Legg merke til at muligheten til å forandre disse 
          uversjonerte egenskapene må bli eksplisitt satt av 
          depotadministratoren (se <xref 
          linkend="svn.reposadmin.create.hooks" />).
          Siden egenskapene ikke er versjonerte, risikerer du å miste 
          informasjon hvis du ikke er forsiktig når du redigerer.
          Depotadministratoren kan sette opp metoder for å beskytte mot 
          datatap som dette, og standardoppsettet forbyr forandringer i 
          revisjonsegenskaper.</para>

      </sidebar>

      <!-- @ENGLISH {{{
      <para>And as with file contents, your property changes are local
        modifications, only made permanent when you commit them to the
        repository with <command>svn commit</command>.  Your property
        changes can be easily unmade, too&mdash;the <command>svn
        revert</command> command will restore your files and
        directories to their un-edited states, contents, properties,
        and all.  Also, you can receive interesting information about
        the state of your file and directory properties by using the
        <command>svn status</command> and <command>svn diff</command>
        commands.</para>
      @ENGLISH }}} -->
      <para>Og i likhet med filinnhold, er forandringene dine i 
        egenskapene lokale modifiseringer som kun blir gjort permanente 
        når du legger dem inn i depotet med <command>svn 
        commit</command>.
        Egenskapsforandringene kan lett omgjøres – kommandoen 
        <command>svn revert</command> vil sette filene og katalogene 
        dine tilbake til den uredigerte tilstanden – innhold, 
        egenskaper, alt.
        Du kan også få interessant informasjon om tilstanden til fil- og 
        katalogegenskapene ved å bruke kommandoene <command>svn 
        status</command> og <command>svn diff</command>.</para>

      <!-- @ENGLISH {{{
      <screen>
$ svn status calc/button.c
 M     calc/button.c
$ svn diff calc/button.c
Property changes on: calc/button.c
___________________________________________________________________
Name: copyright
   + (c) 2003 Red-Bean Software

$
</screen>
      @ENGLISH }}} -->
      <screen>
$ svn status calc/button.c
 M     calc/button.c
$ svn diff calc/button.c
Egenskapsforandringer på: calc/button.c
___________________________________________________________________
Navn: copyright
   + (c) 2003 Red-Bean Software

$
</screen>

      <!-- @ENGLISH {{{
      <para>Notice how the <command>status</command> subcommand
        displays <literal>M</literal> in the second column instead of
        the first.  That is because we have modified the properties on
        <filename>calc/button.c</filename>, but not modified its
        textual contents.  Had we changed both, we would have seen
        <literal>M</literal> in the first column, too (see <xref
        linkend="svn.tour.cycle.examine.status" />).</para>
      @ENGLISH }}} -->
      <para>Legg merke til hvordan 
        <command>status</command>-delkommandoen viser 
        <literal>M</literal> i den andre kolonnen istedenfor den første.
        Det er fordi vi har forandret egenskapene på 
        <filename>calc/button.c</filename>, men ikke forandret 
        tekstinnholdet.
        Hadde vi forandret begge to, ville det også vært en 
        <literal>M</literal> i den første kolonnen (se <xref 
        linkend="svn.tour.cycle.examine.status" />).</para>

      <sidebar>
        <!-- @ENGLISH {{{
        <title>Property Conflicts</title>
        @ENGLISH }}} -->
        <title>Konflikter i egenskaper</title>

        <!-- @ENGLISH {{{
        <para>As with file contents, local property modifications can
          conflict with changes committed by someone else.  If you
          update your working copy directory and receive property
          changes on a versioned resource that clash with your own,
          Subversion will report that the resource is in a conflicted
          state.</para>
        @ENGLISH }}} -->
        <para>I likhet med filinnhold, kan lokale egenskapsforandringene 
          komme i konflikt med forandringer som er lagt inn av noen 
          andre.
          Hvis du oppdaterer arbeidskopikatalogen og mottar 
          egenskapsforandringer på en versjonert ressurs som kolliderer 
          med dine egne, vil Subversion rapportere at ressursen er i en 
          konflikttilstand.</para>
 
        <!-- @ENGLISH {{{
        <screen>
% svn update calc
M  calc/Makefile.in
 C calc/button.c
Updated to revision 143.
$ 
</screen>
        @ENGLISH }}} -->
        <screen>
% svn update calc
M  calc/Makefile.in
 C calc/button.c
Oppdatert til revisjon 143.
$
</screen>
         
        <!-- @ENGLISH {{{
        <para>Subversion will also create, in the same directory as
          the conflicted resource, a file with a
          <filename>.prej</filename> extension which contains the
          details of the conflict.  You should examine the contents of
          this file so you can decide how to resolve the conflict.
          Until the conflict is resolved, you will see a
          <literal>C</literal> in the second column of <command>svn
          status</command> output for that resource, and attempts to
          commit your local modifications will fail.</para>
        @ENGLISH }}} -->
        <para>Subversion vil også lage, i den samme katalogen som 
          ressursen som har en konflikt, en fil med etternavnet 
          <filename>.prej</filename> som inneholder detaljene om 
          konflikten.
          Du kan studere innholdet av denne fila så du kan avgjøre 
          hvordan konflikten skal løses.
          Inntil konflikten er løst, vil du se en <literal>C</literal> i 
          den andre kolonnen av <command>svn status</command>-utskriften 
          for denne ressursen, og forsøk på å legge inn dine lokale 
          forandringer vil feile.</para>

        <!-- @ENGLISH {{{
        <screen>
$ svn status calc
 C     calc/button.c
?      calc/button.c.prej
$ cat calc/button.c.prej 
prop 'linecount': user set to '1256', but update set to '1301'.
$
</screen>
        @ENGLISH }}} -->
        <!-- ¤ --><screen>
$ svn status calc
 C     calc/button.c
?      calc/button.c.prej
$ cat calc/button.c.prej
prop 'linecount': user set to '1256', but update set to '1301'.
$
</screen>
 
        <!-- @ENGLISH {{{
        <para>To resolve property conflicts, simply ensure that the
          conflicting properties contain the values that they should,
          and then use the <command>svn resolved</command> command to
          alert Subversion that you have manually resolved the
          problem.</para>
        @ENGLISH }}} -->
        <para>For å løse egenskapskonflikter, er det bare å passe på at 
          egenskapene som er i konflikt inneholder de verdiene som de 
          skal, og deretter bruke <command>svn 
          resolved</command>-kommandoen for å varsle Subversion om at du 
          har løst problemet manuelt.</para>

      </sidebar>

      <!-- @ENGLISH {{{
      <para>You might also have noticed the non-standard way that
        Subversion currently displays property differences.  You can
        still run <command>svn diff</command> and redirect the output
        to create a usable patch file.  The <command>patch</command>
        program will ignore property patches&mdash;as a rule, it
        ignores any noise it can't understand.  This does
        unfortunately mean that to fully apply a patch generated by
        <command>svn diff</command>, any property modifications will
        need to be applied by hand.</para>
      @ENGLISH }}} -->
      <para>Du har kanskje lagt merke til den smårare måten Subversion 
        viser forskjeller i egenskaper på.
        Du kan fortsatt kjøre <command>svn diff</command> og omdirigere 
        resultatet for å lage en gyldig patchfil.
        <command>patch</command>-programmet vil imidlertid ignorere 
        patcher for egenskaper – alle data som det ikke forstår vil bli 
        ignorert.
        Dette betyr dessverre at for å patche egenskaper med en fil 
        laget av <command>svn diff</command>, må forandringer i 
        egenskaper legges til for hånd.</para>

      <!-- @ENGLISH {{{
      <para>As you can see, the presence of property modifications has
        no outstanding effect on the typical Subversion workflow.
        Your general patterns of updating your working copy, checking
        the status of your files and directories, reporting on the
        modifications you have made, and committing those
        modifications to the repository are completely immune to the
        presence or absence of properties.  The <command>svn</command>
        program has some additional subcommands for actually making
        property changes, but that is the only noticeable asymmetry.</para>
      @ENGLISH }}} -->
      <para>Som du ser, påvirkes ikke arbeidsflyten i Subversion 
        nevneverdig selv om egenskapene er forandret.
        Rutinen med å oppdatere arbeidskopien, sjekke status på filer og 
        kataloger, rapportering om forandringer som du har gjort og 
        innlegging av disse forandringene til depotetet er fullstendig 
        likegyldig til nærværet eller fraværet av egenskaper.
        <command>svn</command>-programmet har noen tilleggskommandoer 
        for å faktisk gjøre forandringer i egenskaper, men det er den 
        eneste merkbare forskjellen.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.special">
      
      <title>Special Properties</title>

      <para>Subversion has no particular policy regarding
        properties&mdash;you can use them for any purpose.  Subversion
        asks only that you not use property names that begin with the
        prefix <literal>svn:</literal>.  That's the namespace that it
        sets aside for its own use.  In fact, Subversion defines
        certain properties that have magical effects on the files and
        directories to which they are attached.  In this section,
        we'll untangle the mystery, and describe how these special
        properties make your life just a little easier.</para>
      
      <sect3 id="svn.advanced.props.special.executable">
        <title><literal>svn:executable</literal></title>
 
        <para>The <literal>svn:executable</literal> property is used
          to control a versioned file's filesystem-level execute
          permission bit in a semi-automated way.  This property has
          no defined values&mdash;its mere presence indicates a desire
          that the execute permission bit be kept enabled by Subversion.
          Removing this property will restore full control of the
          execute bit back to the operating system.</para>

        <para>On many operating systems, the ability to execute a file
          as a command is governed by the presence of an execute
          permission bit.  This bit usually defaults to being
          disabled, and must be explicitly enabled by the user for
          each file that needs it.  In a working copy, new files are
          being created all the time as new versions of existing files
          are received during an update.  This means that you might
          enable the execute bit on a file, then update your working
          copy, and if that file was changed as part of the update,
          its execute bit might get disabled.  So, Subversion provides
          the <literal>svn:executable</literal> property as a way to
          keep the execute bit enabled.</para>

        <para>This property has no effect on filesystems that have no
          concept of an executable permission bit, such as FAT32 and
          NTFS.
          <footnote>
            <para>The Windows filesystems use file extensions (such as
              <literal>.EXE</literal>, <literal>.BAT</literal>, and
              <literal>.COM</literal>) to denote executable
              files.</para>
          </footnote>
          Also, although it has no defined values, Subversion will force
          its value to <literal>*</literal> when setting this property.
          Finally, this property is valid only on files, not on
          directories.</para>

      </sect3>

      <sect3 id="svn.advanced.props.special.mime-type">
        <title><literal>svn:mime-type</literal></title>
        
        <para>The <literal>svn:mime-type</literal> property serves
          many purposes in Subversion.  Besides being a
          general-purpose storage location for a file's Multipurpose
          Internet Mail Extensions (MIME) classification, the value of
          this property determines some behavioral characteristics
          of Subversion itself.</para>

        <para>For example, if a file's
          <literal>svn:mime-type</literal> property is set to a
          non-text MIME type (generally, something that doesn't begin
          with <literal>text/</literal>, though there are exceptions),
          Subversion will assume that the file contains
          binary&mdash;that is, not human-readable&mdash;data.  One of
          the benefits that Subversion typically provides is
          contextual, line-based merging of changes received from the
          server during an update into your working file.  But for
          files believed to contain binary data, there is no concept
          of a <quote>line</quote>.  So, for those files, Subversion
          does not attempt to perform contextual merges during
          updates.  Instead, any time you have locally modified a
          binary working copy file that is also being updated, your
          file is renamed with a <filename>.orig</filename> extension,
          and then Subversion stores a new working copy file that
          contains the changes received during the update, but not
          your own local modifications, at the original filename.
          This behavior is really for the protection of the user
          against failed attempts at performing contextual merges on
          files that simply cannot be contextually merged.</para>

        <para>Also, if the <literal>svn:mime-type</literal>
          property is set, then the Subversion Apache module will use
          its value to populate the <literal>Content-type:</literal>
          HTTP header when responding to GET requests.  This gives a
          crucial clue about how to display a file when perusing
          your repository with a web browser.</para>

      </sect3>

      <sect3 id="svn.advanced.props.special.ignore">
        <title><literal>svn:ignore</literal></title>

        <para>The <literal>svn:ignore</literal> property contains a
          list of file patterns which certain Subversion operations
          will ignore.  Perhaps the most commonly used special
          property, it works in conjunction with the
          <literal>global-ignores</literal> run-time configuration
          option (see <xref linkend="svn.advanced.confarea.opts.config" />) to
          filter unversioned files and directories out of commands
          <command>svn status</command>, <command>svn
          add</command>, and <command>svn import</command>.</para>

        <para>The rationale behind the <literal>svn:ignore</literal>
          property is easily explained.  Subversion does not assume
          that every file or subdirectory in a working copy directory
          is intended for version control.  Resources must be
          explicitly placed under Subversion's management using the
          <command>svn add</command> or <command>svn import</command>
          commands.  As a result, there are often many resources in a
          working copy that are not versioned.</para>

        <para>Now, the <command>svn status</command> command displays
          as part of its output every unversioned file or subdirectory
          in a working copy that is not already filtered out by the
          <literal>global-ignores</literal> option (or its built-in
          default value).  This is done so that users can see if
          perhaps they've forgotten to add a resource to version
          control.</para>

        <para>But Subversion cannot possibly guess the names of
          every resource that should be ignored.  Also, quite often
          there are things that should be ignored in
          <emphasis>every</emphasis> working copy of a particular
          repository.  To force every user of that repository to add
          patterns for those resources to their run-time configuration
          areas would be not just a burden, but has the potential to
          clash with the configuration needs of other working copies
          that the user has checked out.</para>

        <para>The solution is to store ignore patterns that are unique
          to the resources likely to appear in a given directory with
          the directory itself.  Common examples of unversioned
          resources that are basically unique to a directory, yet
          likely to appear there, include output from program
          compilations.  Or&mdash;to use an example more appropriate
          to this book&mdash;the HTML, PDF, or PostScript files
          generated as the result of a conversion of some source
          DocBook XML files to a more legible output format.</para>

        <sidebar>
          <title>Ignore Patterns for CVS Users</title>
        
          <para>The Subversion <literal>svn:ignore</literal> property
            is very similar in syntax and function to the CVS
            <filename>.cvsignore</filename> file.  In fact, if you are
            migrating a CVS working copy to Subversion, you can
            directly migrate the ignore patterns by using the
            <filename>.cvsignore</filename> file as input file to the
            <command>svn propset</command> command:</para>
       
          <screen>
$ svn propset svn:ignore -F .cvsignore .
property 'svn:ignore' set on '.'
$
</screen>        

          <para>There are, however, some differences in the ways that
            CVS and Subversion handle ignore patterns.  The two systems
            use the ignore patterns at some different times, and there
            are slight discrepancies in what the ignore patterns apply
            to.  Also, Subversion does not recognize the use of the
            <literal>!</literal> pattern as a reset back to having no
            ignore patterns at all.</para>

        </sidebar>

        <para>For this purpose, the <literal>svn:ignore</literal>
          property is the solution.  Its value is a multi-line
          collection of file patterns, one pattern per line.  The
          property is set on the directory in which you wish the
          patterns to be applied.
          <footnote>
            <para>The patterns are strictly for that
              directory&mdash;they do not carry recursively into
              subdirectories.</para>
          </footnote>
          For example, say you have the following output from
          <command>svn status</command>:</para>

        <screen>
$ svn status calc
 M     calc/button.c
?      calc/calculator
?      calc/data.c
?      calc/debug_log
?      calc/debug_log.1
?      calc/debug_log.2.gz
?      calc/debug_log.3.gz
</screen>

        <para>In this example, you have made some property
          modifications to <filename>button.c</filename>, but in your
          working copy you also have some unversioned files:
          the latest <filename>calculator</filename> program
          that you've compiled from your source code, a source file
          named <filename>data.c</filename>, and a set of debugging
          output log files.  Now, you know that your build system
          always results in the <filename>calculator</filename>
          program being generated.
          <footnote>
            <para>Isn't that the whole point of a build system?</para>
          </footnote>
          And you know that your test suite always leaves those
          debugging log files lying around.  These facts are true for
          all working copies, not just your own.  And you know that
          you aren't interested in seeing those things every time you
          run <command>svn status</command>.  So you use <command>svn
          propedit svn:ignore calc</command> to add some ignore
          patterns to the <filename>calc</filename> directory.  For
          example, you might add this as the new value of the
          <literal>svn:ignore</literal> property:</para>

        <programlisting>
calculator
debug_log*
</programlisting>

        <para>After you've added this property, you will now have a
          local property modification on the <filename>calc</filename>
          directory.  But notice what else is different about your
          <command>svn status</command> output:</para>

        <screen>
$ svn status
 M     calc
 M     calc/button.c
?      calc/data.c
</screen>

        <para>Now, all the cruft is missing from the output!  Of
          course, those files are still in your working copy.
          Subversion is simply not reminding you that they are present
          and unversioned.  And now with all the trivial noise removed
          from the display, you are left with more interesting
          items&mdash;such as that source code file that you probably
          forgot to add to version control.</para>

        <para>If you want to see the ignored files, you can pass the 
          <option>--no-ignore</option> option to Subversion:</para>

        <screen>
$ svn status --no-ignore
 M     calc/button.c
I      calc/calculator
?      calc/data.c
I      calc/debug_log
I      calc/debug_log.1
I      calc/debug_log.2.gz
I      calc/debug_log.3.gz
</screen>

        <para>The list of patterns to ignore is also used by
          <command>svn add</command> and <command>svn
          import</command>.  Both of these operations involve asking
          Subversion to begin managing some set of files and
          directories.  Rather than force the user to pick and choose
          which files in a tree she wishes to start versioning,
          Subversion uses the ignore patterns to determine which files
          should not be swept into the version control system as part
          of a larger recursive addition or import operation.</para>
   
      </sect3>

      <sect3 id="svn.advanced.props.special.keywords">
        <title><literal>svn:keywords</literal></title>

        <para>Subversion has the ability to substitute
          <firstterm>keywords</firstterm>&mdash;pieces of useful,
          dynamic information about a versioned file&mdash;into the
          contents of the file itself.  Keywords generally describe
          information about the last time the file was known to be
          modified.  Because this information changes each time the
          file changes, and more importantly, just
          <emphasis>after</emphasis> the file changes, it is a hassle
          for any process except the version control system to keep
          the data completely up-to-date.  Left to human authors, the
          information would inevitably grow stale.</para>

        <para>For example, say you have a document in which you would
          like to display the last date on which it was modified.  You
          could burden every author of that document to, just before
          committing their changes, also tweak the part of the
          document that describes when it was last changed.  But
          sooner or later, someone would forget to do that.  Instead
          simply ask Subversion to perform keyword substitution on the
          <literal>LastChangedDate</literal> keyword.  You control
          where the keyword is inserted into your document by placing
          a <firstterm>keyword anchor</firstterm> at the desired
          location in the file.  This anchor is just a string of text
          formatted as
          <literal>$</literal><replaceable>KeywordName</replaceable><literal>$</literal>.</para>

        <para>All keywords are case-sensitive where they appear as
          anchors in files: you must use the correct capitalization in
          order for the keyword to be expanded.  You should consider the
          value of the <literal>svn:keywords</literal> property to be
          case-sensitive too&mdash;certain keyword names will be recognized
          regardless of case, but this behavior is deprecated.</para>

        <para>Subversion defines the list of keywords available for
          substitution.  That list contains the following five keywords, 
          some of which have aliases that you can also use:</para>

        <variablelist>
          <varlistentry>
            <term><literal>Date</literal></term>
            <listitem>
              <para>This keyword describes the last time the file was
                known to have been changed in the repository, and
                looks something like <literal>$Date:
                2002-07-22 21:42:37 -0700 (Mon, 22 Jul 2002)
                $</literal>.  It may also be specified as
                <literal>LastChangedDate</literal>.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>Revision</literal></term>
            <listitem>
              <para>This keyword describes the last known revision in
                which this file changed in the repository, and looks
                something like <literal>$Revision: 144 $</literal>.  
                It may also be specified as
                <literal>LastChangedRevision</literal> or
                <literal>Rev</literal>.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>Author</literal></term>
            <listitem>
              <para>This keyword describes the last known user to
                change this file in the repository, and looks
                something like <literal>$Author: harry $</literal>.  
                It may also be specified as 
                <literal>LastChangedBy</literal>.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>HeadURL</literal></term>
            <listitem>
              <para>This keyword describes the full URL to the latest
                version of the file in the repository, and looks
                something like <literal>$HeadURL:
                http://svn.collab.net/repos/trunk/README $</literal>.
                It may be abbreviated as
                <literal>URL</literal>.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>Id</literal></term>
            <listitem>
              <para>This keyword is a compressed combination of the
                other keywords.  Its substitution looks something like
                <literal>$Id: calc.c 148 2002-07-28 21:30:43Z sally
                $</literal>, and is interpreted to mean that the file
                <filename>calc.c</filename> was last changed in revision
                148 on the evening of July 28, 2002 by the user
                <literal>sally</literal>.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Simply adding keyword anchor text to your file does
          nothing special.  Subversion will never attempt to perform
          textual substitutions on your file contents unless
          explicitly asked to do so.  After all, you might be writing
          a document
          <footnote>
            <para>&hellip; or maybe even a section of a book &hellip;</para>
          </footnote> 
          about how to use keywords, and you don't want Subversion to
          substitute your beautiful examples of un-substituted keyword
          anchors!</para>

        <para>To tell Subversion whether or not to substitute keywords
          on a particular file, we again turn to the property-related
          subcommands.  The <literal>svn:keywords</literal> property,
          when set on a versioned file, controls which keywords will
          be substituted on that file.  The value is a space-delimited
          list of the keyword names or aliases found in the previous
          table.</para>

        <para>For example, say you have a versioned file named
          <filename>weather.txt</filename> that looks like
          this:</para>

        <programlisting>
Here is the latest report from the front lines.
$LastChangedDate$
$Rev$
Cumulus clouds are appearing more frequently as summer approaches.
</programlisting>
        
        <para>With no <literal>svn:keywords</literal> property set on
          that file, Subversion will do nothing special.  Now, let's
          enable substitution of the
          <literal>LastChangedDate</literal> keyword.</para>

        <screen>
$ svn propset svn:keywords "Date Author" weather.txt
property 'svn:keywords' set on 'weather.txt'
$
</screen>        

        <para>Now you have made a local property modification on the
          <filename>weather.txt</filename> file.  You will see no
          changes to the file's contents (unless you made some of your
          own prior to setting the property).  Notice that the file
          contained a keyword anchor for the <literal>Rev</literal>
          keyword, yet we did not include that keyword in the property
          value we set.  Subversion will happily ignore requests to
          substitute keywords that are not present in the file, and
          will not substitute keywords that are not present in the
          <literal>svn:keywords</literal> property value.</para>

        <sidebar>
          <title>Keywords and Spurious Differences</title>

          <para>The user-visible result of keyword substitution might
            lead you to think that every version of a file with that
            feature in use differs from the previous version in at
            least the area where the keyword anchor was placed.
            However, this is actually not the case.  While checking
            for local modifications during <command>svn
            diff</command>, and before transmitting those local
            modifications during <command>svn commit</command>,
            Subversion <quote>un-substitutes</quote> any keywords that
            it previously substituted.  The result is that the
            versions of the file that are stored in the repository
            contain only the real modifications that users make to the
            file.</para>

        </sidebar>

        <para>Immediately after you commit this property change,
          Subversion will update your working file with the new
          substitute text.  Instead of seeing your keyword anchor
          <literal>$LastChangedDate$</literal>, you'll see its
          substituted result.  That result also contains the name of
          the keyword, and continues to be bounded by the dollar sign
          (<literal>$</literal>) characters.  And as we predicted, the
          <literal>Rev</literal> keyword was not substituted because
          we didn't ask for it to be.</para>

        <para>Note also that we set the <literal>svn:keywords</literal>
          property to <quote>Date Author</quote> yet the keyword
          anchor used the alias <literal>$LastChangedDate$</literal>
          and still expanded correctly.</para>

        <screen>
Here is the latest report from the front lines.
$LastChangedDate: 2002-07-22 21:42:37 -0700 (Mon, 22 Jul 2002) $
$Rev$
Cumulus clouds are appearing more frequently as summer approaches.
</screen>
        
        <para>If someone else now commits a change to
          <filename>weather.txt</filename>, your copy of that file
          will continue to display the same substituted keyword value
          as before&mdash;until you update your working copy.  At that
          time the keywords in your <filename>weather.txt</filename>
          file will be re-substituted with information that
          reflects the most recent known commit to that file.</para>

        <para>Subversion 1.2 introduced a new variant of the keyword
          syntax which brought additional, useful&mdash;though perhaps
          atypical&mdash;functionality.  You can now tell Subversion
          to maintain a fixed length (in terms of the number of bytes
          consumed) for the substituted keyword.  By using a
          double-colon (<literal>::</literal>) after the keyword name,
          followed by a number of space characters, you define that
          fixed width.  When Subversion goes to substitute your
          keyword for the keyword and its value, it will essentially
          replace only those space characters, leaving the overall
          width of the keyword field unchanged.  If the substituted
          value is shorter than the defined field width, there will be
          extra padding characters (spaces) at the end of the
          substituted field; if it is too long, it is truncated with a
          special hash (<literal>#</literal>) character just before
          the final dollar sign terminator.</para>

        <para>For example, say you have a document in which you have
          some section of tabular data reflecting the document's
          Subversion keywords.  Using the original Subversion keyword
          substitution syntax, your file might look something
          like:</para>

        <screen>
$Rev$:     Revision of last commit
$Author$:  Author of last commit
$Date$:    Date of last commit
</screen>

        <para>Now, that looks nice and tabular at the start of things.
          But when you then commit that file (with keyword substitution
          enabled, of course), you see:</para>

        <screen>
$Rev: 12 $:     Revision of last commit
$Author: harry $:  Author of last commit
$Date: 2006-03-15 02:33:03 -0500 (Wed, 15 Mar 2006) $:    Date of last commit
</screen>

        <para>The result is not so beautiful.  And you might be
          tempted to then adjust the file after the substitution so
          that it again looks tabular.  But that only holds as long as
          the keyword values are the same width.  If the last
          committed revision rolls into a new place value (say, from
          99 to 100), or if another person with a longer username
          commits the file, stuff gets all crooked again.  However, if
          you are using Subversion 1.2 or better, you can use the new
          fixed-length keyword syntax, define some field widths that
          seem sane, and now your file might look like this:</para>

        <screen>
$Rev::               $:  Revision of last commit
$Author::            $:  Author of last commit
$Date::              $:  Date of last commit
</screen>

        <para>You commit this change to your file.  This time,
          Subversion notices the new fixed-length keyword syntax, and
          maintains the width of the fields as defined by the padding
          you placed between the double-colon and the trailing dollar
          sign.  After substitution, the width of the fields is
          completely unchanged&mdash;the short values for
          <literal>Rev</literal> and <literal>Author</literal> are
          padded with spaces, and the long <literal>Date</literal>
          field is truncated by a hash character:</para>

        <screen>
$Rev:: 13            $:  Revision of last commit
$Author:: harry      $:  Author of last commit
$Date:: 2006-03-15 0#$:  Date of last commit
</screen>
       
        <para>The use of fixed-length keywords is especially handy
          when performing substitutions into complex file formats that
          themselves use fixed-length fields for data, or for which
          the stored size of a given data field is overbearingly
          difficult to modify from outside the format's native
          application (such as for Microsoft Office documents).</para>

        <warning>
          <para>Be aware that because the width of a keyword field is
            measured in bytes, the potential for corruption of
            multi-byte values exists.  For example, a username which
            contains some multi-byte UTF-8 characters might suffer
            truncation in the middle of the string of bytes which make
            up one of those characters.  The result will be a mere
            truncation when viewed at the byte level, but will likely
            appear as a string with an incorrect or garbled final
            character when viewed as UTF-8 text.  It is conceivable
            that certain applications, when asked to load the file,
            would notice the broken UTF-8 text and deem the entire
            file corrupt, refusing to operate on the file
            altogether.</para> 
        </warning>

      </sect3>

      <sect3 id="svn.advanced.props.special.eol-style">
        <title><literal>svn:eol-style</literal></title>

        <para>Unless otherwise noted using a versioned file's
          <literal>svn:mime-type</literal> property, Subversion
          assumes the file contains human-readable data.  Generally
          speaking, Subversion only uses this knowledge to determine
          if contextual difference reports for that file are
          possible.  Otherwise, to Subversion, bytes are bytes.</para>
        
        <para>This means that by default, Subversion doesn't pay any
          attention to the type of <firstterm>end-of-line (EOL)
          markers</firstterm> used in your files.  Unfortunately,
          different operating systems use different tokens to represent
          the end of a line of text in a file.  For example, the usual
          line ending token used by software on the Windows platform
          is a pair of ASCII control characters&mdash;carriage return
          (<literal>CR</literal>) and line feed
          (<literal>LF</literal>).  Unix software, however, just uses
          the <literal>LF</literal> character to denote the end of a
          line.</para>

        <para>Not all of the various tools on these operating systems
          are prepared to understand files that contain line endings
          in a format that differs from the <firstterm>native line
          ending style</firstterm> of the operating system on which
          they are running.  Common results are that Unix programs
          treat the <literal>CR</literal> character present in Windows
          files as a regular character (usually rendered as
          <literal>^M</literal>), and that Windows programs combine
          all of the lines of a Unix file into one giant line because
          no carriage return-linefeed (or <literal>CRLF</literal>)
          character combination was found to denote the end of
          line.</para>

        <para>This sensitivity to foreign EOL markers can become
          frustrating for folks who share a file across different
          operating systems.  For example, consider a source code
          file, and developers that edit this file on both Windows and
          Unix systems.  If all the developers always use tools which
          preserve the line ending style of the file, no problems
          occur.</para>

        <para>But in practice, many common tools either fail to
          properly read a file with foreign EOL markers, or they
          convert the file's line endings to the native style when the
          file is saved.  If the former is true for a developer, he
          has to use an external conversion utility (such as
          <command>dos2unix</command> or its companion,
          <command>unix2dos</command>) to prepare the file for
          editing.  The latter case requires no extra preparation.
          But both cases result in a file that differs from the
          original quite literally on every line!  Prior to committing
          his changes, the user has two choices.  Either he can use a
          conversion utility to restore the modified file to the same
          line ending style that it was in before his edits were made.
          Or, he can simply commit the file&mdash;new EOL markers and
          all.</para>

        <para>The result of scenarios like these include wasted time
          and unnecessary modifications to committed files.  Wasted
          time is painful enough.  But when commits change every line
          in a file, this complicates the job of determining which of
          those lines were changed in a non-trivial way.  Where was
          that bug really fixed?  On what line was a syntax error
          introduced?</para>

        <para>The solution to this problem is the
          <literal>svn:eol-style</literal> property.  When this
          property is set to a valid value, Subversion uses it to
          determine what special processing to perform on the file so
          that the file's line ending style isn't flip-flopping with
          every commit that comes from a different operating
          system.  The valid values are:</para>

        <variablelist>
          <varlistentry>
            <term><literal>native</literal></term>
            <listitem>
              <para>This causes the file to contain the EOL markers
                that are native to the operating system on which
                Subversion was run.  In other words, if a user on a
                Windows machine checks out a working copy that
                contains a file with an
                <literal>svn:eol-style</literal> property set to
                <literal>native</literal>, that file will contain
                <literal>CRLF</literal> EOL markers.  A Unix user
                checking out a working copy which contains the same
                file will see <literal>LF</literal> EOL markers in his
                copy of the file.</para>

              <para>Note that Subversion will actually store the file
                in the repository using normalized
                <literal>LF</literal> EOL markers regardless of the
                operating system.  This is basically transparent to
                the user, though.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>CRLF</literal></term>
            <listitem>
              <para>This causes the file to contain
                <literal>CRLF</literal> sequences for EOL markers,
                regardless of the operating system in use.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>LF</literal></term>
            <listitem>
              <para>This causes the file to contain
                <literal>LF</literal> characters for EOL markers,
                regardless of the operating system in use.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>CR</literal></term>
            <listitem>
              <para>This causes the file to contain
                <literal>CR</literal> characters for EOL markers,
                regardless of the operating system in use.  This line
                ending style is not very common.  It was used on older
                Macintosh platforms (on which Subversion doesn't even
                run).</para>
            </listitem>
          </varlistentry>
        </variablelist>
        
      </sect3>

      <sect3 id="svn.advanced.props.special.externals">
        <title><literal>svn:externals</literal></title>

        <para>The <literal>svn:externals</literal> property contains
          instructions for Subversion to populate a versioned
          directory with one or more other checked-out Subversion
          working copies.  For more information on this keyword and
          its use, see <xref linkend="svn.advanced.externals"/>.</para>

      </sect3>

      <sect3 id="svn.advanced.props.special.special">
        <title><literal>svn:special</literal></title>

        <para>The <literal>svn:special</literal> property is the only
          <literal>svn:</literal> property that isn't meant to be
          directly set or modified by users.  Subversion automatically
          sets this property whenever a <quote>special</quote> object
          is scheduled for addition, such as a symbolic link.  The
          repository stores an <literal>svn:special</literal> object as
          an ordinary file.  However, when a client sees this property
          during checkouts or updates, it interprets the contents of
          the file and translates the item back into the special type
          of object.  In versions of Subversion current at the time of
          writing, only versioned symbolic links have this property
          attached, but in future versions of Subversion other special
          types of nodes will probably use this property as
          well.</para>

        <para>Note: Windows clients don't have symbolic links, and
          thus ignore any <literal>svn:special</literal> files coming
          from a repository that claim to be symbolic links.  On
          Windows, the user ends up with an ordinary versioned file in
          the working copy.</para>
      </sect3>

      <sect3 id="svn.advanced.props.special.needs-lock">
        <title><literal>svn:needs-lock</literal></title>

        <para>This property is used to signify that the file it's
          attached to ought to be locked before editing.  The value of
          the property is irrelevant; Subversion will normalize its
          value to <literal>*</literal>.  When present, the file will
          be read-only <emphasis>unless</emphasis> the user has
          explicitly locked the file.  When a lock-token is present
          (as a result of running <command>svn lock</command>), the
          file becomes read-write.  When the lock is released, the
          file becomes read-only again.</para>

        <para>To learn more about how, when, and why this property
          should be used, see
          <xref
          linkend="svn.advanced.locking.lock-communication"/>.</para>
      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.auto">
      <title>Automatic Property Setting</title>

      <para>Properties are a powerful feature of Subversion, acting as
        key components of many Subversion features discussed elsewhere
        in this and other chapters&mdash;textual diff and merge
        support, keyword substitution, newline translation, etc.  But
        to get the full benefit of properties, they must be set on the
        right files and directories.  Unfortunately, that can be a
        step easily forgotten in the routine of things, especially
        since failing to set a property doesn't usually result in an
        obvious error condition (at least compared to, say, failing to
        add a file to version control).  To help your properties get
        applied to the places that need them, Subversion provides a
        couple of simple but useful features.</para>

      <para>Whenever you introduce a file to version control using the
        <command>svn add</command> or <command>svn import</command>
        commands, Subversion runs a very basic heuristic to determine
        if that file consists of human-readable or non-human-readable
        content.  If the latter is the decision made, Subversion will
        automatically set the <literal>svn:mime-type</literal>
        property on that file to
        <literal>application/octet-stream</literal> (the generic
        <quote>this is a collection of bytes</quote> MIME type).  Of
        course, if Subversion guesses incorrectly, or if you wish to
        set the <literal>svn:mime-type</literal> property to something
        more precise&mdash;perhaps <literal>image/png</literal> or
        <literal>application/x-shockwave-flash</literal>&mdash;you can
        always remove or edit that property.</para>

      <para>Subversion also provides the auto-props feature, which
        allows you to create mappings of filename patterns to property
        names and values.  These mappings are made in your runtime
        configuration area.  They again affect adds and imports, and
        not only can override any default MIME type decision made by
        Subversion during those operations, they can also set
        additional Subversion or custom properties, too.  For example,
        you might create a mapping that says that any time you add
        JPEG files&mdash;ones that match the pattern
        <literal>*.jpg</literal>&mdash;Subversion should automatically
        set the <literal>svn:mime-type</literal> property on those
        files to <literal>image/jpeg</literal>.  Or perhaps any files
        that match <literal>*.cpp</literal> should have
        <literal>svn:eol-style</literal> set to
        <literal>native</literal>, and <literal>svn:keywords</literal>
        set to <literal>Id</literal>.  Auto-prop support is perhaps
        the handiest property related tool in the Subversion toolbox.
        See <xref linkend="svn.advanced.confarea.opts.config"/> for more about
        configuring that support.</para>

    </sect2>     
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.locking">
    <title>Locking</title>

    <para>Subversion's <quote>copy-modify-merge</quote> model is
      optimal when users are collaborating on projects that consist of
      line-based text files, such as program source code.  However, as
      discussed in <xref
      linkend="svn.basic.vsn-models.copy-merge.sb-1"/>, sometimes one
      has to use the <quote>lock-modify-unlock</quote> model instead
      of Subversion's standard concurrent model.  When a file consists
      of binary data, it's often difficult or impossible to merge two
      sets of changes made in parallel by different users.  For this
      reason, Subversion 1.2 and later offers a feature known as
      <firstterm>locking</firstterm>, often known as <quote>reserved
      checkouts</quote> in other version control systems.</para>

    <para>Subversion's locking feature has two main goals:</para>

    <itemizedlist>
      <listitem><para><emphasis>Serializing access to a
          resource</emphasis>.  Allow a user to grab an exclusive
          right to change to a file in the repository.  If Harry
          reserves the right to change <filename>foo.jpg</filename>,
          then Sally should not be able to commit a change to it.</para>
      </listitem>
      <listitem><para><emphasis>Aiding communication</emphasis>.
          Prevent users from wasting time on unmergeable changes.  If
          Harry has reserved the right to change
          <filename>foo.jpg</filename>, then it should be easy for
          Sally to notice this fact and avoid working on the
          file.</para>
      </listitem>
    </itemizedlist>

    <para>Subversion's locking feature is currently limited to files
      only&mdash;it's not yet possible to reserve access to a whole
      directory tree.</para>

    <sidebar id="svn.advanced.locking.meanings">
      <title>Three meanings of <quote>lock</quote></title>

      <para>In this section, and almost everywhere in this book, the
        words <quote>lock</quote> and <quote>locking</quote> describe
        a mechanism for mutual exclusion between users to avoid
        clashing commits. Unfortunately, there are two other sorts
        of <quote>lock</quote> with which Subversion, and therefore
        this book, sometimes needs to be concerned.</para>

      <itemizedlist>

        <listitem><para><firstterm>Working copy locks</firstterm>,
          used internally by Subversion to prevent clashes between
          multiple Subversion clients operating on the same working
          copy. This is the sort of lock indicated by
          an <computeroutput>L</computeroutput> in the third column
          of <command>svn status</command> output, and removed by
          the <command>svn cleanup</command> command, as described in
          <xref linkend="svn.tour.other.cleanup"/>.</para>
        </listitem>

        <listitem><para><firstterm>Database locks</firstterm>, used
          internally by the Berkeley DB backend to prevent clashes
          between multiple programs trying to access the
          database. This is the sort of lock whose unwanted
          persistence after an error can cause a repository to
          be <quote>wedged</quote>, as described in
          <xref linkend="svn.reposadmin.maint.recovery"/>.</para>
        </listitem>

      </itemizedlist>

      <para>You can generally forget about these other sorts of lock,
        until something goes wrong that requires you to care about
        them. In this book, <quote>lock</quote> means the first sort
        unless the contrary is either clear from context or explicitly
        stated.</para>
    </sidebar>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.locking.creation">
      <title>Creating locks</title>
      
      <para>In the Subversion repository, a
        <firstterm>lock</firstterm> is a piece of metadata which
        grants exclusive access to one user to change a file.  This
        user is said to be the <firstterm>lock owner</firstterm>.
        Each lock also has a unique identifier, typically a long
        string of characters, known as the <firstterm>lock
        token</firstterm>.  The repository manages locks in a separate
        table, and enforces locks during a commit operation.  If any
        commit transaction attempts to modify or delete the file (or
        delete a parent of the file), the repository will demand two
        pieces of information:</para>
      
      <orderedlist>
        <listitem><para><emphasis role="bold">User
          authentication</emphasis>.  The client performing the commit
          must be authenticated as the lock owner.</para>
        </listitem>
        <listitem><para><emphasis role="bold">Software
          authorization</emphasis>.  The user's working copy must send
          the lock token with the commit, proving that it knows
          exactly which lock it's using.</para>
        </listitem>
      </orderedlist>
      
      <para>An example is in order, to demonstrate.  Let's say that
        Harry has decided to change a JPEG image.  To prevent other
        people from committing changes to the file, he locks the file
        in the repository using the <command>svn lock</command>
        command:</para>

      <screen>
$ svn lock banana.jpg --message "Editing file for tomorrow's release."
'banana.jpg' locked by user 'harry'.

$ svn status
     K banana.jpg

$ svn info banana.jpg
Path: banana.jpg
Name: banana.jpg
URL: http://svn.example.com/repos/project/banana.jpg
Repository UUID: edb2f264-5ef2-0310-a47a-87b0ce17a8ec
Revision: 2198
Node Kind: file
Schedule: normal
Last Changed Author: frank
Last Changed Rev: 1950
Last Changed Date: 2005-03-15 12:43:04 -0600 (Tue, 15 Mar 2005)
Text Last Updated: 2005-06-08 19:23:07 -0500 (Wed, 08 Jun 2005)
Properties Last Updated: 2005-06-08 19:23:07 -0500 (Wed, 08 Jun 2005)
Checksum: 3b110d3b10638f5d1f4fe0f436a5a2a5
Lock Token: opaquelocktoken:0c0f600b-88f9-0310-9e48-355b44d4a58e
Lock Owner: harry
Lock Created: 2005-06-14 17:20:31 -0500 (Tue, 14 Jun 2005)
Lock Comment (1 line):
Editing file for tomorrow's release.

</screen>

      <para>There are a number of new things demonstrated in the
        previous example.  First, notice that Harry passed the
        <option>--message</option> option to <command>svn
        lock</command>.  Similar to <command>svn commit</command>,
        the <command>svn lock</command> command can take comments
        (either via
        <option>--message (-m)</option> or <option>--file
        (-F)</option>) to describe the reason for locking the file.
        Unlike <command>svn commit</command>, however, <command>svn
        lock</command> will not demand a message by launching your
        preferred text editor.  Lock comments are optional, but still
        recommended to aid communication.</para>

      <para>Second, the lock attempt succeeded.  This means that the
        file wasn't already locked, and that Harry had the latest
        version of the file.  If Harry's working copy of the file had
        been out-of-date, the repository would have rejected the
        request, forcing harry to <command>svn update</command> and
        reattempt the locking command.</para>

      <para>Also notice that after creating the lock in the
        repository, the working copy has cached information about the
        lock&mdash;most importantly, the lock token.  The presence of
        the lock token is critical.  It gives the working copy
        authorization to make use of the lock later on.  The
        <command>svn status</command> command shows a
        <literal>K</literal> next to the file (short for locKed),
        indicating that the lock token is present.</para>

      <sidebar>
        <title>Regarding lock tokens</title>

        <para>A lock token isn't an authentication token, so much as
          an <emphasis>authorization</emphasis> token.  The token
          isn't a protected secret.  In fact, a lock's unique token is
          discoverable by anyone who runs <command>svn info
          URL</command>.</para>

        <para>A lock token is special only when it lives inside a
          working copy.  It's proof that the lock was created in that
          particular working copy, and not somewhere else by some
          other client.  Merely authenticating as the lock owner isn't
          enough to prevent accidents.</para>

        <para>For example: suppose you lock a file using a computer at
         your office, perhaps as part of a changeset in progress.  It
         should not be possible for a working copy (or alternate
         Subversion client) on your home computer to accidentally
         commit a change to that same file, just because you've
         authenticated as the lock's owner.  In other words, the lock
         token prevents one piece of Subversion-related software from
         undermining the work of another.  (In our example, if you
         really need to change the file from an alternate working
         copy, you would need to break the lock and re-lock the
         file.)</para>
      </sidebar>

      <para>Now that Harry has locked <filename>banana.jpg</filename>,
        Sally is unable to change or delete that file:</para>

      <screen>
$ whoami
sally

$ svn delete banana.jpg
D         banana.jpg

$ svn commit -m "Delete useless file."
Deleting       banana.jpg
svn: Commit failed (details follow):
svn: DELETE of
'/repos/project/!svn/wrk/64bad3a9-96f9-0310-818a-df4224ddc35d/banana.jpg':
423 Locked (http://svn.example.com)

</screen>

      <para>But Harry, after touching up the banana's shade of yellow,
        is able to commit his changes to the file.  That's because he
        authenticates as the lock owner, and also because his working
        copy holds the correct lock token:</para>

      <screen>
$ whoami
harry

$ svn status
M    K banana.jpg

$ svn commit -m "Make banana more yellow"
Sending        banana.jpg
Transmitting file data .
Committed revision 2201.

$ svn status
$
</screen>

      <para>Notice that after the commit is finished, <command>svn
          status</command> shows that the lock token is no longer
          present in working copy.  This is the standard behavior
          of <command>svn commit</command>: it walks the working copy
          (or list of targets, if you provide such a list), and sends
          all lock tokens it encounters to the server as part of the
          commit transaction.  After the commit completes
          successfully, all of the repository locks that were
          mentioned are released&mdash;<emphasis>even on files that
          weren't committed.</emphasis> The rationale here is to
          discourage users from being sloppy about locking, or from
          holding locks for too long.  For example, suppose Harry were
          to haphazardly lock thirty files in a directory named
          <filename>images</filename>, because he's unsure of which
          files he needs to change.  He ends up making changes to only
          four files.  When he runs <command>svn commit
          images</command>, the process would still release all thirty
          locks.</para>

      <para>This behavior of automatically releasing locks can be
          overridden with the <option>--no-unlock</option> option
          to <command>svn commit</command>.  This is best used for
          those times when you want to commit changes, but still plan
          to make more changes and thus need to retain existing locks.
          This behavior is also semi-permanently tweakable, by setting
          <literal>no-unlock = yes</literal> in your run-time
          <filename>config</filename> file (see <xref
          linkend="svn.advanced.confarea"/>).</para>

      <para>Of course, locking a file doesn't oblige one to commit a
        change to it.  The lock can be released at any time with a
        simple
        <command>svn unlock</command> command:</para>

      <screen>
$ svn unlock banana.c
'banana.c' unlocked.
</screen>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.locking.discovery">
      <title>Discovering locks</title>

      <para>When a commit fails due to someone else's locks, it's
        fairly easy to learn about them.  The easiest of
        these is <command>svn status --show-updates</command>:</para>

      <screen>
$ whoami
sally

$ svn status --show-updates
M              23   bar.c
M    O         32   raisin.jpg
       *       72   foo.h
Status against revision:     105
</screen>

      <para>In this example, Sally can see not only that her copy of
        <filename>foo.h</filename> is out-of-date, but that one of the
        two modified files she plans to commit is locked in the
        repository.  The <literal>O</literal> symbol stands for
        <quote>Other</quote>, meaning that a lock exists on the file,
        and was created by somebody else.  If she were to attempt a
        commit, the lock on <filename>raisin.jpg</filename> would
        prevent it.  Sally is left wondering who made the lock, when,
        and why.  Once again, <command>svn info</command> has the
        answers:</para>

      <screen>
$ svn info http://svn.example.com/repos/project/raisin.jpg
Path: raisin.jpg
Name: raisin.jpg
URL: http://svn.example.com/repos/project/raisin.jpg
Repository UUID: edb2f264-5ef2-0310-a47a-87b0ce17a8ec
Revision: 105
Node Kind: file
Last Changed Author: sally
Last Changed Rev: 32
Last Changed Date: 2005-01-25 12:43:04 -0600 (Tue, 25 Jan 2005)
Lock Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Lock Owner: harry
Lock Created: 2005-02-16 13:29:18 -0500 (Wed, 16 Feb 2005)
Lock Comment (1 line):
Need to make a quick tweak to this image.
</screen>

      <para>Just as <command>svn info</command> can be used to examine
        objects in the working copy, it can also be used to examine
        objects in the repository.  If the main argument to
        <command>svn info</command> is a working copy path, then all
        of the working copy's cached information is displayed; any
        mention of a lock means that the working copy is holding a
        lock token (if a file is locked by another user or in another
        working copy, <command>svn info</command> on a working copy
        path will show no lock information at all).  If the main
        argument to <command>svn info</command> is a URL, then the
        information reflects the latest version of an object in the
        repository; any mention of a lock describes the current lock
        on the object.</para>

      <para>So in this particular example, Sally can see that Harry
        locked the file on February 16th to <quote>make a quick
        tweak</quote>.  It being June, she suspects that he probably
        forgot all about the lock.  She might phone Harry to complain
        and ask him to release the lock.  If he's unavailable, she
        might try to forcibly break the lock herself or ask an
        administrator to do so.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.locking.break-steal">
      <title>Breaking and stealing locks</title>

      <para>A repository lock isn't sacred; it can be released not
        only by the person who created it, but by anyone at all.  When
        somebody other than the original lock creator destroys a lock,
        we refer to this as <firstterm>breaking</firstterm> the
        lock.</para>

      <para>From the administrator's chair, it's simple to break
        locks.  The <command>svnlook</command>
        and <command>svnadmin</command> programs have the ability to
        display and remove locks directly from the repository.  (For
        more information about these tools, see
        <xref linkend="svn.reposadmin.maint.tk"/>.)</para>

      <screen>
$ svnadmin lslocks /usr/local/svn/repos
Path: /project2/images/banana.jpg
UUID Token: opaquelocktoken:c32b4d88-e8fb-2310-abb3-153ff1236923
Owner: frank
Created: 2005-06-15 13:29:18 -0500 (Wed, 15 Jun 2005)
Expires: 
Comment (1 line):
Still improving the yellow color.

Path: /project/raisin.jpg
UUID Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Owner: harry
Created: 2005-02-16 13:29:18 -0500 (Wed, 16 Feb 2005)
Expires: 
Comment (1 line):
Need to make a quick tweak to this image.

$ svnadmin rmlocks /usr/local/svn/repos /project/raisin.jpg
Removed lock on '/project/raisin.jpg'.
</screen>

      <para>The more interesting option is allowing users to break
        each other's locks over the network.  To do this, one simply
        needs to pass the <option>--force</option> to the unlock
        command:</para>

      <screen>
$ whoami
sally

$ svn status --show-updates
M              23   bar.c
M    O         32   raisin.jpg
       *       72   foo.h
Status against revision:     105

$ svn unlock raisin.jpg
svn: 'raisin.jpg' is not locked in this working copy

$ svn info raisin.jpg | grep URL
URL: http://svn.example.com/repos/project/raisin.jpg

$ svn unlock http://svn.example.com/repos/project/raisin.jpg
svn: Unlock request failed: 403 Forbidden (http://svn.example.com)

$ svn unlock --force http://svn.example.com/repos/project/raisin.jpg
'raisin.jpg' unlocked.
</screen>

      <para>Sally's initial attempt to unlock failed because she
        ran <command>svn unlock</command> directly on her working copy
        of the file, and no lock token was present.  To remove the
        lock directly from the repository, she needs to pass a URL
        to <command>svn unlock</command>.  Her first attempt to unlock
        the URL fails, because she can't authenticate as the lock
        owner (nor does she have the lock token).  But when she
        passes <option>--force</option>, the authentication and
        authorization requirements are ignored, and the remote lock is
        broken.</para>
        
      <para>Of course, simply breaking a lock may not be enough.  In
        the running example, Sally may not only want to break Harry's
        long-forgotten lock, but re-lock the file for her own use.
        She can accomplish this by running <command>svn unlock
        --force</command> and then <command>svn lock</command>
        back-to-back, but there's a small chance that somebody else
        might lock the file between the two commands.  The simpler thing
        to is <firstterm>steal</firstterm> the lock, which involves
        breaking and re-locking the file all in one atomic step.  To
        do this, pass the <option>--force</option> option
        to <command>svn lock</command>:</para>

        <screen>
$ svn lock raisin.jpg
svn: Lock request failed: 423 Locked (http://svn.example.com)

$ svn lock --force raisin.jpg
'raisin.jpg' locked by user 'sally'.
</screen>

        <para>In any case, whether the lock is broken or stolen, Harry
          may be in for a surprise.  Harry's working copy still
          contains the original lock token, but that lock no longer
          exists.  The lock token is said to
          be <firstterm>defunct</firstterm>.  The lock represented by
          the lock-token has either been broken (no longer in the
          repository), or stolen (replaced with a different lock).
          Either way, Harry can see this by asking <command>svn
          status</command> to contact the repository:</para>

        <screen>
$ whoami
harry

$ svn status
     K raisin.jpg

$ svn status --show-updates
     B         32   raisin.jpg

$ svn update
  B  raisin.jpg

$ svn status

$
</screen>

        <para>If the repository lock was broken, then <command>svn
            status --show-updates</command> displays
            a <literal>B</literal> (Broken) symbol next to the file.
            If a new lock exists in place of the old one, then
            a <literal>T</literal> (sTolen) symbol is shown.
            Finally, <command>svn update</command> notices any defunct
            lock tokens and removes them from the working copy.</para>

        <sidebar>
          <title>Locking Policies</title>
        
          <para>Different systems have different notions of how strict
            a lock should be.  Some folks argue that locks must be
            strictly enforced at all costs, releasable only by the
            original creator or administrator.  They argue that if
            anyone can break a lock, then chaos breaks loose and the
            whole point of locking is defeated.  The other side argues
            that locks are first and foremost a communication tool.
            If users are constantly breaking each others' locks, then
            it represents a cultural failure within the team and the
            problem falls outside the scope of software
            enforcement.</para>

          <para>Subversion defaults to the <quote>softer</quote>
            approach, but still allows administrators to create
            stricter enforcement policies through the use of hook
            scripts.  In particular, the <filename>pre-lock</filename>
            and <filename>pre-unlock</filename> hooks allow
            administrators to decide when lock creation and lock
            releases are allowed to happen.  Depending on whether or
            not a lock already exists, these two hooks can decide
            whether or not to allow a certain user to break or steal a
            lock.  The <filename>post-lock</filename>
            and <filename>post-unlock</filename> hooks are also
            available, and can be used to send email after locking
            actions.</para>

          <para>To learn more about repository hooks, see
            <xref linkend="svn.reposadmin.create.hooks"/>.</para>
        </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.locking.lock-communication">
      <title>Lock Communication</title>

      <para>We've seen how <command>svn lock</command>
        and <command>svn unlock</command> can be used to create,
        release, break, and steal locks.  This satisfies the goal of
        serializing commit access to a file.  But what about the
        larger problem of preventing wasted time?</para>

      <para>For example, suppose Harry locks an image file and then
        begins editing it.  Meanwhile, miles away, Sally wants to do
        the same thing.  She doesn't think to run <command>svn status
        --show-updates</command>, so she has no idea that Harry has
        already locked the file.  She spends hours editing the file,
        and when she tries to commit her change, she discovers that
        either the file is locked or that she's out-of-date.
        Regardless, her changes aren't mergeable with Harry's.  One of
        these two people has to throw away their work, and a lot of
        time has been wasted.</para>
      
      <para>Subversion's solution to this problem is provide a
        mechanism to remind users that a file ought to be locked
        <emphasis>before</emphasis> the editing begins.</para>

      <para>The mechanism is a special
        property, <literal>svn:needs-lock</literal>.  If the property
        is attached to a file (the value is irrelevant), then the file
        will have read-only permissions.  When the user locks the file
        and receives a lock token, the file becomes read-write.  When
        the lock is released&mdash;either explicitly unlocked, or
        released via commit&mdash;the file returns to read-only
        again.</para>
      
      <para>The theory, then, is that if the image file has this
        property attached, then Sally would immediately notice
        something is strange when she opens the file for editing.  Her
        application would be unable to save changes, or (better yet)
        tell her that the file is read-only.  This reminds her to lock
        the file before editing, whereby she discovers the
        pre-existing lock:</para>

      <screen>
$ /usr/local/bin/gimp raisin.jpg
gimp: error: file is read-only!

$ ls -l raisin.jpg
-r--r--r--   1 sally   sally   215589 Jun  8 19:23 raisin.jpg

$ svn lock raisin.jpg
svn: Lock request failed: 423 Locked (http://svn.example.com)

$ svn info http://svn.example.com/repos/project/raisin.jpg | grep Lock
Lock Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Lock Owner: harry
Lock Created: 2005-06-08 07:29:18 -0500 (Thu, 08 June 2005)
Lock Comment (1 line):
Making some tweaks.  Locking for the next two hours.

</screen>

        <para>As a matter of <quote>best practice</quote>, both users
          and administrators are encouraged to attach
          the <literal>svn:needs-lock</literal> property to any file
          which cannot be contextually merged.  It's the main
          technique for encouraging good locking habits and preventing
          wasted effort.</para>

        <para>Note that this property is a communication tool which
          works independently from the locking system.  In other
          words, any file can be locked, whether or not this property
          is present.  And conversely, the presence of this property
          doesn't make the repository require a lock when
          committing.</para>

        <para>The system isn't flawless, either.  It's possible that
          even when a file has the property, the read-only reminder
          won't always work.  Sometimes applications misbehave and
          <quote>hijack</quote> the read-only file, silently allowing
          users to edit and save the file anyway.  Unfortunately,
          there's not much Subversion can do about this.</para>

    </sect2>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.pegrevs">
    <title>Peg and Operative Revisions</title>

    <para>We make use of the ability to copy, move, rename, and
      completely replace files and directories on our computers all
      that time.  And your version control system shouldn't get in the
      way of your doing these things with your version controlled
      files and directories, either.  Subversion's file management
      support is quite liberating, affording almost as much
      flexibility for versioned files that you'd expect when
      manipulating your unversioned ones.  But that flexibility means
      that across the lifetime of your repository, a given versioned
      resource might have many paths, and a given path might represent
      several entirely different versioned resources.  And this
      introduces a certain level of complexity to your interactions
      with those paths and resources.</para>

    <para>Subversion is pretty smart about noticing when an object's
      version history includes such <quote>changes of address</quote>.
      For example, if you ask for all the logs of a particular file
      that was renamed last week, Subversion happily provides all
      those logs&mdash;the revision in which the rename itself
      happened, plus the logs of relevant revisions both before and
      after that rename.  So, most of the time, you don't even have to
      think about such things.  But occasionally, Subversion needs
      your help to clear up ambiguities.</para>

    <para>The simplest example of this occurs when a directory or file
      is deleted from version control, and then a new directory or
      file is created with the same name and added to version control.
      Clearly the thing you deleted and the thing you later added
      aren't the same thing, they merely happen to have had the same
      path, which we'll call <filename>/trunk/object</filename>.
      What, then, does it mean to ask Subversion about the history of
      <filename>/trunk/object</filename>?  Are you asking about the
      thing currently at that location, or the old thing you deleted
      from that location?  Are you asking about the operations that
      have happened to all the objects that have lived at that path?
      Clearly, Subversion needs a hint about what you are really
      asking.</para>

    <para>And thanks to moves, versioned resource history can get far
      more twisted than that, even.  For example, you might have a
      directory named <filename>concept</filename>, containing some
      nascent software project you've been toying with.  Eventually,
      though, that project matures to the point that the idea seems to
      actually have some wings, so you do the unthinkable and decide
      to give the project a name.
      <footnote>
        <para><quote>You're not supposed to name it.  Once you name it,
          you start getting attached to it.</quote> &mdash; Mike
          Wazowski</para>
      </footnote>
      Let's say you called your software Frabnaggilywort.  At this
      point, it makes sense to rename the directory to reflect the
      project's new name, so <filename>concept</filename> is renamed
      to <filename>frabnaggilywort</filename>.  Life goes on,
      Frabnaggilywort releases a 1.0 version, and is downloaded and
      used daily by hordes of people aiming to improve their
      lives.</para>
    
    <para>It's a nice story, really, but it doesn't end there.
      Entrepreneur that you are, you've already got another think in
      the tank.  So you make a new directory,
      <filename>concept</filename>, and the cycle begins again.  In
      fact, the cycle begins again many times over the years, each
      time starting with that old <filename>concept</filename>
      directory, then sometimes seeing that directory renamed as the
      idea cures, sometimes seeing it deleted when you scrap the idea.
      Or, to get really sick, maybe you rename
      <filename>concept</filename> to something else for a while, but
      later rename the thing back to <filename>concept</filename> for
      some reason.</para>

    <para>When scenarios like these occur, attempting to instruct
      Subversion to work with these re-used paths can be a little like
      instructing a motorist in Chicago's West Suburbs to drive east
      down Roosevelt Road and turn left onto Main Street.  In a mere
      twenty minutes, you can cross <quote>Main Street</quote> in
      Wheaton, Glen Ellyn, and Lombard.  And no, they aren't the same
      street.  Our motorist&mdash;and our Subversion&mdash;need a
      little more detail in order to do the right thing.</para>

    <para>In version 1.1, Subversion introduced a way for you to tell
      it exactly which Main Street you meant.  It's called the
      <firstterm>peg revision</firstterm>, and it is a revision
      provided to Subversion for the sole purpose of identifying a
      unique line of history.  Because at most one versioned resource
      may occupy a path at any given time&mdash;or, more precisely, in
      any one revision&mdash;the combination of a path and a peg
      revision is all that is needed to refer to a specific line of
      history.  Peg revisions are specified to the Subversion
      command-line client using <firstterm>at syntax</firstterm>, so
      called because the syntax involves appending an <quote>at
      sign</quote> (<literal>@</literal>) and the peg revision to the
      end of the path with which the revision is associated.</para>

    <para>But what of the <option>--revision (-r)</option> of which
      we've spoken so much in this book?  That revision (or set of
      revisions) is called the <firstterm>operative
      revision</firstterm> (or <firstterm>operative revision
      range</firstterm>).  Once a particular line of history has been
      identified using a path and peg revision, Subversion performs
      the requested operation using the operative revision(s).  To map
      this to our Chicagoland streets analogy, if we are told to go to
      606 N. Main Street in Wheaton,
      <footnote>
        <para>606 N. Main Street, Wheaton, Illinois, is the home of
          the Wheaton History Center.  Get it&mdash;<quote>History
          Center</quote>?  It seemed appropriate&hellip;.</para>
      </footnote>
      we can think of <quote>Main Street</quote> as our path and
      <quote>Wheaton</quote> as our peg revision.  These two pieces of
      information identify a unique path which can travelled (north or
      south on Main Street), and will keep us from travelling up and
      down the wrong Main Street in search of our destination.  Now we
      throw in <quote>606 N.</quote> as our operative revision, of
      sorts, and we know <emphasis>exactly</emphasis> where to
      go.</para>

    <sidebar>
      <title>The "peg-revision" algorithm</title>
      
      <para>When the commandline client sees a command of the
        form:</para>

      <screen>
$ svn <replaceable>command</replaceable> -r <replaceable>OPERATIVE-REV</replaceable> item@<replaceable>PEG-REV</replaceable>
</screen>
      
      <para>&hellip;it performs the following algorithm:</para>

      <itemizedlist>
        
        <listitem>
          <para>Go to revision <replaceable>PEG-REV</replaceable>, and
          find <replaceable>item</replaceable>.  This locates a unique
          object in the repository.</para>
        </listitem>

        <listitem>
          <para>Trace the object's history backwards (through any
            possible renames) to its ancestor in
            revision <replaceable>OPERATIVE-REV</replaceable>.</para>
        </listitem>

        <listitem>
          <para>Perform the requested action on that ancestor,
            wherever it is located, or whatever its name might
            be.</para>
        </listitem>

      </itemizedlist>

      <para>Remember that even when you don't explicitly supply a
        peg-revision, it's still present.  It defaults to BASE for
        working copy items, and to HEAD for URLs.</para>
        
    </sidebar>

    <para>Say that long ago we created our repository, and in revision 1
      added our first <filename>concept</filename> directory, plus an
      <filename>IDEA</filename> file in that directory talking about
      the concept.  After several revisions in which real code was
      added and tweaked, we, in revision 20, renamed this directory to
      <filename>frabnaggilywort</filename>.  By revision 27, we had a
      new concept, a new <filename>concept</filename> directory to
      hold it, and a new <filename>IDEA</filename> file to describe
      it.  And then five years and twenty thousand revisions flew by,
      just like they would in any good romance story.</para>

    <para>Now, years later, we wonder what the
      <filename>IDEA</filename> file looked like back in revision 1.
      But Subversion needs to know if we are asking about how the
      <emphasis>current</emphasis> file looked back in revision 1, or
      are we asking for the contents of whatever file lived at
      <filename>concepts/IDEA</filename> in revision 1?  Certainly
      those questions have different answers, and because of peg
      revisions, you can ask either of them.  To find out how the
      current <filename>IDEA</filename> file looked in that old
      revision, you run:</para>

    <screen>
$ svn cat -r 1 concept/IDEA 
subversion/libsvn_client/ra.c:775: (apr_err=20014)
svn: Unable to find repository location for 'concept/IDEA' in revision 1
</screen>

    <para>Of course, in this example, the current
      <filename>IDEA</filename> file didn't exist yet in revision 1,
      so Subversion gives an error.  The command above is shorthand
      for a longer notation which explicitly lists a peg revision.
      The expanded notation is:</para>

    <screen>
$ svn cat -r 1 concept/IDEA@BASE
subversion/libsvn_client/ra.c:775: (apr_err=20014)
svn: Unable to find repository location for 'concept/IDEA' in revision 1
</screen>

    <para>And when executed, it has the expected results.  Peg revisions
      generally default to a value of <literal>BASE</literal> (the
      revision currently present in the working copy) when applied to
      working copy paths, and of <literal>HEAD</literal> when applied
      to URLs.</para>

    <para>Let's ask the other question, then&mdash;in revision 1, what
      were the contents of whatever file occupied the address
      <filename>concepts/IDEA</filename> at the time?  We'll use an
      explicit peg revision to help us out.</para>

    <screen>
$ svn cat concept/IDEA@1
The idea behind this project is to come up with a piece of software
that can frab a naggily wort.  Frabbing naggily worts is tricky
business, and doing it incorrectly can have serious ramifications, so
we need to employ over-the-top input validation and data verification
mechanisms.
</screen>

    <para>This appears to be the right output.  The text even mentions
      frabbing naggily worts, so this is almost certainly the file
      which describes the software now called Frabnaggilywort.  In
      fact, we can verify this using the combination of an explicit
      peg revision and explicit operative revision.  We know that in
      <literal>HEAD</literal>, the Frabnaggilywort project is located
      in the <filename>frabnaggilywort</filename> directory.  So we
      specify that we want to see how the line of history identified
      in <literal>HEAD</literal> as the path
      <filename>frabnaggilywort/IDEA</filename> looked in revision
      1.</para>

    <screen>
$ svn cat -r 1 frabnaggilywort/IDEA@HEAD
The idea behind this project is to come up with a piece of software
that can frab a naggily wort.  Frabbing naggily worts is tricky
business, and doing it incorrectly can have serious ramifications, so
we need to employ over-the-top input validation and data verification
mechanisms.
</screen>

    <para>And the peg and operative revisions need not be so trivial,
      either.  For example, say <filename>frabnaggilywort</filename>
      had been deleted from <literal>HEAD</literal>, but we know it
      existed in revision 20, and we want to see the diffs for its
      <filename>IDEA</filename> file between revisions 4 and 10.  We
      can use the peg revision 20 in conjunction with the URL that
      would have held Frabnaggilywort's <filename>IDEA</filename> file
      in revision 20, and then use 4 and 10 as our operative revision
      range.</para>

    <screen>
$ svn diff -r 4:10 http://svn.red-bean.com/projects/frabnaggilywort/IDEA@20
Index: frabnaggilywort/IDEA
===================================================================
--- frabnaggilywort/IDEA	(revision 4)
+++ frabnaggilywort/IDEA	(revision 10)
@@ -1,5 +1,5 @@
-The idea behind this project is to come up with a piece of software
-that can frab a naggily wort.  Frabbing naggily worts is tricky
-business, and doing it incorrectly can have serious ramifications, so
-we need to employ over-the-top input validation and data verification
-mechanisms.
+The idea behind this project is to come up with a piece of
+client-server software that can remotely frab a naggily wort.
+Frabbing naggily worts is tricky business, and doing it incorrectly
+can have serious ramifications, so we need to employ over-the-top
+input validation and data verification mechanisms.
</screen>

    <para>Fortunately, most folks aren't faced with such complex
      situations.  But when you are, remember that peg revisions are
      that extra hint Subversion needs to clear up ambiguity.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.externals">
    <title>Externals Definitions</title>
    
    <para>Sometimes it is useful to construct a working copy that is
      made out of a number of different checkouts.  For example, you
      may want different subdirectories to come from different
      locations in a repository, or perhaps from different
      repositories altogether.  You could certainly setup such a
      scenario by hand&mdash;using <command>svn checkout</command> to
      create the sort of nested working copy structure you are trying
      to achieve.  But if this layout is important for everyone who
      uses your repository, every other user will need to perform the
      same checkout operations that you did.</para>

    <para>Fortunately, Subversion provides support for
      <firstterm>externals definitions</firstterm>.  An externals
      definition is a mapping of a local directory to the
      URL&mdash;and possibly a particular revision&mdash;of a
      versioned resource.  In Subversion, you declare externals
      definitions in groups using the <literal>svn:externals</literal>
      property.  You can create or modify this property using
      <command>svn propset</command> or <command>svn
      propedit</command> (see <xref linkend="svn.advanced.props.why"/>).  
      It can be set on any versioned directory,
      and its value is a multi-line table of subdirectories (relative
      to the versioned directory on which the property is set) and
      fully qualified, absolute Subversion repository URLs.</para>

    <screen>
$ svn propget svn:externals calc
third-party/sounds             http://sounds.red-bean.com/repos
third-party/skins              http://skins.red-bean.com/repositories/skinproj
third-party/skins/toolkit -r21 http://svn.red-bean.com/repos/skin-maker
</screen>

    <para>The convenience of the <literal>svn:externals</literal>
      property is that once it is set on a versioned directory,
      everyone who checks out a working copy with that directory also
      gets the benefit of the externals definition.  In other words,
      once one person has made the effort to define those nested
      working copy checkouts, no one else has to
      bother&mdash;Subversion will, upon checkout of the original
      working copy, also checkout the external working copies.</para>

    <para>Note the previous externals definition example.  When
      someone checks out a working copy of the
      <filename>calc</filename> directory, Subversion also continues
      to checkout the items found in its externals definition.</para>

    <screen>
$ svn checkout http://svn.example.com/repos/calc
A  calc
A  calc/Makefile
A  calc/integer.c
A  calc/button.c
Checked out revision 148.

Fetching external item into calc/third-party/sounds
A  calc/third-party/sounds/ding.ogg
A  calc/third-party/sounds/dong.ogg
A  calc/third-party/sounds/clang.ogg
&hellip;
A  calc/third-party/sounds/bang.ogg
A  calc/third-party/sounds/twang.ogg
Checked out revision 14.

Fetching external item into calc/third-party/skins
&hellip;
</screen>

    <para>If you need to change the externals definition, you can do
      so using the regular property modification subcommands.  When
      you commit a change to the <literal>svn:externals</literal>
      property, Subversion will synchronize the checked-out items
      against the changed externals definition when you next run
      <command>svn update</command>.  The same thing will happen when
      others update their working copies and receive your changes to
      the externals definition.</para>

    <para>The <command>svn status</command> command also recognizes
      externals definitions, displaying a status code of
      <literal>X</literal> for the disjoint subdirectories into which
      externals are checked out, and then recursing into those
      subdirectories to display the status of the external items
      themselves.</para>

    <tip>
      <para>You should strongly consider using explicit revision
        numbers in all of your externals definitions.  Doing so means
        that you get to decide when to pull down a different snapshot
        of external information, and exactly which snapshot to pull.
        Besides the common sense aspect of not being surprised by
        changes to third-party repositories that you might not have
        any control over, using explicit revision numbers also means
        that as you backdate your working copy to a previous
        revision, your externals definitions will also revert to the
        way they looked in that previous revision, which in turn means
        that the external working copies will be updated to match they
        way <emphasis>they</emphasis> looked back when your repository was
        at that previous revision.  For software projects, this could
        be the difference between a successful and a failed build of
        an older snapshot of your complex codebase.</para>
    </tip>

    <para>The support that exists for externals definitions in
      Subversion today can be a little misleading, though.  First, an
      externals definition can only point to directories, not files.
      Second, the externals definition cannot point to relative paths
      (paths like <filename>../../skins/myskin</filename>).  Third, the
      working copies created via the externals definition support are
      still disconnected from the primary working copy (on whose
      versioned directories the <literal>svn:externals</literal>
      property was actually set).  And Subversion still only truly
      operates on non-disjoint working copies.  So, for example, if
      you want to commit changes that you've made in one or more of
      those external working copies, you must run <command>svn
      commit</command> explicitly on those working
      copies&mdash;committing on the primary working copy will not
      recurse into any external ones.</para>

    <para>Also, since the definitions themselves use absolute URLs,
      moving or copying a directory to which they are attached will
      not affect what gets checked out as an external (though the
      relative local target subdirectory will, of course, move with
      renamed directory).  This can be confusing&mdash;even
      frustrating&mdash;in certain situations.  For example, if you
      use externals definitions on a directory in your
      <filename>/trunk</filename> development line which point to
      other areas of that same line, and then you use <command>svn
      copy</command> to branch that line to some new location
      <filename>/branches/my-branch</filename>, the externals
      definitions on items in your new branch will still refer to
      versioned resources in <filename>/trunk</filename>.  Be aware,
      too, that if you need to re-parent your working copy (using
      <command>svn switch --relocate</command>), externals definitions
      will <emphasis>not</emphasis> also be re-parented.</para>

    <para>Finally, there might be times when you would prefer that
      <command>svn</command> subcommands would not recognize or
      otherwise operate on the external working copies created as the
      result of externals definition handling.  In those instances,
      you can pass the <option>--ignore-externals</option> option to
      the subcommand.</para>
  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
vim: set ft=svnbook :
-->
