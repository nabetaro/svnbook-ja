<chapter id="svn.serverconfig">
  <!-- @ENGLISH {{{
  <title>Server Configuration</title>
  @ENGLISH }}} -->
  <title>&Server;konfigurasjon</title>
  
  <simplesect>
    
    <!-- @ENGLISH {{{
    <para>A Subversion repository can be accessed simultaneously by
      clients running on the same machine on which the repository
      resides using the <literal>file:///</literal> method.  But the
      typical Subversion setup involves a single server machine being
      accessed from clients on computers all over the office&mdash;or,
      perhaps, all over the world.</para>
    @ENGLISH }}} -->
    <para>Et Subversiondepot kan bli aksessert samtidig av klienter som 
      kjører på den samme maskinen der depotet ligger ved å bruke 
      <literal>file:///</literal>-metoden.
      Men det typiske Subversionoppsettet involverer en enkelt 
      &server;maskin som blir aksessert fra klienter på maskiner over 
      hele kontoret – eller kanskje over hele verden.</para>

    
    <!-- @ENGLISH {{{
    <para>This section describes how to get your Subversion repository
      exposed outside its host machine for use by remote clients.  We
      will cover Subversion's currently available server mechanisms,
      discussing the configuration and use of each.  After reading
      this section, you should be able to decide which networking
      setup is right for your needs, and understand how to enable such
      a setup on your host computer.</para>
    @ENGLISH }}} -->
    <para>Denne seksjonen beskriver hvordan du kan <!-- ¤ 
      -->offentliggjøre Subversiondepotet ditt utenfor &server;maskinen 
      så fjerntliggende klienter kan bruke det.
      Vi vil dekke &server;mekanismene som Subversion har tilgjengelig 
      og diskutere konfigurasjonen og bruken av hver av disse.
      Etter å ha lest denne seksjonen vil du være i stand til å avgjøre 
      hvilket nettverksoppsett som er det riktige for dine behov, og 
      forstå hvordan du skal sette dette opp på &server;maskinen.</para>
    
  </simplesect>
  
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.overview">
    
    <!-- @ENGLISH {{{
    <title>Overview</title>
    @ENGLISH }}} -->
    <title>Oversikt</title>
    
    <!-- @ENGLISH {{{
    <para>Subversion was designed with an abstract network layer.
      This means that a repository can be programmatically accessed by
      any sort of server process, and the client <quote>repository
      access</quote> API allows programmers to write plugins that
      speak relevant network protocols.  In theory, Subversion can use
      an infinite number of network implementations.  In practice,
      there are only two servers at the time of writing.</para>
    @ENGLISH }}} -->
    <para>Subversion ble designet med et abstrakt nettverkslag.
      Dette betyr at et depot kan bli <!-- ¤ programmatically --> 
      aksessert av enhver form for &server;prosess, og klientens API for 
      depottilgangen gir programmerere anledning til å lage 
      programtillegg som forstår relevante nettverksprotokoller.
      I teorien kan Subversion bruke et uendelig antall 
      nettverksimplementasjoner.
      I praksis er det for tiden bare to &server;modeller 
      tilgjengelig.</para>
    
    <!-- @ENGLISH {{{
    <para>Apache is an extremely popular webserver; using the
      <command>mod_dav_svn</command> module, Apache can access a
      repository and make it available to clients via the WebDAV/DeltaV
      protocol, which is an extension of HTTP.  In the other corner is
      <command>svnserve</command>: a small, standalone server
      program that speaks a custom protocol with clients.  Table 6-1
      presents a comparison of the two servers.</para>
    @ENGLISH }}} -->
    <para>Apache er en ekstremt populær web&server;. Ved å bruke 
      <command>mod_dav_svn</command>-modulen kan Apache aksessere et 
      depot og gjøre det tilgjengelig for klienter via 
      WebDAV/DeltaV-protokollen, som er en utvidelse av HTTP.
      I det andre hjørnet er <command>svnserve</command>:
      Et lite, enkeltstående &server;program som kommuniserer med 
      klientene ved hjelp av en egendefinert protokoll.
      Tabell 6-1 viser en sammenligning av de to 
      &server;modellene.</para>

    <!-- @ENGLISH {{{
    <para>Note that Subversion, as an open-source project, does not
      officially endorse any server as <quote>primary</quote> or
      <quote>official</quote>.  Neither network implementation is
      treated as a second-class citizen; each server has advantages
      and disadvantages.  In fact, it's possible for different servers
      to run in parallel, each accessing your repositories in its own
      way, and each without hindering the other (see <xref
      linkend="svn.serverconfig.multimethod"/>).  <xref
      linkend="svn.serverconfig.overview.tbl-1"/> gives a brief overview and
      comparison of the two available Subversion servers&mdash;as an
      administrator, it's up to you to choose whatever works best for
      you and your users.</para>
    @ENGLISH }}} -->
    <para>Legg merke til at Subversion, som et opensourceprosjekt, ikke 
      erklærer noen &server;modeller som <quote>primær</quote> eller 
      <quote>offisiell</quote>.
      Ingen nettverksimplementasjoner blir sett på som andreklasses 
      borgere; hver &server;modell har fordeler og ulemeper.
      Faktisk er det mulig for forskjellige &servers; å kjøre parallelt 
      og aksessere depotet på hver sin måte uten å legge hindringer i 
      veien for den andre (se <xref 
      linkend="svn.serverconfig.multimethod"/>).
      <xref
      linkend="svn.serverconfig.overview.tbl-1"/> inneholder en kort 
      oversikt og sammenligning av de to tilgjengelige 
      Subversion&the_servers; – som en administrator er det opp til deg 
      å velge hva som fungerer best for deg og dine brukere.</para>
      

    <table id="svn.serverconfig.overview.tbl-1">
      <!-- @ENGLISH {{{
      <title>Network Server Comparison</title>
      @ENGLISH }}} -->
      <title>Sammenligning av nettverks&servers;</title>
      <tgroup cols="3">
        <thead>
          <row>
            <!-- @ENGLISH {{{
            <entry>Feature</entry>
            @ENGLISH }}} -->
            <entry>Funksjonalitet</entry>
            <entry>Apache + mod_dav_svn</entry>
            <entry>svnserve</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <!-- @ENGLISH {{{
            <entry>Authentication options</entry>
            
            <entry>HTTP(S) basic auth, X.509 certificates, LDAP, NTLM, or
              any other mechanism available to Apache httpd</entry>
            
            <entry>CRAM-MD5 or SSH</entry>
            @ENGLISH }}} -->
            <entry>Autentiseringsvalg</entry>

            <entry>vanlig HTTP(S)-autentisering, X.509-sertifikater, 
              LDAP, NTLM eller enhver annen mekaniske som er 
              tilgjengelig for Apache httpd</entry>

            <entry>CRAM-MD5 eller SSH</entry>
          </row>
          
          <row>
            <!-- @ENGLISH {{{
            <entry>User account options</entry>
            
            <entry>private 'users' file</entry>
            
            <entry>private 'users' file, or existing system (SSH)
              accounts</entry>
            @ENGLISH }}} -->
            <entry>Valg for brukerkontoer</entry>

            <entry>privat fil med brukerliste</entry>

            <entry>privat fil med brukerliste eller eksisterende 
              systemkontoer (SSH)</entry>
          </row>
          
          <row>
            <!-- @ENGLISH {{{
            <entry>Authorization options</entry>
            
            <entry>blanket read/write access, or per-directory
              read/write control</entry>
            
            <entry>blanket read/write access, or per-directory write
              (but not read) control using a pre-commit hook</entry>
            @ENGLISH }}} -->
            <entry>Autorisasjonsvalg</entry>

            <entry>fullstendig lese/skrivetilgang, eller katalogbasert 
              lese/skrivekontroll</entry>

            <entry>fullstendig lese/skrivetilgang, eller katalogbasert 
              skrive- (men ikke lesing) kontroll ved å bruke et 
              <filename>pre-commit</filename>-påhakningsskript</entry>
          </row>
          
          <row>
            <!-- @ENGLISH {{{
            <entry>Encryption</entry>
            
            <entry>via optional SSL</entry>

            <entry>via optional SSH tunnel</entry>
            @ENGLISH }}} -->
            <entry>Kryptering</entry>

            <entry>via valgfri SSL</entry>

            <entry>via valgfri SSH-tunnel</entry>
          </row>

          <row>
            <!-- @ENGLISH {{{
            <entry>Interoperability</entry>
            
            <entry>partially usable by other WebDAV clients</entry>

            <entry>not interoperable</entry>
            @ENGLISH }}} -->
            <entry><!-- ¤ Det lukter dress og slips av det ordet der. Og 
              det er vel et ganske oppkonstruert ord. Men hvilket norskt 
              dataord er vel ikke det? :) -->Interoperabilitet</entry>

            <entry>delvis brukbar for andre WebDAV-klienter</entry>

            <entry><!-- ¤ -->Ikke tilgjengelig</entry>
          </row>

          <row>
            <!-- @ENGLISH {{{
            <entry>Web viewing</entry>
            
            <entry>limited built-in support, or via 3rd-party tools
              such as ViewVC</entry>

            <entry>via 3rd-party tools such as ViewVC</entry>
            @ENGLISH }}} -->
            <entry>Visning på web</entry>

            <entry>begrenset innebygget støtte, eller via tredjeparts 
              verktøy som for eksempel ViewVC</entry>

            <entry>via tredjeparts verktøy som for eksempel 
              ViewVC</entry>
          </row>

          <row>
            <!-- @ENGLISH {{{
            <entry>Speed</entry>
            
            <entry>somewhat slower</entry>

            <entry>somewhat faster</entry>
            @ENGLISH }}} -->
            <entry>Hastighet</entry>

            <entry>Noe langsommere</entry>

            <entry>Noe raskere</entry>
          </row>

          <row>
            <!-- @ENGLISH {{{
            <entry>Initial setup</entry>
            
            <entry>somewhat complex</entry>

            <entry>fairly simple</entry>
            @ENGLISH }}} -->
            <entry>Innledende oppsett</entry>

            <entry>Noe komplekst</entry>

            <entry>Ganske enkelt</entry>
          </row>

        </tbody>
      </tgroup>      
    </table>
    
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.netmodel">

    <!-- @ENGLISH {{{
    <title>Network Model</title>
    @ENGLISH }}} -->
    <title>Nettverksmodellen</title>

    <!-- @ENGLISH {{{
    <para>This section is a general discussion of how a Subversion
      client and server interact with one another, regardless of the
      network implementation you're using.  After reading, you'll have
      a good understanding of how a server can behave and the
      different ways in which a client can be configured to
      respond.</para>
    @ENGLISH }}} -->
    <para>Denne seksjonen er en generell diskusjon om hvordan en 
      Subversionklient og -&server; kommuniserer med hverandre, 
      uavhengig av hvilken nettverksimplementasjon du bruker.
      Etter å ha lest dette vil du ha en god forståelse av hvordan en 
      &server; kan oppføre seg og de forskjellige måtene en klient kan 
      settes opp til å svare.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.netmodel.reqresp">
      <!-- @ENGLISH {{{
      <title>Requests and Responses</title>
      @ENGLISH }}} -->
      <title>Forespørsler og reponser</title>

      <!-- @ENGLISH {{{
      <para>The Subversion client spends most of its time managing
        working copies.  When it needs information from a repository,
        however, it makes a network request, and the server responds
        with an appropriate answer.  The details of the network
        protocol are hidden from the user; the client attempts to
        access a URL, and depending on the URL schema, a particular
        protocol is used to contact the server (see <xref
        linkend="svn.basic.in-action.wc.sb-1"/>).  Users can run <command>svn
        -&#64738;-version</command> to see which URL schemas and protocols the
        client knows how to use.</para>
      @ENGLISH }}} -->
      <para>Subversionklienten bruker mesteparten av tiden til å 
        behandle arbeidskopier.
        Men når den trenger informasjon fra et depot foretar den en 
        nettverksforespørsel og &the_server; kommer med et passende 
        svar.
        Detaljene i nettverksprotokollen er skjult for brukeren; 
        klienten prøver å aksessere en URL, og alt etter hvilket 
        URL-skjema som brukes blir en passende protokoll brukt for å 
        aksessere &the_server; (se <xref 
        linkend="svn.basic.in-action.wc.sb-1"/>).
        Brukere kan kjøre <command>svn --version</command> for å se 
        hvilke URL-skjema og protokoller klienten kan bruke.</para>

      <!-- @ENGLISH {{{
      <para>When the server process receives a client request, it
        typically demands that the client identify itself.  It issues
        an authentication challenge to the client, and the client
        responds by providing <firstterm>credentials</firstterm> back
        to the server.  Once authentication is complete, the server
        responds with the original information the client asked for.
        Notice that this system is different from systems like CVS,
        where the client pre-emptively offers credentials (<quote>logs
        in</quote>) to the server before ever making a request.  In
        Subversion, the server <quote>pulls</quote> credentials by
        challenging the client at the appropriate moment, rather than
        the client <quote>pushing</quote> them.  This makes certain
        operations more elegant.  For example, if a server is
        configured to allow anyone in the world to read a repository,
        then the server will never issue an authentication challenge
        when a client attempts to <command>svn
        checkout</command>.</para>
      @ENGLISH }}} -->
      <para>Når &the_server; mottar en klientforespørsel, forlanger den 
        vanligvis at klienten identifiserer seg.
        Den utsteder en autentiseringsforespørsel til klienten, og 
        klienten svarer ved å <firstterm>legitimere</firstterm> seg 
        ovenfor &the_server;.
        Når autentiseringen er komplett, svarer &the_server; med den 
        originale informasjonen klienten spurte etter.
        Legg merke til at dette systemet er forskjellig fra systemer som 
        CVS, hvor klienten på forhånd oppgir legitimasjon (<quote>logger 
        inn</quote>) til &the_server; før noen forespørsel etter 
        informasjon blir gjort.
        I Subversion <quote>henter</quote> &the_server; legitimasjonen 
        ved å kontrollere klienten på det nødvendige tidspunktet i 
        stedet for at klienten uoppfordret <quote>leverer</quote> den.
        Dette gjør visse operasjoner mer elegant.
        For eksempel, hvis en &server; er konfigurert til å la alle i 
        hele verden få lese depotet, vil &the_server; aldri be om 
        autentisering når klienten prøver en <command>svn 
        checkout</command>.</para>

      <!-- @ENGLISH {{{
      <para>If the client's network request writes new data to the
        repository (e.g. <command>svn commit</command>), then a new
        revision tree is created.  If the client's request was
        authenticated, then the authenticated user's name is stored as
        the value of the <literal>svn:author</literal> property on the
        new revision (see <xref linkend="svn.reposadmin.basics.revprops"/>).  If
        the client was not authenticated (in other words, the server
        never issued an authentication challenge), then the revision's
        <literal>svn:author</literal> property is empty.
        <footnote><para>This problem is actually a FAQ, resulting from
        a misconfigured server setup.</para></footnote></para>
      @ENGLISH }}} -->
      <para>Hvis klientens nettverksforespørsel skriver nye data til 
        depotet (for eksempel <command>svn commit</command>), vil et 
        nytt revisjonstre bli opprettet.
        Hvis klientens forespøsel ble autentisert, blir brukernavnet til 
        den autentiserte brukeren lagret i 
        <literal>svn:author</literal>-egenskapen i den nye revisjonen 
        (se <xref linkend="svn.reposadmin.basics.revprops"/>).
        Hvis klienten ikke ble autentisert (med andre ord, &the_server; 
        spurte ikke etter legitimasjon), er revisjonens 
        <literal>svn:author</literal>-egenskap tom.<footnote>
          <para>Dette er egentlig et spørsmål som ofte dukker opp som et 
            resultat av feil i konfigurasjonen på &the_server;.</para>
        </footnote></para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.netmodel.credcache">
      <!-- @ENGLISH {{{
      <title>Client Credentials Caching</title>
      @ENGLISH }}} -->
      <title>Lagring av klientlegitimasjon</title>

      <!-- @ENGLISH {{{
      <para>Many servers are configured to require authentication on
        every request.  This can become a big annoyance to users, who
        are forced to type their passwords over and over again.</para>
      @ENGLISH }}} -->
      <para>Mange &servers; er satt opp til å forlange autentisering for 
        hver eneste forespørsel.
        Dette kan bli et stort irrtasjonsmoment for brukerne, som blir 
        tvunget til å skrive passordet om og om igjen.</para>

      <!-- @ENGLISH {{{
      <para>Happily, the Subversion client has a remedy for this: a
        built-in system for caching authentication credentials on
        disk.  By default, whenever the command-line client
        successfully authenticates itself to a server, it saves the
        credentials in the user's private runtime configuration
        area&mdash;in <filename>~/.subversion/auth/</filename> on
        Unix-like systems or
        <filename>%APPDATA%/Subversion/auth/</filename> on Windows.
        (The runtime area is covered in more detail in <xref
        linkend="svn.advanced.confarea"/>.)  Successful credentials are
        cached on disk, keyed on a combination of hostname, port, and
        authentication realm.</para>  
      @ENGLISH }}} -->
      <para>Heldigvis har Subversion en løsning på dette:
        Et innebygget system for å lagre legitimasjonen på disk.
        Normalt sett, når kommandolinjeklienten klarer å legitimere seg 
        ovenfor en &server;, lagres denne legitimasjonsinformasjonen i 
        brukerens private <!-- ¤ runtime -->konfigurasjonsområde – i 
        <filename>~/.subversion/auth/</filename> på Unix-lignende 
        systemer eller <filename>%APPDATA%/Subversion/auth/</filename> i 
        Windows.
        (<!-- ¤ runtime igjen – fellesordlista til Skolelinux oversetter 
        dette med «kjøretid», men … vel. I dette tilfellet passer det 
        vel bedre å ikke ha det med. -->Konfigurasjonsområdet er dekket 
        mer inngående i <xref linkend="svn.advanced.confarea"/>.)
        Data fra vellykkede autentiseringer lagres på disken, der 
        nøkkelen er en kombinasjon av &server;navn, port og området der 
        autentiseringen gjelder.</para>

      <!-- @ENGLISH {{{
      <para>When the client receives an authentication challenge, it
        first looks for the appropriate credentials in the disk cache;
        if not present, or if the cached credentials fail to
        authenticate, then the client simply prompts the user for the
        information.</para>
      @ENGLISH }}} -->
      <para>Når klienten må gjennom en autentiseringsprosess, ser den 
        først etter passende legitimasjonsdata i lageret på disken.
        Hvis dette ikke finnes, eller de lagrede legitimasjonsdataene 
        ikke er tilstrekkelig for å fullføre autentiseringen, spør 
        klienten ganske enkelt brukeren etter informasjonen.</para>

      <!-- @ENGLISH {{{
      <para>Security-conscious people may be thinking to themselves,
        <quote>Caching passwords on disk?  That's terrible!  You
        should never do that!</quote> Please remain calm, it's not as
        dangerous as it sounds.</para>
      @ENGLISH }}} -->
      <para>Sikkerhetsbevisste folk tenker nok med seg selv:
        <quote>Lagre passord på disken?
        Det er forferdelig!
        Sånt skal aldri gjøres!</quote>
        Men ta det med ro, det er ikke så farlig som det høres 
        ut.</para>

      <itemizedlist>

        <listitem>
          <!-- @ENGLISH {{{
          <para>The <filename>auth/</filename> caching area is
            permission-protected so that only the user (owner) can
            read data from it, not the world at large.  The operating
            system's own file permissions are protecting the
            password.</para>
          @ENGLISH }}} -->
          <para>Lagringsområdet i <filename>auth/</filename> er 
            beskyttet av rettigheter så bare brukeren (eieren) kan lese 
            dataene derfra, ikke resten av verden.
            Operativsystemets egne filrettigheter beskytter 
            passordet.</para>
        </listitem>

        <listitem>
          <!-- @ENGLISH {{{
          <para>On Windows 2000 and later, the Subversion client uses
            standard Windows cryptography services to encrypt the
            password on disk.  Because the encryption key is managed
            by Windows and is tied to the user's own login
            credentials, only the user can decrypt the cached
            password.  (Note: if the user's Windows account
            password is changed, all of the cached passwords become
            undecipherable.  The Subversion client will behave as if
            they don't exist, prompting for passwords when
            required.)</para>
          @ENGLISH }}} -->
          <para>På Windows 2000 og senere bruker Subversionklienten 
            standard kryptografitjenester i Windows for å kryptere 
            passordet på disken.
            Fordi krypteringsnøkkelen blir vedlikeholdt av Windows og 
            den er forbundet med brukerens egne <!-- ¤ credentials 
            -->innloggingsbrukerdata, kan bare brukeren dekryptere det 
            lagrede passordet.
            (Merk:
            Hvis brukerens passord i Windows blir forandret, kan ikke de 
            lagrede passordene dekrypteres.
            Subversionklienten vil oppføre seg som om de ikke eksisterer 
            og spørre etter passord når det er nødvendig.)</para>
        </listitem>

        <listitem>
          <!-- @ENGLISH {{{
          <para>For the truly paranoid willing to sacrifice all
            convenience, it's possible to disable credential caching
            altogether.</para>
          @ENGLISH }}} -->
          <para>For den sanne paranoide som er villig til å ofre alle 
            behageligheter, er det mulig å deaktivere all lagring av 
            <!-- ¤ credential igjen. Men egentlig går vel dette? 
            -->innloggingsdata.</para>
        </listitem>

      </itemizedlist>

      <!-- @ENGLISH {{{
      <para>To disable caching for a single command, pass the
        <option>-&#64738;-no-auth-cache</option> option:</para>
      @ENGLISH }}} -->
      <para>For å forhindre lagring for en enkelt kommando, spesifiser 
        valget <option>--no-auth-cache</option>:</para>

      <!-- @ENGLISH {{{
      <screen>
$ svn commit -F log_msg.txt -&#64738;-no-auth-cache
Authentication realm: &lt;svn://host.example.com:3690&gt; example realm
Username:  joe
Password for 'joe':

Adding         newfile
Transmitting file data .
Committed revision 2324.

# password was not cached, so a second commit still prompts us

$ svn delete newfile
$ svn commit -F new_msg.txt
Authentication realm: &lt;svn://host.example.com:3690&gt; example realm
Username:  joe
&hellip;
</screen>
      @ENGLISH }}} -->
      <!-- ¤ --><screen>
$ svn commit -F log_msg.txt --no-auth-cache
Authentication realm: &lt;svn://host.example.com:3690&gt; example realm
Username:  joe
Password for 'joe':

Adding         newfile
Transmitting file data .
Committed revision 2324.

# Passordet ble ikke lagret, så ved neste innlegging blir vi spurt på 
# nytt.

$ svn delete newfile
$ svn commit -F new_msg.txt
Authentication realm: &lt;svn://host.example.com:3690&gt; example realm
Username:  joe
…
</screen>

      <!-- @ENGLISH {{{
      <para>Or, if you want to disable credential caching permanently,
        you can edit your runtime <filename>config</filename> file
        (located next to the <filename>auth/</filename> directory).
        Simply set <literal>store-auth-creds</literal> to
        <literal>no</literal>, and no credentials will be cached on
        disk, ever.</para>
      @ENGLISH }}} -->
      <para>Eller, hvis du vil slå av lagring av legitimasjonen 
        permanent, kan du redigere <filename>config</filename>-filen 
        (plassert ved siden av <filename>auth/</filename>-katalogen).
        Ved å sette <literal>store-auth-creds</literal> til 
        <literal>no</literal> vil ingen legitimasjon bli lagret på 
        disken i det hele tatt.</para>

      <screen>
[auth]
store-auth-creds = no
</screen>

      <!-- @ENGLISH {{{
      <para>Sometimes users will want to remove specific credentials
        from the disk cache.  To do this, you need to navigate into
        the <filename>auth/</filename> area and manually delete the
        appropriate cache file.  Credentials are cached in individual
        files;  if you look inside each file, you will see keys and
        values.  The <literal>svn:realmstring</literal> key describes
        the particular server realm that the file is associated
        with:</para>
      @ENGLISH }}} -->
      <para>Noen ganger vil brukere ønske å fjerne spesifikke 
        legitimasjonsdata fra disklageret.
        For å gjøre dette, må du gå inn i 
        <filename>auth/</filename>-området og manuelt slette den 
        aktuelle filen.
        Legitimasjonen er lagret i individuelle filer, og hvis du ser på 
        hver fil, vil du se nøkler og verdier.
        <literal>svn:realmstring</literal>-nøkkelen viser hvilket 
        &server;område filen er assosiert med:</para>

      <screen>
$ ls ~/.subversion/auth/svn.simple/
5671adf2865e267db74f09ba6f872c28        
3893ed123b39500bca8a0b382839198e
5c3c22968347b390f349ff340196ed39

$ cat ~/.subversion/auth/svn.simple/5671adf2865e267db74f09ba6f872c28

K 8
username
V 3
joe
K 8
password
V 4
blah
K 15
svn:realmstring
V 45
&lt;https://svn.domain.com:443&gt; Joe's repository
END
</screen>

      <!-- @ENGLISH {{{
      <para>Once you have located the proper cache file, just delete
        it.</para>
      @ENGLISH }}} -->
      <para>Når du har funnet den riktige filen, er det bare å slette 
        den.</para>

      <!-- @ENGLISH {{{
      <para>One last word about client authentication behavior: a bit
        of explanation about the <option>-&#64738;-username</option> and
        <option>-&#64738;-password</option> options is needed.  Many client
        subcommands accept these options; however it is important to
        understand using these options <emphasis>does not</emphasis>
        automatically send credentials to the server.  As discussed
        earlier, the server <quote>pulls</quote> credentials from the
        client when it deems necessary; the client cannot
        <quote>push</quote> them at will.  If a username and/or
        password are passed as options, they will
        <emphasis>only</emphasis> be presented to the server if the
        server requests them.

         <footnote><para>Again, a common mistake is to misconfigure a
           server so that it never issues an authentication challenge.
           When users pass <option>-&#64738;-username</option> and
           <option>-&#64738;-password</option> options to the client,
           they're surprised to see that they're never used, i.e. new
           revisions still appear to have been committed
           anonymously!</para></footnote>
        
        Typically, these options are used when:</para>
      @ENGLISH }}} -->
      <para>Et siste ord om oppførselen under klientautentisering, en 
        liten forklaring angående <option>--username</option> og 
        <option>--password</option> er på sin plass.
        Mange delkommandoer for klienten godtar disse valgene, men det 
        er viktig å forstå at bruken av disse valgene sender 
        <emphasis>ikke</emphasis> brukerdata til &the_server;.
        Som tidligere nevnt, <quote>henter</quote> &the_server; 
        brukerdata fra klienten når det er nødvendig; klienten kan ikke 
        <quote>levere</quote> dataene når den vil.
        Hvis et brukernavn og/eller passord blir spesifisert som valg, 
        vil de <emphasis>bare</emphasis> bli gitt til &the_server; hvis 
        &the_server; spør etter dem.<footnote>
          <para>Som sagt, en vanlig feil er å feilkonfigurere 
            &the_server; så den aldri spør etter autentiseringsinfo.
            Når brukere angir <option>--username</option> og 
            <option>--password</option> til klienten, blir de overrasket 
            over å se at dataene aldri blir brukt og at nye revisjoner 
            fortsatt ser ut til å ha blitt lagt inn anonymt!</para>
        </footnote>
        Vanligvis blir disse valgene brukt når:</para>

      <itemizedlist>
        <listitem>
          <!-- @ENGLISH {{{
          <para>the user wants to authenticate as a different user
            than her system login name, or</para>
          @ENGLISH }}} -->
          <para>brukeren vil identifisere seg som en annen bruker enn 
            brukernavnet på systemet, eller</para>
        </listitem>
        <listitem>
          <!-- @ENGLISH {{{
          <para>a script wants to authenticate without using cached
            credentials.</para>
          @ENGLISH }}} -->
          <para>et skript vil identifisere seg uten å bruke lagrede 
            brukerdata.</para>
        </listitem>
      </itemizedlist>
          

      <!-- @ENGLISH {{{
      <para>Here is a final summary that describes how a Subversion
        client behaves when it receives an authentication
        challenge:</para>
      @ENGLISH }}} -->
      <para>Her er en avsluttende oversikt som beskriver hvordan en 
        Subversionklient oppfører seg når den mottar en 
        autentiseringsutfordring:</para>

      <orderedlist>
        <listitem>
          <!-- @ENGLISH {{{
          <para>Check whether the user specified any credentials as
            command-line options, via <option>-&#64738;-username</option>
            and/or <option>-&#64738;-password</option>.  If not, or if these
            options fail to authenticate successfully, then</para>
          @ENGLISH }}} -->
          <para>Sjekk om brukeren spesifiserte noen brukerdata som 
            kommandolinjevalg med <option>--username</option> og/eller 
            <option>--password</option>.
            Hvis ikke, eller hvis disse valgene ikke er i stand til å 
            fullføre autentiseringen,</para>
        </listitem>

        <listitem>
          <!-- @ENGLISH {{{
          <para>Look up the server's realm in the runtime
            <filename>auth/</filename> area, to see if the user already
            has the appropriate credentials cached.  If not, or if the
            cached credentials fail to authenticate, then</para>
          @ENGLISH }}} -->
          <para>Let opp &the_server;s område i 
            <filename>auth/</filename>-området for å se om brukeren 
            allerede har lagret de nødvendige identifikasjonsdataene.
            Hvis ikke, eller hvis de lagrede brukerdataene ikke er 
            tilstrekkelig for å autentisere,</para>
        </listitem>

        <listitem>
          <!-- @ENGLISH {{{
          <para>Resort to prompting the user.</para>
          @ENGLISH }}} -->
          <para>Spør brukeren.</para>
        </listitem>
      </orderedlist>

      <!-- @ENGLISH {{{
      <para>If the client successfully authenticates by any of the
        methods listed above, it will attempt to cache the credentials
        on disk (unless the user has disabled this behavior, as
        mentioned earlier).</para>
      @ENGLISH }}} -->
      <para>Hvis klienten klarer å legitimere seg ved hjelp av noen av 
        metodene nevnt ovenfor, vil den prøve å lagre brukerdataene på 
        disken (unntatt hvis brukeren har slått av denne oppførselen, 
        som tidligere nevnt).</para>

    </sect2>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.svnserve">
    
    <!-- @ENGLISH {{{
    <title>svnserve, a custom server</title>
    @ENGLISH }}} -->
    <title>svnserve, en tilpasset &server;</title>

    <!-- @ENGLISH {{{
    <para>The <command>svnserve</command> program is a lightweight
      server, capable of speaking to clients over TCP/IP using a
      custom, stateful protocol.  Clients contact an
      <command>svnserve</command> server by using URLs that begin with
      the <literal>svn://</literal> or <literal>svn+ssh://</literal>
      schema.  This section will explain the different ways of running
      <command>svnserve</command>, how clients authenticate themselves
      to the server, and how to configure appropriate access control
      to your repositories.</para>
    @ENGLISH }}} -->
    <para>Programmet <command>svnserve</command> er en lettvekts&server; 
    som er i stand til å snakke med klienter over TCP/IP ved å bruke en 
    tilpasset, <!-- ¤ --><foreignphrase>stateful</foreignphrase> 
    protokoll.
      Klienter kontakter en <command>svnserve</command>-&server; ved å 
      bruke URL-er som begynner med <literal>svn://</literal>- eller 
      <literal>svn+ssh://</literal>-skjemaet.
      Denne seksjonen vil forklare de forskjellige måtene å kjøre 
      <command>svnserve</command> på, hvordan klienter autentiserer seg 
      selv ovenfor &the_server;, og hvordan du setter opp en passende 
      adgangskontroll til depotene dine.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.invoking">
      <!-- @ENGLISH {{{
      <title>Invoking the Server</title>
      @ENGLISH }}} -->
      <title>Starte &the_server;</title>

      <!-- @ENGLISH {{{
      <para>There are a few different ways to invoke the
        <command>svnserve</command> program.  If invoked with no
        options, you'll see nothing but a help message.  However, if
        you're planning to have <command>inetd</command> launch the
        process, then you can pass the <option>-i</option>
        (<option>-&#64738;-inetd</option>) option:</para>
      @ENGLISH }}} -->
      <para>Det er forskjellige måter å starte 
        <command>svnserve</command>-programmet.
        Hvis det kjøres uten noen valg, vil du bare se en hjelpemelding.
        Hvis du planlegger å la <command>inetd</command> starte 
        prosessen, kan du angi valget <option>-i</option> 
        (<option>--inetd</option>):</para>

      <screen>
$ svnserve -i
( success ( 1 2 ( ANONYMOUS ) ( edit-pipeline ) ) )
</screen>

      <!-- @ENGLISH {{{
      <para>When invoked with the <option>-&#64738;-inetd</option> option,
        <command>svnserve</command> attempts to speak with a
        Subversion client via <emphasis>stdin</emphasis> and
        <emphasis>stdout</emphasis> using a custom protocol.  This is
        the standard behavior for a program being run via
        <command>inetd</command>.  The IANA has reserved port 3690
        for the Subversion protocol, so on a Unix-like system you can
        add lines to <filename>/etc/services</filename> like these (if
        they don't already exist):</para>
      @ENGLISH }}} -->
      <para>Når programmet blir startet med 
        <option>--inetd</option>-valget, prøver 
        <command>svnserve</command> å snakke med en Subversionklient via 
        <emphasis>standard inn</emphasis> og <emphasis>standard 
        ut</emphasis> ved å bruke en tilpasset protokoll.
        Dette er den vanlige oppførselen for et program som blir kjørt 
        via <command>inetd</command>.
        IANA har reservert port 3690 for Subversionprotokollen, så på et 
        Unix-lignende system kan du legge til linjer som dette i 
        <filename>/etc/services</filename> (hvis de ikke allerede 
        eksisterer):</para>

      <screen>
svn           3690/tcp   # Subversion
svn           3690/udp   # Subversion
</screen>

      <!-- @ENGLISH {{{
      <para>And if your system is using a classic Unix-like
        <command>inetd</command> daemon, you can add this line to
        <filename>/etc/inetd.conf</filename>:</para>
      @ENGLISH }}} -->
      <para>Og hvis systemet ditt bruker en klassisk Unix-lignende 
        <command>inetd</command>-daemon, kan du legge denne linjen til 
        <filename>/etc/inetd.conf</filename>:</para>

      <!-- @ENGLISH {{{
      <screen>
svn stream tcp nowait svnowner /usr/bin/svnserve svnserve -i
</screen>
      @ENGLISH }}} -->
      <screen>
svn stream tcp nowait svnbruker /usr/bin/svnserve svnserve -i
</screen>

      <!-- @ENGLISH {{{
      <para>Make sure <quote>svnowner</quote> is a user which has
        appropriate permissions to access your repositories.  Now, when
        a client connection comes into your server on port 3690,
        <command>inetd</command> will spawn an
        <command>svnserve</command> process to service it.</para>
      @ENGLISH }}} -->
      <para>Pass på at <quote>svnbruker</quote> er en bruker som har 
        tilstrekkelige rettigheter til å få tilgang til depotene dine.
        Når nå en klientforbindelse kommer inn til &the_server; på port 
        3690, vil <command>inetd</command> starte en egen 
        <command>svnserve</command>-prosess for å ta seg av den.</para>

      <!-- @ENGLISH {{{
      <para>On a Windows system, third-party tools exist to run
      <command>svnserve</command> as a service.  Look on Subversion's
      website for a list of these tools.</para>
      @ENGLISH }}} -->
      <para>På et MS Windows-system finnes det tredjeparts verktøy for å 
        kjøre <command>svnserve</command> som en tjeneste.
        Se på Subversions hjemmeside for en liste over disse 
        verktøyene.</para>

      <!-- @ENGLISH {{{
      <para>A second option is to run <command>svnserve</command> as a
        standalone <quote>daemon</quote> process.  Use the
        <option>-d</option> option for this:</para>
      @ENGLISH }}} -->
      <para>En annen måte er å kjøre <command>svnserve</command> som en 
        selvstendig <quote>daemon</quote>-prosess.
        Bruk <option>-d</option>-valget for dette:</para>

        <!-- @ENGLISH {{{
        <screen>
$ svnserve -d
$               # svnserve is now running, listening on port 3690
</screen>
        @ENGLISH }}} -->
      <screen>
$ svnserve -d
$               # nå kjører svnserve og lytter på port 3690
</screen>

      <!-- @ENGLISH {{{
      <para>When running <command>svnserve</command> in daemon mode,
        you can use the <option>-&#64738;-listen-port=</option> and
        <option>-&#64738;-listen-host=</option> options to customize the exact
        port and hostname to <quote>bind</quote> to.</para>
      @ENGLISH }}} -->
      <para>Når <command>svnserve</command> kjøres i daemon-modus, kan 
        du bruke valgene <option>--listen-port=</option> og 
        <option>--listen-host=</option> for å sette den eksakte porten 
        og vertsnavn som den skal <!-- ¤ Det er jo referert til bind(2), 
        men kan man verbe det på en fornuftig måte uten å miste 
        presensformen? Tror ikke det, så det fornorskes litt. 
        --><quote>bindes</quote> til:</para>

      <!-- @ENGLISH {{{
      <para>There's still a third way to invoke
        <command>svnserve</command>, and that's in <quote>tunnel
        mode</quote>, with the <option>-t</option> option.  This mode
        assumes that a remote-service program such as
        <command>RSH</command> or <command>SSH</command> has
        successfully authenticated a user and is now invoking a
        private <command>svnserve</command> process <emphasis>as that
        user</emphasis>.  The <command>svnserve</command> program
        behaves normally (communicating via <emphasis>stdin</emphasis>
        and <emphasis>stdout</emphasis>), and assumes that the traffic
        is being automatically redirected over some sort of tunnel
        back to the client.  When <command>svnserve</command> is
        invoked by a tunnel agent like this, be sure that the
        authenticated user has full read and write access to the
        repository database files. (See <xref
        linkend="svn.serverconfig.svnserve.invoking.sb-1"/>.)  It's essentially the same as
        a local user accessing the repository via
        <literal>file:///</literal> URLs.</para>
      @ENGLISH }}} -->
      <para>Og det er fortsatt en tredje måte å starte 
        <command>svnserve</command> på, og det er i 
        <quote>tunnelmodus</quote>, med valget <option>-t</option>.
        Denne modusen forutsetter at et fjerntjenesteprogram som 
        <command>RSH</command> eller <command>SSH</command> har klart å 
        autentisere som en bruker og nå skal starte en privat 
        <command>svnserve</command>-prosess <emphasis>som denne 
        brukeren</emphasis>.
        <command>svnserve</command>-programmet oppfører seg normalt 
        (kommuniserer via <emphasis>standard inn</emphasis> og 
        <emphasis>standard ut</emphasis>), og går ut i fra at trafikken 
        blir automatisk omdirigert gjennom en form for tunnel tilbake 
        til klienten.
        Når <command>svnserve</command> blir startet av en <!-- ¤ agent 
        -->tunnelagent som dette, pass på at den autentiserte brukeren 
        har full skrive- og leseaksess til databasefilene i depotet.
        (Se <xref linkend="svn.serverconfig.svnserve.invoking.sb-1"/>.)
        Det er hovedsaklig det samme prinsippet som når en lokal bruker 
        får tilgang til depotet via 
        <literal>file:///</literal>-URLer.</para>

      <sidebar id="svn.serverconfig.svnserve.invoking.sb-1">
        <!-- @ENGLISH {{{
        <title>Servers and Permissions:  A Word of Warning</title>        
        @ENGLISH }}} -->
        <title>&Servers; og rettigheter: En liten advarsel</title>

        <!-- @ENGLISH {{{
        <para>First, remember that a Subversion repository is a
          collection of database files; any process which accesses the
          repository directly needs to have proper read and write
          permissions on the entire repository.  If you're not
          careful, this can lead to a number of headaches, especially
          if you're using a Berkeley DB database rather than FSFS.  Be
          sure to read <xref linkend="svn.serverconfig.multimethod"/>.</para>
        @ENGLISH }}} -->
        <para>For det første, husk at et Subversiondepot er en samling 
          med databasefiler; enhver prosess som aksesserer depotet 
          direkte må ha tilstrekkelige lese- og skriverettigheter til 
          hele depotet.
          Hvis du ikke er forsiktig, kan dette føre til en rekke 
          hodepiner, spesielt hvis du bruker en Berkeley DB-database 
          istedenfor FSFS.
          Pass på å lese <xref 
          linkend="svn.serverconfig.multimethod"/>.</para>

        <!-- @ENGLISH {{{
        <para>Secondly, when configuring <command>svnserve</command>,
          Apache <command>httpd</command>, or any other server
          process, keep in mind that you might not want to launch the
          server process as the user <literal>root</literal> (or as
          any other user with unlimited permissions).  Depending on
          the ownership and permissions of the repositories you're
          exporting, it's often prudent to use a
          different&mdash;perhaps custom&mdash;user.  For example,
          many administrators create a new user named
          <literal>svn</literal>, grant that user exclusive ownership
          and rights to the exported Subversion repositories, and only
          run their server processes as that user.</para>
        @ENGLISH }}} -->
        <para>For det andre, når du setter opp 
          <command>svnserve</command>, Apache <command>httpd</command> 
          eller en annen &server;prosess, husk på at du ikke vil starte 
          tjenesten som <literal>root</literal>-brukeren (eller en annen 
          bruker med ubegrensede rettigheter).
          Avhengig av eierskapet og rettighetene på depotene du 
          eksporterer, er det ofte fornuftig å bruke en annen – kanskje 
          spesiallaget – bruker.
          For eksempel lager mange administratorer en ny bruker kalt 
          <literal>svn</literal>, gir denne eksklusivt eierskap og 
          rettigheter til de eksporterte Subversiondepotene og kjører 
          &server;prosessene kun som denne brukeren.</para>
      </sidebar>


      <!-- @ENGLISH {{{
      <para>Once the <command>svnserve</command> program is running,
        it makes every repository on your system available to the
        network.  A client needs to specify an
        <emphasis>absolute</emphasis> path in the repository URL.  For
        example, if a repository is located at
        <filename>/usr/local/repositories/project1</filename>, then a
        client would reach it via <systemitem
        class="url">svn://host.example.com/usr/local/repositories/project1
        </systemitem>.  To increase security, you can pass the
        <option>-r</option> option to <command>svnserve</command>,
        which restricts it to exporting only repositories below that
        path:</para>
      @ENGLISH }}} -->
      <para>Når <command>svnserve</command>-programmet kjører, gjør det 
        alle depotene på systemet tilgjengelig på nettverket.
        En klient må spesifisere en <emphasis>absolutt</emphasis> sti i 
        depot-URLen.
        Hvis for eksempel et depot ligger i 
        <filename>/usr/local/depoter/prosjekt1</filename>, kan en klient 
        nå det via <systemitem 
        class="url">svn://&server;.example.com/usr/local/depoter/prosjekt1</systemitem>.
        For å øke sikkerheten kan du angi <option>-r</option>-valget til 
        <command>svnserve</command> som begrenser den til å kun 
        ekportere depoter som ligger under denne stien:</para>
      
      <!-- @ENGLISH {{{
      <screen>
$ svnserve -d -r /usr/local/repositories
&hellip;
</screen>
      @ENGLISH }}} -->
      <screen>
$ svnserve -d -r /usr/local/depoter
…
</screen>

      <!-- @ENGLISH {{{
      <para>Using the <option>-r</option> option effectively
        modifies the location that the program treats as the root of
        the remote filesystem space.  Clients then use URLs that
        have that path portion removed from them, leaving much
        shorter (and much less revealing) URLs:</para>
      @ENGLISH }}} -->
      <para>Bruken av <option>-r</option>-valget forandrer plasseringen 
        av roten som programmet bruker på det fjerntliggende 
        filsystemet.
        Klienter bruker dermed URLer som har fjernet denne delen av 
        stien, noe som gir mye kortere (og mindre avslørende) 
        URLer:</para>
      
      <!-- @ENGLISH {{{
      <screen>
$ svn checkout svn://host.example.com/project1
&hellip;
</screen>
      @ENGLISH }}} -->
      <screen>
$ svn checkout svn://&server;.example.com/prosjekt1
…
</screen>
 
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.auth">
      <!-- @ENGLISH {{{
      <title>Built-in authentication and authorization</title>
      @ENGLISH }}} -->
      <title>Innebygget autentisering og autorisasjon</title>

      <!-- @ENGLISH {{{
      <para>When a client connects to an <command>svnserve</command>
        process, the following things happen:</para>
      @ENGLISH }}} -->
      <para>Når en klient kobler seg til en 
        <command>svnserve</command>-prosess, skjer de følgende 
        tingene:</para>

      <itemizedlist>
        <!-- @ENGLISH {{{
        <listitem><para>The client selects a specific
        repository.</para></listitem>
        @ENGLISH }}} -->
        <listitem>
          <para>Klienten velger et spesifikt depot.</para>
        </listitem>

        <!-- @ENGLISH {{{
        <listitem><para>The server processes the repository's
        <filename>conf/svnserve.conf</filename> file, and begins to
        enforce any authentication and authorization policies defined
        therein.</para></listitem>
        @ENGLISH }}} -->
        <listitem>
          <para>&The_server; går gjennom depotets 
            <filename>conf/svnserve.conf</filename>-fil og begynner å 
            gjennomføre alle autentiserings- og autorisasjonsregler som 
            er definert i den.</para>
        </listitem>

        <!-- @ENGLISH {{{
        <listitem><para>Depending on the situation and authorization
        policies,</para>
        @ENGLISH }}} -->
        <listitem>
          <para>Avhengig av situasjonen og autorisasjonsreglene,</para>

          <itemizedlist>
            <!-- @ENGLISH {{{
            <listitem><para>the client may be allowed to make requests
              anonymously, without ever receiving an authentication
              challenge, OR</para></listitem>
            @ENGLISH }}} -->
            <listitem>
              <para>kan klienten få lov til å foreta forespørsler 
                anonymt, uten noen gang å motta en 
                autentiseringsutfordring, ELLER</para>
            </listitem>

            <!-- @ENGLISH {{{
            <listitem><para>the client may be challenged for
              authentication at any time, OR</para></listitem>
            @ENGLISH }}} -->
            <listitem>
              <para>klienten kan bli spurt etter autentiseringsinfo til 
                enhver tid, ELLER</para>
            </listitem>

            <!-- @ENGLISH {{{
            <listitem><para>if operating in <quote>tunnel
              mode</quote>, the client will declare itself to be
              already externally authenticated.</para></listitem>
            @ENGLISH }}} -->
            <listitem>
              <para>hvis den opererer i <quote>tunnelmodus</quote>, vil 
                klienten erklære seg selv som å allerede være eksternt 
                autentisert.</para></listitem>
          </itemizedlist>
        </listitem>

      </itemizedlist>

      <!-- @ENGLISH {{{
      <para>At the time of writing, the server only knows how to send
        a CRAM-MD5 <footnote><para>See RFC 2195.</para></footnote>
        authentication challenge.  In essence, the server sends a bit
        of data to the client.  The client uses the MD5 hash algorithm
        to create a fingerprint of the data and password combined,
        then sends the fingerprint as a response.  The server performs
        the same computation with the stored password to verify that
        the result is identical.  <emphasis>At no point does the
        actual password travel over the network.</emphasis></para>
      @ENGLISH }}} -->
      <para>Når dette skrives, vet &the_server; bare hvordan den skal 
        sende en CRAM-MD5<footnote>
          <para>Se RFC 2195.</para>
        </footnote>-autentiseringsutfordring.
        I hovedsak sender &the_server; litt data til klienten.
        Klienten bruker MD5-algoritmen for å lage et fingeravtrykk av de 
        kombinerte dataene og passordet og sender fingeravtrykket som 
        svar.
        &The_server; foretar den samme utregningen med det lagrede 
        passordet for å sjekke at resultatet er identisk.
        <emphasis>Passordet blir ikke på noe tidspunkt sendt over 
        nettverket.</emphasis></para>

      <!-- @ENGLISH {{{
      <para>It's also possible, of course, for the client to be
        externally authenticated via a tunnel agent, such as
        <command>SSH</command>.  In that case, the server simply
        examines the user it's running as, and uses it as the
        authenticated username.  For more on this, see <xref
        linkend="svn.serverconfig.svnserve.sshauth"/>.</para>
      @ENGLISH }}} -->
      <para>Det er også selvfølgelig mulig for klienten å bli eksternt 
        autentisert via en tunnelagent, som for eksempel 
        <command>SSH</command>.
        I dette tilfellet sjekker &the_server; rett og slett bare 
        brukeren den kjører som, og bruker den som det autentiserte 
        brukernavnet.
        For mer om dette, se <xref 
        linkend="svn.serverconfig.svnserve.sshauth"/>.</para>

      <!-- @ENGLISH {{{
      <para>As you've already guessed, a repository's
        <filename>svnserve.conf</filename> file is the central
        mechanism for controlling authentication and authorization
        policies.  The file has the same format as other configuration
        files (see <xref linkend="svn.advanced.confarea"/>): section names
        are marked by square brackets (<literal>[</literal> and
        <literal>]</literal>), comments begin with hashes
        (<literal>#</literal>), and each section contains
        specific variables that can be set (<literal>variable =
        value</literal>).  Let's walk through this file and learn how
        to use them.</para>
      @ENGLISH }}} -->
      <para>Som du allerede har gjettet, er 
        <filename>svnserve.conf</filename>-filen i et depot den sentrale 
        mekanismen for å kontrollere autentiserings- og 
        autorisasjonsregler.
        Filen har det samme formatet som andre konfigurasjonsfiler (se 
        <xref linkend="svn.advanced.confarea"/>):
        Seksjonsnavn er markert med klammeparenteser 
        (<literal>[</literal> og <literal>]</literal>), kommentarer 
        begynner med <!-- ¤ -->hashtegn (<literal>#</literal>), og hver 
        seksjon inneholder spesifikke variabler som kan settes 
        (<literal>variabel = verdi</literal>).
        La oss gå gjennom denne filen og lære hvordan vi bruker 
        dem.</para>

      <sect3 id="svn.serverconfig.svnserve.auth.users">
        <!-- @ENGLISH {{{
        <title>Create a 'users' file and realm</title>
        @ENGLISH }}} -->
        <title>Opprette en brukerfil og område</title>

        <!-- @ENGLISH {{{
        <para>For now, the <literal>[general]</literal> section of the
          <filename>svnserve.conf</filename> has all the variables you
          need.  Begin by defining a file which contains usernames and
          passwords, and an authentication realm:</para>
        @ENGLISH }}} -->
        <para>For øyeblikket har <literal>[general]</literal>-seksjonen 
          i <filename>svnserve.conf</filename> alle variablene som du 
          trenger.
          Start ved å definere en fil som inneholder brukernavn og 
          passord, og et autentiseringsområde:</para>

        <!-- @ENGLISH {{{
        <screen>
[general]
password-db = userfile
realm = example realm
</screen>
        @ENGLISH }}} -->
        <screen>
[general]
password-db = brukerfil
realm = eksempelområde
</screen>

        <!-- @ENGLISH {{{
        <para>The <literal>realm</literal> is a name that you define.
          It tells clients which sort of <quote>authentication
          namespace</quote> they're connecting to; the Subversion
          client displays it in the authentication prompt, and uses it
          as a key (along with the server's hostname and port) for
          caching credentials on disk (see <xref
          linkend="svn.serverconfig.netmodel.credcache"/>).  The
          <literal>password-db</literal> variable points to a separate
          file that contains a list of usernames and passwords, using
          the same familiar format.  For example:</para>
        @ENGLISH }}} -->
        <para><literal>realm</literal> er et navn som du definerer.
          Det forteller klienter hvilket 
          <quote>autentiseringsnavnerom</quote> de kobler seg til; 
          Subversionklienten viser det når den spør etter 
          autentiseringsinfo, og bruker det som en nøkkel (sammen med 
          &the_server;s vertsnavn og port) for å lagre legitimasjonsinfo 
          på disken (se <xref 
          linkend="svn.serverconfig.netmodel.credcache"/>).
          Variabelen <literal>password-db</literal> peker til en separat 
          fil som inneholder en liste med brukernavn og passord, som 
          bruker det samme kjente formatet.
          For eksempel:</para>

        <!-- @ENGLISH {{{
        <screen>
[users]
harry = foopassword
sally = barpassword
</screen>
        @ENGLISH }}} -->
        <screen>
[users]
harry = foopassord
sally = barpassord
</screen>

        <!-- @ENGLISH {{{
        <para>The value of <literal>password-db</literal> can be an
          absolute or relative path to the users file.  For many
          admins, it's easy to keep the file right in the
          <filename>conf/</filename> area of the repository, alongside
          <filename>svnserve.conf</filename>.  On the other hand, it's
          possible you may want to have two or more repositories share
          the same users file; in that case, the file should probably
          live in a more public place.  The repositories sharing the
          users file should also be configured to have the same realm,
          since the list of users essentially defines an
          authentication realm.  Wherever the file lives, be sure to
          set the file's read and write permissions appropriately.  If
          you know which user(s) <command>svnserve</command> will run
          as, restrict read access to the user file as necessary.</para>
        @ENGLISH }}} -->
        <para>Verdien i <literal>password-db</literal> kan være en 
          absolutt eller relativ sti til brukerfila.
          For mange administratorer er det enkelt å lagre fila i 
          <filename>conf/</filename>-området i depotet, sammen med 
          <filename>svnserve.conf</filename>.
          På den annen side er det mulig at du vil ha to eller flere 
          depoter som deler den samme brukerfila; i så tilfelle bør fila 
          kanskje ligge på en mer offentlig plass.
          Depotene som deler brukerfila bør også settes opp til å ha 
          samme område (<foreignphrase>realm</foreignphrase>) siden 
          brukerlista <!-- ¤ essentially -->hovedsaklig definerer et 
          autentiseringsområde.
          Hvor fila enn ligger, pass på å sette lese- og 
          skriverettighetene på den.
          Hvis du vet hvilke(n) bruker(e) <command>svnserve</command> 
          vil kjøre som, begrens lesetilgangen til brukerfila etter hva 
          som er nødvendig.</para>

      </sect3>

      <sect3 id="svn.serverconfig.svnserve.auth.general">
        <!-- @ENGLISH {{{
        <title>Set access controls</title>
        @ENGLISH }}} -->
        <title>Sette tilgangskontroll</title>

        <!-- @ENGLISH {{{
        <para>There are two more variables to set in the
          <filename>svnserve.conf</filename> file: they determine what
          unauthenticated (anonymous) and authenticated users are
          allowed to do.  The variables <literal>anon-access</literal>
          and <literal>auth-access</literal> can be set to the values
          <literal>none</literal>, <literal>read</literal>, or
          <literal>write</literal>.  Setting the value to
          <literal>none</literal> restricts all access of any kind;
          <literal>read</literal> allows read-only access to the
          repository, and <literal>write</literal> allows complete
          read/write access to the repository.  For example:</para>
        @ENGLISH }}} -->
        <para>Det er to variabler til som må settes i 
          <filename>svnserve.conf</filename>-fila, de avgjør hva 
          uautentiserte (anonyme) og autentiserte brukere får lov til å 
          gjøre.
          Variablene <literal>anon-access</literal> og 
          <literal>auth-access</literal> kan settes til verdiene 
          <literal>none</literal>, <literal>read</literal> eller 
          <literal>write</literal>.
          Ved å sette verdien til <literal>none</literal> begrenses alle 
          typer tilganger; <literal>read</literal> tillater bare lesing 
          fra depotet, og <literal>write</literal> gir fullstendig 
          lese/skrive-tilgang til depotet.
          For eksempel:</para>

        <!-- ¤ Her kopieres skjermteksten nøyaktig likt, så det med at 
        «verdiene har den standardverdien» blir riktig. Eller er de 
        L10N’et? Sjekkes. -->
        <!-- @ENGLISH {{{
        <screen>
[general]
password-db = userfile
realm = example realm

# anonymous users can only read the repository
anon-access = read

# authenticated users can both read and write
auth-access = write
</screen>
        @ENGLISH }}} -->
        <screen>
[general]
password-db = userfile
realm = example realm

# anonyme brukere kan bare lese depotet
anon-access = read

# autentiserte brukere kan både lese og skrive
auth-access = write
</screen>

        <!-- @ENGLISH {{{
        <para>The example settings are, in fact, the default values of
          the variables, should you forget to define them.  If you
          want to be even more conservative, you can block anonymous
          access completely:</para>
        @ENGLISH }}} -->
        <para>Oppsettet i dette eksempelet viser standardverdiene som 
          variablene har, i tilfelle du glemmer å definere dem.
          Hvis du vil være enda mer konservativ, kan du blokkere anonym 
          tilgang fullstendig:</para>

        <!-- @ENGLISH {{{
        <screen>
[general]
password-db = userfile
realm = example realm

# anonymous users aren't allowed
anon-access = none

# authenticated users can both read and write
auth-access = write
</screen>
        @ENGLISH }}} -->
        <screen>
[general]
password-db = brukerfil
realm = eksempelområde

# anonyme brukere forbudt
anon-access = none

# autentiserte brukere kan både lese og skrive
auth-access = write
</screen>

        <!-- @ENGLISH {{{
        <para>Notice that <command>svnserve</command> only understands
          <quote>blanket</quote> access control.  A user either has
          universal read/write access, universal read access, or no
          access.  There is no detailed control over access to
          specific paths within the repository.  For many projects and
          sites, this level of access control is more than adequate.
          However, if you need per-directory access control, you'll
          need to use either use Apache with
          <command>mod_authz_svn</command> (see <xref
          linkend="svn.serverconfig.httpd.authz.perdir"/>) or use a
          <command>pre-commit</command> hook script to control write
          access (see <xref linkend="svn.reposadmin.create.hooks"/>).  The
          Subversion distribution comes with
          <command>commit-access-control.pl</command> and the more
          sophisticated <command>svnperms.py</command> scripts for use
          in pre-commit scripts.</para>
        @ENGLISH }}} -->
        <para>Legg merke til at <command>svnserve</command> bare forstår 
          <!-- ¤ blanket --><quote>fullstendig</quote> tilgangskontroll.
          En bruker har enten universell lese/skrive-tilgang, universell 
          lesetilgang eller ingen tilgang.
          Det er ingen detaljert kontroll over tilgang til spesifikke 
          stier i depotet.
          For mange prosjekter og <!-- ¤ sites -->&servers; er dette 
          nivået på tilgangskontroll mer enn nok.
          Hvis du imidlertid trenger tilgangskontroll på katalognivå, må 
          du enten bruke Apache med <command>mod_auth_svn</command> (se 
          <xref linkend="svn.serverconfig.httpd.authz.perdir"/>) eller 
          bruke et <command>pre-commit</command>-påhakningsskript for å 
          kontrollere skrivetilgangen (se <xref 
          linkend="svn.reposadmin.create.hooks"/>).
          Subversiondistribusjonen kommer med skriptet 
          <command>commit-access-control.pl</command> og det mer 
          sofistikerte <command>svnperms.py</command> for bruk i 
          <command>pre-commit</command>-skript.</para>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.sshauth">
      <!-- @ENGLISH {{{
      <title>SSH authentication and authorization</title>
      @ENGLISH }}} -->
      <title>Autentisering og autorisasjon via SSH</title>

      <!-- @ENGLISH {{{
      <para><command>svnserve</command>'s built-in authentication can
        be very handy, because it avoids the need to create real
        system accounts.  On the other hand, some administrators
        already have well-established SSH authentication frameworks in
        place.  In these situations, all of the project's users
        already have system accounts and the ability to <quote>SSH
        into</quote> the server machine.</para>
      @ENGLISH }}} -->
      <para><command>svnserve</command>s innebyggede autentisering kan 
        være veldig grei å ha med å gjøre, fordi man ikke trenger å 
        opprette virkelige brukerkontoer på systemet.
        På den annen side har noen administratorer allerede et 
        veletablert rammeverk for SSH-autentisering på plass.
        I disse situasjonene har alle brukerne på prosjektet allerede 
        systemkontoer og muligheten til å koble seg til via SSH på 
        &server;maskinen.</para>

      <!-- @ENGLISH {{{
      <para>It's easy to use SSH in conjunction with
        <command>svnserve</command>.  The client simply uses the
        <literal>svn+ssh://</literal> URL schema to connect:</para>
      @ENGLISH }}} -->
      <para>Det er enkelt å bruke SSH sammen med 
        <command>svnserve</command>.
        Klienten bruker ganske enkelt URL-skjemaet 
        <literal>svn+ssh://</literal> for å koble seg til:</para>

      <!-- @ENGLISH {{{
      <screen>
$ whoami
harry

$ svn list svn+ssh://host.example.com/repos/project
harry@host.example.com's password:  *****

foo
bar
baz
&hellip;
</screen>
      @ENGLISH }}} -->
      <screen>
$ whoami
harry

$ svn list svn+ssh://&server;.example.com/repos/prosjekt
harry@&server;.example.com's password:  *****

foo
bar
baz
…
</screen>

      <!-- @ENGLISH {{{
      <para>In this example, the Subversion client is invoking a local
        <command>ssh</command> process, connecting to
        <literal>host.example.com</literal>, authenticating as the
        user <literal>harry</literal>, then spawning a private
        <command>svnserve</command> process on the remote machine
        running as the user <literal>harry</literal>.  The
        <command>svnserve</command> command is being invoked in tunnel
        mode (<option>-t</option>) and its network protocol is being
        <quote>tunneled</quote> over the encrypted connection by
        <command>ssh</command>, the tunnel-agent.
        <command>svnserve</command> is aware that it's running as the
        user <literal>harry</literal>, and if the client performs a
        commit, the authenticated username will be attributed as the
        author of the new revision.</para>
      @ENGLISH }}} -->
      <para>I dette eksempelet starter Subversionklienten en lokal 
        <command>ssh</command>-prosess, kobler seg opp mot 
        <literal>&server;.example.com</literal>, autentiserer seg som 
        brukeren <literal>harry</literal>, starter en privat 
        <command>svnserve</command>-prosess på den fjerntliggende 
        maskinen som kjører som brukeren <literal>harry</literal>.
        <command>svnserve</command>-kommandoen blir startet i 
        tunnelmodus (<option>-t</option>) og nettverksprotokollen som 
        den bruker blir <quote>lagt i tunnel</quote> over den krypterte 
        forbindelsen via <command>ssh</command>, tunnelagenten.
        <command>svnserve</command> vet at den kjører som brukeren 
        <literal>harry</literal>, og hvis klienten foretar en 
        innlegging, vil det autentiserte brukernavnet bli kreditert som 
        forfatteren av den nye revisjonen.</para>

      <!-- @ENGLISH {{{
      <para>The important thing to understand here is that the
        Subversion client is <emphasis>not</emphasis> connecting to a
        running <command>svnserve</command> daemon.  This method of
        access doesn't require a daemon, nor does it notice one if
        present.  It relies wholly on the ability of
        <command>ssh</command> to spawn a temporary
        <command>svnserve</command> process, which then terminates
        when the network connection is closed.</para>
      @ENGLISH }}} -->
      <para>Den viktige tingen å forstå her er at Subversionklienten 
        <emphasis>ikke</emphasis> kobler seg til en kjørende 
        <command>svnserve</command>-daemon.
        Denne tilkoblingsmetoden krever ingen daemon, og den legger 
        heller ikke merke til om noen slike finnes.
        Den stoler fullt og helt på evnen til <command>ssh</command> å 
        starte en midlertidig <command>svnserve</command>-prosess, som 
        avsluttes når nettverksforbindelsen lukkes.</para>

      <!-- @ENGLISH {{{
      <para>When using <literal>svn+ssh://</literal> URLs to access a
        repository, remember that it's the <command>ssh</command>
        program prompting for authentication, and
        <emphasis>not</emphasis> the <command>svn</command> client
        program.  That means there's no automatic password caching
        going on (see <xref linkend="svn.serverconfig.netmodel.credcache"/>).  The
        Subversion client often makes multiple connections to the
        repository, though users don't normally notice this due to the
        password caching feature.  When using
        <literal>svn+ssh://</literal> URLs, however, users may be
        annoyed by <command>ssh</command> repeatedly asking for a
        password for every outbound connection.  The solution is to
        use a separate SSH password-caching tool like
        <command>ssh-agent</command> on a Unix-like system, or
        <command>pageant</command> on Windows.</para>
      @ENGLISH }}} -->
      <para>Når du bruker <literal>svn+ssh://</literal>-URLer til å 
        aksessere et depot, husk at det er 
        <command>ssh</command>-programmet som spør etter autentisering, 
        og <emphasis>ikke</emphasis> <command>svn</command>-klienten.
        Dette betyr at det er ingen automatisk lagring av passord (se 
        <xref linkend="svn.serverconfig.netmodel.credcache"/>).
        Subversionklienten foretar ofte flere tilkoblinger til depotet, 
        selv om brukere vanligvis ikke legger merke til dette på grunn 
        av funksjonen som lagrer passord.
        Men ved bruk av <literal>svn+ssh://</literal> kan brukere bli 
        plaget med at <command>ssh</command> spør etter passord for hver 
        eneste utgående tilkobling.
        Løsningen er å bruke et separat passordlagringssystem for SSH 
        som for eksempel <command>ssh-agent</command> på et 
        Unix-lignende system eller <command>pageant</command> i 
        Windows.</para>

      <!-- @ENGLISH {{{
      <para>When running over a tunnel, authorization is primarily
        controlled by operating system permissions to the repository's
        database files; it's very much the same as if Harry were
        accessing the repository directly via a
        <literal>file:///</literal> URL.  If multiple system users are
        going to be accessing the repository directly, you may want to
        place them into a common group, and you'll need to be careful
        about umasks.  (Be sure to read <xref
        linkend="svn.serverconfig.multimethod"/>.)  But even in the case of
        tunneling, the <filename>svnserve.conf</filename> file can
        still be used to block access, by simply setting
        <literal>auth-access = read</literal> or <literal>auth-access
        = none</literal>.</para>
      @ENGLISH }}} -->
      <para>Når tilkobling skjer gjennom en tunnel, blir autorisering 
        for databasefilene i depotet hovedsaklig kontrollert av 
        tilgangsrettigheter i operativsystemet; det er mye det samme som 
        om Harry aksesserer depotet direkte via en <!-- ¤ Skal den 
        ekstra slashen være der? --><literal>file:///</literal>-URL.
        Hvis flere systembrukere skal aksessere depotet direkte, vil du 
        kanskje plassere dem i en felles gruppe, og alt du trenger å 
        tenke på er å være forsiktig med <literal>umask</literal>.
        (Pass på å lese <xref linkend="svn.serverconfig.multimethod"/>.)
        Men selv i tilfellet med bruk av tunnel kan 
        <filename>svnserve.conf</filename> bli brukt til å blokkere 
        tilgang ved å sette <literal>auth-access = read</literal> eller 
        <literal>auth-access = none</literal>.</para>
      
      <!-- @ENGLISH {{{
      <para>You'd think that the story of SSH tunneling would end
        here, but it doesn't.  Subversion allows you to create custom
        tunnel behaviors in your run-time <filename>config</filename>
        file (see <xref linkend="svn.advanced.confarea"/>).  For example,
        suppose you want to use RSH instead of SSH.  In the
        <literal>[tunnels]</literal> section of your
        <filename>config</filename> file, simply define it like
        this:</para>
      @ENGLISH }}} -->
      <para>Man skulle tro at historien om SSH ender her, men det gjør 
        den ikke.
        Subversion lar deg opprette tilpasset tunneloppførsel i <!-- ¤ 
        run-time -->kjøringsfilen <filename>config</filename> (se <xref 
        linkend="svn.advanced.confarea"/>).
        I <literal>[tunnels]</literal>-seksjonen i 
        <filename>config</filename>-filen kan du enkelt definere det på 
        denne måten:</para>

      <screen>
[tunnels]
rsh = rsh
</screen>

      <!-- @ENGLISH {{{
      <para>And now, you can use this new tunnel definition by using a
        URL schema that matches the name of your new variable:
        <literal>svn+rsh://host/path</literal>.  When using the new
        URL schema, the Subversion client will actually be running the
        command <command>rsh host svnserve -t</command> behind the
        scenes.  If you include a username in the URL (for example,
        <literal>svn+rsh://username@host/path</literal>) the client
        will also include that in its command (<command>rsh
        username@host svnserve -t</command>).  But you can define new
        tunneling schemes to be much more clever than that:</para>
      @ENGLISH }}} -->
      <para>Og nå kan du bruke denne nye tunneldefinsjonen ved å bruke 
        et URL-skjema som samsvarer med navnet på den nye variabelen:
        <literal>svn+rsh://&server;/sti</literal>.
        Ved bruk av det nye URL-skjemaet vil Subversionklienten faktisk 
        kjøre kommandoen <command>rsh &server; svnserve -t</command> 
        <!-- ¤ -->i bakgrunnen.
        Hvis du inkluderer et brukernavn i URLen (for eksempel 
        <literal>svn+rsh://brukernavn@&server;/sti</literal>), vil 
        klienten også ta dette med i kommandoen (<command>rsh 
        brukernavn@&server; svnserve -t</command>).
        Men du kan definere nye tunnelskjema til å være mye mer 
        avanserte enn som så:</para>

      <screen>
[tunnels]
joessh = $JOESSH /opt/alternate/ssh -p 29934
</screen>

      <!-- @ENGLISH {{{
      <para>This example demonstrates a couple of things.  First, it
        shows how to make the Subversion client launch a very specific
        tunneling binary (the one located at
        <filename>/opt/alternate/ssh</filename>) with specific
        options.  In this case, accessing a
        <literal>svn+joessh://</literal> URL would invoke the
        particular SSH binary with <option>-p 29934</option> as
        arguments&mdash;useful if you want the tunnel program to
        connect to a non-standard port.</para>
      @ENGLISH }}} -->
      <para>Dette eksempelet demonstrerer et par ting.
        For det første viser det hvordan du lar Subversionklienten kjøre 
        en spesifikk binærfil som oppretter tunnelen (den som ligger som 
        <filename>/opt/alternate/ssh</filename> med spesifikke valg.
        I dette tilfellet vil det å aksessere en 
        <literal>svn+joessh://</literal>-URL starte denne SSH-binærfilen 
        med <option>-p 29934</option> som parameter – nyttig hvis du vil 
        at tunnelprogrammet skal koble seg til en ustandard port.</para>

      <!-- @ENGLISH {{{
      <para>Second, it shows how to define a custom environment
        variable that can override the name of the tunneling program.
        Setting the <literal>SVN_SSH</literal> environment variable is
        a convenient way to override the default SSH tunnel agent.
        But if you need to have several different overrides for
        different servers, each perhaps contacting a different port or
        passing a different set of options to SSH, you can use the
        mechanism demonstrated in this example.  Now if we were to set
        the <literal>JOESSH</literal> environment variable, its value
        would override the entire value of the tunnel
        variable&mdash;<command>$JOESSH</command> would be executed
        instead of <command>/opt/alternate/ssh -p
        29934</command>.</para>
      @ENGLISH }}} -->
      <para>For det andre viser det hvordan en tilpasset miljøvariabel 
        kan overstyre navnet på et tunnelprogram.
        Det å sette miljøvariabelen <literal>SVN_SSH</literal> er en 
        behagelig måte å overstyre den vanlige SSH-tunnelagenten.
        Men hvis du må ha flere forskjellige overstyringer for 
        forskjellige &servers;, der hver av dem kanskje kontakter en 
        forskjellig port eller sender et annet sett med parametere til 
        SSH, kan du bruke mekanismen som er demonstrert i dette 
        eksempelet.
        Hvis vi nå setter miljøvariabelen <literal>JOESSH</literal> til 
        noe, vil innholdet av denne variabelen overstyre hele innholdet 
        av tunnelvariabelen – <command>$JOESSH</command> vil bli kjørt 
        istedenfor <command>/opt/alternate/ssh -p 
        29934</command>.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.sshtricks">
      <!-- @ENGLISH {{{
      <title>SSH configuration tricks</title>
      @ENGLISH }}} -->
      <title>Konfigurasjonstriks i SSH</title>

      <!-- @ENGLISH {{{
      <para>It's not only possible to control the way in which the
        client invokes <command>ssh</command>, but also to control
        the behavior of <command>sshd</command> on your server
        machine.  In this section, we'll show how to control the
        exact <command>svnserve</command> command executed
        by <command>sshd</command>, as well as how to have multiple
        users share a single system account.</para>
      @ENGLISH }}} -->
      <para>Det er ikke bare mulig å kontrollere måten klienten starter 
        <command>ssh</command> på, men også å kontrollere oppførselen 
        til <command>sshd</command> på &server;maskinen.
        I denne seksjonen vil vi vise hvordan du kontrollerer den 
        eksakte <command>svnserve</command>-kommandoen som blir kjørt av 
        <command>sshd</command>, og også hvordan du får flere brukere 
        til å dele en enkel systemkonto.</para>
      
      <sect3 id="svn.serverconfig.svnserve.sshtricks.setup">
        <!-- @ENGLISH {{{
        <title>Initial setup</title>
        @ENGLISH }}} -->
        <title>Innledende oppsett</title>
        
        <!-- @ENGLISH {{{
        <para>To begin, locate the home directory of the account
          you'll be using to launch <command>svnserve</command>.  Make
          sure the account has an SSH public/private keypair
          installed, and that the user can log in via public-key
          authentication.  Password authentication will not work,
          since all of the following SSH tricks revolve around using
          the SSH <filename>authorized_keys</filename> file.</para>
        @ENGLISH }}} -->
        <para>Til å begynne med, finn fram til hjemmekatalogen for 
          kontoen som du skal bruke til å kjøre 
          <command>svnserve</command>.
          Vær sikker på at kontoen har et offentlig/privat SSH-nøkkelpar 
          installert, og at brukeren kan logge inn via autentisering med 
          offentlig nøkkel.
          Autentisering via passord vil ikke fungere, siden alle de 
          følgende SSH-triksene baserer seg på bruk av 
          <filename>authorized_keys</filename>-filen som brukes av 
          SSH.</para>

        <!-- @ENGLISH {{{
        <para>If it doesn't already exist, create the
          <filename>authorized_keys</filename> file (on Unix,
          typically <filename>~/.ssh/authorized_keys</filename>).
          Each line in this file describes a public key that is
          allowed to connect.  The lines are typically of the
          form:</para>
        @ENGLISH }}} -->
        <para>Hvis den ikke allerede finnes, opprett filen 
          <filename>authorized_keys</filename> (i Unix er den vanligvis 
          kalt <filename>~/.ssh/authorized_keys</filename>).
          Hver linje i denne filen beskriver en offentlig nøkkel som får 
          lov til å koble seg til.
          Linjene har vanligvis dette formatet:</para>

        <!-- @ENGLISH {{{
        <screen>
  ssh-dsa AAAABtce9euch.... user@example.com
</screen>
        @ENGLISH }}} -->
        <screen>
  ssh-dsa AAAABtce9euch.... bruker@example.com
</screen>
          
        <!-- @ENGLISH {{{
        <para>The first field describes the type of key, the second
          field is the uuencoded key itself, and the third field is a
          comment.  However, it's a lesser known fact that the entire
          line can be preceded by a <literal>command</literal>
          field:</para>
        @ENGLISH }}} -->
        <para>Det første feltet beskriver nøkkeltypen, det andre feltet 
          er selve den uuencodede nøkkelen, og det tredje feltet er en 
          kommentar.
          En lite kjent funksjonalitet er at hele linjen kan bli 
          innledet av et <literal>command</literal>-felt:</para>

        <!-- @ENGLISH {{{
        <screen>
  command="program" ssh-dsa AAAABtce9euch.... user@example.com
</screen>
        @ENGLISH }}} -->
        <screen>
  command="program" ssh-dsa AAAABtce9euch.... bruker@example.com
</screen>

        <!-- @ENGLISH {{{
        <para>When the <literal>command</literal> field is set, the
          SSH daemon will run the named program instead of the
          typical <command>svnserve -t</command> invocation that the
          Subversion client asks for.  This opens the door to a number
          of server-side tricks.  In the following examples, we
          abbreviate the lines of the file as:</para>
        @ENGLISH }}} -->
        <para>Når <literal>command</literal>-feltet er definert, vil 
          SSH-daemonen kjøre det navngitte programmet istedenfor den 
          typiske <command>svnserve -t</command>-prosessen som 
          Subversionklienten spør etter.
          Dette åpner døra til en rekke triks på &server;siden.
          I de følgende eksemplene forkorter vi linjene i filen 
          som:</para>

        <!-- @ENGLISH {{{
        <screen>
  command="program" TYPE KEY COMMENT
</screen>
        @ENGLISH }}} -->
        <screen>
  command="program" TYPE NØKKEL KOMMENTAR
</screen>

      </sect3>
      
      <sect3 id="svn.serverconfig.svnserve.sshtricks.fixedcmd">
        <!-- @ENGLISH {{{
        <title>Controlling the invoked command</title>
        @ENGLISH }}} -->
        <title>Kontrollere den startede kommandoen</title>

        <!-- @ENGLISH {{{
        <para>Because we can specify the executed server-side command,
          it's easy to name a specific <command>svnserve</command>
          binary to run and to pass it extra arguments:</para>
        @ENGLISH }}} -->
        <para>Fordi vi kan spesifisere kommandoen som kjøres på 
          &server;siden, er det lett å navngi en spesifikk 
          <command>svnserve</command>-binærfil som skal kjøres og levere 
          et ekstra parameter til den:</para>
        
        <!-- @ENGLISH {{{
        <screen>
  command="/path/to/svnserve -t -r /virtual/root" TYPE KEY COMMENT
</screen>
        @ENGLISH }}} -->
        <screen>
  command="/sti/til/svnserve -t -r /virtuell/rot" TYPE NØKKEL KOMMENTAR
</screen>

        <!-- @ENGLISH {{{
        <para>In this example, <filename>/path/to/svnserve</filename>
          might be a custom wrapper script
          around <command>svnserve</command> which sets the umask (see
          <xref linkend="svn.serverconfig.multimethod"/>).  It also shows how to
          anchor <command>svnserve</command> in a virtual root
          directory, just as one often does when
          running <command>svnserve</command> as a daemon process.
          This might be done either to restrict access to parts of the
          system, or simply to relieve the user of having to type an
          absolute path in the <literal>svn+ssh://</literal>
          URL.</para>
        @ENGLISH }}} -->
        <para>I dette eksempelet kan 
          <filename>/sti/til/svnserve</filename> være et spesiallaget 
          innkapslingsskript rundt <command>svnserve</command> som 
          setter umask-verdien (se <xref 
          linkend="svn.serverconfig.multimethod"/>).
          Det viser også hvordan <command>svnserve</command> kan 
          forankres i en virtuell rotkatalog akkurat som man ofte gjør 
          når <command>svnserve</command> kjøres som en daemonprosess.
          Dette kan gjøres enten ved å begrense adgangen til deler av 
          systemet, eller ganske enkelt spare brukeren for å måtte 
          skrive inn en absolutt sti i 
          <literal>svn+ssh://</literal>-URLen.</para>
        
        <!-- @ENGLISH {{{
        <para>It's also possible to have multiple users share a single
          account.  Instead of creating a separate system account for
          each user, generate a public/private keypair for each
          person.  Then place each public key into
          the <filename>authorized_users</filename> file, one per
          line, and use the <option>-&#64738;-tunnel-user</option>
          option:</para>
        @ENGLISH }}} -->
        <para>Det er også mulig å la flere brukere dele en enkel konto.
          Istedenfor å lage en egen systemkonto for hver bruker, lag et 
          offentlig/privat nøkkelpar for hver person.
          Legg deretter hver offentlig nøkkel inn i 
          <filename>authorized_users</filename>-filen, en per linje, og 
          bruk valget <option>--tunnel-user</option>:</para>

        <!-- @ENGLISH {{{
        <screen>
  command="svnserve -t -&#64738;-tunnel-user=harry" TYPE1 KEY1 harry@example.com
  command="svnserve -t -&#64738;-tunnel-user=sally" TYPE2 KEY2 sally@example.com
</screen>
        @ENGLISH }}} -->
        <screen>
  command="svnserve -t --tunnel-user=harry" TYPE1 NØKKEL1 harry@example.com
  command="svnserve -t --tunnel-user=sally" TYPE2 NØKKEL2 sally@example.com
</screen>

        <!-- @ENGLISH {{{
        <para>This example allows both Harry and Sally to connect to
          the same account via public-key authentication.  Each of
          them has a custom command that will be executed;
          the <option>-&#64738;-tunnel-user</option> option 
          tells <command>svnserve -t</command> to assume that the named
          argument is the authenticated user.  Without
          <option>-&#64738;-tunnel-user</option>, it would appear as though
          all commits were coming from the one shared system
          account.</para>
        @ENGLISH }}} -->
        <para>Dette eksempelet lar både Harry og Sally få koble seg til 
          den samme kontoen via offentlig nøkkel-autentisering.
          Hver av dem har en spesiallaget kommando som vil bli kjørt;
          valget <option>--tunnel-user</option> ber <command>svnserve 
          -t</command> om å gå ut i fra at den spesifiserte verdien er 
          den autentiserte brukeren.
          Uten <option>--tunnel-user</option> vil det se ut som om alle 
          innlegginger kommer fra en delt systemkonto.</para>

        <!-- @ENGLISH {{{
        <para>A final word of caution: giving a user access to the
          server via public-key in a shared account might still allow
          other forms of SSH access, even if you've set
          the <literal>command</literal> value
          in <filename>authorized_keys</filename>.  For example, the
          user may still get shell access through SSH, or be able to
          perform X11 or general port-forwarding through your server.
          To give the user as little permission as possible, you may
          want to specify a number of restrictive options immediately
          after the <literal>command</literal>:</para>
        @ENGLISH }}} -->
        <para>En siste advarsel:
          Det å gi en bruker tilgang til &the_server; via en offentlig 
          nøkkel på en delt konto kan fortsatt gi andre former for 
          SSH-tilgang, selv om du har definert 
          <literal>command</literal>-verdien i 
          <filename>authorized_keys</filename>.
          Brukeren kan for eksempel fortsatt få kommandolinjetilgang via 
          SSH, eller være i stand til å utføre X11- eller generell 
          port-<!-- ¤ -->forwarding gjennom &the_server;.
          For å gi brukeren så lite rettigheter som mulig, vil du 
          kanskje spesifisere et antall begrensningsvalg like etter 
          <literal>command</literal>:</para>

        <!-- @ENGLISH {{{
        <screen>
  command="svnserve -t -&#64738;-tunnel-user=harry",no-port-forwarding,\
           no-agent-forwarding,no-X11-forwarding,no-pty \
           TYPE1 KEY1 harry@example.com
</screen>
        @ENGLISH }}} -->
        <screen>
  command="svnserve -t --tunnel-user=harry",no-port-forwarding,\
           no-agent-forwarding,no-X11-forwarding,no-pty \
           TYPE1 NØKKEL1 harry@example.com
</screen>

      </sect3>

    </sect2>
    
  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.httpd">
    
    <!-- @ENGLISH {{{
    <title>httpd, the Apache HTTP server</title>
    @ENGLISH }}} -->
    <title>HTTP-&the_server; Apache (httpd)</title>

    <!-- @ENGLISH {{{
    <para>The Apache HTTP Server is a <quote>heavy duty</quote>
      network server that Subversion can leverage.  Via a custom
      module, <command>httpd</command> makes Subversion repositories
      available to clients via the WebDAV/DeltaV protocol, which is an
      extension to HTTP 1.1 (see <ulink url="http://www.webdav.org/"/>
      for more information).  This protocol takes the ubiquitous HTTP
      protocol that is the core of the World Wide Web, and adds
      writing&mdash;specifically, versioned
      writing&mdash;capabilities.  The result is a standardized,
      robust system that is conveniently packaged as part of the
      Apache 2.0 software, is supported by numerous operating systems
      and third-party products, and doesn't require network
      administrators to open up yet another custom port.
      <footnote>
        <para>They really hate doing that.</para>
      </footnote>
      While an Apache-Subversion server has more features than
      <command>svnserve</command>, it's also a bit more difficult
      to set up.  With flexibility often comes more complexity.</para>
    @ENGLISH }}} -->
    <para>HTTP-&the_server; Apache er en nettverks&server; i 
      tungvektsklassen som Subversion kan bruke.
      Ved hjelp av en spesiallaget modul gjør <command>httpd</command> 
      Subversiondepoter tilgjengelig for klienter via 
      WebDAV/DeltaV-protokollen, som er en utvidelse av HTTP 1.1 (se 
      <ulink url="http://www.webdav.org/"/> for mer informasjon).
      Denne protokollen tar HTTP-protokollen som vi finner over alt, 
      kjernen av <!-- ¤ -->World Wide Web, og legger til muligheter for 
      skriving – mer spesifikt, versjonert skriving.
      Resultatet er et standardisert, robust system som går godt sammen  
      med Apache 2.0-programvaren, støttet av et stort antall 
      operativsystemer og tredjeparts programvare.
      Og systemadministratorer trenger ikke å åpne enda en port på 
      systemet.<footnote>
        <para>Det er noe som de virkelig hater.</para>
      </footnote>
      En Apache/Subversion-&server; har større funksjonalitet enn 
      <command>svnserve</command>, men er også vanskeligere å sette opp.
      Med fleksibilitet kommer det ofte mer kompleksitet med på 
      kjøpet.</para>

    <!-- @ENGLISH {{{
    <para>Much of the following discussion includes references to
      Apache configuration directives.  While some examples are given
      of the use of these directives, describing them in full is
      outside the scope of this chapter.  The Apache team maintains
      excellent documentation, publicly available on their website at
      <ulink url="http://httpd.apache.org"/>.  For example, a general
      reference for the configuration directives is located at <ulink url="
      http://httpd.apache.org/docs-2.0/mod/directives.html"/>.</para>
    @ENGLISH }}} -->
    <para>Mye av den følgende diskusjonen inneholder referanser til 
      konfigurasjonsdirektiver for Apache.
      Selv om noen eksempler inneholder bruk av disse direktivene, er 
      det å beskrive dem i full detalj utenfor det som dette kapittelet 
      dekker.
      Utviklerne bak Apache vedlikeholder fortreffelig dokumentasjon, 
      offentlig tilgjengelig på hjemmesiden <ulink 
      url="http://httpd.apache.org"/>.
      En generell oversikt over konfigurasjonsdirektivene er for 
      eksempel tilgjengelig på <ulink 
      url="http://httpd.apache.org/docs-2.0/mod/directives.html"/>.</para>
    
    <!-- @ENGLISH {{{
    <para>Also, as you make changes to your Apache setup, it is likely
      that somewhere along the way a mistake will be made.  If you are
      not already familiar with Apache's logging subsystem, you should
      become aware of it.  In your <filename>httpd.conf</filename>
      file are directives that specify the on-disk locations of the
      access and error logs generated by Apache (the
      <literal>CustomLog</literal> and <literal>ErrorLog</literal>
      directives, respectively).  Subversion's mod_dav_svn uses
      Apache's error logging interface as well.  You can always browse
      the contents of those files for information that might reveal
      the source of a problem that is not clearly noticeable
      otherwise.</para>
    @ENGLISH }}} -->
    <para>I tillegg, etter hvert som du gjør forandringer til 
      Apacheoppsettet, kan det skje at en feil blir gjort på veien.
      Hvis du ikke allerede kjenner til Apaches loggesystem, bør du bli 
      kjent med det.
      I <filename>httpd.conf</filename>-filen din er det direktiver som 
      spesifiserer plasseringer på disken av aksess- og 
      feilmeldingsloggene som genereres av Apache (henholdsvis 
      direktivene <literal>CustomLog</literal> og 
      <literal>ErrorLog</literal>).
      Subversions mod_dav_svn bruker også Apaches logging av 
      feilmeldinger.
      Du kan alltids gå gjennom innholdet av disse filene etter 
      informasjon som kan vise kilden til et problem som ellers ikke er 
      lett å få øye på.</para>
    
    <sidebar>
      <!-- @ENGLISH {{{
      <title>Why Apache 2?</title>
      @ENGLISH }}} -->
      <title>Hvorfor Apache 2?</title>

      <!-- @ENGLISH {{{
      <para>If you're a system administrator, it's very likely that
        you're already running the Apache web server and have some
        prior experience with it.  At the time of writing, Apache 1.3
        is by far the most popular version of Apache.  The world has
        been somewhat slow to upgrade to the Apache 2.X series for
        various reasons: some people fear change, especially changing
        something as critical as a web server.  Other people depend on
        plug-in modules that only work against the Apache 1.3 API, and
        are waiting for a 2.X port.  Whatever the reason, many people
        begin to worry when they first discover that Subversion's
        Apache module is written specifically for the Apache 2 API.</para>
      @ENGLISH }}} -->
      <para>Hvis du er en systemadministrator, er det ganske sannsynlig 
        at du allerede kjører web&the_server; Apache og har noe 
        tidligere erfaring med den.
        Når dette skrives, er Apache 1.3 med god margin den mest 
        populære versjonen av Apache.
        Verden har vært ganske sen med å oppgradere til Apache 
        2.X-serien av diverse grunner:
        Noen folk frykter forandringer, spesielt det å forandre noe så 
        kritisk som en web&server;.
        Andre folk er avhenging av <!-- ¤ -->innpluggingsmoduler som 
        bare virker mot Apache 1.3-<!-- ¤ API -->grensesnittet, og 
        venter på en versjon for 2.X.
        Hva grunnen enn er, begynner mange personer å bekymre seg når de 
        oppdager at Subversions Apachemodul er skrevet spesifikt for 
        grensesnittet for Apache 2.</para>

      <!-- @ENGLISH {{{
      <para>The proper response to this problem is: don't worry about
        it.  It's easy to run Apache 1.3 and Apache 2 side-by-side;
        simply install them to separate places, and use Apache 2 as a
        dedicated Subversion server that runs on a port other than 80.
        Clients can access the repository by placing the port number
        into the URL:</para>
      @ENGLISH }}} -->
      <para>Svaret på dette problemet er:
        Ikke noe å bekymre seg for.
        Det er lett å kjøre Apache 1.3 og Apache 2 side ved side; bare 
        installer dem på forskjellige plasser på disken, og bruk Apache 
        2 som en dedisert Subversion&server; som bruker en annen port 
        enn 80.
        Klienter kan aksessere depotet ved å plassere portnummeret i 
        URLen:</para>

      <!-- @ENGLISH {{{
      <screen>
$ svn checkout http://host.example.com:7382/repos/project
&hellip;
</screen>
      @ENGLISH }}} -->
      <screen>
$ svn checkout http://&server;.example.com:7382/repos/prosjekt
…
</screen>
    </sidebar>


    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.prereqs">
      <!-- @ENGLISH {{{
      <title>Prerequisites</title>
      @ENGLISH }}} -->
      <title>Systemkrav</title>
      
      <!-- @ENGLISH {{{
      <para>To network your repository over HTTP, you basically need
        four components, available in two packages.  You'll need
        Apache <command>httpd</command> 2.0, the
        <command>mod_dav</command> DAV module that comes with it,
        Subversion, and the <command>mod_dav_svn</command>
        filesystem provider module distributed with Subversion.
        Once you have all of those components, the process of
        networking your repository is as simple as:</para>
      @ENGLISH }}} -->
      <para>For å få depotet ditt på nettverk over HTTP, trenger du 
        hovedsaklig fire komponenter, tilgjengelig i to pakker.
        Du trenger Apache <command>httpd</command> 2.0, DAV-modulen 
        <command>mod_dav</command> som følger med Apache, Subversion og 
        filsystemmodulen <command>mod_dav_svn</command> som kommer 
        sammen med Subversion.
        Når du har alle disse komponentene er prosessen å få depotet på 
        nett så enkel som å:</para>
      
      <itemizedlist>
        <listitem>
          <!-- @ENGLISH {{{
          <para>getting httpd 2.0 up and running with the mod_dav
            module,</para>
          @ENGLISH }}} -->
          <para>få httpd 2.0 opp og kjøre med mod_dav-modulen,</para>
        </listitem>
        <listitem>
          <!-- @ENGLISH {{{
          <para>installing the mod_dav_svn plugin to mod_dav, which
            uses Subversion's libraries to access the repository,
            and</para>
          @ENGLISH }}} -->
          <para>installere programtillegget mod_dav_svn til mod_dav, som 
            bruker Subversions biblioteker til å aksessere depotet, 
            og</para>
        </listitem>
        <listitem>
          <!-- @ENGLISH {{{
          <para>configuring your <filename>httpd.conf</filename>
            file to export (or expose) the repository.</para>
          @ENGLISH }}} -->
          <para>konfigurere <filename>httpd.conf</filename>-filen din 
            til å eksportere (eller vise) depotet.</para>
        </listitem>
      </itemizedlist>
      
      <!-- @ENGLISH {{{
      <para>You can accomplish the first two items either by
        compiling <command>httpd</command> and Subversion from
        source code, or by installing pre-built binary packages of
        them on your system.  For the most up-to-date information on
        how to compile Subversion for use with the Apache HTTP Server,
        as well as how to compile and configure Apache itself for
        this purpose, see the <filename>INSTALL</filename> file in
        the top level of the Subversion source code tree.</para>
      @ENGLISH }}} -->
      <para>Du kan sette opp de første to elementene enten ved å 
        kompilere <command>httpd</command> og Subversion fra kildekode 
        eller ved å installere ferdigbygde pakker med dem på systemet.
        For den mest oppdaterte informasjonen om hvordan du kompilerer 
        Subversion for bruk sammen med Apache HTTP-&the_server; og 
        hvordan kompilere og sette opp selve Apache for dette, se 
        <filename>INSTALL</filename>-filen på toppnivået av 
        kildekodetreet til Subversion.</para>
      
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.basic">
      <!-- @ENGLISH {{{
      <title>Basic Apache Configuration</title>
      @ENGLISH }}} -->
      <title>Grunnleggende oppsett av Apache</title>
      
      <!-- @ENGLISH {{{
      <para>Once you have all the necessary components installed on
        your system, all that remains is the configuration of Apache
        via its <filename>httpd.conf</filename> file.  Instruct Apache
        to load the mod_dav_svn module using the
        <literal>LoadModule</literal> directive.  This directive must
        precede any other Subversion-related configuration items.  If
        your Apache was installed using the default layout, your
        <command>mod_dav_svn</command> module should have been
        installed in the <filename>modules</filename> subdirectory of
        the Apache install location (often
        <filename>/usr/local/apache2</filename>).  The
        <literal>LoadModule</literal> directive has a simple syntax,
        mapping a named module to the location of a shared library on
        disk:</para>
      @ENGLISH }}} -->
      <para>Når du har alle de nødvendige komponentene installert på 
        systemet ditt, er alt som gjenstår å konfigurere Apache ved 
        hjelp av <filename>httpd.conf</filename>-filen.
        Få Apache til å laste mod_dav_svn-modulen ved å bruke 
        <literal>LoadModule</literal>-direktivet.
        Dette direktivet må komme foran alle andre Subversion-relaterte 
        elementer.
        Hvis Apache ble installert med standard filplasseringer, er 
        <command>mod_dav_svn</command>-modulen plassert i 
        <filename>modules</filename>-katalogen der Apache er installert 
        (ofte <filename>/usr/local/apache2</filename>).
        <literal>LoadModule</literal>-direktivet har en enkel syntaks 
        som <!-- ¤ mapping --> kobler en navngitt modul til plasseringen 
        av et delt bibliotek på disken:</para>
    
        <screen>
LoadModule dav_svn_module     modules/mod_dav_svn.so
</screen>

      <!-- @ENGLISH {{{
      <para>Note that if <command>mod_dav</command> was compiled as a
        shared object (instead of statically linked directly to the
        <command>httpd</command> binary), you'll need a similar
        <literal>LoadModule</literal> statement for it, too.  Be sure
        that it comes before the <command>mod_dav_svn</command> line:</para>
      @ENGLISH }}} -->
      <para>Legg merke til at hvis <command>mod_dav</command> ble 
        kompilert som et delt objekt (istedenfor å bli statisk linket 
        direkte til binærfilen <command>httpd</command>) vil du også 
        trenge en tilsvarende <literal>LoadModule</literal>-linje for 
        dette.
        Pass på at den kommer før 
        <command>mod_dav_svn</command>-linjen:</para>

        <screen>
LoadModule dav_module         modules/mod_dav.so
LoadModule dav_svn_module     modules/mod_dav_svn.so
</screen>

    
      <!-- @ENGLISH {{{
      <para>At a later location in your configuration file, you now
        need to tell Apache where you keep your Subversion repository
        (or repositories).  The <literal>Location</literal> directive
        has an XML-like notation, starting with an opening tag, and
        ending with a closing tag, with various other configuration
        directives in the middle.  The purpose of the
        <literal>Location</literal> directive is to instruct Apache to
        do something special when handling requests that are directed
        at a given URL or one of its children.  In the case of
        Subversion, you want Apache to simply hand off support for
        URLs that point at versioned resources to the DAV layer.  You
        can instruct Apache to delegate the handling of all URLs whose
        path portions (the part of the URL that follows the server's
        name and the optional port number) begin with
        <filename>/repos/</filename> to a DAV provider whose
        repository is located at
        <filename>/absolute/path/to/repository</filename> using the
        following <filename>httpd.conf</filename> syntax:</para>
      @ENGLISH }}} -->
      <!-- ¤ Dette avsnittet kan med fordel finleses litt sånn 
      etterhvert. -->
      <para>På en senere plassering i konfigurasjonsfilen må du fortelle 
        Apache hvor du har lagt Subversiondepotet (eller depotene).
        <literal>Location</literal>-direktivet har en XML-lignende 
        notasjon som starter med et åpningselement og slutter med et 
        sluttelement med diverse andre konfigurasjonsdirektiver i 
        midten.
        Formålet med <literal>Location</literal>-direktivet er å 
        instruere Apache til å gjøre noe spesielt når den behandler 
        forespørsler som går til en gitt URL eller et av dens barn.
        I tilfellet med Subversion vil du at Apache gir støtte for URLer 
        som peker til en versjonert ressurs i DAV-laget.
        Du kan instruere Apache til å delegere håndteringen av alle 
        URLer der en del av stien (den delen av URLen som kommer etter 
        &server;navnet og det valgfrie portnummeret) som begynner med 
        <filename>/repos/</filename> til en DAV-tjeneste som har depotet 
        plassert som <filename>/absolutt/sti/til/depotet</filename> ved 
        å bruke den følgende 
        <filename>httpd.conf</filename>-syntaksen:</para>
                
        <!-- @ENGLISH {{{
        <screen>
&lt;Location /repos&gt;
  DAV svn
  SVNPath /absolute/path/to/repository
&lt;/Location&gt;
</screen>
        @ENGLISH }}} -->
        <screen>
&lt;Location /repos&gt;
  DAV svn
  SVNPath /absolutt/sti/til/depotet
&lt;/Location&gt;
</screen>
            
      <!-- @ENGLISH {{{
      <para>If you plan to support multiple Subversion repositories
        that will reside in the same parent directory on your local
        disk, you can use an alternative directive, the
        <literal>SVNParentPath</literal> directive, to indicate that
        common parent directory.  For example, if you know you will be
        creating multiple Subversion repositories in a directory
        <filename>/usr/local/svn</filename> that would be accessed via
        URLs like <systemitem
        class="url">http://my.server.com/svn/repos1</systemitem>,
        <systemitem
        class="url">http://my.server.com/svn/repos2</systemitem>, and
        so on, you could use the <filename>httpd.conf</filename>
        configuration syntax in the following example:</para>
      @ENGLISH }}} -->
      <para>Hvis du planlegger å ha flere Subversiondepoter som vil 
        ligge i den samme foreldrekatalogen på en lokal disk, kan du 
        bruke et alternativt direktiv, 
        <literal>SVNParentPath</literal>-direktivet, for å indikere 
        denne felles foreldrekatalogen.
        Hvis du for eksempel vet at du vil opprette flere 
        Subversiondepoter i katalogen 
        <filename>/usr/local/svn</filename> som vil bli aksessert vie 
        URLer som <systemitem 
        class="url">http://min.&server;.com/svn/depot1</systemitem>, 
        <systemitem 
        class="url">http://min.&server;.com/svn/depot2</systemitem> og 
        så videre, kan du bruke 
        <filename>httpd.conf</filename>-konfigurasjonssyntaksen i det 
        følgende eksempelet:</para>
              
        <!-- @ENGLISH {{{
        <screen>
&lt;Location /svn&gt;
  DAV svn

  # any "/svn/foo" URL will map to a repository /usr/local/svn/foo
  SVNParentPath /usr/local/svn
&lt;/Location&gt;
</screen>
        @ENGLISH }}} -->
        <screen>
&lt;Location /svn&gt;
  DAV svn

  # alle "/svn/foo"-URLer vil kobles til katalogen /usr/local/svn/foo
  SVNParentPath /usr/local/svn
&lt;/Location&gt;
</screen>
            
      <!-- @ENGLISH {{{
      <para>Using the previous syntax, Apache will delegate the
        handling of all URLs whose path portions begin with
        <filename>/svn/</filename> to the Subversion DAV provider,
        which will then assume that any items in the directory
        specified by the <literal>SVNParentPath</literal> directive
        are actually Subversion repositories.  This is a particularly
        convenient syntax in that, unlike the use of the
        <literal>SVNPath</literal> directive, you don't have to
        restart Apache in order to create and network new
        repositories.</para>      
      @ENGLISH }}} -->
      <para>Ved å bruke den foregående syntaksen vil Apache delegere 
        håndteringen av alle URLer der stien begynner med 
        <filename>/svn/</filename> til DAV-tjenesten for Subversion som 
        deretter vil gå ut i fra at alle elementer i katalogen 
        spesifisert med <literal>SVNParentPath</literal>-direktivet 
        faktisk er Subversiondepoter.
        Dette er en spesielt lettvint syntaks fordi i motsetning til 
        bruken av <literal>SVNPath</literal>-direktivet trenger du ikke 
        å starte Apache på nytt for å opprette nye depoter og få dem på 
        nett.</para>

      <!-- @ENGLISH {{{
      <para>Be sure that when you define your new
        <literal>Location</literal>, it doesn't overlap with other
        exported Locations.  For example, if your main
        <literal>DocumentRoot</literal> is <filename>/www</filename>,
        do not export a Subversion repository in <literal>&lt;Location
        /www/repos&gt;</literal>.  If a request comes in for the URI
        <filename>/www/repos/foo.c</filename>, Apache won't know
        whether to look for a file <filename>repos/foo.c</filename> in
        the <literal>DocumentRoot</literal>, or whether to delegate
        <command>mod_dav_svn</command> to return
        <filename>foo.c</filename> from the Subversion
        repository.</para>
      @ENGLISH }}} -->
      <para>Pass på at den nye <literal>Location</literal>-defineringen 
        ikke overlapper med andre eksporterte plasseringer.
        For eksempel, hvis hovedplasseringen av 
        <literal>DocumentRoot</literal> er <filename>/www</filename>, 
        ikke eksporter et Subversiondepot med <literal>&lt;Location 
        /www/repos&gt;</literal>.
        Hvis en forespørsel kommer for URIen 
        <filename>/www/repos/foo.c</filename>, vet ikke Apache om den 
        skal se etter filen <filename>repos/foo.c</filename> i 
        <literal>DocumentRoot</literal> eller om den skal delegere 
        jobben til <command>mod_dav_svn</command> for å returnere 
        <filename>foo.c</filename> fra Subversiondepotet.</para>

      <sidebar>
        <!-- @ENGLISH {{{
        <title>Server Names and the COPY Request</title>
        @ENGLISH }}} -->
        <title>&Server;navn og COPY-forespørselen</title>
        
        <!-- @ENGLISH {{{
        <para>Subversion makes use of the <literal>COPY</literal>
          request type to perform server-side copies of files and
          directories.  As part of the sanity checking done by the
          Apache modules, the source of the copy is expected to be
          located on the same machine as the destination of the copy.
          To satisfy this requirement, you might need to tell mod_dav
          the name you use as the hostname of your server.  Generally,
          you can use the <literal>ServerName</literal> directive in
          <filename>httpd.conf</filename> to accomplish this.</para>
        @ENGLISH }}} -->
        <para>Subversion gjør bruk av 
          <literal>COPY</literal>-forespørselstypen for å utføre 
          kopiering av filer og kataloger på &server;siden.
          Som en del av de <!-- ¤ sanity checking -->interne kontrollene 
          gjort av Apachemoduler, blir det forventet at kilden til 
          kopien ligger på den samme maskinen som målet til kopien.
          For å tilfredsstille dette kravet, kan det hende at du må 
          fortelle mod_dav navnet som du bruker som &server;navn på 
          &the_server;.
          Vanligvis kan du bruke 
          <literal>ServerName</literal>-direktivet i 
          <filename>httpd.conf</filename> for å få dette til.</para>
        
        <screen>
ServerName svn.example.com
</screen>
            
        <!-- @ENGLISH {{{
        <para>If you are using Apache's virtual hosting support via
          the <literal>NameVirtualHost</literal> directive, you may
          need to use the <literal>ServerAlias</literal> directive to
          specify additional names that your server is known by.
          Again, refer to the Apache documentation for full
          details.</para>
        @ENGLISH }}} -->
        <para>Hvis du bruker Apaches virtuelle &server;støtte med 
          <literal>NameVirtualHost</literal>-direktivet, kan det hende 
          at du må bruke <literal>ServerAlias</literal>-direktivet for å 
          spesifisere flere navn som &the_server; din er kjent som.
          Les i dokumentasjonen for Apache for fullstendige detaljer om 
          dette.</para>
      </sidebar>

      <!-- @ENGLISH {{{
      <para>At this stage, you should strongly consider the question
        of permissions.  If you've been running Apache for some time
        now as your regular web server, you probably already have a
        collection of content&mdash;web pages, scripts and such.
        These items have already been configured with a set of
        permissions that allows them to work with Apache, or more
        appropriately, that allows Apache to work with those files.
        Apache, when used as a Subversion server, will also need the
        correct permissions to read and write to your Subversion
        repository.  (See <xref linkend="svn.serverconfig.svnserve.invoking.sb-1"/>.)</para>
      @ENGLISH }}} -->
      <para>På dette steget bør du sterkt vurdere spørsmålet angående 
        rettigheter.
        Hvis du har kjørt Apache en stund som din vanlige web&server;, 
        har du sannsynligvis en samling med innhold – hjemmesider, 
        skript og lignende.
        Disse elementene er allerede blitt satt opp med et sett 
        rettigheter som gjør at de fungerer med Apache, eller rettere 
        sagt, som gjør at Apache virker med disse filene.
        Når Apache brukes som en Subversion&server; vil den også trenge 
        de riktige rettighetene for å lese og skrive til 
        Subversiondepotet.
        (Se <xref 
        linkend="svn.serverconfig.svnserve.invoking.sb-1"/>.)</para>
    
      <!-- @ENGLISH {{{
      <para>You will need to determine a permission system setup that
        satisfies Subversion's requirements without messing up any
        previously existing web page or script installations.  This
        might mean changing the permissions on your Subversion
        repository to match those in use by other things that Apache
        serves for you, or it could mean using the
        <literal>User</literal> and <literal>Group</literal>
        directives in <filename>httpd.conf</filename> to specify that
        Apache should run as the user and group that owns your
        Subversion repository.  There is no single correct way to set
        up your permissions, and each administrator will have
        different reasons for doing things a certain way.  Just be
        aware that permission-related problems are perhaps the most
        common oversight when configuring a Subversion repository for
        use with Apache.</para>
      @ENGLISH }}} -->
      <para>Du må finne fram til et oppsett for rettighetssystemet som 
        tilfredsstiller Subversions krav uten å rote til noen av de 
        nettsidene eller skriptene som er installert fra før.
        Dette kan bety å forandre rettighetene på Subversiondepotet til 
        å samsvare med de som brukes av andre ting som Apache håndterer 
        for deg, eller det kan innebære å bruke direktivene 
        <literal>User</literal> og <literal>Group</literal> i 
        <filename>httpd.conf</filename> for å spesifisere at Apache må 
        kjøre som den brukeren og gruppen som eier Subversiondepotet.
        Det er ingen enkelt universalløsning for å sette opp 
        rettighetene, og hver administrator vil ha forskjellige grunner 
        for å gjøre ting på en spesiell måte.
        Bare husk at rettighetsrelaterte problemer kanskje er det som 
        oftest blir oversett når et Subversiondepot settes opp for bruk 
        med Apache.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.authn">
      <!-- @ENGLISH {{{
      <title>Authentication Options</title>
      @ENGLISH }}} -->
      <title>Autentiseringsvalg</title>

      <!-- @ENGLISH {{{
      <para>At this point, if you configured
        <filename>httpd.conf</filename> to contain something like</para>
      @ENGLISH }}} -->
      <para>På dette punktet, hvis du satte opp 
        <filename>httpd.conf</filename> til å inneholde noe som</para>

      <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
&lt;/Location&gt;
</screen>

      <!-- @ENGLISH {{{
      <para>...then your repository is <quote>anonymously</quote>
        accessible to the world.  Until you configure some
        authentication and authorization policies, the Subversion
        repositories you make available via the
        <literal>Location</literal> directive will be generally
        accessible to everyone.  In other words,</para>
      @ENGLISH }}} -->
      <para>…er depotet ditt <quote>anonymt</quote> tilgjengelig for 
        hele verden.
        Inntil du setter opp regler for autentisering og autorisasjon, 
        vil Subversiondepotene som du gjør tilgjengelig via 
        <literal>Location</literal>-direktivet generelt være 
        tilgjengelig for alle.
        Med andre ord,</para>
      
      <itemizedlist>
        <listitem>
          <!-- @ENGLISH {{{
          <para>anyone can use their Subversion client to checkout a
            working copy of a repository URL (or any of its
            subdirectories),</para>
          @ENGLISH }}} -->
          <para>alle kan bruke Subversionklienten sin til å hente ut e 
            arbeidskopi av en URL i depotet (eller enhver underkatalog 
            under det),</para>
        </listitem>
        <listitem>
          <!-- @ENGLISH {{{
          <para>anyone can interactively browse the repository's
            latest revision simply by pointing their web browser to
            the repository URL, and</para>
          @ENGLISH }}} -->
          <para>alle kan interaktivt bla igjennom depotets seneste 
            revisjon ved å bare gå til depot-URLen med nettleseren, 
            og</para>
        </listitem>
        <listitem>
          <!-- @ENGLISH {{{
          <para>anyone can commit to the repository.</para>
          @ENGLISH }}} -->
          <para>alle kan foreta innlegginger i depotet.</para>
        </listitem>
      </itemizedlist>

      <sect3 id="svn.serverconfig.httpd.authn.basic">
        <!-- @ENGLISH {{{
        <title>Basic HTTP Authentication</title>
        @ENGLISH }}} -->
        <title>Enkel HTTP-autentisering</title>
        
        <!-- @ENGLISH {{{
        <para>The easiest way to authenticate a client is via the
          HTTP Basic authentication mechanism, which simply uses a
          username and password to verify that a user is who she says
          she is.  Apache provides an <command>htpasswd</command>
          utility for managing the list of acceptable usernames and
          passwords, those to whom you wish to grant special access to
          your Subversion repository.  Let's grant commit access to
          Sally and Harry.  First, we need to add them to the password
          file.</para>
        @ENGLISH }}} -->
        <para>Den enkleste måten å autentisere en klient er via den 
          grunnleggende HTTP-autentiseringsmekanismen som rett og slett 
          bruker et brukernavn og passord for å kontrollere at en bruker 
          er den som hun sier at hun er.
          Apache har et program kalt <command>htpasswd</command> for å 
          vedlikeholde listen med akseptable brukernavn og passord for 
          de som du vil gi spesialtilgang til Subversiondepotet ditt.
          La oss gi Sally og Harry tilgang til å legge inn forandringer 
          i depotet.
          Først må vi legge dem til passordfilen.</para>
    
        <!-- @ENGLISH {{{
        <screen>
$ ### First time: use -c to create the file
$ ### Use -m to use MD5 encryption of the password, which is more secure
$ htpasswd -cm /etc/svn-auth-file harry
New password: ***** 
Re-type new password: *****
Adding password for user harry
$ htpasswd -m /etc/svn-auth-file sally
New password: *******
Re-type new password: *******
Adding password for user sally
$
</screen>
        @ENGLISH }}} -->
        <screen>
$ ### Første gang: Bruk -c for å opprette filen
$ ### Bruk -m for å bruke MD5-kryptering av passordet, noe som er sikrere
$ htpasswd -cm /etc/svn-passord-fil harry
New password: ***** 
Re-type new password: *****
Adding password for user harry
$ htpasswd -m /etc/svn-passord-fil sally
New password: *******
Re-type new password: *******
Adding password for user sally
$
</screen>

        <!-- @ENGLISH {{{
        <para>Next, you need to add some more
          <filename>httpd.conf</filename> directives inside your
          <literal>Location</literal> block to tell Apache what to do
          with your new password file.  The
          <literal>AuthType</literal> directive specifies the type of
          authentication system to use.  In this case, we want to
          specify the <literal>Basic</literal> authentication system.
          <literal>AuthName</literal> is an arbitrary name that you
          give for the authentication domain.  Most browsers will
          display this name in the pop-up dialog box when the browser
          is querying the user for his name and password.  Finally,
          use the <literal>AuthUserFile</literal> directive to specify
          the location of the password file you created using
          <command>htpasswd</command>.</para>
        @ENGLISH }}} -->
        <para>Det neste som du må gjøre er å legge til noen flere 
          <filename>httpd.conf</filename>-direktiver inne i 
          <literal>Location</literal>-blokken for å fortelle Apache hva 
          den skal gjøre med den nye passordfilen.
          <literal>AuthType</literal>-direktivet spesifiserer hvilken 
          type autentiseringssystem som skal brukes.
          I dette tilfellet vil vi spesifisere 
          <literal>Basic</literal>-autentiseringssystemet.
          <literal>AuthName</literal> er et vilkårlig navn som du angir 
          for autentiseringsområdet.
          De fleste nettleserne vil vise dette navnet i et 
          oppsprettsvindu når nettleseren spør brukeren etter navn og 
          passord.
          Til sist, bruk <literal>AuthUserFile</literal>-direktivet for 
          å angi plasseringen til passordfilen som du opprettet ved å 
          bruke <command>htpasswd</command>.</para>
    
        <!-- @ENGLISH {{{
        <para>After adding these three directives, your
          <literal>&lt;Location&gt;</literal> block should look
          something like this:</para>
        @ENGLISH }}} -->
        <para>Etter at du har lagt til disse tre direktivene, skal 
          <literal>&lt;Location&gt;</literal>-blokken din se ut omtrent 
          som dette:</para>
    
        <!-- @ENGLISH {{{
        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /etc/svn-auth-file
&lt;/Location&gt;
</screen>
        @ENGLISH }}} -->
        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  AuthType Basic
  AuthName "Subversiondepot"
  AuthUserFile /etc/svn-passord-fil
&lt;/Location&gt;
</screen>

        <!-- @ENGLISH {{{
        <para>This <literal>&lt;Location&gt;</literal> block is not
          yet complete, and will not do anything useful.  It's merely
          telling Apache that whenever authorization is required,
          Apache should harvest a username and password from the
          Subversion client.  What's missing here, however, are
          directives that tell Apache <emphasis>which</emphasis> sorts
          of client requests require authorization.  Wherever
          authorization is required, Apache will demand
          authentication as well.  The simplest thing to do is protect
          all requests.  Adding <literal>Require valid-user</literal>
          tells Apache that all requests require an authenticated
          user:</para>
        @ENGLISH }}} -->
        <para>Denne <literal>&lt;Location&gt;</literal>-blokken er ikke 
          komplett enda, og vil ikke gjøre noe nyttig.
          Den forteller bare Apache at hver gang det kreves autorisasjon 
          skal Apache hente et brukernavn og passord fra 
          Subversionklienten.
          Det som mangler her er direktiver som forteller Apache 
          <emphasis>hvilke</emphasis> typer klientforespørsler som 
          krever autorisasjon.
          Der autorisasjon kreves, vil Apache også forlange 
          autentisering.
          Den enkleste tingen er å beskytte alle forespørsler.
          Ved å legge til <literal>Require valid-user</literal> 
          forteller vi Apache at alle forespørsler må komme fra en 
          autentisert bruker:</para>

        <!-- @ENGLISH {{{
        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /etc/svn-auth-file
  Require valid-user
&lt;/Location&gt;
</screen>
        @ENGLISH }}} -->
        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  AuthType Basic
  AuthName "Subversiondepot"
  AuthUserFile /etc/svn-passord-fil
  Require valid-user
&lt;/Location&gt;
</screen>

        <!-- @ENGLISH {{{
        <para>Be sure to read the next section (<xref
          linkend="svn.serverconfig.httpd.authz"/>) for more detail on the
          <literal>Require</literal> directive and other ways to set
          authorization policies.</para>
        @ENGLISH }}} -->
        <para>Pass på å lese den neste seksjonen (<xref 
          linkend="svn.serverconfig.httpd.authz"/>) for flere detaljer 
          om <literal>Require</literal>-direktivet og andre måter å 
          sette opp autorisasjonsregler på.</para>

        <!-- @ENGLISH {{{
        <para>One word of warning: HTTP Basic Auth passwords pass in
          very nearly plain-text over the network, and thus are
          extremely insecure.  If you're worried about password
          snooping, it may be best to use some sort of SSL encryption,
          so that clients authenticate via <literal>https://</literal>
          instead of <literal>http://</literal>; at a bare minimum,
          you can configure Apache to use a self-signed server
          certificate.
          <footnote>
            <para>While self-signed server certificates are still
              vulnerable to a <quote>man in the middle</quote> attack,
              such an attack is still much more difficult for a casual
              observer to pull off, compared to sniffing unprotected
              passwords.</para>
          </footnote>
          Consult Apache's documentation (and OpenSSL documentation)
          about how to do that.</para>
        @ENGLISH }}} -->
        <para>En advarsel:
          <!-- ¤ --><quote>HTTP Basic Auth</quote>-passord blir sendt 
          omtrent i klartekst over nettverket, og er derfor ekstremt 
          usikkert.
          Hvis du er bekymret for passordsniffing, er det best å bruke 
          en form for SSL-kryptering, så klienter autentiserer via 
          <literal>https://</literal> istedenfor 
          <literal>http://</literal>; som et <!-- ¤ -->minimum kan du 
          sette opp Apache til å bruke et selvsignert 
          sertifikat.<footnote>
            <para>Selv om selvsignerte &server;sertifikater også er 
              sårbare for <quote>mann-i-midten</quote>-angrep, vil et 
              slikt angrep for en vanlig observatør være mye 
              vanskeligere å få til, sammenlignet med å sniffe 
              ubeskyttede passord</para>
          </footnote>
          Konsulter Apaches dokumentasjon (og dokmentasjon om OpenSSL) 
          om hvordan det gjøres.</para>

      </sect3>


      <sect3 id="svn.serverconfig.httpd.authn.sslcerts">
        <!-- @ENGLISH {{{
        <title>SSL Certificate Management</title>
        @ENGLISH }}} -->
        <title>Håndtering av SSL-sertifikater</title>
        
        <!-- @ENGLISH {{{
        <para>Businesses that need to expose their repositories for access
          outside the company firewall should be conscious of the
          possibility that unauthorized parties could be
          <quote>sniffing</quote> their network traffic.  SSL makes
          that kind of unwanted attention less likely to result in
          sensitive data leaks.</para>
        @ENGLISH }}} -->
        <para>Forretninger som har behov for å utsette depotene for 
          tilgang fra utsiden av firmabrannveggen bør være bevisst på 
          muligheten for at uautoriserte parter kan 
          <quote>sniffe</quote> nettverkstrafikken deres.
          SSL minsker sjansen for at denne formen for uønsket 
          oppmerksomhet resulterer i sensitive datalekkasjer.</para>

        <!-- @ENGLISH {{{
        <para>If a Subversion client is compiled to use OpenSSL, then
          it gains the ability to speak to an Apache server via
          <literal>https://</literal> URLs.  The Neon library used by
          the Subversion client is not only able to verify server
          certificates, but can also supply client certificates when
          challenged.  When the client and server have exchanged SSL
          certificates and successfully authenticated one another, all
          further communication is encrypted via a session key.</para>
        @ENGLISH }}} -->
        <para>Hvis en Subversionklient er kompilert for å kunne bruke 
          OpenSSL, gir det muligheten til å snakke til en Apache&server; 
          via <literal>http://</literal>-URLer.
          Neon-biblioteket som brukes av Subversionklienten er ikke bare 
          i stand til å kontrollere &server;sertifikater, men kan også 
          oppgi klientsertifikater når den blir spurt om det.
          Når klienten og &the_server; har vekslet SSL-sertifikater og 
          klart å autentisere hverandre, vil all videre kommunikasjon 
          bli kryptert med en sesjonsnøkkel.</para>

        <!-- @ENGLISH {{{
        <para>It's beyond the scope of this book to describe how to
          generate client and server certificates, and how to
          configure Apache to use them.  Many other books, including
          Apache's own documentation, describe this task.  But what
          <emphasis>can</emphasis> be covered here is how to manage
          server and client certificates from an ordinary Subversion
          client.</para>
        @ENGLISH }}} -->
        <para>Det er utenfor temaet for denne boken å beskrive hvordan 
          man lager klient- og &server;sertifikater, og hvordan Apache 
          settes opp for å bruke dem.
          Mange andre bøker, inkludert Apaches egen dokumentasjon, 
          beskriver denne oppgaven.
          Men det som <emphasis>kan</emphasis> bli dekket her er hvordan 
          man vedlikeholder &server;- og klientsertifikater <!-- ¤ 
          Kanskje det blir bedre med «for» her? -->fra en vanlig 
          Subversionklient.</para>

        <!-- @ENGLISH {{{
        <para>When speaking to Apache via <literal>https://</literal>,
          a Subversion client can receive two different types of
          information:</para>
        @ENGLISH }}} -->
        <para>Mens det snakkes med Apache via 
          <literal>https://</literal> kan en Subversionklient motta to 
          typer informasjon:</para>

        <itemizedlist>
          <!-- @ENGLISH {{{
          <listitem><para>a server certificate</para></listitem>
          <listitem><para>a demand for a client certificate</para></listitem>
          @ENGLISH }}} -->
          <listitem>
            <para>et &server;sertifikat</para>
          </listitem>
          <listitem>
            <para>krav om et klientsertifikat</para>
          </listitem>
        </itemizedlist>

        <!-- @ENGLISH {{{
        <para>If the client receives a server certificate, it needs to
          verify that it trusts the certificate: is the server really
          who it claims to be?  The OpenSSL library does this by
          examining the signer of the server certificate, or
          <firstterm>certifying authority</firstterm> (CA).  If
          OpenSSL is unable to automatically trust the CA, or if some
          other problem occurs (such as an expired certificate or
          hostname mismatch), the Subversion command-line client will
          ask you whether you want to trust the server certificate
          anyway:</para>
        @ENGLISH }}} -->
        <para>Hvis klienten mottar et &server;sertifikat, må den sjekke 
          at den stoler på sertifikatet – er &the_server; virkelig den 
          som den påstår at den er?
          OpenSSL-biblioteket gjør dette ved å undersøke <!-- ¤ Ah, fint 
          ord. Eller har man ikke lov å si det? -->signatøren av 
          &server;sertifikatet eller 
          <firstterm>godkjenningsinstansen</firstterm> – 
          <foreignphrase>certifying authority</foreignphrase> (CA).
          Hvis OpenSSL ikke er i stand til å automatisk stole på <!-- ¤ 
          Eller er det bedre å bruke CA her? -->godkjenningsinstansen, 
          eller hvis et annet problem oppstår (som et utgått sertifikat 
          eller at &server;navnet ikke stemmer), vil <!-- ¤ Dæsken for 
          et ord. Bør det deles opp? -->Subversionkommandolinjeklienten 
          vil spørre deg om du vil stole på &server;sertifikatet 
          uansett:</para>

        <!-- @ENGLISH {{{
        <screen>
$ svn list https://host.example.com/repos/project

Error validating server certificate for 'https://host.example.com:443':
 - The certificate is not issued by a trusted authority. Use the
   fingerprint to validate the certificate manually!
Certificate information:
 - Hostname: host.example.com
 - Valid: from Jan 30 19:23:56 2004 GMT until Jan 30 19:23:56 2006 GMT
 - Issuer: CA, example.com, Sometown, California, US
 - Fingerprint: 7d:e1:a9:34:33:39:ba:6a:e9:a5:c4:22:98:7b:76:5c:92:a0:9c:7b

(R)eject, accept (t)emporarily or accept (p)ermanently?
</screen>
        @ENGLISH }}} -->
        <!-- ¤ --><screen>
$ svn list https://&server;.example.com/repos/prosjekt

Error validating server certificate for 'https://&server;.example.com:443':
 - The certificate is not issued by a trusted authority. Use the
   fingerprint to validate the certificate manually!
Certificate information:
 - Hostname: &server;.example.com
 - Valid: from Jan 30 19:23:56 2004 GMT until Jan 30 19:23:56 2006 GMT
 - Issuer: CA, example.com, Sometown, California, US
 - Fingerprint: 7d:e1:a9:34:33:39:ba:6a:e9:a5:c4:22:98:7b:76:5c:92:a0:9c:7b

(R)eject, accept (t)emporarily or accept (p)ermanently?
</screen>

        <!-- @ENGLISH {{{
        <para>This dialogue should look familiar; it's essentially the
          same question you've probably seen coming from your web
          browser (which is just another HTTP client like Subversion!).
          If you choose the (p)ermanent option, the server certificate
          will be cached in your private run-time
          <filename>auth/</filename> area in just the same way your
          username and password are cached (see <xref
          linkend="svn.serverconfig.netmodel.credcache"/>).  If cached,
          Subversion will automatically remember to trust this certificate
          in future negotiations.</para>
        @ENGLISH }}} -->
        <para>Denne dialogen skulle se kjent ut, det er hovedsaklig det 
          samme spørsmålet som du har sett i nettleseren din (som jo 
          bare er en annen HTTP-klient lik Subversion!).
          Hvis du velger det (p)ermanente valget, vil 
          &server;sertifikatet bli lagret i ditt private 
          <filename>auth/</filename>-område som brukes under kjøring på 
          omtrent den samme måten som brukernavnet og passordet ditt 
          blir lagret (se <xref 
          linkend="svn.serverconfig.netmodel.credcache"/>).
          Hvis det blir lagret, vil Subversion automatisk huske dette 
          sertifikatet i framtidige <!-- ¤ -->forhandlinger.</para>

        <!-- @ENGLISH {{{
        <para>Your run-time <filename>servers</filename> file also gives
          you the ability to make your Subversion client automatically
          trust specific CAs, either globally or on a per-host basis.
          Simply set the <literal>ssl-authority-files</literal>
          variable to a semicolon-separated list of PEM-encoded CA
          certificates:</para>
        @ENGLISH }}} -->
        <para><filename>servers</filename>-filen som brukes under 
          kjøring gir deg også muligheten til å la Subversionklienten 
          automatisk stole på spesifikke <!-- ¤ Eller bruke CA? 
          -->godkjenningsinstanser, enten globalt eller på en <!-- ¤ 
          --><quote>per &server;</quote>-basis.
          Sett ganske enkelt variabelen 
          <literal>ssl-authority-files</literal> til en 
          semikolonseparert liste med PEM-kodede sertifikater:</para>

        <!-- @ENGLISH {{{
        <screen>
[global]
ssl-authority-files = /path/to/CAcert1.pem;/path/to/CAcert2.pem
</screen>
        @ENGLISH }}} -->
        <screen>
[global]
ssl-authority-files = /sti/til/CAcert1.pem;/sti/til/CAcert2.pem
</screen>
        
        <!-- @ENGLISH {{{
        <para>Many OpenSSL installations also have a pre-defined set
          of <quote>default</quote> CAs that are nearly universally
          trusted.  To make the Subversion client automatically trust
          these standard authorities, set the
          <literal>ssl-trust-default-ca</literal> variable to
          <literal>true</literal>.</para>
        @ENGLISH }}} -->
        <para>Mange OpenSSL-installasjoner har også et forhåndsdefinert 
          sett av <quote>standardiserte</quote> godkjenningsinstanser 
          som det stoles omtrent universelt på.
          Får å få Subversionklienten til å automatisk stole på disse 
          standardautoritetene, sett variabelen 
          <literal>ssl-trust-default-ca</literal> til 
          <literal>true</literal>.</para>

        <!-- @ENGLISH {{{
        <para>When talking to Apache, a Subversion client might also
          receive a challenge for a client certificate.  Apache is
          asking the client to identify itself: is the client really
          who it says it is?  If all goes correctly, the Subversion
          client sends back a private certificate signed by a CA that
          Apache trusts.  A client certificate is usually stored on
          disk in encrypted format, protected by a local password.
          When Subversion receives this challenge, it will ask you for
          both a path to the certificate and the password which
          protects it:</para>
        @ENGLISH }}} -->
        <para>Mens den snakker med Apache, kan en Subversionklient også 
          motta et krav om et klientsertifikat.
          Apache spør klienten om å identifisere seg selv:
          Er klienten virkelig den som den sier at den er?
          Hvis alt går riktig for seg, sender Subversionklienten tilbake 
          et privat sertifikat signert av en godkjenningsinstans som 
          Apache stoler på.
          Et klientsertifikat blir vanligvis lagret på disken i et 
          kryptert format, beskyttet av et lokalt passord.
          Når Subversion mottar denne utfordringen, vil den spørre deg 
          etter både en sti til sertifikatet og passordet som beskytter 
          det:</para>

        <!-- @ENGLISH {{{
        <screen>
$ svn list https://host.example.com/repos/project

Authentication realm: https://host.example.com:443
Client certificate filename: /path/to/my/cert.p12
Passphrase for '/path/to/my/cert.p12':  ********
&hellip;
</screen>
        @ENGLISH }}} -->
        <screen>
$ svn list https://&server;.example.com/repos/prosjekt

Authentication realm: https://&server;.example.com:443
Client certificate filename: /sti/til/mitt/cert.p12
Passphrase for '/sti/til/mitt/cert.p12':  ********
…
</screen>

        <!-- @ENGLISH {{{
        <para>Notice that the client certificate is a
          <quote>p12</quote> file.  To use a client certificate with
          Subversion, it must be in PKCS#12 format, which is a
          portable standard.  Most web browsers are already able to
          import and export certificates in that format.   Another
          option is to use the OpenSSL command-line tools to convert
          existing certificates into PKCS#12.</para>
        @ENGLISH }}} -->
        <para>Legg merke til at klientsertifikatet er en 
          <quote>p12</quote>-fil.
          For å bruke et klientsertifikat med Subversion, må det være i 
          PKCS#12-format som er en portabel standard.
          De fleste nettlesere klarer allerede å importere og eksportere 
          sertifikater i dette formatet.
          En annen mulighet er å bruke kommandolinjeverktøyene i OpenSSL 
          for å konvertere eksisterende sertifikater til PKCS#12.</para>

        <!-- @ENGLISH {{{
        <para>Again, the runtime <filename>servers</filename> file
          allows you to automate this challenge on a per-host basis.
          Either or both pieces of information can be described in
          runtime variables:</para>
        @ENGLISH }}} -->
        <para><filename>servers</filename>-filen som brukes under 
          kjøring lar deg automatisere denne <!-- ¤ -->utfordringen på 
          en per-&server;-basis.
          <!-- ¤ Either -->En av eller begge delene informasjon kan bli  
          beskrevet med kjørevariabler:</para>

        <!-- @ENGLISH {{{
        <screen>
[groups]
examplehost = host.example.com

[examplehost]
ssl-client-cert-file = /path/to/my/cert.p12
ssl-client-cert-password = somepassword
</screen>
        @ENGLISH }}} -->
        <screen>
[groups]
examplehost = &server;.example.com

[examplehost]
ssl-client-cert-file = /sti/til/mitt/cert.p12
ssl-client-cert-password = etellerannetpassord
</screen>

        <!-- @ENGLISH {{{
        <para>Once you've set the
          <literal>ssl-client-cert-file</literal> and
          <literal>ssl-client-cert-password</literal> variables, the
          Subversion client can automatically respond to a client
          certificate challenge without prompting you.
          <footnote>
            <para>More security-conscious folk might not want to store
              the client certificate password in the runtime
              <filename>servers</filename> file.</para>
          </footnote>
        </para>
        @ENGLISH }}} -->
        <para>Når du har satt variablene 
          <literal>ssl-client-cert-file</literal> og 
          <literal>ssl-client-cert-password</literal>, kan 
          Subversionklienten automatisk svare på en 
          klientsertifikatutfordring uten å spørre deg.<footnote>
            <para>Mer sikkerhetsbevisste folk vil kanskje ikke lagre 
              klientsertifikatpassordet i kjørefilen 
              <filename>servers</filename>.</para>
          </footnote></para>

      </sect3>

    </sect2>
    
    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.authz">
      <!-- @ENGLISH {{{
      <title>Authorization Options</title>
      @ENGLISH }}} -->
      <title>Autorisasjonsvalg</title>

      <!-- @ENGLISH {{{
      <para>At this point, you've configured authentication, but not
        authorization.  Apache is able to challenge clients and
        confirm identities, but it has not been told how to allow or
        restrict access to the clients bearing those identities.  This
        section describes two strategies for controlling access to
        your repositories.</para>
      @ENGLISH }}} -->
      <para>På dette punktet har du konfigurert autentisering, men ikke 
        autorisasjon.
        Apache er i stand til å utfordre klienter og godkjenne 
        identiteter, men er ikke blitt fortalt hvordan adgangen skal 
        begrenses eller hva disse klientene som har disse identitetene 
        skal få lov til.
        Denne seksjonen beskriver to strategier for å kontrollere 
        tilgangen til depotene dine.</para>

      <sect3 id="svn.serverconfig.httpd.authz.blanket">
        <!-- @ENGLISH {{{
        <title>Blanket Access Control</title>
        @ENGLISH }}} -->
        <title><!-- ¤ «Blanket». Tar en nødløsning til jeg finner en 
          grei oversettelse for det ordet. -->Adgangskontroll for hele 
          depotet</title>

        <!-- @ENGLISH {{{
        <para>The simplest form of access control is to authorize
          certain users for either read-only access to a repository,
          or read/write access to a repository.</para>
        @ENGLISH }}} -->
        <para>Den enkleste formen for adgangskontroll er å autorisere 
          visse brukere enten for <!-- ¤ -->leseaksess til et depot 
          eller lese/skrive-tilgang til et depot.</para>

        <!-- @ENGLISH {{{
        <para>You can restrict access on all repository operations by
          adding the <literal>Require valid-user</literal> directive
          to your <literal>&lt;Location&gt;</literal> block.  Using
          our previous example, this would mean that only clients that
          claimed to be either <literal>harry</literal> or
          <literal>sally</literal>, and provided the correct
          password for their respective username, would be allowed to
          do anything with the Subversion repository:</para>
        @ENGLISH }}} -->
        <para>Du kan begrense tilgangen til alle depotoperasjoner ved å 
          legge til <literal>Require valid-user</literal>-direktivet i 
          <literal>&lt;Location&gt;</literal>-blokken.
          Ved å bruke det foregående eksempelet vil dette bety at bare 
          klienter som påstår å være enten <literal>harry</literal> 
          eller <literal>sally</literal> og som oppga korrekt passord 
          for de respektive brukernavnene vil få tilgang til å gjøre 
          <!-- ¤ «anything» i denne sammenhengen -->noe med 
          Subversiondepotet:</para>
    
        <!-- @ENGLISH {{{
        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # how to authenticate a user
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file
  
  # only authenticated users may access the repository
  Require valid-user
&lt;/Location&gt;
</screen>
        @ENGLISH }}} -->
        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # hvordan brukeren autentiseres
  AuthType Basic
  AuthName "Subversiondepot"
  AuthUserFile /sti/til/brukerfil

  # bare autentiserte brukere får tilgang til depotet
  Require valid-user
&lt;/Location&gt;
</screen>

        <!-- @ENGLISH {{{
        <para>Sometimes you don't need to run such a tight ship.  For
          example, Subversion's own source code repository at
          <ulink url="http://svn.collab.net/repos/svn"/> allows anyone
          in the world to perform read-only repository tasks (like
          checking out working copies and browsing the repository with
          a web browser), but restricts all write operations to
          authenticated users.  To do this type of selective
          restriction, you can use the <literal>Limit</literal> and
          <literal>LimitExcept</literal> configuration directives.
          Like the <literal>Location</literal> directive, these blocks
          have starting and ending tags, and you would nest them
          inside your <literal>&lt;Location&gt;</literal>
          block.</para>
        @ENGLISH }}} -->
        <para>Noen ganger trenger du ikke å <!-- ¤ -->ha en like streng 
          adgangskontroll.
          Depotet til Subversions kildekodedepot på <ulink 
          url="http://svn.collab.net/repos/svn"/> tillater alle i verden 
          å utføre leseoperasjoner i depotet (som å hente ut 
          arbeidskopier og bla gjennom depotet med en nettleser), men 
          begrenser alle skriveoperasjoner til autentiserte brukere.
          For å få til denne typen selektiv begrensning kan du bruke 
          konfigurasjonsdirektivene <literal>Limit</literal> og 
          <literal>LimitExcept</literal>.
          I likhet med <literal>Location</literal>-direktivet har disse 
          blokkene start- og sluttelementer, og du legger dem inn i 
          <literal>&lt;Location&gt;</literal>-blokken.</para>
  
        <!-- @ENGLISH {{{
        <para>The parameters present on the <literal>Limit</literal>
          and <literal>LimitExcept</literal> directives are HTTP
          request types that are affected by that block.  For example,
          if you wanted to disallow all access to your repository
          except the currently supported read-only operations, you
          would use the <literal>LimitExcept</literal> directive,
          passing the <literal>GET</literal>,
          <literal>PROPFIND</literal>, <literal>OPTIONS</literal>, and
          <literal>REPORT</literal> request type parameters.  Then the
          previously mentioned <literal>Require valid-user</literal>
          directive would be placed inside the
          <literal>&lt;LimitExcept&gt;</literal> block instead of just
          inside the <literal>&lt;Location&gt;</literal> block.</para>
        @ENGLISH }}} -->
        <para>Parametrene som brukes sammen med direktivene 
          <literal>Limit</literal> og <literal>LimitExcept</literal> er 
          typer av HTTP-forespørsler som blir påvirket av den blokken.
          Hvis du for eksempel vil forby all tilgang til depotet unntatt 
          de foreløpig støttede leseoperasjonene, vil du bruke 
          <literal>LimitExcept</literal>-direktivet sammen med 
          forespørselstypene <literal>GET</literal>, 
          <literal>PROPFIND</literal>, <literal>OPTIONS</literal> og 
          <literal>REPORT</literal>.
          Deretter plasseres det tidligere nevnte direktivet 
          <literal>Require valid-user</literal> inne i 
          <literal>&lt;LimitExcept&gt;</literal>-blokken istedenfor bare 
          inne i <literal>&lt;Location&gt;</literal>-blokken.</para>
    
        <!-- @ENGLISH {{{
        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # how to authenticate a user
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file

  # For any operations other than these, require an authenticated user.
  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;
    Require valid-user
  &lt;/LimitExcept&gt;
&lt;/Location&gt;
</screen>
        @ENGLISH }}} -->
        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # hvordan brukeren skal autentiseres
  AuthType Basic
  AuthName "Subversiondepot"
  AuthUserFile /sti/til/brukerfil

  # For alle andre operasjoner enn disse kreves en autentisert bruker.
  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;
    Require valid-user
  &lt;/LimitExcept&gt;
&lt;/Location&gt;
</screen>

        <!-- @ENGLISH {{{
        <para>These are only a few simple examples.  For more in-depth
          information about Apache access control and the
          <literal>Require</literal> directive, take a look at the
          <literal>Security</literal> section of the Apache
          documentation's tutorials collection at <ulink
           url="http://httpd.apache.org/docs-2.0/misc/tutorials.html"/>.</para>
        @ENGLISH }}} -->
        <para>Dette er bare noen få enkle eksempler.
          For informasjon som går mer i dybden om Apaches 
          adgangskontroll og <literal>Require</literal>-direktivet, ta 
          en kikk på <literal>Security</literal>-seksjonen i 
          dokmentasjonssamlingen for Apache på <ulink
          url="http://httpd.apache.org/docs-2.0/misc/tutorials.html"/>.</para>
              

      </sect3>

      <sect3 id="svn.serverconfig.httpd.authz.perdir">
        <!-- @ENGLISH {{{
        <title>Per-Directory Access Control</title>
        @ENGLISH }}} -->
        <title>Adgangskontroll på katalognivå</title>

        <!-- @ENGLISH {{{
        <para>It's possible to set up finer-grained permissions using
          a second Apache httpd module,
          <command>mod_authz_svn</command>.  This module grabs the
          various opaque URLs passing from client to server, asks
          <command>mod_dav_svn</command> to decode them, and then
          possibly vetoes requests based on access policies defined in
          a configuration file.</para>
        @ENGLISH }}} -->
        <para>Det er mulig å sette opp mer <!-- ¤ -->finjusterte 
          rettigheter ved å bruke en annen Apache httpd-modul, 
          <command>mod_authz_svn</command>.
          Denne modulen <!-- ¤ grabs – «tar tak i», «grabber» (er det 
          dialekt?) eller noe annet. -->tar for seg de forskjellige <!-- 
          ¤ opaque --><quote>uklare</quote>
          URLene som blir sendt fra klienten til &the_server;, spør 
          <command>mod_dav_svn</command> om å dekode dem og avgjør etter 
          dette om forespørsler skal nektes, basert på tilgangsregler 
          som er definert i en konfigurasjonsfil.</para>

        <!-- @ENGLISH {{{
        <para>If you've built Subversion from source code,
          <command>mod_authz_svn</command> is automatically built
          and installed alongside <command>mod_dav_svn</command>.
          Many binary distributions install it automatically as well.
          To verify that it's installed correctly, make sure it comes
          right after <command>mod_dav_svn</command>'s
          <literal>LoadModule</literal> directive in
          <filename>httpd.conf</filename>:</para>
        @ENGLISH }}} -->
        <para>Hvis du har bygget Subversion fra kildekode, blir 
          <command>mod_authz_svn</command> automatisk bygget og 
          installert sammen med <command>mod_dav_svn</command>.
          Mange binærdistribusjoner installerer den også automatisk.
          For å kontrollere at den er riktig installert, pass på at den 
          kommer rett etter <command>mod_dav_svn</command>s 
          <literal>LoadModule</literal>-direktiv i 
          <filename>httpd.conf</filename>:</para>

        <screen>
LoadModule dav_module         modules/mod_dav.so
LoadModule dav_svn_module     modules/mod_dav_svn.so
LoadModule authz_svn_module   modules/mod_authz_svn.so
</screen>

        <!-- @ENGLISH {{{
        <para>To activate this module, you need to configure your
          <literal>Location</literal> block to use the
          <literal>AuthzSVNAccessFile</literal> directive, which
          specifies a file containing the permissions policy for paths
          within your repositories.  (In a moment, we'll discuss the
          format of that file.)</para>
        @ENGLISH }}} -->
        <para>For å aktivere denne modulen må du sette opp 
          <literal>Location</literal>-blokken til å bruke 
          <literal>AuthSVNAccessFile</literal>-direktivet, som 
          spesifiserer en fil som inneholder regler for rettigheter til 
          stier i depotene dine.
          (Vil vil diskutere formatet på denne filen om et 
          øyeblikk.)</para>

        <!-- @ENGLISH {{{
        <para>Apache is flexible, so you have the option to configure
          your block in one of three general patterns.  To begin,
          choose one of these basic configuration patterns.  (The
          examples below are very simple; look at Apache's own
          documentation for much more detail on Apache authentication
          and authorization options.)</para>
        @ENGLISH }}} -->
        <para>Apache er fleksibel, så du har muligheten til å sette opp 
          blokken etter ett av tre generelle mønstre.
          For å begynne, velg ett av disse grunnleggende 
          konfigurasjonsmønstrene.
          (Eksemplene nedenfor er veldig enkle; se på Apaches egen 
          dokumentasjon for mange flere detaljer om autentiserings- og 
          autorisasjonsvalg i Apache.)</para>

        <!-- @ENGLISH {{{
        <para>The simplest block is to allow open access to everyone.
          In this scenario, Apache never sends authentication
          challenges, so all users are treated as
          <quote>anonymous</quote>.</para>
        @ENGLISH }}} -->
        <para>Den enkleste blokken gir tilgang til alle.
          I dette scenariet sender Apache aldri 
          autentiseringsutfordringer, så alle brukerne blir behandlet 
          som anonyme.</para>

        <example id="svn.serverconfig.httpd.authz.perdir.ex-1">
          <!-- @ENGLISH {{{
          <title>A sample configuration for anonymous access.</title>
          @ENGLISH }}} -->
          <title>Et eksempel på oppsett for anonym tilgang.</title>
          <!-- @ENGLISH {{{
          <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # our access control policy
  AuthzSVNAccessFile /path/to/access/file                 
&lt;/Location&gt;
          </programlisting>
          @ENGLISH }}} -->
          <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # våre regler for tilgang
  AuthzSVNAccessFile /sti/til/aksessfil
&lt;/Location&gt;
          </programlisting>
        </example>

        <!-- @ENGLISH {{{
        <para>On the opposite end of the paranoia scale, you can
          configure your block to demand authentication from everyone.
          All clients must supply credentials to identify themselves.
          Your block unconditionally requires authentication via the
          <literal>Require valid-user</literal> directive, and defines
          a means to authenticate.</para>
        @ENGLISH }}} -->
        <para>I den andre enden av paranoiaskalaen kan du sette opp 
          blokken din til å forlange autentisering av alle.
          Alle klienter må oppgi legitimasjon for å identifisere seg.
          Blokken krever betingelsesløst autentisering via 
          <literal>Require valid-user</literal>-direktivet og definerer 
          en <!-- ¤ -->autentiseringsmåte.</para>

        <example id="svn.serverconfig.httpd.authz.perdir.ex-2">
          <!-- @ENGLISH {{{
          <title>A sample configuration for authenticated access.</title>
          @ENGLISH }}} -->
          <title>Eksempel på oppsett for autentisert tilgang.</title>
          <!-- @ENGLISH {{{
          <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /usr/local/svn
            
  # our access control policy
  AuthzSVNAccessFile /path/to/access/file                 
            
  # only authenticated users may access the repository
  Require valid-user
            
  # how to authenticate a user
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file                  
&lt;/Location&gt;
          </programlisting>
          @ENGLISH }}} -->
          <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # våre regler for tilgang
  AuthzSVNAccessFile /sti/til/aksessfil

  # kun autentiserte brukere får tilgang til depotet
  Require valid-user

  # hvordan brukeren skal autentiseres
  AuthType Basic
  AuthName "Subversiondepot"
  AuthUserFile /sti/til/brukerfil
&lt;/Location&gt;
          </programlisting>
        </example>

        <!-- @ENGLISH {{{
        <para>A third very popular pattern is to allow a combination
          of authenticated and anonymous access.  For example, many
          administrators want to allow anonymous users to read certain
          repository directories, but want only authenticated users to
          read (or write) more sensitive areas.  In this setup, all
          users start out accessing the repository anonymously.  If
          your access control policy demands a real username at any
          point, Apache will demand authentication from the client.
          To do this, you use both the <literal>Satisfy Any</literal>
          and <literal>Require valid-user</literal> directives
          together.</para>
        @ENGLISH }}} -->
        <para>Et tredje, meget populært mønster er å tillate en 
          kombinasjon av autentisert og anonym tilgang.
          For eksempel ønsker mange administratorer å tillate alle 
          anonyme brukere å lese visse depotkataloger, men vil at kun 
          autentiserte brukere kan lese (eller skrive til) mer sensitive 
          områder.
          Med dette oppsettet starter alle brukerne med å aksessere 
          depotet anonymt.
          Hvis reglene for adgangskontrollen på et eller annet punkt 
          krever et brukernavn, vil Apache forlange autentisering av 
          klienten.
          For å gjøre dette, bruker du både <literal>Satisfy 
          Any</literal> og <literal>Require 
          Valid-user</literal>-direktivene sammen.</para>

        <example id="svn.serverconfig.httpd.authz.perdir.ex-3">
          <!-- @ENGLISH {{{
          <title>A sample configuration for mixed
            authenticated/anonymous access.</title>
          @ENGLISH }}} -->
          <title>Eksempel på oppsett for blandet autentisert/anonym 
            tilgang.</title>
          <!-- @ENGLISH {{{
          <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /usr/local/svn
            
  # our access control policy
  AuthzSVNAccessFile /path/to/access/file                 
            
  # try anonymous access first, resort to real 
  # authentication if necessary.
  Satisfy Any
  Require valid-user
            
  # how to authenticate a user
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file                  
&lt;/Location&gt;
          </programlisting>
          @ENGLISH }}} -->
          <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # våre regler for tilgang
  AuthzSVNAccessFile /sti/til/aksessfil

  # prøv først anononym tilgang og fall tilbake på skikkelig 
  # autentisering hvis det er nødvendig.
  Satisfy Any
  Require valid-user

  # hvordan brukeren skal autentiseres
  AuthType Basic
  AuthName "Subversiondepot"
  AuthUserFile /sti/til/brukerfil
&lt;/Location&gt;
          </programlisting>
        </example>
        
        <!-- @ENGLISH {{{
        <para>Once your basic <literal>Location</literal> block is
          configured, you can create an access file and define some
          authorization rules in it.</para>
        @ENGLISH }}} -->
        <para>Når den grunnleggende <literal>Location</literal>-blokken 
          er satt opp, kan du opprette en aksessfil og definere noen 
          autorisasjonsregler i den.</para>

        <!-- @ENGLISH {{{
        <para>The syntax of the access file is the same familiar one
          used by <command>svnserve.conf</command> and the runtime
          configuration files.  Lines that start with a hash
          (<literal>#</literal>) are ignored.  In its simplest form,
          each section names a repository and path within it, and the
          authenticated usernames are the option names within each
          section.  The value of each option describes the user's
          level of access to the repository path: either
          <literal>r</literal> (read-only) or <literal>rw</literal>
          (read-write).  If the user is not mentioned at all, no
          access is allowed.</para>
        @ENGLISH }}} -->
        <para>Syntaksen til aksessfilnen er den samme kjente som brukes 
          av <command>svnserve.conf</command> og konfigurasjonsfilene 
          som brukes under kjøring.
          Linjer som starter med en hash (<literal>#</literal>) 
          ignoreres.
          I sin enkleste form <!-- ¤ -->navngir hver seksjon et depot og 
          en sti i det, og de autentiserte brukernavnene er <!-- ¤ 
          -->valgnavnene innenfor hver seksjon.
          Verdien til hvert valg beskriver brukerens adgangsnivå til 
          depotstien:
          Enten <literal>r</literal> (kun lesing) eller 
          <literal>rw</literal> (både skriving og lesing).
          Hvis brukeren ikke nevnes i det hele tatt, gis ingen tilgang i 
          det hele tatt.</para>

        <!-- @ENGLISH {{{
        <para>To be more specific: the value of the section-names are
          either of the form <literal>[repos-name:path]</literal> or
          the form <literal>[path]</literal>.  If you're using the
          <literal>SVNParentPath</literal> directive, then it's
          important to specify the repository names in your sections.
          If you omit them, then a section like
          <literal>[/some/dir]</literal> will match the path
          <filename>/some/dir</filename> in <emphasis>every</emphasis>
          repository.  If you're using the <literal>SVNPath</literal>
          directive, however, then it's fine to only define paths in
          your sections&mdash;after all, there's only one
          repository.</para>
        @ENGLISH }}} -->
        <para>For å være mer spesifikk:
          Verdien til seksjonsnavnene er enten på formen 
          <literal>[depotnavn:sti]</literal> eller på formen 
          <literal>[sti]</literal>.
          Hvis du bruker <literal>SVNParentPath</literal>-direktivet, er 
          det viktig å spesifisere depotnavnet i seksjonene dine.
          Hvis du utelater dem, vil en seksjon som 
          <literal>[en/katalog]</literal> samsvare med stien 
          <filename>en/katalog</filename> i <emphasis>hvert 
          eneste</emphasis> depot.
          Hvis du bruker imidlertid bruker 
          <literal>SVNPath</literal>-direktivet, er det greit å bare 
          definere stier i seksjonene dine — når alt kommer til alt, 
          finnes det bare ett depot.</para>
          
        <screen>
[calc:/branches/calc/bug-142]
harry = rw
sally = r
</screen>

        <!-- @ENGLISH {{{
        <para>In this first example, the user <literal>harry</literal> has
          full read and write access on the
          <filename>/branches/calc/bug-142</filename> directory in the
          <literal>calc</literal> repository, but the user
          <literal>sally</literal> has read-only access.  Any other
          users are blocked from accessing this directory.</para>
        @ENGLISH }}} -->
        <para>I dette første eksempelet har brukeren 
          <literal>harry</literal> full lese- og skrivetilgang i 
          katalogen <filename>/branches/calc/big-142</filename> i 
          <literal>calc</literal>-depotet, men brukeren 
          <literal>sally</literal> har kun lesetilgang.
          Alle andre brukere nektes tilgang til depotet.</para>

        <!-- @ENGLISH {{{
        <para>Of course, permissions are inherited from
          parent to child directory.  That means that we can specify a
          subdirectory with a different access policy for
          Sally:</para>
        @ENGLISH }}} -->
        <para>Alle tilganger arves selvfølgelig fra foreldrekataloger 
          til underkataloger.
          Dette betyr at vi kan spesifisere en underkatalog med en 
          forskjellig adgangsregel for Sally:</para>

        <!-- @ENGLISH {{{
        <screen>
[calc:/branches/calc/bug-142]
harry = rw
sally = r

# give sally write access only to the 'testing' subdir
[calc:/branches/calc/bug-142/testing]
sally = rw
</screen>
        @ENGLISH }}} -->
        <screen>
[calc:/branches/calc/bug-142]
harry = rw
sally = r

# gi sally skrivetilgang kun til underkatalogen «testing»
[calc:/branches/calc/bug-142/testing]
sally = rw
</screen>

        <!-- @ENGLISH {{{
        <para>Now Sally can write to the <filename>testing</filename>
          subdirectory of the branch, but can still only read other
          parts.  Harry, meanwhile, continues to have complete
          read-write access to the whole branch.</para>
        @ENGLISH }}} -->
        <para>Nå kan Sally skrive til underkatalogen 
          <filename>testing</filename> på grenen, men kan fortsatt bare 
          lese andre deler.
          Imens fortsetter Harry å ha både lese- og skrivetilgang til 
          hele grenen.</para>

        <!-- @ENGLISH {{{
        <para>It's also possible to explicitly deny permission to
          someone via inheritance rules, by setting the username
          variable to nothing:</para>
        @ENGLISH }}} -->
        <para>Det er også mulig å eksplisitt nekte <!-- ¤ -->adgang til 
          noen ved hjelp av <!-- ¤ -->arveregler, ved å sette 
          brukernavnvariabelen til ingenting:</para>

        <!-- @ENGLISH {{{
        <screen>
[calc:/branches/calc/bug-142]
harry = rw
sally = r

[calc:/branches/calc/bug-142/secret]
harry =
</screen>
        @ENGLISH }}} -->
        <screen>
[calc:/branches/calc/bug-142]
harry = rw
sally = r

[calc:/branches/calc/bug-142/hemmelig]
harry =
</screen>
        
        <!-- @ENGLISH {{{
        <para>In this example, Harry has read-write access to the
          entire <filename>bug-142</filename> tree, but has absolutely no
          access at all to the <filename>secret</filename>
          subdirectory within it.</para>
        @ENGLISH }}} -->
        <para>I dette eksempelet har Harry både lese- og skrivetilgang 
          til hele <filename>bug-142</filename>-treet, men har absolutt 
          ingen tilgang i det hele tatt til underkatalogen 
          <filename>hemmelig</filename> innenfor det.</para>

        <!-- @ENGLISH {{{
        <para>The thing to remember is that the most specific path
          always matches first.  The <command>mod_authz_svn</command>
          module tries to match the path itself, and then the parent
          of the path, then the parent of that, and so on.  The net
          effect is that mentioning a specific path in the accessfile
          will always override any permissions inherited from parent
          directories.</para>
        @ENGLISH }}} -->
        <para>Tingen å huske på er at den mest spesifikke stien alltid 
          samsvarer først.
          <command>mod_authz_svn</command>-modulen prøver selv å få 
          stien til å stemme, deretter forelderen til stien, så 
          forelderen til den, og så videre.
          Netteffekten er at det å nevne en spesifikk sti i aksessfilen 
          alltid vil overstyre alle rettigheter som er arvet fra 
          foreldrekataloger.</para>

        <!-- @ENGLISH {{{
        <para>By default, nobody has any access to the repository at
          all.  That means that if you're starting with an empty file,
          you'll probably want to give at least read permission to all
          users at the root of the repository.  You can do this by
          using the asterisk variable (<literal>*</literal>), which
          means <quote>all users</quote>:</para>
        @ENGLISH }}} -->
        <para>Som standard har ingen noen tilgang til depotet i det hele 
          tatt.
          Det betyr at hvis du starter med en tom fil, vil du 
          sannsynligvis ønske å i det minste gi leserettigheter til alle 
          brukere ved roten av depotet.
          Du kan gjøre dette ved å bruke asteriskvariabelen 
          (<literal>*</literal>), som betyr <quote>alle 
          brukere</quote>:</para>

        <screen>
[/]
* = r
</screen>

        <!-- @ENGLISH {{{
        <para>This is a common setup; notice that there's no
          repository name mentioned in the section name.  This makes
          all repositories world readable to all users, whether you're
          using <literal>SVNPath</literal> or
          <literal>SVNParentPath</literal>.  Once all users have
          read-access to the repositories, you can give explicit
          <literal>rw</literal> permission to certain users on specific
          subdirectories within specific repositories.</para>
        @ENGLISH }}} -->
        <para>Dette er et vanlig oppsett; legg merke til at det ikke 
          nevnes noen depotnavn i seksjonsnavnet.
          Dette gjør alle depotene fullstendig lesbare for alle 
          brukerne, enten du bruker <literal>SVNPath</literal> eller 
          <literal>SVNParentPath</literal>
          Når alle brukerne har lesetilgang til depotene, kan du gi 
          eksplisitt <literal>rw</literal>-rettigheter til visse brukere 
          i spesifikke underkataloger inne i spesifikke depoter.</para>

        <!-- @ENGLISH {{{
        <para>The asterisk variable (<literal>*</literal>) is also
          worth special mention here: it's the
          <emphasis>only</emphasis> pattern which matches an anonymous
          user.  If you've configured your <literal>Location</literal>
          block to allow a mixture of anonymous and authenticated
          access, all users start out accessing Apache anonymously.
          <command>mod_authz_svn</command> looks for a
          <literal>*</literal> value defined for the path being
          accessed;  if it can't find one, then Apache demands real
          authentication from the client.</para>
        @ENGLISH }}} -->
        <para>Asteriskvariabelen (<literal>*</literal>) er også verdt 
          litt spesiell omtale her:
          Det er det <emphasis>eneste</emphasis> mønsteret som samsvarer 
          med en anonym bruker.
          Hvis du har satt opp <literal>Location</literal>-blokken din 
          til å tillate en blanding av anonym og autentisert tilgang, 
          starter alle brukere med å aksessere Apache anonymt.
          <command>mod_authz_svn</command> ser etter en 
          <literal>*</literal>-verdi for stien som blir aksessert; hvis 
          den ikke finner noen, forlanger Apache skikkelig autentisering 
          fra klienten.</para>

        <!-- @ENGLISH {{{
        <para>The access file also allows you to define whole groups
          of users, much like the Unix <filename>/etc/group</filename>
          file:</para>
        @ENGLISH }}} -->
        <para>Aksessfilen lar deg også definere hele grupper med 
          brukere, ganske likt <filename>/etc/group</filename> på 
          Unix-systemer:</para>

        <!-- @ENGLISH {{{
        <screen>
[groups]
calc-developers = harry, sally, joe
paint-developers = frank, sally, jane
everyone = harry, sally, joe, frank, sally, jane
</screen>
        @ENGLISH }}} -->
        <screen>
[groups]
calc-utviklere = harry, sally, joe
paint-utviklere = frank, sally, jane
alle = harry, sally, joe, frank, sally, jane
</screen>

        <!-- @ENGLISH {{{
        <para>Groups can be granted access control just like users.
          Distinguish them with an <quote>at</quote> (<literal>@</literal>)
          prefix:</para>
        @ENGLISH }}} -->
        <para>Grupper kan bli gitt tilgang akkurat som brukere.
          Skill mellom dem ved å sette en krøllalfa 
          (<literal>@</literal>) foran gruppenavnet:</para>

        <!-- @ENGLISH {{{
        <screen>
[calc:/projects/calc]
@calc-developers = rw

[paint:/projects/paint]
@paint-developers = rw
jane = r 
</screen>
        @ENGLISH }}} -->
        <screen>
[calc:/prosjekter/calc]
@calc-utviklere = rw

[paint:/prosjekter/paint]
@paint-utviklere = rw
jane = r 
</screen>

        <!-- @ENGLISH {{{
        <para>Groups can also be defined to contain other
          groups:</para>
        @ENGLISH }}} -->
        <para>Grupper kan også bli definert til å inneholde andre 
          grupper:</para>

        <!-- @ENGLISH {{{
        <screen>
[groups]
calc-developers = harry, sally, joe
paint-developers = frank, sally, jane
everyone = @calc-developers, @paint-developers
</screen>
        @ENGLISH }}} -->
        <screen>
[groups]
calc-utviklere = harry, sally, joe
paint-utviklere = frank, sally, jane
alle = @calc-utviklere, @paint-utviklere
</screen>

        <!-- @ENGLISH {{{
        <para>...and that's pretty much all there is to it.</para>
        @ENGLISH }}} -->
        <para>…og det er omtrent det som er å si om den saken.</para>

      </sect3>

      <sect3 id="svn.serverconfig.httpd.authz.pathauthzoff">
        <!-- @ENGLISH {{{
        <title>Disabling Path-based Checks</title>
        @ENGLISH }}} -->
        <title>Slå av stibaserte kontroller</title>

        <!-- @ENGLISH {{{
        <para>The <command>mod_dav_svn</command> module goes through a
          lot of work to make sure that data you've marked
          <quote>unreadable</quote> doesn't get accidentally leaked.
          This means that it needs to closely monitor all of the paths
          and file-contents returned by commands like <command>svn
          checkout</command> or <command>svn update</command>
          commands.  If these commands encounter a path that isn't
          readable according to some authorization policy, then the
          path is typically omitted altogether.  In the case of
          history or rename tracing&mdash;e.g. running a command like
          <command>svn cat -r OLD foo.c</command> on a file that was
          renamed long ago&mdash;the rename tracking will simply halt
          if one of the object's former names is determined to be
          read-restricted.</para>
        @ENGLISH }}} -->
        <para><command>mod_dav_svn</command>-modulen går gjennom en 
          masse arbeid for å forsikre seg om at dataene som du har 
          markert som <quote>uleselig</quote> ikke blir lekket ved en 
          ulykke.
          Dette betyr at den må passe nøye på alle stiene og filinnhold 
          som blir returnert av kommandoer som <command>svn 
          checkout</command> eller <command>svn update</command>.
          Hvis disse kommandoene kommer over en sti som ikke er lesbar i 
          følge en eller annen autorisasjonsregel, blir stien <!-- ¤ 
          -->vanligvis totalt utelatt.
          Når det gjelder <!-- ¤ -->tråling av historien og navneskifter 
          – for eksempel å kjøre en kommando som <command>svn cat -r 
          GAMMELREV foo.c</command> på en fil som skiftet navn for lenge 
          siden – vil trålingen av navneskiftet ganske enkelt stoppe 
          hvis et av objektets tidligere navn blir anslått til å være 
          beskyttet mot lesing.</para>

        <!-- @ENGLISH {{{
        <para>All of this path-checking can sometimes be quite
          expensive, especially in the case of <command>svn
          log</command>.  When retrieving a list revisions, the server
          looks at every changed path in each revision and checks it
          for readability.  If an unreadable path is discovered, then
          it's omitted from the list of the revision's changed paths
          (normally seen with the <option>-&#64738;-verbose</option> option),
          and the whole log message is suppressed.  Needless to say,
          this can be time-consuming on revisions that affect a large
          number of files.  This is the cost of security: even if you
          haven't configured a module like
          <command>mod_authz_svn</command> at all, the
          <command>mod_dav_svn</command> module is still asking Apache
          <command>httpd</command> to run authorization checks on
          every path.  The <command>mod_dav_svn</command> module has
          no idea what authorization modules have been installed, so
          all it can do is ask Apache to invoke whatever might be
          present.</para>
        @ENGLISH }}} -->
        <para>Alle disse kontrollene av stier kan noen ganger være 
          ganske dyrekjøpte, spesielt i tilfellet med <command>svn 
          log</command>.
          Når det hentes en liste med revisjoner, ser &the_server; på 
          alle stier som har forandret seg i hver revisjon og sjekker om 
          stien er leselig.
          Hvis en uleselig sti blir funnet, utelates den fra listen med 
          forandrede stier i revisjonen (som man vanligvis ser med 
          <option>--verbose</option>-valget), og hele loggmeldingen blir 
          utelatt.
          Dette kan føre til at mye tid blir brukt på revisjoner som 
          påvirker et stort antall filer.
          Dette er prisen for sikkerhet:
          Selv om du ikke har satt opp en modul som 
          <command>mod_authz_svn</command> i det hele tatt, ber 
          <command>mod_dav_svn</command>-modulen fortsatt Apache 
          <command>httpd</command> om å kjøre autorisasjonssjekker på 
          hver eneste sti.
          <command>mod_dav_svn</command>-modulen har ingen formening om 
          hvilke autorisasjonsmoduler som er installert, så alt den kan 
          gjøre er å be Apache om å utføre alle som kan 
          eksistere.</para>

        <!-- @ENGLISH {{{
        <para>On the other hand, there's also an escape-hatch of
          sorts, one which allows you to trade security features for
          speed.  If you're not enforcing any sort of per-directory
          authorization (i.e. not using
          <command>mod_authz_svn</command> or similar module), then
          you can disable all of this path-checking.  In your
          <filename>httpd.conf</filename> file, use the
          <literal>SVNPathAuthz</literal> directive:</para>
        @ENGLISH }}} -->
        <para>På den annen side finnes det en slags <!-- ¤ escape-hatch 
          -->nødløsning for dette, en som lar deg bytte 
          sikkerhetsfunksjonalitet mot hastighet.
          Hvis du ikke gjennomfører noen form for katalogbasert 
          autorisasjon (det vil si at <command>mod_authz_svn</command> 
          eller en lignende modul ikke brukes) kan du slå av alt av 
          stikontroller.
          Bruk <literal>SVNPathAuthz</literal>-direktivet i 
          <filename>httpd.conf</filename>-filen:</para>

        <example id="svn.serverconfig.httpd.authz.pathauthzoff.ex-1">
          <!-- @ENGLISH {{{
          <title>Disabling path checks altogether</title>
          @ENGLISH }}} -->
          <title>Slå av alle filstikontroller</title>
          <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /usr/local/svn
            
  SVNPathAuthz off
&lt;/Location&gt;            
          </programlisting>
        </example>

        <!-- @ENGLISH {{{
        <para>The <literal>SVNPathAuthz</literal> directive is <quote>on</quote> by
          default.  When set <quote>off</quote>, all path-based
          authorization checking is disabled;
          <command>mod_dav_svn</command> stops invoking authorization
          checks on every path it discovers.</para>
        @ENGLISH }}} -->
        <para><literal>SVNPathAuthz</literal>-direktivet er 
          <quote>on</quote> (aktivt) som standard.
          Når det settes til <quote>off</quote>, slås all stibasert 
          autorisasjonskontroll av; <command>mod_dav_svn</command> lar 
          være å utføre autorisasjonssjekker på hver sti som den 
          finner.</para>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.extra">
      <!-- @ENGLISH {{{
      <title>Extra Goodies</title>
      @ENGLISH }}} -->
      <title><!-- ¤ -->Flere lure ting</title>

      <!-- @ENGLISH {{{
      <para>We've covered most of the authentication and authorization
        options for Apache and mod_dav_svn.  But there are a few other
        nice features that Apache provides.</para>
      @ENGLISH }}} -->
      <para>Vi har dekket mesteparten av autentiserings- og 
        autorisasjonsvalg for Apache og mod_dav_svn.
        Men det er noen andre fine ting som Apache tilbyr.</para>

      <sect3 id="svn.serverconfig.httpd.extra.browsing">
        <!-- @ENGLISH {{{
        <title>Repository Browsing</title>
        @ENGLISH }}} -->
        <title>Bla gjennom depotet</title>
        
        <!-- @ENGLISH {{{
        <para>One of the most useful benefits of an Apache/WebDAV
          configuration for your Subversion repository is that the
          youngest revisions of your versioned files and directories
          are immediately available for viewing via a regular web
          browser.  Since Subversion uses URLs to identify versioned
          resources, those URLs used for HTTP-based repository access
          can be typed directly into a Web browser.  Your browser will
          issue a <literal>GET</literal> request for that URL, and
          based on whether that URL represents a versioned directory
          or file, mod_dav_svn will respond with a directory listing
          or with file contents.</para>
        @ENGLISH }}} -->
        <para>En av de nyttigste fordelene med å bruke et 
          Apache/WebDAV-oppsett for Subversiondepotet ditt er at de 
          yngste revisjonene av de versjonerte filene og katalogene er 
          øyeblikkelig tilgjengelig for visning gjennom en vanlig 
          nettleser.
          Siden Subversion bruker URLer til å identifisere versjonerte 
          ressurser, kan disse URLene for HTTP-basert depottilgang bli 
          skrevet direkte inn i en nettleser.
          Nettleseren vil foreta en <literal>GET</literal>-forespørsel 
          for denne URLen, og avhengig om denne URLen representerer en 
          versjonert katalog eller fil vil mod_dav_svn svare med en 
          katalogutlisting eller innholdet av en fil.</para>

        <!-- @ENGLISH {{{
        <para>Since the URLs do not contain any information about
          which version of the resource you wish to see, mod_dav_svn
          will always answer with the youngest version.  This
          functionality has the wonderful side-effect that you can
          pass around Subversion URLs to your peers as references to
          documents, and those URLs will always point at the latest
          manifestation of that document.  Of course, you can even use
          the URLs as hyperlinks from other web sites, too.</para>
        @ENGLISH }}} -->
        <para>Siden URLene ikke inneholder noen informasjon om hvilken 
          versjon av ressursen du ønsker å se, vil mod_dav_svn alltid 
          svare med den yngste versjonen.
          Denne funksjonaliteten har den <!-- ¤ -->ytterst stilfulle 
          bieffekten at du kan sende Subversion-URLer til mottakere som 
          referanser til dokumenter, og disse URLene vil alltid peke til 
          den nyeste versjonen av dette dokumentet.
          Du kan selvfølgelig også til og med bruke URLene som 
          hyperlinker fra andre hjemmesider.</para>

        <!-- @ENGLISH {{{
        <para>You generally will get more use out of URLs to versioned
          files&mdash;after all, that's where the interesting content
          tends to lie.  But you might have occasion to browse a
          Subversion directory listing, where you'll quickly note that
          the generated HTML used to display that listing is very
          basic, and certainly not intended to be aesthetically
          pleasing (or even interesting).  To enable customization of
          these directory displays, Subversion provides an XML index
          feature.  A single <literal>SVNIndexXSLT</literal> directive
          in your repository's <literal>Location</literal> block of
          <filename>httpd.conf</filename> will instruct mod_dav_svn to
          generate XML output when displaying a directory listing, and
          to reference the XSLT stylesheet of your choice:</para>
        @ENGLISH }}} -->
        <para>Vanligvis vil du få mer ut av URLer til versjonerte filer 
          – det er jo der alt det interessante innholdet har for vane å 
          ligge.
          Men noen ganger må du bla direkte gjennom en katalogliste i 
          Subversion, og da legger du merke til at den genererte HTML-en 
          som brukes i utlistingen er ganske enkel, og i hvertfall ikke 
          ment å være en nytelse for øyet.
          For å gjøre det mulig å tilpasse disse katalogvisningene, har 
          Subversion en XML-basert <!-- ¤ -->innholdsfunksjonalitet.
          Et enkelt <literal>SVNIndexXSLT</literal>-direktiv i depotets 
          <literal>Location</literal>-blokk i 
          <filename>httpd.conf</filename> vil instruere mod_dav_svn til 
          å generere XML-data når den viser en katalogutlisting og 
          referere til XSLT-stilsettet som du har valgt:</para>
 
        <!-- @ENGLISH {{{
        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  SVNIndexXSLT "/svnindex.xsl"
  &hellip;
&lt;/Location&gt;
</screen>
        @ENGLISH }}} -->
        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  SVNIndexXSLT "/svnindex.xsl"
  …
&lt;/Location&gt;
</screen>

        <!-- @ENGLISH {{{
        <para>Using the <literal>SVNIndexXSLT</literal> directive and
          a creative XSLT stylesheet, you can make your directory
          listings match the color schemes and imagery used in other
          parts of your website.  Or, if you'd prefer, you can use the
          sample stylesheets provided in the Subversion source
          distribution's <filename>tools/xslt/</filename> directory.
          Keep in mind that the path provided to the
          <literal>SVNIndexXSLT</literal> directory is actually a URL
          path&mdash;browsers need to be able to read your stylesheets
          in order to make use of them!</para>
        @ENGLISH }}} -->
        <para>Ved å bruke <literal>SVNIndexXSLT</literal>-direktivet og 
          et kreativt XSLT-stilsett, kan du få katalogutlistingene til å 
          følge fargevalgene og utseendet til andre deler av hjemmesiden 
          din.
          Eller du kan bruke eksempelstilsettene som ligger i 
          Subversionkildekodens <filename>tools/xslt</filename>-katalog.
          Husk på at stien som gis til 
          <literal>SVNIndexXSLT</literal>-direktivet egentlig er en URL 
          — nettlesere må være i stand til å lese stilsettene dine for å 
          kunne bruke dem!</para>

        <sidebar>
          <!-- @ENGLISH {{{
          <title>Can I view older revisions?</title>
          @ENGLISH }}} -->
          <title>Kan jeg se på eldre revisjoner?</title>

          <!-- @ENGLISH {{{
          <para>With an ordinary web browser?  In one word: nope.  At
            least, not with <command>mod_dav_svn</command> as your
            only tool.</para>
          @ENGLISH }}} -->
          <para>Men en vanlig nettleser?
            Ett ord:
            Niks.
            I det minste ikke bare med <command>mod_dav_svn</command> 
            som det eneste verktøyet.</para>

          <!-- @ENGLISH {{{
          <para>Your web browser only speaks ordinary HTTP.  That
            means it only knows how to GET public URLs, which
            represent the latest versions of files and directories.
            According to the WebDAV/DeltaV spec, each server defines a
            private URL syntax for older versions of resources, and
            that syntax is opaque to clients.  To find an older
            version of a file, a client must follow a specific
            procedure to <quote>discover</quote> the proper URL; the
            procedure involves issuing a series of WebDAV PROPFIND
            requests and understanding DeltaV concepts.  This is
            something your web browser simply can't do.</para>
          @ENGLISH }}} -->
          <para>Nettleseren din snakker bare vanlig HTTP.
            Det betyr at den bare vet hvordan den skal <!-- ¤ literal 
            --><literal>GET</literal> offentlige URLer, som 
            representerer den seneste versjonen av filer og kataloger.
            I henhold til WebDAV/DeltaV-sepsifikasjonen definerer hver 
            &server; en privat URL-syntaks for eldre versjoner av 
            ressurser, og denne syntaksen er <!-- ¤ -->skjult for 
            klienter.
            For å finne en eldre versjon av en fil, må klienten følge en 
            spesifikk prosedyre for å <quote>avdekke</quote> den 
            fullstendige URLen; prosedyren involverer å sende en serie 
            <literal>PROFIND</literal> WebDAV-forespørsler og forstå 
            konseptene omkring DeltaV.
            Dette er noe som nettleseren din rett og slett ikke kan 
            gjøre.</para>

          <!-- @ENGLISH {{{
          <para>So to answer the question, one obvious way to see
            older revisions of files and directories is by passing the
            <option>-&#64738;-revision</option> argument to the <command>svn
            list</command> and <command>svn cat</command> commands.
            To browse old revisions with your web browser, however,
            you can use third-party software.  A good example of this
            is ViewVC (<ulink url="http://viewvc.tigris.org/"/>).
            ViewVC was originally written to display CVS repositories
            through the web,
            <footnote>
              <para>Back then, it was called <quote>ViewCVS</quote>.</para>
            </footnote>
            and the latest bleeding-edge versions (at
            the time of writing) are able to understand Subversion
            repositories as well.</para>
          @ENGLISH }}} -->
          <para>Så for å svare på spørsmålet, en åpenbar måte å se på 
            eldre revisjoner av filer og kataloger er å gi 
            <option>--revision</option>-argumentet til kommandoene 
            <command>svn list</command> og <command>svn cat</command>.
            Men for å bla gjennom gamle revisjoner med nettleseren må du 
            bruke tredjeparts programvare.
            Et godt eksempel på dette er ViewVC (<ulink 
            url="http://viewvc.tigris.org/"/>).
            ViewVC ble egentlig skrevet for å vise CVS-depoter på <!-- ¤ 
            Merkes fordi den er kontroversiell. -->web,<footnote>
              <para>På den tiden ble den kalt 
                <quote>ViewCVS</quote>.</para>
            </footnote> og de aller siste <!-- ¤ bleeding-edge --> 
            versjonene (når dette skrives) forstår seg også på 
            Subversiondepoter.</para>
        </sidebar>

      </sect3>

      <sect3 id="svn.serverconfig.httpd.extra.other">
        <!-- @ENGLISH {{{
        <title>Other Features</title>
        @ENGLISH }}} -->
        <title>Annen funksjonalitet</title>
        
        <!-- @ENGLISH {{{
        <para>Several of the features already provided by Apache in
          its role as a robust Web server can be leveraged for
          increased functionality or security in Subversion as well.
          Subversion communicates with Apache using Neon, which is a
          generic HTTP/WebDAV library with support for such mechanisms
          as SSL (the Secure Socket Layer, discussed earlier) and
          Deflate compression (the same algorithm used by the
          <command>gzip</command> and <command>PKZIP</command>
          programs to <quote>shrink</quote> files into smaller chunks
          of data).  You need only to compile support for the features
          you desire into Subversion and Apache, and properly
          configure the programs to use those features.</para>
        @ENGLISH }}} -->
        <para>Mye av funksjonliteten som Apache tilbyr i sin rolle som 
          en robust web&server; kan i tillegg bli <!-- ¤ Resten av 
          setninga. --> satt opp for økt funksjonalitet eller sikkerhet 
          i Subversion.
          Subversion kommuniserer med Apache ved bruk av Neon, som er et 
          generelt HTTP/WebDAV-bibliotek med støtte for mekanismer som 
          SSL (<foreignphrase>Secure Socket Layer</foreignphrase>, som 
          tidligere diskutert) og <quote>deflate</quote>-kompresjon (den 
          samme algoritmen som brukes av programmene 
          <command>gzip</command> og <command>PKZIP</command> for å 
          minske størrelsen på filer).
          Du trenger bare å kompilere støtte for den funksjonaliteten du 
          ønsker inn i Subversion og Apache og sette programmene opp for 
          å bruke denne funksjonaliteten.<quote></quote></para>
    
        <!-- @ENGLISH {{{
        <para>Deflate compression places a small burden on the client
          and server to compress and decompress network transmissions
          as a way to minimize the size of the actual transmission.
          In cases where network bandwidth is in short supply, this
          kind of compression can greatly increase the speed at which
          communications between server and client can be sent.  In
          extreme cases, this minimized network transmission could be
          the difference between an operation timing out or completing
          successfully.</para>
        @ENGLISH }}} -->
        <para><quote>Deflate</quote>-pakking øker belastningen litt på 
          klienten og &the_server; for å pakke og pakke opp overføringer 
          på nettverket som en måte å minske størrelsen på den faktiske 
          overføringen.
          I tilfeller med liten båndbredde kan dette virkelig øke 
          hastigheten på kommunikasjonen mellom &the_server; og 
          klienten.
          I ekstreme tilfeller kan denne minskede nettverksoverføringen 
          utgjøre forskjellen på enten å få et tidsavbrudd eller å 
          fullføre operasjonen.</para>
  
        <!-- @ENGLISH {{{
        <para>Less interesting, but equally useful, are other features
          of the Apache and Subversion relationship, such as the
          ability to specify a custom port (instead of the default
          HTTP port 80) or a virtual domain name by which the
          Subversion repository should be accessed, or the ability to
          access the repository through a proxy.  These things are all
          supported by Neon, so Subversion gets that support for
          free.</para>
        @ENGLISH }}} -->
        <para>Mindre interessante, men like nyttige funksjonaliteter i 
          forholdet mellom Apache og Subversion er muligheten til å 
          spesifisere en spesiell port (istedenfor den vanlige 
          HTTP-porten 80) eller virtuelle domenenavn som 
          Subversiondepoter skal aksesseres via, eller muligheten til å 
          aksessere depotet gjennom en mellom&server;.
          Alle disse tingene støttes av Neon, så denne støtten får 
          Subversion helt gratis.</para>

        <!-- @ENGLISH {{{
        <para>Finally, because <command>mod_dav_svn</command> is
          speaking a semi-complete dialect of WebDAV/DeltaV, it's
          possible to access the repository via third-party DAV
          clients.  Most modern operating systems (Win32, OS X, and
          Linux) have the built-in ability to mount a DAV server as a
          standard network <quote>share</quote>.  This is a
          complicated topic; for details, read <xref
          linkend="svn.webdav"/>.</para>
        @ENGLISH }}} -->
        <para>Til sist, fordi <command>mod_dav_svn</command> snakker en 
          halvkomplett dialekt av WebDAV/DeltaV, er det mulig å 
          aksessere depotet vie tredjeparts DAV-klienter.
          De fleste moderne operativsystemer (Win32, OS X og Linux) har 
          muligheten til å montere en DAV-&server; som en standard 
          <quote>share</quote> (delt ressurs eller disk).
          Dette er et kompliser tema; for detaljer, les <xref 
          linkend="svn.webdav"/>.</para>

        
      </sect3>

    </sect2>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.multimethod">
    
    <!-- @ENGLISH {{{
    <title>Supporting Multiple Repository Access Methods</title>
    @ENGLISH }}} -->
    <title><!-- ¤ Krøkkete setning -->Støtte for flere metoder for 
      tilgang til depotet</title>

    <!-- @ENGLISH {{{
    <para>You've seen how a repository can be accessed in many
      different ways.  But is it possible&mdash;or safe&mdash;for your
      repository to be accessed by multiple methods simultaneously?
      The answer is yes, provided you use a bit of foresight.</para>
    @ENGLISH }}} -->
    <para>Du har sett hvordan et depot kan bli aksessert på mange 
      forskjellige måter.
      Men er det mulig – eller trygt – for depotet å bli aksessert på 
      flere forskjellige måter samtidig?</para>
    
    <!-- @ENGLISH {{{
    <para>At any given time, these processes may require read and
      write access to your repository:</para>
    @ENGLISH }}} -->
    <para>Til enhver tid kan disse prosessene kreve lese- og 
      skriveaksess til depotet:</para>
    
    <itemizedlist>
      <listitem>
        <!-- @ENGLISH {{{
        <para>regular system users using a Subversion client (as
          themselves) to access the repository directly via
          <literal>file:///</literal> URLs;</para>
        @ENGLISH }}} -->
        <para>vanlige brukere som bruker en Subversionklient (som seg 
          selv) for å aksessere depotet direkte via <!-- ¤ Ekstra 
          skråstrek --><literal>file:///</literal>-URLer,</para>
      </listitem>
      <listitem>
        <!-- @ENGLISH {{{
        <para>regular system users connecting to SSH-spawned private
          <command>svnserve</command> processes (running as
          themselves) which access the repository;</para>
        @ENGLISH }}} -->
        <para>vanlige brukere som kobler seg til private <!-- ¤ spawn 
          -->SSH-startede <command>svnserve</command>-prosesser (som 
          kjører som brukeren selv) som aksesserer depotet,</para>
      </listitem>
      <listitem>
        <!-- @ENGLISH {{{
        <para>an <command>svnserve</command> process&mdash;either a
          daemon or one launched by
          <command>inetd</command>&mdash;running as a particular fixed
          user;</para>
        @ENGLISH }}} -->
        <para>en <command>svnserve</command>-prosess – enten en daemon 
          eller en startet av <command>inetd</command> – som kjører som 
          en spesiell bruker,</para>
      </listitem>
      <listitem>
        <!-- @ENGLISH {{{
        <para>an Apache <command>httpd</command> process, running as a
          particular fixed user.</para>
        @ENGLISH }}} -->
        <para>en Apache <command>httpd</command>-process, som kjører som 
          en spesiell <!-- ¤ fixed --> bruker.</para>
      </listitem>
    </itemizedlist>
    
    <!-- @ENGLISH {{{
    <para>The most common problem administrators run into is repository
      ownership and permissions.  Does every process (or user) in the
      previous list have the rights to read and write the Berkeley DB
      files?  Assuming you have a Unix-like operating system, a
      straightforward approach might be to place every potential
      repository user into a new <literal>svn</literal> group, and
      make the repository wholly owned by that group.  But even that's
      not enough, because a process may write to the database files
      using an unfriendly umask&mdash;one that prevents access by
      other users.</para>
    @ENGLISH }}} -->
    <para>Det vanligste problemer administratorer får med å gjøre er 
      eierskap og rettigheter for depotene.
      Har alle prosesser (og brukere) i den forrige listen rettigheter 
      til å lese og skrive til Berkeley DB-filene?
      Hvis du har et Unix-lignende operativsystem er en <!-- ¤ 
      straightforward -->grei måte å plassere hver eneste potensiell 
      depotbruker i en ny <literal>svn</literal>-gruppe og gjøre denne 
      gruppen til eier av hele depotet.
      Men til og med dette er ikke nok, fordi en prosess kan skrive til 
      databasefilene med en utrivelig umask – en som forbyr tilgang for 
      andre brukere.</para>
    
    <!-- @ENGLISH {{{
    <para>So the next step beyond setting up a common group for
      repository users is to force every repository-accessing process
      to use a sane umask.  For users accessing the repository
      directly, you can make the <command>svn</command> program into a
      wrapper script that first sets <command>umask 002</command> and
      then runs the real <command>svn</command> client program.  You
      can write a similar wrapper script for the
      <command>svnserve</command> program, and add a <command>umask
      002</command> command to Apache's own startup script,
      <filename>apachectl</filename>.  For example:</para>
    @ENGLISH }}} -->
    <para>Så det neste steget etter å sette opp en felles gruppe for 
      depotbrukerne er å tvinge alle prosesser som aksesserer depotet 
      til å bruke en fornuftig umask.
      For brukere som aksesserer depotet direkte kan du kapsle 
      <command>svn</command>-programmet inn i et skript som først setter 
      <command>umask 002</command> og deretter kjører det egentlige 
      svn-programmet.
      Du kan skrive et lignende innkapslingsskript for 
      <command>svnserve</command>-programmet, og legge til en 
      <command>umask 002</command> til Apaches eget oppstartsskript 
      <command>apachectl</command>.
      For eksempel:<filename></filename></para>

    <screen>
$ cat /usr/bin/svn

#!/bin/sh

umask 002
/usr/bin/svn-real "$@"

</screen>

    <!-- @ENGLISH {{{
    <para>Another common problem is often encountered on Unix-like
      systems.  As a repository is used, Berkeley DB occasionally
      creates new log files to journal its actions.  Even if the
      repository is wholly owned by the <command>svn</command> group,
      these newly created files won't necessarily be owned by that
      same group, which then creates more permissions problems for
      your users.  A good workaround is to set the group SUID bit on
      the repository's <filename>db</filename> directory.  This causes
      all newly-created log files to have the same group owner as the
      parent directory.</para>
    @ENGLISH }}} -->
    <para>Et annet vanlig problem oppstår ofte på Unix-lignende 
      systemer.
      Når et depot blir brukt, lager Berkeley DB noen ganger nye 
      loggfiler for å journalføre det som den gjør.
      Selv om hele depotet eies av <literal>svn</literal>-gruppen, vil 
      ikke disse nye filene nødvendigvis eies av den samme gruppen, som 
      i sin tur fører til flere rettighetsproblemer for brukerne.
      En grei måte å ordne dette på er å sette gruppens SUID-bit på 
      <filename>db</filename>-katalogen i depotet.
      Dette gjør at alle nyopprettede loggfiler tilhører den samme 
      gruppen som foreldrekatalogen.</para>

    <!-- @ENGLISH {{{
    <para>Once you've jumped through these hoops, your repository
      should be accessible by all the necessary processes.  It may
      seem a bit messy and complicated, but the problems of having
      multiple users sharing write-access to common files are classic
      ones that are not often elegantly solved.</para>
    @ENGLISH }}} -->
    <para>Når du har gjort alt dette, skal depotet være tilgjengelig for 
      alle de nødvendige prosessene.
      Det kan se rotete og komplisert ut, men problemene med å ha flere 
      brukere som skal dele skrivetilgang til vanlige filer er klassiske 
      og må løses på måter som ikke er spesielt elegante.</para>
    
    <!-- @ENGLISH {{{
    <para>Fortunately, most repository administrators will never
      <emphasis>need</emphasis> to have such a complex configuration.
      Users who wish to access repositories that live on the same
      machine are not limited to using <literal>file://</literal>
      access URLs&mdash;they can typically contact the Apache HTTP
      server or <command>svnserve</command> using
      <literal>localhost</literal> for the server name in their
      <literal>http://</literal> or <literal>svn://</literal> URLs.
      And to maintain multiple server processes for your Subversion
      repositories is likely to be more of a headache than necessary.
      We recommend you choose the server that best meets your needs
      and stick with it!</para>
    @ENGLISH }}} -->
    <para>Heldigvis vil de fleste administratorer noen gang trenge å ha 
      et slikt komplisert oppsett.
      Brukere som ønsker tilgang til depoter som er på den samme 
      maskinen er ikke begrenset til å bruke URLer av 
      <literal>file://</literal>-typen, de kan vanligvis kontakte Apache 
      HTTP-&the_server; eller <command>svnserve</command> ved å bruke 
      <literal>localhost</literal> som &server;navnet i 
      <literal>http://</literal>- og <literal>svn://</literal>-URLene.
      Og det å vedlikeholde flere &server;prosesser for 
      Subversiondepotene har en tendens til å skaffe mer hodebry enn 
      nødvendig.
      Vi anbefaler at du velger den &the_server; som passer best til 
      dine behov og holder deg til den!</para>

    <sidebar>
      <!-- @ENGLISH {{{
      <title>The svn+ssh:// server checklist</title>
      @ENGLISH }}} -->
      <title>Sjekklisten for svn+ssh://-&servers;</title>

      <!-- @ENGLISH {{{
      <para>It can be quite tricky to get a bunch of users with
        existing SSH accounts to share a repository without
        permissions problems.  If you're confused about all the things
        that you (as an administrator) need to do on a Unix-like
        system, here's a quick checklist that resummarizes some of
        things discussed in this section:</para>
      @ENGLISH }}} -->
      <para>Det kan være ganske vanskelig å få en dunge med brukere som 
        har eksisterende SSH-kontoer å dele et depot uten 
        rettighetsproblemer.
        Hvis du er forvirret angående alle tingene som du (som en 
        administrator) trenger å gjøre på en Unix-lignende system, her 
        er en rask sjekkliste som oppsummerer noen av tingene som ble 
        diskutert i denne seksjonen:</para>

      <itemizedlist>
        <listitem>
          <!-- @ENGLISH {{{
          <para>All of your SSH users need to be able to read and
            write to the repository.  Put all the SSH users into a
            single group.  Make the repository wholly owned by that
            group, and set the group permissions to read/write.</para>
          @ENGLISH }}} -->
          <para>Alle SSH-brukerne dine må være i stand til å lese og 
            skrive til depotet.
            Legg alle SSH-brukerne inn i en enkelt gruppe.
            Gjør denne gruppen til eier av depotet og sett 
            grupperettighene til lesing+skriving.</para>
        </listitem>

        <listitem>
          <!-- @ENGLISH {{{
          <para>Your users need to use a sane umask when accessing the
            repository.  Make sure that <command>svnserve</command>
            (<filename>/usr/bin/svnserve</filename>, or wherever
            it lives in <literal>$PATH</literal>) is actually a
            wrapper script which sets <command>umask 002</command> and
            executes the real <command>svnserve</command>
            binary.  Take similar measures when using
            <command>svnlook</command> and
            <command>svnadmin</command>.  Either run them with a sane
            umask, or wrap them as described above.</para>
          @ENGLISH }}} -->
          <para>Brukerne må ha en fornuftig umask når depotet 
            aksesseres.
            Pass på at <command>svnserve</command> 
            (<filename>/usr/bin/svnserve</filename> eller hvor den nå 
            ligger i <literal>$PATH</literal>) egentlig er et 
            innkapslingsskript som setter <command>umask 002</command> 
            og kjører den ekte <command>svnserve</command>-binærfilen.
            Gjør det samme med <command>svnlook</command> og 
            <command>svnadmin</command>.
            Programmet må enten kjøres med en anstendig umask eller 
            pakkes inn som beskrevet ovenfor.</para>
        </listitem>
      </itemizedlist>

    </sidebar>

  </sect1>




</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
vim: set ft=svnbook :
-->
