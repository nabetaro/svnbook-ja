<chapter id="svn.branchmerge">
<!-- @ENGLISH {{{
  <title>Branching and Merging</title>
@ENGLISH }}} -->
  <title>Forgrening og fletting</title>

  <simplesect>

    <!-- @ENGLISH {{{
    <para>Branching, tagging, and merging are concepts common to
      almost all version control systems.  If you're not familiar with
      these ideas, we provide a good introduction in this chapter.  If
      you are familiar, then hopefully you'll find it interesting to
      see how Subversion implements these ideas.</para>
    @ENGLISH }}} -->
    <para>Forgrening (<quote>branching</quote>), merking 
      (<quote>tagging</quote>) og fletting (<quote>merging</quote>) er 
      konsepter felles for nesten alle versjonskontrollsystemer.
      Hvis du ikke er vant med disse idéene, gir vi en god introduksjon 
      i dette kapittelet.
      Hvis du kjenner til dem, finner du det forhåpentligvis interessant 
      å se hvordan Subversion har implementert disse idéene.</para>

    <!-- @ENGLISH {{{
    <para>Branching is a fundamental part of version control.  If
      you're going to allow Subversion to manage your data, then this
      is a feature you'll eventually come to depend on.  This chapter
      assumes that you're already familiar with Subversion's basic
      concepts (<xref linkend="svn.basic"/>).</para>
    @ENGLISH }}} -->
    <para>Forgreninger er en fundamental del av versjonskontroll.
      Hvis du skal tillate Subversion å behandle dine data, er dette en 
      funksjon som du etterhvert kommer til å basere deg mye på.
      Dette kapittelet går ut i fra at du allerede er kjent med 
      Subversions grunnleggende konsepter (<xref 
      linkend="svn.basic"/>).</para>

  </simplesect>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.whatis">
    <!-- @ENGLISH {{{
    <title>What's a Branch?</title> 
    @ENGLISH }}} -->
    <title>Hva er en forgrening?</title> 

    <!-- @ENGLISH {{{
    <para>Suppose it's your job to maintain a document for a division
      in your company, a handbook of some sort.  One day a different
      division asks you for the same handbook, but with a few parts
      <quote>tweaked</quote> for them, since they do things slightly
      differently.</para>
    @ENGLISH }}} -->
    <para>Tenk deg at det er din jobb å vedlikeholde et dokument for en 
      avdeling i firmaet ditt, en håndbok av et eller annet slag.
      En dag spør en annen avdeling deg etter den samme håndboken, men 
      med noen deler <quote>spesialtilpasset</quote> for dem, siden de 
      gjør ting litt forskjellig.</para>

    <!-- @ENGLISH {{{
    <para>What do you do in this situation?  You do the obvious thing:
      you make a second copy of your document, and begin maintaining
      the two copies separately.  As each department asks you to make
      small changes, you incorporate them into one copy or the
      other.</para>
    @ENGLISH }}} -->
    <para>Hva gjør du i denne situasjonen?
      Du gjør den opplagte tingen:
      Du lager en annen kopi av dokumentet og begynner å vedlikeholde de 
      to kopiene separat.
      Etterhvert som hver avdeling ber deg om å gjøre små forandringer, 
      legger du dem inn i den ene kopien eller den andre.</para>

    <!-- @ENGLISH {{{
    <para>You often want to make the same change to both copies.  For
      example, if you discover a typo in the first copy, it's very
      likely that the same typo exists in the second copy.  The two
      documents are almost the same, after all; they only differ in
      small, specific ways.</para>
    @ENGLISH }}} -->
    <para>Du vil ofte ønske å gjøre den samme forandringen i begge 
      kopiene.
      Hvis du for eksempel finner en skrivefeil i den første kopien, er 
      det veldig sannsynlig at den samme trykkfeilen eksisterer i den 
      andre kopien.
      De to dokumentene er nesten like når alt kommer til alt; 
      forskjellene er små og spesifikke.</para>

    <!-- @ENGLISH {{{
    <para>This is the basic concept of a
      <firstterm>branch</firstterm>&mdash;namely, a line of
      development that exists independently of another line, yet still
      shares a common history if you look far enough back in time.  A
      branch always begins life as a copy of something, and moves on
      from there, generating its own history (see <xref
      linkend="svn.branchmerge.whatis.dia-1"/>).</para>
    @ENGLISH }}} -->
    <para>Dette er det grunnleggende konseptet for en 
      <firstterm>forgrening</firstterm> – det vil si en utviklingslinje 
      som eksisterer uavhengig av en annen linje, men som likevel deler 
      en felles historie hvis du ser langt nok tilbake i tid.
      En forgrening begynner bestandig livet som en kopi av noe, og går 
      videre derfra ved å lage sin egen historie (se <xref 
      linkend="svn.branchmerge.whatis.dia-1"/>).</para>

      <figure id="svn.branchmerge.whatis.dia-1">
        <!-- @ENGLISH {{{
        <title>Branches of development</title>
        @ENGLISH }}} -->
        <title>Forgreninger av utviklingen</title>
        <graphic fileref="images/ch04dia1.png"/>
      </figure>

    <!-- @ENGLISH {{{
    <para>Subversion has commands to help you maintain parallel
      branches of your files and directories.  It allows you to create
      branches by copying your data, and remembers that the copies are
      related to one another.  It also helps you duplicate changes
      from one branch to another.  Finally, it can make portions of
      your working copy reflect different branches, so that you can
      <quote>mix and match</quote> different lines of development in
      your daily work.</para>
    @ENGLISH }}} -->
    <para>Subversion har kommandoer for å hjelpe deg å vedlikeholde 
      parallelle forgreninger av filene og katalogene dine.
      Programmet lar deg opprette forgreninger ved å kopiere data, og 
      husker at kopiene er relaterte til hverandre.
      I tillegg får du også hjelp til å duplisere forandringer fra en 
      gren til en annen.
      Til sist, Subversion kan la porsjoner av arbeidskopien reflektere 
      forskjellige forgreninger, så du kan <quote>blande og 
      tilpasse</quote> forskjellige utviklingslinjer i ditt daglige 
      arbeid.</para>

  </sect1>
  
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.using">
    <!-- @ENGLISH {{{
    <title>Using Branches</title> 
    @ENGLISH }}} -->
    <title>Bruke forgreninger</title> 

    <!-- @ENGLISH {{{
    <para>At this point, you should understand how each commit creates
      an entire new filesystem tree (called a <quote>revision</quote>)
      in the repository.  If not, go back and read about revisions in
      <xref linkend="svn.basic.in-action.revs"/>.</para>
    @ENGLISH }}} -->
    <para>På dette punktet skal du ha fått forståelsen av hvordan hver 
      innlegging oppretter et helt nytt filsystemtre (kalt en 
      <quote>revisjon</quote>) i depotet.
      Hvis ikke, gå tilbake og les om revisjoner i <xref 
      linkend="svn.basic.in-action.revs"/>.</para>

    <!-- @ENGLISH {{{
    <para>For this chapter, we'll go back to the same example from
      Chapter 2.  Remember that you and your collaborator, Sally, are
      sharing a repository that contains two projects,
      <filename>paint</filename> and <filename>calc</filename>.
      Notice that in <xref linkend="svn.branchmerge.using.dia-1"/>, however, each
      project directory now contains subdirectories named
      <filename>trunk</filename> and <filename>branches</filename>.
      The reason for this will soon become clear.</para>
    @ENGLISH }}} -->
    <para>I dette kapittelet skal vi gå tilbake til det samme eksempelet 
      fra kapittel 2.
      Du husker at du og din kollega Sally deler et depot som inneholder 
      to prosjekter – <filename>paint</filename> og 
      <filename>calc</filename>.
      Merk imidlertid at i <xref linkend="svn.branchmerge.using.dia-1"/> 
      inneholder hver prosjektkatalog underkataloger kalt 
      <filename>trunk</filename> og <filename>branches</filename>.
      Grunnen til dette vil du snart få greie på.</para>
    
      <figure id="svn.branchmerge.using.dia-1">
        <!-- @ENGLISH {{{
        <title>Starting repository layout</title>
        @ENGLISH }}} -->
        <title>Depotets utseende til å begynne med</title>
        <graphic fileref="images/ch04dia2.png"/>
      </figure>

    <!-- @ENGLISH {{{
    <para>As before, assume that Sally and you both have working
      copies of the <quote>calc</quote> project.  Specifically, you
      each have a working copy of <filename>/calc/trunk</filename>.
      All the files for the project are in this subdirectory rather
      than in <filename>/calc</filename> itself, because your team has
      decided that <filename>/calc/trunk</filename> is where the
      <quote>main line</quote> of development is going to take
      place.</para>
    @ENGLISH }}} -->
    <para>Som tidligere, tenk deg at du og Sally begge har arbeidskopier 
      av <quote>calc</quote>-prosjektet.
      Mer spesifikt, dere har begge en arbeidskopi av 
      <filename>/calc/trunk</filename>.
      Alle filene for prosjektet er i denne underkatalogen istedenfor i 
      selve <filename>/calc</filename>, fordi teamet ditt har bestemt at 
      <filename>/calc/trunk</filename> er der <quote>hovedlinjen</quote> 
      av utviklingen skal foregå.</para>

    <!-- @ENGLISH {{{
    <para>Let's say that you've been given the task of performing a
      radical reorganization of the project.  It will take a long time
      to write, and will affect all the files in the project.  The
      problem here is that you don't want to interfere with Sally, who
      is in the process of fixing small bugs here and there.  She's
      depending on the fact that the latest version of the project (in
      <filename>/calc/trunk</filename>) is always usable.  If you
      start committing your changes bit-by-bit, you'll surely break
      things for Sally.</para>
    @ENGLISH }}} -->
    <para>La oss si at du har fått oppgaven å utføre en radikal 
      reorganisering av prosjektet.
      Det vil ta lang tid å skrive, og vil påvirke alle filene i 
      prosjektet.
      Problemet her er at du vil ikke forstyrre Sally, som er i full 
      gang med å fikse småfeil her og der.
      Hun er avhengig av at den seneste versjonen av prosjektet (i 
      <filename>/calc/trunk</filename>) alltid fungerer.
      Hvis du starter med å legge inn forandringene dine bit for bit, 
      vil du ganske sikkert ødelegge ting for Sally.</para>

    <!-- @ENGLISH {{{
    <para>One strategy is to crawl into a hole: you and Sally can stop
      sharing information for a week or two.  That is, start gutting
      and reorganizing all the files in your working copy, but don't
      commit or update until you're completely finished with the task.
      There are a number of problems with this, though.  First, it's
      not very safe.  Most people like to save their work to the
      repository frequently, should something bad accidentally happen
      to their working copy.  Second, it's not very flexible.  If you
      do your work on different computers (perhaps you have a working
      copy of <filename>/calc/trunk</filename> on two different
      machines), you'll need to manually copy your changes back and
      forth, or just do all the work on a single computer.  By that
      same token, it's difficult to share your changes-in-progress
      with anyone else.  A common software development <quote>best
      practice</quote> is to allow your peers to review your work as you
      go.  If nobody sees your intermediate commits, you lose
      potential feedback.  Finally, when you're finished with all your
      changes, you might find it very difficult to re-merge your final
      work with the rest of the company's main body of code.  Sally
      (or others) may have made many other changes in the repository
      that are difficult to incorporate into your working
      copy&mdash;especially if you run <command>svn update</command>
      after weeks of isolation.</para>
    @ENGLISH }}} -->
    <para>En strategi er å krabbe inn i et hull; du og Sally kan stoppe 
      med å dele informasjon for en uke eller to.
      Det vil si, starte med å <!-- ¤ gutting --> omorganisere alle 
      filene i arbeidskopien din, men ikke legge inn eller oppdatere før 
      du er helt ferdig med oppgaven.
      Men det er en del problemer med denne metoden.
      For det første er det ikke særlig trygt.
      Folk flest liker å lagre arbeidet sitt til depotet med jevne 
      mellomrom i tilfelle noe stygt skulle skje med arbeidskopien.
      For det andre er det ikke spesielt fleksibelt.
      Hvis du gjør arbeidet ditt på forskjellige datamaskiner (kanskje 
      du har en arbeidskopi av <filename>/calc/trunk</filename> på to 
      forskjellige maskiner) må du kopiere forandringene manuelt fram og 
      tilbake, eller gjøre hele jobben på en enkelt maskin.
      På samme måte er det vanskelig å dele forandringene dine som er 
      under utvikling med andre.
      Vanlig god praksis innen programutvikling er å la dine kolleger få 
      se over arbeidet ditt mens du holder på.
      Hvis ingen ser innleggingene dine, går du glipp av potensiell 
      respons.
      Til slutt, når du er ferdig med alle forandringene dine, kan du 
      oppleve at det er veldig vanskelig å flette sammen det endelige 
      resultatet ditt med resten av koden til firmaet.
      Sally (eller andre) kan ha gjort mange forandringer i depotet som 
      er vanskelig å legge inn i arbeidskopien din – spesielt hvis du 
      kjører <command>svn update</command> etter flere uker med 
      isolasjon.</para>

    <!-- @ENGLISH {{{
    <para>The better solution is to create your own branch, or line of
      development, in the repository.  This allows you to save your
      half-broken work frequently without interfering with others, yet
      you can still selectively share information with your
      collaborators.  You'll see exactly how this works later
      on.</para>
    @ENGLISH }}} -->
    <para>En bedre løsning er å opprette din egen forgrening, eller 
      utviklingslinje, i depotet.
      Dette lar deg lagre det halvfungerende resultatet ditt med jevne 
      mellomrom uten å blande det med arbeidet til andre, og samtidig 
      kan du velge ut informasjon som du vil dele med dine kolleger.
      Du vil etter hvert få se nøyaktig hvordan dette fungerer.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.using.create">
    <!-- @ENGLISH {{{
      <title>Creating a Branch</title> 
    @ENGLISH }}} -->
    <title>Opprette en forgrening</title>
      
      <!-- @ENGLISH {{{
      <para>Creating a branch is very simple&mdash;you make a copy of
        the project in the repository using the <command>svn
        copy</command> command.  Subversion is not only able to copy
        single files, but whole directories as well.  In this case,
        you want to make a copy of the
        <filename>/calc/trunk</filename> directory.  Where should the
        new copy live?  Wherever you wish&mdash;it's a matter of
        project policy.  Let's say that your team has a policy of
        creating branches in the <filename>/calc/branches</filename>
        area of the repository, and you want to name your branch
        <literal>my-calc-branch</literal>.  You'll want to create a
        new directory,
        <filename>/calc/branches/my-calc-branch</filename>, which
        begins its life as a copy of
        <filename>/calc/trunk</filename>.</para>
      @ENGLISH }}} -->
      <para>Det å opprette en ny gren er veldig enkelt – du lager en 
        kopi av prosjektet i depotet ved å bruke kommandoen <command>svn 
        copy</command>.
        Subversion er ikke bare i stand til å kopiere enkle filer, men 
        også hele kataloger.
        I dette tilfellet vil du lage en kopi av 
        <filename>/calc/trunk</filename>-katalogen.
        Hvor skal den nye kopien være?
        Hvor du vil – det er et spørsmål om prosjektrutiner.
        La oss si at teamet ditt har som regel å opprette forgreninger i 
        <filename>/calc/branches</filename>-området i depotet, og du vil 
        kalle grenen din <literal>my-calc-branch</literal>.
        Det du vil er å lage en ny katalog, 
        <filename>/calc/branches/my-calc-branch</filename>, som begynner 
        livet som en kopi av <filename>/calc/trunk</filename>.</para>

      <!-- @ENGLISH {{{
      <para>There are two different ways to make a copy.  We'll
        demonstrate the messy way first, just to make the concept
        clear.  To begin, check out a working copy of the project's
        root directory, <filename>/calc</filename>:</para>
      @ENGLISH }}} -->
      <para>Det er to forskjellige måter å lage en kopi på.
        Vi vil demonstrere den rotete måten først, bare for å klargjøre 
        konseptet.
        Til å begynne med, hent ut en arbeidskopi av prosjektets 
        rotkatalog, <filename>/calc</filename>:</para>

      <!-- @ENGLISH {{{
      <screen>
$ svn checkout http://svn.example.com/repos/calc bigwc
A  bigwc/trunk/
A  bigwc/trunk/Makefile
A  bigwc/trunk/integer.c
A  bigwc/trunk/button.c
A  bigwc/branches/
Checked out revision 340.
</screen>
      @ENGLISH }}} -->
      <screen>
$ svn checkout http://svn.example.com/repos/calc bigwc
A  bigwc/trunk/
A  bigwc/trunk/Makefile
A  bigwc/trunk/integer.c
A  bigwc/trunk/button.c
A  bigwc/branches/
Sjekket ut revisjon 340.
</screen>

      <!-- @ENGLISH {{{
      <para>Making a copy is now simply a matter of passing two
        working-copy paths to the <command>svn copy</command>
        command:</para>
      @ENGLISH }}} -->
      <para>For å lage en kopi er det nå bare å angi to arbeidskopistier 
        til kommandoen <command>svn copy</command>:</para>

      <screen>
$ cd bigwc
$ svn copy trunk branches/my-calc-branch
$ svn status
A  +   branches/my-calc-branch
</screen>

      <!-- @ENGLISH {{{
      <para>In this case, the <command>svn copy</command> command
        recursively copies the <filename>trunk</filename> working
        directory to a new working directory,
        <filename>branches/my-calc-branch</filename>.  As you can see
        from the <command>svn status</command> command, the new
        directory is now scheduled for addition to the repository.
        But also notice the <quote>+</quote> sign next to the letter
        A.  This indicates that the scheduled addition is a
        <emphasis>copy</emphasis> of something, not something new.
        When you commit your changes, Subversion will create
        <filename>/calc/branches/my-calc-branch</filename> in the
        repository by copying <filename>/calc/trunk</filename>, rather
        than resending all of the working copy data over the
        network:</para>
      @ENGLISH }}} -->
      <para>I dette tilfellet kopierer <command>svn copy</command> 
        katalogen <filename>trunk</filename> rekursivt til en ny 
        arbeidskatalog, <filename>branches/my-calc-branch</filename>.
        Som du kan se av kommandoen <command>svn status</command> er den 
        nye katalogen nå klargjort for å legges til i depotet.
        Men legg også merke til <quote>+</quote>-tegnet ved siden av 
        bokstaven A.
        Dette indikerer at den klargjorte tilleggingen er en 
        <emphasis>kopi</emphasis> av noe, og ikke noe nytt.
        Når du legger inn forandringene dine, vil Subversion lage 
        <filename>/calc/branches/my-calc-branch</filename> i depotet ved 
        å kopiere <filename>/calc/trunk</filename> istedenfor å sende 
        hele arbeidskopien over nettverket en gang til:</para>

      <!-- @ENGLISH {{{
      <screen>
$ svn commit -m "Creating a private branch of /calc/trunk."
Adding         branches/my-calc-branch
Committed revision 341.
</screen>
      @ENGLISH }}} -->
      <screen>
$ svn commit -m "Lager en privat gren av /calc/trunk."
Legger til         branches/my-calc-branch
La inn revisjon 341.
</screen>

      <!-- @ENGLISH {{{
      <para>And now the easier method of creating a branch, which we
        should have told you about in the first place: <command>svn
        copy</command> is able to operate directly on two URLs.</para>
      @ENGLISH }}} -->
      <para>Og nå den lettere måten å lage en gren på, som vi skulle 
        fortalt deg om til å begynne med:
        <command>svn copy</command> kan operere direkte mot to 
        URLer.</para>

      <!-- @ENGLISH {{{
      <screen>
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/branches/my-calc-branch \
      -m "Creating a private branch of /calc/trunk."

Committed revision 341.
</screen>
      @ENGLISH }}} -->
      <screen>
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/branches/my-calc-branch \
      -m "Lager en privat gren av /calc/trunk."

La inn revisjon 341.
</screen>

      <!-- @ENGLISH {{{
      <para>There's really no difference between these two methods.
        Both procedures create a new directory in revision 341, and
        the new directory is a copy of
        <filename>/calc/trunk</filename>.  This is shown in <xref
        linkend="svn.branchmerge.using.create.dia-1"/>.  Notice that the second method,
        however, performs an <emphasis>immediate</emphasis> commit.
        <footnote> 
          <para>Subversion does not support
            cross-repository copying.  When using URLs with <command>svn
            copy</command> or <command>svn move</command>, you can only
            copy items within the same repository.</para>
        </footnote>
        It's an easier procedure, because it doesn't require you to
        check out a large mirror of the repository.  In fact, this
        technique doesn't even require you to have a working copy at
        all.</para>
      @ENGLISH }}} -->
      <para>Det er egentlig ingen forskjell på disse to metodene.
        Begge prosedyrene lager en ny katalog i revisjon 341, og den nye 
        katalogen er en kopi av <filename>/calc/trunk</filename>.
        Dette er vist i <xref 
        linkend="svn.branchmerge.using.create.dia-1"/>.
        Legg merke til at den andre metoden utfører en 
        <emphasis>øyeblikkelig</emphasis> innlegging.<footnote>
          <para>Subversion støtter ikke kopiering mellom forskjellige 
            depot.
            Når du bruker URLer med <command>svn copy</command> eller 
            <command>svn move</command> kan du bare kopiere elementer 
            innenfor det samme depotet.</para>
        </footnote>
        Det er en lettere prosedyre, fordi det ikke kreves at du må 
        hente ut et stort speil av depotet.
        Faktisk trenger du med denne teknikken ikke en arbeidskopi i det 
        hele tatt.</para>
      
      <figure id="svn.branchmerge.using.create.dia-1">
        <!-- @ENGLISH {{{
        <title>Repository with new copy</title>
        @ENGLISH }}} -->
        <title>Depot med ny kopi</title>
        <graphic fileref="images/ch04dia3.png"/>
      </figure>
      
      <sidebar>
        <!-- @ENGLISH {{{
        <title>Cheap Copies</title>
        @ENGLISH }}} -->
        <title>Billige kopier</title>
                
        <!-- @ENGLISH {{{
        <para>Subversion's repository has a special design.  When you
          copy a directory, you don't need to worry about the
          repository growing huge&mdash;Subversion doesn't actually
          duplicate any data.  Instead, it creates a new directory
          entry that points to an <emphasis>existing</emphasis> tree.
          If you're a Unix user, this is the same concept as a
          hard-link.  From there, the copy is said to be
          <quote>lazy</quote>.  That is, if you commit a change to one
          file within the copied directory, then only that file
          changes&mdash;the rest of the files continue to exist as
          links to the original files in the original
          directory.</para>
        @ENGLISH }}} -->
        <para>Et depot i Subversion har en spesiell design.
          Når du kopierer en katalog, trenger du ikke å bekymre deg for 
          at depotet skal vokse seg stort – Subversion dupliserer 
          egentlig ingen data.
          Istedenfor lages det en ny katalogpost som peker til et 
          <emphasis>eksisterende</emphasis> tre.
          Hvis du er en Unixbruker, er dette det samme konseptet som en 
          hard lenke.
          <!-- ¤ -->Denne kopien kalles <quote>lat</quote>.
          Det vil si at hvis du legger inn en forandring til en fil i 
          den kopierte katalogen, forandrer bare denne filen seg – 
          resten av filene fortsetter å eksistere som lenker til de 
          originale filene i den originale katalogen.</para>
      
        <!-- @ENGLISH {{{
        <para>This is why you'll often hear Subversion users talk
          about <quote>cheap copies</quote>.  It doesn't matter how
          large the directory is&mdash;it takes a very tiny, constant
          amount of time to make a copy of it.  In fact, this feature
          is the basis of how commits work in Subversion: each
          revision is a <quote>cheap copy</quote> of the previous
          revision, with a few items lazily changed within.  (To read
          more about this, visit Subversion's website and read about
          the <quote>bubble up</quote> method in Subversion's design
          documents.)</para>
        @ENGLISH }}} -->
        <para>Det er derfor du ofte vil høre Subversionbrukere snakke om 
          <quote>billige kopier</quote>.
          Det har ingenting å si hvor stor en katalog er – det tar en 
          veldig liten, konstant mengde tid å lage en kopi av den.
          Faktisk er denne egenskapen basisen for hvordan innlegginger 
          skjer i Subversion; hver revisjon er en <quote>billig 
          kopi</quote> av den forrige revisjonen, med noen få elementer 
          som forandrer seg på <quote>en lat måte</quote> i den.
          (For å lese mer om dette, besøk Subversions hjemmeside og les 
          om <quote>bubble up</quote>-metoden i Subversions 
          designdokumenter.)</para>

        <!-- @ENGLISH {{{
        <para>Of course, these internal mechanics of copying and
          sharing data are hidden from the user, who simply sees
          copies of trees.  The main point here is that copies are
          cheap, both in time and space.  Make branches as often as
          you want.</para>
        @ENGLISH }}} -->
        <para>Selvfølgelig, denne interne mekanikken med kopiering og 
          deling av data er skjult for brukeren, som rett og slett bare 
          ser kopier av trær.
          Hovedpoenget her er at kopier er billige, både når det gjelder 
          tid og plass.
          Lag forgreninger så ofte som du vil.</para>
      </sidebar>

    </sect2>
    
    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.using.work">
      <!-- @ENGLISH {{{
      <title>Working with Your Branch</title> 
      @ENGLISH }}} -->
      <title>Arbeide med grenen</title> 

      <!-- @ENGLISH {{{
      <para>Now that you've created a branch of the project, you can
        check out a new working copy to start using it:</para>
      @ENGLISH }}} -->
      <para>Nå som du har laget en gren av prosjektet, kan du hente ut 
        en ny arbeidskopi for å starte bruken av den:</para>

      <!-- @ENGLISH {{{
      <screen>
$ svn checkout http://svn.example.com/repos/calc/branches/my-calc-branch
A  my-calc-branch/Makefile
A  my-calc-branch/integer.c
A  my-calc-branch/button.c
Checked out revision 341.
</screen>
      @ENGLISH }}} -->
      <screen>
$ svn checkout http://svn.example.com/repos/calc/branches/my-calc-branch
A  my-calc-branch/Makefile
A  my-calc-branch/integer.c
A  my-calc-branch/button.c
Sjekket ut revisjon 341.
</screen>

      <!-- @ENGLISH {{{
      <para>There's nothing special about this working copy; it simply
        mirrors a different directory in the repository.  When you
        commit changes, however, Sally won't ever see them when she
        updates.  Her working copy is of
        <filename>/calc/trunk</filename>.  (Be sure to read <xref
        linkend="svn.branchmerge.switchwc"/> later in this chapter: the
        <command>svn switch</command> command is an alternate way of
        creating a working copy of a branch.)</para>
      @ENGLISH }}} -->
      <para>Det er ingenting spesielt med denne arbeidskopien; den 
        avspeiler simpelthen bare en annen katalog i depotet.
        Men når du legger inn forandringer, vil ikke Sally se noen av 
        dem når hun oppdaterer.
        Hennes arbeidskopi er fra <filename>/calc/trunk</filename>.
        (Pass på å lese <xref linkend="svn.branchmerge.switchwc"/> 
        senere i dette kapittelet:
        Kommandoen <command>svn switch</command> er en alternativ måte å 
        lage en arbeidskopi av en forgrening.)</para>

      <!-- @ENGLISH {{{
      <para>Let's pretend that a week goes by, and the following
        commits happen:</para>
      @ENGLISH }}} -->
      <para>La oss late som om en uke går, og de følgende innlegginger 
        blir gjort:</para>

      <itemizedlist>
        <!-- @ENGLISH {{{
        <listitem><para>
          You make a change to
          <filename>/calc/branches/my-calc-branch/button.c</filename>,
          which creates revision 342.</para>
        </listitem>
        @ENGLISH }}} -->
        <listitem>
          <para>Du gjør en forandring i 
            <filename>/calc/branches/my-calc-branch/button.c</filename> 
            som lager revisjon 342.</para>
        </listitem>

        <!-- @ENGLISH {{{
        <listitem><para>
          You make a change to
          <filename>/calc/branches/my-calc-branch/integer.c</filename>,
          which creates revision 343.</para>
        </listitem>
        @ENGLISH }}} -->
        <listitem>
          <para>Du gjør en forandring i 
            <filename>/calc/branches/my-calc-branch/integer.c</filename> 
            som lager revisjon 343.</para>
        </listitem>

        <!-- @ENGLISH {{{
        <listitem><para>
          Sally makes a change to
          <filename>/calc/trunk/integer.c</filename>, which creates
          revision 344.</para>
        </listitem>
        @ENGLISH }}} -->
        <listitem>
          <para>Sally gjør en forandring i 
            <filename>/calc/trunk/integer.c</filename> som lager 
            revisjon 344.</para>
        </listitem>
      </itemizedlist>

      <!-- @ENGLISH {{{
      <para>There are now two independent lines of development, shown
        in <xref linkend="svn.branchmerge.using.work.dia-1"/>, happening on
        <filename>integer.c</filename>.</para>
      @ENGLISH }}} -->
      <para>Det er nå to uavhengige utviklingslinjer, vist i <xref 
        linkend="svn.branchmerge.using.work.dia-1"/>, som skjer med 
        <filename>integer.c</filename>.</para>

      <figure id="svn.branchmerge.using.work.dia-1">
        <!-- @ENGLISH {{{
        <title>The branching of one file's history</title>
        @ENGLISH }}} -->
        <title>Forgreningen av en fils historie</title>
        <graphic fileref="images/ch04dia4.png"/>
      </figure>

      <!-- @ENGLISH {{{
      <para>Things get interesting when you look at the history of
        changes made to your copy of
        <filename>integer.c</filename>:</para>
      @ENGLISH }}} -->
      <para>Ting blir interessante når du ser på historien til 
        forandringene gjort i din kopi av 
        <filename>integer.c</filename>:</para>

      <!-- @ENGLISH {{{
      <screen>
$ pwd
/home/user/my-calc-branch

$ svn log -&#64738;-verbose integer.c
-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-
r343 | user | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   M /calc/branches/my-calc-branch/integer.c

* integer.c:  frozzled the wazjub.

-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-
r341 | user | 2002-11-03 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)

Creating a private branch of /calc/trunk.

-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-
r303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  changed a docstring.

-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-
r98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  adding this file to the project.

-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-
</screen>
      @ENGLISH }}} -->
      <screen>
$ pwd
/home/user/my-calc-branch

$ svn log --verbose integer.c
------------------------------------------------------------------------
r343 | bruker | 2002-11-07 15:27:56 -0600 (tor, 07 nov 2002) | 2 lines
Endrede filstier:
   M /calc/branches/my-calc-branch/integer.c

* integer.c:  <!-- ¤ Ja, den blir ikke grei. -->frozzled the wazjub.

------------------------------------------------------------------------
r341 | bruker | 2002-11-03 15:27:56 -0600 (tor, 07 nov 2002) | 2 lines
Endrede filstier:
   A /calc/branches/my-calc-branch (fra /calc/trunk:340)

Lager en privat gren av /calc/trunk.

------------------------------------------------------------------------
r303 | sally | 2002-10-29 21:14:35 -0600 (tir, 29 okt 2002) | 2 lines
Endrede filstier:
   M /calc/trunk/integer.c

* integer.c:  Forandret en docstring.

------------------------------------------------------------------------
r98 | sally | 2002-02-22 15:35:29 -0600 (fre, 22 feb 2002) | 2 lines
Endrede filstier:
   M /calc/trunk/integer.c

* integer.c:  Legger til denne fila i prosjektet.

------------------------------------------------------------------------
</screen>

      <!-- @ENGLISH {{{
      <para>Notice that Subversion is tracing the history of your
        branch's <filename>integer.c</filename> all the way back
        through time, even traversing the point where it was copied.
        It shows the creation of the branch as an event in the
        history, because <filename>integer.c</filename> was implicitly
        copied when all of <filename>/calc/trunk/</filename> was
        copied.  Now look what happens when Sally runs the same
        command on her copy of the file:</para>
      @ENGLISH }}} -->
      <para>Legg merke til at Subversion går gjennom historien av 
        forgreningens <filename>integer.c</filename> hele veien tilbake 
        gjennom tiden og krysser til og med punktet den ble kopiert.
        Opprettelsen av forgreningen vises som en hendelse i historien, 
        fordi <filename>integer.c</filename> også ble kopiert når alt 
        under <filename>/calc/trunk/</filename> ble kopiert.
        Se nå hva som skjer når Sally kjører den samme kommandoen på 
        hennes kopi av filen:</para>

      <!-- @ENGLISH {{{
      <screen>
$ pwd
/home/sally/calc

$ svn log -&#64738;-verbose integer.c
-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-
r344 | sally | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  fix a bunch of spelling errors.

-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-
r303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  changed a docstring.

-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-
r98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  adding this file to the project.

-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-
</screen>
      @ENGLISH }}} -->
      <screen>
$ pwd
/home/sally/calc

$ svn log --verbose integer.c
------------------------------------------------------------------------
r344 | sally | 2002-11-07 15:27:56 -0600 (tor, 07 nov 2002) | 2 lines
Endrede filstier:
   M /calc/trunk/integer.c

* integer.c:  Ordnet en dunge med skrivefeil.

------------------------------------------------------------------------
r303 | sally | 2002-10-29 21:14:35 -0600 (tir, 29 okt 2002) | 2 lines
Endrede filstier:
   M /calc/trunk/integer.c

* integer.c:  Forandret en docstring.

------------------------------------------------------------------------
r98 | sally | 2002-02-22 15:35:29 -0600 (fre, 22 feb 2002) | 2 lines
Endrede filstier:
   M /calc/trunk/integer.c

* integer.c:  Legger til denne fila i prosjektet.

------------------------------------------------------------------------
</screen>

      <!-- @ENGLISH {{{
      <para>Sally sees her own revision 344 change, but not the change
        you made in revision 343.  As far as Subversion is concerned,
        these two commits affected different files in different
        repository locations.  However, Subversion
        <emphasis>does</emphasis> show that the two files share a
        common history.  Before the branch-copy was made in revision
        341, they used to be the same file.  That's why you and Sally
        both see the changes made in revisions 303 and 98.</para>
      @ENGLISH }}} -->
      <para>Sally ser at hennes egen revisjon 344 forandrer seg, men 
        ikke forandringen som du gjorde i revisjon 343.
        Hva Subversion angår, påvirket disse to innleggingene 
        forskjellige filer på forskjellige plasseringer i depotet.
        Subversion viser imidlertid at de to filene deler en felles 
        historie.
        Før grenkopieringen ble gjort i revisjon 341 var de den samme 
        filen.
        Det er derfor både du og Sally ser forandringene gjort i 
        revisjonene 303 og 98.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.using.concepts">
      <!-- @ENGLISH {{{
      <title>The Key Concepts Behind Branches</title> 
      @ENGLISH }}} -->
      <title>Nøkkelkonseptet bak forgreninger</title>

      <!-- @ENGLISH {{{
      <para>There are two important lessons that you should remember
        from this section.</para>
      @ENGLISH }}} -->
      <para>Det er to viktige <!-- ¤ -->ting du bør huske fra denne 
        seksjonen.</para>

      <orderedlist>
        <listitem>
          <!-- @ENGLISH {{{
          <para>Unlike many other version control systems,
            Subversion's branches exist as <emphasis>normal filesystem
            directories</emphasis> in the repository, not in an extra
            dimension.  These directories just happen to carry some
            extra historical information.</para>
          @ENGLISH }}} -->
          <para>Ulikt mange andre versjonskontrollsystemer eksisterer 
            Subversions forgreninger som <emphasis>vanlige 
            filsystemkataloger</emphasis> i depotet, ikke i en ekstra 
            dimensjon.
            Disse katalogene <!-- ¤ just happen -->inneholder bare noe 
            ekstra historisk informasjon.</para>
        </listitem>
        <listitem>
          <!-- @ENGLISH {{{
          <para>Subversion has no internal concept of a
            branch&mdash;only copies.  When you copy a directory, the
            resulting directory is only a <quote>branch</quote>
            because <emphasis>you</emphasis> attach that meaning to
            it.  You may think of the directory differently, or treat
            it differently, but to Subversion it's just an ordinary
            directory that happens to have been created by
            copying.</para>
          @ENGLISH }}} -->
          <para>Subversion har ikke noe internt begrep om en gren – bare 
            kopier.
            Når du kopierer en katalog, er den resulterende nye 
            katalogen bare en <quote>gren</quote> fordi 
            <emphasis>du</emphasis> legger denne meningen til den.
            Du kan tenke på denne katalogen på en spesiell måte eller 
            behandle den forskjellig, men for Subversion er den bare en 
            vanlig katalog som tilfeldigvis er blitt opprettet ved 
            kopiering.</para>
        </listitem>
      </orderedlist>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.copychanges">
    <!-- @ENGLISH {{{
    <title>Copying Changes Between Branches</title>
    @ENGLISH }}} -->
    <title>Kopiere forandringer mellom forgreninger</title>

    <!-- @ENGLISH {{{
    <para>Now you and Sally are working on parallel branches of the
      project: you're working on a private branch, and Sally is
      working on the <firstterm>trunk</firstterm>, or main line of
      development.</para>
    @ENGLISH }}} -->
    <para>Nå arbeider du og Sally på parallelle grener i prosjektet:
      Du arbeider på en privat gren, og Sally jobber i 
      <firstterm>trunk</firstterm>, eller hovedlinjen av 
      utviklingen.</para>

    <!-- @ENGLISH {{{
    <para>For projects that have a large number of contributors, it's
      common for most people to have working copies of the trunk.
      Whenever someone needs to make a long-running change that is
      likely to disrupt the trunk, a standard procedure is to create a
      private branch and commit changes there until all the work is
      complete.</para>
    @ENGLISH }}} -->
    <para>For prosjekter som har et stort antall bidragsytere er det 
      vanlig for de fleste personer å ha arbeidskopier av 
      <filename>trunk</filename>.
      Når noen må gjøre forandringer som vil ta litt tid og som 
      sannsynligvis kommer til å forstyrre <filename>trunk</filename>, 
      er standard prosedyre å lage en privat gren og legge inn 
      forandringer der til alt arbeidet er fullført.</para>

    <!-- @ENGLISH {{{
    <para>So, the good news is that you and Sally aren't interfering
      with each other.  The bad news is that it's very easy to drift
      <emphasis>too</emphasis> far apart.  Remember that one of the
      problems with the <quote>crawl in a hole</quote> strategy is
      that by the time you're finished with your branch, it may be
      near-impossible to merge your changes back into the trunk
      without a huge number of conflicts.</para>
    @ENGLISH }}} -->
    <para>Så, de gode nyhetene er at du og Sally ikke forstyrrer 
      hverandre.
      De dårlige nyhetene er at det er veldig lett å drive 
      <emphasis>for</emphasis> langt avgårde.
      Husk at ett av problemene med <quote>krabbe inn i et 
      hull</quote>-strategien er at når du er ferdig med grenen din, vil 
      det bli nesten umulig å flette inn dine forandringer tilbake til 
      <filename>trunk</filename> uten et stort antall konflikter.</para>
    
    <!-- @ENGLISH {{{
    <para>Instead, you and Sally might continue to share changes as
      you work.  It's up to you to decide which changes are worth
      sharing; Subversion gives you the ability to selectively
      <quote>copy</quote> changes between branches.  And when you're
      completely finished with your branch, your entire set of branch
      changes can be copied back into the trunk.</para>
    @ENGLISH }}} -->
    <para>Istedenfor kan du og Sally fortsette med å dele forandringer 
      mens du arbeider.
      Det er opp til deg å bestemme hvilke forandringer som er verdt å 
      dele; Subversion gir deg muligheten til å selektivt 
      <quote>kopiere</quote> forandringer mellom grener.
      Og når du er fullstendig ferdig med din gren, kan hele settet med 
      grenforandringer bli kopiert tilbake til 
      <filename>trunk</filename>.</para>
    

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.copychanges.specific">
      <!-- @ENGLISH {{{
      <title>Copying Specific Changes</title>
      @ENGLISH }}} -->
      <title>Kopiere spesifikke forandringer</title>
      

      <!-- @ENGLISH {{{
      <para>In the previous section, we mentioned that both you and
        Sally made changes to <filename>integer.c</filename> on
        different branches.  If you look at Sally's log message for
        revision 344, you can see that she fixed some spelling errors.
        No doubt, your copy of the same file still has the same spelling
        errors.  It's likely that your future changes to this file will
        be affecting the same areas that have the spelling errors, so
        you're in for some potential conflicts when you merge your
        branch someday.  It's better, then, to receive Sally's change
        now, <emphasis>before</emphasis> you start working too heavily
        in the same places.</para>
      @ENGLISH }}} -->
      <para>I den forrige seksjonen nevnte vi at både du og Sally gjorde 
        forandringer til <filename>integer.c</filename> på forskjellige 
        forgreninger.
        Hvis du ser på Sallys loggmelding for revisjon 344, kan du se at 
        hun forandret noen stavefeil.
        Din kopi av den samme filen har uten tvil de samme 
        skrivefeilene.
        Det er sannsynlig at dine fremtidige forandringer i denne filen 
        vil påvirke de samme områdene som skrivefeilene ligger i, så du 
        ligger an til å få potensielle konflikter når du en vakker dag 
        fletter inn grenen din.
        Da er det bedre å motta Sallys forandringer nå, 
        <emphasis>før</emphasis> du starter med å arbeide mye i det 
        samme området.</para>

      <!-- @ENGLISH {{{
      <para>It's time to use the <command>svn merge</command> command.
        This command, it turns out, is a very close cousin to the
        <command>svn diff</command> command (which you read about in
        Chapter 3).  Both commands are able to compare any two objects
        in the repository and describe the differences.  For example,
        you can ask <command>svn diff</command> to show you the exact
        change made by Sally in revision 344:</para>
      @ENGLISH }}} -->
      <para>Det er på tide å bruke kommandoen <command>svn 
        merge</command>.
        Det skal vise seg at denne kommandoen er en veldig nær slektning 
        av <command>svn diff</command>-kommandoen (som du leste om i 
        kapittel 3).
        Begge kommandoene er i stand til å sammenligne to vilkårlige 
        objekter i depotet og beskrive forskjellene.
        For eksempel kan du spørre <command>svn diff</command> om å vise 
        deg den eksakte forandringen gjort av Sally i revisjon 
        344:</para>

      <!-- @ENGLISH {{{
      <screen>
$ svn diff -r 343:344 http://svn.example.com/repos/calc/trunk

Index: integer.c
===================================================================
-&#64738;-&#64738;- integer.c	(revision 343)
+++ integer.c	(revision 344)
@@ -147,7 +147,7 @@
     case 6:  sprintf(info-&gt;operating_system, "HPFS (OS/2 or NT)"); break;
     case 7:  sprintf(info-&gt;operating_system, "Macintosh"); break;
     case 8:  sprintf(info-&gt;operating_system, "Z-System"); break;
-    case 9:  sprintf(info-&gt;operating_system, "CPM"); break;
+    case 9:  sprintf(info-&gt;operating_system, "CP/M"); break;
     case 10:  sprintf(info-&gt;operating_system, "TOPS-20"); break;
     case 11:  sprintf(info-&gt;operating_system, "NTFS (Windows NT)"); break;
     case 12:  sprintf(info-&gt;operating_system, "QDOS"); break;
@@ -164,7 +164,7 @@
     low = (unsigned short) read_byte(gzfile);  /* read LSB */
     high = (unsigned short) read_byte(gzfile); /* read MSB */
     high = high &lt;&lt; 8;  /* interpret MSB correctly */
-    total = low + high; /* add them togethe for correct total */
+    total = low + high; /* add them together for correct total */
 
     info-&gt;extra_header = (unsigned char *) my_malloc(total);
     fread(info-&gt;extra_header, total, 1, gzfile);
@@ -241,7 +241,7 @@
      Store the offset with ftell() ! */
 
   if ((info-&gt;data_offset = ftell(gzfile))== -1) {
-    printf("error: ftell() retturned -1.\n");
+    printf("error: ftell() returned -1.\n");
     exit(1);
   }
 
@@ -249,7 +249,7 @@
   printf("I believe start of compressed data is %u\n", info-&gt;data_offset);
   #endif
   
-  /* Set postion eight bytes from the end of the file. */
+  /* Set position eight bytes from the end of the file. */
 
   if (fseek(gzfile, -8, SEEK_END)) {
     printf("error: fseek() returned non-zero\n");
</screen>
      @ENGLISH }}} -->
      <screen>
$ svn diff -r 343:344 http://svn.example.com/repos/calc/trunk

Index: integer.c
===================================================================
--- integer.c	(revisjon 343)
+++ integer.c	(revisjon 344)
@@ -147,7 +147,7 @@
     case 6:  sprintf(info-&gt;operating_system, "HPFS (OS/2 or NT)"); break;
     case 7:  sprintf(info-&gt;operating_system, "Macintosh"); break;
     case 8:  sprintf(info-&gt;operating_system, "Z-System"); break;
-    case 9:  sprintf(info-&gt;operating_system, "CPM"); break;
+    case 9:  sprintf(info-&gt;operating_system, "CP/M"); break;
     case 10:  sprintf(info-&gt;operating_system, "TOPS-20"); break;
     case 11:  sprintf(info-&gt;operating_system, "NTFS (Windows NT)"); break;
     case 12:  sprintf(info-&gt;operating_system, "QDOS"); break;
@@ -164,7 +164,7 @@
     low = (unsigned short) read_byte(gzfile);  /* read LSB */
     high = (unsigned short) read_byte(gzfile); /* read MSB */
     high = high &lt;&lt; 8;  /* interpret MSB correctly */
-    total = low + high; /* add them togethe for correct total */
+    total = low + high; /* add them together for correct total */
 
     info-&gt;extra_header = (unsigned char *) my_malloc(total);
     fread(info-&gt;extra_header, total, 1, gzfile);
@@ -241,7 +241,7 @@
      Store the offset with ftell() ! */
 
   if ((info-&gt;data_offset = ftell(gzfile))== -1) {
-    printf("error: ftell() retturned -1.\n");
+    printf("error: ftell() returned -1.\n");
     exit(1);
   }
 
@@ -249,7 +249,7 @@
   printf("I believe start of compressed data is %u\n", info-&gt;data_offset);
   #endif
   
-  /* Set postion eight bytes from the end of the file. */
+  /* Set position eight bytes from the end of the file. */
 
   if (fseek(gzfile, -8, SEEK_END)) {
     printf("error: fseek() returned non-zero\n");
</screen>
      
      <!-- @ENGLISH {{{
      <para>The <command>svn merge</command> command is almost exactly
        the same.  Instead of printing the differences to your
        terminal, however, it applies them directly to your working
        copy as <emphasis>local modifications</emphasis>:</para>
      @ENGLISH }}} -->
      <para>Kommandoen <command>svn merge</command> gjør omtrent 
        nøyaktig det samme.
        Istedenfor å skrive forskjellene til terminalen din, blir de 
        lagt direkte til arbeidskopien din som <emphasis>lokale 
        modifikasjoner</emphasis>:</para>
    
      <screen>
$ svn merge -r 343:344 http://svn.example.com/repos/calc/trunk
U  integer.c

$ svn status
M  integer.c
</screen>

      <!-- @ENGLISH {{{
      <para>The output of <command>svn merge</command> shows that your
        copy of <filename>integer.c</filename> was patched.  It now
        contains Sally's change&mdash;the change has been
        <quote>copied</quote> from the trunk to your working copy of
        your private branch, and now exists as a local modification.
        At this point, it's up to you to review the local modification
        and make sure it works correctly.</para>
      @ENGLISH }}} -->
      <para>Utdataene fra <command>svn merge</command> viser at din kopi 
        av <filename>integer.c</filename> ble patchet.
        Nå inneholder den Sallys forandring – forandringen er blitt 
        <quote>kopiert</quote> fra <filename>trunk</filename> til din 
        arbeidskopi på din private gren, og eksisterer nå som en lokal 
        modifisering.
        På dette punktet er det opp til deg å se over den lokale 
        modifiseringen og forsikre deg om at den fungerer 
        korrekt.</para>

      <!-- @ENGLISH {{{
      <para>In another scenario, it's possible that things may not have
        gone so well, and that <filename>integer.c</filename> may have
        entered a conflicted state.  You might need to resolve the
        conflict using standard procedures (see Chapter 3), or if you
        decide that the merge was a bad idea altogether, simply give up
        and <command>svn revert</command> the local change.</para>
      @ENGLISH }}} -->
      <para>I et annet scenario er det mulig at ting ikke gikk så bra og 
        at <filename>integer.c</filename> gikk inn i en 
        konflikttilstand.
        Du må kanskje løse konflikten ved hjelp av standard prosedyrer 
        (se kapittel 3), eller hvis du finner ut at flettingen egentlig 
        var en dårlig idé, kan du rett og slett gi opp og kjøre 
        <command>svn revert</command> på den lokale forandringen.</para>

      <!-- @ENGLISH {{{
      <para>But assuming that you've reviewed the merged change, you can
        <command>svn commit</command> the change as usual.  At that
        point, the change has been merged into your repository branch.
        In version control terminology, this act of copying changes
        between branches is commonly called
        <firstterm>porting</firstterm> changes.</para>
      @ENGLISH }}} -->
      <para>Men hvis vi går ut i fra at du har sett over forandringen, 
        kan du bruke <command>svn commit</command> til å legge inn 
        forandringen på vanlig måte.
        På dette tidpunktet er forandringen blitt flettet inn i din 
        depotgren.
        I versjonskontrollterminologi blir denne måten å kopiere 
        forandringer mellom forgreninger <!-- ¤ «porting» på norsk 
        blir … ??? Derfor tar jeg med den engelske betegnelsen 
        foreløpig. -->på engelsk kalt 
        <foreignphrase>porting</foreignphrase>.
        <!-- ¤ Og så legger vi til litt. -->Det finnes ikke en 
        standardisert betegnelse for dette på norsk, så vi bruker i 
        denne boken uttrykket <quote>flette</quote>.</para>

      <!-- @ENGLISH {{{
      <para>When you commit the local modification, make sure your log
        message mentions that you're porting a specific change from
        one branch to another.  For example:</para>
      @ENGLISH }}} -->
      <para>Når du legger inn de lokale modifiseringene, bør du forsikre 
        deg om at loggmeldingen din nevner at du fletter en forandring 
        fra en gren til en annen.
        For eksempel:</para>

      <!-- @ENGLISH {{{
      <screen>
$ svn commit -m "integer.c: ported r344 (spelling fixes) from trunk."
Sending        integer.c
Transmitting file data .
Committed revision 360.
</screen>
      @ENGLISH }}} -->
      <screen>
$ svn commit -m "integer.c: Flettet r344 (retting av skrivefeil) fra trunk."
Sending        integer.c
Sender fildata .
La inn revisjon 360.
</screen>

      <!-- @ENGLISH {{{
      <para>As you'll see in the next sections, this is a very
        important <quote>best practice</quote> to follow.</para>
      @ENGLISH }}} -->
      <para>Som du vil se i de neste seksjonene, er dette en veldig 
        viktig <!-- ¤ --><quote>god praksis</quote> å følge.</para>

      <sidebar>
        <!-- @ENGLISH {{{
        <title>Why Not Use Patches Instead?</title>
        @ENGLISH }}} -->
        <title>Hvorfor ikke bruke patcher istedenfor?</title>
        
        <!-- @ENGLISH {{{
        <para>A question may be on your mind, especially if you're a
          Unix user: why bother to use <command>svn merge</command> at
          all?  Why not simply use the operating system's
          <command>patch</command> command to accomplish the same job?
          For example:</para>
        @ENGLISH }}} -->
        <para>Et spørsmål kan lure i bakhodet ditt, spesielt hvis du er 
          en Unixbruker:
          Hvorfor bry seg med å bruke <command>svn merge</command> i det 
          hele tatt?
          Hvorfor ikke rett og slett bruke operativsystemets 
          <command>patch</command>-kommando for å utføre den samme 
          jobben?
          For eksempel:</para>

        <!-- @ENGLISH {{{
        <screen>
$ svn diff -r 343:344 http://svn.example.com/repos/calc/trunk &gt; patchfile
$ patch -p0  &lt; patchfile
Patching file integer.c using Plan A...
Hunk #1 succeeded at 147.
Hunk #2 succeeded at 164.
Hunk #3 succeeded at 241.
Hunk #4 succeeded at 249.
done
</screen>
        @ENGLISH }}} -->
        <screen>
$ svn diff -r 343:344 http://svn.example.com/repos/calc/trunk &gt; patchfil
$ patch -p0  &lt; patchfile
Patching file integer.c using Plan A...
Hunk #1 succeeded at 147.
Hunk #2 succeeded at 164.
Hunk #3 succeeded at 241.
Hunk #4 succeeded at 249.
done
</screen>

        <!-- @ENGLISH {{{
        <para>In this particular case, yes, there really is no
          difference.  But <command>svn merge</command> has special
          abilities that surpass the <command>patch</command> program.
          The file format used by <command>patch</command> is quite
          limited; it's only able to tweak file contents.  There's no
          way to represent changes to <emphasis>trees</emphasis>, such
          as the addition, removal, or renaming of files and
          directories.  If Sally's change had, say, added a new
          directory, the output of <command>svn diff</command>
          wouldn't have mentioned it at all.  <command>svn
          diff</command> only outputs the limited patch-format, so
          there are some ideas it simply can't express.
          <footnote>
            <para>In the future, the Subversion project plans to use
              (or invent) an expanded patch format that describes
              changes in tree structure and properties.</para>
          </footnote>
          The <command>svn merge</command> command, however, can express
          changes in tree structure and properties by directly applying
          them to your working copy.</para>
        @ENGLISH }}} -->
        <para>Ja, i dette spesielle tilfellet er det egentlig ingen 
          forskjell.
          Men <command>svn merge</command> har spesielle evner som 
          overgår <command>patch</command>-programmet.
          Filformatet brukt av <command>patch</command> er ganske 
          begrenset; det er bare i stand til å forandre innhold av 
          filer.
          Det er ingen måte å representere forandringer i 
          <emphasis>trær</emphasis>, som tillegginger, slettinger eller 
          navneskifter på filer og kataloger.
          Hvis Sallys forandring hadde, la oss si, lagt til en katalog, 
          ville utdataene fra <command>svn diff</command> ikke nevnt det 
          i det hele tatt.
          <command>svn diff</command> skriver bare ut det begrensede 
          patch-formatet, så det er noen <!-- ¤ ideas -->forandringer 
          det rett og slett ikke kan vise.<footnote>
            <para>I fremtiden planlegger Subversionprosjektet å bruke 
              (eller finne opp) et utvidet patchformat som beskriver 
              forandringer i trestruktur og egenskaper.</para>
          </footnote>
          <command>svn merge</command>-kommandoen, derimot, kan uttrykke 
          forandringer i trestruktur og egenskaper ved å legge dem 
          direkte inn i arbeidskopien din.</para>

      </sidebar>
      
      <!-- @ENGLISH {{{
      <para>A word of warning: while <command>svn diff</command> and
        <command>svn merge</command> are very similar in concept, they
        do have different syntax in many cases.  Be sure to read about
        them in Chapter 9 for details, or ask <command>svn
        help</command>.  For example, <command>svn merge</command>
        requires a working-copy path as a target, i.e. a place where
        it should apply the tree-changes.  If the target isn't
        specified, it assumes you are trying to perform one of the
        following common operations:</para>
      @ENGLISH }}} -->
      <para>En liten advarsel:
        Selv om <command>svn diff</command> og <command>svn 
        merge</command> er veldig like i konsept, har de i mange 
        tilfeller forskjellig syntaks.
        Vær sikker på at du får lest om dem i kapittel 9 for detaljer, 
        eller spør <command>svn help</command>.
        For eksempel krever <command>svn merge</command> en arbeidskopi 
        som et mål, det vil si en plass hvor den skal legge inn 
        treforandringene.
        Hvis målet ikke er spesifisert, går den ut i fra at du prøver å 
        utføre en av de følgende operasjonene:</para>

      <orderedlist>
        <listitem>
          <!-- @ENGLISH {{{
          <para>You want to merge directory changes into your current
            working directory.</para>
          @ENGLISH }}} -->
          <para>Du vil flette katalogforandringer inn i den gjeldende 
            arbeidskatalogen.</para>
        </listitem>
        <listitem>
          <!-- @ENGLISH {{{
          <para>You want to merge the changes in a specific file into
            a file by the same name which exists in your current working 
            directory.</para>
          @ENGLISH }}} -->
          <para>Du vil flette forandringene i en spesifikk fil inn i en 
            fil med det samme navnet som eksisterer i den gjeldende 
            arbeidskatalogen.</para>
        </listitem>
      </orderedlist>

      <!-- @ENGLISH {{{
      <para>If you are merging a directory and haven't specified a
        target path, <command>svn merge</command> assumes the first case
        above and tries to apply the changes into your current
        directory.  If you are merging a file, and that file (or a file
        by the same name) exists in your current working directory,
        <command>svn merge</command> assumes the second case and tries
        to apply the changes to a local file with the same name.</para>
      @ENGLISH }}} -->
      <para>Hvis du fletter en katalog og ikke har spesifisert en 
        målsti, går <command>svn merge</command> ut i fra det første 
        tilfellet og prøver å legge inn forandringene til den gjeldende 
        katalogen.
        Hvis du fletter en fil, og denne filen (eller en fil med det 
        samme navnet) eksisterer i den gjeldende katalogen, går 
        <command>svn merge</command> ut i fra det andre tilfellet og 
        forsøker å legge inn forandringene til en lokal fil med det 
        samme navnet.</para>
      
      <!-- @ENGLISH {{{
      <para>If you want changes applied somewhere else, you'll
        need to say so.  For example, if you're sitting in the parent
        directory of your working copy, you'll have to specify the
        target directory to receive the changes:</para>
      @ENGLISH }}} -->
      <para>Hvis du vil legge inn forandringer en annen plass, må du si 
        fra om dette.
        Hvis du for eksempel sitter i foreldrekatalogen til 
        arbeidskopien din, må du spesifisere målkatalogen som skal motta 
        forandringene:</para>
      
      <screen>
$ svn merge -r 343:344 http://svn.example.com/repos/calc/trunk my-calc-branch
U   my-calc-branch/integer.c
</screen>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.copychanges.keyconcept">
      <!-- @ENGLISH {{{
      <title>The Key Concept Behind Merging</title>
      @ENGLISH }}} -->
      <title>Nøkkelkonseptet bak fletting</title>

      <!-- @ENGLISH {{{
      <para>You've now seen an example of the <command>svn
          merge</command> command, and you're about to see several
          more.  If you're feeling confused about exactly how merging
          works, you're not alone.  Many users (especially those new
          to version control) are initially perplexed about the proper
          syntax of the command, and about how and when the feature
          should be used.  But fear not, this command is actually much
          simpler than you think!  There's a very easy technique for
          understanding exactly how <command>svn merge</command>
          behaves.</para>
      @ENGLISH }}} -->
      <para>Du har nå sett et eksempel på <command>svn 
        merge</command>-kommandoen, og du skal få se flere.
        Hvis du er forvirret omkring hvordan fletting faktisk virker, er 
        du ikke alene om det.
        Mange brukere (spesielt de som er nye innen versjonskontroll) er 
        usikker på den riktige syntaksen til kommandoen, og når denne 
        funksjonaliteten skal brukes.
        Men frykt ikke, denne kommandoen er faktisk mye enklere enn du 
        tror!
        Det er en veldig enkel teknikk for å forstå nøyaktig hvordan 
        <command>svn merge</command> virker.</para>

      <!-- @ENGLISH {{{
      <para>The main source of confusion is the
        <emphasis>name</emphasis> of the command.  The term
        <quote>merge</quote> somehow denotes that branches are
        combined together, or that there's some sort of mysterious
        blending of data going on.  That's not the case.  A better
        name for the command might have been <command>svn
        diff-and-apply</command>, because that's all that happens:
        two repository trees are compared, and the differences are
        applied to a working copy.</para>
      @ENGLISH }}} -->
      <para>Hovedkilden til forvirringen er <emphasis>navnet</emphasis> 
        på kommandoen.
        Terminologien <foreignphrase>merge</foreignphrase> – 
        <quote>flette</quote> – indikerer på en måte at grener blir 
        kombinert sammen, eller at det er en form for mystisk 
        sammenblanding av data som foregår.
        Det er ikke tilfellet.
        Et bedre navn for kommandoen hadde vært <command>svn 
        diff-and-apply</command> – <quote>finn forskjell og legg denne 
        til</quote> – fordi det er alt som skjer:
        To depottrær blir sammenlignet, og forskjellene blir lagt inn i 
        arbeidskopien.</para>

      <!-- @ENGLISH {{{
      <para>The command takes three arguments:</para>
      @ENGLISH }}} -->
      <para>Kommandoen tar tre argumenter:</para>

      <orderedlist>

        <!-- @ENGLISH {{{
        <listitem><para>An initial repository tree (often called the
        <firstterm>left side</firstterm> of the
        comparison),</para></listitem>
        @ENGLISH }}} -->
        <listitem>
          <para>Et innledende depottre (ofte kalt den <firstterm>venstre 
            siden</firstterm> av sammenligningen),</para>
        </listitem>

        <!-- @ENGLISH {{{
        <listitem><para>A final repository tree (often called the
        <firstterm>right side</firstterm> of the
        comparison),</para></listitem>
        @ENGLISH }}} -->
        <listitem>
          <para>Et slutt-depottre (ofte kalt den <firstterm>høyre 
            siden</firstterm> av sammenligningen),</para>
        </listitem>

        <!-- @ENGLISH {{{
        <listitem><para>A working copy to accept the differences as
        local changes (often called the <firstterm>target</firstterm>
        of the merge).</para></listitem>
        @ENGLISH }}} -->
        <listitem>
          <para>En arbeidskopi som skal motta forandringene som lokale 
            forandringer (ofte kalt <firstterm>målet</firstterm> til 
            flettingen).</para>
        </listitem>
        
      </orderedlist>

      <!-- @ENGLISH {{{
      <para>Once these three arguments are specified, the two trees
        are compared, and the resulting differences are applied to the
        target working copy as local modifications.  When the command
        is done, the results are no different than if you had
        hand-edited the files, or run various <command>svn
        add</command> or <command>svn delete</command> commands
        yourself.  If you like the results, you can commit them.  If
        you don't like the results, you can simply <command>svn
        revert</command> all of the changes.</para>
      @ENGLISH }}} -->
      <para>Når disse tre argumentene er spesifisert, blir de to trærne 
        sammenlignet og de forskjellene som programmet finner blir lagt 
        inn i mål-arbeidskopien som lokale forandringer.
        Når kommandoen er ferdig, er ikke resultatet forskjellig fra om 
        du hadde redigert filene for hånd, eller selv kjørt diverse 
        <command>svn add</command> eller <command>svn 
        delete</command>-kommandoer.
        Hvis du ikke liker resultatene, kan du enkelt kjøre <command>svn 
        revert</command> for å omgjøre alle forandringene.</para>

      <!-- @ENGLISH {{{
      <para>The syntax of <command>svn merge</command> allows you to
        specify the three necessary arguments rather flexibly.  Here
        are some examples:</para>
      @ENGLISH }}} -->
      <para>Syntaksen til <command>svn merge</command> lar deg 
        spesifisere de tre nødvendige argumentene ganske fleksibelt.
        Her er noen eksempler:</para>

      <!-- @ENGLISH {{{
      <screen>      
$ svn merge http://svn.example.com/repos/branch1@150 \
            http://svn.example.com/repos/branch2@212 \
            my-working-copy
            
$ svn merge -r 100:200 http://svn.example.com/repos/trunk my-working-copy

$ svn merge -r 100:200 http://svn.example.com/repos/trunk
</screen>
      @ENGLISH }}} -->
      <screen>
$ svn merge http://svn.example.com/repos/branch1@150 \
            http://svn.example.com/repos/branch2@212 \
            min-arbeidskopi

$ svn merge -r 100:200 http://svn.example.com/repos/trunk min-arbeidskopi

$ svn merge -r 100:200 http://svn.example.com/repos/trunk
</screen>

      <!-- @ENGLISH {{{
      <para>The first syntax lays out all three arguments explicitly,
        naming each tree in the form <emphasis>URL@REV</emphasis> and
        naming the working copy target.  The second syntax can be used
        as a shorthand for situations when you're comparing two
        different revisions of the same URL.  The last syntax shows
        how the working-copy argument is optional; if omitted, it
        defaults to the current directory.</para>
      @ENGLISH }}} -->
      <para>Den første syntaksen legger spesifikt opp alle tre 
        argumentene, ved å nevne hvert tre på formen 
        <emphasis>URL@REV</emphasis> og nevne arbeidskopimålet.
        Den andre syntaksen kan bli brukt som en snarvei for situasjoner 
        når du sammenligner to forskjellige revisjoner på den samme 
        URLen.
        Den siste syntaksen viser hvordan arbeidskopiargumentet er 
        valgfritt; hvis det er utelatt, brukes den gjeldende 
        katalogen.</para>


    </sect2>
    
    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.copychanges.bestprac">
      <!-- @ENGLISH {{{
      <title>Best Practices for Merging</title>
      @ENGLISH }}} -->
      <title>Beste praksiser for fletting</title>

      <sect3 id="svn.branchmerge.copychanges.bestprac.track">
        <!-- @ENGLISH {{{
        <title>Tracking Merges Manually</title>
        @ENGLISH }}} -->
        <title>Følge flettinger manuelt</title>

        <!-- @ENGLISH {{{
        <para>Merging changes sounds simple enough, but in practice it
          can become a headache.  The problem is that if you
          repeatedly merge changes from one branch to another, you
          might accidentally merge the same change
          <emphasis>twice</emphasis>.  When this happens, sometimes
          things will work fine.  When patching a file, Subversion
          typically notices if the file already has the change, and
          does nothing.  But if the already-existing change has been
          modified in any way, you'll get a conflict.</para>
        @ENGLISH }}} -->
        <para>Fletting av forandringer høres enkelt ut, men i praksis 
          kan det bli en hodepine.
          Problemet er at hvis du gjentatte ganger fletter forandringer 
          fra en gren til en annen, kan du ved en ulykke flette den 
          samme forandringen <emphasis>to ganger</emphasis>.
          Når dette skjer, vil det noen ganger gå bra.
          Når en fil blir patchet vil Subversion vanligvis oppdage at 
          filen inneholder forandringen, og gjør ingenting.
          Men hvis den allerede eksisterende forandringen er blitt 
          forandret på en eller annen måte, vil du få en 
          konflikt.</para>

        <!-- @ENGLISH {{{
        <para>Ideally, your version control system should prevent the
          double-application of changes to a branch.  It should
          automatically remember which changes a branch has already
          received, and be able to list them for you.  It should use
          this information to help automate merges as much as
          possible.</para>
        @ENGLISH }}} -->
        <para>Ideelt sett bør versjonskontrollsystemet forhindre <!-- ¤ 
          -->forsøket på å legge inn doble forandringer til en gren.
          Det bør huske automatisk hvilke forandringer en gren allerede 
          har mottatt, og bør være i stand til å liste dem ut for deg.
          Det bør bruke denne informasjonen til å hjelpe til med å 
          automatisere flettinger så mye som mulig.</para>

        <!-- @ENGLISH {{{
        <para>Unfortunately, Subversion is not such a system.  Like
          CVS, Subversion does not yet record any information about
          merge operations.  When you commit local modifications, the
          repository has no idea whether those changes came from
          running <command>svn merge</command>, or from just
          hand-editing the files.</para>
        @ENGLISH }}} -->
        <para>Dessverre er ikke Subversion et sånt system.
          I likhet med CVS lagrer ikke Subversion 1.0 noen informasjon 
          om fletteoperasjoner.
          Når du legger inn lokale forandringer, har ikke depotet noen 
          idé om hvorvidt disse forandringene kom fra en kjøring av 
          <command>svn merge</command>, eller fra en redigering av 
          filene for hånd.</para>

        <!-- @ENGLISH {{{
        <para>What does this mean to you, the user?  It means that
          until the day Subversion grows this feature, you'll have to
          track merge information yourself.  The best place to do this
          is in the commit log-message.  As demonstrated in the
          earlier example, it's recommended that your log-message
          mention a specific revision number (or range of revisions)
          that are being merged into your branch.  Later on, you can
          run <command>svn log</command> to review which changes your
          branch already contains.  This will allow you to carefully
          construct a subsequent <command>svn merge</command> command
          that won't be redundant with previously ported
          changes.</para>
        @ENGLISH }}} -->
        <para>Hva betyr dette for deg, brukeren?
          Det betyr at inntil den dagen Subversion får denne funksjonen, 
          må du selv holde rede på fletteinformasjonen.
          Den beste plassen å gjøre dette er i selve loggmeldingen.
          Som demonstrert i det tidligere eksempelet, anbefales det at 
          loggmeldingen din nevner et spesifikt revisjonsnummer (eller 
          område av revisjoner) som blir flettet inn i grenen.
          Senere kan du kjøre <command>svn log</command> for å se over 
          hvilke forandringer forgreningen allerede inneholder.
          Dette vil la deg varsomt konstruere en etterfølgende 
          <command>svn merge</command>-kommando som ikke vil bli <!-- ¤ 
          -->overflødig i forhold til tidligere <!-- ¤ -->flettede 
          forandringer.</para>

        <!-- @ENGLISH {{{
        <para>In the next section, we'll show some examples of this
          technique in action.</para>
        @ENGLISH }}} -->
        <para>I den neste seksjonen vil vi vise noen eksempler på denne 
          teknikken i praksis.</para>

      </sect3>
      
      <sect3 id="svn.branchmerge.copychanges.bestprac.preview">
        <!-- @ENGLISH {{{
        <title>Previewing Merges</title>
        @ENGLISH }}} -->
        <title>Vise flettinger på forhånd</title>
        
        <!-- @ENGLISH {{{
        <para>Because merging only results in local modifications,
          it's not usually a high-risk operation.  If you get the
          merge wrong the first time, simply <command>svn
          revert</command> the changes and try again.</para>
        @ENGLISH }}} -->
        <para>Fordi fletting bare resulterer i lokale modifikasjoner, er 
          det vanligvis ikke noen høyrisikooperasjon.
          Hvis flettingen går galt første gangen, kan du kjøre 
          <command>svn revert</command> på forandringene og prøve 
          igjen.</para>
        
        <!-- @ENGLISH {{{
        <para>It's possible, however, that your working copy might
          already have local modifications.  The changes applied by a
          merge will be mixed with your pre-existing ones, and running
          <command>svn revert</command> is no longer an option.  The
          two sets of changes may be impossible to separate.</para>
        @ENGLISH }}} -->
        <para>Men det er derimot mulig at arbeidskopien din allerede 
          inneholder lokale forandringer.
          Forandringene lagt inn av en fletting vil bli blandet med de 
          du har fra før, og det å kjøre <command>svn revert</command> 
          er ikke lenger et alternativ.
          De to settene med forandringer kan bli umulig å 
          separere.</para>

        <!-- @ENGLISH {{{
        <para>In cases like this, people take comfort in being able to
          predict or examine merges before they happen.  One simple
          way to do that is to run <command>svn diff</command> with
          the same arguments you plan to pass to <command>svn
          merge</command>, as we already showed in our first example
          of merging.  Another method of previewing is to pass the
          <option>-&#64738;-dry-run</option> option to the merge
          command:</para>
        @ENGLISH }}} -->
        <para>I tilfeller som dette vil det være greit å kunne forutsi 
          eller undersøke forandringer før de skjer.
          En enkel måte å gjøre det på er å kjøre <command>svn 
          diff</command> med de samme argumentene som du planlegger å gi 
          til <command>svn merge</command>, som vi allerede har vist i 
          det første eksemplet vårt med fletting.
          En annen metode for forhåndsvisning er å angi 
          <option>--dry-run</option>-valget til flettekommandoen:</para>

        <!-- @ENGLISH {{{
        <screen>
$ svn merge -&#64738;-dry-run -r 343:344 http://svn.example.com/repos/calc/trunk
U  integer.c

$ svn status
#  nothing printed, working copy is still unchanged.
</screen>
        @ENGLISH }}} -->
        <screen>
$ svn merge --dry-run -r 343:344 http://svn.example.com/repos/calc/trunk
U  integer.c

$ svn status
# ingenting blir skrevet ut, arbeidskopien er fortsatt uforandret.
</screen>

        <!-- @ENGLISH {{{
        <para>The <option>-&#64738;-dry-run</option> option doesn't actually
          apply any local changes to the working copy.  It only shows
          status codes that <emphasis>would</emphasis> be printed in a
          real merge.  It's useful for getting a <quote>high
          level</quote> preview of the potential merge, for those
          times when running <command>svn diff</command> gives too
          much detail.</para>
        @ENGLISH }}} -->
        <para><option>--dry-run</option>-valget gjør egentlig ingen 
          forandringer i arbeidskopien.
          Det viser bare statuskoder som <emphasis>ville</emphasis> 
          blitt skrevet ut under en virkelig fletting.
          Det er nyttig for å få en <quote>høynivå</quote>-oversikt over 
          den potensielle flettingen for de gangene der kjøring av 
          <command>svn diff</command> gir alt for mange detaljer.</para>

      </sect3>

      <sidebar>
        <!-- @ENGLISH {{{
        <title>Subversion and Changesets</title>
        @ENGLISH }}} -->
        <title>Subversion og forandringssett 
        (<foreignphrase>changesets</foreignphrase>)</title>

        <!-- @ENGLISH {{{
        <para>Everyone seems to have a slightly different definition
          of <quote>changeset</quote>, or at least a different
          expectation of what it means for a version control system to
          have <quote>changeset features</quote>.  For our purpose,
          let's say that a changeset is just a collection of changes
          with a unique name.  The changes might include textual edits
          to file contents, modifications to tree structure, or tweaks
          to metadata.  In more common speak, a changeset is just a
          patch with a name you can refer to.</para>
        @ENGLISH }}} -->
        <para>Alle ser ut til å ha litt forskjellige definisjoner av 
          <quote>forandringssett</quote>, eller i det minste 
          forskjellige forventninger av hva det betyr for et 
          versjonskontrollsystem å ha 
          <quote>forandringssettfunksjonalitet</quote>.
          For vårt bruk, la oss si at et forandringssett bare er en 
          samling av forandringer med et unikt navn.
          Forandringene kan inkludere tekstmessige redigeringer i 
          filinnhold, forandringer i en trestruktur, eller forandringer 
          i metadata.
          Sagt på en mer folkelig måte, et forandringssett er bare en 
          patch med et navn du kan referere til.</para>

        <!-- @ENGLISH {{{
        <para>In Subversion, a global revision number N names a tree
          in the repository: it's the way the repository looked after
          the Nth commit.  It's also the name of an implicit
          changeset: if you compare tree N with tree N-1, you can
          derive the exact patch that was committed.  For this reason,
          it's easy to think of <quote>revision N</quote> as not just
          a tree, but a changeset as well.  If you use an issue
          tracker to manage bugs, you can use the revision numbers to
          refer to particular patches that fix bugs&mdash;for example,
          <quote>this issue was fixed by revision 9238.</quote>.
          Somebody can then run <command>svn log -r9238</command> to
          read about the exact changeset which fixed the bug, and run
          <command>svn diff -r9237:9238</command> to see the patch
          itself.  And Subversion's <literal>merge</literal> command
          also uses revision numbers.  You can merge specific changesets
          from one branch to another by naming them in the merge
          arguments: <command>svn merge -r9237:9238</command> would
          merge changeset #9238 into your working copy.</para>
        @ENGLISH }}} -->
        <para>I Subversion gir et globalt revisjonsnummer N navn til et 
          tre i depotet:
          Det er måten depotet så ut etter den Nte innleggingen.
          Det er også navnet på et implisitt forandringssett:
          Hvis du sammenligner treet N med treet N-1, kan du derivere 
          den eksakte patchen som ble lagt inn.
          På grunn av dette er det lett å tenke på <quote>revisjon 
          N</quote> som ikke bare et tre, men også et forandringssett.
          Hvis du bruker en feildatabase – <!-- ¤ 
          --><foreignphrase>issue tracker</foreignphrase> – for å holde 
          rede på programfeil, kan du bruke revisjonsnumre til å 
          referere til spesielle patcher som fikser feil – for eksempel, 
          <quote>denne feilen ble fikset i revisjon 9238.</quote>.
          Noen kan da kjøre <command>svn log -r9238</command> for å lese 
          om det eksakte forandringssettet som ordnet feilen, og kjøre 
          <command>svn diff -r9237:9238</command> for å se selve 
          patchen.
          Og Subversions <literal>merge</literal>-kommando bruker også 
          revisjonsnumre.
          Du kan flette spesifikke forandringssett fra en gren til en 
          annen ved å gi dem navn i fletteargumentene:
          <command>svn merge -r9237:9238</command> vil flette 
          forandringssett #9238 inn i arbeidskopien din.</para>
      </sidebar>

      <sect3 id="svn.branchmerge.copychanges.bestprac.merge">
        <!-- @ENGLISH {{{
        <title>Merge Conflicts</title>
        @ENGLISH }}} -->
        <title>Konflikter under fletting</title>

        <!-- @ENGLISH {{{
        <para>Just like the <command>svn update</command> command,
          <command>svn merge</command> applies changes to your working
          copy.  And therefore it's also capable of creating
          conflicts.  The conflicts produced by <command>svn
          merge</command>, however, are sometimes different, and this
          section explains those differences.</para>
        @ENGLISH }}} -->
        <para>Akkurat som <command>svn update</command>-kommandoen, 
          legger <command>svn merge</command> inn forandringer i 
          arbeidskopien din.
          Og derfor er den også i stand til å lage konflikter.
          Konfliktene produsert av <command>svn merge</command> er 
          imidlertid noen ganger forskjellige, og denne seksjonen 
          forklarer disse forskjellene.</para>

        <!-- @ENGLISH {{{
        <para>To begin with, assume that your working copy has no
          local edits.  When you <command>svn update</command> to a
          particular revision, the changes sent by the server will
          always apply <quote>cleanly</quote> to your working copy.
          The server produces the delta by comparing two trees: a
          virtual snapshot of your working copy, and the revision tree
          you're interested in.  Because the left-hand side of the
          comparison is exactly equal to what you already have, the
          delta is guaranteed to correctly convert your working copy
          into the right-hand tree.</para>
        @ENGLISH }}} -->
        <para>Til å begynne med, tenk deg at arbeidskopien din ikke 
          inneholder noen lokale redigeringer.
          Når du <command>svn update</command>-er til en spesiell 
          revisjon, vil forandringene sendt fra &the_server; alltid bli 
          lagt inn på en <quote>renslig</quote> måte i arbeidskopien.
          &The_server; produsererer deltaet ved å sammenligne to trær:
          Et virtuelt øyeblikksbilde av arbeidskopien din, og 
          revisjonstreet du er er interessert i.
          Fordi den venstre siden av sammenligningen er nøyaktig lik det 
          du allerede har, er deltaet garantert å korrekt konvertere 
          arbeidskopien din til treet som er på høyre side.</para>

        <!-- @ENGLISH {{{
        <para>But <command>svn merge</command> has no such guarantees
          and can be much more chaotic: the user can ask the server to
          compare <emphasis>any</emphasis> two trees at all, even ones
          that are unrelated to the working copy!  This means there's
          large potential for human error.  Users will sometimes
          compare the wrong two trees, creating a delta that doesn't
          apply cleanly.  <command>svn merge</command> will do its
          best to apply as much of the delta as possible, but some
          parts may be impossible.  Just like the Unix
          <command>patch</command> command sometimes complains about
          <quote>failed hunks</quote>, <command>svn merge</command>
          will complain about <quote>skipped targets</quote>:</para>
        @ENGLISH }}} -->
        <para>Men <command>svn merge</command> har ingen slike garantier 
          og kan være mye mer kaotisk:
          Brukeren kan be &the_server; om å sammenligne <emphasis>alle 
          mulige</emphasis> trær, til og med trær som ikke er relatert 
          til arbeidskopien!
          Dette betyr at det er et stort potensiale for menneskelige 
          feil.
          Brukere vil noen ganger sammenligne to gale trær, og dermed 
          lage et delta som ikke kan legges inn på en ren måte.
          <command>svn merge</command> vil gjøre sitt beste for å legge 
          inn så mye av deltaet som mulig, men noen deler kan være 
          umulige.
          Akkurat som <command>patch</command>-kommandoen i Unix noen 
          ganger klager over <!-- ¤ --><quote>failed hunks</quote>, vil 
          <command>svn merge</command> klage over <!-- ¤ 
          --><quote>skipped targets</quote>:</para>

        <!-- @ENGLISH {{{
        <screen>
$ svn merge -r 1288:1351 http://svn.example.com/repos/branch
U  foo.c
U  bar.c
Skipped missing target: 'baz.c'
U  glub.c
C  glorb.h

$
</screen>
        @ENGLISH }}} -->
        <screen>
$ svn merge -r 1288:1351 http://svn.example.com/repos/branch
U  foo.c
U  bar.c
Hoppet over savnet mål: «baz.c»
U  glub.c
C  glorb.h

$
</screen>

        <!-- @ENGLISH {{{
        <para>In the previous example it might be the case that
          <filename>baz.c</filename> exists in both snapshots of the
          branch being compared, and the resulting delta wants to
          change the file's contents, but the file doesn't exist in
          the working copy.  Whatever the case, the
          <quote>skipped</quote> message means that the user is most
          likely comparing the wrong two trees; they're the classic
          sign of driver error.  When this happens, it's easy to
          recursively revert all the changes created by the merge
          (<command>svn revert -&#64738;-recursive</command>), delete any
          unversioned files or directories left behind after the
          revert, and re-run <command>svn merge</command> with
          different arguments.</para>
        @ENGLISH }}} -->
        <para>I det forrige eksempelet kan tilfellet være at 
          <filename>baz.c</filename> eksisterer både i øyeblikksbildet 
          av grenen som sammenlignes, og det resulterende deltaet vil 
          forandre filens innhold, men filen eksisterer ikke i 
          arbeidskopien.
          Hva som enn er tilfelle, betyr <!-- ¤ 
          --><quote>skipped</quote>-meldingen at brukeren mest 
          sannsynlig sammenligner to gale trær; de er det klassiske 
          tegnet på en feil gjort av <!-- ¤ driver = sjåfør? 
          -->brukeren.
          Når dette skjer er det lett å rekursivt omgjøre alle 
          forandringene gjort under flettingen (<command>svn revert 
          --recursive</command>), slette eventuelle uversjonerte filer 
          eller kataloger som ligger igjen etter tilbakestillingen, og 
          kjøre <command>svn merge</command> med forskjellige 
          argumenter.</para>

        <!-- @ENGLISH {{{
        <para>Also notice that the previous example shows a conflict
          happening on <filename>glorb.h</filename>.  We already
          stated that the working copy has no local edits: how can a
          conflict possibly happen?  Again, because the user can use
          <command>svn merge</command> to define and apply any old
          delta to the working copy, that delta may contain textual
          changes that don't cleanly apply to a working file, even if
          the file has no local modifications.</para>
        @ENGLISH }}} -->
        <para>Legg også merke til at det forrige eksempelet viser en 
          konflikt som skjer i <filename>glorb.h</filename>.
          Vi har allerede fastslått at arbeidskopien ikke har noen 
          lokale forandringer; <!-- ¤ semikolon istedenfor kolon -->
          hvordan er det da mulig at en lokal konflikt kan oppstå?
          Igjen, fordi brukeren kan bruke <command>svn merge</command> 
          for å definere og legge til enhver gammel delta til 
          arbeidskopien, kan denne deltaen inneholde tekstmessige 
          forandringer som ikke kan legges helt uproblematisk inn i en 
          arbeidsfil, selv om denne filen ikke har noen lokale 
          forandringer.</para>

        <!-- @ENGLISH {{{
        <para>Another small difference between <command>svn
          update</command> and <command>svn merge</command> are the
          names of the full-text files created when a conflict
          happens.  In <xref linkend="svn.tour.cycle.resolve"/>, we saw
          that an update produces files named
          <filename>filename.mine</filename>,
          <filename>filename.rOLDREV</filename>, and
          <filename>filename.rNEWREV</filename>.  When <command>svn
          merge</command> produces a conflict, though, it creates
          three files named <filename>filename.working</filename>,
          <filename>filename.left</filename>, and
          <filename>filename.right</filename>.  In this case, the
          terms <quote>left</quote> and <quote>right</quote> are
          describing which side of the double-tree comparison the file
          came from.  In any case, these differing names will help you
          distinguish between conflicts that happened as a result of an
          update versus ones that happened as a result of a
          merge.</para>
        @ENGLISH }}} -->
        <para>En annen liten forskjell mellom <command>svn 
          update</command> og <command>svn merge</command> er navnene på 
          fulltekst-filene som blir opprettet når en konflikt oppstår.
          I <xref linkend="svn.tour.cycle.resolve"/> så vi at en 
          oppdatering produserer filene 
          <filename>filnavn.mine</filename>, 
          <filename>filnavn.rGAMMELREV</filename> og 
          <filename>filnavn.rNYREV</filename>.
          Men når <command>svn merge</command> produserer en konflikt, 
          oppretter den tre filer kalt 
          <filename>filnavn.working</filename>, 
          <filename>filnavn.left</filename> og 
          <filename>filename.right</filename>.
          I dette tilfellet beskriver terminologien <quote>left</quote> 
          og <quote>right</quote> hvilken side filen kom fra.
          I alle fall, disse forskjellige navnene vil hjelpe deg å 
          skille mellom filer som er opprettet som følge av en 
          oppdatering versus filer som er opprettet som resultat av en 
          fletting.</para>

      </sect3>
      
      <sect3 id="svn.branchmerge.copychanges.bestprac.ancestry">
        <!-- @ENGLISH {{{
        <title>Noticing or Ignoring Ancestry</title>
        @ENGLISH }}} -->
        <title>Legge merke til eller ignorere slektskap</title>

        <!-- @ENGLISH {{{
        <para>When conversing with a Subversion developer, you might
          very likely hear reference to the term
          <firstterm>ancestry</firstterm>.  This word is used to
          describe the relationship between two objects in a
          repository: if they're related to each other, then one
          object is said to be an ancestor of the other.</para>
        @ENGLISH }}} -->
        <para>Når du snakker med en Subversionutvikler kan det hende du 
          hører referanser til begrepet <firstterm>slektskap</firstterm> 
          – <foreignphrase>ancestry</foreignphrase>.
          Dette ordet blir brukt til å beskrive forholdet mellom to 
          objekter i et depot:
          Hvis de er relaterte til hverandre, vil det ene objektet være 
          en stamfar til det andre.</para>

        <!-- @ENGLISH {{{
        <para>For example, suppose you commit revision 100, which
          includes a change to a file <filename>foo.c</filename>.
          Then <filename>foo.c@99</filename> is an
          <quote>ancestor</quote> of <filename>foo.c@100</filename>.
          On the other hand, suppose you commit the deletion of
          <filename>foo.c</filename> in revision 101, and then add a
          new file by the same name in revision 102.  In this case,
          <filename>foo.c@99</filename> and
          <filename>foo.c@102</filename> may appear to be related
          (they have the same path), but in fact are completely
          different objects in the repository.  They share no history
          or <quote>ancestry</quote>.</para>
        @ENGLISH }}} -->
        <para>For eksempel, tenk deg at du legger inn revisjon 100, som 
          inkluderer en forandring i en fil kalt 
          <filename>foo.c</filename>.
          Da er <filename>foo.c@99</filename> en <quote>stamfar</quote> 
          til <filename>foo.c@100</filename>.
          På den annen side, tenk at du legger inn en sletting av 
          <filename>foo.c</filename> i revisjon 101, og deretter legger 
          til en ny fil med det samme navnet i revisjon 102.
          I dette tilfellet kan det se ut som om 
          <filename>foo.c@99</filename> og 
          <filename>foo.c@102</filename> er relaterte (de har den samme 
          filstien), men de er faktisk totalt forskjellige objekter i 
          depotet.
          De deler ingen historie eller <quote>slektskap</quote>.</para>

        <!-- @ENGLISH {{{
        <para>The reason for bringing this up is to point out an
          important difference between <command>svn diff</command> and
          <command>svn merge</command>.  The former command ignores
          ancestry, while the latter command is quite sensitive to it.
          For example, if you asked <command>svn diff</command> to
          compare revisions 99 and 102 of <filename>foo.c</filename>,
          you would see line-based diffs; the <literal>diff</literal>
          command is blindly comparing two paths.  But if you asked
          <command>svn merge</command> to compare the same two objects,
          it would notice that they're unrelated and first attempt to
          delete the old file, then add the new file;  the output would
          indicate a deletion followed by an add:</para>
        @ENGLISH }}} -->
        <para>Grunnen til at vi tar dette opp er for å fremheve en 
          viktig forskjell mellom <command>svn diff</command> og 
          <command>svn merge</command>.
          Den første kommandoen ignorerer slektskap, mens den sistnevnte 
          kommandoen er ganske følsom for det.
          Hvis du for eksempel ber <command>svn diff</command> om å 
          sammenligne revisjon 99 og 102 av <filename>foo.c</filename>, 
          vil du se linjebaserte forskjeller; 
          <literal>diff</literal>-kommandoen sammenligner blindt to 
          stier.
          Men hvis du ber <command>svn merge</command> om å sammenligne 
          de samme to objektene, vil den oppdage at de er urelaterte og 
          først prøve å slette den gamle filen og deretter legge til den 
          nye filen.
          Utdataene fra programmet vil indikere en sletting etterfulgt 
          av en tillegging:</para>

        <screen>
D  foo.c
A  foo.c
</screen>

        <!-- @ENGLISH {{{
        <para>Most merges involve comparing trees that are ancestrally
          related to one another, and therefore <command>svn
          merge</command> defaults to this behavior.  Occasionally,
          however, you may want the <literal>merge</literal> command to
          compare two unrelated trees.  For example, you may have
          imported two source-code trees representing different vendor
          releases of a software project (see <xref
          linkend="svn.advanced.vendorbr"/>).
          If you asked <command>svn merge</command> to compare the two
          trees, you'd see the entire first tree being deleted,
          followed by an add of the entire second tree!</para>
        @ENGLISH }}} -->
        <para>De fleste flettinger involverer sammenligning av trær som 
          er slektsmessig relatert til hverandre, og derfor har 
          <command>svn merge</command> denne oppførselen som standard.
          Men nå og da vil du kanskje bruke 
          <literal>merge</literal>-kommandoen til å sammenligne to 
          urelaterte trær.
          For eksempel har du kanskje importert to kildekodetrær som 
          representerer forskjellige <!-- ¤ vendor --> utgivelser av et 
          programprosjekt (se <xref linkend="svn.advanced.vendorbr"/>).
          Hvis du ber <command>svn merge</command> om å sammenligne de 
          to trærne, vil du se at hele det første treet blir slettet, 
          fulgt av en tillegging av hele det andre treet!</para>

        <!-- @ENGLISH {{{
        <para>In these situations, you'll want <command>svn
          merge</command> to do a path-based comparison only, ignoring
          any relations between files and directories.  Add the
          <option>-&#64738;-ignore-ancestry</option> option to your merge
          command, and it will behave just like <command>svn
          diff</command>.  (And conversely, the
          <option>-&#64738;-notice-ancestry</option> option will cause
          <command>svn diff</command> to behave like the
          <literal>merge</literal> command.)</para>
        @ENGLISH }}} -->
        <para>I disse situasjonene vil du at <command>svn 
          merge</command> bare gjør en stibasert sammenligning og 
          ignorerer enhver relasjon mellom filer og kataloger.
          Legg til valget <option>--ignore-ancestry</option> til 
          flettekommandoen, og den vil oppføre seg akkurat som 
          <command>svn diff</command>.
          (Og på motsatt måte vil 
          <option>--notice-ancestry</option>-valget få <command>svn 
          diff</command> til å oppføre seg som 
          <literal>merge</literal>-kommandoen.</para>

      </sect3>

    </sect2>


  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.commonuses">
    <!-- @ENGLISH {{{
    <title>Common Use-Cases</title>
    @ENGLISH }}} -->
    <title>Vanlige bruksområder</title>

    <!-- @ENGLISH {{{
    <para>There are many different uses for branching and <command>svn
      merge</command>, and this section describes the most common ones
      you're likely to run into.</para>
    @ENGLISH }}} -->
    <para>Det er mange forskjellige bruksområder for forgreninger og 
      <command>svn merge</command>, og denne seksjonen beskriver de 
      vanligste som du sannsynligvis vil komme over.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.commonuses.wholebr">
      <!-- @ENGLISH {{{
      <title>Merging a Whole Branch to Another</title>
      @ENGLISH }}} -->
      <title>Flette en hel gren til en annen</title>

      <!-- @ENGLISH {{{
      <para>To complete our running example, we'll move forward in
        time.  Suppose several days have passed, and many changes have
        happened on both the trunk and your private branch.  Suppose
        that you've finished working on your private branch; the
        feature or bug fix is finally complete, and now you want to
        merge all of your branch changes back into the trunk for
        others to enjoy.</para>
      @ENGLISH }}} -->
      <para>For å fullføre eksempelet vårt vil vi nå reise fram i tiden.
        Tenk deg at flere dager har gått, og mange forandringer har 
        skjedd både i trunk og på den private grenen din.
        Tenk deg så at du er ferdig med arbeidet på den private grenen; 
        funksjonaliteten eller feilrettingen er endelig fullført, og nå 
        vil du flette alle forandringene fra grenen din til trunk så 
        andre kan få glede av dem.</para>

      <!-- @ENGLISH {{{
      <para>So how do we use <command>svn merge</command> in this
        scenario?  Remember that this command compares two trees, and
        applies the differences to a working copy.  So to receive the
        changes, you need to have a working copy of the trunk.  We'll
        assume that either you still have your original one lying
        around (fully updated), or that you recently checked out a
        fresh working copy of <filename>/calc/trunk</filename>.</para>
      @ENGLISH }}} -->
      <para>Så hvordan bruker vi <command>svn merge</command> i dette 
        tilfellet?
        Husk at denne kommandoen sammenligner to trær og legger 
        forandringene inn i en arbeidskopi.
        For å motta forandringene må du derfor ha en arbeidskopi av 
        trunk.
        Vi går ut i fra at du enten har den originale liggende (helt 
        oppdatert), eller at du nylig hentet ut en fersk arbeidskopi av 
        <filename>/calc/trunk</filename>.</para>

      <!-- @ENGLISH {{{
      <para>But which two trees should be compared?  At first glance,
        the answer may seem obvious: just compare the latest trunk
        tree with your latest branch tree.  But beware&mdash;this
        assumption is <emphasis>wrong</emphasis>, and has burned many
        a new user!  Since <command>svn merge</command> operates like
        <command>svn diff</command>, comparing the latest trunk and 
        branch trees will <emphasis>not</emphasis> merely describe
        the set of changes you made to your branch.  Such a comparison
        shows too many changes: it would not only show the addition of
        your branch changes, but also the <emphasis>removal</emphasis>
        of trunk changes that never happened on your branch.</para>
      @ENGLISH }}} -->
      <para>Men hvilke to trær skal sammenlignes?
        Ved første øyekast ser det innlysende ut:
        Bare sammenlign seneste treet fra trunk med det seneste treet 
        fra forgreningen.
        Men pass på – denne antakelsen er <emphasis>feil</emphasis>, noe 
        som mange nye brukere har brent seg på.
        Siden <command>svn merge</command> opererer på samme måte som
        <command>svn diff</command>, vil en sammenligning mellom trærne 
        i nyeste trunk og gren <emphasis>ikke</emphasis> bare vise 
        forandringene som du har gjort på grenen.
        En slik sammenligning viser alt for mange forandringer:
        Den vil ikke bare vise tilleggingene av dine forandringer på 
        grenen, men også <emphasis>fjerningen</emphasis> av forandringer 
        i trunk som aldri skjedde på din gren.</para>

      <!-- @ENGLISH {{{
      <para>To express only the changes that happened on your branch,
        you need to compare the initial state of your branch to its
        final state.  Using <command>svn log</command> on your branch,
        you can see that your branch was created in revision 341.  And
        the final state of your branch is simply a matter of using the
        <literal>HEAD</literal> revision.  That means you want to
        compare revisions 341 and <literal>HEAD</literal> of your
        branch directory, and apply those differences to a working
        copy of the trunk.</para>
      @ENGLISH }}} -->
      <para>For å bare vise forandringene som skjedde på din gren, må du 
        sammenligne tilstanden ved starten av grenen din i forhold til 
        dens endelige tilstand.
        Ved å bruke <command>svn log</command> på grenen kan du se at 
        den ble opprettet i revisjon 341.
        Og den endelige tilstanden får du ved å bruke 
        <literal>HEAD</literal>-revisjonen.
        Dette betyr at du vil sammenligne revisjonene 341 og 
        <literal>HEAD</literal> i forgreningskatalogen og legge disse 
        forskjellene inn i en arbeidskopi av trunk.</para>

      <tip>
        <!-- @ENGLISH {{{
        <para>A nice way of finding the revision in which a branch was
          created (the <quote>base</quote> of the branch) is to use the
          <option>-&#64738;-stop-on-copy</option> option to <command>svn
          log</command>.  The log subcommand will normally show every
          change ever made to the branch, including tracing back
          through the copy which created the branch.  So normally,
          you'll see history from the trunk as well.  The
          <option>-&#64738;-stop-on-copy</option> will halt log output as soon
          as <command>svn log</command> detects that its target was
          copied or renamed.</para>
        @ENGLISH }}} -->
        <para>En fin måte å finne revisjonen en gren ble opprettet i 
          (<quote>basen</quote> av forgreningen) er å bruke valget 
          <option>--stop-on-copy</option> til <command>svn 
          log</command>.
          Delkommandoen <command>svn log</command> vil normalt vise hver 
          eneste forandring gjort på grenen, inkludert å gå forbi 
          kopieringen som opprettet grenen.
          Så vanligvis vil du også se historien fra trunk.
          <option>--stop-on-copy</option>-valget vil stoppe 
          loggutlistingen med en gang <command>svn log</command> finner 
          ut at målet ble kopiert eller skiftet navn.</para>

        <!-- @ENGLISH {{{
        <para>So in our continuing example,</para>
        @ENGLISH }}} -->
        <para>Så hvis vi går videre i eksempelet,</para>

        <!-- @ENGLISH {{{
        <screen>
$ svn log -&#64738;-verbose -&#64738;-stop-on-copy \
          http://svn.example.com/repos/calc/branches/my-calc-branch
&hellip;
-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-
r341 | user | 2002-11-03 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)

$
</screen>
        @ENGLISH }}} -->
        <screen>
$ svn log --verbose --stop-on-copy \
          http://svn.example.com/repos/calc/branches/my-calc-branch
…
------------------------------------------------------------------------
r341 | bruker | 2002-11-03 15:27:56 -0600 (tor, 07 nov 2002) | 2 lines
Endrede filstier:
   A /calc/branches/my-calc-branch (fra /calc/trunk:340)

$
</screen>
        
        <!-- @ENGLISH {{{
        <para>As expected, the final revision printed by this command
          is the revision in which <filename>my-calc-branch</filename>
          was created by copying.</para>
        @ENGLISH }}} -->
        <para>Som forventet er den siste revisjonen skrevet ut av denne 
          kommandoen den revisjonen der 
          <filename>my-calc-branch</filename> ble opprettet ved 
          kopiering.</para>
      </tip>


      <!-- @ENGLISH {{{
      <para>Here's the final merging procedure, then:</para>
      @ENGLISH }}} -->
      <para>Her er den siste fletteprosedyren, og deretter:</para>

      <!-- @ENGLISH {{{
      <screen>
$ cd calc/trunk
$ svn update
At revision 405.

$ svn merge -r 341:405 http://svn.example.com/repos/calc/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile

$ svn status
M   integer.c
M   button.c
M   Makefile

# ...examine the diffs, compile, test, etc...

$ svn commit -m "Merged my-calc-branch changes r341:405 into the trunk."
Sending        integer.c
Sending        button.c
Sending        Makefile
Transmitting file data ...
Committed revision 406.
</screen>
      @ENGLISH }}} -->
      <screen>
$ cd calc/trunk
$ svn update
På revisjon 405.

$ svn merge -r 341:405 http://svn.example.com/repos/calc/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile

$ svn status
M   integer.c
M   button.c
M   Makefile

# … Undersøk forskjellene, kompiler, test osv …

$ svn commit -m "Flettet forandringer mellom r341:405 fra my-calc-branch til trunk."
Sender        integer.c
Sender        button.c
Sender        Makefile
Sender fildata ...
La inn revisjon 406.
</screen>

      <!-- @ENGLISH {{{
      <para>Again, notice that the commit log message very
        specifically mentions the range of changes that was merged
        into the trunk.  Always remember to do this, because it's
        critical information you'll need later on.</para>
      @ENGLISH }}} -->
      <para>Igjen, legg merke til at loggmeldingen veldig spesifikt 
        nevner området av forandringer som ble flettet inn på trunk.
        Husk alltid å gjøre dette, fordi det er vital informasjon som du 
        vil trenge senere.</para>

      <!-- @ENGLISH {{{
      <para>For example, suppose you decide to keep working on your
        branch for another week, in order to complete an enhancement
        to your original feature or bug fix.  The repository's
        <literal>HEAD</literal> revision is now 480, and you're ready
        to do another merge from your private branch to the trunk.
        But as discussed in <xref linkend="svn.branchmerge.copychanges.bestprac"/>, you
        don't want to merge the changes you've already merged before;
        you only want to merge everything <quote>new</quote> on your
        branch since the last time you merged.  The trick is to figure
        out what's new.</para>
      @ENGLISH }}} -->
      <para>For eksempel, tenk at du bestemmer deg for å fortsette 
        arbeidet på grenen en uke til, for å fullføre feilrettingen 
        eller en forbedring av den originale funksjonaliteten.
        Depotets <literal>HEAD</literal>-revisjon er nå 480, og du er 
        klar til å utføre en ny fletting fra den private grenen din til 
        trunk.
        Men som diskutert i <xref 
        linkend="svn.branchmerge.copychanges.bestprac"/> vil du ikke 
        flette forandringene du allerede har flettet før; du vil bare 
        flette alt <quote>nytt</quote> på grenen siden forrige gang du 
        flettet.
        Trikset er å finne ut <emphasis>hva</emphasis> som er 
        nytt.</para>

      <!-- @ENGLISH {{{
      <para>The first step is to run <command>svn log</command> on the
        trunk, and look for a log message about the last time you
        merged from the branch:</para>
      @ENGLISH }}} -->
      <para>Første skritt er å kjøre <command>svn log</command> på trunk 
        og se etter en loggmelding fra forrige gang du flettet fra 
        grenen:</para>

      <!-- @ENGLISH {{{
      <screen>
$ cd calc/trunk
$ svn log
&hellip;
-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-
r406 | user | 2004-02-08 11:17:26 -0600 (Sun, 08 Feb 2004) | 1 line

Merged my-calc-branch changes r341:405 into the trunk.
-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-
&hellip;
</screen>
      @ENGLISH }}} -->
      <screen>
$ cd calc/trunk
$ svn log
…
------------------------------------------------------------------------
r406 | bruker | 2004-02-08 11:17:26 -0600 (søn, 08 feb 2004) | 1 line

Flettet forandringer mellom r341:405 fra my-calc-branch til trunk.
------------------------------------------------------------------------
…
</screen>
      
      <!-- @ENGLISH {{{
      <para>Aha!  Since all branch-changes that happened between
        revisions 341 and 405 were previously merged to the trunk as
        revision 406, you now know that you want to merge only the
        branch changes after that&mdash;by comparing revisions 406 and
        <literal>HEAD</literal>.</para>
      @ENGLISH }}} -->
      <para>Aha!
        Siden alle grenforandringene som skjedde mellom revisjonene 341 
        og 405 ble flettet til trunk som revisjon 406, vet du nå at du 
        bare vil flette grenforandringene etter dette – ved å 
        sammenligne revisjonene 406 og <literal>HEAD</literal>.</para>

      <!-- @ENGLISH {{{
      <screen>
$ cd calc/trunk
$ svn update
At revision 480.

# We notice that HEAD is currently 480, so we use it to do the merge:

$ svn merge -r 406:480 http://svn.example.com/repos/calc/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile

$ svn commit -m "Merged my-calc-branch changes r406:480 into the trunk."
Sending        integer.c
Sending        button.c
Sending        Makefile
Transmitting file data ...
Committed revision 481.
</screen>
      @ENGLISH }}} -->
      <screen>
$ cd calc/trunk
$ svn update
På revisjon 480.

# Vi ser at HEAD er 480 for øyeblikket, så vi bruker den for å utføre 
# flettingen:

$ svn merge -r 406:480 http://svn.example.com/repos/calc/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile

$ svn commit -m "Flettet forandringer mellom r406:480 fra my-calc-branch til trunk."
Sender        integer.c
Sender        button.c
Sender        Makefile
Sender fildata ...
La inn revisjon 481.
</screen>

      <!-- @ENGLISH {{{
      <para>Now the trunk contains the complete second wave of changes
        made to the branch.  At this point, you can either delete your
        branch (we'll discuss this later on), or continue working on
        your branch and repeat this procedure for subsequent
        merges.</para>
      @ENGLISH }}} -->
      <para>Nå inneholder trunk alle forandringene som ble gjort i den 
        andre omgangen på grenen.
        På dette punktet kan du enten slette grenen (dette vil vi komme 
        tilbake til) eller fortsette arbeidet på grenen og repetere 
        denne prosedyren for etterfølgende flettinger.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.commonuses.undo">
      <!-- @ENGLISH {{{
      <title>Undoing Changes</title>
      @ENGLISH }}} -->
      <title>Omgjøre forandringer</title>

      <!-- @ENGLISH {{{
      <para>Another common use for <command>svn merge</command> is to
        roll back a change that has already been committed.  Suppose
        you're working away happily on a working copy of
        <filename>/calc/trunk</filename>, and you discover that the
        change made way back in revision 303, which changed
        <filename>integer.c</filename>, is completely wrong.  It never
        should have been committed.  You can use <command>svn
        merge</command> to <quote>undo</quote> the change in your
        working copy, and then commit the local modification to the
        repository.  All you need to do is to specify a
        <emphasis>reverse</emphasis> difference:</para>
      @ENGLISH }}} -->
      <para>En annen vanlig bruksmåte for <command>svn merge</command> 
        er å omgjøre en forandring som allerede er blitt lagt inn.
        Tenk deg at du jobber glad og fornøyd på en arbeidskopi av 
        <filename>/calc/trunk</filename>, og plutselig finner ut at 
        forandringen du gjorde langt tilbake i revisjon 303, som 
        forandret <filename>integer.c</filename>, er helt feil.
        Den skulle aldri vært lagt inn.
        Du kan bruke <command>svn merge</command> for å 
        <quote>angre</quote> forandringen i arbeidskopien din, og 
        deretter legge inn de lokale forandringene til depotet.
        Alt du trenger å gjøre er å spesifisere en 
        <emphasis>omvendt</emphasis> forskjell:</para>


      <!-- @ENGLISH {{{
      <screen>
$ svn merge -r 303:302 http://svn.example.com/repos/calc/trunk
U  integer.c

$ svn status
M  integer.c

$ svn diff
&hellip;
# verify that the change is removed
&hellip;

$ svn commit -m "Undoing change committed in r303."
Sending        integer.c
Transmitting file data .
Committed revision 350.
</screen>
      @ENGLISH }}} -->
      <screen>
$ svn merge -r 303:302 http://svn.example.com/repos/calc/trunk
U  integer.c

$ svn status
M  integer.c

$ svn diff
…
# Sjekk at forandringen er fjernet
…

$ svn commit -m "Fjernet forandringen som ble lagt inn i r303."
Sender        integer.c
Sender fildata .
La inn revisjon 350.
</screen>

      <!-- @ENGLISH {{{
      <para>One way to think about a repository revision is as a
        specific group of changes (some version control systems call
        these <firstterm>changesets</firstterm>).  By using the
        <option>-r</option> switch, you can ask <command>svn
        merge</command> to apply a changeset, or whole range of
        changesets, to your working copy.  In our case of undoing a
        change, we're asking <command>svn merge</command> to apply
        changeset #303 to our working copy
        <emphasis>backwards</emphasis>.</para>
      @ENGLISH }}} -->
      <para>En måte å tenke på en depotrevisjon er som en spesifikk 
        gruppe av forandringer (noen versjonskontrollsystemer kaller 
        disse <firstterm>forandringssett</firstterm> – 
        <foreignphrase>changesets</foreignphrase>).
        Ved å bruke <option>-r</option>-valget kan du be <command>svn 
        merge</command> om å legge inn et forandringssett, eller et helt 
        område av forandringssett, til arbeidskopien din.
        I vårt tilfelle med å omgjøre en forandring ber vi <command>svn 
        merge</command> om å legge inn forandringssett nummer 303 
        <emphasis>baklengs</emphasis> inn i arbeidskopien vår.</para>
    
      <!-- @ENGLISH {{{
      <para>Keep in mind that rolling back a change like this is just
        like any other <command>svn merge</command> operation, so you
        should use <command>svn status</command> and <command>svn
        diff</command> to confirm that your work is in the state you
        want it to be in, and then use <command>svn commit</command>
        to send the final version to the repository.  After
        committing, this particular changeset is no longer reflected
        in the <literal>HEAD</literal> revision.</para>
      @ENGLISH }}} -->
      <para>Husk at det å rulle tilbake en forandring som dette er 
        akkurat likt enhver annen <command>svn 
        merge</command>-operasjon, så du bør bruke <command>svn 
        status</command> og <command>svn diff</command> for å forsikre 
        deg om at arbeidet ditt er i den tilstanden du vil det skal være 
        i, og deretter bruke <command>svn commit</command> for å sende 
        den endelige versjonen til depotet.
        Etter innleggingen er dette spesielle forandringssettet ikke 
        lenger representert i <literal>HEAD</literal>-revisjonen.</para>

      <!-- @ENGLISH {{{
      <para>Again, you may be thinking: well, that really didn't undo
        the commit, did it?  The change still exists in revision 303.
        If somebody checks out a version of the
        <filename>calc</filename> project between revisions 303 and
        349, they'll still see the bad change, right?</para>
      @ENGLISH }}} -->
      <para>Og så tenker du kanskje:
        Nåh, dette omgjorde vel egentlig ikke innleggingen?
        Forandringen eksisterer fortsatt i revisjon 303.
        Hvis noen henter ut en versjon av 
        <filename>calc</filename>-prosjektet mellom revisjonene 303 og 
        349, vil de se den gale forandringen, ikke sant?</para>

      <!-- @ENGLISH {{{
      <para>Yes, that's true.  When we talk about
        <quote>removing</quote> a change, we're really talking about
        removing it from <literal>HEAD</literal>.  The original change
        still exists in the repository's history.  For most
        situations, this is good enough.  Most people are only
        interested in tracking the <literal>HEAD</literal> of a
        project anyway.  There are special cases, however, where you
        really might want to destroy all evidence of the commit.
        (Perhaps somebody accidentally committed a confidential
        document.)  This isn't so easy, it turns out, because
        Subversion was deliberately designed to never lose
        information.  Revisions are immutable trees which build upon
        one another.  Removing a revision from history would cause a
        domino effect, creating chaos in all subsequent revisions and
        possibly invalidating all working copies.
        <footnote>
          <para>The Subversion project has plans, however, to someday
            implement an <command>svnadmin obliterate</command>
            command that would accomplish the task of permanently
            deleting information.  In the meantime, see <xref
            linkend="svn.reposadmin.maint.tk.svndumpfilter"/> for a possible
            workaround.</para>
        </footnote>
      </para>
      @ENGLISH }}} -->
      <para>Ja, det stemmer.
        Når vi snakker om å <quote>fjerne</quote> en forandring, snakker 
        vi egentlig om å fjerne den fra <literal>HEAD</literal>.
        Den originale forandringen eksisterer fortsatt i depotets 
        historie.
        I de fleste situasjoner er dette greit nok.
        De fleste er bare interessert i å følge <literal>HEAD</literal> 
        av et prosjekt uansett.
        Det er imidlertid spesielle tilfeller der du virkelig vil 
        ødelegge alle spor etter innleggingen, kanskje la noen inn et 
        konfidensielt dokument ved en ulykke.
        Dette er ikke så lett, viser det seg, fordi Subversion ble 
        spesielt designet for å aldri miste informasjon.
        Revisjoner er uforanderlige trær som bygger på hverandre.
        Det å fjerne en revisjon fra historien vil forårsake en 
        dominoeffekt som vil føre til kaos i alle etterfølgende 
        revisjoner og muligens gjøre alle arbeidskopiene 
        ubrukelige.<footnote>
          <para>Subversionprosjektet har imidlertid planer om å legge 
            inn en <command>svnadmin obliterate</command>-kommando som 
            vil ta seg av oppgaven med å permanent slette informasjon.
            I mellomtiden, se <xref 
            linkend="svn.reposadmin.maint.tk.svndumpfilter"/> for en 
            mulig omvei om problemet.</para>
        </footnote></para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.commonuses.resurrect">
      <!-- @ENGLISH {{{
      <title>Resurrecting Deleted Items</title>
      @ENGLISH }}} -->
      <title>Hente tilbake slettede elementer</title>

      <!-- @ENGLISH {{{
      <para>The great thing about version control systems is that
        information is never lost.  Even when you delete a file or
        directory, it may be gone from the <literal>HEAD</literal>
        revision, but the object still exists in earlier revisions.
        One of the most common questions new users ask is, <quote>How
        do I get my old file or directory back?</quote>.</para>
      @ENGLISH }}} -->
      <para>Det som er fint med versjonskontrollsystemer er at 
        informasjon aldri går tapt.
        Selv om du sletter en fil eller katalog, kan den være borte fra 
        <literal>HEAD</literal>-revisjonen, men objektet eksisterer 
        fortsatt i tidligere revisjoner.
        Et av de vanligste spørsmålene nye brukere spør om, er: 
        <quote>Hvordan får jeg den gamle filen eller katalogen min 
        tilbake?</quote>.</para>

      <!-- @ENGLISH {{{
      <para>The first step is to define exactly <emphasis
        role="bold">which</emphasis> item you're trying to resurrect.
        Here's a useful metaphor: you can think of every object in the
        repository as existing in a sort of two-dimensional coordinate
        system.  The first coordinate is a particular revision tree,
        and the second coordinate is a path within that tree.  So
        every version of your file or directory can be defined by a
        specific coordinate pair.</para>
      @ENGLISH }}} -->
      <para>Første skritt er å definere nøyaktig 
        <emphasis>hvilket</emphasis> element du skal prøve å hente 
        tilbake.
        Her er en nyttig metafor:
        Du kan tenke på hvert objekt i depotet som om det eksisterer i 
        et slags todimensjonalt koordinatsystem.
        Det første koordinatet er et spesifikt revisjonstre, og det 
        andre koordinatet er en sti inne i dette treet.
        Så hver versjon av filen eller katalogen din kan bli definert 
        som et spesifikt koordinatpar.</para>

      <!-- @ENGLISH {{{
      <para>Subversion has no <filename>Attic</filename> directory
        like CVS does,
        <footnote>
          <para>Because CVS doesn't version trees, it creates an
            <filename>Attic</filename> area within each repository
            directory as a way of remembering deleted files.</para>
        </footnote>
        so you need to use <command>svn
        log</command> to discover the exact coordinate pair you wish
        to resurrect.  A good strategy is to run <command>svn log
        -&#64738;-verbose</command> in a directory which used to contain your
        deleted item.  The <option>-&#64738;-verbose</option> option shows a
        list of all changed items in each revision; all you need to do
        is find the revision in which you deleted the file or
        directory.  You can do this visually, or by using another tool
        to examine the log output (via <command>grep</command>, or
        perhaps via an incremental search in an editor).</para>
      @ENGLISH }}} -->
      <para>Subversion har ingen <filename>Attic</filename>-katalog som 
        CVS har,<footnote>
          <para>Fordi CVS ikke versjonerer trær, lager den et 
            <filename>Attic</filename>-område innenfor hver depotkatalog 
            som en måte å huske slettede filer på.</para>
        </footnote> så du må bruke <command>svn log</command> for å 
        finne det eksakte koordinatparet som du vil hente tilbake.
        En god strategi er å kjøre <command>svn log --verbose</command> 
        i en katalog som inneholdt det slettede elementet ditt.
        Valget <command>--verbose</command> viser en liste over alle 
        forandrede elementer i hver revisjon; alt du trenger å gjøre er 
        å finne revisjonen der du slettet filen eller katalogen.
        Du kan gjøre dette visuelt, eller ved å bruke et annet verktøy 
        for å undersøke utdataene fra loggen (ved hjelp av 
        <command>grep</command>, eller kanskje ved hjelp av et 
        inkrementelt søk i en tekstbehandler).</para>

      <!-- @ENGLISH {{{
      <screen>
$ cd parent-dir
$ svn log -&#64738;-verbose
&hellip;
-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-
r808 | joe | 2003-12-26 14:29:40 -0600 (Fri, 26 Dec 2003) | 3 lines
Changed paths:
   D /calc/trunk/real.c
   M /calc/trunk/integer.c

Added fast fourier transform functions to integer.c.
Removed real.c because code now in double.c.
&hellip;
</screen>
      @ENGLISH }}} -->
      <screen>
…
------------------------------------------------------------------------
r808 | joe | 2003-12-26 14:29:40 -0600 (fre, 26 des 2003) | 3 lines
Endrede filstier:
   D /calc/trunk/real.c
   M /calc/trunk/integer.c

La inn Fast Fourier transform-funksjoner i integer.c .
Slettet real.c fordi koden nå ligger i double.c .
…
</screen>

      <!-- @ENGLISH {{{
      <para>In the example, we're assuming that you're looking for a
        deleted file <filename>real.c</filename>.  By looking through
        the logs of a parent directory, you've spotted that this file
        was deleted in revision 808.  Therefore, the last version of
        the file to exist was in the revision right before that.
        Conclusion: you want to resurrect the path
        <filename>/calc/trunk/real.c</filename> from revision
        807.</para>
      @ENGLISH }}} -->
      <para>I eksempelet går vi ut i fra at du ser etter en slettet fil 
        kalt <filename>real.c</filename>.
        Ved å se gjennom loggene for en foreldrekatalog, har du funnet 
        ut at denne filen ble slettet i revisjon 808.
        Derfor er den siste versjonen av filen der den fortsatt 
        eksisterte i revisjonen like før dette.
        Konklusjon:
        Du vil hente tilbake stien 
        <filename>/calc/trunk/real.c</filename> fra revisjon 807.</para>

      <!-- @ENGLISH {{{
      <para>That was the hard part&mdash;the research.  Now that you
        know what you want to restore, you have two different
        choices.</para>
      @ENGLISH }}} -->
      <para>Dette var den vanskelige delen – <!-- ¤ -->etterforskningen.
        Nå som du vet hva du vil hente tilbake, har du to forskjellige 
        valg.</para>
      
      <!-- @ENGLISH {{{
      <para>One option is to use <command>svn merge</command> to apply
        revision 808 <quote>in reverse</quote>.  (We've already
        discussed how to undo changes, see <xref
        linkend="svn.branchmerge.commonuses.undo"/>.)  This would have the effect of
        re-adding <filename>real.c</filename> as a local modification.
        The file would be scheduled for addition, and after a commit,
        the file would again exist in <literal>HEAD</literal>.</para>
      @ENGLISH }}} -->
      <para>En måte er å bruke <command>svn merge</command> for å legge 
        inn revisjon 808 <quote>i revers</quote>.
        (Vi har allerede gått gjennom hvordan vi omgjør forandringer, se 
        <xref linkend="svn.branchmerge.commonuses.undo"/>.)
        Dette vil ha samme effekten som å legge til 
        <filename>real.c</filename> en gang til som en lokal 
        modifisering.
        Filen vil bli klargjort for tillegging, og etter en innlegging 
        med <command>svn commit</command> vil filen eksistere i 
        <literal>HEAD</literal> igjen.</para>

      <!-- @ENGLISH {{{
      <para>In this particular example, however, this is probably not
        the best strategy.  Reverse-applying revision 808 would not
        only schedule <filename>real.c</filename> for addition, but
        the log message indicates that it would also undo certain
        changes to <filename>integer.c</filename>, which you don't
        want.  Certainly, you could reverse-merge revision 808 and
        then <command>svn revert</command> the local modifications to
        <filename>integer.c</filename>, but this technique doesn't
        scale well.  What if there were 90 files changed in revision
        808?</para>
      @ENGLISH }}} -->
      <para>Men i dette spesielle eksempelet er det kanskje ikke den 
        beste strategien.
        Å legge inn revisjon 808 i revers vil ikke bare klargjøre 
        <filename>real.c</filename> for tillegging, men loggmeldingen 
        indikerer at det vil også bli omgjort forandringer i 
        <filename>integer.c</filename>, noe som du ikke ønsker.
        Du kan selvfølgelig bakoverflette revisjon 808 og deretter kjøre 
        <command>svn revert</command> på de lokale forandringene i 
        <filename>integer.c</filename>, men denne teknikken skalerer 
        ikke alltid like bra.
        Hva hvis det var 90 filer som forandret seg i revisjon 
        808?</para>

      <!-- @ENGLISH {{{
      <para>A second, more targeted strategy is not to use
        <command>svn merge</command> at all, but rather the
        <command>svn copy</command> command.  Simply copy the exact
        revision and path <quote>coordinate pair</quote> from the
        repository to your working copy:</para>
      @ENGLISH }}} -->
      <para>En annen og mer målrettet strategi er å ikke bruke 
        <command>svn merge</command> i det hele tatt, men derimot 
        <command>svn copy</command>.
        Kopier ganske enkelt den eksakte revisjonens og stiens 
        <quote>koordinatpar</quote> fra depotet til arbeidskopien 
        din:</para>

      <!-- @ENGLISH {{{
      <screen>
$ svn copy -&#64738;-revision 807 \
           http://svn.example.com/repos/calc/trunk/real.c ./real.c

$ svn status
A  +   real.c

$ svn commit -m "Resurrected real.c from revision 807, /calc/trunk/real.c."
Adding         real.c
Transmitting file data .
Committed revision 1390.
</screen>
      @ENGLISH }}} -->
      <screen>
$ svn copy --revision 807 \
           http://svn.example.com/repos/calc/trunk/real.c ./real.c

$ svn status
A  +   real.c

$ svn commit -m "Hentet tilbake real.c from revisjon 807, /calc/trunk/real.c ."
Legger til         real.c
Sender fildata .
La inn revisjon 1390.
</screen>

      <!-- @ENGLISH {{{
      <para>The plus sign in the status output indicates that the item
        isn't merely scheduled for addition, but scheduled for
        addition <quote>with history</quote>.  Subversion remembers
        where it was copied from.  In the future, running <command>svn
        log</command> on this file will traverse back through the
        file's resurrection and through all the history it had prior
        to revision 807.  In other words, this new
        <filename>real.c</filename> isn't really new; it's a direct
        descendant of the original, deleted file.</para>
      @ENGLISH }}} -->
      <para>Plusstegnet som vises i statusoversikten indikerer at 
        elementet ikke bare er klargjort for tillegging, men er 
        klargjort for tillegging <quote>med historie</quote>.
        Subversion husker hvor det ble kopiert fra.
        I framtiden vil kjøring av <command>svn log</command> på denne 
        filen gå tilbake forbi gjenoppstandelsen av filen og gjennom 
        hele historien den hadde før revisjon 807.
        Med andre ord, denne nye <filename>real.c</filename> er ikke 
        egentlig ny; den er en direkte etterkommer av den originale, 
        slettede filen.</para>

      <!-- @ENGLISH {{{
      <para>Although our example shows us resurrecting a file, note
        that these same techniques work just as well for resurrecting
        deleted directories.</para>
      @ENGLISH }}} -->
      <para>Selv om eksempelet vårt viser at vi henter tilbake en fil, 
        legg merke til at disse samme teknikkene virker like godt når 
        det gjelder å hente tilbake slettede kataloger.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.commonuses.patterns">
      <!-- @ENGLISH {{{
      <title>Common Branching Patterns</title>
      @ENGLISH }}} -->
      <title>Vanlige forgreningsmønstre</title>

      <!-- @ENGLISH {{{
      <para>Version control is most often used for software
        development, so here's a quick peek at two of the most common
        branching/merging patterns used by teams of programmers.  If
        you're not using Subversion for software development, feel
        free to skip this section.  If you're a software developer
        using version control for the first time, pay close attention,
        as these patterns are often considered best practices by
        experienced folk.  These processes aren't specific to
        Subversion; they're applicable to any version control system.
        Still, it may help to see them described in Subversion
        terms.</para>
      @ENGLISH }}} -->
      <para>Versjonskontroll blir vanligvis brukt til programutvikling, 
        så her er en rask kikk på to av de vanligste 
        forgrenings-/flettemønstere som blir brukt av 
        programmeringsteam.
        Hvis du ikke bruker Subversion til programutvikling, kan du 
        hoppe over denne seksjonen.
        Hvis du er en programutvikler som bruker versjonskontroll for 
        første gang, følg nøye med, da disse fremgangsmåtene blant 
        erfarne brukere ofte er ansett som de beste metodene.
        Disse prosessene er ikke spesifikke for Subversion;
        de kan brukes med ethvert versjonskontrollsystem.
        Men det kan hjelpe å se dem beskrevet i 
        Subversionterminologi.</para>
      
      <sect3 id="svn.branchmerge.commonuses.patterns.release">
        <!-- @ENGLISH {{{
        <title>Release Branches</title>
        @ENGLISH }}} -->
        <title>Utgivelsesgrener</title>
      
        <!-- @ENGLISH {{{
        <para>Most software has a typical lifecycle: code, test,
          release, repeat.  There are two problems with this process.
          First, developers need to keep writing new features while
          quality-assurance teams take time to test supposedly-stable
          versions of the software.  New work cannot halt while the
          software is tested.  Second, the team almost always needs to
          support older, released versions of software; if a bug is
          discovered in the latest code, it most likely exists in
          released versions as well, and customers will want to get
          that bugfix without having to wait for a major new
          release.</para>
        @ENGLISH }}} -->
        <para>Programvare har vanligvis denne livssyklusen:
          Kode, teste, offentliggjøre, repetere.
          Det er to problemer med denne prosessen.
          For det første trenger utviklere å skrive ny funksjonalitet 
          mens kvalitetssikringsteam tester versjoner som er ment å 
          skulle være stabil.
          Nytt arbeide kan ikke stoppe opp mens programvaren blir testet 
          ut.
          For det andre, teamet må nesten alltid støtte eldre, utgitte 
          versjoner av programvaren; hvis en feil blir oppdaget i den 
          seneste koden, eksisterer den sannsynligvis også i utgitte 
          versjoner, og kundene vil ønske å få denne feilen rettet uten 
          å måtte vente på en ny stor utgivelse.</para>

        <!-- @ENGLISH {{{
        <para>Here's where version control can help.  The typical
          procedure looks like this:</para>
        @ENGLISH }}} -->
        <para>Og det er her versjonskontroll kan hjelpe.
          Den vanlige prosedyren ser ut som dette:</para>

      <itemizedlist>

        <listitem>
          <!-- @ENGLISH {{{
          <para><emphasis>Developers commit all new work to the
                trunk.</emphasis>

              Day-to-day changes are committed to
              <filename>/trunk</filename>: new features, bugfixes, and
              so on.</para>
          @ENGLISH }}} -->
          <para><emphasis>Utviklerne legger inn alt nytt arbeid til 
            <filename>trunk</filename>.</emphasis>

            Daglige forandringer legges inn på 
            <filename>/trunk</filename>:
            Ny funksjonalitet, retting av feil og så videre.</para>
        </listitem>

        <listitem>
          <!-- @ENGLISH {{{
          <para><emphasis>The trunk is copied to a
                <quote>release</quote> branch.</emphasis>

              When the team thinks the software is ready for release
              (say, a 1.0 release), then <filename>/trunk</filename>
              might be copied to
              <filename>/branches/1.0</filename>.</para>
          @ENGLISH }}} -->
          <para><emphasis><filename>trunk</filename> blir kopiert til en 
            <quote>utgivelses</quote>-gren.</emphasis>

            Når teamet synes programvaren er klar for utgivelse (for 
            eksempel en 1.0-versjon), kan <filename>/trunk</filename> 
            bli kopiert til <filename>/branches/1.0</filename>.</para>
        </listitem>

        <listitem>
          <!-- @ENGLISH {{{
          <para><emphasis>Teams continue to work in parallel.</emphasis>

              One team begins rigorous testing of the release branch,
              while another team continues new work (say, for version
              2.0) on <filename>/trunk</filename>.  If bugs are
              discovered in either location, fixes are ported back and
              forth as necessary.  At some point, however, even that
              process stops.  The branch is <quote>frozen</quote> for
              final testing right before a release.</para>
          @ENGLISH }}} -->
          <para><emphasis>Teamene fortsetter å arbeide 
            parallelt.</emphasis>

            Et team begynner inngående testing av utgivelsesgrenen, mens 
            et annet team fortsetter på nytt arbeid (for eksempel på det 
            som skal bli versjon 2.0) i <filename>/trunk</filename>.
            Hvis det blir funnet feil på et av stedene, blir 
            nødvendige reparasjoner flettet fram og tilbake.
            Men på et punkt stopper også denne prosessen.
            Grenen er <quote>frosset</quote> for avsluttende testing 
            rett før en utgivelse.</para>
        </listitem>
          
        <listitem>
          <!-- @ENGLISH {{{
          <para><emphasis>The branch is tagged and released.</emphasis>

              When testing is complete,
              <filename>/branches/1.0</filename> is copied to
              <filename>/tags/1.0.0</filename> as a reference
              snapshot.  The tag is packaged and released to
              customers.</para>
          @ENGLISH }}} -->
          <para><emphasis>Grenen blir merket og utgitt.</emphasis>

            Når testingen er ferdig, blir 
            <filename>/branches/1.0</filename> kopiert til 
            <filename>/tags/1.0.0</filename> som et referanseøyeblikksbilde.
            De merkede filene pakkes og sendes ut til kundene.</para>
        </listitem>

        <listitem>
          <!-- @ENGLISH {{{
          <para><emphasis>The branch is maintained over time.</emphasis>

              While work continues on <filename>/trunk</filename> for
              version 2.0, bugfixes continue to be ported from
              <filename>/trunk</filename> to
              <filename>/branches/1.0</filename>.  When enough
              bugfixes have accumulated, management may decide to do a
              1.0.1 release: <filename>/branches/1.0</filename> is
              copied to <filename>/tags/1.0.1</filename>, and the tag
              is packaged and released.</para>
          @ENGLISH }}} -->
          <para><emphasis>Grenen blir vedlikeholdt over tid.</emphasis>

            Mens arbeidet fortsetter på <filename>/trunk</filename> for 
            versjon 2.0, blir fortsatt feil som blir funnet på 
            <filename>/trunk</filename> flettet derfra til 
            <filename>/branches/1.0</filename>.
            Når et tilstrekkelig antall feil er blitt rettet, kan 
            vedlikeholderne bestemme seg for å lage en 1.0.1-utgivelse:
            <filename>/branches/1.0</filename> blir kopiert til 
            <filename>/tags/1.0.1</filename>, og de merkede filene blir pakket og 
            utgitt.</para>
        </listitem>

        </itemizedlist>

        <!-- @ENGLISH {{{
        <para>This entire process repeats as the software matures:
          when the 2.0 work is complete, a new 2.0 release branch is
          created, tested, tagged, and eventually released.  After
          some years, the repository ends up with a number of release
          branches in <quote>maintenance</quote> mode, and a number
          of tags representing final shipped versions.</para>
        @ENGLISH }}} -->
        <para>Hele denne prosessen repeteres mens programvaren modnes:
          Når arbeidet for 2.0 er komplett, blir en ny utgivelsesgren 
          for 2.0 opprettet, testet, merket og eventuelt utgitt.
          Etter noen år ender depotet opp med et antall grener i 
          <quote>vedlikeholdsmodus</quote>, og et antall merker som 
          representerer ferdige, utgitte versjoner.</para>

      </sect3>

      <sect3 id="svn.branchmerge.commonuses.patterns.feature">
        <!-- @ENGLISH {{{
        <title>Feature Branches</title>
        @ENGLISH }}} -->
        <title>Funksjonalitetsgrener</title>
      
        <!-- @ENGLISH {{{
        <para>A <firstterm>feature branch</firstterm> is the sort of
          branch that's been the dominant example in this chapter, the
          one you've been working on while Sally continues to work on
          <filename>/trunk</filename>.  It's a temporary branch
          created to work on a complex change without interfering with
          the stability of <filename>/trunk</filename>.  Unlike
          release branches (which may need to be supported forever),
          feature branches are born, used for a while, merged back to
          the trunk, then ultimately deleted.  They have a finite span
          of usefulness.</para>
        @ENGLISH }}} -->
        <para>En <firstterm>funksjonalitetsgren</firstterm> er den typen 
          gren som har vært det dominerende eksempelet i dette 
          kapittelet, den typen du har arbeidet på mens Sally fortsetter 
          å arbeide på <filename>/trunk</filename>.
          Det er en midlertidig gren som er opprettet for å arbeide på 
          en kompleks forandring uten å la det gå ut over stabiliteten 
          til <filename>/trunk</filename>.
          I motsetning til utgivelsesgrener (som kanskje må bli støttet 
          for alltid) blir funksjonalitetsgrener født, brukt en stund, 
          flettet tilbake til <filename>trunk</filename>, og deretter 
          til sist slettet.
          De har en begrenset nyttighetsperiode.</para>

        <!-- @ENGLISH {{{
        <para>Again, project policies vary widely concerning exactly
          when it's appropriate to create a feature branch.  Some
          projects never use feature branches at all: commits to
          <filename>/trunk</filename> are a free-for-all.  The
          advantage to this system is that it's simple&mdash;nobody
          needs to learn about branching or merging.  The disadvantage
          is that the trunk code is often unstable or unusable.  Other
          projects use branches to an extreme: no change is
          <emphasis>ever</emphasis> committed to the trunk directly.
          Even the most trivial changes are created on a short-lived
          branch, carefully reviewed and merged to the trunk.  Then
          the branch is deleted.  This system guarantees an
          exceptionally stable and usable trunk at all times, but at
          the cost of tremendous process overhead.</para>
        @ENGLISH }}} -->
        <para>Igjen, prosjekt-policy varierer veldig når det gjelder 
          nøyaktig når det passer å opprette en funksjonalitetsgren.
          Noen prosjekter bruker ikke funksjonalitetsgrener i det hele 
          tatt; innlegginger til <filename>/trunk</filename> er <!-- ¤ 
          -->tilgjengelig for alle.
          Fordelen med dette systemet er at det er enkelt – ingen 
          trenger å lære om forgrening eller fletting.
          Ulempen er at koden i <filename>trunk</filename> ofte er 
          ustabil eller ubrukelig.
          Andre prosjekter bruker forgreninger til det ekstreme; ingen 
          forandringer blir <emphasis>noen gang</emphasis> lagt direkte 
          inn på trunk.
          Til og med de enkleste forandringer blir laget på en gren med 
          kort levetid, nøye kontrollert og deretter flettet til trunk.  
          Så blir grenen slettet.
          Dette systemet garanterer en eksepsjonelt stabil og brukbar 
          trunk til enhver tid, men med en pris i form av mer arbeid i 
          prosessen.</para>

        <!-- @ENGLISH {{{
        <para>Most projects take a middle-of-the-road approach.  They
          commonly insist that <filename>/trunk</filename> compile and
          pass regression tests at all times.  A feature branch is
          only required when a change requires a large number of
          destabilizing commits.  A good rule of thumb is to ask this
          question: if the developer worked for days in isolation and
          then committed the large change all at once (so that
          <filename>/trunk</filename> were never destabilized), would
          it be too large a change to review?  If the answer to that
          question is <quote>yes</quote>, then the change should be
          developed on a feature branch.  As the developer commits
          incremental changes to the branch, they can be easily
          reviewed by peers.</para>
        @ENGLISH }}} -->
        <para>Noen prosjekter velger en rute midt i mellom.
          De insisterer på at <filename>/trunk</filename> skal kunne 
          kompilere og passere <!-- ¤ -->systemsjekker til enhver tid.
          En funksjonalitetsgren er bare nødvendig når en forandring 
          krever et stort antall innlegginger som kan gå ut over 
          stabiliteten.
          En god tommelfingerregel er å stille dette spørsmålet:
          Hvis utvikleren jobbet i flere dager i isolasjon og deretter 
          la inn hele den store forandringen på en gang (så 
          <filename>/trunk</filename> aldri ble ustabil), ville den 
          blitt for stor for gjennomlesing?
          Hvis svaret til det er <quote>ja</quote>, bør forandringen bli 
          utviklet på en funksjonalitetsgren.
          Etter hvert som utvikleren legger inn økende forandringer til 
          grenen, kan de bli sett over av kolleger.</para>

        <!-- @ENGLISH {{{
        <para>Finally, there's the issue of how to best keep a feature
          branch in <quote>sync</quote> with the trunk as work
          progresses.  As we mentioned earlier, there's a great risk
          to working on a branch for weeks or months; trunk changes
          may continue to pour in, to the point where the two lines of
          development differ so greatly that it may become a nightmare
          trying to merge the branch back to the trunk.</para>
        @ENGLISH }}} -->
        <para>Til sist har vi spørsmålet om hvordan man best kan holde 
          en fremtidig gren i <quote>synk</quote> med trunk etterhvert 
          som arbeidet går fram.
          Som vi nevnte tidligere, er det en stor risiko å arbeide på en 
          gren i flere uker eller måneder; forandringer på trunk kommer 
          strømmende inn, til punktet der de to utviklingslinjene er 
          såpass forskjellige at det kan bli et mareritt å flette grenen 
          tilbake til trunk.</para>

        <!-- @ENGLISH {{{
        <para>This situation is best avoided by regularly merging
          trunk changes to the branch.  Make up a policy: once a week,
          merge the last week's worth of trunk changes to the branch.
          Take care when doing this; the merging needs to be
          hand-tracked to avoid the problem of repeated merges (as
          described in <xref linkend="svn.branchmerge.copychanges.bestprac.track"/>).  You'll
          need to write careful log messages detailing exactly which
          revision ranges have been merged already (as
          demonstrated in <xref linkend="svn.branchmerge.commonuses.wholebr"/>).  It
          may sound intimidating, but it's actually pretty easy to
          do.</para>
        @ENGLISH }}} -->
        <para>Denne situasjonen unngås best ved å jevnlig flette 
          trunk-forandringer inn på grenen.
          Lag en regel:
          En gang i uken fletter du forrige ukes forandringer til 
          grenen.
          Vær nøye når du gjør dette; flettingen må <!-- ¤ -->sjekkes 
          for å unngå problemet med gjentatte flettinger (som beskrevet 
          i <xref 
          linkend="svn.branchmerge.copychanges.bestprac.track"/>).
          Du må skrive nøyaktige loggmeldinger med detaljer om hvilket 
          revisjonsområde som allerede er blitt flettet (som demonstrert 
          i <xref linkend="svn.branchmerge.commonuses.wholebr"/>).
          Det kan høres skremmende ut, men er faktisk ganske enkelt å 
          gjøre.</para>

        <!-- @ENGLISH {{{
        <para>At some point, you'll be ready to merge the
          <quote>synchronized</quote> feature branch back to the
          trunk.  To do this, begin by doing a final merge of the
          latest trunk changes to the branch.  When that's done, the
          latest versions of branch and trunk will be absolutely
          identical except for your branch changes.  So in this
          special case, you would merge by comparing the branch with
          the trunk:</para>
        @ENGLISH }}} -->
        <para>Etterhvert er du klar til å flette den 
          <quote>synkroniserte</quote> funksjonalitetsgrenen tilbake til 
          trunk.
          For å gjøre dette, start med å gjøre en avsluttende fletting 
          av de siste trunk-forandringene til grenen.
          Når det er gjort, vil de siste versjonene av grenen og trunk 
          være absolutt like, bortsett fra forandringene på grenen din.
          Så i dette spesielle tilfellet, vil du flette ved å 
          sammenligne grenen med <filename>trunk</filename>:</para>

<!-- @ENGLISH {{{
        <screen>
$ cd trunk-working-copy

$ svn update
At revision 1910.

$ svn merge http://svn.example.com/repos/calc/trunk@1910 \
            http://svn.example.com/repos/calc/branches/mybranch@1910
U  real.c
U  integer.c
A  newdirectory
A  newdirectory/newfile
&hellip;
</screen>
@ENGLISH }}} -->
        <screen>
$ cd trunk-i-arbeidskopien

$ svn update
På revisjon 1910.

$ svn merge http://svn.example.com/repos/calc/trunk@1910 \
            http://svn.example.com/repos/calc/branches/mybranch@1910
U  real.c
U  integer.c
A  nykatalog
A  nykatalog/nyfil
…
</screen>

        <!-- @ENGLISH {{{
        <para>By comparing the <literal>HEAD</literal> revision of the
          trunk with the <literal>HEAD</literal> revision of the
          branch, you're defining a delta that describes only the
          changes you made to the branch; both lines of development
          already have all of the trunk changes.</para>
        @ENGLISH }}} -->
        <para>Ved å sammenligne <literal>HEAD</literal>-revisjonen for 
          trunk med <literal>HEAD</literal>-revisjonen på grenen, kan du 
          definere ett delta som beskriver kun de forandringene som du 
          gjorde til grenen; begge utviklingsgrener inneholder allerede 
          forandringene fra trunk.</para>

        <!-- @ENGLISH {{{
        <para>Another way of thinking about this pattern is that your
          weekly sync of trunk to branch is analogous to running
          <command>svn update</command> in a working copy, while the
          final merge step is analogous to running <command>svn
          commit</command> from a working copy.  After all, what else
          <emphasis>is</emphasis> a working copy but a very shallow
          private branch?  It's a branch that's only capable of
          storing one change at a time.</para>
        @ENGLISH }}} -->
        <para>En annen måte å tenke på dette <!-- ¤ -->mønsteret er at 
          den ukentlige synkroniseringen er det samme som å kjøre 
          <command>svn update</command> i en arbeidskopi, mens det siste 
          trinnet med fletting er det samme som å kjøre <command>svn 
          commit</command> fra en arbeidskopi. Når alt kommer til alt, 
          <emphasis>er</emphasis> jo en arbeidskopi en grunn, privat 
          gren.
          Det er en gren som bare er i stand til å lagre én forandring 
          om gangen.</para>

      </sect3>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.switchwc">
    <!-- @ENGLISH {{{
    <title>Switching a Working Copy</title>
    @ENGLISH }}} -->
    <title>Bytte om en arbeidskopi</title>

    <!-- @ENGLISH {{{
    <para>The <command>svn switch</command> command transforms an
      existing working copy into a different branch.  While this
      command isn't strictly necessary for working with branches, it
      provides a nice shortcut to users.  In our earlier example,
      after creating your private branch, you checked out a fresh
      working copy of the new repository directory.  Instead, you can
      simply ask Subversion to change your working copy of
      <filename>/calc/trunk</filename> to mirror the new branch
      location:</para>
    @ENGLISH }}} -->
    <para>Kommandoen <command>svn switch</command> flytter en 
      eksisterende arbeidskopi til en annen gren.
      Selv om denne kommandoen strengt tatt ikke er nødvendig for å 
      arbeide med forgreninger, gir den en fin snarvei for brukere,
      I det tidligere eksempelet vårt, etter at du opprettet en privat 
      gren, hentet du ut en fersk arbeidskopi av den nye katalogen i 
      depotet.
      Istedenfor kan du rett og slett be Subversion om å forandre 
      arbeidskopien din av <filename>/calc/trunk</filename> til å 
      avspeile plasseringen til den nye grenen:</para>

    <!-- @ENGLISH {{{
    <screen>
$ cd calc

$ svn info | grep URL
URL: http://svn.example.com/repos/calc/trunk

$ svn switch http://svn.example.com/repos/calc/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile
Updated to revision 341.

$ svn info | grep URL
URL: http://svn.example.com/repos/calc/branches/my-calc-branch
</screen>
    @ENGLISH }}} -->
    <screen>
$ cd calc

$ svn info | grep Nettadresse
Nettadresse: http://svn.example.com/repos/calc/trunk

$ svn switch http://svn.example.com/repos/calc/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile
Oppdatert til revisjon 341.

$ svn info | grep Nettadresse
Nettadresse: http://svn.example.com/repos/calc/branches/my-calc-branch
</screen>

    <!-- @ENGLISH {{{
    <para>After <quote>switching</quote> to the branch, your working
      copy is no different than what you would get from doing a fresh
      checkout of the directory.  And it's usually more efficient to
      use this command, because often branches only differ by a small
      degree.  The server sends only the minimal set of changes
      necessary to make your working copy reflect the branch
      directory.</para>
    @ENGLISH }}} -->
    <para>Etter å ha <quote>byttet om</quote> til grenen, er ikke 
      arbeidskopien mer forskjellig enn om du hadde gjort en fersk 
      uthenting av katalogen.
      Og det er vanligvis mer praktisk å bruke denne kommandoen, fordi 
      forskjellene mellom grener ofte er ganske små.
      &The_server; sender bare et minimalt sett med forandringer 
      nødvendig for å avspeile grenkatalogen.</para>

    <!-- @ENGLISH {{{
    <para>The <command>svn switch</command> command also takes a
      <option>-&#64738;-revision</option> (<option>-r</option>) option, so you
      need not always move your working copy to the <quote>tip</quote>
      of the branch.</para>
    @ENGLISH }}} -->
    <para><command>svn switch</command>-kommandoen tar også et 
      <option>--revision</option> (<option>-r</option>)-valg, så du 
      trenger ikke alltid å flytte arbeidskopien din til 
      <quote>tuppen</quote> av grenen.</para>

    <!-- @ENGLISH {{{
    <para>Of course, most projects are more complicated than our
      <filename>calc</filename> example, containing multiple
      subdirectories.  Subversion users often follow a specific
      algorithm when using branches:</para>
    @ENGLISH }}} -->
    <para>Selvfølgelig, de fleste prosjekter er mer kompliserte enn 
      <filename>calc</filename>-eksempelet vårt, og inneholder flere 
      underkataloger.
      Subversionbrukere følger ofte en spesiell algoritme ved bruk av 
      grener:</para>

      <orderedlist>
        <listitem>
          <!-- @ENGLISH {{{
          <para>Copy the project's entire <quote>trunk</quote> to a
            new branch directory.</para>
          @ENGLISH }}} -->
          <para>Kopier hele <quote>trunk</quote> fra prosjektet til en 
            ny grenkatalog.</para>
        </listitem>
        <listitem>
          <!-- @ENGLISH {{{
          <para>Switch only <emphasis>part</emphasis> of the trunk
            working copy to mirror the branch.</para>
          @ENGLISH }}} -->
          <para>Bytt bare om <emphasis>en del</emphasis> av 
            trunk-arbeidskopien for å avspeile forgreningen.</para>
        </listitem>
      </orderedlist>
    
    <!-- @ENGLISH {{{
    <para>In other words, if a user knows that the branch-work only
      needs to happen on a specific subdirectory, they use
      <command>svn switch</command> to move only that subdirectory to
      the branch.  (Or sometimes users will switch just a single
      working file to the branch!)  That way, they can continue to
      receive normal <quote>trunk</quote> updates to most of their
      working copy, but the switched portions will remain immune
      (unless someone commits a change to their branch).  This feature
      adds a whole new dimension to the concept of a <quote>mixed
      working copy</quote>&mdash;not only can working copies contain a
      mixture of working revisions, but a mixture of repository
      locations as well.</para>
    @ENGLISH }}} -->
    <para>Med andre ord, hvis en bruker vet at grenarbeidet kun trenger 
      å skje i en spesiell underkatalog, bruker de <command>svn 
      switch</command> for å flytte bare denne underkatalogen til 
      grenen.
      (Og noen ganger vil brukere bare bytte om en enkelt arbeidsfil til 
      grenen!)
      På denne måten kan de fortsette å motta normale oppdateringer fra 
      <quote>trunk</quote> til mesteparten av arbeidskopien deres, men 
      de ombyttede delene vil forbli immune (unntatt hvis noen legger 
      inn en forandring til denne grenen).
      Denne funksjonaliteten legger til en hel ny dimensjon til 
      konseptet med en <quote>blandet arbeidskopi</quote> – ikke bare 
      kan arbeidskopier inneholde en blanding av av arbeidsrevisjoner, 
      men også en blanding av depotbeliggenheter.</para>
    
    <!-- @ENGLISH {{{
    <para>If your working copy contains a number of switched subtrees
      from different repository locations, it continues to function as
      normal.  When you update, you'll receive patches to each subtree
      as appropriate.  When you commit, your local changes will still
      be applied as a single, atomic change to the repository.</para>
    @ENGLISH }}} -->
    <para>Hvis arbeidskopien din inneholder et antall ombyttede 
      katalogtrær fra forskjellige depotplasseringer, fortsetter den å 
      virke som normalt.
      Når du oppdaterer, vil du motta patcher til hvert undertre der det 
      er nødvendig.
      Når du legger inn forandringer, vil dine lokale forandringer 
      fortsatt bli lagt inn som en enkel, atomisk forandring til 
      depotet.</para>

    <!-- @ENGLISH {{{
    <para>Note that while it's okay for your working copy to reflect a
      mixture of repository locations, these locations must all be
      within the <emphasis>same</emphasis> repository.  Subversion
      repositories aren't yet able to communicate with one another;
      that's a feature planned beyond Subversion
      1.0.<footnote><para>You <emphasis>can</emphasis>, however, use
      <command>svn switch</command> with the
      <option>-&#64738;-relocate</option> switch if the URL of your server
      changes and you don't want to abandon an existing working copy.
      See the <command>svn switch</command> section in <xref
      linkend="svn.ref"/> for more information and an example.</para>
      </footnote></para>
    @ENGLISH }}} -->
    <para>Legg merke til at mens det er greit for arbeidskopien din å 
      avspeile en blanding av depotplasseringer, må alle disse 
      plasseringene være innenfor det <emphasis>samme</emphasis> 
      depotet.
      Subversiondepoter er foreløpig ikke i stand til å kommunisere med 
      hverandre; det er en funksjonalitet som er planlagt etter 
      Subversion 1.0.<footnote>
        <para>Du <emphasis>kan</emphasis> imidlertid bruke <command>svn 
          switch</command> med <option>--relocate</option>-valget hvis 
          URL-en til &the_server; forandrer seg og du ikke vil forkaste 
          en eksisterende arbeidskopi.
          Se <command>svn switch</command>-seksjonen i <xref 
          linkend="svn.ref"/> for mer informasjon og et eksempel.</para>
      </footnote></para>
    
    <sidebar>
      <!-- @ENGLISH {{{
      <title>Switches and Updates</title>
      @ENGLISH }}} -->
      <title>Ombyttinger og oppdateringer</title>
      
      <!-- @ENGLISH {{{
      <para>Have you noticed that the output of <command>svn
        switch</command> and <command>svn update</command> look the
        same?  The <literal>switch</literal> command is actually a
        superset of the update command.</para>
      @ENGLISH }}} -->
      <para>Har du lagt merke til at utdataene fra <command>svn 
        switch</command> og <command>svn update</command> ser likedan 
        ut?
        <literal>switch</literal>-kommandoen er faktisk en <!-- ¤ 
        «superset»: Overordnet? Utvidet versjon? Eller noe annet? Tror 
        «utvidet versjon» skal gå, i og med at den som sagt lengre nede 
        også flytter kopien gjennom «rom» i tillegg til «tid».
        -->utvidet versjon av 
        <command>update</command>-kommandoen.</para>

      <!-- @ENGLISH {{{
      <para>When you run <command>svn update</command>, you're asking
        the repository to compare two trees.  The repository does so,
        and then sends a description of the differences back to the
        client.  The only difference between <command>svn
        switch</command> and <command>svn update</command> is that the
        <literal>update</literal> command always compares two identical
        paths.</para>
      @ENGLISH }}} -->
      <para>Når du kjører <command>svn update</command>, ber du depotet 
        om å sammenligne to trær.
        Depotet gjør dette, og sender deretter en beskrivelse av 
        forskjellene tilbake til klienten.
        Den eneste forskjellen mellom <command>svn switch</command> og 
        <command>svn update</command> er at 
        <literal>update</literal>-kommandoen alltid sammenligner to 
        identiske stier.</para>
      
      <!-- @ENGLISH {{{
      <para>That is, if your working copy is a mirror of
        <filename>/calc/trunk</filename>, then <command>svn
        update</command> will automatically compare your working copy
        of <filename>/calc/trunk</filename> to
        <filename>/calc/trunk</filename> in the
        <literal>HEAD</literal> revision.  If you're switching your
        working copy to a branch, then <command>svn switch</command>
        will compare your working copy of
        <filename>/calc/trunk</filename> to some
        <emphasis>other</emphasis> branch-directory in the
        <literal>HEAD</literal> revision.</para>
      @ENGLISH }}} -->
      <para>Det vil si, hvis arbeidskopien din er et speil av 
        <filename>/calc/trunk</filename>, vil <command>svn 
        update</command> automatisk sammenligne arbeidskopien din av 
        <filename>/calc/trunk</filename> med 
        <filename>/calc/trunk</filename> i 
        <literal>HEAD</literal>-revisjonen.
        Hvis du bytter om arbeidskopien din til en gren, vil 
        <command>svn switch</command> sammenligne arbeidskopien av 
        <filename>/calc/trunk</filename> med en 
        <emphasis>annen</emphasis> grenkatalog i 
        <literal>HEAD</literal>-revisjonen.</para>

      <!-- @ENGLISH {{{
      <para>In other words, an update moves your working copy through
        time.  A switch moves your working copy through time
        <emphasis>and</emphasis> space.</para>
      @ENGLISH }}} -->
      <para>Med andre ord, en <command>update</command>-kommando flytter 
        arbeidskopien din gjennom tiden.
        En <command>switch</command>-kommando flytter arbeidskopien 
        gjennom tid <emphasis>og</emphasis> rom.</para>
    </sidebar>

    <!-- @ENGLISH {{{
    <para>Because <command>svn switch</command> is essentially a
      variant of <command>svn update</command>, it shares the same
      behaviors; any local modifications in your working copy are
      preserved when new data arrives from the repository.  This
      allows you to perform all sorts of clever tricks.</para>
    @ENGLISH }}} -->
    <para>Fordi <command>svn switch</command> egentlig er en variant av 
      <command>svn update</command> oppfører den seg på samme måte; alle 
      lokale modifiseringer i arbeidskopen blir tatt vare på når nye 
      data ankommer fra depotet.
      Dette lar deg gjøre alle mulige lure triks.</para>

    <!-- @ENGLISH {{{
    <para>For example, suppose you have a working copy of
      <filename>/calc/trunk</filename> and make a number of changes to
      it.  Then you suddenly realize that you meant to make the
      changes to a branch instead.  No problem!  When you <command>svn
      switch</command> your working copy to the branch, the local
      changes will remain.  You can then test and commit them to the
      branch.</para>
    @ENGLISH }}} -->
    <para>For eksempel, tenk deg at du har en arbeidskopi av 
      <filename>/calc/trunk</filename> og gjør et antall forandringer i 
      den.
      Så finner du plutselig ut at du skulle gjøre disse forandringene 
      på en gren istedenfor.
      Ikke noe problem!
      Når du bruker <command>svn switch</command> for å flytte 
      arbeidskopien til grenen, vil de lokale forandringene bli værende.
      Du kan deretter teste og legge dem inn på grenen.</para>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.tags">
    <!-- @ENGLISH {{{
    <title>Tags</title>
    @ENGLISH }}} -->
    <title>Merker 
      (<quote><foreignphrase>tags</foreignphrase></quote>)</title>

    <!-- @ENGLISH {{{
    <para>Another common version control concept is a
      <firstterm>tag</firstterm>.  A tag is just a
      <quote>snapshot</quote> of a project in time.  In Subversion,
      this idea already seems to be everywhere.  Each repository
      revision is exactly that&mdash;a snapshot of the filesystem
      after each commit.</para>
    @ENGLISH }}} -->
    <para>Et annet vanlig versjonskontrollkonsept er et 
      <firstterm>merke</firstterm> – <foreignphrase>tag</foreignphrase>.
      Et merke er bare et <quote>øyeblikksbilde</quote> av et prosjekt 
      på et spesiell tidspunkt.
      I Subversion ser denne idéen ut til å være overalt.
      Hver depotrevisjon er akkurat det – et øyeblikksbilde av 
      filsystemet etter hver innlegging.</para>

    <!-- @ENGLISH {{{
    <para>However, people often want to give more human-friendly names
      to tags, like <literal>release-1.0</literal>.  And they want to
      make snapshots of smaller subdirectories of the filesystem.
      After all, it's not so easy to remember that release-1.0 of a
      piece of software is a particular subdirectory of revision
      4822.</para>
    @ENGLISH }}} -->
    <para>Men folk vil ofte ønske å gi mer menneskevennlige navn på 
      merker, som <literal>versjon-1.0</literal>.
      Og de ønsker å ta øyeblikksbilder av mindre underkataloger i 
      filsystemet.
      Når alt kommer til alt, er det ikke så lett å huske at versjon-1.0 
      av et programprosjekt er en spesiell underkatalog av revisjon 
      4822.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.tags.mksimple">
      <!-- @ENGLISH {{{
      <title>Creating a Simple Tag</title>
      @ENGLISH }}} -->
      <title>Lage et enkelt merke</title>

      <!-- @ENGLISH {{{
      <para>Once again, <command>svn copy</command> comes to the
        rescue.  If you want to create a snapshot of
        <filename>/calc/trunk</filename> exactly as it looks in the
        <literal>HEAD</literal> revision, then make a copy of it:</para>
      @ENGLISH }}} -->
      <para>Atter en gang kommer <command>svn copy</command> og redder 
        situasjonen.
        Hvis du vil lage et øyeblikksbilde av 
        <filename>/calc/trunk</filename> nøyaktig som den ser ut i 
        <literal>HEAD</literal>-revisjonen, kan du lage en kopi av 
        den:</para>

      <!-- @ENGLISH {{{
      <screen>
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/tags/release-1.0 \
      -m "Tagging the 1.0 release of the 'calc' project."

Committed revision 351.
</screen>
      @ENGLISH }}} -->
      <screen>
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/tags/versjon-1.0 \
      -m "Merker 1.0-versjonen av «calc»-prosjektet."

La inn revisjon 351.
</screen>

      <!-- @ENGLISH {{{
      <para>This example assumes that a
        <filename>/calc/tags</filename> directory already exists.  (If it
        doesn't, see <xref linkend="svn.ref.svn.c.mkdir"/>).
        After the copy completes, the new
        <filename>release-1.0</filename> directory is forever a
        snapshot of how the project looked in the
        <literal>HEAD</literal> revision at the time you made the
        copy.  Of course you might want to be more precise about
        exactly which revision you copy, in case somebody else may
        have committed changes to the project when you weren't
        looking.  So if you know that revision 350 of
        <filename>/calc/trunk</filename> is exactly the snapshot you
        want, you can specify it by passing <option>-r 350</option> to
        the <command>svn copy</command> command.</para>
      @ENGLISH }}} -->
      <para>Dette eksempelet forutsetter at en 
        <filename>/calc/tags</filename>-katalog allerede eksisterer.
        (Hvis den ikke gjør det, se <xref 
        linkend="svn.ref.svn.c.mkdir"/>.)
        Etter at kopieringen er fullført, vil den nye 
        <filename>versjon-1.0</filename>-katalogen for alltid være et 
        øyeblikksbilde av hvordan prosjektet så ut i 
        <literal>HEAD</literal>-revisjonen på den tiden du lagde kopien.
        Selvfølgelig vil du være mer presis angående hvilken revisjon du 
        kopierer, i tilfelle noen andre kan ha lagt inn forandringer til 
        prosjektet mens du ikke så det.
        Så hvis du vet at revisjon 350 av 
        <filename>/calc/trunk</filename> er nøyaktig det øeblikksbildet 
        du ønsker, kan du spesifisere dette ved å angi <option>-r 
        350</option> til <command>svn copy</command>-kommandoen.</para>

      <!-- @ENGLISH {{{
      <para>But wait a moment: isn't this tag-creation procedure the
        same procedure we used to create a branch?  Yes, in fact, it
        is.  In Subversion, there's no difference between a tag and a
        branch.  Both are just ordinary directories that are created
        by copying.  Just as with branches, the only reason a copied
        directory is a <quote>tag</quote> is because
        <emphasis>humans</emphasis> have decided to treat it that way:
        as long as nobody ever commits to the directory, it forever
        remains a snapshot.  If people start committing to it, it
        becomes a branch.</para>
      @ENGLISH }}} -->
      <para>Men vent nå litt:
        Er ikke denne prosedyren med opprettelse av merker den samme 
        prosedyren som vi brukte da vi lagde en gren?
        Ja, faktisk er det det.
        I Subversion er det ingen forskjell på et merke og en gren.
        Begge er bare vanlige kataloger som er opprettet ved kopiering.
        Akkurat som med grener er den eneste grunnen til at en kopiert 
        katalog er et <quote>merke</quote> fordi 
        <emphasis>mennesker</emphasis> har bestemt seg for å behandle 
        den på denne måten:
        Så lenge ingen legger inn forandringer i katalogen, forblir den 
        for alltid et øyeblikksbilde.
        Hvis noen begynner å legge inn forandringer i den, blir den en 
        gren.</para>

      <!-- @ENGLISH {{{
      <para>If you are administering a repository, there are two
        approaches you can take to managing tags.  The first approach
        is <quote>hands off</quote>: as a matter of project policy,
        decide where your tags will live, and make sure all users know
        how to treat the directories they copy in there.  (That is,
        make sure they know not to commit to them.)  The second
        approach is more paranoid: you can use one of the
        access-control scripts provided with Subversion to prevent
        anyone from doing anything but creating new copies in the
        tags-area (See <xref linkend="svn.serverconfig"/>.)  The paranoid
        approach, however, isn't usually necessary.  If a user
        accidentally commits a change to a tag-directory, you can
        simply undo the change as discussed in the previous section.
        This is version control, after all.</para>
      @ENGLISH }}} -->
      <para>Hvis du administrerer et depot, er det to fremgangsmåter du 
        kan bruke for å holde rede på merker.
        Den første fremgangsmåten er <quote>ikke rør</quote>:
        Som en del av reglene for prosjektet, bestem hvor i depotet 
        merkene skal ligge, og gjør det klart for alle brukere hvordan 
        de skal behandle kataloger som de kopierer inn dit.
        (Det vil si, vær sikker på at de vet at nye innlegginger ikke 
        skal skje der.)
        Den andre fremgangsmåten er mer paranoid:
        Du kan bruke et av aksesskontrollskriptene som følger med 
        Subversion til å forhindre noen fra å gjøre noe annet enn å 
        opprette nye kopier i merkeområdet (se <xref 
        linkend="svn.serverconfig"/>).
        Den paranoide ruten er imidlertid vanligvis ikke nødvendig.
        Hvis en bruker legger inn en forandring i en merkekatalog, kan 
        du enkelt og greit omgjøre forandringen som nevnt i den forrige 
        seksjonen.
        Dette er versjonskontroll, tross alt.</para>

    </sect2>
    
    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.tags.mkcomplex">
      <!-- @ENGLISH {{{
      <title>Creating a Complex Tag</title>
      @ENGLISH }}} -->
      <title>Lage et komplekst merke</title>
      
      <!-- @ENGLISH {{{
      <para>Sometimes you may want your <quote>snapshot</quote> to be
        more complicated than a single directory at a single
        revision.</para>
      @ENGLISH }}} -->
      <para>Noen ganger vil du at <quote>øyeblikksbildet</quote> skal 
        være mer komplisert enn en enkel katalog med en enkelt 
        revisjon.</para>
      
      <!-- @ENGLISH {{{
      <para>For example, pretend your project is much larger than our
        <filename>calc</filename> example: suppose it contains a
        number of subdirectories and many more files.  In the course
        of your work, you may decide that you need to create a working
        copy that is designed to have specific features and bug fixes.
        You can accomplish this by selectively backdating files or
        directories to particular revisions (using <command>svn update
        -r</command> liberally), or by switching files and directories
        to particular branches (making use of <command>svn
        switch</command>).  When you're done, your working copy is a
        hodgepodge of repository locations from different revisions.
        But after testing, you know it's the precise combination of
        data you need.</para>
      @ENGLISH }}} -->
      <para>For eksempel, tenk deg at prosjektet ditt er mye større enn 
        <filename>calc</filename>-eksempelet vårt:
        Det inneholder mange underkataloger og mange flere filer.
        Mens du holder på med arbeidet, bestemmer du deg kanskje for at 
        du må lage en arbeidskopi som skal ha en spesiell funksjonalitet 
        sammen med feilrettinger.
        Du kan oppnå dette ved å selektivt tilbakedatere filer eller 
        kataloger til spesielle revisjoner (ved å bruke <command>svn 
        update -r</command> i stor skala) eller ved å bytte om filer og 
        kataloger til spesielle grener (ved hjelp av <command>svn 
        switch</command>).
        Når du er ferdig, er arbeidskopien din et virvar av 
        depotplasseringer fra forskjellige revisjoner.
        Men etter at du har kjørt noen tester, vet du at dette er 
        akkurat sånn som du vil ha det.</para>

      <!-- @ENGLISH {{{
      <para>Time to make a snapshot.  Copying one URL to another won't
        work here.  In this case, you want to make a snapshot of your
        exact working copy arrangement and store it in the repository.
        Luckily, <command>svn copy</command> actually has four
        different uses (which you can read about in Chapter 9),
        including the ability to copy a working-copy tree to the
        repository:</para>
      @ENGLISH }}} -->
      <para>På tide å lagre et øyeblikksbilde.
        Det å kopiere en URL til en annen vil ikke fungere her.
        I dette tilfellet ønsker du å lage et øyeblikksbilde av din 
        eksakte arbeidskopi og lagre den i depotet.
        Heldigvis har <command>svn copy</command> faktisk fire 
        forskjellige bruksmåter (som du kan lese om i kapittel 9), 
        inkludert muligheten til å kopiere et tre av en arbeidskopi til 
        depotet:</para>

      <!-- @ENGLISH {{{
      <screen>
$ ls
my-working-copy/

$ svn copy my-working-copy http://svn.example.com/repos/calc/tags/mytag

Committed revision 352.
</screen>
      @ENGLISH }}} -->
      <screen>
$ ls
min-arbeidskopi/

$ svn copy min-arbeidskopi 
http://svn.example.com/repos/calc/tags/mittmerke

La inn revisjon 352.
</screen>

      <!-- @ENGLISH {{{
      <para>Now there is a new directory in the repository,
        <filename>/calc/tags/mytag</filename>, which is an exact
        snapshot of your working copy&mdash;mixed revisions, URLs,
        and all.</para>
      @ENGLISH }}} -->
      <para>Nå er det en ny katalog i depotet, 
        <filename>/calc/tags/mittmerke</filename>, som er et eksakt 
        øyeblikksbilde av arbeidskopien din – blandede revisjoner, URLer 
        og hele pakken.</para>

      <!-- @ENGLISH {{{
      <para>Other users have found interesting uses for this feature.
        Sometimes there are situations where you have a bunch of local
        changes made to your working copy, and you'd like a
        collaborator to see them.  Instead of running <command>svn
        diff</command> and sending a patch file (which won't capture
        tree changes, symlink changes or changes in properties), you can
        instead use <command>svn copy</command> to <quote>upload</quote>
        your working copy to a private area of the repository.  Your
        collaborator can then either checkout a verbatim copy of your
        working copy, or use <command>svn merge</command> to receive
        your exact changes.</para>
      @ENGLISH }}} -->
      <para>Andre brukere har funnet interessante måter å bruke denne 
        funksjonaliteten på.
        Noen ganger er det situasjoner hvor du har en dunge med lokale 
        forandringer i arbeidskopien, og du vil at en kollega skal se på 
        dem.
        Istedenfor å kjøre <command>svn diff</command> og sende 
        patchfilen (som ikke vil fange opp treforandringer eller 
        forandringer i symbolske linker eller egenskaper), kan du 
        istedenfor bruke <command>svn copy</command> for å 
        <quote>sende</quote> arbeidskopien til et privat område i 
        depotet.
        Kollegaen din kan dermed enten hente ut en nøyaktig kopi av 
        arbeidskopien din, eller bruke <command>svn merge</command> for 
        å motta de eksakte forandringene dine.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.maint">
    <!-- @ENGLISH {{{
    <title>Branch Maintenance</title>
    @ENGLISH }}} -->
    <title>Vedlikehold av grener</title>

    <!-- @ENGLISH {{{
    <para>You may have noticed by now that Subversion is extremely
      flexible.  Because it implements branches and tags with the same
      underlying mechanism (directory copies), and because branches
      and tags appear in normal filesystem space, many people find
      Subversion intimidating.  It's almost <emphasis>too</emphasis>
      flexible.  In this section, we'll offer some suggestions for
      arranging and managing your data over time.</para>
    @ENGLISH }}} -->
    <para>Du har kanskje sett nå at Subversion er ekstremt fleksibel.
      Fordi grener og merker blir laget med den samme underliggende 
      mekanismen (kopier av kataloger), og fordi grener og merker vises 
      i filsystemet, finner mange Subversion <!-- ¤ -->litt skremmende.
      Den er nesten <emphasis>for</emphasis> fleksibel.
      I denne seksjonen vil vi komme med noen forslag på hvordan du kan 
      arrangere og vedlikeholde dataene dine over tid.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.maint.layout">
      <!-- @ENGLISH {{{
      <title>Repository Layout</title>
      @ENGLISH }}} -->
      <title>Utseendet på depotet</title>
      
      <!-- @ENGLISH {{{
      <para>There are some standard, recommended ways to organize a
        repository.  Most people create a <filename>trunk</filename>
        directory to hold the <quote>main line</quote> of development,
        a <filename>branches</filename> directory to contain branch
        copies, and a <filename>tags</filename> directory to contain
        tag copies.  If a repository holds only one project, then
        often people create these top-level directories:</para>
      @ENGLISH }}} -->
      <para>Det er noen standardiserte, anbefalte måter å organisere et 
        depot på.
        Mange lager en <filename>trunk</filename>-katalog for å lagre 
        <quote>hovedlinjen</quote> av utviklingen, en 
        <filename>branches</filename>-katalog som inneholder grenkopier, 
        og en <filename>tags</filename>-katalog som inneholder merker.
        Hvis et depot bare inneholder ett prosjekt, lager man ofte disse 
        toppkatalogene:</para>

      <screen>
/trunk
/branches
/tags
</screen>

      <!-- @ENGLISH {{{
      <para>If a repository contains multiple projects, admins
        typically index their layout by project (see <xref
        linkend="svn.reposadmin.projects.chooselayout"/> to read more about
        <quote>project roots</quote>):</para>
      @ENGLISH }}} -->
      <para>Hvis et depot inneholder flere prosjekter, legger 
        administratorer vanligvis depotet opp etter prosjekt (se <xref 
        linkend="svn.reposadmin.projects.chooselayout"/> for å lese mer 
        om <quote>prosjektrøtter</quote>):</para>

      <screen>
/paint/trunk
/paint/branches
/paint/tags
/calc/trunk
/calc/branches
/calc/tags
</screen>

      <!-- @ENGLISH {{{
      <para>Of course, you're free to ignore these common layouts.
        You can create any sort of variation, whatever works best for
        you or your team.  Remember that whatever you choose, it's not
        a permanent commitment.  You can reorganize your repository at
        any time.  Because branches and tags are ordinary directories,
        the <command>svn move</command> command can move or rename
        them however you wish.  Switching from one layout to another
        is just a matter of issuing a series of server-side moves; if
        you don't like the way things are organized in the repository,
        just juggle the directories around.</para>
      @ENGLISH }}} -->
      <para>Du står selvfølgelig fritt til å ignorere disse vanlige 
        oppsettene.
        Du kan lage alle mulige varianter, hva som enn fungerer best for 
        deg og ditt team.
        Husk at hva du enn velger, er du ikke forpliktet til å ha det 
        sånn for alltid.
        Du kan reorganisere depotet ditt når du vil.
        Fordi grener og merker er vanlige kataloger, kan <command>svn 
        move</command>-kommandoen flytte eller skifte navn på dem sånn 
        som du ønsker.
        Å bytte fra et utseende til et annet er bare snakk om å utføre 
        en serie flyttinger på &the_server;; hvis du ikke liker måten 
        ting er organisert på i depotet, er det bare å ommøblere på 
        katalogene.</para>

      <!-- @ENGLISH {{{
      <para>Remember, though, that while moving directories may be
        easy to do, you need to be considerate of your users as well.
        Your juggling can be disorienting to users with existing
        working copies.  If a user has a working copy of a particular
        repository directory, your <command>svn move</command>
        operation might remove the path from the latest revision.
        When the user next runs <command>svn update</command>, she will
        be told that her working copy represents a path that no
        longer exists, and the user will be forced to <command>svn
        switch</command> to the new location.
        </para>
      @ENGLISH }}} -->
      <para>Men husk at selv om det å flytte kataloger er en enkel sak, 
        må du også tenke på brukerne dine.
        Ommøbleringen kan være forvirrende for brukere med eksisterende 
        arbeidskopier.
        Hvis en bruker har en arbeidskopi fra en spesiell depotkatalog, 
        kan <command>svn move</command>-operasjonen fjerne stien fra den 
        seneste revisjonen.
        Når brukeren kjører <command>svn update</command> neste gang, 
        vil hun bli fortalt at arbeidskopien hennes representerer en sti 
        som ikke lenger finnes, og brukeren vil bli tvunget til å bruke 
        <command>svn switch</command> for å sette arbeidskopien til den 
        nye plasseringen.</para>
      
    </sect2>
    
    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.maint.lifetime">
      <!-- @ENGLISH {{{
      <title>Data Lifetimes</title>
      @ENGLISH }}} -->
      <title>Levetid for data</title>

      <!-- @ENGLISH {{{
      <para>Another nice feature of Subversion's model is that
        branches and tags can have finite lifetimes, just like any
        other versioned item.  For example, suppose you eventually
        finish all your work on your personal branch of the
        <filename>calc</filename> project.  After merging all of your
        changes back into <filename>/calc/trunk</filename>, there's
        no need for your private branch directory to stick around
        anymore:</para>
      @ENGLISH }}} -->
      <para>En annen fin funksjonalitet med Subversions modell er at 
        grener og merker kan ha begrenset levetid, akkurat som ethvert 
        annet versjonert element.
        Tenk deg for eksempel at du etterhvert blir ferdig med alt 
        arbeidet på din personlige gren i 
        <filename>calc</filename>-prosjektet.
        Etter at du har flettet alle dine forandringer tilbake til 
        <filename>/calc/trunk</filename>, trenger ikke grenkatalogen å 
        ligge der mer:</para>

      <!-- @ENGLISH {{{
      <screen>
$ svn delete http://svn.example.com/repos/calc/branches/my-calc-branch \
             -m "Removing obsolete branch of calc project."

Committed revision 375.
</screen>
      @ENGLISH }}} -->
      <screen>
$ svn delete http://svn.example.com/repos/calc/branches/min-calc-gren \
             -m "Fjerner avlegs gren i calc-prosjektet."

La inn revisjon 375.
</screen>

      <!-- @ENGLISH {{{
      <para>And now your branch is gone.  Of course it's not really
        gone: the directory is simply missing from the
        <literal>HEAD</literal> revision, no longer distracting
        anyone.  If you use <command>svn checkout</command>,
        <command>svn switch</command>, or <command>svn list</command>
        to examine an earlier revision, you'll still be able to see
        your old branch.</para>
      @ENGLISH }}} -->
      <para>Og nå er forgreningen borte.
        Vel, selvfølgelig er den ikke <emphasis>egentlig</emphasis> 
        borte, katalogen mangler bare fra 
        <literal>HEAD</literal>-revisjonen og distraherer dermed ingen.
        Hvis du bruker <command>svn checkout</command>, <command>svn 
        switch</command> eller <command>svn list</command> for å 
        undersøke en tidligere revisjon, vil du fortsatt være i stand 
        til å se den gamle grenen din.</para>

      <!-- @ENGLISH {{{
      <para>If browsing your deleted directory isn't enough, you can
        always bring it back.  Resurrecting data is very easy in
        Subversion.  If there's a deleted directory (or file) that
        you'd like to bring back into <literal>HEAD</literal>, simply
        use <command>svn copy -r</command> to copy it from the old
        revision:</para>
      @ENGLISH }}} -->
      <para>Hvis det ikke er nok å bare undersøke den slettede 
        katalogen, kan du alltids hente den tilbake.
        Å hente tilbake data i Subversion er veldig enkelt.
        Hvis det er en slettet katalog (eller fil) som du vil hente 
        tilbake inn i <literal>HEAD</literal>, kan du bruke <command>svn 
        copy -r</command> for å kopiere den fra den gamle 
        revisjonen:</para>

      <!-- @ENGLISH {{{
      <screen>
$ svn copy -r 374 http://svn.example.com/repos/calc/branches/my-calc-branch \
                  http://svn.example.com/repos/calc/branches/my-calc-branch

Committed revision 376.
</screen>
      @ENGLISH }}} -->
      <screen>
$ svn copy -r 374 http://svn.example.com/repos/calc/branches/min-calc-gren \
                  http://svn.example.com/repos/calc/branches/min-calc-gren

La inn revisjon 376.
</screen>

      <!-- @ENGLISH {{{
      <para>In our example, your personal branch had a relatively
        short lifetime: you may have created it to fix a bug or
        implement a new feature.  When your task is done, so is the
        branch.  In software development, though, it's also common to
        have two <quote>main</quote> branches running side-by-side for
        very long periods.  For example, suppose it's time to release
        a stable version of the <filename>calc</filename> project to the
        public, and you know it's going to take a couple of months to
        shake bugs out of the software.  You don't want people to add
        new features to the project, but you don't want to tell all
        developers to stop programming either.  So instead, you create
        a <quote>stable</quote> branch of the software that won't
        change much:</para>
      @ENGLISH }}} -->
      <para>I eksempelet vårt hadde den personlige grenen din en 
        relativt kort levetid, du kan ha laget den for å ordne en feil 
        eller legge til en ny funksjonalitet.
        Når oppgaven din er gjort, er levetiden til grenen over.
        Men innen programutvikling er det også vanlig å ha to 
        <quote>hoved</quote>-grener som lever ved siden av hverandre for 
        veldig lange perioder.
        For eksempel, tenk deg at det er på tide å utgi en stabil 
        versjon av <filename>calc</filename>-prosjektet til 
        offentligheten, og du vet at det kommer til å ta noen måneder å 
        luke ut feil av programmet.
        Du vil ikke at folk skal legge inn ny funksjonalitet til 
        prosjektet, men du vil heller ikke at utviklerne skal stoppe 
        programmeringen.
        Så istedenfor lager du en <quote>stabil</quote> gren av 
        programmet som ikke vil forandre seg så mye:</para>

      <!-- @ENGLISH {{{
      <screen>
$ svn copy http://svn.example.com/repos/calc/trunk \
         http://svn.example.com/repos/calc/branches/stable-1.0 \
         -m "Creating stable branch of calc project."

Committed revision 377.
</screen>
      @ENGLISH }}} -->
      <screen>
$ svn copy http://svn.example.com/repos/calc/trunk \
         http://svn.example.com/repos/calc/branches/stabil-1.0 \
         -m "Lager stabil gren av calc-prosjektet."

La inn revisjon 377.
</screen>

      <!-- @ENGLISH {{{
      <para>And now developers are free to continue adding
        cutting-edge (or experimental) features to
        <filename>/calc/trunk</filename>, and you can declare a
        project policy that only bug fixes are to be committed to
        <filename>/calc/branches/stable-1.0</filename>.  That is, as
        people continue to work on the trunk, a human selectively
        ports bug fixes over to the stable branch.  Even after the
        stable branch has shipped, you'll probably continue to
        maintain the branch for a long time&mdash;that is, as long
        as you continue to support that release for customers.</para>
      @ENGLISH }}} -->
      <para>Og nå kan utviklerne fortsette med å legge til rykende 
        ferske (eller eksperimentelle) funksjoner til 
        <filename>/calc/trunk</filename>, og du kan lage en regel for 
        prosjektet som sier at kun feilrettinger skal legges inn i 
        <filename>/calc/branches/stabil-1.0</filename>.
        Det vil si, mens brukerne fortsetter å arbeide i trunk, kan 
        feilrettinger selektivt bli flettet over til den stabile grenen.
        Selv etter at den stabile grenen er på markedet, vil du 
        sannsynligvis fortsette å vedlikeholde grenen i lang tid – det 
        vil si så lenge du fortsetter med å vedlikeholde utgivelsen for 
        kunder.</para>

    </sect2>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.summary">
    <!-- @ENGLISH {{{
    <title>Summary</title>
    @ENGLISH }}} -->
    <title>Oppsummering</title>

    <!-- @ENGLISH {{{
    <para>We've covered a lot of ground in this chapter.  We've
      discussed the concepts of tags and branches, and demonstrated
      how Subversion implements these concepts by copying directories
      with the <command>svn copy</command> command.  We've shown how
      to use <command>svn merge</command> to copy changes from one
      branch to another, or roll back bad changes.  We've gone over
      the use of <command>svn switch</command> to create
      mixed-location working copies.  And we've talked about how one
      might manage the organization and lifetimes of branches in a
      repository.</para>
    @ENGLISH }}} -->
    <para>Vi har gått gjennom en god del i dette kapittelet.
      Vi har diskutert konseptene rundt merker og grener, og demonstrert 
      hvordan Subversion implementerer disse konseptene ved å kopiere 
      kataloger med <command>svn copy</command>-kommandoen.
      Vi har vist hvordan <command>svn merge</command> brukes for å 
      kopiere forandringer fra en gren til en annen, eller omgjøre feile 
      forandringer.
      Vi har gått over bruken av <command>svn switch</command> for å 
      lage arbeidskopier med blandede revisjoner.
      Og vi har snakket om hvordan man kan vedlikeholde organiseringen 
      og levetiden til grener i et depot.</para>

    <!-- @ENGLISH {{{
    <para>Remember the Subversion mantra: branches and tags are cheap.
      So use them liberally!</para>
    @ENGLISH }}} -->
    <para>Husk mantraet til Subversion:
      Grener og merker er billige.
      Bruk dem så mye du vil!</para>

  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
vim: set ft=svnbook :
-->


