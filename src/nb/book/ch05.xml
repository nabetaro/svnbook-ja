<chapter id="svn.reposadmin">
<!-- @ENGLISH {{{
  <title>Repository Administration</title>
@ENGLISH }}} -->
  <title>Depotadministrasjon</title>

  <simplesect>

    <!-- @ENGLISH {{{
    <para>The Subversion repository is the central storehouse of
      versioned data for any number of projects.  As such, it becomes
      an obvious candidate for all the love and attention an
      administrator can offer.  While the repository is generally a
      low-maintenance item, it is important to understand how to
      properly configure and care for it so that potential problems
      are avoided, and actual problems are safely resolved.</para>
    @ENGLISH }}} -->
    <para>Subversiondepotet er den sentrale lagringsplassen for 
      versjonerte data for ethvert antall prosjekter.
      Som sådan blir det en opplagt kandidat for all kjærlighet og 
      oppmerksomhet en administrator kan tilby.
      Selv om depotet vanligvis er et element som krever lite 
      vedlikehold, er det viktig å forstå hvordan du kan konfigurere og 
      passe på det så potensielle problemer blir unngått, og aktuelle 
      problemer løst på en trygg måte.</para>

    <!-- @ENGLISH {{{
    <para>In this chapter, we'll discuss how to create and configure
      a Subversion repository.  We'll also talk about repository
      maintenance, including the use of the <command>svnlook</command>
      and <command>svnadmin</command> tools (which are provided with
      Subversion).  We'll address some common questions and mistakes,
      and give some suggestions on how to arrange the data in the
      repository.</para>
    @ENGLISH }}} -->
    <para>I dette kapittelet vil vi diskutere hvordan du kan opprette og 
      konfigurere et Subversiondepot.
      Vi vil også snakke om depotvedlikehold, inkludert bruken av 
      verktøyene <command>svnlook</command> og 
      <command>svnadmin</command> (som følger med Subversion).
      Vi vil adressere vanlige spørsmål og feilgrep, og komme med noen 
      forslag til hvordan du kan legge opp dataene i depotet.</para>

    <!-- @ENGLISH {{{
    <para>If you plan to access a Subversion repository only in the
      role of a user whose data is under version control (that is, via
      a Subversion client), you can skip this chapter altogether.
      However, if you are, or wish to become, a Subversion repository
      administrator,
      <footnote>
        <para>This may sound really prestigious and lofty, but we're
          just talking about anyone who is interested in that
          mysterious realm beyond the working copy where everyone's
          data hangs out.</para>
      </footnote>
      you should definitely pay attention to this chapter.</para>
    @ENGLISH }}} -->
    <para>Hvis du planlegger å aksessere et Subversiondepot bare i 
      rollen som en bruker som har data under versjonskontroll (det vil 
      si via en Subversionklient), kan du hoppe over hele dette 
      kapitlet.
      Hvis du derimot er, eller vil bli, en administrator for et 
      Subversiondepot,<footnote>
        <para>Dette kan høres <!-- ¤ -->råflott ut, men vi snakker bare 
          om alle som er interesserte i dette mystiske området hvor 
          alles data ligger.</para>
      </footnote> bør du så absolutt følge med i dette 
      kapittelet.</para>

  </simplesect>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.basics">
    <!-- @ENGLISH {{{
    <title>Repository Basics</title>
    @ENGLISH }}} -->
    <title>Det grunnleggende ved et depot</title>

    <!-- @ENGLISH {{{
    <para>Before jumping into the broader topic of repository
      administration, let's further define what a repository is.  How
      does it look?  How does it feel?  Does it take its tea hot or
      iced, sweetened, and with lemon?  As an administrator, you'll be
      expected to understand the composition of a repository both from
      a logical perspective&mdash;dealing with how data is represented
      inside the repository&mdash;and from a physical nuts-and-bolts
      perspective&mdash;how a repository looks and acts with respect
      to non-Subversion tools.  The following section covers some of
      these basic concepts at a very high level.</para>
    @ENGLISH }}} -->
    <para>Før vi hopper inn i det mer generelle innen emnet 
      depotadministrasjon, la oss definere videre hva et depot er.
      Hvordan ser det ut?
      Hvordan føles det?
      Vil det ha teen sin varm eller med is, søt, og med sitron?
      Som en administrator blir det forventet av deg at du må forstå 
      sammensetningen av et depot både fra et logisk perspektiv – det å 
      styre med hvordan data er representert i depotet – og fra et 
      fysisk skrue-og-mutter-perspektiv – hvordan et depot ser ut og 
      oppfører seg i sammenheng med verktøy <!-- ¤ -->som ikke hører med 
      til Subversion-pakken.
      Den følgende seksjonen dekker noen av disse grunnleggende 
      konseptene på et høyt nivå.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.txnsrevs">
      <!-- @ENGLISH {{{
      <title>Understanding Transactions and Revisions</title>
      @ENGLISH }}} -->
      <title>Forståelse av transaksjoner og revisjoner</title>
        
      <!-- @ENGLISH {{{
      <para>Conceptually speaking, a Subversion repository is a
        sequence of directory trees.  Each tree is a snapshot of how
        the files and directories versioned in your repository looked
        at some point in time.  These snapshots are created as a
        result of client operations, and are called revisions.</para>
      @ENGLISH }}} -->
      <para>Konseptmessig sagt er et Subversiondepot en sekvens av trær.
        Hvert tre er et øyeblikksbilde av hvordan filene og katalogene 
        så ut på et spesielt tidspunkt.
        Disse øyeblikksbildene er opprettet som et resultat av 
        klientoperasjoner og blir kalt revisjoner.</para>

      <!-- @ENGLISH {{{
      <para>Every revision begins life as a transaction tree.  When
        doing a commit, a client builds a Subversion transaction that
        mirrors their local changes (plus any additional changes that
        might have been made to the repository since the beginning of
        the client's commit process), and then instructs the
        repository to store that tree as the next snapshot in the
        sequence.  If the commit succeeds, the transaction is
        effectively promoted into a new revision tree, and is assigned
        a new revision number.  If the commit fails for some reason,
        the transaction is destroyed and the client is informed of the
        failure.</para>
      @ENGLISH }}} -->
      <para>Hver revisjon begynner livet som et transaksjonstre.
        Når du gjør en innlegging, bygger en klient en 
        Subversiontransaksjon som avspeiler deres lokale forandringer 
        (pluss eventuelle forandringer som er blitt lagt inn i tillegg 
        til depotet siden begynnelsen av innleggingsprosessen), og 
        instruerer deretter depotet om å lagre dette treet som det neste 
        øyeblikksbildet i sekvensen.
        Hvis innleggingen lykkes, blir transaksjonen <!-- ¤ effectively 
        promoted -->innlemmet i et nytt revisjonstre, og blir tildelt et 
        nytt revisjonsnummer.
        Hvis innleggingen av en eller annen grunn ikke lykkes, blir 
        transaksjonen ødelagt og klienten informeres om feilen.</para>
            
      <!-- @ENGLISH {{{
      <para>Updates work in a similar way.  The client builds a
        temporary transaction tree that mirrors the state of the
        working copy.  The repository then compares that transaction
        tree with the revision tree at the requested revision (usually
        the most recent, or <quote>youngest</quote> tree), and sends
        back information that informs the client about what changes
        are needed to transform their working copy into a replica of
        that revision tree.  After the update completes, the temporary
        transaction is deleted.</para>
      @ENGLISH }}} -->
      <para>Oppdateringer fungerer på en lignende måte.
        Klienten bygger et midlertidig transaksjonstre som avspeiler 
        tilstanden til arbeidskopien.
        Depotet sammenligner deretter dette transaksjonstreet med 
        revisjonstreet i den forespurte revisjonen (vanligvis det 
        nyeste, eller <quote>yngste</quote> treet), og sender tilbake 
        informasjon som forteller klienten om hvilke forandringer som er 
        nødvendig for å forandre deres arbeidskopi til et replikat av 
        det aktuelle revisjonstreet.
        Etter at oppdateringen er fullført, blir den midlertidige 
        transaksjonen slettet.</para>
          
      <!-- @ENGLISH {{{
      <para>The use of transaction trees is the only way to make
        permanent changes to a repository's versioned filesystem.
        However, it's important to understand that the lifetime of a
        transaction is completely flexible.  In the case of updates,
        transactions are temporary trees that are immediately
        destroyed.  In the case of commits, transactions are
        transformed into permanent revisions (or removed if the commit
        fails).  In the case of an error or bug, it's possible that a
        transaction can be accidentally left lying around in the
        repository (not really affecting anything, but still taking up
        space).</para>
      @ENGLISH }}} -->
      <para>Bruken av transaksjonstrær er den eneste måten å gjøre 
        permanente forandringer til et depots versjonskontrollerte 
        filsystem.
        Det er imidlertid viktig å forstå at livløpet til en transaksjon 
        er komplett fleksible.
        I tilfellet med oppdateringer er transaksjoner midlertidige trær 
        som blir øyeblikkelig ødelagt.
        I tilfellet med innlegginger blir transaksjoner transformert inn 
        i permanente revisjoner (eller fjernet hvis innleggingen 
        feiler).
        I tilfelle en generell feil eller programfeil oppstår, er det 
        mulig at en transaksjon kan bli liggende igjen i depotet (uten å 
        påvirke noe som helst, men tar opp diskplass).</para>

     <!-- @ENGLISH {{{
      <para>In theory, someday whole workflow applications might
        revolve around more fine-grained control of transaction
        lifetime.  It is feasible to imagine a system whereby each
        transaction slated to become a revision is left in stasis well
        after the client finishes describing its changes to
        repository.  This would enable each new commit to be reviewed
        by someone else, perhaps a manager or engineering QA team, who
        can choose to promote the transaction into a revision, or
        abort it.</para>
     @ENGLISH }}} -->
      <para>I teorien vil kanskje <!-- ¤ -->hele 
        arbeidsflytapplikasjoner en gang gi mer nøyaktig kontroll med 
        levetiden til en transaksjon.
        Det er mulig å tenke seg et system som ved hver transaksjon 
        beregnet på å bli en revisjon blir satt <!-- ¤ -->på venting 
        etter at klienten er <!-- ¤ -->ferdig med å beskrive sine 
        forandringer til depotet.
        Dette ville muliggjøre at hver ny innlegging kan bli sett over 
        av noen andre, kanskje en manager eller <!-- ¤ -->ledende 
        utvikler, som kan velge å forfremme transaksjonen til en 
        revisjon eller avbryte den.</para>
            
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.revprops">
      <!-- @ENGLISH {{{
      <title>Unversioned Properties</title>
      @ENGLISH }}} -->
      <title>Uversjonerte egenskaper</title>

      <!-- @ENGLISH {{{
      <para>Transactions and revisions in the Subversion repository
        can have properties attached to them.  These properties are
        generic key-to-value mappings, and are generally used to store
        information about the tree to which they are attached.  The
        names and values of these properties are stored in the
        repository's filesystem, along with the rest of your tree
        data.</para>
      @ENGLISH }}} -->
      <para>Transaksjoner og revisjoner i Subversiondepotet kan ha 
        vedlagte egenskaper.
        Disse egenskapene er generiske 
        <quote>nøkkel-til-verdi</quote>-mappinger, og blir vanligvis 
        brukt til å lagre informasjon om treet som de er vedlagt.
        Navnene og verdiene til disse egenskapene er lagret i depotets 
        filsystem, sammen med resten av dataene for treet.</para>

      <!-- @ENGLISH {{{
      <para>Revision and transaction properties are useful for
        associating information with a tree that is not strictly
        related to the files and directories in that tree&mdash;the
        kind of information that isn't managed by client working
        copies.  For example, when a new commit transaction is created
        in the repository, Subversion adds a property to that
        transaction named <literal>svn:date</literal>&mdash;a
        datestamp representing the time that the transaction was
        created.  By the time the commit process is finished, and the
        transaction is promoted to a permanent revision, the tree has
        also been given a property to store the username of the
        revision's author (<literal>svn:author</literal>) and a
        property to store the log message attached to that revision
        (<literal>svn:log</literal>).</para>
      @ENGLISH }}} -->
      <para>Revisjons- og transaksjonsegenskaper er nyttige for å 
        assosiere informasjon sammen med et tre som ikke er spesifikt 
        relatert til filene og katalogene i dette treet ― den typen 
        informasjon som ikke er behandlet av arbeidskopier for klienten.
        For eksempel, når en ny innleggingstransaksjon er opprettet i 
        depotet, legger Subversion en egenskap til denne transaksjonen 
        kalt <literal>svn:date</literal> – et tidsmerke som 
        representerer tidspunktet transaksjonen ble opprettet.
        Når innleggingsprosessen er fullført, og transaksjonen blir 
        forfremmet til en permanent revisjon, har treet også fått en 
        egenskap for å lagre brukernavnet til revisjonens forfatter 
        (<literal>svn:author</literal>) og en egenskap for å lagre 
        loggmeldingen som hører til denne revisjonen 
        <literal>svn:log</literal>.</para>

      <!-- @ENGLISH {{{
      <para>Revision and transaction properties are
        <firstterm>unversioned properties</firstterm>&mdash;as they
        are modified, their previous values are permanently discarded.
        Also, while revision trees themselves are immutable, the
        properties attached to those trees are not.  You can add,
        remove, and modify revision properties at any time in the
        future.  If you commit a new revision and later realize that
        you had some misinformation or spelling error in your log
        message, you can simply replace the value of the
        <literal>svn:log</literal> property with a new, corrected log
        message.</para>
      @ENGLISH }}} -->
      <para>Revisjons- og transaksjonsegenskaper er 
        <firstterm>uversjonerte egenskaper</firstterm> – når de blir 
        modifisert blir den foregående verdien permanent forkastet.
        Selv om revisjonstrær er uforanderlige, gjelder ikke dette 
        egenskapene som er vedlagt disse trærne.
        Du kan legge til, fjerne, og modifisere revisjonsegenskaper til 
        enhver tid i fremtiden.
        Hvis du legger inn en ny revisjon og senere finner ut at du la 
        inn feil informasjon eller skrivefeil i loggmeldingen, kan du 
        enkelt forandre verdien i <literal>svn:log</literal>-egenskapen 
        med en ny, rettet loggmelding.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.backends">
      <!-- @ENGLISH {{{
      <title>Repository Data Stores</title>
      @ENGLISH }}} -->
      <title>Datalagring i depotet</title>

      <!-- @ENGLISH {{{
      <para>As of Subversion 1.1, there are two options for storing
        data in a Subversion repository.  One type of repository
        stores everything in a Berkeley DB database; the other kind
        stores data in ordinary flat files, using a custom
        format.  Because Subversion developers often refer to a
        repository as <quote>the (versioned) filesystem</quote>, they have
        adopted the habit of referring to the latter type of repository as
        <firstterm>FSFS</firstterm>
        <footnote>
          <para>Pronounced <quote>fuzz-fuzz</quote>, if Jack
            Repenning has anything to say about it.</para>
        </footnote>
        &mdash;a versioned
        filesystem implementation that uses the native OS filesystem
        to store data.</para>
      @ENGLISH }}} -->
      <para>I Subversion 1.1 er det to valg for å lagre data i et 
        Subversiondepot.
        En depottype lagrer alt i en Berkeley DB-database; den andre 
        typen lagrer data som ordinære <quote>flate filer</quote> i et 
        tilpasset format.
        Fordi Subversionutviklere ofte referer til et depot som 
        <quote>det (versjonerte) filsystemet</quote>, har de lagt seg 
        til vanen med å refere til den sistnevnte typen depot som 
        <firstterm>FSFS</firstterm><footnote>
          <para>Uttales <quote>fuzz-fuzz</quote>, hvis Jack Repenning 
            har noe å si angående det.</para>
        </footnote> – en versjonert filsystemimplementasjon som bruker 
        det vanlige filsystemet til operativsystemet for å lagre 
        data.</para>

      <!-- @ENGLISH {{{
      <para>When a repository is created, an administrator must decide
        whether it will use Berkeley DB or FSFS.  There are advantages
        and disadvantages to each, which we'll describe in a bit.
        Neither back-end is more <quote>official</quote> than another,
        and programs which access the repository are insulated from
        this implementation detail.  Programs have no idea how a
        repository is storing data; they only see revision and
        transaction trees through the repository API.</para>
      @ENGLISH }}} -->
      <para>Når et depot er opprettet, må administratoren bestemme om 
        Berkeley DB eller FSFS skal brukes.
        Det er fordeler og ulemper med begge to, som vi vil gå gjennom 
        ganske snart.
        Ingen av de bakenforliggende depotene er mer 
        <quote>offisielle</quote> enn andre, og programmer som 
        aksesserer depotet er beskyttet fra denne 
        implementasjonsdetaljen.
        Programmer har ingen formening om hvordan depotet lagrer data; 
        de ser bare revisjons- og transaksjonstrær gjennom 
        depotgrensesnittet.</para>

      <!-- @ENGLISH {{{
      <para><xref linkend="svn.reposadmin.basics.backends.tbl-1"/>
        gives a comparative overview of Berkeley DB and FSFS
        repositories.  The next sections go into detail.</para>
      @ENGLISH }}} -->
      <para><xref linkend="svn.reposadmin.basics.backends.tbl-1"/> 
        inneholder en tabell som gir en oversikt over forskjellene 
        mellom depoter av typen Berkeley DB og FSFS.
        De neste seksjonene går inn i detalj.</para>

      <table id="svn.reposadmin.basics.backends.tbl-1">
        <!-- @ENGLISH {{{
        <title>Repository Data Store Comparison</title>
        @ENGLISH }}} -->
        <title>Sammenligning av datalagring i depoter</title>
        <tgroup cols="3">
          <thead>
            <row>
              <!-- @ENGLISH {{{
              <entry>Feature</entry>
              <entry>Berkeley DB</entry>
              <entry>FSFS</entry>
              @ENGLISH }}} -->
              <entry>Funksjonalitet</entry>
              <entry>Berkeley DB</entry>
              <entry>FSFS</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <!-- @ENGLISH {{{
              <entry>Sensitivity to interruptions</entry>
              @ENGLISH }}} -->
              <entry>Følsom for avbrytelser</entry>
              
              <!-- @ENGLISH {{{
              <entry>very;  crashes and permission problems can leave the
                database <quote>wedged</quote>, requiring journaled
                recovery procedures.</entry>
              @ENGLISH }}} -->
              <entry>veldig;
              krasj og problemer med rettigheter kan etterlate databasen 
              i en <quote>fastkilt</quote> (Engelsk: 
              <foreignphrase>wedged</foreignphrase>) tilstand som krever 
              journalførte gjenopprettingsprosedyrer.</entry>
              
              <!-- @ENGLISH {{{
              <entry>quite insensitive.</entry>
              @ENGLISH }}} -->
              <entry>ganske ufølsom.</entry>
            </row>
            
            <row>
              <!-- @ENGLISH {{{
              <entry>Usable from a read-only mount</entry>
              
              <entry>no</entry>
              
              <entry>yes</entry>
              @ENGLISH }}} -->
              <entry>Kan brukes fra et ikke-skrivbart medium</entry>

              <entry>nei</entry>

              <entry>ja</entry>
            </row>
            
            <row>
              <!-- @ENGLISH {{{
              <entry>Platform-independent storage</entry>
              
              <entry>no</entry>
              
              <entry>yes</entry>
              @ENGLISH }}} -->
              <entry>Plattformuavhengig lagring</entry>

              <entry>nei</entry>

              <entry>ja</entry>
            </row>
            
            <row>
              <!-- @ENGLISH {{{
              <entry>Usable over network filesystems</entry>
              
              <entry>no</entry>
              
              <entry>yes</entry>
              @ENGLISH }}} -->
              <entry>Brukbar over nettverksfilsystem</entry>

              <entry>nei</entry>

              <entry>ja</entry>
            </row>
            
            <row>
              <!-- @ENGLISH {{{
              <entry>Repository size</entry>
              
              <entry>slightly larger</entry>
              
              <entry>slightly smaller</entry>
              @ENGLISH }}} -->
              <entry>Depotstørrelse</entry>

              <entry>litt større</entry>

              <entry>litt mindre</entry>
            </row>

            <row>
              <!-- @ENGLISH {{{
              <entry>Scalability: number of revision trees</entry>
              
              <entry>database;  no problems</entry>
              
              <entry>some older native filesystems don't scale well with
                thousands of entries in a single directory.</entry>
              @ENGLISH }}} -->
              <entry>Skalerbarhet:
                Antall revisjonstrær</entry>

              <entry>database; ingen problemer</entry>

              <entry>ytelsen på noen eldre filsystemer blir dårligere 
                med tusenvis av elementer i en katalog.</entry>
            </row>

            <row>
              <!-- @ENGLISH {{{
              <entry>Scalability: directories with many files</entry>
              
              <entry>slower</entry>
              
              <entry>faster</entry>
              @ENGLISH }}} -->
              <entry>Skalerbarhet:
                Kataloger med mange filer</entry>

              <entry>langsommere</entry>

              <entry>raskere</entry>
            </row>
                        
            <row>
              <!-- @ENGLISH {{{
              <entry>Speed:  checking out latest code</entry>
              
              <entry>faster</entry>
              
              <entry>slower</entry>
              @ENGLISH }}} -->
              <entry>Hastighet:
                Uthenting av nyeste kode</entry>

              <entry>raskere</entry>

              <entry>langsommere</entry>
            </row>
            
            <row>
              <!-- @ENGLISH {{{
              <entry>Speed:  large commits</entry>
              
              <entry>slower, but work is spread throughout commit</entry>
              
              <entry>faster, but finalization delay may cause client
                timeouts</entry>
              @ENGLISH }}} -->
              <entry>Hastighet:
                Store innlegginger</entry>

              <entry>langsommere, men arbeidet blir spredt ut over 
                innleggingen</entry>

              <entry>raskere, men forsinkelse i avslutningen kan 
                forårsake tidsavbrudd for klienten.</entry>
            </row>
            
            <row>
              <!-- @ENGLISH {{{
              <entry>Group permissions handling</entry>
              
              <entry>sensitive to user umask problems;  best if accessed
                by only one user.</entry>
              
              <entry>works around umask problems</entry>
              @ENGLISH }}} -->
              <entry>Behandling av grupperettigheter</entry>

              <entry>følsom for problemer med umask; det beste er om den 
                blir aksessert av bare en bruker.</entry>

              <entry>jobber seg rundt problemer med umask</entry>
            </row>

            <row>
              <!-- @ENGLISH {{{
              <entry>Code maturity</entry>
              
              <entry>in use since 2001</entry>
              
              <entry>in use since 2004</entry>
              @ENGLISH }}} -->
              <entry><!-- ¤ -->Kodemodenhet</entry>

              <entry>i bruk siden 2001</entry>

              <entry>i bruk siden 2004</entry>
            </row>

          </tbody>
        </tgroup>      
      </table>
      
      <sect3 id="svn.reposadmin.basics.backends.bdb">
        <title>Berkeley DB</title>
        
        <!-- @ENGLISH {{{
        <para>When the initial design phase of Subversion was in
          progress, the developers decided to use Berkeley DB for a
          variety of reasons, including its open-source license,
          transaction support, reliability, performance, API
          simplicity, thread-safety, support for cursors, and so
          on.</para>
        @ENGLISH }}} -->
        <para>I den innledende designfasen av Subversion bestemte 
          utviklerne seg for å bruke Berkeley DB av diverse grunner, 
          blant annet dens åpne lisens, transaksjonsstøtte, stabilitet, 
          effektivitet, enkelt grensesnitt, trådsikkerhet, støtte for 
          <!-- ¤ -->databasepekere og så videre.</para>

        <!-- @ENGLISH {{{
        <para>Berkeley DB provides real transaction
          support&mdash;perhaps its most powerful feature.  Multiple
          processes accessing your Subversion repositories don't have
          to worry about accidentally clobbering each other's data.
          The isolation provided by the transaction system is such
          that for any given operation, the Subversion repository code
          sees a static view of the database&mdash;not a database that
          is constantly changing at the hand of some other
          process&mdash;and can make decisions based on that view.  If
          the decision made happens to conflict with what another
          process is doing, the entire operation is rolled back as if
          it never happened, and Subversion gracefully retries the
          operation against a new, updated (and yet still static) view
          of the database.</para>
        @ENGLISH }}} -->
        <para>Berkeley DB tilbyr reell støtte for transaksjoner – 
          kanskje dens kraftigste funksjonalitet.
          Flere prosesser som aksesserer Subversiondepotene dine trenger 
          ikke å tenke på faren ved å rote til hverandres data.
          Isolasjonen som transaksjonssystemet tilbyr er slik at for 
          enhver operasjon ser Subversions depotkode et statisk bilde av 
          en database – ikke en database som konstant forandres av en 
          annen prosess – og kan foreta avgjørelser basert på dette 
          bildet.
          Hvis avgjørelsen kommer i konflikt med det en annen prosess 
          gjør, blir hele operasjonen rullet tilbake som om den aldri 
          skjedde, og Subversion prøver <!-- ¤ -->forsiktig operasjonen  
          mot et nytt, oppdatert (og fortsatt statisk) bilde av 
          databasen.</para>

        <!-- @ENGLISH {{{
        <para>Another great feature of Berkeley DB is <firstterm>hot
          backups</firstterm>&mdash;the ability to backup the database
          environment without taking it <quote>offline</quote>.  We'll
          discuss how to backup your repository in <xref
          linkend="svn.reposadmin.maint.backup"/>, but the benefits of being
          able to make fully functional copies of your repositories
          without any downtime should be obvious.</para>
        @ENGLISH }}} -->
        <para>En annen fin funksjonalitet med Berkeley DB er 
          <firstterm>varme backuper</firstterm> (<foreignphrase>hot 
          backups</foreignphrase>) – muligeten til å ta sikkerhetskopi 
          av databasen uten å ta den ned.
          Vi vil diskutere hvordan du tar backup av depotet i <xref 
          linkend="svn.reposadmin.maint.backup"/>, men fordelene med å 
          kunne ta fullstendige fungerende kopier av depotene dine uten 
          nedetid er innlysende.</para>

        <!-- @ENGLISH {{{
        <para>Berkeley DB is also a very reliable database system.
          Subversion uses Berkeley DB's logging facilities, which
          means that the database first writes to on-disk log files a
          description of any modifications it is about to make, and
          then makes the modification itself.  This is to ensure that
          if anything goes wrong, the database system can back up to
          a previous <firstterm>checkpoint</firstterm>&mdash;a
          location in the log files known not to be corrupt&mdash;and
          replay transactions until the data is restored to a usable
          state.  See <xref linkend="svn.reposadmin.maint.diskspace"/> for more
          about Berkeley DB log files.</para>
        @ENGLISH }}} -->
        <para>Berkeley DB er også et veldig sikkert databasesystem.
          Subversion bruker Berkeley DBs loggefasiliteter, som betyr at 
          databasen først lager en beskrivelse i loggfiler på disken om 
          hva den er i ferd med å gjøre, og foretar deretter selve 
          modifiseringen.
          Dette er for å forsikre seg om at i tilfelle noe går galt, kan 
          databasesystemet hente tilbake et tidligere 
          <firstterm>sjekkpunkt</firstterm> – en posisjon i loggfilene 
          som den vet ikke er ødelagt – og <quote>spille av</quote> 
          transaksjoner inntil dataene er gjenopprettet til en 
          fungerende tilstand. Se <xref 
          linkend="svn.reposadmin.maint.diskspace"/> for mer angående 
          loggfilene i Berkeley DB.</para>

        <!-- @ENGLISH {{{
        <para>But every rose has its thorn, and so we must note some
          known limitations of Berkeley DB.  First, Berkeley DB
          environments are not portable.  You cannot simply copy a
          Subversion repository that was created on a Unix system onto
          a Windows system and expect it to work.  While much of the
          Berkeley DB database format is architecture independent,
          there are other aspects of the environment that are not.
          Secondly, Subversion uses Berkeley DB in a way that will not
          operate on Windows 95/98 systems&mdash;if you need to house
          a repository on a Windows machine, stick with Windows 2000
          or Windows XP.  Also, you should never keep a Berkeley DB
          repository on a network share.  While Berkeley DB promises
          to behave correctly on network shares that meet a particular
          set of specifications, almost no known shares actually meet
          all those specifications.</para>
        @ENGLISH }}} -->
        <para>Men alle roser har torner, og derfor må vi være klar over 
          noen kjente begrensninger i Berkeley DB.
          For det første er ikke Berkeley DB-miljøer portable.
          Du kan ikke bare kopiere et Subversiondepot som er laget på et 
          UNIX-system til et Windows-system og forvente at det skal 
          virke.
          Selv om mye av Berkely DB-formatet er arkitekturuavhengig, er 
          det andre aspekter med miljøet som ikke er det.
          For det andre bruker Subersion Berkeley DB på en måte som ikke 
          vil fungere i Windows 95/98 – hvis du må ha depotet på en 
          Windowsmaskin, bruk Windows 2000 eller Windows XP.
          Legg heller aldri et Berkeley DB-depot på en nettverksdisk.
          Selv om Berkeley DB lover å oppføre seg korrekt på 
          nettverksdisker som oppfyller spesielle kriterier, er det 
          nesten ingen kjente nettverksdelinger som faktisk oppfyller 
          alle disse spesifikasjonene.</para>

        <!-- @ENGLISH {{{
        <para>Finally, because Berkeley DB is a library linked
          directly into Subversion, it's more sensitive to
          interruptions than a typical relational database system.
          Most SQL systems, for example, have a dedicated server
          process that mediates all access to tables.  If a program
          accessing the database crashes for some reason, the database
          daemon notices the lost connection and cleans up any mess
          left behind.  And because the database daemon is the only
          process accessing the tables, applications don't need to
          worry about permission conflicts.  These things are not the
          case with Berkeley DB, however.  Subversion (and programs
          using Subversion libraries) access the database tables
          directly, which means that a program crash can leave the
          database in a temporarily inconsistent, inaccessible state.
          When this happens, an administrator needs to ask Berkeley DB
          to restore to a checkpoint, which is a bit of an annoyance.
          Other things can cause a repository to <quote>wedge</quote>
          besides crashed processes, such as programs conflicting over
          ownership and permissions on the database files.  So while a
          Berkeley DB repository is quite fast and scalable, it's best
          used by a single server process running as one
          user&mdash;such as Apache's <command>httpd</command> or
          <command>svnserve</command> (see <xref
          linkend="svn.serverconfig"/>)&mdash;rather than accessing it as
          many different users via <literal>file:///</literal> or
          <literal>svn+ssh://</literal> URLs.  If using a Berkeley DB
          repository directly as multiple users, be sure to read <xref
          linkend="svn.serverconfig.multimethod"/>.</para>
        @ENGLISH }}} -->
        <para>Til sist, fordi Berkeley DB er et bibliotek linket direkte 
          inn i Subversion, er det mer sensibelt for avbrudd enn et 
          typisk relasjonsdatabesestystem.
          De fleste SQL-systemer har for eksempel en dedisert 
          &server;prosess som fordeler all tilgang til tabeller.
          Hvis et program som aksesserer databasen krasjer av en eller 
          annen grunn, oppdager daemonen som styrer databasen at 
          forbindelsen er brutt og ordner opp i eventuelt rot som blir 
          liggende igjen.
          Og fordi databasedaemonen er den eneste prosessen som 
          aksesserer tabellene, trenger ikke applikasjoner å tenke på 
          rettighetskonflikter.
          Disse tingene er imidlertid ikke tilfelle med Berkeley DB.
          Subversion (og programmer som bruker Subversionbiblioteker) 
          aksesserer databasetabellene direkte, noe som betyr at et 
          programkrasj kan etterlate databasen i en midlertidig, 
          utilgjengelig tilstand.
          Når dette skjer, må en administrator be Berkeley DB om 
          gjenoppretting til et sjekkpunkt, noe som er litt plagsomt.
          Andre ting kan føre til at et depot <quote>kiler seg 
          fast</quote> 
          (<quote><foreignphrase>wedge</foreignphrase></quote>) sammen 
          med krasjede prosesser, som for eksempel programmer som kommer 
          i konflikt angående eierskap og tilgang til databasefilene.
          Så mens et Berkeley DB-depot er ganske raskt og skalerbart, 
          fungerer det best når det kun blir brukt av én enkelt 
          &server;prosess som kjører som én bruker – som for eksempel 
          Apaches <command>httpd</command> eller 
          <command>svnserve</command> (se <xref 
          linkend="svn.serverconfig"/>) – istedenfor å aksessere det med 
          mange forskjellige brukere via <literal>file:///</literal> 
          eller <literal>svn+ssh://</literal>-URLer.
          Hvis et Berkeley DB-depot blir brukt direkte med flere 
          forskjellige brukere, pass på at du har lest <xref 
          linkend="svn.serverconfig.multimethod"/>.</para>

      </sect3>
      
      <sect3 id="svn.reposadmin.basics.backends.fsfs">
        <title>FSFS</title>

        <!-- @ENGLISH {{{
        <para>In mid-2004, a second type of repository storage system
          came into being: one which doesn't use a database at all.
          An FSFS repository stores a revision tree in a single file,
          and so all of a repository's revisions can be found in a
          single subdirectory full of numbered files.  Transactions
          are created in separate subdirectories.  When complete, a
          single transaction file is created and moved to the
          revisions directory, thus guaranteeing that commits are
          atomic.  And because a revision file is permanent and
          unchanging, the repository also can be backed up while
          <quote>hot</quote>, just like a Berkeley DB repository.</para>
        @ENGLISH }}} -->
        <para>I midten av 2004 ble et nytt lagringsformat for depotet 
          laget, et som ikke bruker en database i det hele tatt.
          Et FSFS-depot lagrer et revisjonstre i en enkelt fil, og alle 
          depotets revisjoner kan dermed finnes i en enkelt underkatalog 
          full av nummererte filer.
          Transaksjoner blir opprettet i separate underkataloger.
          Når den er komplett, blir en enkelt transaksjonsfil opprettet 
          og flyttet til revisjonskatalogen og garanterer dermed at 
          innleggingen blir atomisk.
          Og fordi en revisjonsfil er permanent og uforanderlig, kan 
          depotet også bli tatt backup av mens det er i bruk, akkurat 
          som et Berkeley DB-depot.</para>

        <!-- @ENGLISH {{{
        <para>The revision-file format represents a revision's
          directory structure, file contents, and deltas against files
          in other revision trees.  Unlike a Berkeley DB database,
          this storage format is portable across different operating
          systems and isn't sensitive to CPU architecture.  Because
          there's no journaling or shared-memory files being used, the
          repository can be safely accessed over a network filesystem
          and examined in a read-only environment.  The lack of
          database overhead also means that the overall repository
          size is a bit smaller.</para>
        @ENGLISH }}} -->
        <para>Revisjonsfilformatet representerer en revisjons 
          katalogstruktur, filinnhold og forskjeller i forhold til filer 
          i andre revisjonstrær.
          Ulikt en Berkeley DB-database, er dette lagringsformatet 
          portabelt mellom forskjellige operativsystemer og er ikke 
          sensitiv ovenfor CPU-arkitektur.
          Fordi det ikke blir brukt journalfiler eller filer som bruker 
          delt hukommelse, kan depotet trygt aksesseres via et 
          nettverksfilsystem og bli utforsket i et skrivebeskyttet 
          miljø.
          Mangelen på databaseoverhead betyr også at den samlede 
          depotstørrelsen blir en del mindre.</para>

        <!-- @ENGLISH {{{
        <para>FSFS has different performance characteristics too.
          When committing a directory with a huge number of files, FSFS
          uses an O(N) algorithm to append entries, while Berkeley DB
          uses an O(N^2) algorithm to rewrite the whole directory.  On
          the other hand, FSFS writes the latest version of a file as
          a delta against an earlier version, which means that
          checking out the latest tree is a bit slower than fetching
          the fulltexts stored in a Berkeley DB HEAD revision.  FSFS
          also has a longer delay when finalizing a commit, which
          could in extreme cases cause clients to time out when
          waiting for a response.</para>
        @ENGLISH }}} -->
        <para>FSFS har også forskjellige ytelseskarakteristikker.
          Når en katalog med mange filer legges inn, bruker FSFS en 
          O(N)-algoritme for å legge til poster, mens Berkeley DB bruker 
          en O(N^2)-algoritme for å skrive hele katalogen en gang til.
          På den annen side skriver FSFS den seneste versjonen av en fil 
          som en delta (forskjell) mot en tidligere versjon, noe som 
          betyr at det å hente ut det seneste treet er litt langsommere 
          enn å hente fullteksten lagret i en HEAD-revisjon i Berkeley 
          DB.
          FSFS har også en lengre forsinkelse når en innlegging skal 
          fullføres, noe som i ekstreme tilfeller kan føre til at 
          klienter får et tidsavbrudd under venting på respons.</para>

        <!-- @ENGLISH {{{
        <para>The most important distinction, however, is FSFS's
          inability to be <quote>wedged</quote> when something goes
          wrong.  If a process using a Berkeley DB database runs into
          a permissions problem or suddenly crashes, the database is
          left unusable until an administrator recovers it.  If the
          same scenarios happen to a process using an FSFS repository,
          the repository isn't affected at all.  At worst, some
          transaction data is left behind.</para>
        @ENGLISH }}} -->
        <para>Men den viktigste forskjellen er FSFSs evne til å ikke bli 
          <quote>fastkilt</quote> hvis noe går galt.
          Hvis en prosess som bruker en Berkeley DB-database får 
          problemer med rettigheter eller plutselig krasjer, er ikke 
          databasen brukbar før en administrator gjenoppretter den.
          Hvis det samme skjer med en prosess som bruker et FSFS-depot, 
          blir ikke depotet påvirket i det hele tatt.
          I verste fall blir bare noen transaksjonsdata liggende 
          igjen.</para>

        <!-- @ENGLISH {{{
        <para>The only real argument against FSFS is its relative
          immaturity compared to Berkeley DB.  It hasn't been used or
          stress-tested nearly as much, and so a lot of these
          assertions about speed and scalability are just that:
          assertions, based on good guesses.  In theory, it promises a
          lower barrier to entry for new administrators and is less
          susceptible to problems.  In practice, only time will
          tell.</para>
        @ENGLISH }}} -->
        <para>Det eneste virkelige argumentet mot FSFS er fartstiden det 
          har hatt i forhold til Berkeley DB.
          Det er ikke like mye brukt og har ikke blitt stresstestet like 
          mye, så derfor er mange av disse antakelsene om hastighet og 
          skalerbarhet nettopp det:
          Antakelser, basert på gode gjetninger.
          I teorien lover den en lavere barriere å forsere for nye 
          administratorer og er forventet å skape mindre problemer.
          I praksis vil bare tiden vise om dette stemmer.</para>

      </sect3>
    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.create">
    <!-- @ENGLISH {{{
    <title>Repository Creation and Configuration</title>
    @ENGLISH }}} -->
    <title>Opprettelse og konfigurering av depotet</title>

    <!-- @ENGLISH {{{
    <para>Creating a Subversion repository is an incredibly simple
      task.  The <command>svnadmin</command> utility, provided with
      Subversion, has a subcommand for doing just that.  To create a
      new repository, just run:</para>
    @ENGLISH }}} -->
    <para>Det å opprette et Subversiondepot er en utrolig enkel oppgave.
      <command>svnadmin</command>-verktøyet som følger med Subversion 
      har en delkommando som gjør akkurat det.
      For å opprette et nytt depot, er det bare å kjøre:</para>
          
    <!-- @ENGLISH {{{
    <screen>
$ svnadmin create /path/to/repos
</screen>
    @ENGLISH }}} -->
    <screen>
$ svnadmin create /sti/til/depot
</screen>
          
    <!-- @ENGLISH {{{
    <para>This creates a new repository in the directory
      <filename>/path/to/repos</filename>.  This new repository begins
      life at revision 0, which is defined to consist of nothing but
      the top-level root (<filename>/</filename>) filesystem
      directory.  Initially, revision 0 also has a single revision
      property, <literal>svn:date</literal>, set to the time at which
      the repository was created.</para>
    @ENGLISH }}} -->
    <para>Dette oppretter et nytt depot i katalogen 
      <filename>/sti/til/depot</filename>.
      Dette nye depotet starter livet ved revisjon 0, som er definert 
      til å bare innholde en rot på toppnivå (<filename>/</filename>) i 
      filsystemet.
      Revisjon 0 har også en enkelt revisjonsegenskap satt 
      innledningsvis, <literal>svn:date</literal>, som er satt til 
      tidspunktet depotet ble opprettet.</para>

    <!-- @ENGLISH {{{
    <para>In Subversion 1.2, a repository is created with an FSFS
      back-end by default (see <xref
      linkend="svn.reposadmin.basics.backends"/>).  The back-end can
      be explicitly chosen with the <option>-&#64738;-fs-type</option>
      argument:</para>
    @ENGLISH }}} -->
    <para>I Subversion 1.2 blir et depot opprettet i FSFS-formatet som 
      standard (se <xref linkend="svn.reposadmin.basics.backends"/>).
      Formatet kan bli eksplisitt valgt med 
      <option>--fs-type</option>-valget:</para>

    <!-- @ENGLISH {{{
    <screen>
$ svnadmin create -&#64738;-fs-type fsfs /path/to/repos
$ svnadmin create -&#64738;-fs-type bdb /path/to/other/repos
</screen>
    @ENGLISH }}} -->
    <screen>
$ svnadmin create --fs-type fsfs /sti/til/depot
$ svnadmin create --fs-type bdb /sti/til/annet/depot
</screen>


    <warning>
      <!-- @ENGLISH {{{
      <para>Do not create a Berkeley DB repository on a network
        share&mdash;it <emphasis>cannot</emphasis> exist on a remote
        filesystem such as NFS, AFS, or Windows SMB.  Berkeley DB
        requires that the underlying filesystem implement strict POSIX
        locking semantics, and more importantly, the ability to map
        files directly into process memory.  Almost no network
        filesystems provide these features.  If you attempt to use
        Berkeley DB on a network share, the results are
        unpredictable&mdash;you may see mysterious errors right away,
        or it may be months before you discover that your repository
        database is subtly corrupted.</para>
      @ENGLISH }}} -->
      <para>Opprett ikke et Berkeley DB-depot på en nettverksdisk – det 
        <emphasis>kan ikke</emphasis> eksistere på et fjerntliggende 
        filsystem som NFS, AFS eller Windows SMB.
        Berkeley DB krever at det underliggende filsystemet har 
        implementert streng POSIX låsesemantikk, og enda viktigere, 
        muligheten til å mappe filer direkte inn i prosesshukommelsen.
        Nesten ingen nettverksfilsystemer tilbyr disse mulighetene.
        Hvis du forsøker å bruke Berkeley DB på en nettverksdisk, er 
        resultatene uforutsigelige – du kan se mystiske feilmeldinger 
        med en gang, eller det kan gå månedsvis før du oppdager at 
        depotet i all stillhet blir herpa.</para>

      <!-- @ENGLISH {{{
      <para>If you need multiple computers to access the repository,
        you create an FSFS repository on the network share, not a
        Berkeley DB repository.  Or better yet, set up a real server
        process (such as Apache or <command>svnserve</command>), store
        the repository on a local filesystem which the server can
        access, and make the repository available over a network.
        <xref linkend="svn.serverconfig"/> covers this process in
        detail.</para>
      @ENGLISH }}} -->
      <para>Hvis du trenger flere datamaskiner for å aksessere depotet, 
        lager du et FSFS-depot på nettverksdisken, ikke et Berkeley 
        DB-depot.
        Eller enda bedre, sett opp en skikkelig &server;prosess (som for 
        eksempel Apache eller <command>svnserve</command>), legg depotet 
        i et lokalt filsystem som &the_server; kan aksessere og gjør 
        depotet tilgjengelig over et nettverk. <xref 
        linkend="svn.serverconfig"/> dekker denne prosessen i 
        detalj.</para>
    </warning>
          
    <!-- @ENGLISH {{{
    <para>You may have noticed that the path argument to
      <command>svnadmin</command> was just a regular filesystem path
      and not a URL like the <command>svn</command> client program
      uses when referring to repositories.  Both
      <command>svnadmin</command> and <command>svnlook</command> are
      considered server-side utilities&mdash;they are used on the
      machine where the repository resides to examine or modify
      aspects of the repository, and are in fact unable to perform
      tasks across a network.  A common mistake made by Subversion
      newcomers is trying to pass URLs (even <quote>local</quote>
      <literal>file:</literal> ones) to these two programs.</para>
    @ENGLISH }}} -->
    <para>Du har kanskje lagt merke til at stiargumentet til 
      <command>svnadmin</command> bare var en vanlig filsystemsti og 
      ikke en URL lik det <command>svn</command>-klienten bruker når den 
      refererer til depot.
      Både <command>svnadmin</command> og <command>svnlook</command> 
      ansees som &server;side-verktøy – de blir brukt på maskinen hvor 
      depotet ligger for å undersøke og modifisere aspekter ved depotet, 
      og er faktisk ikke i stand til å utføre oppgaver over nettverket.
      En vanlig feil som blir gjort av nybakte Subversionbrukere er å gi 
      URLer (til og med av typene <quote>local</quote> og 
      <literal>file:</literal>) til disse to programmene.</para>

    <!-- @ENGLISH {{{
    <para>So, after you've run the <command>svnadmin create</command>
      command, you have a shiny new Subversion repository in its own
      directory.  Let's take a peek at what is actually created inside
      that subdirectory.</para>
    @ENGLISH }}} -->
    <para>Så, etter at du har kjørt <command>svnadmin 
      create</command>-kommandoen, har du et skinnende nytt depot i sin 
      egen katalog.
      La oss ta en kikk på hva som egentlig er laget i denne 
      katalogen.</para>
            
    <!-- @ENGLISH {{{
    <screen>
$ ls repos
conf/  dav/  db/  format  hooks/  locks/  README.txt
</screen>
    @ENGLISH }}} -->
    <screen>
$ ls depot
conf/  dav/  db/  format  hooks/  locks/  README.txt
</screen>
      
    <!-- @ENGLISH {{{
    <para>With the exception of the <filename>README.txt</filename> and
      <filename>format</filename> files,
      the repository directory is a collection of subdirectories.  As
      in other areas of the Subversion design, modularity is given
      high regard, and hierarchical organization is preferred to
      cluttered chaos.  Here is a brief description of all of
      the items you see in your new repository directory:</para>
    @ENGLISH }}} -->
    <para>Med unntak av filene <filename>README.txt</filename> og 
      <filename>format</filename>, er depotkatalogen en samling av 
      underkataloger.
      Som i andre områder av Subversion-designet er modularitet gitt 
      stor oppmerksomhet, og hierarkisk organisering er foretrukket 
      framfor <!-- cluttered -->rotete kaos.
      Her er en rask beskrivelse av alle elementene som du ser i den nye 
      depotkatalogen:</para>

    <variablelist>
      <varlistentry>
        <term>conf</term>
        <listitem>
          <!-- @ENGLISH {{{
          <para>A directory containing repository configuration files.</para>
          @ENGLISH }}} -->
          <para>En katalog som inneholder konfigurasjonsfiler for 
            depotet.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>dav</term>
        <listitem>
          <!-- @ENGLISH {{{
          <para>A directory provided to Apache and mod_dav_svn for
            their private housekeeping data.</para>
          @ENGLISH }}} -->
          <para>En katalog der Apache og mod_dav_svn lagrer sine 
            husholdningsdata.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>db</term>
        <listitem>
          <!-- @ENGLISH {{{
          <para>Where all of your versioned data resides.  This
            directory is either a Berkeley DB environment (full of DB
            tables and other things), or is an FSFS environment
            containing revision files.</para>
          @ENGLISH }}} -->
          <para>Der alle dine versjonerte data ligger.
            Denne katalogen er enten et Berkeley DB-miljø (full av 
            databasetabeller og andre ting) eller et FSFS-miljø som 
            inneholder revisjonsfiler.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>format</term>
        <listitem>
          <!-- @ENGLISH {{{
          <para>A file whose contents are a single integer value that
            dictates the version number of the repository layout.</para>
          @ENGLISH }}} -->
          <para>En fil som inneholder en enkelt heltallsverdi som 
            spesifiserer versjonsnummeret til depotlayouten.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>hooks</term>
        <listitem>
          <!-- @ENGLISH {{{
          <para>A directory full of hook script templates (and hook
            scripts themselves, once you've installed some).</para>
          @ENGLISH }}} -->
          <para>En katalog full av maler for påhakningsskript (Engelsk: 
            <foreignphrase>hooks</foreignphrase>) og påhakningsskriptene 
            selv, når du har installert noen.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>locks</term>
        <listitem>
          <!-- @ENGLISH {{{
          <para>A directory for Subversion's repository locking
            data, used for tracking accessors to the repository.</para>
          @ENGLISH }}} -->
          <para>En katalog for Subversions låsedata, brukt for å følge 
            <!-- ¤ -->tilganger til depotet.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>README.txt</term>
        <listitem>
          <!-- @ENGLISH {{{
          <para>A file which merely informs its readers that they
            are looking at a Subversion repository.</para>
          @ENGLISH }}} -->
          <para>En fil som bare informerer sine lesere om at de ser på 
            et Subversiondepot.</para>
        </listitem>
      </varlistentry>
    </variablelist>
      
    <!-- @ENGLISH {{{
    <para>In general, you shouldn't tamper with your repository
      <quote>by hand</quote>.  The <command>svnadmin</command> tool
      should be sufficient for any changes necessary to your
      repository, or you can look to third-party tools (such as
      Berkeley DB's tool suite) for tweaking relevant subsections of
      the repository.  Some exceptions exist, though, and we'll cover
      those here.</para>
    @ENGLISH }}} -->
    <para>Generelt sett skal du ikke fikle med depotet <quote>for 
      hånd</quote>.
      <command>svnadmin</command>-verktøyet skal være nok til alle 
      nødvendige forandringer i depotet, eller du kan se på tredjeparts 
      verktøy (som Berkeley DBs verktøysamling) for å finpusse relevante 
      delseksjoner av depotet.
      Noen unntak gjelder imidlertid, og disse skal vi gå gjennom 
      her.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.create.hooks">
      <!-- @ENGLISH {{{
      <title>Hook Scripts</title>
      @ENGLISH }}} -->
      <title>Påhakningsskript</title>

      <!-- @ENGLISH {{{
      <para>A <firstterm>hook</firstterm> is a program triggered by
        some repository event, such as the creation of a new revision
        or the modification of an unversioned property.  Each hook is
        handed enough information to tell what that event is, what
        target(s) it's operating on, and the username of the person
        who triggered the event.  Depending on the hook's output or
        return status, the hook program may continue the action, stop
        it, or suspend it in some way.</para>
      @ENGLISH }}} -->
      <para>Et <!-- ¤ --><firstterm>påhakningsskript</firstterm> (på 
        engelsk kalt <foreignphrase>hooks</foreignphrase>) er et program 
        som blir utløst av en hendelse i depotet, som for eksempel 
        opprettelsen av en ny revisjon eller modifiseringen av en 
        uversjonert egenskap.
        Hver påhakning blir gitt nok informasjon til å fortelle hva 
        denne hendelsen er, hvilke mål den opererer på, og brukernavnet 
        til personen som satte i gang hendelsen.
        Avhengig av påhakningens utdata eller returstatus, kan 
        påhakningsprogrammet fortsette hendelsen, stoppe den, eller 
        utsette den på en eller annen måte.</para>
            
      <!-- @ENGLISH {{{
      <para>The <filename>hooks</filename> subdirectory is, by
        default, filled with templates for various repository
        hooks.</para>
      @ENGLISH }}} -->
      <para><filename>hooks</filename>-katalogen er, som standard, fylt 
        med maler for diverse depotpåhakninger.</para>
            
      <!-- @ENGLISH {{{
      <screen>
$ ls repos/hooks/
post-commit.tmpl          post-unlock.tmpl          pre-revprop-change.tmpl
post-lock.tmpl            pre-commit.tmpl           pre-unlock.tmpl
post-revprop-change.tmpl  pre-lock.tmpl             start-commit.tmpl
</screen>
      @ENGLISH }}} -->
      <screen>
$ ls depot/hooks/
post-commit.tmpl          post-unlock.tmpl          pre-revprop-change.tmpl
post-lock.tmpl            pre-commit.tmpl           pre-unlock.tmpl
post-revprop-change.tmpl  pre-lock.tmpl             start-commit.tmpl
</screen>
            
      <!-- @ENGLISH {{{
      <para>There is one template for each hook that the Subversion
        repository implements, and by examining the contents of those
        template scripts, you can see what triggers each such script
        to run and what data is passed to that script.  Also present
        in many of these templates are examples of how one might use
        that script, in conjunction with other Subversion-supplied
        programs, to perform common useful tasks.  To actually install
        a working hook, you need only place some executable program or
        script into the <filename>repos/hooks</filename> directory
        which can be executed as the name (like
        <command>start-commit</command> or
        <command>post-commit</command>) of the hook.</para>
      @ENGLISH }}} -->
      <para>Det er en mal for hver påhakning som Subversiondepotet 
        implementerer, og ved å undersøke innholdet til disse 
        eksempelskriptene, kan du se hva som fører til at hvert av disse 
        skriptene begynner å kjøre og hvilke data som blir levert til 
        dette skriptet.
        Det som også ligger i mange av disse malene er eksempler på 
        hvordan man kan bruke skriptet i sammenheng med andre programmer 
        som følger med Subversion for å utføre vanlige, nyttige 
        oppgaver.
        For å faktisk installere en påhakning som virker, trenger du 
        bare å plassere et kjørbart program eller skript i 
        <filename>depot/hooks</filename>-katalogen som kan bli kjørt 
        basert på navnet (som for eksempel 
        <command>start-commit</command> eller 
        <command>post-commit</command>) til påhakningen.</para>

      <!-- @ENGLISH {{{
      <para>On Unix platforms, this means supplying a script or
        program (which could be a shell script, a Python program, a
        compiled C binary, or any number of other things) named
        exactly like the name of the hook.  Of course, the template
        files are present for more than just informational
        purposes&mdash;the easiest way to install a hook on Unix
        platforms is to simply copy the appropriate template file to a
        new file that lacks the <literal>.tmpl</literal> extension,
        customize the hook's contents, and ensure that the script is
        executable.  Windows, however, uses file extensions to
        determine whether or not a program is executable, so you would
        need to supply a program whose basename is the name of the
        hook, and whose extension is one of the special extensions
        recognized by Windows for executable programs, such as
        <filename>.exe</filename> or <filename>.com</filename> for
        programs, and <filename>.bat</filename> for batch
        files.</para>
      @ENGLISH }}} -->
      <para>På Unix-plattformer betyr dette å legge inn et skript eller 
        program (som kan være et <!-- ¤ -->shellskript, et 
        Pythonprogram, et kompilert C-program, eller hva som helst 
        annet) som heter akkurat det samme som påhakningen.
        Selvfølgelig, malfilene er der for mer enn bare 
        informasjonsverdien – den letteste måten å installere en 
        påhakning på Unixplattformer er å bare kopiere den riktige 
        malfilen til en ny fil som mangler 
        <literal>.tmpl</literal>-etternavnet, finpusse på innholdet, og 
        forsikre deg om at skriptet er kjørbart.
        Men Windows bruker filetternavn til å avgjøre hvorvidt et 
        program er kjørbart eller ikke, så da må du legge inn et program 
        der hovednavnet er navnet på påhakningen, og der etternavnet er 
        en av de spesielle etternavnene som Windows kjenner igjen som 
        kjørbare, for eksempel <filename>.exe</filename> eller 
        <filename>.com</filename> for programmer, og 
        <filename>.bat</filename> for batchfiler.</para>

      <tip>
        <!-- @ENGLISH {{{
        <para>For security reasons, the Subversion repository executes
        hook scripts with an empty environment&mdash;that is, no
        environment variables are set at all, not even
        <literal>$PATH</literal> or <literal>%PATH%</literal>.
        Because of this, a lot of administrators are baffled when
        their hook script runs fine by hand, but doesn't work when run
        by Subversion.  Be sure to explicitly set environment
        variables in your hook and/or use absolute paths to
        programs.</para>
        @ENGLISH }}} -->
        <para>Av sikkerhetsgrunner kjører Subversion påhakningsskript 
          med et tomt miljø (environment) – det betyr, ingen 
          miljøvariabler er satt i det hele tatt, ikke engang 
          <literal>$PATH</literal> eller <literal>%PATH%</literal>.
          På grunn av dette blir mange adminstratorer forvirret når 
          påhakningsskriptet kjører fint for hånd, men virker ikke når 
          det blir kjørt av Subversion.
          Pass på å eksplisitt sette variabler i skriptet og/eller bruk 
          absolutte stier til programmer.</para>
      </tip>

      <!-- @ENGLISH {{{
      <para>There are nine hooks implemented by the Subversion
        repository:</para>
      @ENGLISH }}} -->
      <para>Det er lagt inn ni påhakninger i Subversiondepotet:</para>

      <variablelist>
        <varlistentry>
          <term><filename>start-commit</filename></term>
          <listitem>
            <!-- @ENGLISH {{{
            <para>This is run before the commit transaction is even
              created.  It is typically used to decide if the user has
              commit privileges at all.  The repository passes two
              arguments to this program: the path to the repository,
              and username which is attempting the commit.  If the
              program returns a non-zero exit value, the commit is
              stopped before the transaction is even created.  If the
              hook program writes data to stderr, it will be
              marshalled back to the client.</para>
            @ENGLISH }}} -->
            <para>Denne blir kjørt allerede før innleggingstransaksjonen 
              er opprettet.
              Det blir vanligvis brukt til å avgjøre om brukeren har 
              innleggingsprivilegier i det hele tatt.
              Depotet leverer to argumenter til dette programmet:
              Stien til depotet, og brukernavnet som forsøker seg på 
              innleggingen.
              Hvis programmet returnerer en verdi som ikke er null, blir 
              denne innleggingen stoppet allerede før transaksjonen blir 
              laget.
              Hvis påhakningen skriver data til standardfeil, vil det 
              bli <!-- ¤ marshalled -->sendt tilbake til 
              klienten.</para>
          </listitem>
        </varlistentry>
            
        <varlistentry>
          <term><filename>pre-commit</filename></term>
          <listitem>
            <!-- @ENGLISH {{{
            <para>This is run when the transaction is complete, but
              before it is committed.  Typically, this hook is used to
              protect against commits that are disallowed due to
              content or location (for example, your site might
              require that all commits to a certain branch include a
              ticket number from the bug tracker, or that the incoming
              log message is non-empty).  The repository passes two
              arguments to this program: the path to the repository,
              and the name of the transaction being committed.  If the
              program returns a non-zero exit value, the commit is
              aborted and the transaction is removed.  If the hook
              program writes data to stderr, it will be marshalled
              back to the client.</para>
            @ENGLISH }}} -->
            <para>Dette blir kjørt når transaksjonen er komplett, men 
              før den er lagt inn.
              Vanligvis blir denne påhakningen brukt til å beskytte mot 
              innlegginger som er forbudt på grunn av innhold eller 
              beliggenhet (for eksempel kan <!-- ¤ site -->&the_server; 
              kreve at alle innlegginger til en spesiell gren inneholder 
              et billettnummer fra feildatabasen, eller at den 
              innkommende loggmeldingen ikke er tom).
              Depotet leverer to argumenter til dette programmet:
              Stien til depotet, og navnet på transaksjonen som legges 
              inn.
              Hvis programmet returnerer en verdi som ikke er null, 
              avbrytes innleggingen og transaksjonen blir fjernet.
              Hvis programmet skriver data til stderr, vil dette bli 
              <!-- marshalled -->sendt tilbake til klienten.</para>

            <!-- @ENGLISH {{{
            <para>The Subversion distribution includes some access
              control scripts (located in the
              <filename>tools/hook-scripts</filename> directory of the
              Subversion source tree) that can be called from
              <command>pre-commit</command> to implement fine-grained
              write-access control.  Another option is to use the
              <command>mod_authz_svn</command> Apache httpd module,
              which provides both read and write access control on
              individual directories (see <xref
              linkend="svn.serverconfig.httpd.authz.perdir"/>).  In a future version
              of Subversion, we plan to implement access control lists
              (ACLs) directly in the filesystem.</para>
            @ENGLISH }}} -->
            <para>Subversiondistribusjonen inneholder noen 
              aksesskontrollskript (i 
              <filename>tools/hook-scripts</filename>-katalogen i 
              kildekodefiltreet til Subversion) som kan bli kalt fra 
              <command>pre-commit</command> for å kunne legge inn 
              finjustert kontroll for skriveaksess.
              En annen mulighet er å bruke Apache-modulen 
              <command>mod_authz_svn</command> som gir både lese- og 
              skrivekontroll i individuelle kataloger (se <xref 
              linkend="svn.serverconfig.httpd.authz.perdir"/>).
              I en framtidig versjon av Subversion planlegger vi å legge 
              inn lister for aksesskontroll (ACL) direkte inn i 
              filsystemet.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><filename>post-commit</filename></term>
          <listitem>
            <!-- @ENGLISH {{{
            <para>This is run after the transaction is committed, and
              a new revision is created.  Most people use this hook to
              send out descriptive emails about the commit or to make
              a backup of the repository.  The repository passes two
              arguments to this program: the path to the repository,
              and the new revision number that was created.  The exit
              code of the program is ignored.</para>
            @ENGLISH }}} -->
            <para>Dette blir kjørt etter at transaksjonen er lagt inn, 
              og en ny revisjon er opprettet.
              De fleste vil bruke denne påhakningen til å sende ut 
              beskrivende eposter om innleggingen eller for å ta backup 
              av depotet.
              Depotet gir to argumenter til dette programmet:
              Stien til depotet, og det nye revisjonsnummeret som ble 
              opprettet.
              Returverdien fra programmet blir ignorert.</para>
                
            <!-- @ENGLISH {{{
            <para>The Subversion distribution includes
              <command>mailer.py</command> and
              <command>commit-email.pl</command> scripts (located in
              the <filename>tools/hook-scripts/</filename> directory
              of the Subversion source tree) that can be used to send
              email with (and/or append to a log file) a description
              of a given commit.  This mail contains a list of the
              paths that were changed, the log message attached to the
              commit, the author and date of the commit, as well as a
              GNU diff-style display of the changes made to the
              various versioned files as part of the commit.</para>
            @ENGLISH }}} -->
            <para>Subversiondistribusjonen inneholder skriptene
              <command>mailer.py</command> og 
              <command>commit-email.pl</command> (i 
              <filename>tools/hook-scripts/</filename>-katalogen i 
              Subversiontreet) som kan bli brukt til å sende epost med 
              (og/eller legge til en loggfil) en beskrivelse av en 
              mottatt innlegging.
              Denne mailen inneholder en liste over de stiene som ble 
              forandret, loggmeldingen som er vedlagt innleggingen, 
              forfatteren og datoen til innleggingen, sammen med en GNU 
              diff-visning av forandringene som ble gjort til diverse 
              filer som del av innleggingen.</para>

            <!-- @ENGLISH {{{
            <para>Another useful tool provided by Subversion is the
              <command>hot-backup.py</command> script (located in the
              <filename>tools/backup/</filename> directory of the
              Subversion source tree).  This script performs hot
              backups of your Subversion repository (a feature
              supported by the Berkeley DB database back-end), and can
              be used to make a per-commit snapshot of your repository
              for archival or emergency recovery purposes.</para>
            @ENGLISH }}} -->
            <para>Et annet nyttig verktøy som følger med Subversion er 
              skriptet <command>hot-backup.py</command> (i 
              <filename>tools/backup/</filename>-katalogen i 
              kildekodetreet til Subversion).
              Dette skriptet tar <quote>varme</quote> backuper av 
              Subversiondepotet (en funksjonalitet støttet av den 
              bakenforliggende Berkeley DB-databasen), og kan bli brukt 
              til å foreta en øyeblikkslagring av depotet mellom hver 
              innlegging for arkiverings- eller sikkerhetsformål.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><filename>pre-revprop-change</filename></term>
          <listitem>
            <!-- @ENGLISH {{{
            <para>Because Subversion's revision properties are not
              versioned, making modifications to such a property (for
              example, the <literal>svn:log</literal> commit message
              property) will overwrite the previous value of that
              property forever.  Since data can be potentially lost
              here, Subversion supplies this hook (and its
              counterpart, <filename>post-revprop-change</filename>)
              so that repository administrators can keep records of
              changes to these items using some external means if
              they so desire.  As a precaution against losing
              unversioned property data, Subversion clients will not
              be allowed to remotely modify revision properties at all
              unless this hook is implemented for your repository.</para>
            @ENGLISH }}} -->
            <para>Fordi Subversions revisjonsegenskaper ikke er 
              versjonerte, vil det å forandre slike egenskaper (for 
              eksempel <literal>svn:log</literal>-egenskapen som 
              inneholder loggmeldingen for innleggingen) overskrive den 
              forrige verdien for alltid.
              Siden data kan gå tapt her, har Subversion denne 
              påhakningen (og dens <!-- ¤ -->motstykke 
              <filename>post-revprop-change</filename>) så 
              depotadministratorer kan lage logger med forandringer i 
              disse elementene ved bruk av eksterne hjelpemidler hvis de 
              vil det.
              Som en forholdsregel mot å miste uversjonerte data, vil 
              ikke Subversionklienter få lov til å forandre 
              revisjonsegenskaper i det hele tatt hvis ikke denne 
              påhakningen er aktivisert i depotet ditt.</para>

            <!-- @ENGLISH {{{
            <para>This hook runs just before such a modification is
              made to the repository.  The repository passes four
              arguments to this hook: the path to the repository, the
              revision on which the to-be-modified property exists, the
              authenticated username of the person making the change,
              and the name of the property itself.</para>
            @ENGLISH }}} -->
            <para>Denne påhakningen kjører like før en slik modifisering 
              blir lagt inn i depotet.
              Depotet leverer fire argumenter til denne påhakningen:
              Stien til depotet, revisjonen som egenskapen som skal 
              forandres befinner seg på, det autentiserte brukernavnet 
              til personen som gjør forandringen, og navnet på selve 
              egenskapen.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><filename>post-revprop-change</filename></term>
          <listitem>
            <!-- @ENGLISH {{{
            <para>As mentioned earlier, this hook is the counterpart
              of the <filename>pre-revprop-change</filename> hook.  In
              fact, for the sake of paranoia this script will not run
              unless the <filename>pre-revprop-change</filename> hook
              exists.  When both of these hooks are present, the
              <filename>post-revprop-change</filename> hook runs just
              after a revision property has been changed, and is
              typically used to send an email containing the new value
              of the changed property.  The repository passes four
              arguments to this hook: the path to the repository, the
              revision on which the property exists, the authenticated
              username of the person making the change, and the name of
              the property itself.</para>
            @ENGLISH }}} -->
            <para>Som nevnt tidligere, er denne påhakningen motstykket 
              til <filename>pre-revprop-change</filename>-påhakningen.
              For paranoiaens skyld vil faktisk ikke dette skriptet 
              kjøre uten at 
              <filename>pre-revprop-change</filename>-skriptet finnes.
              Når begge disse skriptene finnes, kjører 
              <filename>post-revprop-change</filename>-påhakningen like 
              etter at en revisjonsegenskap er blitt forandret, og blir 
              vanligvis brukt til å sende en epost som inneholder den 
              nye verdien til den forandrede egenskapen.
              Depotet leverer fire argumenter til denne påhakningen:
              Stien til depotet, revisjonen som egenskapen tilhører, det 
              godkjente brukernavnet til personen som gjør forandringen, 
              og navnet på selve egenskapen.</para>

            <!-- @ENGLISH {{{
            <para>The Subversion distribution includes a
              <command>propchange-email.pl</command> script (located
              in the <filename>tools/hook-scripts/</filename>
              directory of the Subversion source tree) that can be
              used to send email with (and/or append to a log file)
              the details of a revision property change.  This mail
              contains the revision and name of the changed property,
              the user who made the change, and the new property
              value.</para>
            @ENGLISH }}} -->
            <para>Subversiondistribusjonen inkluderer skriptet 
              <command>propchange-email.pl</command> (i 
              <filename>tools/hook-scripts/</filename>-katalogen i 
              Subversions kildekodetre) som kan bli brukt til å sende 
              epost med (og/eller legge til en loggfil) detaljene om en 
              egenskapsforandring.
              Denne eposten inneholder revisjonen og navnet til den 
              forandrede egenskapen, brukeren som gjorde forandringen, 
              og den nye verdien til egenskapen.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><filename>pre-lock</filename></term>
          <listitem>
            <!-- @ENGLISH {{{
            <para>This hook runs whenever someone attempts to lock a
              file.  It can be used to prevent locks altogether, or to
              create a more complex policy specifying exactly which
              users are allowed to lock particular paths.  If the hook
              notices a pre-existing lock, then it can also decide
              whether a user is allowed to <quote>steal</quote> the
              existing lock.  The repository passes three arguments to
              the hook: the path to the repository, the path being
              locked, and the user attempting to perform the lock.  If
              the program returns a non-zero exit value, the lock
              action is aborted and anything printed to stderr is
              marshalled back to the client.</para>
            @ENGLISH }}} -->
            <para>Denne påhakningen kjøres hver gang noen prøver å låse 
              en fil.
              Den kan bli brukt til å forby låser i det hele tatt, eller 
              å definere et mer komplekst regelsett som spesifiserer 
              nøyaktig hvilke brukere som får lov til å låse spesielle 
              stier.
              Hvis påhakningen finner en allerede eksisterende lås, kan 
              den også bestemme om en bruker har lov til å 
              <quote>stjele</quote> den eksisterende låsen.
              Depotet leverer tre argumenter til påhakningen:
              Stien til depotet, stien som blir låst, og navnet på 
              brukeren som prøver å utføre låsingen.
              Hvis programmet returnerer en verdi som ikke er null, blir 
              låseprosessen avbrutt og alt som blir skrevet til standard 
              feil blir sendt tilbake til klienten.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><filename>post-lock</filename></term>
          <listitem>
            <!-- @ENGLISH {{{
            <para>This hook runs after a path is locked.  The locked
              path is passed to the hook's stdin, and the hook also
              receives two arguments:  the path to the repository, and
              the user who performed the lock.  The hook is then free
              to send email notification or record the event in any
              way it chooses.  Because the lock already happened, the
              output of the hook is ignored.</para>
            @ENGLISH }}} -->
            <para>Denne påhakningen kjører etter at en sti er låst.
              Den låste stien sendes til påhakningens standard inn, og 
              påhakningen mottar også to argumenter:
              Stien til depotet og brukeren som utførte låsingen.
              Skriptet kan dermed sende melding via epost eller logge 
              hendelsen på den måten som er bestemt.
              Fordi låsingen allerede har skjedd, blir utdataene fra 
              påhakningen ignorert.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><filename>pre-unlock</filename></term>
          <listitem>
            <!-- @ENGLISH {{{
            <para>This hook runs whenever someone attempts to remove a
              lock on a file.  It can be used to create policies that
              specify which users are allowed to unlock particular
              paths.  It's particularly important for determining
              policies about lock breakage.  If user A locks a file,
              is user B allowed to break the lock?  What if the lock
              is more than a week old?  These sorts of things can be
              decided and enforced by the hook.  The repository passes
              three arguments to the hook: the path to the repository,
              the path being unlocked, and the user attempting to
              remove the lock.  If the program returns a non-zero exit
              value, the unlock action is aborted and anything printed
              to stderr is marshalled back to the client.</para>
            @ENGLISH }}} -->
            <para>Denne påhakningen kjøres når noen prøver å fjerne en 
              lås på en fil.
              Den kan brukes til å lage regler som spesifiserer hvilke 
              brukere som har lov til å låse opp spesielle stier.
              Den er spesielt viktig for å avgjøre regler om bryting av 
              låser.
              Hvis bruker A låser en fil, får bruker B lov til å bryte 
              låsen?
              Hva hvis låsen er mer enn en uke gammel?
              Denne typen ting kan bli bestemt og gjennomført av 
              påhakningen.
              Depotet leverer tre argumenter til påhakningen:
              Stien til depotet, stien som låses opp, og navnet på 
              brukeren som prøver å fjerne låsen.
              Hvis programmet returnerer en verdi som ikke er null, blir 
              opplåsingsprosessen avbrutt og alt som blir skrevet til 
              standardfeil leveres til klienten.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><filename>post-unlock</filename></term>
          <listitem>
            <!-- @ENGLISH {{{
            <para>This hook runs after a path is unlocked.  The
              unlocked path is passed to the hook's stdin, and the
              hook also receives two arguments: the path to the
              repository, and the user who removed the lock.  The hook
              is then free to send email notification or record the
              event in any way it chooses.  Because the lock removal
              already happened, the output of the hook is
              ignored.</para>
            @ENGLISH }}} -->
            <para>Denne påhakningen kjøres etter at en sti er låst opp.
              Stien som er låst opp sendes til skriptets standard inn, 
              og det mottar også to argumenter:
              Stien til depotet og brukeren som fjernet låsen.
              Påhakningen kan dermed sende epost eller logge hendelsen 
              på den måten som er valgt.
              Fordi fjerningen av låsen allerede har skjedd, blir 
              utdataene fra påhakningen ignorert.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <warning>
        <!-- @ENGLISH {{{
        <para>Do not attempt to modify the transaction using hook
          scripts.  A common example of this would be to automatically
          set properties such as <literal>svn:eol-style</literal> or
          <literal>svn:mime-type</literal> during the commit.  While
          this might seem like a good idea, it causes problems.  The
          main problem is that the client does not know about the
          change made by the hook script, and there is no way to
          inform the client that it is out-of-date.  This
          inconsistency can lead to surprising and unexpected
          behavior.</para>
        @ENGLISH }}} -->
        <para>Ikke forsøk å forandre transaksjonen ved å bruke 
          påhakningsskript.
          Et vanlig eksempel på dette ville være å automatisk sette 
          egenskaper som <literal>svn:eol-style</literal> eller 
          <literal>svn:mime-type</literal> under innleggingen.
          Selv om dette kan se ut som en god idé, fører det til 
          problemer.
          Hovedproblemet er at klienten ikke vet om forandringen gjort 
          av påhakningsscriptet, og det er ingen måte å informere 
          klienten om at den er utdatert.
          Denne inkonsekventheten kan føre til overraskende og uventet 
          oppførsel.</para>

        <!-- @ENGLISH {{{
        <para>Instead of attempting to modify the transaction, it is
          much better to <emphasis>check</emphasis> the transaction in
          the <filename>pre-commit</filename> hook and reject the
          commit if it does not meet the desired requirements.</para>
        @ENGLISH }}} -->
        <para>Istedenfor å forsøke å modifisere transaksjonen, er det 
          mye bedre å <emphasis>sjekke</emphasis> transaksjonen i 
          <filename>pre-commit</filename> og nekte innlegging hvis den 
          ikke møter de ønskede kravene.</para>
      </warning>

      <!-- @ENGLISH {{{
      <para>Subversion will attempt to execute hooks as the same user
        who owns the process which is accessing the Subversion
        repository.  In most cases, the repository is being accessed
        via Apache HTTP server and mod_dav_svn, so this user is the
        same user that Apache runs as.  The hooks themselves will need
        to be configured with OS-level permissions that allow that
        user to execute them.  Also, this means that any file or
        programs (including the Subversion repository itself) accessed
        directly or indirectly by the hook will be accessed as the
        same user.  In other words, be alert to potential
        permission-related problems that could prevent the hook from
        performing the tasks you've written it to perform.</para>
      @ENGLISH }}} -->
      <para>Subversion vil forsøke å kjøre påhakningsskriptene som den 
        samme brukeren som eier prosessen som aksesserer 
        Subversiondepotet.
        I de fleste tilfeller blir depotet aksessert via Apache 
        HTTP-&the_server; og mod_dav_svn, så denne brukeren er den samme 
        som Apache kjører som.
        Selve påhakningene må bli satt opp med rettigheter på 
        operativsystemnivå som tillater denne brukeren å kjøre dem.
        Dette betyr også at enhver fil eller program (inkludert selve 
        Subversiondepotet) aksessert direkte eller indirekte av 
        påhakningen vil bli aksessert som den samme brukeren.
        Med andre ord, vær obs på mulig rettighetsproblematikk som kan 
        forhindre påhakningsskriptet fra å utføre de oppgavene du har 
        satt det til.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.create.bdb">
      <!-- @ENGLISH {{{
      <title>Berkeley DB Configuration</title>
      @ENGLISH }}} -->
      <title>Konfigurasjon av Berkeley DB</title>

      <!-- @ENGLISH {{{
      <para>A Berkeley DB environment is an encapsulation of one or
        more databases, log files, region files and configuration
        files.  The Berkeley DB environment has its own set of default
        configuration values for things like the number of locks
        allowed to be taken out at any given time, or the maximum size
        of the journaling log files, etc.  Subversion's filesystem
        code additionally chooses default values for some of the
        Berkeley DB configuration options.  However, sometimes your
        particular repository, with its unique collection of data and
        access patterns, might require a different set of
        configuration option values.</para>
      @ENGLISH }}} -->
      <para>Et Berkeley DB-miljø er en innkapsling av en eller flere 
        databaser, loggfiler, regionfiler og konfigurasjonsfiler.
        Berkeley DB-miljøet har sitt eget sett med konfigurasjonsverdier 
        for ting som antallet låser som er tillatt brukt på en gang, 
        maksimal størrelse på journalloggfiler og så videre.
        Subversions filsystemkode velger i tillegg standardverdier for 
        noen av konfigurasjonsvalgene i Berkeley DB.</para>

      <!-- @ENGLISH {{{
      <para>The folks at Sleepycat (the producers of Berkeley DB)
        understand that different databases have different
        requirements, and so they have provided a mechanism for
        overriding at runtime many of the configuration values for the
        Berkeley DB environment.  Berkeley checks for the presence of
        a file named <filename>DB_CONFIG</filename> in each
        environment directory, and parses the options found in that
        file for use with that particular Berkeley environment.</para>
      @ENGLISH }}} -->
      <para>Folkene i Sleepycat (produsentene av Berkeley DB) innser at 
        forskjellige databaser har forskjellige krav, og de har derfor 
        lagt inn en mekanisme for å overstyre mange av 
        konfigurasjonsverdiene til Berkeley DB under kjøring.
        Berkeley sjekker at filen <filename>DB_CONFIG</filename> finnes 
        i hver miljøkatalog, og leser valgene som er i denne filen for 
        bruk med akkurat dette Berkeley-miljøet.</para>

      <!-- @ENGLISH {{{
      <para>The Berkeley configuration file for your repository is
        located in the <filename>db</filename> environment directory,
        at <filename>repos/db/DB_CONFIG</filename>.  Subversion itself
        creates this file when it creates the rest of the repository.
        The file initially contains some default options, as well as
        pointers to the Berkeley DB online documentation so you can
        read about what those options do.  Of course, you are free to
        add any of the supported Berkeley DB options to your
        <filename>DB_CONFIG</filename> file.  Just be aware that while
        Subversion never attempts to read or interpret the contents of
        the file, and makes no use of the option settings in it,
        you'll want to avoid any configuration changes that may cause
        Berkeley DB to behave in a fashion that is unexpected by the
        rest of the Subversion code.  Also, changes made to
        <filename>DB_CONFIG</filename> won't take effect until you
        recover the database environment (using <command>svnadmin
        recover</command>).</para>
      @ENGLISH }}} -->
      <para>Berkeley-konfigurasjonsfilen for ditt depot ligger i 
        miljøkatalogen <filename>db</filename> i 
        <filename>depot/db/DB_CONFIG</filename>.
        Subversion oppretter selv denne filen når den lager resten av 
        depotet.
        Filen inneholder innledningsvis noen standardvalg sammen med 
        pekere til dokumentasjonen til Berkeley DB som ligger på nettet 
        så du kan lese om hva disse valgene gjør.
        Du har selvfølgelig også muligheten til å legge til alle valg 
        som Berkeley DB støtter til 
        <filename>DB_CONFIG</filename>-filen.
        Pass bare på at mens Subversion aldri prøver å lese eller forstå 
        innholdet i filen og bruker ingen av valgene i den, vil du unngå 
        å gjøre forandringer i konfigurasjonen som får Berkeley DB seg 
        til å oppføre seg annerledes enn det Subversionkoden forventer.
        I tillegg vil ikke forandringer gjort i 
        <filename>DB_CONFIG</filename> aktiviseres før du gjenoppretter 
        databasemiljøet (ved bruk av <command>svnadmin 
        recover</command>).</para>
    </sect2>
  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.maint">
    <!-- @ENGLISH {{{
    <title>Repository Maintenance</title>
    @ENGLISH }}} -->
    <title>Vedlikehold av depotet</title>

    <!-- @ENGLISH {{{
    <para>Maintaining a Subversion repository can be a daunting task,
      mostly due to the complexities inherent in systems which have a
      database backend.  Doing the task well is all about knowing the
      tools&mdash;what they are, when to use them, and how to use
      them.  This section will introduce you to the repository
      administration tools provided by Subversion, and how to wield
      them to accomplish tasks such as repository migrations,
      upgrades, backups and cleanups.</para>
    @ENGLISH }}} -->
    <para>Å vedlikeholde et Subversiondepot kan være en skremmende 
      oppgave, mest på grunn av kompleksiteten som er innebygget i 
      systemer med en <!-- ¤ Er det noe som heter det? Det høres 
      ihvertfall norskt ut. -->bakenforliggende database.
      Å utføre oppgaven godt handler om å kjenne verktøyene – hva de er, 
      når de skal brukes, og hvordan de brukes.
      Denne seksjonen vil introdusere deg for administrasjonsverktøy som 
      følger med Subversion, og hvordan få dem til å utføre oppgaver som 
      flytting av depot, oppgraderinger, sikkerhetskopiering og 
      opprydding.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.tk">
      <!-- @ENGLISH {{{
      <title>An Administrator's Toolkit</title>
      @ENGLISH }}} -->
      <title>En administrators verktøykasse</title>

      <!-- @ENGLISH {{{
      <para>Subversion provides a handful of utilities useful for
        creating, inspecting, modifying and repairing your repository.
        Let's look more closely at each of those tools.  Afterward,
        we'll briefly examine some of the utilities included in the
        Berkeley DB distribution that provide functionality specific
        to your repository's database backend not otherwise provided
        by Subversion's own tools.</para>
      @ENGLISH }}} -->
      <para>Subversion har en håndfull programmer som er nyttige til å 
        opprette, inspisere, modifisere og reparere depotet ditt.
        La oss se litt nærmere på hvert av disse verktøyene.
        Etterpå vil vi gå raskt over noen av de programmene som er 
        inkludert i Berkeley DB-distribusjonen som tilbyr funksjonalitet 
        spesifikk til databasedelen i depotet som ikke Subversions egne 
        verktøy tar seg av.</para>

      <sect3 id="svn.reposadmin.maint.tk.svnlook">
        <title>svnlook</title>
            
        <!-- @ENGLISH {{{
        <para><command>svnlook</command> is a tool provided by
          Subversion for examining the various revisions and
          transactions in a repository.  No part of this program
          attempts to change the repository&mdash;it's a
          <quote>read-only</quote> tool.  <command>svnlook</command>
          is typically used by the repository hooks for reporting the
          changes that are about to be committed (in the case of the
          <command>pre-commit</command> hook) or that were just
          committed (in the case of the <command>post-commit</command>
          hook) to the repository.  A repository administrator may use
          this tool for diagnostic purposes.</para>
        @ENGLISH }}} -->
        <para><command>svnlook</command> er et verktøy som følger med 
          Subversion.
          Det er beregnet for å utforske de forskjellige revisjonene og 
          transaksjonene i et depot.
          Ingen deler av dette programmet prøver å forandre depotet – 
          det er et <quote>bare lese</quote>-verktøy.
          <command>svnlook</command> blir vanligvis brukt av 
          påhakningsskriptene i depotet for å rapportere forandringene 
          som er i ferd med å bli lagt inn (i tilfellet med 
          <command>pre-commit</command>-påhakningen) eller det som 
          nettopp ble lagt inn (i tilfellet med 
          <command>post-commit</command>-påhakningen) i depotet.
          En depotadministrator kan bruke dette verktøyet for 
          diagnoseformål.</para>
            
        <!-- @ENGLISH {{{
        <para><command>svnlook</command> has a straightforward
          syntax:</para>
        @ENGLISH }}} -->
        <para><command>svnlook</command> har en <!-- ¤ -->likefrem 
          syntaks:</para>
            
        <!-- ¤ Legg inn norsk versjon -->
        <screen>
$ svnlook help
general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]
Note: any subcommand which takes the '--revision' and '--transaction'
      options will, if invoked without one of those options, act on
      the repository's youngest revision.
Type "svnlook help &lt;subcommand&gt;" for help on a specific subcommand.
&hellip;
</screen>

        <!-- @ENGLISH {{{
        <para>Nearly every one of <command>svnlook</command>'s
          subcommands can operate on either a revision or a
          transaction tree, printing information about the tree
          itself, or how it differs from the previous revision of the
          repository.  You use the <option>-&#64738;-revision</option> and
          <option>-&#64738;-transaction</option> options to specify which
          revision or transaction, respectively, to examine.  Note
          that while revision numbers appear as natural numbers,
          transaction names are alphanumeric strings.  Keep in mind
          that the filesystem only allows browsing of uncommitted
          transactions (transactions that have not resulted in a new
          revision).  Most repositories will have no such
          transactions, because transactions are usually either
          committed (which disqualifies them from viewing) or aborted
          and removed.</para>
        @ENGLISH }}} -->
        <para>Nesten hver eneste av delkommandoene til 
          <command>svnlook</command> kan operere på enten et revisjons- 
          eller transaksjonstre og skrive ut informasjon om selve treet 
          eller hvordan det skiller seg ut fra den forrige revisjonen i 
          depotet.
          Du bruker valgene <option>--revision</option> og 
          <option>--transaction</option> for å spesifisere henholdsvis 
          hvilken revisjon eller transaksjon som skal undersøkes.
          Legg merke til at mens revisjonsnumre fremstår som naturlige 
          tall, er transaksjonsnavn alfanumeriske strenger.
          Husk at filsystemet bare tillater gjennomgang av transaksjoner 
          som enda ikke er lagt inn (transaksjoner som ikke har 
          resultert i en ny revisjon).
          De fleste depot vil ikke ha noen slike transaksjoner, fordi 
          transaksjoner vanligvis enten er lagt inn (som diskvalifiserer 
          dem fra visning) eller avbrutt og fjernet.</para>

        <!-- @ENGLISH {{{
        <para>In the absence of both the <option>-&#64738;-revision</option>
          and <option>-&#64738;-transaction</option> options,
          <command>svnlook</command> will examine the youngest (or
          <quote>HEAD</quote>) revision in the repository.  So the
          following two commands do exactly the same thing when 19 is
          the youngest revision in the repository located at
          <filename>/path/to/repos</filename>:</para>
        @ENGLISH }}} -->
        <para>Hvis både valgene <option>--revision</option> og 
          <option>--transaction</option> mangler, vil 
          <command>svnlook</command> undersøke den yngste (eller 
          <quote>HEAD</quote>) revisjonen i depotet.
          Så de følgende to kommandoene gjør akkurat det samme når 19 er 
          den yngste revisjonen i depotet som ligger i 
          <filename>/sti/til/depot</filename>:</para>

        <!-- @ENGLISH {{{
        <screen>
$ svnlook info /path/to/repos
$ svnlook info /path/to/repos -&#64738;-revision 19
</screen>
        @ENGLISH }}} -->
        <screen>
$ svnlook info /sti/til/depot
$ svnlook info /sti/til/depot --revision 19
</screen>

        <!-- @ENGLISH {{{
        <para>The only exception to these rules about subcommands is
          the <command>svnlook youngest</command> subcommand, which
          takes no options, and simply prints out the
          <literal>HEAD</literal> revision number.</para>
        @ENGLISH }}} -->
        <para>Det eneste unntaket fra disse reglene om delkommandoer er 
          <command>svnlook youngest</command>-delkommandoen, som ikke 
          tar noen valg, og bare skriver ut nummeret for 
          <literal>HEAD</literal>-revisjonen.</para>

        <!-- @ENGLISH {{{
        <screen>
$ svnlook youngest /path/to/repos
19
</screen>
        @ENGLISH }}} -->
        <screen>
$ svnlook youngest /sti/til/depot
19
</screen>
            
        <!-- @ENGLISH {{{
        <para>Output from <command>svnlook</command> is designed to be
          both human- and machine-parsable.  Take as an example the output
          of the <literal>info</literal> subcommand:</para>
        @ENGLISH }}} -->
        <para>Utdataene fra <command>svnlook</command> er designet for å 
          være lesbare både for menneske og maskin.
          Som et eksempel kan vi ta utdataene fra delkommandoen 
          <literal>info</literal>:</para>

        <!-- @ENGLISH {{{
        <screen>
$ svnlook info /path/to/repos
sally
2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)
27
Added the usual
Greek tree.
</screen>
        @ENGLISH }}} -->
        <screen>
$ svnlook info /sti/til/depot
sally
2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)
27
La til det vanlige
greske treet.
</screen>

        <!-- @ENGLISH {{{
        <para>The output of the <literal>info</literal> subcommand is
          defined as:</para>
        @ENGLISH }}} -->
        <para>Utdataene fra <literal>info</literal>-delkommandoen er 
          definert som:</para>

        <orderedlist>
          <listitem>
            <!-- @ENGLISH {{{
            <para>The author, followed by a newline.</para>
            @ENGLISH }}} -->
            <para>Forfatteren, etterfulgt av linjeslutt.</para>
          </listitem>
          <listitem>
            <!-- @ENGLISH {{{
            <para>The date, followed by a newline.</para>
            @ENGLISH }}} -->
            <para>Datoen, etterfulgt av linjeslutt.</para>
          </listitem>
          <listitem>
            <!-- @ENGLISH {{{
            <para>The number of characters in the log message,
              followed by a newline.</para>
            @ENGLISH }}} -->
            <para>Antallet tegn i loggmeldingen, etterfulgt av 
              linjeslutt.</para>
          </listitem>
          <listitem>
            <!-- @ENGLISH {{{
            <para>The log message itself, followed by a newline.</para>
            @ENGLISH }}} -->
            <para>Selve loggmeldingen, etterfulgt av linjeslutt.</para>
          </listitem>
        </orderedlist>

        <!-- @ENGLISH {{{
        <para>This output is human-readable, meaning items like the
          datestamp are displayed using a textual representation
          instead of something more obscure (such as the number of
          nanoseconds since the Tasty Freeze guy drove by).  But this
          output is also machine-parsable&mdash;because the log
          message can contain multiple lines and be unbounded in
          length, <command>svnlook</command> provides the length of
          that message before the message itself.  This allows scripts
          and other wrappers around this command to make intelligent
          decisions about the log message, such as how much memory to
          allocate for the message, or at least how many bytes to skip
          in the event that this output is not the last bit of data in
          the stream.</para>
        @ENGLISH }}} -->
        <para>Disse utdataene er leselige for det menneskelige øye, det 
          vil si at elementer som datoen blir vist som tekst istedenfor 
          noe mer obskurt (som antall nanosekunder siden <!-- ¤ Ehhh… 
          Jaja. -->isbilen kjørte forbi).
          Men disse utdataene er også lesbare for en datamaskin – fordi 
          loggmeldingen kan inneholde flere linjer og ha ubegrenset 
          lengde, skriver <command>svnlook</command> lengden på denne 
          meldingen før selve meldingen.
          Dette tillater skript og andre programmer som bruker denne 
          kommandoen å gjøre intelligente valg angående loggmeldingen, 
          som hvor mye hukommelse som skal reserveres for meldingen, 
          eller i det minste hvor mange bytes som må hoppes over når 
          disse utdataene ikke er den siste datadelen i strømmen.</para>

        <!-- @ENGLISH {{{
        <para>Another common use of <command>svnlook</command> is to
          actually view the contents of a revision or transaction
          tree.  The <command>svnlook tree</command> command displays
          the directories and files in the requested tree.  If you
          supply the <option>-&#64738;-show-ids</option> option, it will also
          show the filesystem node revision IDs for each of those
          paths (which is generally of more use to developers than to
          users).</para>
        @ENGLISH }}} -->
        <para>En annen vanlig bruk av <command>svnlook</command> er å 
          faktisk vise innholdet i et revisjons- eller transaksjonstre.
          Kommandoen <command>svnlook tree</command> viser katalogene og 
          filene i det forespurte treet.
          Hvis du angir valget <option>--show-ids</option>, vil den også 
          vise noderevisjons-ID for hver av disse stiene (som vanligvis 
          er mer nyttige for utviklere enn vanlige brukere).</para>

        <!-- @ENGLISH {{{
        <screen>
$ svnlook tree /path/to/repos -&#64738;-show-ids
/ &lt;0.0.1&gt;
 A/ &lt;2.0.1&gt;
  B/ &lt;4.0.1&gt;
   lambda &lt;5.0.1&gt;
   E/ &lt;6.0.1&gt;
    alpha &lt;7.0.1&gt;
    beta &lt;8.0.1&gt;
   F/ &lt;9.0.1&gt;
  mu &lt;3.0.1&gt;
  C/ &lt;a.0.1&gt;
  D/ &lt;b.0.1&gt;
   gamma &lt;c.0.1&gt;
   G/ &lt;d.0.1&gt;
    pi &lt;e.0.1&gt;
    rho &lt;f.0.1&gt;
    tau &lt;g.0.1&gt;
   H/ &lt;h.0.1&gt;
    chi &lt;i.0.1&gt;
    omega &lt;k.0.1&gt;
    psi &lt;j.0.1&gt;
 iota &lt;1.0.1&gt;
</screen>
        @ENGLISH }}} -->
        <screen>
$ svnlook tree /sti/til/depot --show-ids
/ &lt;0.0.1&gt;
 A/ &lt;2.0.1&gt;
  B/ &lt;4.0.1&gt;
   lambda &lt;5.0.1&gt;
   E/ &lt;6.0.1&gt;
    alpha &lt;7.0.1&gt;
    beta &lt;8.0.1&gt;
   F/ &lt;9.0.1&gt;
  mu &lt;3.0.1&gt;
  C/ &lt;a.0.1&gt;
  D/ &lt;b.0.1&gt;
   gamma &lt;c.0.1&gt;
   G/ &lt;d.0.1&gt;
    pi &lt;e.0.1&gt;
    rho &lt;f.0.1&gt;
    tau &lt;g.0.1&gt;
   H/ &lt;h.0.1&gt;
    chi &lt;i.0.1&gt;
    omega &lt;k.0.1&gt;
    psi &lt;j.0.1&gt;
 iota &lt;1.0.1&gt;
</screen>

        <!-- @ENGLISH {{{
        <para>Once you've seen the layout of directories and files in
          your tree, you can use commands like <command>svnlook
          cat</command>, <command>svnlook propget</command>, and
          <command>svnlook proplist</command> to dig into the details
          of those files and directories.</para>
        @ENGLISH }}} -->
        <para>Når du har sett på layouten for kataloger og filer i treet 
          ditt, kan du bruke kommandoer som <command>svnlook 
          cat</command>, <command>svnlook propget</command> og 
          <command>svnlook proplist</command> for å grave dypere i 
          detaljene om disse filene og katalogene.</para>

        <!-- @ENGLISH {{{
        <para><command>svnlook</command> can perform a variety of
          other queries, displaying subsets of bits of information
          we've mentioned previously, reporting which paths were
          modified in a given revision or transaction, showing textual
          and property differences made to files and directories, and
          so on.  The following is a brief description of the current
          list of subcommands accepted by <command>svnlook</command>,
          and the output of those subcommands:</para>
        @ENGLISH }}} -->
        <para><command>svnlook</command> kan utføre en rekke andre 
          forespørsler, vise <!-- ¤ -->delsett av biter av informasjon 
          som vi har nevnt tidligere, rapportere hvilke stier som ble 
          modifisert i en gitt revisjon eller transaksjon, vise tekst- 
          og egenskapsforskjeller gjort med filer og kataloger og så 
          videre.
          Det følgende er en rask beskrivelse av den nåværende listen 
          med delkommandoer som <command>svnlook</command> aksepterer, 
          og utdataene fra disse delkommandoene:</para>

        <variablelist>
          <varlistentry>
            <term><literal>author</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Print the tree's author.</para>
              @ENGLISH }}} -->
              <para>Skriv treets forfatter.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>cat</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Print the contents of a file in the tree.</para>
              @ENGLISH }}} -->
              <para>Skriv innholdet av en fil i treet.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>changed</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>List all files and directories that changed in the 
                tree.</para>
              @ENGLISH }}} -->
              <para>List alle filer og kataloger som forandret seg i 
                treet.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>date</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Print the tree's datestamp.</para>
              @ENGLISH }}} -->
              <para>Skriv dato og klokkeslett for treet.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>diff</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Print unified diffs of changed files.</para>
              @ENGLISH }}} -->
              <para>Lag <foreignphrase>unified diff</foreignphrase> 
                (patch) av forandrede filer.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>dirs-changed</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>List the directories in the tree that were
                themselves changed, or whose file children were
                changed.</para>
              @ENGLISH }}} -->
              <para>List katalogene i treet som enten selv forandret 
                seg, eller der en <!-- ¤ -->fil under den forandret 
                seg.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>history</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Display interesting points in the history of a
                versioned path (places where modifications or copies
                occurred).</para>
              @ENGLISH }}} -->
              <para>Vis interessante punkter i historien for en 
                versjonert sti (steder der modifiseringer eller 
                kopieringer skjedde).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>info</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Print the tree's author, datestamp, log message
                character count, and log message.</para>
              @ENGLISH }}} -->
              <para>Skriv treets forfatter, tidspunkt, antall tegn i 
                loggmeldingen og selve loggmeldingen.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>lock</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>If a path is locked, describe the lock attributes.</para>
              @ENGLISH }}} -->
              <para>Hvis en sti er låst, beskriv 
                låseattributtene.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>log</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Print the tree's log message.</para>
              @ENGLISH }}} -->
              <para>Vis loggmeldingen for treet.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>propget</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Print the value of a property on a path in the
                tree.</para>
              @ENGLISH }}} -->
              <para>Skriv verdien for en egenskap på en sti i 
                treet.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>proplist</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Print the names and values of properties set on paths
                in the tree.</para>
              @ENGLISH }}} -->
              <para>Skriv navnene og verdiene til egenskapene satt på 
                stier i treet.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>tree</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Print the tree listing, optionally revealing the
                filesystem node revision IDs associated with each
                path.</para>
              @ENGLISH }}} -->
              <para>Skriv en liste over treet, med valgfri visning av 
                filsystemets noderevisions-IDer som er assosiert med 
                hver sti.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>uuid</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Print the repository's UUID&mdash;
                <emphasis>U</emphasis>niversal <emphasis>U</emphasis>nique
                <emphasis>ID</emphasis>entifier.</para>
              @ENGLISH }}} -->
              <para>Skriv depotets UUID – <emphasis>U</emphasis>niversal 
                <emphasis>U</emphasis>nique
                <emphasis>ID</emphasis>entifier.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>youngest</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Print the youngest revision number.</para>
              @ENGLISH }}} -->
              <para>Skriv det yngste revisjonsnummeret.</para>
            </listitem>
          </varlistentry>
        </variablelist>

      </sect3>

      <sect3 id="svn.reposadmin.maint.tk.svnadmin">
        <title>svnadmin</title>

        <!-- @ENGLISH {{{
        <para>The <command>svnadmin</command> program is the
          repository administrator's best friend.  Besides providing
          the ability to create Subversion repositories, this program
          allows you to perform several maintenance operations on
          those repositories.  The syntax of
          <command>svnadmin</command> is similar to that of
          <command>svnlook</command>:</para>
        @ENGLISH }}} -->
        <para>Programmet <command>svnadmin</command> er 
          depotadministratorens beste venn.
          Ved siden av å gi muligheten til å opprette Subversiondepoter, 
          tillater dette programmet deg å utføre flere 
          vedlikeholdsoperasjoner på disse depotene.
          Syntaksen på <command>svnadmin</command> er lik den i 
          <command>svnlook</command>:</para>

        <!-- @ENGLISH {{{
        <screen>
$ svnadmin help
general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp; OPTIONS ...]
Type "svnadmin help &lt;subcommand&gt;" for help on a specific subcommand.

Available subcommands:
   create
   deltify
   dump
   help (?, h)
&hellip;
</screen>
        @ENGLISH }}} -->
        <!-- ¤ --><screen>
$ svnadmin help
general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp; OPTIONS ...]
Type "svnadmin help &lt;subcommand&gt;" for help on a specific subcommand.

Available subcommands:
   create
   deltify
   dump
   help (?, h)
…
</screen>

        <!-- @ENGLISH {{{
        <para>We've already mentioned <command>svnadmin</command>'s
          <literal>create</literal> subcommand (see <xref
          linkend="svn.reposadmin.create"/>).  Most of the others we will
          cover in more detail later in this chapter.  For now, let's
          just take a quick glance at what each of the available
          subcommands offers.</para>
        @ENGLISH }}} -->
        <para>Vi har allerede nevnt delkommandoen 
          <literal>create</literal> i <command>svnadmin</command> (se 
          <xref linkend="svn.reposadmin.create"/>).
          De fleste andre vil vi gå grundigere gjennom senere i dette 
          kapitlet.
          Nå nøyer vi oss med å ta en rask kikk på hva de forskjellige 
          delkommandoene tilbyr.</para>

        <variablelist>
          <varlistentry>
            <term><literal>create</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Create a new Subversion repository.</para>
              @ENGLISH }}} -->
              <para>Opprett et nytt Subversiondepot.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>deltify</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Run over a specified revision range, performing
                predecessor deltification on the paths changed in
                those revisions.  If no revisions are specified, this
                command will simply deltify the
                <literal>HEAD</literal> revision.</para>
              @ENGLISH }}} -->
              <para>Gå over et spesifisert revisjonsområde og utfør 
                forløper-deltifisering på stiene som forandret seg i 
                disse revisjonene.
                Hvis ingen revisjoner er spesifisert, vil denne 
                kommandoen rett og slett bare deltifisere 
                <literal>HEAD</literal>-revisjonen.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>dump</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Dump the contents of the repository, bounded by a
                given set of revisions, using a portable dump format.</para>
              @ENGLISH }}} -->
              <para>Dump innholdet av depotet, begrenset av et 
                spesifisert sett av revisjoner, i et portabelt 
                dumpformat.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>hotcopy</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Make a hot copy of a repository.  You can run
                this command at any time and make a safe copy of the
                repository, regardless if other processes are using
                the repository.</para>
              @ENGLISH }}} -->
              <para>Lag en <quote>varm kopi</quote> av et depot.
                Du kan kjøre denne kommandoen til enhver tid og lage en 
                trygg kopi av depotet, selv om andre prosesser bruker 
                depotet.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>list-dblogs</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>(Berkeley DB repositories only.)  List the paths
                of Berkeley DB log files associated with the
                repository.  This list includes all log
                files&mdash;those still in use by Subversion, as well
                as those no longer in use.</para>
              @ENGLISH }}} -->
              <para>(Bare Berkeley DB-depot.)
                List stiene for Berkeley DB-loggfiler assosiert med 
                depotet.
                Denne listen inkluderer alle loggfiler ― de som fortsatt 
                brukes av Subversion, sammen med de som ikke lenger er i 
                bruk.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>list-unused-dblogs</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>(Berkeley DB repositories only.)  List the paths
                of Berkeley DB log files associated with, but no
                longer used by, the repository.  You may safely remove
                these log files from the repository layout, possibly
                archiving them for use in the event that you ever need
                to perform a catastrophic recovery of the
                repository.</para>
              @ENGLISH }}} -->
              <para>(Bare Berkeley DB-depot.)
                List stiene for Berkeley DB-loggfiler assosiert med, men 
                ikke lenger brukt av depotet.
                Du kan trygt fjerne disse loggfilene fra depotet og 
                muligens arkivere dem for senere bruk i tilfelle du en 
                gang får bruk for katastrofe-gjenoppretting av 
                depotet.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>load</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Load a set of revisions into a repository from a
                stream of data that uses the same portable dump format
                generated by the <literal>dump</literal> subcommand.</para>
              @ENGLISH }}} -->
              <para>Last et sett revisjoner inn i et depot fra en strøm 
                av data som bruker det samme portable dumpformatet 
                generert av 
                <literal>dump</literal>-delkommandoen.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>lslocks</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>List and describe any locks that exist in the
                repository.</para>
              @ENGLISH }}} -->
              <para>List og beskriv enhver lås som eksisterer i 
                depotet.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>lstxns</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>List the names of uncommitted Subversion
                transactions that currently exist in the repository.</para>
              @ENGLISH }}} -->
              <para>List navnene på Subversiontransaksjonene som ikke er 
                lagt inn, men som eksisterer i depotet.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>recover</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Perform recovery steps on a repository that is in
                need of such, generally after a fatal error has
                occurred that prevented a process from cleanly
                shutting down its communication with the repository.</para>
              @ENGLISH }}} -->
              <para>Utfør gjenoppretting på et depot som trenger det, 
                vanligvis etter at en fatal feil er oppstått som 
                forhindret en prosess fra å lukke kommunikasjonen med 
                depotet på en skikkelig måte.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>rmlocks</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Unconditionally remove locks from listed
                paths.</para>
              @ENGLISH }}} -->
              <para>Fjern låser fra listede stier 
                betingelsesløst.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>rmtxns</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Cleanly remove Subversion transactions from the
                repository (conveniently fed by output from the
                <literal>lstxns</literal> subcommand).</para>
              @ENGLISH }}} -->
              <para>Fjern Subversiontransaksjoner fra depotet på en 
                renslig måte <!-- ¤ -->(kan bruke utdataene fra 
                <literal>lstxns</literal>-delkommandoen).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>setlog</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Replace the current value of the
                <literal>svn:log</literal> (commit log message)
                property on a given revision in the repository with a
                new value.</para>
              @ENGLISH }}} -->
              <para>Erstatt den nåværende verdien i 
                <literal>svn:log</literal>-egenskapen (loggmelding) for  
                en angitt revisjon i depotet med en ny verdi.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>verify</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Verify the contents of the repository.  This includes,
                among other things, checksum comparisons of the
                versioned data stored in the repository.</para>
              @ENGLISH }}} -->
              <para>Verifiser innholdet i et depot.
                Dette inkluderer blant annet sjekk av kontrollsummer til 
                de versjonerte dataene som er lagret i depotet.</para>
            </listitem>
          </varlistentry>
        </variablelist>

      </sect3>

      <sect3 id="svn.reposadmin.maint.tk.svndumpfilter">
        <title>svndumpfilter</title>

        <!-- @ENGLISH {{{
        <para>Since Subversion stores everything in an opaque database
          system, attempting manual tweaks is unwise, if not quite
          difficult.  And once data has been stored in your
          repository, Subversion generally doesn't provide an
          easy way to remove that data.
          <footnote>
            <para>That, by the way, is a <emphasis>feature</emphasis>,
              not a bug.</para>
          </footnote>
          But inevitably, there will be times when you would like to
          manipulate the history of your repository.  You might need
          to strip out all instances of a file that was accidentally
          added to the repository (and shouldn't be there for whatever
          reason).  Or, perhaps you have multiple projects sharing a
          single repository, and you decide to split them up into
          their own repositories.  To accomplish tasks like this,
          administrators need a more manageable and malleable
          representation of the data in their repositories&mdash;the
          Subversion repository dump format.</para>
        @ENGLISH }}} -->
        <para>Siden Subversion lagrer alt i et skjult databasesystem, er 
          det å prøve på manuelle forandringer ikke spesielt lurt, for 
          ikke å si vanskelig.
          Og når dataene er lagret i depotet, har ikke Subversion noen 
          enkel måte å fjerne disse dataene.<footnote>
            <para>Og det er forøvrig en 
              <emphasis>funksjonalitet</emphasis> og ikke en 
              feil.</para>
          </footnote>
          Men det er ikke til å komme forbi at det er noen ganger du vil 
          manipulere historien til depotet ditt.
          Det kan være at du vil fjerne alle spor etter en fil som ble 
          lagt til ved en ulykke (og som av en eller annen grunn ikke 
          skal være der).
          Eller du har kanskje flere prosjekter som deler et enkelt 
          depot, og du bestemmer deg for å dele dem opp i sine egne 
          depoter.
          For å utføre oppgaver som dette, trenger administratorer en 
          mer håndterlig og formbar representasjon av dataene i deres 
          egne depot – dumpformatet for Subversiondepot.</para>

        <!-- @ENGLISH {{{
        <para>The Subversion repository dump format is a
          human-readable representation of the changes that you've
          made to your versioned data over time.  You use the
          <command>svnadmin dump</command> command to generate the
          dump data, and <command>svnadmin load</command> to populate
          a new repository with it (see <xref
          linkend="svn.reposadmin.maint.migrate"/>).  The great thing about the
          human-readability aspect of the dump format is that, if you
          aren't careless about it, you can manually inspect and
          modify it.  Of course, the downside is that if you have two
          years' worth of repository activity encapsulated in what is
          likely to be a very large dump file, it could take you a
          long, long time to manually inspect and modify it.</para>
        @ENGLISH }}} -->
        <para>Dumpformatet for Subversiondepot er en representasjon av 
          forandringene som du har gjort i dine versjonerte data over 
          tid, i et menneskelig lesbart format.
          Du bruker kommandoen <command>svnadmin dump</command> for å 
          generere dumpdataene og <command>svnadmin load</command> for å 
          legge disse dataene inn i et nytt depot (se <xref 
          linkend="svn.reposadmin.maint.migrate"/>).
          Den fine tingen med det menneskelesbare dumpformatet er at du 
          kan inspisere og modifisere det hvis du er forsiktig.
          Selvfølgelig, bakdelen er at hvis du har to år med 
          depotaktivitet pakket inn i en stor dumpfil, vil det ta deg 
          lang, lang tid å manuelt inspisere og modifisere den.</para>

        <!-- @ENGLISH {{{
        <para>While it won't be the most commonly used tool at the
          administrator's disposal, <command>svndumpfilter</command>
          provides a very particular brand of useful
          functionality&mdash;the ability to quickly and easily modify
          that dump data by acting as a path-based filter.  Simply
          give it either a list of paths you wish to keep, or a list
          of paths you wish to not keep, then pipe your repository
          dump data through this filter.  The result will be a
          modified stream of dump data that contains only the
          versioned paths you (explicitly or implicitly) requested.</para>
        @ENGLISH }}} -->
        <para>Selv om det ikke vil være det vanligste verktøyet til bruk 
          for depotadministratoren, gir <command>svndumpfilter</command> 
          en veldig spesiell type nyttig funksjonalitet – muligheten til 
          å raskt og enkelt modifisere disse dumpdataene ved å fungere 
          som et stibasert filter.
          Du gir ganske enkelt programmet en liste over stier som du vil 
          beholde, eller en liste med stier som du vil fjerne, og sender 
          deretter dumpdataene fra depotet via et rør gjennom dette 
          filteret.
          Resultatet er en modifisert strøm av dumpdata som kun 
          inneholder de versjonerte stiene som du (eksplisitt eller 
          implisitt) ba om.</para>

        <!-- @ENGLISH {{{
        <para>The syntax of <command>svndumpfilter</command> is as
          follows:</para>
        @ENGLISH }}} -->
        <para>Syntaksen for <command>svndumpfilter</command> er som 
          følger:</para>

        <!-- ¤ -->
        <screen>
$ svndumpfilter help
general usage: svndumpfilter SUBCOMMAND [ARGS &amp; OPTIONS ...]
Type "svndumpfilter help &lt;subcommand&gt;" for help on a specific subcommand.

Available subcommands:
   exclude
   include
   help (?, h)
</screen>

        <!-- @ENGLISH {{{
        <para>There are only two interesting subcommands.  They allow
          you to make the choice between explicit or implicit
          inclusion of paths in the stream:</para>
        @ENGLISH }}} -->
        <para>Her er det bare to interessante delkommandoer.
          De gir deg valget mellom eksplisitt eller implisitt 
          inkludering av stier i strømmen:</para>

        <variablelist>
          <varlistentry>
            <term><literal>exclude</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Filter out a set of paths from the dump data
                stream.</para>
              @ENGLISH }}} -->
              <para>Filtrer bort et sett med stier fra 
                dumpdatastrømmen.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>include</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Allow only the requested set of paths to pass
                through the dump data stream.</para>
              @ENGLISH }}} -->
              <para>Tillat bare de angitte stiene å slippe gjennom 
                dumpdatastrømmen.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <!-- @ENGLISH {{{
        <para>Let's look a realistic example of how you might use this
          program.  We discuss elsewhere (see <xref
          linkend="svn.reposadmin.projects.chooselayout"/>) the process of deciding how to
          choose a layout for the data in your
          repositories&mdash;using one repository per project or
          combining them, arranging stuff within your repository, and
          so on.  But sometimes after new revisions start flying in,
          you rethink your layout and would like to make some changes.
          A common change is the decision to move multiple projects
          which are sharing a single repository into separate
          repositories for each project.</para>
        @ENGLISH }}} -->
        <para>La oss se på et realistisk eksempel på hvordan du vil 
          bruke dette programmet.
          Vi diskuterer en annen plass (se <xref 
          linkend="svn.reposadmin.projects.chooselayout"/>) prosessen 
          med å bestemme hvordan dataene i depotene dine skal legges opp 
          – om du vil bruke ett depot for hvert prosjekt eller kombinere 
          dem, hvordan du arrangerer ting innenfor depotet og så videre.
          Men noen ganger etter at nye revisjoner begynner å komme inn, 
          tenker du på nytt over layouten og vil gjøre noen 
          forandringer.
          En vanlig forandring er å bestemme seg for å flytte flere 
          prosjekter som deler et enkelt depot inn i separate depot for 
          hvert prosjekt.</para>

        <!-- @ENGLISH {{{
        <para>Our imaginary repository contains three projects:
          <literal>calc</literal>, <literal>calendar</literal>, and
          <literal>spreadsheet</literal>.  They have been living
          side-by-side in a layout like this:</para>
        @ENGLISH }}} -->
        <para>Vårt hypotetiske depot inneholder tre prosjekter:
          <!-- ¤ Får se om disse navnene blir fornorsket på et eller 
          annen tidspunkt. --><literal>calc</literal>, 
          <literal>calendar</literal> og <literal>spreadsheet</literal>.
        De har levd ved siden av hverandre som følger:</para>

        <screen>
/
   calc/
      trunk/
      branches/
      tags/
   calendar/
      trunk/
      branches/
      tags/
   spreadsheet/
      trunk/
      branches/
      tags/
</screen>

        <!-- @ENGLISH {{{
        <para>To get these three projects into their own repositories,
          we first dump the whole repository:</para>
        @ENGLISH }}} -->
        <para>For å få disse tre prosjektene inn i deres egne depot, 
          dumper vi først hele depotet:</para>

        <!-- @ENGLISH {{{
        <screen>
$ svnadmin dump /path/to/repos &gt; repos-dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
* Dumped revision 3.
&hellip;
$
</screen>
        @ENGLISH }}} -->
        <screen>
$ svnadmin dump /path/to/repos &gt; depot-dumpfil
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
* Dumped revision 3.
…
$
</screen>

        <!-- @ENGLISH {{{
        <para>Next, run that dump file through the filter, each time
          including only one of our top-level directories, and
          resulting in three new dump files:</para>
        @ENGLISH }}} -->
        <para>Så kjører vi denne dumpfilen gjennom filteret og for hver 
          gang inkluderer vi bare en av katalogene på toppnivå, noe som 
          resulterer i tre nye dumpfiler:</para>

        <!-- @ENGLISH {{{
        <screen>
$ cat repos-dumpfile | svndumpfilter include calc &gt; calc-dumpfile
&hellip;
$ cat repos-dumpfile | svndumpfilter include calendar &gt; cal-dumpfile
&hellip;
$ cat repos-dumpfile | svndumpfilter include spreadsheet &gt; ss-dumpfile
&hellip;
$
</screen>
        @ENGLISH }}} -->
        <screen>
$ cat repos-dumpfile | svndumpfilter include calc &gt; calc-dumpfil
…
$ cat repos-dumpfile | svndumpfilter include calendar &gt; cal-dumpfil
…
$ cat repos-dumpfile | svndumpfilter include spreadsheet &gt; ss-dumpfil
…
$
</screen>

        <!-- @ENGLISH {{{
        <para>At this point, you have to make a decision.  Each of
          your dump files will create a valid repository,
          but will preserve the paths exactly as they were in the
          original repository.  This means that even though you would
          have a repository solely for your <literal>calc</literal>
          project, that repository would still have a top-level
          directory named <filename>calc</filename>.  If you want
          your <filename>trunk</filename>, <filename>tags</filename>,
          and <filename>branches</filename> directories to live in the
          root of your repository, you might wish to edit your
          dump files, tweaking the <literal>Node-path</literal> and
          <literal>Node-copyfrom-path</literal> headers to no longer have
          that first <filename>calc/</filename> path component.  Also,
          you'll want to remove the section of dump data that creates
          the <filename>calc</filename> directory.  It will look
          something like:</para>
        @ENGLISH }}} -->
        <para>På dette punktet må du ta en avgjørelse.
          Hver av dumpfilene fine vil lage et gyldig depot, men vil 
          gjenskape stiene nøyaktig som de var i det opprinnelige 
          depotet.
          Dette betyr at selv om du vil ha et depot kun for 
          <literal>calc</literal>-prosjektet, vil dette depotet fortsatt 
          ha en toppkatalog kalt <filename>calc</filename>.
          Hvis du vil at katalogene <filename>trunk</filename>, 
          <filename>tags</filename> og <filename>branches</filename> 
          skal være i roten av depotet, vil du kanskje ønske å redigere 
          dumpfilene og forandre <literal>Node-path</literal> og 
          <literal>Node-copyfrom-path</literal> i headerne så de ikke 
          lengre inneholder denne <filename>calc/</filename>-komponenten 
          i stien.
          I tillegg ønsker du å fjerne seksjonen i dumpdataene som 
          oppretter <filename>calc</filename>-katalogen.
          Det vil se ut omtrent som dette:</para>

        <screen>
Node-path: calc
Node-action: add
Node-kind: dir
Content-length: 0

</screen>

        <warning>
          <!-- @ENGLISH {{{
          <para>If you do plan on manually editing the dump file to
            remove a top-level directory, make sure that your editor is
            not set to automatically convert end-lines to the native
            format (e.g. \r\n to \n) as the content will then not agree
            with the metadata and this will render the dump file
            useless.</para>
          @ENGLISH }}} -->
          <para>Hvis du planlegger å redigere dumpfilen manuelt for å 
            fjerne en toppkatalog, vær sikker på at tekstbehandleren din 
            ikke er satt til å automatisk konvertere linjeslutt til det 
            lokale formatet (det vil si \r\n til \n).
            Dette vil føre til at innholdet ikke vil samsvare med 
            metadataene og dumpfilen vil dermed bli ubrukelig.</para>
        </warning>

        <!-- @ENGLISH {{{
        <para>All that remains now is to create your three new
          repositories, and load each dump file into the right
          repository:</para>
        @ENGLISH }}} -->
        <para>Alt som gjenstår nå er å opprette dine tre nye depot og 
          laste hver dumpfil inn i det riktige depotet:</para>

        <!-- @ENGLISH {{{
        <screen>
$ svnadmin create calc; svnadmin load calc &lt; calc-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : button.c ... done.
&hellip;
$ svnadmin create calendar; svnadmin load calendar &lt; cal-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : cal.c ... done.
&hellip;
$ svnadmin create spreadsheet; svnadmin load spreadsheet &lt; ss-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : ss.c ... done.
&hellip;
$
</screen>
        @ENGLISH }}} -->
        <screen>
$ svnadmin create calc; svnadmin load calc &lt; calc-dumpfil
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : button.c ... done.
…
$ svnadmin create calendar; svnadmin load calendar &lt; cal-dumpfil
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : cal.c ... done.
…
$ svnadmin create spreadsheet; svnadmin load spreadsheet &lt; ss-dumpfil
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : ss.c ... done.
…
$
</screen>

        <!-- @ENGLISH {{{
        <para>Both of <command>svndumpfilter</command>'s subcommands
          accept options for deciding how to deal with
          <quote>empty</quote> revisions.  If a given revision
          contained only changes to paths that were filtered out, that
          now-empty revision could be considered uninteresting or even
          unwanted.  So to give the user control over what to do with
          those revisions, <command>svndumpfilter</command> provides
          the following command-line options:</para>
        @ENGLISH }}} -->
        <para>Begge delkommandoene til <command>svndumpfilter</command> 
          godtar valg for å bestemme hva de skal gjøre med 
          <quote>tomme</quote> revisjoner.
          Hvis en gitt revisjon bare inneholdt forandringer i stier som 
          ble filtrert bort kan denne revisjonen som nå er tom bli 
          betraktet som uinteressant eller til og med uønsket.
          Så for å gi brukeren kontroll over hva som skal gjøres med 
          disse revisjonene, har <command>svndumpfilter</command> disse 
          kommandolinjevalgene:</para>

        <variablelist>
          <varlistentry>
            <term><option>--drop-empty-revs</option></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Do not generate empty revisions at all&mdash;just
                omit them.</para>
              @ENGLISH }}} -->
              <para>Ikke lag tomme revisjoner i det hele tatt – utelat 
                dem.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--renumber-revs</option></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>If empty revisions are dropped (using the
                <option>-&#64738;-drop-empty-revs</option> option), change the
                revision numbers of the remaining revisions so that
                there are no gaps in the numeric sequence.</para>
              @ENGLISH }}} -->
              <para>Hvis tomme revisjoner er droppet (ved bruk av valget 
                <option>--drop-empty-revs</option>), forandres 
                revisjonsnumrene på de gjenværende revisjonene så det 
                ikke blir mellomrom i den numeriske sekvensen.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--preserve-revprops</option></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>If empty revisions are not dropped, preserve the
                revision properties (log message, author, date, custom
                properties, etc.) for those empty revisions.
                Otherwise, empty revisions will only contain the
                original datestamp, and a generated log message that
                indicates that this revision was emptied by
                <command>svndumpfilter</command>.</para>
              @ENGLISH }}} -->
              <para>Hvis tomme revisjoner ikke droppes, ta vare på 
                revisjonsegenskaper (loggmelding, forfatter, dato, 
                egendefinerte egenskaper og så videre) for disse tomme 
                revisjonene.
                Tomme revisjoner vil ellers bare inneholde det originale 
                tidspunktet og en generert loggmelding som indikerer at 
                denne revisjonen ble tømt av 
                <command>svndumpfilter</command>.</para>
            </listitem>
          </varlistentry>
        </variablelist>
        
        <!-- @ENGLISH {{{
        <para>While <command>svndumpfilter</command> can be very
          useful, and a huge timesaver, there are unfortunately a
          couple of gotchas.  First, this utility is overly sensitive
          to path semantics.  Pay attention to whether paths in your
          dump file are specified with or without leading slashes.
          You'll want to look at the <literal>Node-path</literal> and
          <literal>Node-copyfrom-path</literal> headers.</para>
        @ENGLISH }}} -->
        <para>Selv om <command>svndumpfilter</command> kan være veldig 
          nyttig og sparer masse tid, er det dessverre et par ting å 
          passe på.
          For det første er dette verktøyet overfølsom for <!-- ¤ Finn 
          et mer brukervennlig ord for «semantikk» -->sti-semantikk.
          Legg merke til om stiene i dumpfilen er spesifisert med eller 
          uten skråstreker i starten.
          Dette vil du se i <literal>Node-path</literal> og 
          <literal>Node-copyfrom-path</literal> i headerne.</para>

        <!-- @ENGLISH {{{
        <screen>
&hellip;
Node-path: spreadsheet/Makefile
&hellip;
</screen>
        @ENGLISH }}} -->
        <screen>
…
Node-path: spreadsheet/Makefile
…
</screen>

        <!-- @ENGLISH {{{
        <para>If the paths have leading slashes, you should
          include leading slashes in the paths you pass to
          <command>svndumpfilter include</command> and
          <command>svndumpfilter exclude</command> (and if they don't,
          you shouldn't).  Further, if your dump file has an inconsistent
          usage of leading slashes for some reason,
          <footnote>
            <para>While <command>svnadmin dump</command> has a
              consistent leading slash policy&mdash;to not include
              them&mdash;other programs which generate dump data might
              not be so consistent.</para>
          </footnote>
          you should probably normalize those paths so they all
          have, or lack, leading slashes.</para>
        @ENGLISH }}} -->
        <para>Hvis stiene har innledende skråstreker, skal du også ha 
          innledende skråstreker i stiene som du leverer til 
          <command>svndumpfilter include</command> og 
          <command>svndumpfilter exclude</command> (og hvis de ikke har 
          det, skal du ikke gjøre det).
          Videre, hvis dumpfilen din har inkonsekvent bruk av innledende 
          skråstreker av en eller annen grunn,<footnote>
            <para>Selv om <command>svnadmin dump</command> har en 
              konsekvent regel om innledende skråstreker – å ikke 
              inkludere dem – kan det være at andre programmer som 
              genererer dumpdata ikke er like konsekvente.</para>
          </footnote> bør du normalisere disse stiene så de alle enten 
          har eller mangler innledende skråstreker.</para>

        <!-- @ENGLISH {{{
        <para>Also, copied paths can give you some trouble.
          Subversion supports copy operations in the repository, where
          a new path is created by copying some already existing path.
          It is possible that at some point in the lifetime of your
          repository, you might have copied a file or directory from
          some location that <command>svndumpfilter</command> is
          excluding, to a location that it is including.  In order to
          make the dump data self-sufficient,
          <command>svndumpfilter</command> needs to still show the
          addition of the new path&mdash;including the contents of any
          files created by the copy&mdash;and not represent that
          addition as a copy from a source that won't exist in your
          filtered dump data stream.  But because the Subversion
          repository dump format only shows what was changed in each
          revision, the contents of the copy source might not be
          readily available.  If you suspect that you have any copies
          of this sort in your repository, you might want to rethink
          your set of included/excluded paths.</para>
        @ENGLISH }}} -->
        <para>I tillegg kan kopierte stier gi deg litt trøbbel.
          Subversion støtter kopioperasjoner i depotet, der en ny sti 
          blir opprettet ved å kopiere en allerede eksisterende sti.
          Det er mulig at på et eller annet punkt i livsløpet til 
          depotet blir en fil eller katalog kopiert fra en plass som 
          <command>svndumpfilter</command> utelater, til en plass som 
          programmet inkluderer.
          For å gjøre dumpdataene <!-- ¤ self-sufficient -->selvforsynt, 
          må <command>svndumpfilter</command> vise tilleggingen av den 
          nye stien – inkludert innholdet av alle filer opprettet av 
          kopieringen – og ikke vise denne tilleggingen som en kopiering 
          fra en kilde som ikke eksisterer i den filtrerte 
          dumpdatastrømmen.
          Men fordi dumpformatet i Subversion bare viser hva som ble 
          forandret i hver revisjon, kan det være at innholdet i kilden 
          for kopien ikke er <!-- ¤ readily --> tilgjengelig.
          Hvis du har mistanke om at du har denslags kopier i depotet 
          ditt, vil du kanskje tenke gjennom valget ditt av 
          inkluderte/utelatte stier på nytt.</para>

      </sect3>

      <sect3 id="svn.reposadmin.maint.tk.bdbutil">
        <!-- @ENGLISH {{{
        <title>Berkeley DB Utilities</title>
        @ENGLISH }}} -->
        <title>Berkeley DB-verktøy</title>

        <!-- @ENGLISH {{{
        <para>If you're using a Berkeley DB repository, then all of
          your versioned filesystem's structure and data live in a set
          of database tables within the <filename>db</filename>
          subdirectory of your repository.  This subdirectory is a
          regular Berkeley DB environment directory, and can therefore
          be used in conjunction with any of the Berkeley database
          tools (you can see the documentation for these tools at
          Sleepycat's website,
          <ulink url="http://www.sleepycat.com/"/>).</para>
        @ENGLISH }}} -->
        <para>Hvis du bruker et Berkeley DB-depot, vil alle strukturer 
          og data være i et sett med databasetabeller i katalogen 
          <filename>db</filename> i depotet ditt.
          Denne underkatalogen er en vanlig Berkeley DB miljøkatalog, og 
          kan derfor bli brukt i forbindelse med alle Berkeley 
          databaseverktøy (du kan se dokumentasjonen for disse 
          verktøyene på Sleepycats hjemmeside, <ulink 
          url="http://www.sleepycat.com/"/>).</para>

        <!-- @ENGLISH {{{
        <para>For day-to-day Subversion use, these tools are
          unnecessary.  Most of the functionality typically needed for
          Subversion repositories has been duplicated in the
          <command>svnadmin</command> tool.  For example,
          <command>svnadmin list-unused-dblogs</command> and
          <command>svnadmin list-dblogs</command> perform a
          subset of what is provided by the Berkeley
          <command>db_archive</command> command, and <command>svnadmin
          recover</command> reflects the common use cases of the
          <command>db_recover</command> utility.</para>
        @ENGLISH }}} -->
        <para>For daglig Subversionbruk er disse verktøyene unødvendige.
          Mesteparten av funksjonaliteten som vanligvis er nødvendig for 
          Subversiondepot er blitt duplisert i 
          <command>svnadmin</command>-verktøyet.
          For eksempel, <command>svnadmin list-unused-dblogs</command> 
          og <command>svnadmin list-dblogs</command> utfører en <!-- ¤ 
          subset -->del av hva Berkeley-kommandoen 
          <command>db_archive</command> gjør, og <command>svnadmin 
          recover</command> gjenspeiler de vanlige <!-- ¤ use-cases 
          -->bruksmåter for 
          <command>db_recover</command>-programmet.</para>
            
        <!-- @ENGLISH {{{
        <para>There are still a few Berkeley DB utilities that you
          might find useful.  The <command>db_dump</command> and
          <command>db_load</command> programs write and read,
          respectively, a custom file format which describes the keys
          and values in a Berkeley DB database.  Since Berkeley
          databases are not portable across machine architectures,
          this format is a useful way to transfer those databases from
          machine to machine, irrespective of architecture or
          operating system.  Also, the <command>db_stat</command>
          utility can provide useful information about the status of
          your Berkeley DB environment, including detailed statistics
          about the locking and storage subsystems.</para>
        @ENGLISH }}} -->
        <para>Det er fortsatt noen få Berkeley DB-programmer som du kan 
          finne nyttige.
          Programmene <command>db_dump</command> og 
          <command>db_load</command> skriver og leser <!-- ¤ Blir det 
          rar setning hvis h. står her? -->henholdsvis et tilpasset 
          filformat som beskriver nøkler og verdier i en Berkeley 
          DB-database.
          Siden Berkeley DB-databaser ikke er portable på tvers av 
          maskinarkitekturer, er dette formatet en nyttig måte å 
          overføre disse databasene fra maskin til maskin, uavhengig av 
          arkitektur eller operativsystem.
          I tillegg kan programmet <command>db_stat</command> gi deg 
          nyttig informasjon om statusen til Berkeley DB-miljøet, 
          inkludert detaljert statistikk om undersystemer som tar seg av 
          låsing og lagring.</para>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.cleanup">
      <!-- @ENGLISH {{{
      <title>Repository Cleanup</title>
      @ENGLISH }}} -->
      <title><!-- ¤ Er det ikke noe i samme gata en annen plass i boka? 
        -->Depotvedlikehold</title>
            
      <!-- @ENGLISH {{{
      <para>Your Subversion repository will generally require very
        little attention once it is configured to your liking.
        However, there are times when some manual assistance from an
        administrator might be in order.  The
        <command>svnadmin</command> utility provides some helpful
        functionality to assist you in performing such tasks as:</para>
      @ENGLISH }}} -->
      <para>Subversiondepotet ditt vil vanligvis kreve veldig lite 
        tilsyn når det er konfigurert sånn som du vil ha det.
        Det er imidlertid enkelte ganger en administrator må trå til med 
        manuell assistanse.
        Verktøyet <command>svnadmin</command> gir nyttig funksjonalitet 
        for å hjelpe deg med å utføre oppgaver som:</para>

      <itemizedlist>
        <listitem>
          <!-- @ENGLISH {{{
          <para>modifying commit log messages,</para>
          @ENGLISH }}} -->
          <para>modifisere loggmeldinger</para>
        </listitem>
        <listitem>
          <!-- @ENGLISH {{{
          <para>removing dead transactions,</para>
          @ENGLISH }}} -->
          <para>fjerne døde transaksjoner</para>
        </listitem>
        <listitem>
          <!-- @ENGLISH {{{
          <para>recovering <quote>wedged</quote> repositories, and</para>
          @ENGLISH }}} -->
          <para>gjenopprette <quote>fastkilte</quote> depoter, og</para>
        </listitem>
        <listitem>
          <!-- @ENGLISH {{{
          <para>migrating repository contents to a different
            repository.</para>
          @ENGLISH }}} -->
          <para>flytte depotinnholdet til et annet depot.</para>
        </listitem>
      </itemizedlist>

      <!-- @ENGLISH {{{
      <para>Perhaps the most commonly used of
        <command>svnadmin</command>'s subcommands is
        <literal>setlog</literal>.  When a transaction is committed to
        the repository and promoted to a revision, the descriptive log
        message associated with that new revision (and provided by the
        user) is stored as an unversioned property attached to the
        revision itself.  In other words, the repository remembers
        only the latest value of the property, and discards previous
        ones.</para>
      @ENGLISH }}} -->
      <para>Den delkommandoen som kanskje blir brukt mest i 
        <command>svnadmin</command> er <literal>setlog</literal>.
        Når en transaksjon er lagt inn i depotet og forfremmet til en 
        revisjon, blir den beskrivende loggmeldingen assosiert med denne 
        nye revisjonen <!-- ¤ «(and provided by the user)» Hva menes det 
        her? --> lagret som en uversjonert egenskap vedlagt selve 
        revisjonen.
        Med andre ord, depotet husker bare den seneste verdien til 
        egenskapen, og forkaster tidligere versjoner.</para>

      <!-- @ENGLISH {{{
      <para>Sometimes a user will have an error in her log message (a
        misspelling or some misinformation, perhaps).  If the
        repository is configured (using the
        <literal>pre-revprop-change</literal> and
        <literal>post-revprop-change</literal> hooks; see <xref
        linkend="svn.reposadmin.create.hooks"/>) to accept changes to this log
        message after the commit is finished, then the user can
        <quote>fix</quote> her log message remotely using the
        <command>svn</command> program's <literal>propset</literal>
        command (see <xref linkend="svn.ref"/>).  However, because of
        the potential to lose information forever, Subversion
        repositories are not, by default, configured to allow changes
        to unversioned properties&mdash;except by an administrator.</para>
      @ENGLISH }}} -->
      <para>Noen ganger skjer det at det blir feil i en loggmelding (en 
        skrivefeil eller kanskje noe feilinformasjon).
        Hvis depotet er satt opp (ved bruk av påhakningene
        <literal>pre-rev-prop-change</literal> og 
        <literal>post-revprop-change</literal>; se <xref 
        linkend="svn.reposadmin.create.hooks"/>) til å akseptere 
        forandringer i denne loggmeldingen etter at innleggingen er 
        ferdig, kan brukeren <quote>fikse</quote> loggmeldingen <!-- 
        remotely -->fra en annen maskin ved bruk av 
        <command>svn</command>-programmets 
        <literal>propset</literal>-kommando (se <xref 
        linkend="svn.ref"/>).
        Men fordi det her er en potensiell sjanse for å miste 
        informasjon for alltid, er standard oppsett på et 
        Subversiondepot å ikke godta forandringer i uversjonerte 
        egenskaper – unntatt av en administrator.</para>

      <!-- @ENGLISH {{{
      <para>If a log message needs to be changed by an administrator,
        this can be done using <command>svnadmin setlog</command>.
        This command changes the log message (the
        <literal>svn:log</literal> property) on a given revision of a
        repository, reading the new value from a provided file.</para>
      @ENGLISH }}} -->
      <para>Hvis en loggmelding må forandres av en administrator, kan 
        dette gjøres ved å bruke <command>svnadmin setlog</command>.
        Denne kommandoen forandrer loggmeldingen 
        (<literal>svn:log</literal>-egenskapen) på en gitt revisjoen i 
        et depot, ved å lese den nye verdien fra en fil.</para>
          
      <!-- @ENGLISH {{{
      <screen>
$ echo "Here is the new, correct log message" &gt; newlog.txt
$ svnadmin setlog myrepos newlog.txt -r 388
</screen>
      @ENGLISH }}} -->
      <screen>
$ echo "Her er den nye, korrekte loggmeldingen" &gt; nylogg.txt
$ svnadmin setlog mittdepot nylogg.txt -r 388
</screen>
      
      <!-- @ENGLISH {{{
      <para>The <command>svnadmin setlog</command> command alone is
        still bound by the same protections against modifying
        unversioned properties as a remote client is&mdash;the
        <literal>pre-</literal> and
        <literal>post-revprop-change</literal> hooks are still
        triggered, and therefore must be setup to accept changes of
        this nature.  But an administrator can get around these
        protections by passing the <option>-&#64738;-bypass-hooks</option>
        option to the <command>svnadmin setlog</command> command.</para>
      @ENGLISH }}} -->
      <para>Kommandoen <command>svnadmin setlog</command> alene er 
        fortsatt bundet av den samme beskyttelsen mot å modifisere 
        uversjonerte egenskaper som en klient <!-- 
        «remote»-problematikken igjen -->på en annen maskin er – 
        påhakningsskriptene <literal>pre-revprop-change</literal> og 
        <literal>post-revprop-change</literal> blir fortsatt aktivisert 
        og må derfor settes opp til å godta denne typen forandringer.
        Men en administrator kan gå rundt denne beskyttelsen ved å angi 
        valget <option>--bypass-hooks</option> til <command>svnadmin 
        setlog</command>-kommandoen.</para>
 
      <warning>
        <!-- @ENGLISH {{{
        <para>Remember, though, that by bypassing the hooks, you are
          likely avoiding such things as email notifications of
          property changes, backup systems which track unversioned
          property changes, and so on.  In other words, be very
          careful about what you are changing, and how you change
          it.</para>
        @ENGLISH }}} -->
        <para>Men husk at ved å omgå påhakningsskriptene unngår du også 
          utføring av ting som meldinger via email om forandringer i 
          egenskaper, backupsystemer som følger med på 
          egenskapsforandringer og så videre.
          Med andre ord, vær meget forsiktig med hva du forandrer og 
          hvordan du forandrer det.</para>
      </warning>

      <!-- @ENGLISH {{{
      <para>Another common use of <command>svnadmin</command> is to
        query the repository for outstanding&mdash;possibly
        dead&mdash;Subversion transactions.  In the event that a
        commit should fail, the transaction is usually cleaned up.
        That is, the transaction itself is removed from the
        repository, and any data associated with (and only with) that
        transaction is removed as well.  Occasionally, though, a
        failure occurs in such a way that the cleanup of the
        transaction never happens.  This could happen for several
        reasons: perhaps the client operation was inelegantly
        terminated by the user, or a network failure might have
        occurred in the middle of an operation, etc.  Regardless of
        the reason, dead transactions can happen.  They don't do any
        real harm, other than consuming a small bit of disk space.  A
        fastidious administrator may nonetheless want to remove
        them.</para>
      @ENGLISH }}} -->
      <para>En annen vanlig måte å bruke <command>svnadmin</command> på 
        er å spørre depotet om utestående – muligens døde – 
        Subversiontransaksjoner.
        Hvis en innlegging feiler, blir transaksjonen vanligvis ryddet 
        opp i.
        Det vil si, selve transaksjonen blir fjernet fra depotet, og 
        alle dataene assosiert med (og bare med) denne transaksjonen 
        blir fjernet i samme slengen.
        Men enkelte ganger kan det skje en feil på en måte som gjør at 
        oppryddingen av transaksjonen aldri skjer.
        Dette kan skje av flere grunner:
        Kanskje ble klientoperasjonen uelegant avsluttet av brukeren, 
        eller en nettverksfeil kan ha skjedd midt i en operasjon og så 
        videre.
        Uansett grunnen, døde transaksjoner kan skje.
        De gjør ingen reell skade utenom å okkupere en liten del av 
        diskplassen, og en pertentlig administrator vil nok ønske å 
        fjerne dem.</para>

      <!-- @ENGLISH {{{
      <para>You can use <command>svnadmin</command>'s
        <literal>lstxns</literal> command to list the names of the
        currently outstanding transactions.</para>
      @ENGLISH }}} -->
      <para>Du kan bruke <command>svnadmin</command>s 
        <literal>lstxns</literal>-kommando for å liste navnene på 
        utestående transaksjoner som ligger i depotet for 
        øyeblikket.</para>

      <!-- @ENGLISH {{{
      <screen>
$ svnadmin lstxns myrepos
19
3a1
a45
$
</screen>
      @ENGLISH }}} -->
      <screen>
$ svnadmin lstxns mittdepot
19
3a1
a45
$
</screen>

      <!-- @ENGLISH {{{
      <para>Each item in the resultant output can then be used with
        <command>svnlook</command> (and its
        <option>-&#64738;-transaction</option> option) to determine who
        created the transaction, when it was created, what types of
        changes were made in the transaction&mdash;in other words,
        whether or not the transaction is a safe candidate for
        removal!  If so, the transaction's name can be passed to
        <command>svnadmin rmtxns</command>, which will perform the
        cleanup of the transaction.  In fact, the
        <literal>rmtxns</literal> subcommand can take its input
        directly from the output of <literal>lstxns</literal>!</para>
      @ENGLISH }}} -->
      <para>Hvert element i de resulterende utdataene kan deretter bli 
        brukt sammen med <command>svnlook</command> (og dens valg 
        <option>--transaction</option>) for å finne ut hvem som lagde 
        transaksjonen, når den ble laget, hvilke typer forandringer som 
        ble gjort i transaksjonen – med andre ord, om transaksjonen er 
        eller ikke er en trygg kandidat for sletting!
        Hvis den er det, kan transaksjonens navn leveres til 
        <command>svnadmin rmtxns</command> som vil utføre fjerning av 
        transaksjonen.
        <literal>rmtxns</literal>-delkommandoen kan faktisk motta 
        dataene direkte fra det som <literal>lstxns</literal> 
        genererer!</para>

      <!-- @ENGLISH {{{
      <screen>
$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`
$
</screen>
      @ENGLISH }}} -->
      <screen>
$ svnadmin rmtxns mittdepot `svnadmin lstxns mittdepot`
$
</screen>

      <!-- @ENGLISH {{{
      <para>If you use these two subcommands like this, you should
        consider making your repository temporarily inaccessible to
        clients.  That way, no one can begin a legitimate transaction
        before you start your cleanup.  The following is a little bit
        of shell-scripting that can quickly generate information about
        each outstanding transaction in your repository:</para>
      @ENGLISH }}} -->
      <para>Hvis du bruker disse to delkommandoene som dette, bør du 
        vurdere å gjøre depotet midlertidig utilgjengelig for klienter.
        På denne måten kan ingen starte på en legitim transaksjon før du 
        starter på opprenskningen.
        Det følgende er en skallsnutt som raskt kan generere informasjon 
        om hver utestående transaksjon i depotet ditt:</para>

      <example id="svn.reposadmin.maint.cleanup.ex-1">
        <!-- @ENGLISH {{{
        <title>txn-info.sh (Reporting Outstanding Transactions)</title>
        @ENGLISH }}} -->
        <title>txn-info.sh (Rapporterer utestående 
          transaksjoner)</title>

        <!-- @ENGLISH {{{
        <programlisting>
#!/bin/sh

### Generate informational output for all outstanding transactions in
### a Subversion repository.

REPOS="${1}"
if [ "x$REPOS" = x ] ; then
  echo "usage: $0 REPOS_PATH"
  exit
fi

for TXN in `svnadmin lstxns ${REPOS}`; do 
  echo "-&#64738;-&#64738;-[ Transaction ${TXN} ]-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-"
  svnlook info "${REPOS}" -&#64738;-transaction "${TXN}"
done
</programlisting>
        @ENGLISH }}} -->
        <programlisting>
#!/bin/sh

### Generer informasjon om alle utestående transaksjoner i et 
### Subversiondepot.

REPOS="${1}"
if [ "x$REPOS" = x ] ; then
  echo "bruk: $0 STI_TIL_DEPOT"
  exit
fi

for TXN in `svnadmin lstxns ${REPOS}`; do 
  echo "---[ Transaksjon ${TXN} ]-------------------------------------------"
  svnlook info "${REPOS}" --transaction "${TXN}"
done
</programlisting>
      </example>

      <!-- @ENGLISH {{{
      <para>You can run the previous script using
        <command>/path/to/txn-info.sh /path/to/repos</command>.  The
        output is basically a concatenation of several chunks of
        <command>svnlook info</command> output (see <xref
        linkend="svn.reposadmin.maint.tk.svnlook"/>), and will look something
        like:</para>
      @ENGLISH }}} -->
      <para>Du kan kjøre det foregående skriptet ved å bruke 
        <command>/sti/til/txn-info.sh /sti/til/depot</command>.
        Utdataene er hovedsaklig flere biter av utdataene fra 
        <command>svnlook info</command> som er satt sammen (se <xref 
        linkend="svn.reposadmin.maint.tk.svnlook"/>), og vil se ut som 
        noe i denne retningen:</para>

      <!-- @ENGLISH {{{
      <screen>
$ txn-info.sh myrepos
-&#64738;-&#64738;-[ Transaction 19 ]-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-
sally
2001-09-04 11:57:19 -0500 (Tue, 04 Sep 2001)
0
-&#64738;-&#64738;-[ Transaction 3a1 ]-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-
harry
2001-09-10 16:50:30 -0500 (Mon, 10 Sep 2001)
39
Trying to commit over a faulty network.
-&#64738;-&#64738;-[ Transaction a45 ]-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-
sally
2001-09-12 11:09:28 -0500 (Wed, 12 Sep 2001)
0
$
</screen>
      @ENGLISH }}} -->
      <screen>
$ txn-info.sh mittdepot
---[ Transaksjon 19 ]-------------------------------------------
sally
2001-09-04 11:57:19 -0500 (Tue, 04 Sep 2001)
0
---[ Transaksjon 3a1 ]-------------------------------------------
harry
2001-09-10 16:50:30 -0500 (Mon, 10 Sep 2001)
39
Prøver å legge inn over et skrøpelig nettverk.
---[ Transaksjon a45 ]-------------------------------------------
sally
2001-09-12 11:09:28 -0500 (Wed, 12 Sep 2001)
0
$
</screen>

      <!-- @ENGLISH {{{
      <para>A long-abandoned transaction usually represents some sort
        of failed or interrupted commit.  A transaction's datestamp
        can provide interesting information&mdash;for example, how
        likely is it that an operation begun nine months ago is still
        active?</para>
      @ENGLISH }}} -->
      <para>En transaksjon som har vært avbrutt over lengre tid 
        representerer vanligvis en feilet eller avbrutt innlegging.
        Tidspunktet til en transaksjon kan bidra med interessant 
        informasjon – for eksempel, hvor sannsynlig er det at en 
        operasjon som begynte for ni måneder siden fortsatt er 
        aktiv?</para>

      <!-- @ENGLISH {{{
      <para>In short, transaction cleanup decisions need not be made
        unwisely.  Various sources of information&mdash;including
        Apache's error and access logs, the logs of successful
        Subversion commits, and so on&mdash;can be employed in the
        decision-making process.  Finally, an administrator can often
        simply communicate with a seemingly dead transaction's owner
        (via email, for example) to verify that the transaction is, in
        fact, in a zombie state.</para>
      @ENGLISH }}} -->
      <para>Kort sagt er det ikke nødvendig å foreta ukloke beslutninger 
        angående fjerning av transaksjoner.
        Forskjellige kilder til informasjon – inkludert Apaches feil- og 
        adgangslogg, loggene med gjennomførte Subversioninnlegginger og 
        så videre – kan bli tatt med i beslutningsprosessen.
        Til sist kan administratoren rett og slett kommunisere med 
        eieren av en tilsynelatende død transaksjon (via email, for 
        eksempel) for å fastslå om transaksjonen faktisk er i en 
        zombietilstand.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.diskspace">
      <!-- @ENGLISH {{{
      <title>Managing Disk Space</title>
      @ENGLISH }}} -->
      <title><!-- ¤ -->Bruken av diskplass</title>

        <!-- @ENGLISH {{{
        <para>While the cost of storage has dropped incredibly in the
          past few years, disk usage is still a valid concern for
          administrators seeking to version large amounts of data.
          Every additional byte consumed by the live repository is a
          byte that needs to be backed up offsite, perhaps multiple
          times as part of rotating backup schedules.  If using a
          Berkeley DB repository, the primary storage mechanism is a
          complex database system, it is useful to know what pieces of
          data need to remain on the live site, which need to be
          backed up, and which can be safely removed.  This section is
          specific to Berkeley DB;  FSFS repositories have no extra
          data to be cleaned up or reclaimed.</para>
        @ENGLISH }}} -->
        <para>Selv om prisen på datalagring har stupt de siste årene, er 
          bruken av diskplass fortsatt noe administratorer må tenke på 
          hvis de vil versjonere store mengder data.
          Hver eneste ekstra byte konsumert av det aktive depotet er en 
          byte som må tas backup av utenfor maskinen, kanskje flere 
          ganger som del av roterende backuper.
          Hvis du bruker et Berkeley DB-depot, er den primære 
          lagringsmekanismen et komplekst databasesystem og det er 
          nyttig å vite hvilke deler av dataene som må forbli på den 
          aktive <!-- ¤ Ja, hallo, vi er da ikke ekstremister. -->siten, 
          hvilke som det må tas sikkerhetskopi av, og hva som trygt kan 
          fjernes.
          Denne seksjonen handler spesifikt om Berkeley DB, FSFS-depot 
          har ingen ekstra data som kan ryddes opp i eller <!-- ¤ 
          -->brukes om igjen.</para>

        <!-- @ENGLISH {{{
        <para>Until recently, the largest offender of disk space usage
          with respect to Subversion repositories was the log files to
          which Berkeley DB performs its pre-writes before modifying
          the actual database files.  These files capture all the
          actions taken along the route of changing the database from
          one state to another&mdash;while the database files reflect
          at any given time some state, the log files contain all the
          many changes along the way between states.  As such, they
          can start to accumulate quite rapidly.</para>
        @ENGLISH }}} -->
        <para>Inntil nylig var de største synderne når det gjelder 
          diskplass som brukes av Subversiondepoter loggfilene der 
          Berkeley DB utfører skrivingen på forhånd før de aktuelle 
          databasefilene modifiseres.
          Disse filene inneholder alle operasjonene som blir utført når 
          databasen skal forandres fra en tilstand til en annen – mens 
          databasefilene til enhver tid avspeiler en viss tilstand, 
          inneholder loggfilene alle de mange småforandringene langs 
          veien mellom tilstander.
          Derfor kan de øke i omfang ganske fort.</para>

        <!-- @ENGLISH {{{
        <para>Fortunately, beginning with the 4.2 release of Berkeley
          DB, the database environment has the ability to remove its
          own unused log files without any external procedures.  Any
          repositories created using an <command>svnadmin</command>
          which is compiled against Berkeley DB version 4.2 or greater
          will be configured for this automatic log file removal.  If
          you don't want this feature enabled, simply pass the
          <option>-&#64738;-bdb-log-keep</option> option to the
          <command>svnadmin create</command> command.  If you forget
          to do this, or change your mind at a later time, simple edit
          the <filename>DB_CONFIG</filename> file found in your
          repository's <filename>db</filename> directory, comment out
          the line which contains the <literal>set_flags
          DB_LOG_AUTOREMOVE</literal> directive, and then run
          <command>svnadmin recover</command> on your repository to
          force the configuration changes to take effect.  See <xref
          linkend="svn.reposadmin.create.bdb"/> for more information about
          database configuration.</para>
        @ENGLISH }}} -->
        <para>Heldigvis, fra og med 4.2-versjonen av Berkeley DB har 
          databasemiljøet muligheten til å fjerne sine egne ubrukte 
          loggfiler uten eksterne prosedyrer.
          Ethvert depot som er laget med en <command>svnadmin</command> 
          som er kompilert mot Berkeley DB 4.2 eller større vil bli 
          konfigurert for denne automatiske slettingen av loggfiler.
          Hvis du ikke vil ha denne funksjonaliteten aktivisert, kan du 
          ganske enkelt angi valget <option>--bdb-log-keep</option> til 
          <command>svnadmin create</command>-kommandoen.
          Hvis du glemmer å gjøre dette, eller forandrer mening på et 
          senere tidspunkt, kan du redigere filen 
          <filename>DB_CONFIG</filename> som ligger i katalogen 
          <filename>db</filename> i depotet.
          Du kommenterer bort linjen som inneholder direktivet 
          <literal>set_flags DB_LOG_AUTOREMOVE</literal> og kjører 
          deretter <command>svnadmin recover</command> på depotet ditt 
          for å aktivisere forandringene i konfigrasjonen.
          Se <xref linkend="svn.reposadmin.create.bdb"/> for mer 
          informasjon om databasekonfigurasjon.</para>

        <!-- @ENGLISH {{{
        <para>Without some sort of automatic log file removal in
          place, log files will accumulate as you use your repository.
          This is actually somewhat of a feature of the database
          system&mdash;you should be able to recreate your entire
          database using nothing but the log files, so these files can
          be useful for catastrophic database recovery.  But
          typically, you'll want to archive the log files that are no
          longer in use by Berkeley DB, and then remove them from disk
          to conserve space.  Use the <command>svnadmin
          list-unused-dblogs</command> command to list the unused
          log files:</para>
        @ENGLISH }}} -->
        <para>Uten noen form for automatisk sletting av loggfiler på 
          plass, vil loggfilene samle seg opp etterhvert som du bruker 
          depotet.
          Dette er faktisk en form for God Ting i databasesystemet – du 
          vil være i stand til å gjenopprette hele databasen ved bruk av 
          loggfilene alene, så disse filene kan være nyttige for 
          gjenoppretting etter en katastrofe.
          Men vanligvis vil du arkivere loggfilene som ikke lenger er i 
          bruk av Berkeley DB og deretter fjerne dem fra disken for å 
          spare plass.
          Bruk kommandoen <command>svnadmin list-unused-dblogs</command> 
          for å liste ut de ubrukte loggfilene:</para>

      <!-- @ENGLISH {{{
      <screen>
$ svnadmin list-unused-dblogs /path/to/repos
/path/to/repos/log.0000000031
/path/to/repos/log.0000000032
/path/to/repos/log.0000000033

$ svnadmin list-unused-dblogs /path/to/repos | xargs rm
## disk space reclaimed!
</screen>
      @ENGLISH }}} -->
      <screen>
$ svnadmin list-unused-dblogs /sti/til/depot
/sti/til/depot/log.0000000031
/sti/til/depot/log.0000000032
/sti/til/depot/log.0000000033

$ svnadmin list-unused-dblogs /sti/til/depot | xargs rm
## diskplassen er frigjort!
</screen>

        <!-- @ENGLISH {{{
        <para>To keep the size of the repository as small as possible,
          Subversion uses <firstterm>deltification</firstterm> (or,
          <quote>deltified storage</quote>) within the repository
          itself.  Deltification involves encoding the representation
          of a chunk of data as a collection of differences against
          some other chunk of data.  If the two pieces of data are
          very similar, this deltification results in storage savings
          for the deltified chunk&mdash;rather than taking up space
          equal to the size of the original data, it only takes up
          enough space to say, <quote>I look just like this other
          piece of data over here, except for the following couple of
          changes</quote>.  Specifically, each time a new version of a
          file is committed to the repository, Subversion encodes the
          previous version (actually, several previous versions) as a
          delta against the new version.  The result is that most of
          the repository data that tends to be sizable&mdash;namely,
          the contents of versioned files&mdash;is stored at a much
          smaller size than the original <quote>fulltext</quote>
          representation of that data.</para>
        @ENGLISH }}} -->
        <para>For å holde størrelsen på depotet så liten som mulig, 
          bruker Subversion <firstterm>deltifisering</firstterm> (eller 
          <quote>deltifisert lagring</quote>) inne i selve depotet.
          Deltifisering involverer å kode representasjonen av en porsjon 
          data som en samling av forskjeller mot en annen porsjon data.
          Hvis de to delene med data er veldig like, resulterer denne 
          deltifiseringen i sparing av lagringsplass for den 
          deltifiserte porsjonen – istedenfor å ta opp plass lik 
          størrelsen av de originale dataene, brukes nå nok plass for å 
          si: <quote>Jeg ser ut akkurat som de dataene der borte, 
          unntatt de følgende forandringene</quote>.
          Mer spesifikt, hver gang en ny versjon av en fil blir lagt inn 
          i depotet, koder Subversion den forrige versjonen (egentlig 
          flere tidligere versjoner) som en delta mot den nye versjonen.
          Resultatet er at mesteparten av depotdataene som har en 
          tendens til å forandre seg i størrelse – innholdet av 
          versjonerte filer – blir lagret med en mye mindre datamengde 
          enn den originale <quote>fulltekst</quote>-representasjonen av 
          disse dataene.</para>

        <note>
          <!-- @ENGLISH {{{
          <para>Because all of the Subversion repository data that is
            subject to deltification is stored in a single Berkeley DB
            database file, reducing the size of the stored values will
            not necessarily reduce the size of the database file
            itself.  Berkeley DB will, however, keep internal records
            of unused areas of the database file, and use those areas
            first before growing the size of the database file.  So
            while deltification doesn't produce immediate space
            savings, it can drastically slow future growth of the
            database.</para>
          @ENGLISH }}} -->
          <para>Fordi alle Subversions depotdata som blir deltifisert 
            blir lagret i en enkelt Berkeley DB-databasefil, vil ikke 
            nødvendigvis det å redusere størrelsen på de lagrede 
            verdiene nødvendigvis redusere størrelsen på selve 
            databasefilen.
            Berkeley DB vil imidlertid ha interne poster med ubrukte 
            områder i databasefilen, og vil bruke disse områdene først 
            før den øker størrelsen på databasefilen.
            Så selv om deltifisering ikke medfører øyeblikkelig sparing 
            av diskplass, kan det redusere fremtidig økning i 
            databasestørrelsen ganske drastisk.</para>
        </note>

    </sect2>
        
    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.recovery">
      <!-- @ENGLISH {{{
      <title>Repository Recovery</title>
      @ENGLISH }}} -->
      <title>Depotgjenoppretting</title>

      <!-- @ENGLISH {{{
      <para>As mentioned in <xref linkend="svn.reposadmin.basics.backends.bdb"/>, a
        Berkeley DB repository can sometimes be left in frozen state
        if not closed properly.  When this happens, an administrator
        needs to rewind the database back into a consistent
        state.</para>
      @ENGLISH }}} -->
      <para>Som nevnt i <xref 
        linkend="svn.reposadmin.basics.backends.bdb"/>, kan et Berkeley 
        DB-depot noen ganger bli etterlatt i en frosset tilstand hvis 
        det ikke blir skikkelig lukket.
        Når dette skjer, må en administrator rulle databasen tilbake i 
        funksjonell stand.</para>

      <!-- @ENGLISH {{{
      <para>In order to protect the data in your repository, Berkeley
        DB uses a locking mechanism.  This mechanism ensures that
        portions of the database are not simultaneously modified by
        multiple database accessors, and that each process sees the
        data in the correct state when that data is being read from
        the database.  When a process needs to change something in the
        database, it first checks for the existence of a lock on the
        target data.  If the data is not locked, the process locks the
        data, makes the change it wants to make, and then unlocks the
        data.  Other processes are forced to wait until that lock is
        removed before they are permitted to continue accessing that
        section of the database.</para>
      @ENGLISH }}} -->
      <para>For å beskytte dataene i depotet ditt, bruker Berkeley DB en 
        låsemekanisme.
        Denne mekanismen forsikrer at deler av databasen ikke blir 
        oppdatert samtidig av flere sin aksesserer databasen, og at hver 
        prosess ser dataene i den korrekte tilstanden som da disse 
        dataene ble lest fra databasen.
        Når en prosess må forandre noe i databasen sjekker den først om 
        det eksisterer en lås på måldataene.
        Hvis dataene ikke er låst, låser denne prosessen dataene, gjør 
        forandringene som den ønsker å gjøre, og låser deretter opp 
        dataene.
        Andre prosesser blir tvunget til å vente inntil denne låsen er 
        fjernet før de får lov til å fortsette med tilgangen til denne 
        seksjonen av databasen.</para>

      <!-- @ENGLISH {{{
      <para>In the course of using your Subversion repository, fatal
        errors (such as running out of disk space or available memory)
        or interruptions can prevent a process from having the chance to
        remove the locks it has placed in the database.  The result is
        that the back-end database system gets <quote>wedged</quote>.
        When this happens, any attempts to access the repository hang
        indefinitely (since each new accessor is waiting for a lock to
        go away&mdash;which isn't going to happen).</para>
      @ENGLISH }}} -->
      <para>Under bruk av Subversiondepotet kan fatale feil (som å gå 
        tom for diskplass eller tilgjengelig hukommelse) eller 
        avbrytelser forhindre en prosess fra å fjerne låsene som den har 
        plassert i databasen.
        Resultatet er at det bakenforliggende databasesystemet blir 
        <quote>fastkilt</quote>.
        Når dette skjer, vil ethvert forsøk på å aksessere depotet henge 
        til evig tid (siden hver ny tilgang vil vente på at en lås skal 
        forsvinne – noe som ikke kommer til å skje).</para>

      <!-- @ENGLISH {{{
      <para>First, if this happens to your repository, don't panic.
        The Berkeley DB filesystem takes advantage of database
        transactions and checkpoints and pre-write journaling to
        ensure that only the most catastrophic of events
        <footnote>
          <para>E.g.: hard drive + huge electromagnet = disaster.</para>
        </footnote>
        can permanently destroy a database environment.  A
        sufficiently paranoid repository administrator will be making
        off-site backups of the repository data in some fashion, but
        don't call your system administrator to restore a backup tape
        just yet.</para>
      @ENGLISH }}} -->
      <para>For det første, hvis dette skjer med depotet ditt, ingen 
        panikk.
        Berkeley DB-filsystemet benytter seg av databasetransaksjoner og 
        sjekkpunkter og forhåndsskriver journaler for å forsikre at bare 
        de mest katastrofale hendelser<footnote>
          <para>Som for eksempel:
            Harddisk + kjempemagnet = krise.</para>
        </footnote> kan ødelegge databasen permanent.
        En tilstrekkelig paranoid depotadministrator vil ta 
        sikkerhetskopier av depotet til en annen maskin på en eller 
        annen måte, men ikke få systemadministratoren din til å hente 
        tilbake det som er på backuptapen helt enda.</para>

      <!-- @ENGLISH {{{
      <para>Secondly, use the following recipe to attempt to
        <quote>unwedge</quote> your repository:</para>
      @ENGLISH }}} -->
      <para>For det andre, bruk den følgende oppskriften for å forsøke å 
        <!-- ¤ --><quote>fjerne fastkilingen</quote> av depotet:</para>
   
      <orderedlist>
        <listitem>
          <!-- @ENGLISH {{{
          <para>Make sure that there are no processes accessing (or
            attempting to access) the repository.  For networked
            repositories, this means shutting down the Apache HTTP
            Server, too.</para>
          @ENGLISH }}} -->
          <para>Sjekk at det ikker er noen prosesser som aksesserer 
            (eller forsøker å få tilgang) til depotet.
            For depot på nettverket betyr dette at Apache HTTP også må 
            kjøres ned.</para>
        </listitem>
        <listitem> 
          <!-- @ENGLISH {{{
          <para>Become the user who owns and manages the repository.
            This is important, as recovering a repository while
            running as the wrong user can tweak the permissions of the
            repository's files in such a way that your repository will
            still be inaccessible even after it is 
            <quote>unwedged</quote>.</para>
          @ENGLISH }}} -->
          <para>Bli brukeren som eier og vedlikeholder depotet.
            Dette er viktig fordi en gjenoppretting av depotet med gal 
            bruker kan forandre rettighetene på filene i depotet så det 
            fortsatt vil være utilgjengelig selv etter at det er 
            <quote>reparert</quote>.</para>
        </listitem>
        <listitem>
          <!-- @ENGLISH {{{
          <para>Run the command <command>svnadmin recover
            /path/to/repos</command>.  You should see output like
            this:</para>
          @ENGLISH }}} -->
          <para>Kjør kommandoen <command>svnadmin recover 
            /sti/til/depot</command>.
            Du vil nå se noe i likhet med dette:</para>
              
          <!-- ¤ Bruke norske meldinger en gang i tida? -->
          <screen>
Repository lock acquired.
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 19.
</screen>
          <!-- @ENGLISH {{{
          <para>This command may take many minutes to complete.</para>
          @ENGLISH }}} -->
          <para>Denne kommandoen kan ta flere minutter å 
            fullføre.</para>
        </listitem>
        <listitem>
          <!-- @ENGLISH {{{
          <para>Restart the Subversion server.</para>
          @ENGLISH }}} -->
          <para>Start Subversion&the_server; på nytt.</para>
        </listitem>
      </orderedlist>
            
      <!-- @ENGLISH {{{
      <para>This procedure fixes almost every case of repository
        lock-up.  Make sure that you run this command as the user that
        owns and manages the database, not just as
        <literal>root</literal>.  Part of the recovery process might
        involve recreating from scratch various database files (shared
        memory regions, for example).  Recovering as
        <literal>root</literal> will create those files such that they
        are owned by <literal>root</literal>, which means that even
        after you restore connectivity to your repository, regular
        users will be unable to access it.</para>
      @ENGLISH }}} -->
      <para>Denne prosedyren reparerer nesten ethvert tilfelle av låste 
        databaser.
        Pass på at du kjører denne kommandoen som brukeren som eier og 
        vedlikeholder databasen, ikke bare som <literal>root</literal>.
        Deler av gjenopprettingsprosessen kan føre til at diverse 
        databasefiler blir opprettet på nytt (delte områder av 
        hukommelsen, for eksempel).
        Gjenoppretting som <literal>root</literal> vil lage disse filene 
        som om de er eid av <literal>root</literal>, noe som betyr at 
        til og med etter at du setter opp forbindelsen til databasen 
        igjen, klarer ikke vanlige brukere å få tilgang til den.</para>

      <!-- @ENGLISH {{{
      <para>If the previous procedure, for some reason, does not
        successfully unwedge your repository, you should do two
        things.  First, move your broken repository out of the way and
        restore your latest backup of it.  Then, send an email to the
        Subversion user list (at
        <email>users@subversion.tigris.org</email>) describing your
        problem in detail.  Data integrity is an extremely high
        priority to the Subversion developers.</para>
      @ENGLISH }}} -->
      <para>Hvis den nevnte prosedyren av en eller annen grunn ikke 
        klarer å reparere depotet ditt, skal du gjøre to ting.
        Først flytter du det ødelagte depotet ut av veien og legger inn 
        den siste sikkerhetskopien av den.
        Deretter, send en email til Subversionbrukerlisten (på 
        <email>users@subversion.tigris.org</email>) der du beskriver 
        problemet i detalj.
        Dataintegritet har ekstremt høy prioritet for 
        Subversionutviklerne.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.migrate">
      <!-- @ENGLISH {{{
      <title>Migrating a Repository</title>
      @ENGLISH }}} -->
      <title>Flytte et depot</title>
    
      <!-- @ENGLISH {{{
      <para>A Subversion filesystem has its data spread throughout
        various database tables in a fashion generally understood by
        (and of interest to) only the Subversion developers
        themselves.  However, circumstances may arise that call for
        all, or some subset, of that data to be collected into a
        single, portable, flat file format.  Subversion provides such
        a mechanism, implemented in a pair of
        <command>svnadmin</command> subcommands:
        <literal>dump</literal> and <literal>load</literal>.</para>
      @ENGLISH }}} -->
      <para>Et Subversionfilsystem har dataene sine spredt over flere 
        databasetabeller på en måte som generelt bare er forstått av (og 
        som bare har interesse for) selve Subversionutviklerne.
        Ting kan imidlertid skje som gjør at alt eller litt av disse 
        dataene må samles i et enkeltstående og portabelt 
        <quote>flatt</quote> filformat.
        Subversion har en slik mekanisme, implementert som et par 
        <command>svnadmin</command>-delkommandoer:
        <literal>dump</literal> og <literal>load</literal>.</para>

      <!-- @ENGLISH {{{
      <para>The most common reason to dump and load a Subversion
        repository is due to changes in Subversion itself.  As
        Subversion matures, there are times when certain changes made
        to the back-end database schema cause Subversion to be
        incompatible with previous versions of the repository.  Other
        reasons for dumping and loading might be to migrate a Berkeley
        DB repository to a new OS or CPU architecture, or to switch
        between Berkeley DB and FSFS back-ends.  The recommended
        course of action is relatively simple:</para>
      @ENGLISH }}} -->
      <para>Den vanligste grunnen til å dumpe og laste et 
        Subversiondepot er på grunn av forandringer i selve Subversion.
        Etterhvert som Subversion modnes, skjer det noen ganger at det 
        blir gjort forandringer i det bakenforliggende databaseoppsettet 
        som fører til at Subversion blir inkompatibel med tidligere 
        versjoner av depotet.
        Andre grunner for dumping og lasting kan være å flytte et 
        Berkeley DB-depot til et annet operativsystem eller en annen 
        CPU-arkitektur, eller for å bytte mellom Berkeley DB- og 
        FSFS-lagringsformat.
        Den anbefalte måten å gjøre dette på er relativt enkel:</para>
  
      <orderedlist>
        <listitem>
          <!-- @ENGLISH {{{
          <para>Using your <emphasis>current</emphasis> version of
            <command>svnadmin</command>, dump your repositories to
            dump files.</para>
          @ENGLISH }}} -->
          <para>Bruk din <emphasis>nåværende</emphasis> versjon av 
            <command>svnadmin</command>, dump depotene dine til 
            dumpfiler.</para>
        </listitem>
        <listitem>
          <!-- @ENGLISH {{{
          <para>Upgrade to the new version of Subversion.</para>
          @ENGLISH }}} -->
          <para>Oppgrader til den nye versjonen av Subversion.</para>
        </listitem>
        <listitem>
          <!-- @ENGLISH {{{
          <para>Move your old repositories out of the way, and create
            new empty ones in their place using your
            <emphasis>new</emphasis> <command>svnadmin</command>.</para>
          @ENGLISH }}} -->
          <para>Flytt de gamle depotene ut av veien, og opprett nye på 
            plassen deres ved å bruke den <emphasis>nye</emphasis> 
            versjonen av <command>svnadmin</command>.</para>
        </listitem>
        <listitem>
          <!-- @ENGLISH {{{
          <para>Again using your <emphasis>new</emphasis>
            <command>svnadmin</command>, load your dump files into
            their respective, just-created repositories.</para>
          @ENGLISH }}} -->
          <para>Så laster du dumpfilene inn i de respektive nyopprettede 
            depotene ved å bruke den <emphasis>nye</emphasis> versjonen 
            av <command>svnadmin</command>.</para>
        </listitem>
        <listitem>
          <!-- @ENGLISH {{{
          <para>Be sure to copy any customizations from your old
            repositories to the new ones, including
            <filename>DB_CONFIG</filename> files and hook scripts.
            You'll want to pay attention to the release notes for the
            new release of Subversion to see if any changes since your
            last upgrade affect those hooks or configuration
            options.</para>
          @ENGLISH }}} -->
          <para>Pass på å kopiere alle egne tilpasninger fra de gamle 
            depotene til de nye, inkludert 
            <filename>DB_CONFIG</filename>-filer og påhakningsskript.
            Det kan være lurt å lese hva som er forandret i den nye 
            versjonen av Subversion for å se om det er noen forandringer 
            der som gjør at du må gjøre forandringer i 
            påhakningsskriptene eller konfigurasjonen.</para>
        </listitem>
        <listitem>
          <!-- @ENGLISH {{{
          <para>If the migration process made your repository
            accessible at a different URL (e.g. moved to a different
            computer, or is being accessed via a different schema),
            then you'll probably want to tell your users to run
            <command>svn switch -&#64738;-relocate</command> on their existing
            working copies.  See <xref
            linkend="svn.ref.svn.c.switch"/>.</para>
          @ENGLISH }}} -->
          <para>Hvis flytteprosessen gjør depotet ditt tilgjengelig på 
            en annen URL (for eksempel flyttet til en annen maskin eller 
            blir aksessert på en annen måte), bør du be alle brukerne 
            dine om å kjøre <command>svn switch --relocate</command> på 
            sine eksisterende arbeidskopier.
            Se <xref linkend="svn.ref.svn.c.switch"/>.</para>
        </listitem>
      </orderedlist>

      <!-- @ENGLISH {{{
      <para><command>svnadmin dump</command> will output a range of
        repository revisions that are formatted using Subversion's
        custom filesystem dump format.  The dump format is printed to
        the standard output stream, while informative messages are
        printed to the standard error stream.  This allows you to
        redirect the output stream to a file while watching the status
        output in your terminal window.  For example:</para>
      @ENGLISH }}} -->
      <para><command>svnadmin dump</command> vil generere utdata med en 
        rekke depotrevisjoner som er i Subversions spesiallagde 
        filsystemdumpformat.
        Dumpformatet sendes til standard ut-strømmen 
        (<literal>stdout</literal>), mens informative meldinger sendes 
        til standardfeil-strømmen (<literal>stderr</literal>).
        Dette gjør at du kan omdirigere utdatastrømmen til en fil mens 
        du holder øye med statusen i terminalvinduet.</para>

      <!-- @ENGLISH {{{
      <screen>
$ svnlook youngest myrepos
26
$ svnadmin dump myrepos &gt; dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
&hellip;
* Dumped revision 25.
* Dumped revision 26.
</screen>
      @ENGLISH }}} -->
      <!-- ¤ --><screen>
$ svnlook youngest mittdepot
26
$ svnadmin dump mittdepot &gt; dumpfil
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
…
* Dumped revision 25.
* Dumped revision 26.
</screen>

      <!-- @ENGLISH {{{
      <para>At the end of the process, you will have a single file
        (<filename>dumpfile</filename> in the previous example) that
        contains all the data stored in your repository in the
        requested range of revisions.  Note that <command>svnadmin
        dump</command> is reading revision trees from the repository
        just like any other <quote>reader</quote> process would
        (<command>svn checkout</command>, for example).  So it's safe
        to run this command at any time.</para>
      @ENGLISH }}} -->
      <para>Når denne prosessen er ferdig, vil du ha en enkelt fil 
        (<filename>dumpfil</filename> i det foregående eksempelet) som 
        inneholder alle dataene som er lagret i depotet ditt i det 
        forespurte området med revisjoner.
        Legg merke til at <command>svnadmin dump</command> leser 
        revisjonstrær fra depotet akkurat som enhver annen leseprosess 
        ville gjort det (<command>svn checkout</command>, for eksempel), 
        så det er trygt å kjøre denne kommandoen når som helst.</para>

      <!-- @ENGLISH {{{
      <para>The other subcommand in the pair, <command>svnadmin
        load</command>, parses the standard input stream as a
        Subversion repository dump file, and effectively replays those
        dumped revisions into the target repository for that
        operation.  It also gives informative feedback, this time
        using the standard output stream:</para>
      @ENGLISH }}} -->
      <para>Den andre delkommandoen i dette radarparet, 
        <command>svnadmin load</command>, tolker inndatastrømmen som en 
        Subversiondumpfil og <!-- ¤ --><quote>spiller av</quote> disse 
        dumpede revisjonene inn i måldepotet <!-- ¤ -->for denne 
        operasjonen.
        Den gir også informativ feedback, denne gangen ved å bruke 
        standard ut-strømmen:</para>

      <!-- @ENGLISH {{{
      <screen>
$ svnadmin load newrepos &lt; dumpfile
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : A ... done.
     * adding path : A/B ... done.
     &hellip;
-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 2
     * editing path : A/mu ... done.
     * editing path : A/D/G/rho ... done.

-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;

&hellip;

&lt;&lt;&lt; Started new txn, based on original revision 25
     * editing path : A/D/gamma ... done.

-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 26
     * adding path : A/Z/zeta ... done.
     * editing path : A/mu ... done.

-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;-&#64738;- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;

</screen>
      @ENGLISH }}} -->
      <screen>
$ svnadmin load newrepos &lt; dumpfile
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : A ... done.
     * adding path : A/B ... done.
     …
------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 2
     * editing path : A/mu ... done.
     * editing path : A/D/G/rho ... done.

------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;

…

&lt;&lt;&lt; Started new txn, based on original revision 25
     * editing path : A/D/gamma ... done.

------- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 26
     * adding path : A/Z/zeta ... done.
     * editing path : A/mu ... done.

------- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;

</screen>

      <!-- @ENGLISH {{{
      <para>The result of a load is new revisions added to a
        repository&mdash;the same thing you get by making commits
        against that repository from a regular Subversion client.  And
        just as in a commit, you can use hook scripts to perform
        actions before and after each of the commits made during a load
        process.  By passing the <option>-&#64738;-use-pre-commit-hook</option> 
        and <option>-&#64738;-use-post-commit-hook</option> options to
        <command>svnadmin load</command>, you can instruct Subversion
        to execute the pre-commit and post-commit hook scripts,
        respectively, for each loaded revision.  You might use these,
        for example, to ensure that loaded revisions pass through the
        same validation steps that regular commits pass through.  Of
        course, you should use these options with care&mdash;if your
        post-commit hook sends emails to a mailing list for each new
        commit, you might not want to spew hundreds or thousands of
        commit emails in rapid succession at that list for each of the
        loaded revisions!  You can read more about the use of hook 
        scripts in <xref linkend="svn.reposadmin.create.hooks"/>.</para>
      @ENGLISH }}} -->
      <para>Resultatet av en lasting er at nye revisjoner blir lagt til 
        et depot – det samme som skjer når du legger inn revisjoner i 
        depotet fra en vanlig Subversionklient.
        Og akkurat som i en innlegging kan du bruke påhakningsskript for  
        å utføre oppgaver før og etter hver av innleggingene som blir 
        gjort under en lasteprosess.
        Ved å angi valgene <option>--use-pre-commit-hook</option> og 
        <option>--use-post-commit-hook</option> sammen med 
        <command>svnadmin load</command>, kan du instruere Subversion 
        til å utføre henholdsvis pre-commit- og post-commit-skriptene 
        for hver lastede revisjon.
        Du kan for eksempel bruke disse til å forsikre deg om at de 
        lastede revisjonene går gjennom de samme valideringsstegene som 
        vanlige innlegginger går gjennom.
        Selvfølgelig bør du bruke disse valgene med forsiktighet – hvis 
        post-commit-påhakningen sender epost til en postliste for hver 
        ny revisjon, vil du nok ikke sende ut hundre- eller tusenvis av 
        innleggingsmeldinger i rask rekkefølge til denne listen for hver 
        eneste lastede revisjon!
        Du kan lese mer om bruken av påhakningsskript i <xref 
        linkend="svn.reposadmin.create.hooks"/>.</para>

      <!-- @ENGLISH {{{
      <para>Note that because <command>svnadmin</command> uses
        standard input and output streams for the repository dump and
        load process, people who are feeling especially saucy can try
        things like this (perhaps even using different versions of
        <command>svnadmin</command> on each side of the pipe):</para>
      @ENGLISH }}} -->
      <para>Legg merke til at fordi <command>svnadmin</command> bruker 
        standard inn- og standard ut-strømmer for depotdumpen og 
        lasteprosessen, kan folk som <!--¤ -->vet hva de driver på med 
        prøve på ting som dette (kanskje til og med bruke forskjellige 
        versjoner av <command>svnadmin</command> på hver side av 
        røret):</para>
  
      <!-- @ENGLISH {{{
      <screen>
$ svnadmin create newrepos
$ svnadmin dump myrepos | svnadmin load newrepos
</screen>
      @ENGLISH }}} -->
      <screen>
$ svnadmin create nyttdepot
$ svnadmin dump mittdepot | svnadmin load nyttdepot
</screen>

      <!-- @ENGLISH {{{
      <para>By default, the dump file will be quite large&mdash;much
        larger than the repository itself.  That's because every
        version of every file is expressed as a full text in the
        dump file.  This is the fastest and simplest behavior, and nice
        if you're piping the dump data directly into some other
        process (such as a compression program, filtering program, or
        into a loading process).  But if you're creating a dump file for
        longer-term storage, you'll likely want to save disk space by
        using the <option>-&#64738;-deltas</option> switch.  With this option,
        successive revisions of files will be output as compressed,
        binary differences&mdash;just as file revisions are stored in
        a repository.  This option is slower, but results in a
        dump file much closer in size to the original
        repository.</para>
      @ENGLISH }}} -->
      <para><!-- ¤ «By default», men dette går vel det også. Kunne 
        sikkert brukt den vanlige «som standard», men synes ikke den 
        passer helt her. -->Vanligvis vil dumpfilen bli ganske stor – 
        mye større enn selve depotet.
        Dette er fordi hver eneste versjon av hver fil blir representert 
        som fulltekst i dumpfilen.
        Dette er den raskeste og enkleste oppførselen, og fin hvis du 
        sender dumpdataene gjennom et rør direkte til en annen prosess 
        (som for eksempel et pakkeprogram, filterprogram eller inn i en 
        lasteprosess).
        Men hvis du lager en dumpfil som er ment for langtidslagring, 
        vil du nok ønske å spare diskplass ved å bruke valget 
        <option>--deltas</option>.
        Med dette valget vil etterfølgende revisjoner av filer bli 
        generert som pakkede, binære forskjeller – akkurat som 
        filrevisjoner er lagret i et depot.
        Dette valget er langsommere, men resulterer i en dumpfil mer lik 
        størrelsen til det originale depotet.</para>

      <!-- @ENGLISH {{{
      <para>We mentioned previously that <command>svnadmin
        dump</command> outputs a range of revisions.  Use the
        <option>-&#64738;-revision</option> option to specify a single
        revision to dump, or a range of revisions.  If you omit this
        option, all the existing repository revisions will be
        dumped.</para>
      @ENGLISH }}} -->
      <para>Vi nevnte tidligere at <command>svnadmin dump</command> 
        sender en rekke revisjoner til standard ut.
        Bruk <option>--revision</option>-valget for å spesifisere en 
        enkelt revisjon som skal dumpes, eller et område med revisjoner.
        Hvis du utelater dette valget, vil alle eksisterende 
        depotrevisjoner bli dumpet.</para>

      <!-- @ENGLISH {{{
      <screen>
$ svnadmin dump myrepos -&#64738;-revision 23 &gt; rev-23.dumpfile
$ svnadmin dump myrepos -&#64738;-revision 100:200 &gt; revs-100-200.dumpfile
</screen>
      @ENGLISH }}} -->
      <screen>
$ svnadmin dump mittdepot --revision 23 &gt; rev-23.dumpfil
$ svnadmin dump mittdepot --revision 100:200 &gt; rev-100-200.dumpfil
</screen>

      <!-- @ENGLISH {{{
      <para>As Subversion dumps each new revision, it outputs only
        enough information to allow a future loader to re-create that
        revision based on the previous one.  In other words, for any
        given revision in the dump file, only the items that were
        changed in that revision will appear in the dump.  The only
        exception to this rule is the first revision that is dumped
        with the current <command>svnadmin dump</command>
        command.</para>
      @ENGLISH }}} -->
      <para>Når Subversion dumper hver ny revisjon, lagres akkurat nok 
        informasjon til at et framtidig lasteprogram kan gjenskape denne 
        revisjonen basert på en tidligere revisjon.
        Med andre ord, for enhver gitt revisjon i dumpfilen vil bare de 
        elementene som ble forandret i den revisjonen havne i dumpen.
        Det eneste unntaket fra denne regelen er den første revisjonen 
        som blir dumpet med den nåværende <command>svnadmin 
        dump</command>-kommandoen.</para>

      <!-- @ENGLISH {{{
      <para>By default, Subversion will not express the first dumped
        revision as merely differences to be applied to the previous
        revision.  For one thing, there is no previous revision in the
        dump file!  And secondly, Subversion cannot know the state of
        the repository into which the dump data will be loaded (if it
        ever, in fact, occurs).  To ensure that the output of each
        execution of <command>svnadmin dump</command> is
        self-sufficient, the first dumped revision is by default a
        full representation of every directory, file, and property in
        that revision of the repository.</para>
      @ENGLISH }}} -->
      <para><!-- ¤ Den evinnelige «By default»-problematikken. 
        -->Vanligvis vil Subversion ikke uttrykke den første dumpede 
        revisjonen bare som forskjeller som skal legges til den forrige 
        revisjonen.
        En grunn til dette er at det ikke <emphasis>er</emphasis> noen 
        tidligere revisjon i dumpfilen!
        For det andre kan ikke Subversion vite tilstanden til depotet 
        som dumpdataene vil bli lastet inn i (<!-- ¤ -->hvis det i det 
        hele tatt noen gang blir et).
        For å garantere at utdataene etter hver kjøring av 
        <command>svnadmin dump</command> er selvforsynt, er den første 
        dumpede revisjonen vanligvis en full representasjon av hver 
        katalog, fil og egenskap i denne revisjonen i depotet.</para>

      <!-- @ENGLISH {{{
      <para>However, you can change this default behavior.  If you add
        the <option>-&#64738;-incremental</option> option when you dump your
        repository, <command>svnadmin</command> will compare the first
        dumped revision against the previous revision in the
        repository, the same way it treats every other revision that
        gets dumped.  It will then output the first revision exactly
        as it does the rest of the revisions in the dump
        range&mdash;mentioning only the changes that occurred in that
        revision.  The benefit of this is that you can create several
        small dump files that can be loaded in succession, instead of
        one large one, like so:</para>
      @ENGLISH }}} -->
      <para>Denne standardoppførselen kan du imidlertid forandre.
        Hvis du legger til <option>--incremental</option>-valget når du 
        dumper depotet ditt, vil <command>svnadmin</command> sammenligne 
        den første dumpede revisjonen mot den forrige revisjonen i 
        depotet, på den samme måten som den behandler alle andre 
        revisjoner som blir dumpet.
        Programmet vil deretter generere den første revisjonen nøyaktig 
        som det gjør med resten av revisjonene i dumpområdet – det tar 
        bare med de forandringene som oppsto i den revisjonen.
        Fordelen med dette er at du kan lage flere små dumpfiler som kan 
        bli lastet etter hverandre istedenfor en stor fil.
        Dette gjøres på denne måten:</para>

      <!-- @ENGLISH {{{
      <screen>
$ svnadmin dump myrepos -&#64738;-revision 0:1000 &gt; dumpfile1
$ svnadmin dump myrepos -&#64738;-revision 1001:2000 -&#64738;-incremental &gt; dumpfile2
$ svnadmin dump myrepos -&#64738;-revision 2001:3000 -&#64738;-incremental &gt; dumpfile3
</screen>
      @ENGLISH }}} -->
      <screen>
$ svnadmin dump mittdepot --revision 0:1000 &gt; dumpfil1
$ svnadmin dump mittdepot --revision 1001:2000 --incremental &gt; dumpfil2
$ svnadmin dump mittdepot --revision 2001:3000 --incremental &gt; dumpfil3
</screen>

      <!-- @ENGLISH {{{
      <para>These dump files could be loaded into a new repository with
        the following command sequence:</para>
      @ENGLISH }}} -->
      <para>Disse dumpfilene kan så bli lastet inn i et nytt depot med 
        den følgende kommandosekvensen:</para>

      <!-- @ENGLISH {{{
      <screen>
$ svnadmin load newrepos &lt; dumpfile1
$ svnadmin load newrepos &lt; dumpfile2
$ svnadmin load newrepos &lt; dumpfile3
</screen>
      @ENGLISH }}} -->
      <screen>
$ svnadmin load nyttdepot &lt; dumpfil1
$ svnadmin load nyttdepot &lt; dumpfil2
$ svnadmin load nyttdepot &lt; dumpfil3
</screen>

      <!-- @ENGLISH {{{
      <para>Another neat trick you can perform with this
        <option>-&#64738;-incremental</option> option involves appending to an
        existing dump file a new range of dumped revisions.  For
        example, you might have a <literal>post-commit</literal> hook
        that simply appends the repository dump of the single revision
        that triggered the hook.  Or you might have a script that runs
        nightly to append dump file data for all the revisions that
        were added to the repository since the last time the script
        ran.  Used like this, <command>svnadmin</command>'s
        <literal>dump</literal> and <literal>load</literal> commands
        can be a valuable means by which to backup changes to your
        repository over time in case of a system crash or some other
        catastrophic event.</para>
      @ENGLISH }}} -->
      <para>Et annet lurt triks du kan utføre med dette 
        <option>--incremental</option>-valget går ut å legge til en 
        rekke revisjoner til en eksisterende dumpfil.
        For eksempel kan du ha en 
        <literal>post-commit</literal>-påhakning som rett og slett 
        legger til depotdumpen av den spesifikke revisjonen som utførte 
        påhakningsskriptet.
        Eller du kan ha et skript som kjøres om natten for å legge til 
        dumpdata for alle revisjonene som ble lagt til depotet siden 
        forrige gang skriptet ble kjørt.
        Brukt på denne måten kan <literal>dump</literal>- og 
        <literal>load</literal>-kommandoen til 
        <command>svnadmin</command> tilby verdifull hjelp med å ta 
        sikkerhetskopi av forandringer i depotet over tid i tilfelle 
        systemkrasj eller andre katastrofer.</para>

      <!-- @ENGLISH {{{
      <para>The dump format can also be used to merge the contents of
        several different repositories into a single repository.  By
        using the <option>-&#64738;-parent-dir</option> option of <command>svnadmin
        load</command>, you can specify a new virtual root directory
        for the load process.  That means if you have dump files for
        three repositories, say <filename>calc-dumpfile</filename>,
        <filename>cal-dumpfile</filename>, and
        <filename>ss-dumpfile</filename>, you can first create a new
        repository to hold them all:</para>
      @ENGLISH }}} -->
      <para>Dumpformatet kan også brukes til å flette innholdet av flere 
        forskjellige depot inn i et enkelt depot.
        Ved å bruke valget <option>--parent-dir</option> når du kjører 
        <command>svnadmin load</command>, kan du spesifisere en ny 
        virtuell rotkatalog for lasteprosessen.
        Dette betyr at hvis du har dumpfiler for tre depoter, la oss si 
        <filename>tekst-dumpfil</filename>, 
        <filename>kalender-dumpfil</filename> og 
        <filename>regneark-dumpfil</filename>, kan du først opprette et 
        nytt depot som skal inneholde alle sammen:</para>

      <!-- @ENGLISH {{{
      <screen>
$ svnadmin create /path/to/projects
$
</screen>
      @ENGLISH }}} -->
      <screen>
$ svnadmin create /sti/til/prosjekter
$
</screen>

      <!-- @ENGLISH {{{
      <para>Then, make new directories in the repository which will
        encapsulate the contents of each of the three previous
        repositories:</para>
      @ENGLISH }}} -->
      <para>Deretter, lag nye kataloger i depotet som vil <quote>pakke 
        inn</quote> innholdet av hver av de tre foregående 
        depotene:</para>

      <!-- @ENGLISH {{{
      <screen>
$ svn mkdir -m "Initial project roots" \
      file:///path/to/projects/calc \
      file:///path/to/projects/calendar \
      file:///path/to/projects/spreadsheet
Committed revision 1.
$ 
</screen>
      @ENGLISH }}} -->
      <screen>
$ svn mkdir -m "Opprettet røtter for prosjektene" \
      file:///sti/til/prosjekter/tekst \
      file:///sti/til/prosjekter/kalender \
      file:///sti/til/prosjekter/regneark
Committed revision 1.
$
</screen>

      <!-- @ENGLISH {{{
      <para>Lastly, load the individual dump files into their
        respective locations in the new repository:</para>
      @ENGLISH }}} -->
      <para>Til sist, last de individuelle dumpfilene inn i deres 
        respektive plasseringer i det nye depotet:</para>

      <!-- @ENGLISH {{{
      <screen>
$ svnadmin load /path/to/projects -&#64738;-parent-dir calc &lt; calc-dumpfile
&hellip;
$ svnadmin load /path/to/projects -&#64738;-parent-dir calendar &lt; cal-dumpfile
&hellip;
$ svnadmin load /path/to/projects -&#64738;-parent-dir spreadsheet &lt; ss-dumpfile
&hellip;
$
</screen>
      @ENGLISH }}} -->
      <screen>
$ svnadmin load /sti/til/prosjekter --parent-dir tekst &lt; tekst-dumpfil
…
$ svnadmin load /sti/til/prosjekter --parent-dir kalender &lt; kalender-dumpfil
…
$ svnadmin load /sti/til/prosjekter --parent-dir regneark &lt; regneark-dumpfil
…
$
</screen>

      <!-- @ENGLISH {{{
      <para>We'll mention one final way to use the Subversion
        repository dump format&mdash;conversion from a different
        storage mechanism or version control system altogether.
        Because the dump file format is, for the most part,
        human-readable,
        <footnote>
          <para>The Subversion repository dump format resembles
            an RFC-822 format, the same type of format used for most
            email.</para>
        </footnote>
        it should be relatively easy to describe generic sets of
        changes&mdash;each of which should be treated as a new
        revision&mdash;using this file format.  In fact, the
        <command>cvs2svn</command> utility (see <xref
        linkend="svn.forcvs.convert"/>) uses the dump format to represent the
        contents of a CVS repository so that those contents can be
        copied into a Subversion repository.</para>
      @ENGLISH }}} -->
      <para>Vi vil nevne en siste måte å bruke depotdumpformatet i 
        Subversion på – konvertering fra en annen lagringsmekanisme 
        eller et annen versjonskontrollsystem.
        Fordi dumpfilformatet for det meste er lesbart for 
        mennesker,<footnote>
          <para>Dumpformatet i Subversion ligner et RFC-882-format, den 
            samme typen format som vanligvis brukes i eposter.</para>
        </footnote> skulle det være relativt enkelt å beskrive generelle 
        sett med forandringer – der hver av dem blir behandlet som en ny  
        revisjon – ved å bruke dette filformatet.
        Faktisk bruker programmet <command>cvs2svn</command> (se <xref 
        linkend="svn.forcvs.convert"/>) dumpformatet for å representere 
        innholdet i et CVS-depot så dette innholdet kan bli kopiert inn 
        i et Subversiondepot.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.backup">
      <!-- @ENGLISH {{{
      <title>Repository Backup</title>
      @ENGLISH }}} -->
      <title>Sikkerhetskopi av depotet</title>

      <!-- @ENGLISH {{{
      <para>Despite numerous advances in technology since the birth of
        the modern computer, one thing unfortunately rings true with
        crystalline clarity&mdash;sometimes, things go very, very
        awry.  Power outages, network connectivity dropouts, corrupt
        RAM and crashed hard drives are but a taste of the evil that
        Fate is poised to unleash on even the most conscientious
        administrator.  And so we arrive at a very important
        topic&mdash;how to make backup copies of your repository
        data.</para>
      @ENGLISH }}} -->
      <para>Tross utallige forbedringer i teknologien siden den moderne 
        datamaskinen ble født, gjør fortsatt en ting seg sterkt 
        gjeldende – noen ganger går ting forferdelig galt.
        Strømbrudd, nettverksbrudd, ødelagte minnebrikker og krasjede 
        harddisker er bare en forsmak på ondskapen som Skjebnen er 
        troende til å øse over selv den mest samvittighetsfulle 
        administrator.
        Vi lander derfor på et meget viktig tema – hvordan du tar 
        sikkerhetskopier av depotdataene dine.</para>

      <!-- @ENGLISH {{{
      <para>There are generally two types of backup methods available
        for Subversion repository administrators&mdash;incremental and
        full.  We discussed in an earlier section of this chapter how
        to use <command>svnadmin dump -&#64738;-incremental</command> to
        perform an incremental backup (see <xref
        linkend="svn.reposadmin.maint.migrate"/>).  Essentially, the idea is to
        only backup at a given time the changes to the repository
        since the last time you made a backup.</para>
      @ENGLISH }}} -->
      <para>Det er generelt sett to backupmetoder som er tilgjengelig 
        for administratorer av Subversiondepot – inkrementell og 
        fullstendig.
        Vi diskuterte i en tidligere seksjon i dette kapittelet hvordan 
        <command>svnadmin dump --incremental</command> kan brukes til å 
        utføre en inkrementell backup (se <xref 
        linkend="svn.reposadmin.maint.migrate"/>).
        Essensen i idéen er at på det punktet kopien lages blir kun 
        forandringene i depotet siden forrige backup tatt med.</para>

      <!-- @ENGLISH {{{
      <para>A full backup of the repository is quite literally a
        duplication of the entire repository directory (which includes
        either Berkeley database or FSFS environment).  Now, unless
        you temporarily disable all other access to your repository,
        simply doing a recursive directory copy runs the risk of
        generating a faulty backup, since someone might be currently
        writing to the database.</para>
      @ENGLISH }}} -->
      <para>En fullstendig kopi av depotet er bokstavelig talt en 
        duplisering av hele depotkatalogen (som inkluderer enten en 
        Berkeley-database eller et FSFS-miljø).
        Hvis du nå tar en kopi uten å midlertidig sperre all tilgang til 
        depotet, vil det å bare ta en rekursiv katalogkopi kanskje føre 
        til at det blir feil i kopien, siden noen kan skrive til 
        databasen på samme tidspunkt.</para>

      <!-- @ENGLISH {{{
      <para>In the case of Berkeley DB, Sleepycat documents describe a
        certain order in which database files can be copied that will
        guarantee a valid backup copy.  And a similar ordering exists
        for FSFS data.  Better still, you don't have to implement
        these algorithms yourself, because the Subversion development
        team has already done so.  The
        <command>hot-backup.py</command> script is found in the
        <filename>tools/backup/</filename> directory of the Subversion
        source distribution.  Given a repository path and a backup
        location, <command>hot-backup.py</command>&mdash;which is
        really just a more intelligent wrapper around the
        <command>svnadmin hotcopy</command> command&mdash;will perform
        the necessary steps for backing up your live
        repository&mdash;without requiring that you bar public
        repository access at all&mdash;and then will clean out the
        dead Berkeley log files from your live repository.</para>
      @ENGLISH }}} -->
      <para>I tilfellet med Berkeley DB beskriver dokumenter laget av 
        Sleepycat en viss rekkefølge databasefiler kan kopieres i som 
        vil garantere en gyldig sikkerhetskopi.
        Og en lignende rekkefølge eksisterer for FSFS-data.
        Enda bedre, du trenger ikke selv å implementere disse 
        algoritmene fordi det er allerede gjort av Subversionutviklerne.
        Skriptet <command>hot-backup.py</command> ligger i 
        <filename>tools/backup/</filename>-katalogen i den distribuerte 
        Subversionkildekoden.
        Ved å gi en depotsti og en backupplassering til 
        <command>hot-backup.py</command> – som egentlig bare er en mer 
        intelligent innpakning rundt <command>svnadmin 
        hotcopy</command>-kommandoen – vil den utføre de nødvendige 
        stegene for å ta backup av det aktive depotet ditt – uten at du 
        må sperre den offentlige tilgangen – og vil deretter rense bort 
        de døde Berkeleyloggfilene fra det aktive depotet.</para>

      <!-- @ENGLISH {{{
      <para>Even if you also have an incremental backup, you might
        want to run this program on a regular basis.  For example, you
        might consider adding <command>hot-backup.py</command> to a
        program scheduler (such as <command>cron</command> on Unix
        systems).  Or, if you prefer fine-grained backup solutions,
        you could have your post-commit hook script call
        <command>hot-backup.py</command> (see <xref
        linkend="svn.reposadmin.create.hooks" />), which will then cause a new
        backup of your repository to occur with every new revision
        created.  Simply add the following to the
        <filename>hooks/post-commit</filename> script in your live
        repository directory:</para>
      @ENGLISH }}} -->
      <para>Selv om du også har en inkrementell backup, vil du 
        sannsynligvis ville kjøre dette programmet med jevne mellomrom.
        For eksempel vil du kanskje vurdere å legge til 
        <command>hot-backup.py</command> til en automatisk 
        programkjøring (som <command>cron</command> på Unix-systemer).
        Eller, hvis du foretrekker finjusterte backupløsninger, kan du 
        sette post-commit-skriptet til å kalle 
        <command>hot-backup.py</command> (se <xref 
        linkend="svn.reposadmin.create.hooks" />), som vil lage en ny 
        kopi av depotet for hver ny revisjon som er opprettet.
        Bare legg det følgende inn i 
        <filename>hook/post-commit</filename>-skriptet i katalogen til 
        det aktive depotet:</para>

      <!-- @ENGLISH {{{
      <programlisting>
(cd /path/to/hook/scripts; ./hot-backup.py ${REPOS} /path/to/backups &amp;)
</programlisting>
      @ENGLISH }}} -->
      <programlisting>
(cd /sti/til/påhakningsskript; \
 ./hot-backup.py ${REPOS} /sti/til/sikkerhetskopier &amp;)
</programlisting>

      <!-- @ENGLISH {{{
      <para>The resulting backup is a fully functional Subversion
        repository, able to be dropped in as a replacement for your
        live repository should something go horribly wrong.</para>
      @ENGLISH }}} -->
      <para>Den resulterende backupen er et fullstendig fungerende 
        Subversiondepot som du kan legge inn som en erstatning for det 
        aktive depotet i tilfelle noe skulle gå forferdelig galt.</para>

      <!-- @ENGLISH {{{
      <para>There are benefits to both types of backup methods.  The
        easiest is by far the full backup, which will always result in
        a perfect working replica of your repository.  This again
        means that should something bad happen to your live
        repository, you can restore from the backup with a simple
        recursive directory copy.  Unfortunately, if you are
        maintaining multiple backups of your repository, these full
        copies will each eat up just as much disk space as your live
        repository.</para>
      @ENGLISH }}} -->
      <para>Det er fordeler med begge backupmetodene.
        Den letteste er helt klart å ta en full sikkerhetskopi, som 
        alltid vil resultere i en fullstendig funksjonell duplikat av 
        depotet ditt.
        Dette betyr igjen at hvis noe stygt skulle skje med det aktive 
        depotet, kan du hente det tilbake fra sikkerhetskopien med en 
        enkel rekursiv katalogkopiering.
        Uheldigvis, hvis du har flere kopier av depotet, vil disse 
        fullstendige kopiene spise opp like mye diskplass som det aktive 
        depotet.</para>

      <!-- @ENGLISH {{{
      <para>Incremental backups using the repository dump format are
        excellent to have on hand if the database schema changes
        between successive versions of Subversion itself.  Since a
        complete repository dump and load are generally required to
        upgrade your repository to the new schema, it's very
        convenient to already have half of that process (the dump
        part) finished.  Unfortunately, the creation of&mdash;and
        restoration from&mdash;incremental backups takes longer, as
        each commit is effectively replayed into either the dump file
        or the repository.</para>
      @ENGLISH }}} -->
      <para>Inkrementelle backuper som bruker depotdumpformatet er 
        utmerket å ha for hånden hvis oppbygningen av databasen 
        forandrer seg mellom versjonene av selve Subversion.
        Siden en komplett depotdump og depotlasting vanligvis er 
        nødvendig for å oppgradere depotet ditt til det nye formatet, er 
        det veldig enkelt å allerede ha halvparten av denne prosessen 
        (dumpdelen) overstått.
        Uheldigvis tar opprettelsen av – og gjenoppretting fra – 
        inkrementelle backuper lengre tid, fordi hver innlegging enten 
        blir spilt av inn i dumpfilen eller depotet.</para>

      <!-- @ENGLISH {{{
      <para>In either backup scenario, repository administrators need
        to be aware of how modifications to unversioned revision
        properties affect their backups.  Since these changes do not
        themselves generate new revisions, they will not trigger
        post-commit hooks, and may not even trigger the
        pre-revprop-change and post-revprop-change hooks.
        <footnote>
          <para><command>svnadmin setlog</command> can be called in a
            way that bypasses the hook interface altogether.</para>
        </footnote>  
        And since you can change revision properties without respect
        to chronological order&mdash;you can change any revision's
        properties at any time&mdash;an incremental backup of the
        latest few revisions might not catch a property modification
        to a revision that was included as part of a previous 
        backup.</para>
      @ENGLISH }}} -->
      <para>I begge disse backupscenariene må depotadminstratorer være 
        oppmerksom på hvordan forandringer i uversjonerte 
        revisjonsegenskaper påvirker sikkerhetskopiene.
        Siden disse forandringene ikke selv lager nye revisjoner, vil de 
        ikke aktivisere post-commit-påhakninger, og kanskje heller ikke 
        aktivisere pre-revprop-change- og 
        post-revprop-change-skriptene.<footnote>
          <para><command>svnadmin setlog</command> kan bli kjørt på en 
            måte som går helt utenom påhakningsgrensesnittet.</para>
        </footnote>
        Og siden du kan forandre revisjonsegenskaper som går på tvers av 
        den kronolgiske rekkefølgen – du kan forandre enhver egenskap 
        for en revisjon når som helst – vil en inkrementell backup av de 
        seneste få revisjonene kanskje ikke fange opp en 
        egenskapsforandring i en revisjon som ble inkludert som del av 
        en tidligere backup.</para>

      <!-- @ENGLISH {{{
      <para>Generally speaking, only the truly paranoid would need to
        backup their entire repository, say, every time a commit
        occurred.  However, assuming that a given repository has some
        other redundancy mechanism in place with relatively fine
        granularity (like per-commit emails), a hot backup of the
        database might be something that a repository administrator
        would want to include as part of a system-wide nightly backup.
        For most repositories, archived commit emails alone provide
        sufficient redundancy as restoration sources, at least for the
        most recent few commits.  But it's your data&mdash;protect it
        as much as you'd like.</para>
      @ENGLISH }}} -->
      <para>Vanligvis vil bare den helt paranoide trenge å ta backup av 
        hele depotet, la oss si, hver gang en innlegging skjer.
        Imidlertid, hvis vi antar at et gitt depot har noen ganske 
        finjusterte mekanismer på plass (som utsending av epost for hver 
        innlegging), vil en varm backup av databasen være noe som en 
        depotadministrator vil ønske å inkludere som del av en nattlig 
        systembackup.
        For de fleste depot vil arkiverte eposter alene gi nok 
        informasjon som gjenopprettelseskilde, i hvert fall for de siste 
        få innleggingene.
        Men det er dine data – beskytt dem i den grad du vil.</para>
            
      <!-- @ENGLISH {{{
      <para>Often, the best approach to repository backups is a
        diversified one.  You can leverage combinations of full and
        incremental backups, plus archives of commit emails.  The
        Subversion developers, for example, back up the Subversion
        source code repository after every new revision is created,
        and keep an archive of all the commit and property change
        notification emails.  Your solution might be similar, but
        should be catered to your needs and that delicate balance of
        convenience with paranoia.  And while all of this might not
        save your hardware from the iron fist of Fate,
        <footnote>
          <para>You know&mdash;the collective term for all of her
            <quote>fickle fingers</quote>.</para>
        </footnote>
        it should certainly help you recover from those trying 
        times.</para>
      @ENGLISH }}} -->
      <para>Ofte er den beste tilnærmingsmåten til kopier av depotet 
        delt.
        Du kan sette opp kombinasjoner av fullstendige og inkrementelle 
        backuper, pluss et arkiv med innleggingsmeldinger.
        Subversionutviklerne tar for eksempel backup av kildekodedepotet 
        etter hver ny revisjon som opprettes, og tar vare på et arkiv 
        med alle eposter som varsler om innlegginger og forandringer i 
        revisjoner og egenskaper.
        Løsningen din kan være noe lignende, men bør tilpasses dine 
        behov og følge den fine linjen mellom bekvemmelighet og 
        paranoia.
        Og selv om dette ikke vil redde hardwaren din fra Skjebnens 
        jernhånd,<!-- ¤ <footnote>
          <para>You know—the collective term for all of her 
            <quote>fickle fingers</quote>.</para>
        </footnote> --> vil det helt sikkert hjelpe deg å komme deg på 
        fote igjen etter harde tider som dette.</para>

    </sect2>
  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.projects">
    <!-- @ENGLISH {{{
    <title>Adding Projects</title>
    @ENGLISH }}} -->
    <title>Legge til prosjekter</title>

    <!-- @ENGLISH {{{
    <para>Once your repository is created and configured, all that
      remains is to begin using it.  If you have a collection of
      existing data that is ready to be placed under version control,
      you will more than likely want to use the <command>svn</command>
      client program's <literal>import</literal> subcommand to
      accomplish that.  Before doing this, though, you should
      carefully consider your long-term plans for the repository.  In
      this section, we will offer some advice on how to plan the
      layout of your repository, and how to get your data arranged in
      that layout.</para>
    @ENGLISH }}} -->
    <para>Når depotet ditt er opprettet og konfigurert, er alt som 
      gjenstår å begynne å bruke det.
      Hvis du har en samling med eksisterende data som er klar til å bli 
      plassert under versjonskontroll, vil du mest sannsynlig bruke 
      <command>svn</command>-klientens 
      <literal>import</literal>-delkommando for å gjøre dette.
      Men før du setter i gang bør du gå nøye gjennom planene for 
      depotet på lang sikt.
      I denne seksjonen vil vi gi noen råd om hvordan du planlegger 
      oppbygningen av depotet, og hvordan du får lagt inn dataene dine i 
      dette oppsettet.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.projects.chooselayout">
      <!-- @ENGLISH {{{
      <title>Choosing a Repository Layout</title>
      @ENGLISH }}} -->
      <title>Velge en depot-layout</title>

      <!-- @ENGLISH {{{
      <para>While Subversion allows you to move around versioned files
        and directories without any loss of information, doing so can
        still disrupt the workflow of those who access the repository
        often and come to expect things to be at certain locations.
        Try to peer into the future a bit; plan ahead before placing
        your data under version control.  By <quote>laying out</quote>
        the contents of your repositories in an effective manner the
        first time, you can prevent a load of future headaches.</para>
      @ENGLISH }}} -->
      <para>Selv om Subversion lar deg flytte rundt versjonerte filer og 
        kataloger uten tap av informasjon, kan det forstyrre 
        arbeidsflyten til de som ofte aksesserer depotet og forventer at 
        ting er på sine respektive plasser.
        Prøv å se litt inn i fremtiden; planlegg på forhånd før du 
        plasserer dataene dine under versjonskontroll.
        Ved å sette opp strukturen på innholdet i depotene dine på en 
        effektiv måte den første gangen, kan du forhindre en drøss med 
        fremtidige hodepiner.</para>

      <!-- @ENGLISH {{{
      <para>There are a few things to consider when setting up
        Subversion repositories.  Let's assume that as repository
        administrator, you will be responsible for supporting the
        version control system for several projects.  The first
        decision is whether to use a single repository for multiple
        projects, or to give each project its own repository, or some
        compromise of these two.</para>
      @ENGLISH }}} -->
      <para>Det er noen få ting å tenke over når du setter opp 
        Subversiondepoter.
        La oss anta at som depotadministrator, vil du være ansvarlig for 
        å vedlikeholde versjonskontrollsystemet for flere prosjekter.
        Det første du må bestemme deg for er om du vil bruke et enkelt 
        depot for flere prosjekter, om du vil gi hvert prosjekt sitt 
        eget depot, eller en kombinasjon av disse løsningene.</para>

      <!-- @ENGLISH {{{
      <para>There are benefits to using a single repository for
        multiple projects, most obviously the lack of duplicated
        maintenance.  A single repository means that there is one set
        of hook scripts, one thing to routinely backup, one thing to
        dump and load if Subversion releases an incompatible new
        version, and so on.  Also, you can move data between projects
        easily, and without losing any historical versioning
        information.</para>
      @ENGLISH }}} -->
      <para>Det er fordeler med å bruke et enkelt depot for flere 
        prosjekter, først og fremst at du slipper duplisert vedlikehold.
        Et enkelt depot betyr at det er ett sett med påhakningsskript, 
        én ting å ta backup av, én ting å dumpe og laste hvis Subversion 
        kommer i en ny inkompatibel versjon og så videre.
        I tillegg kan du lett flytte data mellom prosjekter uten å miste 
        historisk versjonsinformasjon.</para>

      <!-- @ENGLISH {{{
      <para>The downside of using a single repository is that
        different projects may have different commit mailing lists or
        different authentication and authorization requirements.
        Also, remember that Subversion uses repository-global revision
        numbers.  Some folks don't like the fact that even though no
        changes have been made to their project lately, the youngest
        revision number for the repository keeps climbing because
        other projects are actively adding new revisions.</para>
      @ENGLISH }}} -->
      <para>Bakdelen med å bruke et enkelt depot er at forskjellige 
        prosjekter kan ha forskjellige postlister eller forskjellige 
        autentiserings- og autorisasjonskrav.
        Husk også at Subversion bruker globale revisjonsnumre i depotet.
        Noen liker ikke at selv om ingen forandringer er blitt gjort i 
        deres prosjekt den senere tid, fortsetter likevel det yngste 
        revisjonsnummeret å øke fordi andre prosjekter legger til nye 
        revisjoner.</para>

      <!-- @ENGLISH {{{
      <para>A middle-ground approach can be taken, too.  For example,
        projects can be grouped by how well they relate to each other.
        You might have a few repositories with a handful of projects
        in each repository.  That way, projects that are likely to
        want to share data can do so easily, and as new revisions are
        added to the repository, at least the developers know that
        those new revisions are at least remotely related to everyone
        who uses that repository.</para>
      @ENGLISH }}} -->
      <para>En kompromissløsning kan også bli brukt.
        For eksemel kan prosjekter bli gruppert sammen etter hvor 
        relaterte de er til hverandre.
        Du kan ha noen få depoter med en håndfull prosjekter i hvert av 
        dem.
        På denne måten kan prosjekter som kan komme til å dele data 
        gjøre dette ganske enkelt, og etterhvert som nye revisjoner blir 
        lagt til depotet, vet utviklerne at disse nye revisjonene 
        ihvertfall er fjernt relaterte på en eller annen måte til alle 
        som bruker dette depotet.</para>

      <!-- @ENGLISH {{{
      <para>After deciding how to organize your projects with respect
        to repositories, you'll probably want to think about directory
        hierarchies in the repositories themselves.  Because
        Subversion uses regular directory copies for branching and
        tagging (see <xref linkend="svn.branchmerge"/>), the Subversion
        community recommends that you choose a repository location for
        each <firstterm>project root</firstterm>&mdash;the
        <quote>top-most</quote> directory which contains data related
        to that project&mdash;and then create three subdirectories
        beneath that root: <filename>trunk</filename>, meaning the
        directory under which the main project development occurs;
        <filename>branches</filename>, which is a directory in which
        to create various named branches of the main development line;
        <filename>tags</filename>, which is a directory of branches
        that are created, and perhaps destroyed, but never
        changed.
        <footnote>
          <para>The <filename>trunk</filename>, <filename>tags</filename>, 
            and <filename>branches</filename> trio are sometimes referred
            to as <quote>the TTB directories</quote>.</para>
        </footnote>
        </para>
      @ENGLISH }}} -->
      <para>Etter å ha avgjort hvordan du vil organisere prosjektene i 
        henhold til depotene, vil du kanskje tenke over 
        kataloghierarkier i selve depotene.
        Fordi Subversion bruker vanlige katalogkopier til forgrening og 
        merking (se <xref linkend="svn.branchmerge"/>), anbefaler 
        Subversionmiljløet at du velger en katalogplassering for hver 
        <firstterm>prosjektrot</firstterm> – den <quote>øverste</quote> 
        katalogen som inneholder data relatert til det prosjektet – og 
        deretter oppretter tre kataloger under denne roten:
        <filename>trunk</filename> som er katalogen der hovedutviklingen 
        av prosjektet foregår; <filename>branches</filename> som er en 
        katalog som er ment for å lage diverse navngitte grener av 
        hovedutviklingen; <filename>tags</filename> som er en katalog av 
        grener som er laget, og kanskje ødelagt, men aldri 
        forandret.<footnote>
          <para>Trioen <filename>trunk</filename>, 
            <filename>tags</filename> og <filename>branches</filename> 
            blir noen ganger referert til som 
            <quote>TTB-katalogene</quote>.</para>
        </footnote></para>

      <!-- @ENGLISH {{{
      <para>For example, your repository might look like:</para>
      @ENGLISH }}} -->
      <para>For eksempel kan depotet ditt se ut som dette:</para>

      <!-- @ENGLISH {{{
      <screen>
/
   calc/
      trunk/
      tags/
      branches/
   calendar/
      trunk/
      tags/
      branches/
   spreadsheet/
      trunk/
      tags/
      branches/
   &hellip;
</screen>
      @ENGLISH }}} -->
      <screen>
/
   calc/
      trunk/
      tags/
      branches/
   calendar/
      trunk/
      tags/
      branches/
   spreadsheet/
      trunk/
      tags/
      branches/
   …
</screen>

      <!-- @ENGLISH {{{
      <para>Note that it doesn't matter where in your repository each
        project root is.  If you have only one project per repository,
        the logical place to put each project root is at the root of
        that project's respective repository.  If you have multiple
        projects, you might want to arrange them in groups inside the
        repository, perhaps putting projects with similar goals or
        shared code in the same subdirectory, or maybe just grouping
        them alphabetically.  Such an arrangement might look
        like:</para>
      @ENGLISH }}} -->
      <para>Legg merke til at det har ingenting å si hvor i depotet hver 
        prosjektrot er.
        Hvis du har bare ett prosjekt per depot, er den logiske plassen 
        å putte hver prosjektrot i roten av det prosjektets respektive 
        depot.
        Hvis du har flere prosjekter, vil du kanskje ønske å arrangere 
        dem i grupper innenfor depotet, kanskje legge prosjekter med 
        likelydende mål eller delt kode i den samme underkatalogen, 
        eller kanskje rett og slett gruppere dem alfabetisk.
        Et slikt system kan se ut som dette:</para>

      <!-- @ENGLISH {{{
      <screen>
/
   utils/
      calc/
         trunk/
         tags/
         branches/
      calendar/
         trunk/
         tags/
         branches/
      &hellip;
   office/
      spreadsheet/
         trunk/
         tags/
         branches/
      &hellip;
</screen>
      @ENGLISH }}} -->
      <screen>
/
   utils/
      calc/
         trunk/
         tags/
         branches/
      calendar/
         trunk/
         tags/
         branches/
      …
   office/
      spreadsheet/
         trunk/
         tags/
         branches/
      …
</screen>

      <!-- @ENGLISH {{{
      <para>Lay out your repository in whatever way you see fit.
        Subversion does not expect or enforce a layout schema&mdash;in
        its eyes, a directory is a directory is a directory.
        Ultimately, you should choose the repository arrangement that
        meets the needs of the people who work on the projects that
        live there.</para>
      @ENGLISH }}} -->
      <para>Legg opp depotet ditt på den måten du synes passer best.
        Subversion forventer ikke eller påtvinger deg ikke en spesiell 
        layout – hva Subversion angår, er en katalog en katalog en 
        katalog.
        Ideelt sett skal du kunne velge det depotoppsettet som fyller 
        behovet til folkene som arbeider på prosjektet som bor 
        der.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.projects.import">
      <!-- @ENGLISH {{{
      <title>Creating the Layout, and Importing Initial Data</title>
      @ENGLISH }}} -->
      <title>Opprette layouten og importere grunndataene</title>
          
      <!-- @ENGLISH {{{
      <para>After deciding how to arrange the projects in your
        repository, you'll probably want to actually populate the
        repository with that layout and with initial project data.
        There are a couple of ways to do this in Subversion.  You
        could use the <command>svn mkdir</command> command (see <xref
        linkend="svn.ref"/>) to create each directory in your
        skeletal repository layout, one-by-one.  A quicker way to
        accomplish the same task is to use the <command>svn
        import</command> command (see <xref
        linkend="svn.tour.other.import"/>).  By first creating the layout
        in a temporary location on your drive, you can import the
        whole layout tree into the repository in a single
        commit:</para>
      @ENGLISH }}} -->
      <para>Etter at du har bestemt deg for hvordan du vil arrangere 
        prosjektene i depotet ditt, vil du sannsynligvis ønske å fylle 
        depotet med dette oppsettet og de innledende prosjektdataene.
        Det er et par måter du kan gjøre dette i Subversion.
        Du kan bruke <command>svn mkdir</command>-kommandoen (se <xref 
        linkend="svn.ref"/>) for å opprette hver katalog i skjelettet av 
        depotlayouten, en etter en.
        En raskere måte å utføre den samme oppgaven på er å bruke 
        kommandoen <command>svn import</command> (se <xref 
        linkend="svn.tour.other.import"/>).
        Ved å først opprette layouten i en midlertidig plassering på 
        harddisken, kan du importere hele katalogtreet inn i depotet i 
        en enkelt innlegging:</para>
            
      <!-- @ENGLISH {{{
      <screen>
$ mkdir tmpdir
$ cd tmpdir
$ mkdir projectA
$ mkdir projectA/trunk
$ mkdir projectA/branches
$ mkdir projectA/tags
$ mkdir projectB
$ mkdir projectB/trunk
$ mkdir projectB/branches
$ mkdir projectB/tags
&hellip;
$ svn import . file:///path/to/repos -&#64738;-message 'Initial repository layout'
Adding         projectA
Adding         projectA/trunk
Adding         projectA/branches
Adding         projectA/tags
Adding         projectB
Adding         projectB/trunk
Adding         projectB/branches
Adding         projectB/tags
&hellip;
Committed revision 1.
$ cd ..
$ rm -rf tmpdir
$
</screen>
      @ENGLISH }}} -->
      <screen>
$ mkdir tmpdir
$ cd tmpdir
$ mkdir prosjektA
$ mkdir prosjektA/trunk
$ mkdir prosjektA/branches
$ mkdir prosjektA/tags
$ mkdir prosjektB
$ mkdir prosjektB/trunk
$ mkdir prosjektB/branches
$ mkdir prosjektB/tags
…
$ svn import . file:///sti/til/depot --message 'Innledende oppsett av depotet'
Adding         prosjektA
Adding         prosjektA/trunk
Adding         prosjektA/branches
Adding         prosjektA/tags
Adding         prosjektB
Adding         prosjektB/trunk
Adding         prosjektB/branches
Adding         prosjektB/tags
…
Committed revision 1.
$ cd ..
$ rm -rf tmpdir
$
</screen>

      <!-- @ENGLISH {{{
      <para>You can verify the results of the import by running the
        <command>svn list</command> command:</para>
      @ENGLISH }}} -->
      <para>Du kan kontrollere resultatene etter importen ved å kjøre 
        kommandoen <command>svn list</command>:</para>

      <!-- @ENGLISH {{{
      <screen>
$ svn list -&#64738;-verbose file:///path/to/repos
      1 harry               May 08 21:48 projectA/
      1 harry               May 08 21:48 projectB/
&hellip;
$
</screen>
      @ENGLISH }}} -->
      <screen>
$ svn list --verbose file:///sti/til/depot
      1 harry               May 08 21:48 prosjektA/
      1 harry               May 08 21:48 prosjektB/
…
$
</screen>

      <!-- @ENGLISH {{{
      <para>Once you have your skeletal layout in place, you can begin
        importing actual project data into your repository, if any
        such data exists yet.  Once again, there are several ways to
        do this.  You could use the <command>svn import</command>
        command.  You could checkout a working copy from your new
        repository, move and arrange project data inside the working
        copy, and use the <command>svn add</command> and <command>svn
        commit</command> commands.  But once we start talking about
        such things, we're no longer discussing repository
        administration.  If you aren't already familiar with the
        <command>svn</command> client program, see <xref
        linkend="svn.tour"/>.</para>
      @ENGLISH }}} -->
      <para>Når du har skjelettet til oppsettet på plass, kan du begynne 
        å importere selve prosjektdataene inn i depotet ditt, hvis noen 
        slike data allerede eksisterer.
        Som sagt, det er flere måter å gjøre dette på.
        Du kan bruuke <command>svn import</command>-kommandoen.
        Du kan hente ut en arbeidskopi fra det nye depotet ditt, flytte 
        og arrangere prosjektdataene inne i arbeidskopien og bruke 
        <command>svn add</command>- og <command>svn 
        commit</command>-kommandoene.
        Men når vi begynner å snakke om slike ting snakker vi ikke 
        lengre om depotadministrasjon.
        Hvis du ikke allerede er kjent med 
        <command>svn</command>-klientprogrammet, se <xref 
        linkend="svn.tour"/>.</para>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.summary">
    <!-- @ENGLISH {{{
    <title>Summary</title>
    @ENGLISH }}} -->
    <title>Oppsummering</title>

    <!-- @ENGLISH {{{
    <para>By now you should have a basic understanding of how to
      create, configure, and maintain Subversion repositories.  We've
      introduced you to the various tools that will assist you with
      this task.  Throughout the chapter, we've noted common
      administration pitfalls, and suggestions for avoiding
      them.</para>
    @ENGLISH }}} -->
    <para>Nå skal du ha fått en grunnleggende forståelse av hvordan du 
      oppretter, konfigurerer og vedlikeholder Subversiondepoter.
      Vi har introdusert deg for de forskjellige verktøyene som vil 
      hjelpe deg med denne oppgaven.
      Gjennom kapittelet har vi gjort oppmerksom på noen feller en 
      administrator kan gå i og hvordan disse fellene kan unngås.</para>

    <!-- @ENGLISH {{{
    <para>All that remains is for you to decide what exciting data to
      store in your repository, and finally, how to make it available
      over a network.  The next chapter is all about networking.</para>
    @ENGLISH }}} -->
    <para>Alt som gjenstår nå er å bestemme hvilke spennende data som du 
      vil lagre i depotet ditt, og til sist, hvordan du vil gjøre det 
      tilgjengelig over nettverket.
      Det neste kapittelet handler kun om nettverk.</para>

  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
vim: set ft=svnbook :
-->
