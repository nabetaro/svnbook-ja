<chapter id="svn.reposadmin">
<!--
  <title>Repository Administration</title>
-->
  <title>Verwaltung des Projektarchivs</title>

<!--
  <para>The Subversion repository is the central storehouse of all
    your versioned data.  As such, it becomes an obvious candidate for
    all the love and attention an administrator can offer.  While the
    repository is generally a low-maintenance item, it is important to
    understand how to properly configure and care for it so that
    potential problems are avoided, and so actual problems are safely
    resolved.</para>
-->
  <para>Das Subversion-Projektarchiv ist die zentrale Lagerhalle für
    Ihre versionierten Daten. In dieser Rolle kann es sich aller Liebe
    und Zuneigung des Administrators gewiss sein. Obwohl das
    Projektarchiv an sich im Allgemeinen wenig Pflege erfordert, ist es
    wichtig, zu wissen, wie es angemessen konfiguriert und gepflegt
    wird, um etwaige Probleme zu vermeiden und bestehende Probleme
    sicher aufzulösen.</para>

<!--
  <para>In this chapter, we'll discuss how to create and configure a
    Subversion repository.  We'll also talk about repository
    maintenance, providing examples of how and when to use the
    <command>svnlook</command> and <command>svnadmin</command> tools
    provided with Subversion.  We'll address some common questions and
    mistakes and give some suggestions on how to arrange the data in
    the repository.</para>
-->
  <para>In diesem Kapitel werden wir erörtern, wie ein
    Subversion-Projektarchiv aufgesetzt und konfiguriert wird. Wir werden
    auch über die Projektarchiv-Pflege reden und Beispiele dafür geben,
    wann und wie die mit Subversion mitgelieferten Werkzeuge
    <command>svnlook</command> und <command>svnadmin</command>
    verwendet werden. Wir werden einige verbreitete Fragen und Fehler
    besprechen und Vorschläge unterbreiten, wie die Daten im
    Projektarchiv organisiert werden können.</para>

<!--
  <para>If you plan to access a Subversion repository only in the
    role of a user whose data is under version control (i.e., via
    a Subversion client), you can skip this chapter altogether.
    However, if you are, or wish to become, a Subversion repository
    administrator,
    <footnote>
      <para>This may sound really prestigious and lofty, but we're
        just talking about anyone who is interested in that
        mysterious realm beyond the working copy where everyone's
        data hangs out.</para>
    </footnote>
    this chapter is for you.</para>
-->
  <para>Falls Sie vorhaben, das Projektarchiv lediglich in der Rolle
    eines Benutzers zu verwenden, der seine Daten unter
    Versionskontrolle stellen möchte (d.h. über einen
    Subversion-Client), können Sie dieses Kapitel vollständig
    überspringen. Wenn Sie jedoch ein
    Subversion-Projektarchiv-Administrator sind oder werden wollen,
    <footnote>
      <para>Das hört sich vielleicht prestigeträchtig und hochmütig
        an, doch wir meinen lediglich jeden, der an diesem mysteriösen
        Bereich hinter der Arbeitskopie interessiert ist, wo sich alle
        Daten befinden.</para>
    </footnote>
    dann ist dieses Kapitel für Sie gemacht.</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.basics">
<!--
    <title>The Subversion Repository, Defined</title>
-->
    <title>Das Subversion Projektarchiv, Definition</title>

<!--
    <para>Before jumping into the broader topic of repository
      administration, let's further define what a repository is.  How
      does it look?  How does it feel?  Does it take its tea hot or
      iced, sweetened, and with lemon?  As an administrator, you'll be
      expected to understand the composition of a repository both from
      a literal, OS-level perspective&mdash;how a repository looks and
      acts with respect to non-Subversion tools&mdash;and from a
      logical perspective&mdash;dealing with how data is represented
      <emphasis>inside</emphasis> the repository.</para>
-->
    <para>Bevor wir uns in das weite Feld der Projektarchiv-Verwaltung
      begeben, wollen wir definieren, was ein Projektarchiv ist. Wie
      sieht es aus? Wie fühlt es sich an? Trinkt es seinen Tee heiß
      oder mit Eis, gesüßt oder mit Zitrone? Als Administrator wird
      von Ihnen erwartet, dass Sie den Aufbau eines Projektarchivs sowohl
      auf der physischen Betriebssystemebene verstehen &ndash; wie sich
      ein Subversion-Projektarchiv aussieht und wie es sich gegenüber
      Nicht-Subversion-Werkzeugen verhält &ndash; als auch aus einer
      logischen Perspektive &ndash; wie Daten
      <emphasis>innerhalb</emphasis> des Projektarchivs repräsentiert
      werden.</para>

<!--
    <para>Seen through the eyes of a typical file browser application
      (such as Windows Explorer) or command-line based filesystem
      navigation tools, the Subversion repository is just another
      directory full of stuff.  There are some subdirectories with
      human-readable configuration files in them, some subdirectories
      with some not-so-human-readable data files, and so on.  As in
      other areas of the Subversion design, modularity is given high
      regard, and hierarchical organization is preferred to cluttered
      chaos.  So a shallow glance into a typical repository from a
      nuts-and-bolts perspective is sufficient to reveal the basic
      components of the repository:</para>
-->
    <para>Mit den Augen eines typischen Dateibrowsers (wie Windows
      Explorer) oder von kommandozeilenorientierten
      Dateisystem-Navigationswerkzeugen ist das Subversion-Projektarchiv
      bloß ein weiteres gewöhnliches Verzeichnis voller Zeugs. Es gibt
      einige Unterverzeichnisse mit Konfigurationsdateien, die für
      Menschen lesbar sind, einige Unterverzeichnisse mit weniger
      lesbaren Datendateien usw. Wie in anderen Bereichen des
      Subversion-Designs, wird auch hier viel Wert auf Modularität
      gesetzt, und hierarchische Organisation wird vollgepfropftem
      Chaos vorgezogen. Ein flacher Blick in ein typisches Projektarchiv
      aus praxisbezogener Sicht reicht aus, um die grundlegenden
      Komponenten des Projektarchivs zu offenbaren.</para>

    <screen>
$ ls repos
conf/  dav/  db/  format  hooks/  locks/  README.txt
</screen>

<!--
    <para>Here's a quick fly-by overview of what exactly you're seeing
      in this directory listing.  (Don't get bogged down in the
      terminology&mdash;detailed coverage of these components exists
      elsewhere in this and other chapters.)</para>
-->
    <para>Hier ist ein schneller, oberflächlicher Überblick über das,
      was Sie in diesem Verzeichnislisting sehen. (Verzetteln Sie sich
      nicht mit den Fachausdrücken &ndash; eine detaillierte
      Behandlung dieser Komponenten erfolgt an anderer Stelle in
      diesem und in anderen Kapiteln.)</para>

    <variablelist>
      <varlistentry>
        <term>conf</term>
        <listitem>
<!--
          <para>A directory containing configuration files</para>
-->
          <para>Ein Verzeichnis, das Konfigurationsdateien enthält.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>dav</term>
        <listitem>
<!--
          <para>A directory provided to
            <filename>mod_dav_svn</filename> for its private
            housekeeping data</para>
-->
          <para>Ein Verzeichnis, das  bereitgestellt wurde, damit
            <filename>mod_dav_svn</filename> seine privaten
            Verwaltungsdaten dort ablegen kann</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>db</term>
        <listitem>
<!--
          <para>The data store for all of your versioned data</para>
-->
          <para>Der Datenspeicher für all Ihre versionierten Daten</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>format</term>
        <listitem>
<!--
          <para>A file that contains a single integer that
            indicates the version number of the repository layout</para>
-->
          <para>Eine Datei, die eine einzelne Ganzzahl beinhaltet, die
            die Version der Projektarchiv-Struktur angibt</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>hooks</term>
        <listitem>
<!--
          <para>A directory full of hook script templates (and hook
            scripts themselves, once you've installed some)</para>
-->
          <para>Ein Verzeichnis voller Hook-Script-Vorlagen (und den
            eigentlichen Hook-Scripten, sofern Sie welche installiert
            haben)</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>locks</term>
        <listitem>
<!--
          <para>A directory for Subversion's repository lock
            files, used for tracking accessors to the repository</para>
-->
          <para>Ein Verzeichnis für die Sperrdateien des
            Subversion-Projektarchivs, die benutzt werden, um die
            Zugreifenden auf das Projektarchiv zu verfolgen</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>README.txt</term>
        <listitem>
<!--
          <para>A file whose contents merely inform its readers that
            they are looking at a Subversion repository</para>
-->
          <para>Eine Datei, deren Inhalt die Leser darüber informiert,
            dass sie in ein Subversion-Projektarchiv schauen</para>
        </listitem>
      </varlistentry>
    </variablelist>

<!--
    <para>Of course, when accessed via the Subversion libraries, this
      otherwise unremarkable collection of files and directories
      suddenly becomes an implementation of a virtual, versioned
      filesystem, complete with customizable event triggers.  This
      filesystem has its own notions of directories and files, very
      similar to the notions of such things held by real filesystems
      (such as NTFS, FAT32, ext3, etc.).  But this is a special
      filesystem&mdash;it hangs these directories and files from
      revisions, keeping all the changes you've ever made to them
      safely stored and forever accessible.  This is where the
      entirety of your versioned data lives.</para>
-->
    <para>Selbstverständlich wird diese sonst so unauffällige
      Ansammlung aus Dateien und Verzeichnissen, wenn auf sie über die
      Subversion-Bibliotheken zugegriffen wird, eine Implementierung
      eines virtuellen, versionierten Dateisystems, vollständig mit
      anpassbaren Ereignis-Triggern. Dieses Dateisystem hat seine
      eigene Auffassung von Verzeichnissen und Dateien, sehr ähnlich
      den Auffassungen, die echte Dateisysteme (wie NTFS, FAT32, ext3
      usw.) von solchen Dingen haben. Aber dies ist ein spezielles
      Dateisystem &ndash; es hängt diese Dateien und Verzeichnisse an
      Revisionen und hält alle Änderungen, die Sie daran vorgenommen
      haben, sicher abgespeichert und für immer abrufbereit. Hier lebt
      die Gesamtheit Ihrer versionierten Daten.</para>

  </sect1>
 
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.planning">
<!--
    <title>Strategies for Repository Deployment</title>
-->
    <title>Strategien für die Verwendung eines Projektarchivs</title>

<!--
    <para>Due largely to the simplicity of the overall design of the
      Subversion repository and the technologies on which it relies,
      creating and configuring a repository are fairly straightforward
      tasks.  There are a few preliminary decisions you'll want to
      make, but the actual work involved in any given setup of a
      Subversion repository is pretty basic, tending toward
      mindless repetition if you find yourself setting up multiples of
      these things.</para>
-->
    <para>Größtenteils wegen der Einfachheit des Gesamtentwurfs des
      Subversion-Projektarchivs und der ihm zugrundeliegenden Technik,
      ist die Erstellung und Konfiguration eines Projektarchivs eine
      ziemlich unkomplizierte Aufgabe. Es gibt einige Entscheidungen,
      die Sie im Vorfeld treffen sollten, jedoch sind die eigentlichen
      Arbeitsschritte für die Einrichtung eines Subversion-Projektarchivs
      recht einfach und neigen zur stupiden Fleißarbeit, falls Sie
      mehrere davon aufzusetzen haben.</para>

<!--
    <para>Some things you'll want to consider beforehand, though, are:</para>
-->
    <para>Einige Dinge, die Sie jedoch im Vorfeld sorgfältig prüfen
      sollten, sind:</para>

    <itemizedlist>
      <listitem>
<!--
        <para>What data do you expect to live in your repository (or
          repositories), and how will that data be organized?</para>
-->
        <para>Welche Art von Daten sollen in Ihrem Projektarchiv (oder
          Projektarchiven) abgelegt werden, und wie sind diese Daten
          organisiert?</para>
      </listitem>
      <listitem>
<!--
        <para>Where will your repository live, and how will it be
          accessed?</para>
-->
        <para>Wo soll Ihr Projektarchiv untergebracht werden, und wie
          soll darauf zugegriffen werden?</para>
      </listitem>
      <listitem>
<!--
        <para>What types of access control and repository event
          reporting do you need?</para>
-->
        <para>Welche Art von Zugriffskontrolle und
          Ereignisbenachrichtigung benötigen Sie?</para>
      </listitem>
      <listitem>
<!--
        <para>Which of the available types of data store do you want
          to use?</para>
-->
        <para>Welche der verfügbaren Datenspeicherungsarten möchten
          Sie verwenden?</para>
      </listitem>
    </itemizedlist>

<!--
    <para>In this section, we'll try to help you answer those
      questions.</para>
-->
    <para>In diesem Abschnitt werden wir versuchen, Ihnen beim
      Beantworten dieser Fragen zu helfen.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.projects.chooselayout">
<!--
      <title>Planning Your Repository Organization</title>
-->
      <title>Planung der Organisation Ihres Projektarchivs</title>

<!--
      <para>While Subversion allows you to move around versioned files
        and directories without any loss of information, and even
        provides ways of moving whole sets of versioned history from
        one repository to another, doing so can greatly disrupt the
        workflow of those who access the repository often and come to
        expect things to be at certain locations.  So before creating
        a new repository, try to peer into the future a bit; plan
        ahead before placing your data under version control.  By
        conscientiously <quote>laying out</quote> your repository or
        repositories and their versioned contents ahead of time, you
        can prevent many future headaches.</para>
-->
      <para>Obwohl Subversion Ihnen erlaubt, versionierte Dateien und
        Ordner ohne Informationsverlust hin und her zu verschieben und
        sogar Methoden anbietet, um versionierte Geschichte von einem
        Projektarchiv in ein anderes zu verschieben, kann das ziemlich
        den Arbeitsablauf derjenigen stören, die oft auf das
        Projektarchiv zugreifen und gewisse Dinge an bestimmten Orten
        erwarten. Bevor Sie ein neues Projektarchiv erstellen, sollten
        Sie also versuchen, ein wenig in die Zukunft zu schauen;
        planen Sie weitsichtig, bevor Sie Ihre Daten unter
        Versionskontrolle stellen. Durch die vorzeitige gewissenhafte
        <quote>Anlage</quote> Ihres Projektarchivs oder mehrerer
        Projektarchive können Sie viel künftigen Kopfschmerz
        vermeiden.</para>

<!--
      <para>Let's assume that as repository administrator, you will be
        responsible for supporting the version control system for
        several projects.  Your first decision is whether to use a
        single repository for multiple projects, or to give each
        project its own repository, or some compromise of these
        two.</para>
-->
      <para>Nehmen wir an, Sie seien als Projektarchiv-Administrator für
        die Versionskontrollsysteme mehrerer Projekte zuständig. Ihre
        erste Entscheidung ist, ob Sie ein einzelnes Projektarchiv für
        mehrere Projekte verwenden, jedem Projekt sein eigenes
        Projektarchiv geben oder einen Kompromiss aus diesen beiden
        Lösungen  haben wollen.</para>

<!--
      <para>There are benefits to using a single repository for
        multiple projects, most obviously the lack of duplicated
        maintenance.  A single repository means that there is one set
        of hook programs, one thing to routinely back up, one thing to
        dump and load if Subversion releases an incompatible new
        version, and so on.  Also, you can move data between projects
        easily, without losing any historical versioning
        information.</para>
-->
      <para>Ein einzelnes Projektarchiv für mehrere Projekte zu
        verwenden, hat einige Vorteile, am offensichtlichsten ist der
        vermiedene doppelte Verwaltungsaufwand. Ein einzelnes
        Projektarchiv bedeutet, dass es nur einen Satz Hook-Programme,
        ein Ding zum routinemäßigen Sichern, ein Ding für einen Auszug
        und zum anschließenden Laden nach einer inkompatiblen neuen
        Version von Subversion gibt usw. Sie können Daten auch einfach
        zwischen Projekten verschieben, ohne historische
        Versionierungsinformationen zu verlieren.</para>

<!--
      <para>The downside of using a single repository is that
        different projects may have different requirements in terms of
        the repository event triggers, such as needing to send commit
        notification emails to different mailing lists, or having
        different definitions about what does and does not constitute
        a legitimate commit.  These aren't insurmountable problems, of
        course&mdash;it just means that all of your hook scripts have
        to be sensitive to the layout of your repository rather than
        assuming that the whole repository is associated with a single
        group of people.  Also, remember that Subversion uses
        repository-global revision numbers.  While those numbers don't
        have any particular magical powers, some folks still don't
        like the fact that even though no changes have been made to
        their project lately, the youngest revision number for the
        repository keeps climbing because other projects are actively
        adding new revisions.
        <footnote>
          <para>Whether founded in ignorance or in poorly considered
            concepts about how to derive legitimate software
            development metrics, global revision numbers are a silly
            thing to fear, and <emphasis>not</emphasis> the kind of
            thing you should weigh when deciding how to arrange your
            projects and repositories.</para>
        </footnote>
      </para>
-->
      <para>Der Nachteil bei der Verwendung eines einzelnen
        Projektarchivs ist, dass unterschiedliche Projekte auch
        unterschiedliche Anforderungen hinsichtlich der
        Projektarchiv-Ereignis-Trigger haben, wie etwa
        Benachrichtigungs-E-Mails bei Commits an unterschiedliche
        Verteiler, oder unterschiedliche Definitionen dazu, was eine
        berechtigte Übergabe ist und was nicht. Das sind natürlich
        keine unüberwindbaren Probleme &ndash; es bedeutet nur, dass
        all Ihre Hook-Skripte die Struktur Ihres Projektarchivs beachten
        müssen, anstatt davon auszugehen, dass das gesamte Projektarchiv
        von einer einzelnen Gruppe zugeordnet ist. Beachten Sie auch,
        dass Subversion Versionsnummern verwendet, die global für das
        gesamte Projektarchiv gelten. Obwohl diese Nummern keine
        Zauberkräfte haben, mögen manche Zeitgenossen es trotzdem
        nicht, dass, obwohl in letzter Zeit keine Änderungen in ihrem
        Projekt durchgeführt worden sind, die jüngste Versionsnummer
        im Projektarchiv ständig höher wird, weil andere Projekte fleißig
        neue Revisionen hinzufügen.
        <footnote>
          <para>Ob es an Ignoranz oder an schlecht überlegten
            Konzepten zur Erstellung berechtigter Metriken für die
            Software-Entwicklung liegt,  ist es dumm, Angst vor
            globalen Revisionsnummern zu haben, und es ist deshalb
            <emphasis>kein</emphasis> Kriterium, das Sie heranziehen
            sollten, wenn Sie abwägen, wie Sie Ihre Projekte und
            Projektarchive anlegen wollen.</para>
        </footnote>
      </para>

<!--
      <para>A middle-ground approach can be taken, too.  For example,
        projects can be grouped by how well they relate to each other.
        You might have a few repositories with a handful of projects
        in each repository.  That way, projects that are likely to
        want to share data can do so easily, and as new revisions are
        added to the repository, at least the developers know that
        those new revisions are at least remotely related to everyone
        who uses that repository.</para>
-->
      <para>Es kann auch eine Lösung in der Mitte gewählt werden.
        Beispielsweise können Projekte danach geordnet werden, wie
        stark sie miteinander verbunden sind. Sie könnten ein paar
        Projektarchive haben, die jeweils eine handvoll Projekte
        beherbergen. Auf diese Art können Projekte, die wahrscheinlich
        gemeinsame Daten verwenden wollen, dies auch einfach
        bewerkstelligen, und wenn dem Projektarchiv neue Versionen
        hinzugefügt werden, wissen die Entwickler wenigstens, dass
        diese neuen Revisionen zumindest entfernt eine Beziehung zu
        jedem Benutzer dieses Projektarchivs haben.</para>

<!--
      <para>After deciding how to organize your projects with respect
        to repositories, you'll probably want to think about directory
        hierarchies within the repositories themselves.  Because
        Subversion uses regular directory copies for branching and
        tagging (see <xref linkend="svn.branchmerge"/>), the
        Subversion community recommends that you choose a repository
        location for each <firstterm>project
        root</firstterm>&mdash;the <quote>topmost</quote> directory
        that contains data related to that project&mdash;and then
        create three subdirectories beneath that root:
        <filename>trunk</filename>, meaning the directory under which
        the main project development occurs;
        <filename>branches</filename>, which is a directory in which
        to create various named branches of the main development line;
        and <filename>tags</filename>, which is a collection of tree
        snapshots that are created, and perhaps destroyed, but never
        changed.
        <footnote>
          <para>The <filename>trunk</filename>, <filename>tags</filename>, 
            and <filename>branches</filename> trio is sometimes referred
            to as <quote>the TTB directories.</quote></para>
        </footnote>
        </para>
-->
      <para>Nachdem Sie entschieden haben, wie Sie Ihre Projekte in
        Projektarchive aufteilen, möchten Sie sich nun vielleicht
        Gedanken darüber machen, welche Verzeichnishierarchien Sie im
        Projektarchiv anlegen wollen. Da Subversion zum Verzweigen und
        Etikettieren reguläre Verzeichniskopien verwendet (siehe <xref
        linkend="svn.branchmerge"/>), empfiehlt die
        Subversion-Gemeinschaft, dass Sie einen Ort im Projektarchiv für
        jedes <firstterm>Projekt-Wurzelverzeichnis</firstterm> wählen
        &ndash; das oberste Verzeichnis, das Daten für Ihr Projekt
        enthält &ndash; und hierunter dann drei Unterverzeichnisse
        anlegen: <filename>trunk</filename>, das Verzeichnis, in dem
        die Hauptentwicklung stattfindet,
        <filename>branches</filename>, zur Aufnahme verschiedener
        Zweige der Hauptentwicklungslinie und
        <filename>tags</filename>, als Sammlung von Momentaufnahmen
        des Verzeichnisbaums, die erzeugt, vielleicht gelöscht, jedoch
        nie verändert werden.
        <footnote>
          <para>Das Trio <filename>trunk</filename>,
          <filename>tags</filename>, and <filename>branches</filename>
          wird manchmal als <quote>die TTB-Verzeichnisse</quote>
          bezeichnet.</para>
        </footnote>
        </para>

<!--
      <para>For example, your repository might look like this:</para>
-->
      <para>Ihr Projektarchiv könnte z.B. so aussehen:</para>

      <screen>
/
   calc/
      trunk/
      tags/
      branches/
   calendar/
      trunk/
      tags/
      branches/
   spreadsheet/
      trunk/
      tags/
      branches/
   &hellip;
</screen>

<!--
      <para>Note that it doesn't matter where in your repository each
        project root is.  If you have only one project per repository,
        the logical place to put each project root is at the root of
        that project's respective repository.  If you have multiple
        projects, you might want to arrange them in groups inside the
        repository, perhaps putting projects with similar goals or
        shared code in the same subdirectory, or maybe just grouping
        them alphabetically.  Such an arrangement might look
        like this:</para>
-->
      <para>Beachten Sie, dass es unerheblich ist, wo in Ihrem
        Projektarchiv sich das Wurzelverzeichnis Ihres Projektes
        befindet.  Falls Sie nur ein Projekt pro Projektarchiv haben, ist
        der logische Ort für das Wurzelverzeichnis des Projektes das
        Wurzelverzeichnis des zum Projekt gehörenden Projektarchivs.
        Falls Sie mehrere Projekte haben, möchten Sie diese vielleicht
        innerhalb des Projektarchivs gruppieren, indem Sie Projekte
        ähnlichen Zwecks in demselben Unterverzeichnis unterbringen
        oder sie vielleicht nur alphabetisch gruppieren. Eine solche
        Anordnung könnte so aussehen:</para>

      <screen>
/
   utils/
      calc/
         trunk/
         tags/
         branches/
      calendar/
         trunk/
         tags/
         branches/
      &hellip;
   office/
      spreadsheet/
         trunk/
         tags/
         branches/
      &hellip;
</screen>

<!--
      <para>Lay out your repository in whatever way you see fit.
        Subversion does not expect or enforce a particular layout&mdash;in
        its eyes, a directory is a directory is a directory.
        Ultimately, you should choose the repository arrangement that
        meets the needs of the people who work on the projects that
        live there.</para>
-->
      <para>Legen Sie Ihr Projektarchiv so an, wie es Ihnen am besten
        passt.  Subversion erwartet oder erzwingt keine bestimmte
        Anordnung &ndash; für Subversion ist und bleibt ein
        Verzeichnis ein Verzeichnis. Letztendlich sollten Sie für ein
        Projektarchiv eine Struktur wählen, die den Bedürfnissen der
        Leute gerecht wird, die an den Projekten arbeiten, die dort
        untergebracht sind.</para>

<!--
      <para>In the name of full disclosure, though, we'll mention
        another very common layout.  In this layout, the
        <filename>trunk</filename>, <filename>tags</filename>, and
        <filename>branches</filename> directories live in the root
        directory of your repository, and your projects are in
        subdirectories beneath those, like so:</para>
-->
      <para>Der Vollständigkeit halber erwähnen wir noch eine weitere,
        verbreitete Anordnung. Bei dieser Anordnung befinden sich die
        Verzeichnisse <filename>trunk</filename>,
        <filename>tags</filename> und <filename>branches</filename> im
        Wurzelverzeichnis des Projektarchivs und die Projekte in
        Unterverzeichnissen davon:</para>

      <screen>
/
   trunk/
      calc/
      calendar/
      spreadsheet/
      &hellip;
   tags/
      calc/
      calendar/
      spreadsheet/
      &hellip;
   branches/
      calc/
      calendar/
      spreadsheet/
      &hellip;
</screen>

<!--
      <para>There's nothing particularly incorrect about such a
        layout, but it may or may not seem as intuitive for your
        users.  Especially in large, multiproject situations with
        many users, those users may tend to be familiar with only one
        or two of the projects in the repository.  But the
        projects-as-branch-siblings approach tends to deemphasize project
        individuality and focus on the entire set of projects as a
        single entity.  That's a social issue, though.  We like our
        originally suggested arrangement for purely practical
        reasons&mdash;it's easier to ask about (or modify, or migrate
        elsewhere) the entire history of a single project when there's
        a single repository path that holds the entire
        history&mdash;past, present, tagged, and branched&mdash;for
        that project and that project alone.</para>
-->
      <para>An dieser Anordnung ist zwar nichts verkehrt, allerdings
        könnte es für Ihre Benutzer mehr oder weniger intuitiv sein.
        Besonders in Situationen mit vielen Projekten und entsprechend
        vielen Benutzern, kann es vorkommen, dass die Benutzer
        gewöhnlich nur mit einem oder zwei dieser Projekte vertraut
        sind. Allerdings schwächt dieser
        Projekt-als-Geschwister-Zweig-Ansatz die Betonung auf
        Projekt-Individualität und betrachtet die Gesamtmenge der
        Projekte als Ganzes. Das ist jedoch ein sozialer Aspekt. Wir
        mögen unseren ursprünglich geäußerten Vorschlag aus rein
        praktischen Erwägungen &ndash; es ist einfacher, in der
        kompletten Historie eines einzelnen Projektes zu forschen
        (oder sie zu verändern oder woandershin zu migrieren), wenn es
        einen einzelnen Pfad im Projektarchiv gibt, der die gesamte
        Historie für dieses eine Projekt, und nur dieses,  beinhaltet
        &ndash; die Vergangenheit, Tags und Zweige.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.hosting">
<!--
      <title>Deciding Where and How to Host Your Repository</title>
-->
      <title>Entscheiden Sie, wo und wie Ihr Projektarchiv untergebracht
        werden soll</title>

<!--
      <para>Before creating your Subversion repository, an obvious
        question you'll need to answer is where the thing is going to
        live.  This is strongly connected to myriad other
        questions involving how the repository will be accessed (via a
        Subversion server or directly), by whom (users behind your
        corporate firewall or the whole world out on the open
        Internet), what other services you'll be providing around
        Subversion (repository browsing interfaces, email-based
        commit notification, etc.), your data backup strategy, and so
        on.</para>
-->
      <para>Bevor Sie Ihr Subversion-Projektarchiv anlegen, bleibt die
        offensichtliche Frage zu beantworten, wo das Ding hin soll.
        Das hängt eng mit etlichen weiteren Fragen zusammen, etwa wie
        auf das Projektarchiv zugegriffen werden soll (über einen
        Subversion-Server oder direkt), wer darauf zugreifen soll
        (Benutzer hinter Ihrer Firmen-Firewall oder die weite Welt im
        offenen Netz), welche zusätzlichen Dienste Sie im Zusammenhang
        mit Subversion anbieten wollen (Schnittstellen zum Stöbern im
        Projektarchiv, Übergabebenachrichtigungen per E-Mail usw.), Ihre
        Sicherungsstrategie und vieles mehr.</para>

<!--
      <para>We cover server choice and configuration in <xref
        linkend="svn.serverconfig" />, but the point we'd like to
        briefly make here is simply that the answers to some of these
        other questions might have implications that force your hand
        when deciding where your repository will live.  For example,
        certain deployment scenarios might require accessing the
        repository via a remote filesystem from multiple computers, in
        which case (as you'll read in the next section) your choice of
        a repository backend data store turns out not to be a choice
        at all because only one of the available backends will work
        in this scenario.</para>
-->
      <para>Die Auswahl und Konfigurierung des Servers werden wir in
        <xref linkend="svn.serverconfig" /> behandeln; jedoch möchten
        wir an dieser Stelle kurz darauf hinweisen, dass die Antworten
        auf einige der anderen Fragen zur Folge haben, dass Sie bei
        der Entscheidung über den Speicherorte für das Projektarchiv
        keine freie Wahl mehr haben.  Beispielsweise könnten bestimmte
        Einsatzumgebungen erfordern, dass von mehreren Rechnern über
        ein freigegebenes Dateisystem auf das Projektarchiv zugegriffen
        werden muss, so dass (wie Sie im nächsten Abschnitt lesen
        werden) die Wahl der dem Projektarchiv zugrundeliegenden
        Datenspeicherung gar keine Wahl mehr ist, da nur eine der
        verfügbaren Datenspeicherungsverfahren in dieser Umgebung
        funktionieren wird.</para>

<!--
      <para>Addressing each possible way to deploy
        Subversion is both impossible and outside the scope of this
        book.  We simply encourage you to evaluate your options using
        these pages and other sources as your reference material and to
        plan ahead.</para>
-->
      <para>Es ist unmöglich, und würde auch den Rahmen dieses Buches
        sprengen, wenn jede erdenkliche Einsatzart von Subversion
        angesprochen würde. Wir ermutigen Sie einfach, Ihre Optionen
        zu prüfen, indem Sie diese Seiten und weitere Quellen als
        Referenz verwenden und weitsichtig planen.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.backends">
<!--
      <title>Choosing a Data Store</title>
-->
      <title>Auswahl der Datenspeicherung</title>

<!--
      <para>Subversion provides two options for the
        type of underlying data store&mdash;often referred to as
        <quote>the backend</quote> or, somewhat confusingly,
        <quote>the (versioned) filesystem</quote>&mdash;that each
        repository uses.  One type of data store keeps everything in a
        Berkeley DB (or BDB) database environment; repositories that
        use this type are often referred to as being
        <quote>BDB-backed.</quote>  The other type stores data in
        ordinary flat files, using a custom format.  Subversion
        developers have adopted the habit of referring to this latter
        data storage mechanism as <firstterm>FSFS</firstterm>
        <footnote>
          <para>Often pronounced <quote>fuzz-fuzz,</quote> if Jack
            Repenning has anything to say about it.  (This book,
            however, assumes that the reader is thinking
            <quote>eff-ess-eff-ess.</quote>)</para>
        </footnote> 
        &mdash;a versioned filesystem implementation that uses the
        native OS filesystem directly&mdash;rather than via a database
        library or some other abstraction layer&mdash;to store data.</para>
-->
      <para>Subversion unterstützt zwei Optionen für
        das zugrundeliegende Datenspeicherungsverfahren &ndash; oft
        bezeichnet als <quote>das Backend</quote> oder, etwas
        verwirrend, <quote>das (versionierte) Dateisystem</quote>
        &mdash; welches jedes Projektarchiv verwendet. Das eine
        Verfahren speichert alles in einer Berkeley-DB- (oder BDB-)
        Datenbankumgebung; Projektarchive, die dieses Verfahren
        verwenden, werden oft <quote>BDB-basiert</quote> genannt. Das
        andere Verfahren speichert die Daten in gewöhnlichen, flachen
        Dateien, die ein spezielles Format verwenden. Unter
        Subversion-Entwicklern hat sich dafür die Bezeichnung
        <firstterm>FSFS</firstterm>
        <footnote>
          <para>Wenn Jack Repenning gefragt wird, ist die Aussprache
            oft <quote>fass-fass</quote>. (Jedoch geht dieses Buch
            davon aus, dass der Leser <quote>eff-ess-eff-ess</quote>
            denkt)</para>
        </footnote>
        eingebürgert &ndash; eine Implementierung eines versionierten
        Dateisystems, dass direkt das Dateisystem des Betriebssystems
        verwendet &ndash; statt einer Datenbankbibliothek oder einer
        anderen Abstraktionsebene &ndash; um Daten zu speichern</para>

<!--
      <para><xref linkend="svn.reposadmin.basics.backends.tbl-1" />
        gives a comparative overview of Berkeley DB and FSFS
        repositories.</para>
-->
      <para><xref linkend="svn.reposadmin.basics.backends.tbl-1" />
        liefert einen Vergleich zwischen Berkeley-DB- und
        FSFS-Projektarchive.</para>

      <table id="svn.reposadmin.basics.backends.tbl-1">
<!--
        <title>Repository data store comparison</title>
-->
        <title>Vergleich der Projektarchiv-Datenspeicherung</title>
        <tgroup cols="4">
          <thead>
            <row>
<!--
              <entry>Category</entry>
              <entry>Feature</entry>
              <entry>Berkeley DB</entry>
              <entry>FSFS</entry>
-->
              <entry>Kategorie</entry>
              <entry>Funktion</entry>
              <entry>Berkeley DB</entry>
              <entry>FSFS</entry>
            </row>
          </thead>
          <tbody>
            <row>
<!--
              <entry morerows="1">Reliability</entry>
              <entry>Data integrity</entry>
              <entry>When properly deployed, extremely reliable;
                Berkeley DB 4.4 brings auto-recovery</entry>
              <entry>Older versions had some rarely demonstrated, but
                data-destroying bugs</entry>
-->
              <entry morerows="1">Zuverlässigkeit</entry>
              <entry>Unversehrtheit der Daten</entry>
              <entry>Höchst zuverlässig, wenn es richtig aufgesetzt
                wird; Berkeley DB 4.4 bringt automatische
                Wiederherstellung</entry>
              <entry>Ältere Versionen hatten einige selten
                aufgetretene, jedoch datenzerstörende Fehler</entry>
            </row>
            <row>
<!--
              <entry>Sensitivity to interruptions</entry>
              <entry>Very; crashes and permission problems can leave the
                database <quote>wedged,</quote> requiring journaled
                recovery procedures</entry>
              <entry>Quite insensitive</entry>
-->
              <entry>Empfindlichkeit gegenüber Unterbrechungen</entry>
              <entry>Sehr; Abstürze und Berechtigungsprobleme können
                die Datenbank <quote>verklemmt</quote> hinterlassen,
                was eine Wiederherstellung mithilfe des Journals
                erfordert</entry>
              <entry>Ziemlich unempfindlich</entry>
            </row>
            <row>
<!--
              <entry morerows="3">Accessibility</entry>
              <entry>Usable from a read-only mount</entry>
              <entry>No</entry>
              <entry>Yes</entry>
-->
              <entry morerows="3">Zugriffsmöglichkeiten</entry>
              <entry>Benutzbar über eine Laufwerk mit
                Nur-Lese-Zugriff</entry>
              <entry>Nein</entry>
              <entry>Ja</entry>
            </row>
            <row>
<!--
              <entry>Platform-independent storage</entry>
              <entry>No</entry>
              <entry>Yes</entry>
-->
              <entry>Plattformunabhängige Speicherung</entry>
              <entry>Nein</entry>
              <entry>Ja</entry>
            </row>
            <row>
<!--
              <entry>Usable over network filesystems</entry>
              <entry>Generally, no</entry>
              <entry>Yes</entry>
-->
              <entry>Benutzbar über Netz-Dateisysteme</entry>
              <entry>Im Allgemeinen nicht</entry>
              <entry>Ja</entry>
            </row>
            <row>
<!--
              <entry>Group permissions handling</entry>
              <entry>Sensitive to user umask problems; best if accessed
                by only one user</entry>
              <entry>Works around umask problems</entry>
-->
              <entry>Behandlung von Gruppenberechtigungen</entry>
              <entry>Empfindlich für Probleme mit der Benutzer-umask;
                Zugriff am besten nur durch einen Benutzer</entry>
              <entry>Umgeht umask-Probleme</entry>
            </row>
            <row>
<!--
              <entry morerows="2">Scalability</entry>
              <entry>Repository disk usage</entry>
              <entry>Larger (especially if logfiles aren't purged)</entry>
              <entry>Smaller</entry>
-->
              <entry morerows="2">Skalierbarkeit</entry>
              <entry>Plattenplatzbedarf des Projektarchivs</entry>
              <entry>Größer (besonders, wenn Protokolldateien nicht
                gekürzt werden)</entry>
              <entry>Kleiner</entry>
            </row>
            <row>
<!--
              <entry>Number of revision trees</entry>
              <entry>Database; no problems</entry>
              <entry>Some older native filesystems don't scale well with
                thousands of entries in a single directory</entry>
-->
              <entry>Anzahl an Revisionsbäumen</entry>
              <entry>Datenbank; keine Probleme</entry>
              <entry>Einige ältere Dateisysteme lassen sich mit
                tausenden Einträgen in einem Verzeichnis nicht gut
                skalieren</entry>
            </row>
            <row>
<!--
              <entry>Directories with many files</entry>
              <entry>Slower</entry>
              <entry>Faster</entry>
-->
              <entry>Verzeichnisse mit vielen Dateien</entry>
              <entry>Langsamer</entry>
              <entry>Schneller</entry>
            </row>
            <row>
<!--
              <entry morerows="1">Performance</entry>
              <entry>Checking out latest revision</entry>
              <entry>No meaningful difference</entry>
              <entry>No meaningful difference</entry>
-->
              <entry morerows="1">Arbeitsleistung</entry>
              <entry>Auschecken der letzten Revision</entry>
              <entry>Kein spürbarer Unterschied</entry>
              <entry>Kein spürbarer Unterschied</entry>
            </row>
            <row>
<!--
              <entry>Large commits</entry>
              <entry>Slower overall, but cost is amortized across the
                lifetime of the commit</entry>
              <entry>Faster overall, but finalization delay may cause 
                client timeouts</entry>
-->
              <entry>Große Übergaben</entry>
              <entry>Insgesamt langsamer, aber die Kosten amortisieren
                sich über die Dauer der Übergabe</entry>
              <entry>Insgesamt schneller, jedoch können
                Abschlussarbeiten zu Zeitüberschreitungen beim Client
                führen.</entry>
            </row>
          </tbody>
        </tgroup>      
      </table>

<!--
      <para>There are advantages and disadvantages to each of these
        two backend types.  Neither of them is more
        <quote>official</quote> than the other, though the newer FSFS
        is the default data store as of Subversion 1.2.  Both are
        reliable enough to trust with your versioned data.  But as you
        can see in <xref
        linkend="svn.reposadmin.basics.backends.tbl-1" />, the FSFS
        backend provides quite a bit more flexibility in terms of its
        supported deployment scenarios.  More flexibility means you
        have to work a little harder to find ways to deploy it
        incorrectly.  Those reasons&mdash;plus the fact that not using
        Berkeley DB means there's one fewer component in the
        system&mdash;largely explain why today almost everyone uses
        the FSFS backend when creating new repositories.</para>
-->
      <para>Beide dieser Verfahren haben Vor- und Nachteile. Keins
        davon ist <quote>offizieller</quote> als das andere, obwohl
        das neuere FSFS seit Subversion 1.2 das Standardverfahren ist.
        Beide verfügen über die ausreichende Zuverlässigkeit, um ihnen
        Ihre versionierten Daten anzuvertrauen. Doch wie sie in <xref
        linkend="svn.reposadmin.basics.backends.tbl-1" /> sehen
        können, bietet das FSFS-Verfahren bezüglich seiner
        unterstützten Einsatzumgebungen wesentlich mehr Flexibilität.
        Mehr Flexibilität bedeutet, dass Sie sich mehr anstrengen
        müssen, um es falsch einzusetzen. Dies sind die Gründe &ndash;
        hinzu kommt, dass beim Verzicht auf Berkeley DB sich eine
        Komponente weniger im System befindet &ndash; warum heutzutage
        beinahe jeder das FSFS-Verfahren verwendet, wenn neue
        Projektarchive angelegt werden.</para>

<!--
      <para>Fortunately, most programs that access Subversion
        repositories are blissfully ignorant of which backend data
        store is in use.  And you aren't even necessarily stuck with
        your first choice of a data store&mdash;in the event that you
        change your mind later, Subversion provides ways of migrating
        your repository's data into another repository that uses a
        different backend data store.  We talk more about that later
        in this chapter.</para>
-->
      <para>Glücklicherweise interessiert es die meisten Programme
        die auf Subversion-Projektarchive zugreifen nicht, welches
        Speicherverfahren verwendet wird. Außerdem sind Sie mit Ihrer
        ersten Entscheidung für das Speicherverfahren nicht
        notwendigerweise festgelegt &ndash; falls Sie es sich später
        anders überlegen sollten, bietet Subversion Methoden zur
        Migration der Daten im Projektarchiv in ein anderes Projektarchiv,
        das ein unterschiedliches Speicherverfahren verwendet. Wir
        werden das später in diesem Kapitel erörtern.</para>

<!--
      <para>The following subsections provide a more detailed look at
        the available backend data store types.</para>
-->
      <para>Die folgenden Unterabschnitte bieten einen detaillierten
        Blick auf die verfügbaren Speicherverfahren.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.basics.backends.bdb">
        <title>Berkeley DB</title>
        
<!--
        <para>When the initial design phase of Subversion was in
          progress, the developers decided to use Berkeley DB for a
          variety of reasons, including its open source license,
          transaction support, reliability, performance, API
          simplicity, thread safety, support for cursors, and so
          on.</para>
-->
        <para>In der anfänglichen Entwurfsphase von Subversion
          entschieden sich die Entwickler aus einer Reihe von Gründen,
          Berkeley DB zu verwenden. Hierzu zählen die quelloffene
          Lizenz, Transaktionsunterstützung, Zuverlässigkeit,
          Arbeitsleistung, Einfachheit der Programmierschnittstelle,
          Thread-Sicherheit, Cursor-Unterstützung usw.</para>

<!--
        <para>Berkeley DB provides real transaction
          support&mdash;perhaps its most powerful feature.  Multiple
          processes accessing your Subversion repositories don't have
          to worry about accidentally clobbering each other's data.
          The isolation provided by the transaction system is such
          that for any given operation, the Subversion repository code
          sees a static view of the database&mdash;not a database that
          is constantly changing at the hand of some other
          process&mdash;and can make decisions based on that view.  If
          the decision made happens to conflict with what another
          process is doing, the entire operation is rolled back as though
          it never happened, and Subversion gracefully retries the
          operation against a new, updated (and yet still static) view
          of the database.</para>
-->
        <para>Berkeley DB bietet echte Transaktionsunterstützung
          &ndash; vielleicht seine stärkste Funktion. Mehrere
          Prozesse, die auf Ihre Subversion-Projektarchive zugreifen,
          brauchen sich keine Sorgen machen, dass sie sich
          versehentlich gegenseitig die Daten zerschießen. Die durch
          das Transaktiossystem gebotene Isolation bedeutet, dass der
          Subversion-Projektarchiv-Programmcode für jede gegebene
          Operation eine statische Sicht auf die Datenbank hat &ndash;
          keine sich durch die Einflüsse anderer Prozesse ständig
          ändernde Datenbank &ndash; und basierend auf dieser Sicht
          Entscheidungen treffen kann. Falls die getroffene
          Entscheidung zu einem Konflikt damit führt, was eine anderer
          Prozess macht, wird die gesamte Transaktion zurückgerollt,
          als wäre sie nie passiert, und Subversion versucht höflich,
          die Operation mithilfe einer aktualisierten (aber immer noch
          statischen) Sicht der Datenbank erneut durchzuführen.</para>

<!--
        <para>Another great feature of Berkeley DB is <firstterm>hot
          backups</firstterm>&mdash;the ability to back up the
          database environment without taking it
          <quote>offline.</quote> We'll discuss how to back up your
          repository later in this chapter (in <xref
          linkend="svn.reposadmin.maint.backup"/>), but the benefits
          of being able to make fully functional copies of your
          repositories without any downtime should be obvious.</para>
-->
        <para>Eine weitere großartige Funktion von Berkeley DB sind
          <firstterm>Hot Backups</firstterm> &ndash; die Fähigkeit,
          die Datenbankumgebung zu sichern, ohne sie <quote>vom
          Netz</quote> zu nehmen. Wir besprechen später in diesem
          Kapitel, wie Sie Ihr Projektarchiv sichern (in <xref
          linkend="svn.reposadmin.maint.backup"/>), doch sollten die
          Vorteile offensichtlich sein, die dadurch entstehen, dass
          Sie vollständige Sicherheitskopien Ihrer Projektarchive ohne
          Wartungszeiträume machen können.</para>

<!--
        <para>Berkeley DB is also a very reliable database system when
          properly used.  Subversion uses Berkeley DB's logging
          facilities, which means that the database first writes to
          on-disk logfiles a description of any modifications it is
          about to make, and then makes the modification itself.  This
          is to ensure that if anything goes wrong, the database
          system can back up to a previous
          <firstterm>checkpoint</firstterm>&mdash;a location in the
          logfiles known not to be corrupt&mdash;and replay
          transactions until the data is restored to a usable state.
          See <xref linkend="svn.reposadmin.maint.diskspace"/> later
          in this chapter for more about Berkeley DB logfiles.</para>
-->
        <para>Bei Berkeley DB handelt es sich auch um ein sehr
          zuverlässiges Datenbanksystem, wenn es richtig verwendet
          wird. Subversion benutzt das Protokollierungssystem von
          Berkeley DB, was bedeutet, dass die Datenbank zunächst eine
          Beschreibung der Veränderungen in Protokolldateien auf der
          Platte schreibt, bevor die Veränderungen selbst durchgeführt
          werden. Dies stellt sicher, dass, falls etwas schief geht,
          die Datenbank zu einem früheren
          <firstterm>Sicherungspunkt</firstterm> zurückgehen kann
          &ndash; eine Stelle in den Protokolldateien, von der bekannt
          ist, dass sie eine nicht beschädigte Datenbank bezeichnet
          &ndash; und Transaktionen solange wiederholen kann, bis die
          Daten sich wieder in einem brauchbaren zustand befinden.
          Siehe <xref linkend="svn.reposadmin.maint.diskspace"/>
          weiter unten in diesem Kapitel für weitere Informationen zu
          Berkeley-DB-Protokolldateien.</para>

<!--
        <para>But every rose has its thorn, and so we must note some
          known limitations of Berkeley DB.  First, Berkeley DB
          environments are not portable.  You cannot simply copy a
          Subversion repository that was created on a Unix system onto
          a Windows system and expect it to work.  While much of the
          Berkeley DB database format is architecture-independent,
          other aspects of the environment are not.
          Second, Subversion uses Berkeley DB in a way that will not
          operate on Windows 95/98 systems&mdash;if you need to house
          a BDB-backed repository on a Windows machine, stick with
          Windows 2000 or later.</para>
-->
        <para>Doch keine Rose ohne Dornen, uns so müssen wir auch
          einige bekannte Einschränkungen von Berkeley DB ansprechen.
          Erstens sind Berkeley-DB -Umgebungen nicht portierbar. Sie
          können nicht einfach ein unter Unix erzeugtes
          Subversion-Projektarchiv auf ein Windows-System kopieren und
          erwarten, dass es funktioniert. Obwohl ein Großteil des
          Berkeley-DB-Datenbankformats architekturunabhängig ist, sind
          es andere Teile der Umgebung nicht. Zweitens benutzt
          Subversion Berkeley DB auf eine Weise, die nicht auf Windows
          95/98 funktioniert &ndash; falls Sie ein BDB-basiertes
          Projektarchiv auf einer Windows-Maschine unterbringen müssen,
          bleiben Sie bei Windows 2000 oder einem seiner
          Nachfolger.</para>

<!--
        <para>While Berkeley DB promises to behave correctly on
          network shares that meet a particular set of specifications,
          <footnote>
            <para>Berkeley DB requires that the underlying filesystem
              implement strict POSIX locking semantics, and more
              importantly, the ability to map files directly into
              process memory.</para>
          </footnote>
          most networked filesystem types and appliances do
          <emphasis>not</emphasis> actually meet those requirements.
          And in no case can you allow a BDB-backed repository that
          resides on a network share to be accessed by multiple
          clients of that share at once (which quite often is the
          whole point of having the repository live on a network share
          in the first place).</para>
-->
        <para>Obwohl Berkeley DB verspricht, sich korrekt auf
          freigegebenen Netzlaufwerken zu verhalten, die bestimmte
          Anforderungen erfüllen,
          <footnote>
            <para>Berkeley DB setzt voraus, dass das zugrundeliegende
              Dateisystem strenge POSIX-Sperrmechanismen implementiert
              und, noch wichtiger, die Fähigkeit mitbringt, Dateien
              direkt in den Prozessspeicher abzubilden.</para>
          </footnote> bieten die meisten Netz-Dateisysteme
          <emphasis>keine</emphasis> derartige Unterstützung. Und
          keinesfalls dürfen Sie zulassen, dass gleichzeitig von
          mehreren Clients auf ein BDB-basiertes Projektarchiv auf einer
          Netzfreigabe zugegriffen wird (was eigentlich der Hauptgrund
          dafür ist, das Projektarchiv auf einer Netzfreigabe
          unterzubringen).</para>

<!--
        <warning>
          <para>If you attempt to use Berkeley DB on a noncompliant
            remote filesystem, the results are unpredictable&mdash;you
            may see mysterious errors right away, or it may be months
            before you discover that your repository database is
            subtly corrupted.  You should strongly consider using the
            FSFS data store for repositories that need to live on a
            network share.</para>
        </warning>
-->
        <warning>
          <para>Falls Sie versuchen sollten, Berkeley DB auf einem
            Netz-Dateisystem unterzubringen, das die Anforderungen
            nicht erfüllt, ist das Ergebnis unvorhersehbar &ndash; es
            kann sein, dass Sie sofort mysteriöse Fehler wahrnehmen
            oder es kann Monate dauern, bis Sie bemerken, dass Ihre
            Projektarchiv-Datenbank fast unmerklich beschädigt ist. Sie
            sollten ernsthaft erwägen, das FSFS-Speicherverfahren für
            Projektarchive zu verwenden, die auf einer Netzfreigabe
            untergebracht werden sollen.</para>
        </warning>

<!--
        <para>Finally, because Berkeley DB is a library linked
          directly into Subversion, it's more sensitive to
          interruptions than a typical relational database system.
          Most SQL systems, for example, have a dedicated server
          process that mediates all access to tables.  If a program
          accessing the database crashes for some reason, the database
          daemon notices the lost connection and cleans up any mess
          left behind.  And because the database daemon is the only
          process accessing the tables, applications don't need to
          worry about permission conflicts.  These things are not the
          case with Berkeley DB, however.  Subversion (and programs
          using Subversion libraries) access the database tables
          directly, which means that a program crash can leave the
          database in a temporarily inconsistent, inaccessible state.
          When this happens, an administrator needs to ask Berkeley DB
          to restore to a checkpoint, which is a bit of an annoyance.
          Other things can cause a repository to <quote>wedge</quote>
          besides crashed processes, such as programs conflicting over
          ownership and permissions on the database files.</para>
-->
        <para>Schließlich ist Berkeley DB empfindlicher gegenüber
          Unterbrechungen als ein typisches relationales
          Datenbanksystem, da es sich um eine Bibliothek handelt, die
          direkt in Subversion eingebunden ist. Beispielsweise haben
          die meisten SQL-Systeme einen dedizierten Server-Prozess,
          der alle Tabellenzugriffe vermittelt. Falls ein auf die
          Datenbank zugreifendes Programm aus irgendeinem Grund
          abstürzt, bemerkt der Datenbank-Dämon die verlorene
          Verbindung und räumt anschließend auf. Und da der
          Datenbank-Dämon der einzige Prozess ist, der auf die
          Tabellen zugreift, brauchen sich Anwendungsprogramme nicht
          um Berechtigungskonflikte zu kümmern. Das trifft allerdings
          nicht auf Berkeley DB zu. Subversion (und jedes Programm,
          das die Subversion-Bibliotheken verwendet) greift direkt auf
          die Datenbanktabellen zu, was bedeutet, dass ein
          Programmabsturz die Datenbank vorübergehend in einem
          inkonsistenten, nicht zugreifbaren Zustand hinterlassen
          kann, so dass ein Administrator Berkeley DB dazu auffordern
          muss, zu einem Sicherungspunkt zurückzugehen, was etwas
          ärgerlich ist. Neben abgestürzten Prozessen können andere
          Dinge das Projektarchiv <quote>verklemmen</quote>, wie etwa
          Programme, die sich wegen Eigentums- und Zugriffsrechten auf
          Datenbankdateien ins Gehege kommen.</para>

        <note>
<!--
          <para>Berkeley DB 4.4 brings (to Subversion 1.4 and later)
            the ability for Subversion to automatically and
            transparently recover Berkeley DB environments in need of
            such recovery.  When a Subversion process attaches to a
            repository's Berkeley DB environment, it uses some process
            accounting mechanisms to detect any unclean disconnections
            by previous processes, performs any necessary recovery,
            and then continues on as though nothing happened.  This
            doesn't completely eliminate instances of repository
            wedging, but it does drastically reduce the amount of
            human interaction required to recover from them.</para>
        </note>
-->
          <para>Berkeley DB 4.4 bietet (für Subversion 1.4 und spätere
            Versionen) die Fähigkeit, dass Subversion falls erforderlich
            automatisch und transparent Berkeley-DB-Umgebungen 
            wiederherstellt. Wenn sich ein Subversion-Prozess an die
            Berkeley-DB-Umgebung hängt, verwendet er eine Art
            Prozess-Buchhaltung, um unsaubere Verbindungsabbrüche
            früherer Prozesse zu entdecken, führt die notwendige
            Wiederherstellung durch und fährt fort, als wäre nichts
            passiert. Dies verhindert das Vorkommen von Verklemmungen
            zwar nicht vollständig, verringert allerdings erheblich
            den Aufwand an menschlichen Eingriffen, um sich hiervon zu
            erholen.</para>
        </note>

<!--
        <para>So while a Berkeley DB repository is quite fast and
          scalable, it's best used by a single server process running
          as one user&mdash;such as Apache's <command>httpd</command>
          or <command>svnserve</command> (see <xref
          linkend="svn.serverconfig"/>)&mdash;rather than accessing it
          as many different users via <literal>file://</literal> or
          <literal>svn+ssh://</literal> URLs.  If you're accessing a Berkeley
          DB repository directly as multiple users, be sure to read
          <xref linkend="svn.serverconfig.multimethod"/> later in this
          chapter.</para>
-->
        <para>Während ein Berkeley-DB-Projektarchiv ziemlich schnell und
          skalierbar ist, wird es am besten von einem einzelnen
          Server-Prozess unter einer Benutzerkennung verwendet &ndash;
          so wie Apaches <command>httpd</command> oder
          <command>svnserve</command> (siehe <xref
          linkend="svn.serverconfig"/>) &ndash; statt darauf mit
          mehreren Benutzern über <literal>file://</literal> oder
          <literal>svn+ssh://</literal> URLs zuzugreifen.  Falls Sie
          mit mehreren Benutzern direkt auf ein Berkeley-DB-Projektarchiv
          zugreifen wollen, sollten Sie unbedingt <xref
          linkend="svn.serverconfig.multimethod"/> weiter unten in
          diesem Kapitel lesen.</para>

      </sect3>
      
      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.basics.backends.fsfs">
        <title>FSFS</title>

<!--
        <para>In mid-2004, a second type of repository storage
          system&mdash;one that doesn't use a database at
          all&mdash;came into being.  An FSFS repository stores the
          changes associated with a revision in a single file, and so
          all of a repository's revisions can be found in a single
          subdirectory full of numbered files.  Transactions are
          created in separate subdirectories as individual files.
          When complete, the transaction file is renamed and moved
          into the revisions directory, thus guaranteeing that commits
          are atomic.  And because a revision file is permanent and
          unchanging, the repository also can be backed up while
          <quote>hot,</quote> just like a BDB-backed
          repository.</para>
-->
        <para>Mitte 2004 entstand ein zweiter Typ eines
          Projektarchiv-Speichersystems &ndash; eins, das überhaupt keine
          Datenbank verwendet. Ein FSFS-Projektarchiv speichert die zu
          einer Revision gehörenden Änderungen in einer einzelnen
          Datei, so dass sich alle Revisionen eines Projektarchivs in
          einem Verzeichnis voller nummerierter Dateien befinden.
          Transaktionen werden als individuelle Dateien in getrennten
          Verzeichnissen erzeugt. Sobald sie vollständig ist, wird die
          Transaktionsdatei umbenannt und in das Revisionsverzeichnis
          verschoben, so dass die Atomizität von Übergaben
          gewährleistet ist. Und da eine Revisionsdatei dauerhaft und
          unveränderlich ist, kann das Projektarchiv auch im laufenden
          Betrieb gesichert werden, genauso wie ein BDB-basiertes
          Projektarchiv.</para>

<!--
        <para>The FSFS revision files describe a revision's
          directory structure, file contents, and deltas against files
          in other revision trees.  Unlike a Berkeley DB database,
          this storage format is portable across different operating
          systems and isn't sensitive to CPU architecture.  Because
          no journaling or shared-memory files are being used, the
          repository can be safely accessed over a network filesystem
          and examined in a read-only environment.  The lack of
          database overhead also means the overall repository
          size is a bit smaller.</para>
-->
        <para>Die FSFS-Revisionsdateien beschreiben die
          Verzeichnisstruktur einer Revision, Dateiinhalte und Deltas
          zu Dateien in anderen Revisionsbäumen. Anders als eine
          Berkeley-DB-Datenbank, ist dieses Speicherformat auf
          verschiedene Betriebssysteme übertragbar und nicht von einer
          CPU-Architektur abhängig. Da weder Journaldateien noch
          Dateien für gemeinsam benutzten Speicher verwendet werden,
          kann auf das Projektarchiv sicher über ein Netzdateisystem
          zugegriffen und es in einer Nur-Lese-Umgebung untersucht
          werden. Das Fehlen der Datenbankverwaltung bedeutet
          ebenfalls eine etwas geringere Größe des Projektarchivs.</para>

<!--
        <para>FSFS has different performance characteristics, too.
          When committing a directory with a huge number of files,
          FSFS is able to more quickly append directory entries.  On
          the other hand, FSFS writes the latest version of a file as
          a delta against an earlier version, which means that
          checking out the latest tree is a bit slower than fetching
          the full-texts stored in a Berkeley DB HEAD revision.  FSFS
          also has a longer delay when finalizing a commit, which
          could in extreme cases cause clients to time out while
          waiting for a response.</para>
-->
        <para>FSFS hat auch eine unterschiedliche Charakteristik, was
          den Durchsatz anbelangt. Wenn eine große Zahl an Dateien
          übergeben wird, kann FSFS schneller Verzeichniseinträge
          hinzufügen. Andererseits schreibt FSFS die letzte Version
          einer Datei als ein Delta gegenüber einer älteren Version,
          was bedeutet, dass das Auschecken des letzten Baums etwas
          langsamer ist als die vollständigen Texte zu holen, die in
          einer Berkeley-DB HEAD-Revision gespeichert sind. FSFS hat
          auch eine längere Verzögerung beim Fertigstellen einer
          Übergabe, was im Extremfall dazu führen kann, dass bei
          Clients Zeitüberschreitungen beim Warten auf eine Antwort
          auftreten.</para>

<!--
        <para>The most important distinction, however, is FSFS's
          imperviousness to wedging when something goes wrong.  If a
          process using a Berkeley DB database runs into a permissions
          problem or suddenly crashes, the database can be left in an
          unusable state until an administrator recovers it.  If the
          same scenarios happen to a process using an FSFS repository,
          the repository isn't affected at all.  At worst, some
          transaction data is left behind.</para>
-->
        <para>Der wichtigste Unterschied jedoch ist die
          Unempfänglichkeit von FSFS gegenüber Verklemmungen, wenn
          etwas schief geht. Falls ein Prozess, der eine
          Berkeley-DB-Datenbank benutzt, ein Berechtigungsproblem
          bekommt oder plötzlich abstürzt, kann das die Datenbank in
          einen unbrauchbaren Zustand bringen, bis ein Administrator
          sie wiederherstellt. Falls ein Prozess, der ein
          FSFS-Projektarchiv benutzt, in dieselbe Situation gerät, ist
          das Projektarchiv hiervon überhaupt nicht betroffen. Das
          Schlimmste, was passieren kann, ist, dass einige
          Transaktionsdaten nicht abgearbeitet werden können.</para>

<!--
        <para>The only real argument against FSFS is its relative
          immaturity compared to Berkeley DB.  Unlike Berkeley DB,
          which has years of history, its own dedicated development
          team, and, now, Oracle's mighty name attached to it,
          <footnote>
            <para>Oracle bought Sleepycat and its flagship software,
              Berkeley DB, on Valentine's Day in 2006.</para>
          </footnote>
          FSFS is a newer bit of engineering.  Prior to Subversion
          1.4, it was still shaking out some pretty serious data
          integrity bugs, which, while triggered in only very rare
          cases, nonetheless did occur.  That said, FSFS has quickly
          become the backend of choice for some of the largest public
          and private Subversion repositories, and it promises a lower
          barrier to entry for Subversion across the board.</para>
-->
        <para>Das einzige echte Argument, was gegen FSFS spricht, ist
          seine relative Unreife im Gegensatz zu Berkeley DB. Anders
          als Berkeley DB, das auf eine jahrelange Geschichte
          zurückblicken kann, ein eigenes Entwicklerteam hat und sich
          nun mit dem mächtigen Namen Oracle schmücken darf,
          <footnote>
            <para>Oracle kaufte Sleepycat und sein Vorzeigeprogramm,
              Berkeley DB, am Valentinstag 2006.</para>
          </footnote>
          ist FSFS eine neuere Technik. Vor Subversion 1.4 purzelten
          immer noch einige ernsthafte Fehler in Bezug auf die
          Unversehrtheit der Daten heraus, die, obwohl sie sehr selten
          ausgelöst wurden, dennoch auftraten.  Nichtsdestoweniger
          ist FSFS schnell zum Speicherverfahren der Wahl für einige
          der größten öffentlichen und privaten Subversion-Projektarchive
          geworden und verspricht durch die Bank eine niedrigere
          Einstiegshürde für Subversion.</para>

      </sect3>
    </sect2>

  </sect1>
 
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.create">
<!--
    <title>Creating and Configuring Your Repository</title>
-->
    <title>Anlegen und konfigurieren Ihres Projektarchivs</title>

<!--
    <para>Earlier in this chapter (in <xref linkend="svn.reposadmin.planning" />), we
      looked at some of the important decisions that should be made
      before creating and configuring your Subversion repository.
      Now, we finally get to get our hands dirty!  In this section,
      we'll see how to actually create a Subversion repository and
      configure it to perform custom actions when special repository
      events occur.</para>
-->
    <para>Weiter oben in diesem Kapitel (in <xref
      linkend="svn.reposadmin.planning" />), schauten wir auf einige
      der wichtigen Entscheidungen, die zu treffen sind, bevor Ihr
      Subversion-Projektarchiv angelegt und konfiguriert wird. Jetzt
      schaffen wir es endlich, uns die Hände schmutzig zu machen! In
      diesem Abschnitt werden wir sehen, wie ein Subversion-Projektarchiv
      überhaupt angelegt wird und wie es konfiguriert wird, damit es
      bei bestimmten Projektarchiv-Ereignissen spezielle Aktionen
      ausführt.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.creating">
<!--
      <title>Creating the Repository</title>
-->
      <title>Anlegen des Projektarchivs</title>
 
<!--
      <para>Subversion repository creation is an incredibly simple
        task.  The <command>svnadmin</command> utility that comes with
        Subversion provides a subcommand (<command>svnadmin
        create</command>) for doing just that.</para>
-->
      <para>Das Anlegen eines Subversion-Projektarchivs ist eine
        unglaublich einfache Aufgabe. Das mit Subversion gelieferte
        Dienstprogramm <command>svnadmin</command> stellt ein
        Unterbefehl (<command>svnadmin create</command>) zur
        Verfügung, der genau das macht.</para>

<!--
      <screen>
$ # Create a repository
$ svnadmin create /var/svn/repos
$
</screen>
-->
      <screen>
$ # Ein Projektarchiv anlegen
$ svnadmin create /var/svn/repos
$
</screen>

<!--
      <para>This creates a new repository in the directory
        <filename>/var/svn/repos</filename>, and with the default
        filesystem data store.  Prior to Subversion 1.2, the default
        was to use Berkeley DB; the default is now FSFS.  You can
        explicitly choose the filesystem type using the
        <option>- -fs-type</option> argument, which accepts as a
        parameter either <literal>fsfs</literal> or
        <literal>bdb</literal>.</para>
-->
      <para>Damit wird ein neues Projektarchiv im Verzeichnis
        <filename>/var/svn/repos</filename> mit dem
        Standard-Speicherverfahren angelegt. Vor Subversion 1.2 war es
        Berkeley DB, nun ist es FSFS.  Sie können den Dateisystemtypen
        ausdrücklich wählen, indem Sie das Argument
        <option>--fs-type</option> benutzen, das als Parameter
        entweder <literal>fsfs</literal> oder <literal>bdb</literal>
        zulässt.</para>

<!--
      <screen>
$ # Create an FSFS-backed repository
$ svnadmin create - -fs-type fsfs /var/svn/repos
$
</screen>
-->
      <screen>
$ # Ein FSFS-basiertes Projektarchiv anlegen
$ svnadmin create --fs-type fsfs /var/svn/repos
$
</screen>

<!--
      <screen>
# Create a Berkeley-DB-backed repository
$ svnadmin create - -fs-type bdb /var/svn/repos
$
</screen>
-->
      <screen>
# Ein Berkeley-DB-basiertes Projektarchiv anlegen
$ svnadmin create --fs-type bdb /var/svn/repos
$
</screen>

<!--
      <para>After running this simple command, you have a Subversion
        repository.</para>
-->
      <para>Nach dem Ausführen dieses einfachen Befehls haben Sie ein
        Subversion-Projektarchiv.</para>

      <tip>
<!--
        <para>The path argument to <command>svnadmin</command> is just
          a regular filesystem path and not a URL like the
          <command>svn</command> client program uses when referring to
          repositories.  Both <command>svnadmin</command> and
          <command>svnlook</command> are considered server-side
          utilities&mdash;they are used on the machine where the
          repository resides to examine or modify aspects of the
          repository, and are in fact unable to perform tasks across a
          network.  A common mistake made by Subversion newcomers is
          trying to pass URLs (even <quote>local</quote>
          <literal>file://</literal> ones) to these two programs.</para>
-->
        <para>Das Pfad-Argument zu <command>svnadmin</command> ist
          bloß ein gewöhnlicher Pfad im Dateisystem und kein URL wie
          ihn das Client-Programm <command>svn</command> verwendet, um
          auf Projektarchive zu verweisen. Sowohl
          <command>svnadmin</command> als auch
          <command>svnlook</command> werden als serverseitige
          Dienstprogramme betrachtet &ndash; sie werden auf dem
          Rechner benutzt, auf dem das Projektarchiv untergebracht ist,
          um Aspekte des Projektarchivs zu untersuchen oder zu verändern;
          tatsächlich sind sie nicht in der Lage, Aufgaben über das
          Netz zu erledigen. Ein verbreiteter Fehler von
          Subversion-Neulingen ist der Versuch, URLs (sogar
          <quote>lokale</quote> vom Typ <literal>file://</literal>) an
          diese zwei Programme zu übergeben.</para>
      </tip>

<!--
      <para>Present in the <filename>db/</filename> subdirectory of
        your repository is the implementation of the versioned
        filesystem. Your new repository's versioned filesystem begins
        life at revision 0, which is defined to consist of nothing but
        the top-level root (<filename>/</filename>) directory.
        Initially, revision 0 also has a single revision property,
        <literal>svn:date</literal>, set to the time at which the
        repository was created.</para>
-->
      <para>Im Unterverzeichnis <filename>db/</filename> Ihres
        Projektarchivs befindet sich die Implementierung des
        versionierten Dateisystems. Das Leben des versionierten
        Dateisystems Ihres Projektarchivs beginnt mit Revision 0, die aus
        nichts anderem als dem Wurzelverzeichnis
        (<filename>/</filename>) besteht. Zu Beginn hat die Revision 0
        ein einziges Revisions-Property, <literal>svn:date</literal>,
        das als Wert die Angabe des Zeitpunktes besitzt, zu dem das
        Projektarchiv angelegt wurde.</para>

<!--
      <para>Now that you have a repository, it's time to customize
        it.</para>
-->
      <para>Da Sie nun ein Projektarchiv haben, ist es an der Zeit, es
        anzupassen.</para>

      <warning>
<!--
        <para>While some parts of a Subversion repository&mdash;such
          as the configuration files and hook scripts&mdash;are meant
          to be examined and modified manually, you shouldn't (and
          shouldn't need to) tamper with the other parts of the
          repository <quote>by hand.</quote>  The
          <command>svnadmin</command> tool should be sufficient for
          any changes necessary to your repository, or you can look to
          third-party tools (such as Berkeley DB's tool suite) for
          tweaking relevant subsections of the repository.  Do
          <emphasis>not</emphasis> attempt manual manipulation of your
          version control history by poking and prodding around in
          your repository's data store files!</para>
-->
        <para>Während einige Teile des Projektarchivs &ndash; wie die
          Konfigurationsdateien und Hook-Scripts &ndash; für eine
          manuelle Untersuchung und Bearbeitung gedacht sind, sollten
          Sie nicht (und sie sollten es auch nicht nötig haben) an den
          anderen Teilen des Projektarchivs <quote>händisch</quote>
          herumdoktern. Das Dienstprogramm <command>svnadmin</command>
          sollte für alle notwendigen Änderungen an Ihrem Projektarchiv
          ausreichen; sie können auch Dienstprogramme von
          Drittanbietern (wie das Werkzeugpaket von Berkeley DB)
          verwenden, um in entsprechenden Unterabschnitten des
          Projektarchivs Änderungen vorzunehmen. Versuchen Sie
          <emphasis>nicht</emphasis>, die Historie Ihrer
          Versionskontrolle manuell zu verändern, indem Sie in den
          Speicherdateien des Projektarchivs herumstochern!</para>
          </warning>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.create.hooks">
<!--
      <title>Implementing Repository Hooks</title>
-->
      <title>Erstellen von Projektarchiv-Hooks</title>

<!--
      <para>A <firstterm>hook</firstterm> is a program triggered by
        some repository event, such as the creation of a new revision
        or the modification of an unversioned property.  Some hooks
        (the so-called <quote>pre hooks</quote>) run in advance of a
        repository operation and provide a means by which to both
        report what is about to happen and prevent it from
        happening at all.  Other hooks (the <quote>post hooks</quote>)
        run after the completion of a repository event and are useful
        for performing tasks that examine&mdash;but don't
        modify&mdash;the repository.  Each hook is handed enough
        information to tell what that event is (or was), the specific
        repository changes proposed (or completed), and the username
        of the person who triggered the event.</para>
-->
      <para>Ein <firstterm>Hook</firstterm> (Haken) ist ein Programm,
        das durch einige Projektarchiv-Ereignisse gestartet wird, wie
        etwa die Erzeugung einer neuen Revision oder die Veränderung
        eines unversionierten Propertys. Einige Hooks (die sogenannten
        <quote>Pre-Hooks</quote>) starten vor einer
        Projektarchiv-Operation und bieten eine Möglichkeit sowohl zu
        berichten, was passieren wird, als auch zu verhindern, dass es
        überhaupt passiert. Andere Hooks (die
        <quote>Post-Hooks</quote>) starten nach Abschluss eines
        Projektarchiv-Ereignisses und sind nützlich für Aufgaben, die das
        Projektarchiv inspizieren &ndash; aber nicht verändern. Jedem
        Hook wird ausreichend Information übergeben, damit er
        feststellen kann, um welches Ereignis es sich handelt (oder
        handelte), welche genauen Änderungen am Projektarchiv
        beabsichtigt sind (oder durchgeführt wurden) und wie der Name des
        Benutzers lautet, der das Ereignis ausgelöst hat.</para>

<!--
      <para>The <filename>hooks</filename> subdirectory is, by
        default, filled with templates for various repository
        hooks:</para>
-->
      <para>Das Verzeichnis für die <filename>Hooks</filename> ist
        standardmäßig mit Vorlagen für verschiedene Projektarchiv-Hooks
        gefüllt:</para>

      <screen>
$ ls repos/hooks/
post-commit.tmpl          post-unlock.tmpl  pre-revprop-change.tmpl
post-lock.tmpl            pre-commit.tmpl   pre-unlock.tmpl
post-revprop-change.tmpl  pre-lock.tmpl     start-commit.tmpl
$
</screen>

<!--
      <para>There is one template for each hook that the Subversion
        repository supports; by examining the contents of those
        template scripts, you can see what triggers each script
        to run and what data is passed to that script.  Also present
        in many of these templates are examples of how one might use
        that script, in conjunction with other Subversion-supplied
        programs, to perform common useful tasks.  To actually install
        a working hook, you need only place some executable program or
        script into the <filename>repos/hooks</filename> directory,
        which can be executed as the name (such as
        <command>start-commit</command> or
        <command>post-commit</command>) of the hook.</para>
-->
      <para>Es gibt eine Vorlage für jeden Hook, den Subversion
        unterstützt. Sie können sehen, wodurch jedes dieser Scripte
        gestartet wird und welche Daten übergeben werden, indem Sie
        den Inhalt der Scripte inspizieren. In vielen dieser Vorlagen
        befinden sich auch Beispiele dafür, wie dieses Script zusammen
        mit anderen Programmen aus dem Lieferumfang von Subversion
        verwendet werden kann, um häufige, nützliche Aufgaben zu erledigen.
        Um einen funktionierenden Hook zu installieren, brauchen Sie
        nur ein ausführbares Programm oder Script im Verzeichnis
        <filename>repos/hooks</filename> abzulegen, das unter dem
        Namen des Hooks (etwa <command>start-commit</command> oder
        <command>post-commit</command>) gestartet werden kann.</para>

<!--
      <para>On Unix platforms, this means supplying a script or
        program (which could be a shell script, a Python program, a
        compiled C binary, or any number of other things) named
        exactly like the name of the hook.  Of course, the template
        files are present for more than just informational
        purposes&mdash;the easiest way to install a hook on Unix
        platforms is to simply copy the appropriate template file to a
        new file that lacks the <filename>.tmpl</filename> extension,
        customize the hook's contents, and ensure that the script is
        executable.  Windows, however, uses file extensions to
        determine whether a program is executable, so you would
        need to supply a program whose basename is the name of the
        hook and whose extension is one of the special extensions
        recognized by Windows for executable programs, such as
        <filename>.exe</filename> for programs and
        <filename>.bat</filename> for batch files.</para>
-->
      <para>Auf Unix Plattformen bedeutet das, ein Script oder
        Programm bereitzustellen (welches ein Shell-Script, ein
        Python-Programm, ein übersetztes C-Binärprogramm oder
        sonstetwas sein kann), das genauso heißt wie der Hook.
        Natürlich sind die Vorlagen nicht nur zur Information da
        &ndash; die einfachste Möglichkeit, unter Unix einen Hook zu
        installieren, ist es, einfach die passende Vorlagedatei in
        eine Datei zu kopieren, der die Dateiendung
        <filename>.tmpl</filename> fehlt, den Inhalt anzupassen und
        sicherzustellen, dass das Script ausführbar ist. Unter Windows
        werden jedoch Dateiendungen verwendet, um festzustellen, ob
        ein Programm ausführbar ist, so dass Sie ein Programm zur
        Verfügung stellen müssen, dessen Basisname dem Hook entspricht
        und dessen Endung einer derjenigen entspricht, die Windows für
        ausführbare Programme hält, etwa <filename>.exe</filename> für
        Programme und <filename>.bat</filename> für
        Batch-Dateien.</para>

<!--
      <tip>
        <para>For security reasons, the Subversion repository executes
          hook programs with an empty environment&mdash;that is, no
          environment variables are set at all, not even
          <literal>$PATH</literal> (or <literal>%PATH%</literal>,
          under Windows).  Because of this, many administrators
          are baffled when their hook program runs fine by hand, but
          doesn't work when run by Subversion.  Be sure to explicitly
          set any necessary environment variables in your hook program
          and/or use absolute paths to programs.</para>
      </tip>
-->
      <tip>
        <para>Aus Sicherheitsgründen führt Subversion Hook-Programme
          in einer leeren Umgebung aus &ndash; d.h., es sind überhaupt
          keine Umgebungsvariablen gesetzt, nicht einmal
          <literal>$PATH</literal> (oder <literal>%PATH%</literal>
          unter Windows). Deshalb sind viele Administratoren verwirrt,
          wenn deren Hook-Programme normal starten, wenn sie manuell
          aufgerufen werden, aber nicht laufen, wenn sie Subversion
          startet. Stellen Sie sicher, dass Sie entweder alle
          notwendigen Umgebungsvariablen in Ihren Hook-Programmen
          ausdrücklich setzen und/oder absolute Pfade zu Programmen
          verwenden.</para>
        </tip>

<!--
      <para>Subversion executes hooks as the same user who owns the
        process that is accessing the Subversion repository.  In most
        cases, the repository is being accessed via a Subversion
        server, so this user is the same user as whom the server
        runs on the system.  The hooks themselves will need to be
        configured with OS-level permissions that allow that user to
        execute them.  Also, this means that any programs or files
        (including the Subversion repository) accessed directly
        or indirectly by the hook will be accessed as the same user.
        In other words, be alert to potential permission-related
        problems that could prevent the hook from performing the tasks
        it is designed to perform.</para>
-->
      <para>Subversion führt die Hooks unter der Benutzerkennung aus,
        die auch der Prozess besitzt, der auf das Projektarchiv zugreift.
        Meistens wird auf das Projektarchiv über einen Subversion-Server
        zugegriffen, so dass die Benutzerkennung der des
        Serverprozesses entspricht. Die Hooks müssen deshalb mit den
        entsprechenden Berechtigungen des Betriebssystems versehen
        werden, damit diese Benutzerkennung sie ausführen kann. Das
        bedeutet auch, dass der direkte oder indirekte Zugriff auf
        irgendwelche Programme oder Dateien (einschließlich des
        Subversion-Projektarchivs) durch den Hook auch unter derselben
        Kennung erfolgt. Mit anderen Worten: Achten Sie auf mögliche
        Probleme im Zusammenhang mit Zugriffsrechten, die den Hook
        daran hindern könnten, die Ihm zugeteilten Aufgaben
        wahrzunehmen.</para>

<!--
      <para>There are serveral hooks implemented by the Subversion
        repository, and you can get details about each of them in
        <xref linkend="svn.ref.reposhooks" />.  As a repository
        administrator, you'll need to decide which hooks you wish
        to implement (by way of providing an appropriately named and
        permissioned hook program), and how.  When you make this
        decision, keep in mind
        the big picture of how your repository is deployed.
        For example, if you are using server configuration
        to determine which users are permitted to commit
        changes to your repository, you don't need to do this
        sort of access control via the hook system.</para>
-->
      <para>Es gibt mehrere im Subversion-Projektarchiv implementierte
        Hooks; Details zu jedem können Sie in <xref
        linkend="svn.ref.reposhooks" /> nachlesen. Als
        Projektarchiv-Administrator müssen Sie entscheiden, welche Hooks
        sie einrichten wollen (indem Sie ein entsprechend benanntes
        und mit den nötigen Zugriffsrechten versehenes Hook-Programm
        bereitstellen) und wie Sie sie einsetzen wollen. Wenn Sie diese Entscheidung
        treffen, dann behalten Sie das Gesamtbild des
        Projektarchiv-Einsatzes im Auge.  Wenn Sie beispielsweise die
        Konfiguration des Servers verwenden, um festzustellen, welche
        Benutzer Änderungen an Ihr Projektarchiv übergeben dürfen,
        benötigen Sie für diese Zugriffskontrolle nicht das
        Hook-System.</para>

<!--
      <para>There is no shortage of Subversion hook programs and
        scripts that are freely available either from the Subversion community
        itself or elsewhere.  These scripts cover a wide range of
        utility&mdash;basic access control, policy adherence checking,
        issue tracker integration, email- or syndication-based commit
        notification, and beyond.  Or, if you wish to write your own,
        see <xref linkend="svn.developer" />.</para>
-->
      <para>Es gibt keinen Mangel an Subversion-Hook-Programmen und
        Scripten, die frei verfügbar sind, entweder von der
        Subversion-Gemeinschaft oder von woanders her. Diese Scripte
        decken ein breites Spektrum ab &ndash; grundlegende
        Zugriffskontrolle, Kontrolle der Prozesstreue,
        Fehlersystemanbindung, E-Mail-basierte oder syndizierte
        Benachrichtigungen bei Übergaben und noch viel mehr. Oder,
        falls Sie Ihren eigenen schreiben wollen, siehe <xref
        linkend="svn.developer" />.</para>

<!--
      <warning>
        <para>While hook scripts can do almost
          anything, there is one dimension in which hook script
          authors should show restraint:  do <emphasis>not</emphasis>
          modify a commit transaction using hook scripts.  While it
          might be tempting to use hook scripts to automatically
          correct errors, shortcomings, or policy violations present
          in the files being committed, doing so can cause problems.
          Subversion keeps client-side caches of certain bits of
          repository data, and if you change a commit transaction in
          this way, those caches become indetectably stale.  This
          inconsistency can lead to surprising and unexpected
          behavior.  Instead of modifying the transaction, you should
          simply <emphasis>validate</emphasis> the transaction in the
          <filename>pre-commit</filename> hook and reject the commit
          if it does not meet the desired requirements.  As a
          bonus, your users will learn the value of careful,
          compliance-minded work habits.</para>
      </warning>
-->
      <warning>
        <para>Obwohl Hook-Scripts fast alles machen können, gibt es
          eine Dimension, in der sich Hook-Script-Autoren zurückhalten
          sollten: Ändern Sie <emphasis>keine</emphasis>
          Übergabe-Transaktion mithilfe von Hook-Scripten. Trotz der
          Verlockung, Hook-Scripte zur automatischen Korrektur von
          Fehlern, Unzulänglichkeiten oder Prozessverletzungen
          innerhalb der zu übergebenden Dateien einzusetzen, kann das
          zu Problemen führen. Subversion hält bestimmte
          Projektarchiv-Daten in clientseitigen Caches vor, und wenn Sie
          auf diese Art eine Übergabe-Transaktion verändern, werden
          die im Cache befindlichen Informationen ungültig, ohne dass
          jemand etwas merkt. Diese Inkonsistenz kann zu
          überraschendem und unerwartetem Verhalten führen. Statt die
          Transaktion zu verändern, sollten Sie sie einfach im
          <filename>pre-commit</filename>-Hook auf
          <emphasis>Gültigkeit</emphasis> prüfen und die Übergabe
          ablehnen, falls sie den Anforderungen nicht entspricht. Als
          Nebeneffekt werden Ihre Benutzer lernen, wie wertvoll eine
          sorgfältige, sich an den Vorgaben orientierende Arbeitsweise
          ist.</para>
      </warning>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.create.bdb">
<!--
      <title>Berkeley DB Configuration</title>
-->
      <title>Konfiguration von Berkeley DB</title>

<!--
      <para>A Berkeley DB environment is an encapsulation of one or
        more databases, logfiles, region files, and configuration
        files.  The Berkeley DB environment has its own set of default
        configuration values for things such as the number of database
        locks allowed to be taken out at any given time, the maximum
        size of the journaling logfiles, and so on.  Subversion's
        filesystem logic additionally chooses default values for some
        of the Berkeley DB configuration options.  However, sometimes
        your particular repository, with its unique collection of data
        and access patterns, might require a different set of
        configuration option values.</para>
-->
      <para>Eine Berkeley-DB-Umgebung ist eine Kapselung einer oder
        mehrerer Datenbanken, Protokolldateien, Regionsdateien und
        Konfigurationsdateien. Die Berkeley-DB-Umgebung hat ihre
        eigene Menge an Konfigurationswerten für Dinge wie die
        Maximalzahl von Datenbanksperren zu einem gegebenen Zeitpunkt,
        die Obergrenze für die Größe der Protokolldateien usw.
        Darüberhinaus wählt Subversions Dateisystemlogik Standardwerte
        für einige der Berkeley-DB-Konfigurationsoptionen. Manchmal
        jedoch benötigt Ihr besonderes Projektarchiv, welches eine
        einzigartige Sammlung von Daten und Zugriffsmustern darstellt,
        eine unterschiedliche Menge von Konfigurationswerten.</para>

<!--
      <para>The producers of Berkeley DB understand that different
        applications and database environments have different
        requirements, so they have provided a mechanism for overriding
        at runtime many of the configuration values for the Berkeley
        DB environment.  BDB checks for the presence of a file named
        <filename>DB_CONFIG</filename> in the environment directory
        (namely, the repository's <filename>db</filename>
        subdirectory), and parses the options found in that file.
        Subversion itself creates this file when it creates the rest
        of the repository.  The file initially contains some default
        options, as well as pointers to the Berkeley DB online
        documentation so that you can read about what those options do.  Of
        course, you are free to add any of the supported Berkeley DB
        options to your <filename>DB_CONFIG</filename> file.  Just be
        aware that while Subversion never attempts to read or
        interpret the contents of the file and makes no direct use of
        the option settings in it, you'll want to avoid any
        configuration changes that may cause Berkeley DB to behave in
        a fashion that is at odds with what Subversion might expect.
        Also, changes made to <filename>DB_CONFIG</filename> won't
        take effect until you recover the database environment (using
        <command>svnadmin recover</command>).</para>
-->
      <para>Den Herstellern von Berkeley-DB ist bewusst, dass
        unterschiedliche Anwendungen und Datenbankumgebungen auch
        unterschiedliche Anforderungen haben, so dass sie einen
        Mechanismus zur Verfügung gestellt haben, der es ermöglicht,
        während der Laufzeit viele der Konfigurationseinstellungen für
        die Berkeley-DB-Umgebung zu überschreiben. BDB prüft, ob es
        eine Datei namens  <filename>DB_CONFIG</filename> im
        Umgebungsverzeichnis (das Verzeichnis <filename>db</filename>
        des Projektarchivs) gibt und liest die in dieser Datei
        vorhandenen Optionen. Subversion erzeugt diese Datei selbst,
        wenn der Rest eines Projektarchivs erstellt wird. Anfangs
        beinhaltet diese Datei einige Standardoptionen sowie Verweise
        zur Berkeley-DB-Dokumentation im Netz, so dass Sie
        nachschlagen können, was diese Optionen bewirken.
        Selbstverständlich können Sie beliebige von Berkeley DB
        unterstützte Optionen der Datei <filename>DB_CONFIG</filename>
        hinzufügen. Beachten Sie jedoch, dass Sie es vermeiden
        sollten, obwohl Subversion niemals versucht, den Inhalt der
        Datei zu lesen oder zu interpretieren und auch sonst keinen
        direkten Gebrauch von den dortigen Optionseinstellungen macht,
        die Konfiguration so zu verändern, dass sich Berkeley DB
        anders verhält, als es Subversion erwartet. Die Änderungen an
        <filename>DB_CONFIG</filename> werden außerdem erst nach einer
        Wiederherstellung der Datenbankumgebung (mit <command>svnadmin
        recover</command>) gültig.</para>

    </sect2>
  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.maint">
<!--
    <title>Repository Maintenance</title>
-->
    <title>Projektarchiv-Wartung</title>

<!--
    <para>Maintaining a Subversion repository can be daunting, mostly
      due to the complexities inherent in systems that have a database
      backend.  Doing the task well is all about knowing the
      tools&mdash;what they are, when to use them, and how.  This
      section will introduce you to the repository administration
      tools provided by Subversion and discuss how to wield them to
      accomplish tasks such as repository data migration, upgrades,
      backups, and cleanups.</para>
-->
    <para>Die Wartung eines Subversion-Projektarchivs kann abschreckend
      sein, was an der Komplexität liegt, die Systemen innewohnt, die
      auf Datenbanken aufbauen. Die Arbeit gut zu machen, bedeutet,
      die Werkzeuge zu kennen &ndash; was sie sind, wann sie zu
      verwenden sind und wie. Dieser Abschnitt stellt Ihnen die
      Projektarchiv-Verwaltungswerkzeuge vor, die Subversion mitbringt
      und erörtert, wie sie gehandhabt werden, um Aufgaben zu
      erledigen, wie etwa Projektarchiv-Datenmigration, Aktualisierungen,
      Sicherungen und Aufräumarbeiten.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.tk">
<!--
      <title>An Administrator's Toolkit</title>
-->
      <title>Der Werkzeugkasten eines Administrators</title>

<!--
      <para>Subversion provides a handful of utilities useful for
        creating, inspecting, modifying, and repairing your repository.
        Let's look more closely at each of those tools.  Afterward,
        we'll briefly examine some of the utilities included in the
        Berkeley DB distribution that provide functionality specific
        to your repository's database backend not otherwise provided
        by Subversion's own tools.</para>
-->
      <para>Subversion stellt eine Handvoll Dienstprogramme zur
        Verfügung, die nützlich zum Erstellen, Untersuchen, Verändern
        und Reparieren Ihres Projektarchivs sind. Wir wollen uns diese
        Werkzeuge einmal genauer ansehen. Anschließend werden wir kurz
        einige der zum Berkeley-DB-Paket gehörenden Dienstprogramme
        untersuchen, die auf die Besonderheiten der von Subversion
        verwendeten Datenbank zugeschnittene Funktionen anbieten, die
        mit Subversions eigenen Werkzeugen nicht verfügbar
        sind.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnadmin">
        <title>svnadmin</title>

<!--
        <para>The <command>svnadmin</command> program is the
          repository administrator's best friend.  Besides providing
          the ability to create Subversion repositories, this program
          allows you to perform several maintenance operations on
          those repositories.  The syntax of
          <command>svnadmin</command> is similar to that of other
          Subversion command-line programs:</para>
-->
        <para>Das Programm <command>svnadmin</command> ist der beste
          Freund des Projektarchiv-Administrators. Neben der Fähigkeit,
          Subversion-Projektarchive zu erzeugen, erlaubt Ihnen dieses
          Programm verschiedene Wartungsarbeiten auf diesen
          Projektarchive auszuführen. Die Syntax von
          <command>svnadmin</command> ist ähnlich wie bei anderen
          Kommandozeilenprogrammen von Subversion:</para>

<!--
        <screen>
$ svnadmin help
general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp; OPTIONS ...]
Type 'svnadmin help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnadmin - -version' to see the program version and FS modules.

Available subcommands:
   crashtest
   create
   deltify
&hellip;
</screen>
-->
        <screen>
$ svnadmin help
Aufruf: svnadmin UNTERBEFEHL ARCHIV_PFAD [Optionen &amp; Parameter ...]
Geben Sie »svnadmin help &lt;Unterbefehl&gt;« ein, um Hilfe zu einem Unterbefehl
          zu erhalten.
Geben Sie »svnadmin --version« ein, um die Programmversion und die Datei-
          systemmodule zu sehen.

Verfügbare Unterbefehle:
   crashtest
   create
   deltify
&hellip;
</screen>

<!--
        <para>Previously in this chapter (in <xref
          linkend="svn.reposadmin.basics.creating"/>), we were
          introduced to the <command>svnadmin create</command>
          subcommand.  Most of the other <command>svnadmin</command>
          subcommands we will cover later in this chapter.  And you
          can consult <xref linkend="svn.ref.svnadmin" /> for a full
          rundown of subcommands and what each of them offers.</para>
-->
        <para>Früher in diesem Kapitel (in <xref
          linkend="svn.reposadmin.basics.creating"/>), wurde uns der
          Unterbefehl <command>svnadmin create</command> vorgestellt.
          Die meisten anderen Unterbefehle von
          <command>svnadmin</command> werden wir später in diesem
          Kapitel behandeln. Und in <xref linkend="svn.ref.svnadmin"
          /> können Sie in einer vollständigen Aufstellung der
          Unterbefehle nachlesen, was jeder zu bieten hat.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnlook">
        <title>svnlook</title>

<!--
        <para><command>svnlook</command> is a tool provided by
          Subversion for examining the various revisions and
          <firstterm>transactions</firstterm> (which are revisions
          in the making) in a repository.  No part of this program
          attempts to change the repository.  <command>svnlook</command>
          is typically used by the repository hooks for reporting the
          changes that are about to be committed (in the case of the
          <command>pre-commit</command> hook) or that were just
          committed (in the case of the <command>post-commit</command>
          hook) to the repository.  A repository administrator may use
          this tool for diagnostic purposes.</para>
-->
        <para><command>svnlook</command> ist ein von Subversion
          mitgeliefertes Dienstprogramm zum Untersuchen der
          mannigfaltigen Revisionen und
          <firstterm>Transaktionen</firstterm> (bei denen es sich um
          Revisionen in Entstehung handelt) in einem Projektarchiv. Kein
          Teil dieses Programms versucht, das Projektarchiv zu verändern.
          <command>svnlook</command> wird üblicherweise von
          Projektarchiv-Hooks verwendet, um die abzuliefernden Änderungen
          zu melden (im Fall des <command>pre-commit</command>-Hooks)
          oder die gerade an das Projektarchiv übergeben wurden (im Fall
          des <command>post-commit</command>-hooks). Ein
          Projektarchiv-Administrator kann dieses Programm zur Diagnose
          benutzen.</para>

<!--
        <para><command>svnlook</command> has a straightforward
          syntax:</para>
-->
        <para><command>svnlook</command> besitzt eine überschaubare
          Syntax:</para>

<!--
        <screen>
$ svnlook help
general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]
Note: any subcommand which takes the '- -revision' and '- -transaction'
      options will, if invoked without one of those options, act on
      the repository's youngest revision.
Type 'svnlook help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnlook - -version' to see the program version and FS modules.
&hellip;
</screen>
-->
        <screen>
$ svnlook help
Aufruf: svnlook UNTERBEFEHL ARCHIV_PFAD [Optionen &amp; Parameter ...]
Hinweis: Alle Unterbefehle, die die Parameter »--revision« und »--transaction«
         akzeptieren, werden ohne diese Parameter die neueste
         Revision des Projektarchivs verwenden.
Geben Sie »svnlook help &lt;Unterbefehl&gt;« ein, um Hilfe zu einem Unterbefehl
         zu erhalten.
Geben Sie »svnlook --version« ein, um die Programmversion und die Datei-
         systemmodule zu sehen.
&hellip;
</screen>

<!--
        <para>Most of <command>svnlook</command>'s
          subcommands can operate on either a revision or a
          transaction tree, printing information about the tree
          itself, or how it differs from the previous revision of the
          repository.  You use the <option>- -revision</option>
          (<option>-r</option>) and <option>- -transaction</option>
          (<option>-t</option>) options to specify which revision or
          transaction, respectively, to examine.  In the absence of
          both the <option>- -revision</option> (<option>-r</option>)
          and <option>- -transaction</option> (<option>-t</option>)
          options, <command>svnlook</command> will examine the
          youngest (or <literal>HEAD</literal>) revision in the
          repository.  So the following two commands do exactly the
          same thing when 19 is the youngest revision in the
          repository located at
          <filename>/var/svn/repos</filename>:</para>
-->
        <para>Die meisten Unterbefehle von <command>svnlook</command>
          können entweder auf einem Revisions- oder auf einem
          Transaktionsbaum arbeiten, indem sie Informationen über den
          Baum an sich ausgeben oder darüber, inwiefern er sich von
          einer früheren Revision des Projektarchivs unterscheidet. Sie
          verwenden die Optionen <option>--revision</option>
          (<option>-r</option>) und <option>--transaction</option>
          (<option>-t</option>), um die zu untersuchende Revision bzw.
          Transaktion anzugeben. Ohne eine der Optionen
          <option>--revision</option> (<option>-r</option>) und
          <option>--transaction</option> (<option>-t</option>)
          untersucht Subversion die jüngste (oder
          <literal>HEAD</literal>) Revision des Projektarchivs. Das
          heißt, die beiden folgenden Befehle machen genau dasselbe,
          wenn 19 die jüngste Revision im Projektarchiv unter
          <filename>/var/svn/repos</filename> ist:</para>

        <screen>
$ svnlook info /var/svn/repos
$ svnlook info /var/svn/repos -r 19
</screen>

<!--
        <para>One exception to these rules about subcommands is
          the <command>svnlook youngest</command> subcommand, which
          takes no options and simply prints out the repository's
          youngest revision number:</para>
-->
        <para>Eine Ausnahme von diesen Regeln zu Unterbefehlen ist der
          Unterbefehl <command>svnlook youngest</command>, der keine
          Optionen entgegennimmt und einfach die jüngste
          Revisionsnummer des Projektarchivs ausgibt:</para>

        <screen>
$ svnlook youngest /var/svn/repos
19
$
</screen>

        <note>
<!--
          <para>Keep in mind that the only transactions you can browse
            are uncommitted ones.  Most repositories will have no such
            transactions because transactions are usually either
            committed (in which case, you should access them as
            revision with the <option>- -revision</option>
            (<option>-r</option>) option) or aborted and
            removed.</para>
-->
          <para>Beachten Sie, dass Sie nur Transaktionen untersuchen
            können, die noch nicht übergeben sind. Die meisten
            Projektarchive haben keine derartigen Transaktionen, da
            Transaktionen entweder übergeben (in diesem Fall sollten
            Sie darauf mit der Option <option>--revision</option>
            (<option>-r</option>) zugreifen) oder abgebrochen und
            entfernt sind.</para>
        </note>
            
<!--
        <para>Output from <command>svnlook</command> is designed to be
          both human- and machine-parsable.  Take, as an example, the
          output of the <command>svnlook info</command> subcommand:</para>
-->
        <para>Die Ausgabe <command>svnlook</command> ist so gestaltet,
          dass sie sowohl für Menschen als auch für Maschinen lesbar
          ist. Nehmen wir zum Beispiel die Ausgabe des Unterbefehls
          <command>svnlook info</command>:</para>

        <screen>
$ svnlook info /var/svn/repos
sally
2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)
43
Den üblichen griechischen
Baum hinzugefügt.
$
</screen>

<!--
        <para>The output of <command>svnlook info</command> consists
          of the following, in the order given:</para>
-->
        <para>Die Ausgabe von <command>svnlook info</command> besteht
          aus dem Folgenden in entsprechender Reihenfolge:</para>

        <orderedlist>
          <listitem>
<!--
            <para>The author, followed by a newline</para>
-->
            <para>Der Autor gefolgt von einem Zeilenvorschub</para>
          </listitem>
          <listitem>
<!--
            <para>The date, followed by a newline</para>
-->
            <para>Das Datum gefolgt von einem Zeilenvorschub</para>
          </listitem>
          <listitem>
<!--
            <para>The number of characters in the log message,
              followed by a newline</para>
-->
            <para>Die Anzahl der Zeichen der Protokollnachricht
              gefolgt von einem Zeilenvorschub.</para>
          </listitem>
          <listitem>
<!--
            <para>The log message itself, followed by a newline</para>
-->
            <para>Die eigentliche Protokollnachricht gefolgt von einem
              Zeilenvorschub</para>
          </listitem>
        </orderedlist>

<!--
        <para>This output is human-readable, meaning items such as the
          datestamp are displayed using a textual representation
          instead of something more obscure (such as the number of
          nanoseconds since the Tastee Freez guy drove by).  But the
          output is also machine-parsable&mdash;because the log
          message can contain multiple lines and be unbounded in
          length, <command>svnlook</command> provides the length of
          that message before the message itself.  This allows scripts
          and other wrappers around this command to make intelligent
          decisions about the log message, such as how much memory to
          allocate for the message, or at least how many bytes to skip
          in the event that this output is not the last bit of data in
          the stream.</para>
-->
        <para>Diese Ausgabe ist für Menschen lesbar, d.h., Dinge wie
          der Zeitstempel werden als Text dargestellt statt als
          irgendetwas Obskures (wie die Anzahl der Nanosekunden seit
          der Mann von Bofrost das letzte Mal da war). Jedoch ist die
          Ausgabe auch maschinenlesbar &ndash; weil die
          Protokollnachricht mehrere Zeilen umfassen und von der Länge
          her unbegrenzt sein kann, liefert <command>svnlook</command>
          die Länge der Nachricht vor der eigentlichen Nachricht. Das
          erlaubt Scripten und anderen Programmen, die um diesen
          Befehl herumgeschrieben wurden, intelligente Entscheidungen
          in Bezug auf die Protokollnachricht zu treffen, etwa wieviel
          Speicher für die Nachricht anzufordern ist oder zumindest
          wieviele Bytes zu überspringen sind, falls diese Ausgabe
          nicht das letzte Stück im Datenstrom sein sollte.</para>

<!--
        <para><command>svnlook</command> can perform a variety of
          other queries:  displaying subsets of bits of information
          we've mentioned previously, recursively listing versioned
          directory trees, reporting which paths were modified in a
          given revision or transaction, showing textual and property
          differences made to files and directories, and so on.  See
          <xref linkend="svn.ref.svnlook" /> for a full reference of
          <command>svnlook</command>'s features.</para>
-->
        <para><command>svnlook</command> kann eine Auswahl anderer
          Abfragen ausführen: Teilmengen der bereits erwähnten
          Informationen ausgeben, versionierte Verzeichnisbäume
          rekursiv auflisten, berichten, welche Pfade in einer
          bestimmten Revision oder Transaktion verändert wurden,
          textuelle und property-basierte Unterschiede an Dateien und
          Verzeichnissen aufzeigen, usw. Siehe <xref
          linkend="svn.ref.svnlook" /> für eine vollständige Referenz
          der Funktionen von <command>svnlook</command>.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svndumpfilter">
        <title>svndumpfilter</title>

<!--
        <para>While it won't be the most commonly used tool at the
          administrator's disposal, <command>svndumpfilter</command>
          provides a very particular brand of useful
          functionality&mdash;the ability to quickly and easily modify
          streams of Subversion repository history data by acting as a
          path-based filter.</para>
-->
        <para>Obwohl es nicht das am meisten verwendete Werkzeug im
          Sortiment des Administrators sein wird, bietet
          <command>svndumpfilter</command> eine ganz besondere Art von
          nützlichen Funktionen &ndash; die Fähigkeit, schnell und
          einfach Datenströme aus der Projektarchiv-Historie zu
          verändern, indem es als ein pfadbasierter Filter
          arbeitet.</para>

<!--
        <para>The syntax of <command>svndumpfilter</command> is as
          follows:</para>
-->
        <para>Die Syntax von <command>svndumpfilter</command> lautet
          wie folgt:</para>

<!--
        <screen>
$ svndumpfilter help
general usage: svndumpfilter SUBCOMMAND [ARGS &amp; OPTIONS ...]
Type "svndumpfilter help &lt;subcommand&gt;" for help on a specific subcommand.
Type 'svndumpfilter - -version' to see the program version.
  
Available subcommands:
   exclude
   include
   help (?, h)
</screen>
-->
        <screen>
$ svndumpfilter help
Aufruf: svndumpfilter UNTERBEFEHL [Optionen &amp; Parameter ...]
Geben Sie »svndumpfilter help &lt;Unterbefehl&gt;« ein, um Hilfe zu einem
          Unterbefehl zu erhalten.
Geben Sie »svndumpfilter --version« ein, um die Programmversion zu sehen.

Verfügbare Unterbefehle:
   exclude
   include
   help (?, h)
</screen>

<!--
        <para>There are only two interesting subcommands:
          <command>svndumpfilter exclude</command> and
          <command>svndumpfilter include</command>.  They allow you to
          make the choice between implicit or explicit inclusion of
          paths in the stream.  You can learn more about these
          subcommands and <command>svndumpfilter</command>'s unique
          purpose later in this chapter, in <xref
          linkend="svn.reposadmin.maint.filtering" />.</para>
-->
        <para>Es gibt nur zwei interessante Unterbefehle:
          <command>svndumpfilter exclude</command> und
          <command>svndumpfilter include</command>. Sie erlauben
          Ihnen, zwischen einer impliziten oder expliziten
          Einbeziehung von Pfaden im Datenstrom zu wählen. Sie können
          mehr über diese Unterbefehle und den einzigartigen Zweck von
          <command>svndumpfilter</command> später in diesem Kapitel
          unter <xref linkend="svn.reposadmin.maint.filtering" />
          erfahren.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnsync">
        <title>svnsync</title>

<!--
        <para>The <command>svnsync</command> program, which is new to
          the 1.4 release of Subversion, provides all the
          functionality required for maintaining a read-only mirror of
          a Subversion repository.  The program really has one
          job&mdash;to transfer one repository's versioned history
          into another repository.  And while there are few ways to do
          that, its primary strength is that it can operate
          remotely&mdash;the <quote>source</quote> and
          <quote>sink</quote>
          <footnote>
            <para>Or is that, the <quote>sync</quote>?</para>
          </footnote>
          repositories may be on different computers from each other
          and from <command>svnsync</command> itself.</para>
-->
        <para>Der Befehl <command>svnsync</command>, der in Subversion
          1.4 neu hinzugekommen ist, bietet Funktionen zum Verwalten
          eines Nur-Lese-Spiegels des Subversion-Projektarchivs. Das
          Programm hat eine Aufgabe &ndash; die versionierte Historie
          eines Projektarchivs in ein anderes zu übertragen. Und während
          es nicht viele Möglichkeiten gibt, dies zu tun, liegt seine
          hauptsächliche Stärke darin, das es aus der Ferne eingesetzt
          werden kann &ndash; das <quote>Quell</quote>- und
          <quote>Ziel</quote>-Projektarchiv können auf verschiedenen
          Rechnern liegen und auf einem anderen Rechner als
          <command>svnsync</command> selbst.</para>

<!--
        <para>As you might expect, <command>svnsync</command> has a
          syntax that looks very much like every other program we've
          mentioned in this chapter:</para>
-->
        <para>Wie Sie vielleicht erwarten, hat
          <command>svnsync</command> eine Syntax, die allen anderen
          Programmen aus diesem Kapitel gleicht:</para>

<!--
        <screen>
$ svnsync help
general usage: svnsync SUBCOMMAND DEST_URL  [ARGS &amp; OPTIONS ...]
Type 'svnsync help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnsync - -version' to see the program version and RA modules.

Available subcommands:
   initialize (init)
   synchronize (sync)
   copy-revprops
   help (?, h)
$
</screen>
-->
        <screen>
$ svnsync help
Aufruf: svnsync UNTERBEFEHL ZIEL_URL [Optionen &amp; Parameter ...]
Geben Sie »svnsync help &lt;Unterbefehl&gt;« ein, um Hilfe zu einem
          Unterbefehl zu erhalten.
Geben Sie »svnsync --version« ein, um die Programmversion und die Zugriffs-
          module zu sehen.

Verfügbare Unterbefehle:
   initialize (init)
   synchronize (sync)
   copy-revprops
   help (?, h)

$
</screen>

<!--
        <para>We talk more about replicating repositories with
          <command>svnsync</command> later in this chapter (see <xref
          linkend="svn.reposadmin.maint.replication" />).</para>
-->
        <para>Später in diesem Kapitel werden wir mehr über das
          Replizieren von Projektarchiven mit  <command>svnsync</command>
          reden (siehe <xref
          linkend="svn.reposadmin.maint.replication" />).</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.fsfsreshard">
        <title>fsfs-reshard.py</title>

<!--
        <para>While not an official member of the Subversion
          toolchain, the <command>fsfs-reshard.py</command> script
          (found in the <filename>tools/server-side</filename>
          directory of the Subversion source distribution) is a useful
          performance tuning tool for administrators of FSFS-backed
          Subversion repositories.  FSFS repositories contain files
          that describe the changes made in a single revision, and
          files that contain the revision properties associated with
          a single revision.  Repositories created in versions of
          Subversion prior to 1.5 keep these files in two
          directories&mdash;one for each type of file.  As new
          revisions are committed to the repository, Subversion drops
          more files into these two directories&mdash;over time, the
          number of these files in each directory can grow to be quite
          large.  This has been observed to cause performance problems
          on certain network-based filesystems.</para>
-->
        <para>Obwohl es kein offizielles Glied in der Werkzeugkette
          von Subversion ist, handelt es sich bei dem Script
          <command>fsfs-reshard.py</command> (zu finden im Verzeichnis
          <filename>tools/server-side</filename> des
          Subversion-Quelltext-Paketes) um ein nützliches Werkzeug zur
          Leistungssteigerung für Administratoren von FSFS-basierten
          Subversion-Projektarchiven. FSFS-Projektarchive enthalten Dateien,
          die die Änderungen in einer einzelnen Revision beschreiben
          sowie Dateien, die die zu einer Revision gehörenden Eigenschaften
          beinhalten. Projektarchive, die in einer früheren Version als
          Subversion 1.5 erzeugt wurden, legen diese Dateien in zwei
          Verzeichnissen ab &ndash; eins pro Dateityp. Während neue
          Revisionen an das Projektarchiv übergeben werden, legt
          Subversion dort immer mehr Dateien ab &ndash; im Lauf der
          Zeit kann die Anzahl der Dateien recht groß werden. Es wurde
          festgestellt, dass dies bei bestimmten netzbasierten
          Dateisystemen zu Leistungseinbußen kommen kann.</para>

<!--
        <para>Subversion 1.5 creates FSFS-backed repositories using a
          slightly modified layout in which the contents of these two
          directories are <firstterm>sharded</firstterm>, or scattered
          across several subdirectories.  This can greatly reduce the
          time it takes the system to locate any one of these files,
          and therefore increases the overall performance of
          Subversion when reading from the repository.  The number of
          subdirectories used to house these files is configurable,
          though, and that's where
          <command>fsfs-reshard.py</command> comes in.  This script
          reshuffles the repository's file structure into a new
          arrangement that reflects the requested number of sharding
          subdirectories.  This is especially useful for converting an
          older Subversion repository into the new Subversion 1.5
          sharded layout (which Subversion will not automatically do
          for you) or for fine-tuning an already sharded
          repository.</para>
-->
        <para>Subversion 1.5 legt FSFS-basierte Projektarchive mit einer
          geringfügig veränderten Struktur an, in der der Inhalt
          dieser beiden Verzeichnisse
          <firstterm>aufgebrochen</firstterm> ist, d.h. über mehrere
          Unterverzeichnisse aufgeteilt ist.  Das kann die Zeit
          erheblich beschleunigen, die benötigt wird, um eine dieser
          Dateien zu finden und führt somit zu einer allgemeinen
          Leistungssteigerung beim Lesen aus dem Projektarchiv. Die
          Anzahl der Unterverzeichnisse für diese Dateien ist jedoch
          konfigurierbar, und hier setzt
          <command>fsfs-reshard.py</command> an. Dieses Script mischt
          die Dateistruktur des Projektarchivs und ordnet sie gemäß der
          Anzahl der gewünschten Unterverzeichnisse neu an. Das ist
          inbesonders dann nützlich, wenn ein älteres Projektarchiv in
          die neue Struktur von Subversion 1.5 überführt werden soll
          (was Subversion nicht automatisch für Sie macht) oder falls
          ein bereits aufgeteiltes Projektarchiv noch feiner eingestellt
          werden soll.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.bdbutil">
<!--
        <title>Berkeley DB utilities</title>
-->
        <title>Dienstprogramme von Berkeley DB</title>

<!--
        <para>If you're using a Berkeley DB repository, all of
          your versioned filesystem's structure and data live in a set
          of database tables within the <filename>db/</filename>
          subdirectory of your repository.  This subdirectory is a
          regular Berkeley DB environment directory and can therefore
          be used in conjunction with any of the Berkeley database
          tools, typically provided as part of the Berkeley DB
          distribution.</para>
-->
        <para>Falls Sie ein Projektarchiv verwenden, das auf Berkeley DB
          basiert, befindet sich die gesamte Struktur und die Daten
          Ihres versionierten Dateisystems in einer Menge von
          Datenbanktabellen innerhalb des Unterverzeichnisses
          <filename>db/</filename> Ihres Projektarchivs. Dieses
          Unterverzeichnis ist ein gewöhnliches Verzeichnis einer
          Berkeley-DB-Umgebung und kann deshalb mit irgendeinem der
          Berkeley Datenbankwerkzeuge verwendet werden, die
          normalerweise mit Berkeley DB ausgeliefert werden.</para>

<!--
        <para>For day-to-day Subversion use, these tools are
          unnecessary.  Most of the functionality typically needed for
          Subversion repositories has been duplicated in the
          <command>svnadmin</command> tool.  For example,
          <command>svnadmin list-unused-dblogs</command> and
          <command>svnadmin list-dblogs</command> perform a
          subset of what is provided by the Berkeley
          <command>db_archive</command> utility, and <command>svnadmin
          recover</command> reflects the common use cases of the
          <command>db_recover</command> utility.</para>
-->
        <para>Für die tägliche Arbeit mit Subversion werden diese
          Werkzeuge nicht benötigt. Die meisten Funktionen, die
          üblicherweise für Subversion-Projektarchive gebraucht werden,
          sind in <command>svnadmin</command> integriert worden.
          Beispielsweise liefern <command>svnadmin
          list-unused-dblogs</command> und <command>svnadmin
          list-dblogs</command> eine Teilmenge dessen, was vom
          Berkeley-Dienstprogramm <command>db_archive</command>
          angeboten wird, und <command>svnadmin recover</command>
          spiegelt die verbreiteten Anwendungsfälle von
          <command>db_recover</command> wieder.</para>

<!--
        <para>However, there are still a few Berkeley DB utilities
          that you might find useful.  The <command>db_dump</command>
          and <command>db_load</command> programs write and read,
          respectively, a custom file format that describes the keys
          and values in a Berkeley DB database.  Since Berkeley
          databases are not portable across machine architectures,
          this format is a useful way to transfer those databases from
          machine to machine, irrespective of architecture or
          operating system.  As we describe later in this chapter, you
          can also use <command>svnadmin dump</command> and
          <command>svnadmin load</command> for similar purposes, but
          <command>db_dump</command> and <command>db_load</command>
          can do certain jobs just as well and much faster.  They can
          also be useful if the experienced Berkeley DB hacker needs
          to do in-place tweaking of the data in a BDB-backed
          repository for some reason, which is something Subversion's
          utilities won't allow.  Also, the <command>db_stat</command>
          utility can provide useful information about the status of
          your Berkeley DB environment, including detailed statistics
          about the locking and storage subsystems.</para>
-->
        <para>Trotzdem gibt es noch ein paar Berkeley-DB-Werkzeuge,
          die Ihnen nützlich sein könnten. Die Programme
          <command>db_dump</command> und <command>db_load</command>
          schreiben bzw. lesen ein spezielles Dateiformat, das die
          Schlüssel und Werte in einer Berkeley-DB-Datenbank
          beschreibt. Da Berkeley-Datenbanken nicht zwischen
          Rechnerarchitekturen portierbar sind, stellt dieses Format
          ein nützliches Verfahren zur Übertragung der Datenbanken
          zwischen Maschinen zur Verfügung, wobei die Architektur oder
          das Betriebssystem keine Rolle spielen. Später in diesem
          Kapitel werden wir noch beschreiben, wie Sie auch
          <command>svnadmin dump</command> und <command>svnadmin
          load</command> für ähnliche Zwecke verwenden können, doch
          <command>db_dump</command> und <command>db_load</command>
          können bestimmte Aufgaben genausogut und viel schneller
          erledigen. Sie können auch dabei dienlich sein, wenn der
          erfahrene Berkeley-DB-Hacker aus irgendwelchen Gründen die
          Daten in einem BDB-basierten Projektarchiv direkt vor Ort
          anpassen muss, was die Dienstprogramme von Subversion
          nicht erlauben. Ferner liefert das Dienstprogramm
          <command>db_stat</command> nützliche Informationen über den
          Zustand Ihrer Berkeley-DB-Umgebung, wozu ausführliche
          Statistiken über das Sperr- und Speicher-Teilsystem
          gehören.</para>

<!--
        <para>For more information on the Berkeley DB tool chain,
          visit the documentation section of the Berkeley DB section
          of Oracle's web site, located at <ulink
          url="http://www.oracle.com/technology/documentation/berkeley-db/db/"
          />.</para>
-->
        <para>Besuchen Sie für weitergehende Informationen zur
          Berkeley-Werkzeugsammlung den Dokumentationsabschnitt der
          Berkeley-DB-Abteilung auf der Seite von Oracle bei <ulink
          url="http://www.oracle.com/technology/documentation/berkeley-db/db/"
          />.</para>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.setlog">
<!--
      <title>Commit Log Message Correction</title>
-->
      <title>Berichtigung des Protokolleintrags</title>

<!--
      <para>Sometimes a user will have an error in her log message (a
        misspelling or some misinformation, perhaps).  If the
        repository is configured (using the
        <literal>pre-revprop-change</literal> hook; see <xref
        linkend="svn.reposadmin.create.hooks"/>) to accept changes to
        this log message after the commit is finished, the user
        can <quote>fix</quote> her log message remotely using
        <command>svn propset</command> (see <xref
        linkend="svn.ref.svn.c.propset"/>).  However, because of the
        potential to lose information forever, Subversion repositories
        are not, by default, configured to allow changes to
        unversioned properties&mdash;except by an
        administrator.</para>
-->
      <para>Manchmal kommt es vor, dass ein Benutzer einen Fehler im
        Protokolleintrag gemacht hat (einen Tippfehler oder vielleicht
        eine Fehlinformation). Falls das Projektarchiv entsprechend
        eingestellt ist (indem der Hook
        <literal>pre-revprop-change</literal> verwendet wird; siehe
        <xref linkend="svn.reposadmin.create.hooks"/>), um Änderungen
        am Protokolleintrag vorzunehmen nachdem die Übergabe
        abgeschlossen ist, kann der Benutzer den Protokolleintrag aus
        der Ferne mit dem Befehl <command>svn propset</command> (siehe
        <xref linkend="svn.ref.svn.c.propset"/>)
        <quote>berichtigen</quote>.  Wegen der Möglichkeit, dadurch
        für immer Informationen zu verlieren, sind
        Subversion-Projektarchive allerdings standardmäßig nicht so
        eingestellt, dass Änderungen an unversionierten Propertys
        erlaubt sind &ndash; außer für einen Administrator.</para>

<!--
      <para>If a log message needs to be changed by an administrator,
        this can be done using <command>svnadmin setlog</command>.
        This command changes the log message (the
        <literal>svn:log</literal> property) on a given revision of a
        repository, reading the new value from a provided file.</para>
-->
      <para>Falls ein Protokolleintrag durch einen Administrator
        geändert werden muss, kann das mit <command>svnadmin
        setlog</command> geschehen. Dieser Befehl ändert den
        Protokolleintrag (das Property <literal>svn:log</literal>)
        einer gegebenen Revision eines Projektarchivs, indem der neue
        Inhalt aus einer angegebenen Datei gelesen wird.</para>

<!--
      <screen>
$ echo "Here is the new, correct log message" &gt; newlog.txt
$ svnadmin setlog myrepos newlog.txt -r 388
</screen>
-->
      <screen>
$ echo "Hier ist der neue, korrekte Protokolleintrag" &gt; newlog.txt
$ svnadmin setlog myrepos newlog.txt -r 388
</screen>

<!--
      <para>The <command>svnadmin setlog</command> command, by
        default, is
        still bound by the same protections against modifying
        unversioned properties as a remote client is&mdash;the
        <literal>pre-</literal> and
        <literal>post-revprop-change</literal> hooks are still
        triggered, and therefore must be set up to accept changes of
        this nature.  But an administrator can get around these
        protections by passing the <option>- -bypass-hooks</option>
        option to the <command>svnadmin setlog</command> command.</para>
-->
      <para>Auch der Befehl <command>svnadmin setlog</command> ist
        standardmäßig durch dieselben Schutzmechanismen gegen die
        Veränderung unversionierter Propertys eingeschränkt wie ein
        Client aus der Ferne &ndash; die Hooks <literal>pre-</literal>
        und <literal>post-revprop-change</literal> werden immer noch
        ausgelöst und müssen entsprechend eingestellt werden, um
        solche Änderungen zuzulassen. Allerdings kann ein
        Administrator diese Schutzmechanismen umgehen, indem er die
        Option <option>--bypass-hooks</option> an den Befehl
        <command>svnadmin setlog</command> übergibt.</para>

      <warning>
<!--
        <para>Remember, though, that by bypassing the hooks, you are
          likely avoiding such things as email notifications of
          property changes, backup systems that track unversioned
          property changes, and so on.  In other words, be very
          careful about what you are changing, and how you change
          it.</para>
-->
        <para>Denken Sie trotzdem daran, dass beim Umgehen der Hooks
          auch Dinge umgangen werden wie E-Mail-Benachrichtigungen bei
          Property-Änderungen, Sicherungssysteme, die Änderungen an
          unversionierten Propertys verfolgen, usw. Mit anderen
          Worten: Seien Sie sehr vorsichtig bei der Auswahl dessen,
          was Sie ändern und wie Sie es ändern.</para>
      </warning>


    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.diskspace">
<!--
      <title>Managing Disk Space</title>
-->
      <title>Plattenplatzverwaltung</title>

<!--
      <para>While the cost of storage has dropped incredibly in the
        past few years, disk usage is still a valid concern for
        administrators seeking to version large amounts of data.
        Every bit of version history information stored in the live
        repository needs to be backed up
        elsewhere, perhaps multiple times as part of rotating backup
        schedules.  It is useful to know what pieces of Subversion's
        repository data need to remain on the live site, which need to
        be backed up, and which can be safely removed.</para>
-->
      <para>Obwohl die Kosten für Speicherplatz in den letzten Jahren
        unglaublich gefallen sind, ist Plattenplatz immer noch ein
        berechtigtes Anliegen für Administratoren, die große Mengen
        von Daten zu versionieren haben. Jedes im aktiven Projektarchiv
        gespeicherte Bisschen Information über die Versionshistorie
        muss zu einem anderen Ort gesichert werden; vielleicht sogar
        öfter, falls eine zyklische Sicherungsstrategie angewendet
        wird. Es ist zweckdienlich zu wissen, welche Teile von
        Subversions Projektarchiv am Ort verbleiben müssen, welche
        gesichert werden müssen und welche ruhig entfernt werden
        können.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.deltas">
<!--
        <title>How Subversion saves disk space</title>
-->
        <title>Wie Subversion Plattenplatz spart</title>

<!--
        <para>To keep the repository small,
          Subversion uses <firstterm>deltification</firstterm> (or
          deltified storage) within the repository
          itself.  Deltification involves encoding the representation
          of a chunk of data as a collection of differences against
          some other chunk of data.  If the two pieces of data are
          very similar, this deltification results in storage savings
          for the deltified chunk&mdash;rather than taking up space
          equal to the size of the original data, it takes up only
          enough space to say, <quote>I look just like this other
          piece of data over here, except for the following couple of
          changes.</quote>  The result is that most of the repository
          data that tends to be bulky&mdash;namely, the contents of
          versioned files&mdash;is stored at a much smaller size than
          the original full-text representation of that
          data.  And for repositories created with Subversion 1.4 or
          later, the space savings are even better&mdash;now those
          full-text representations of file contents are themselves
          compressed.</para>
-->
        <para>Um das Projektarchiv klein zu halten, verwendet Subversion
          innerhalb des Projektarchivs
          <firstterm>Delta-Kodierung</firstterm> (oder
          Deltaspeicherung). Unter Delta-Kodierung wird die Kodierung
          eines Datensatzes als eine Sammlung von Unterschieden
          gegenüber einem anderen Datensatz verstanden. Falls die
          beiden Datensätze sehr ähnlich sind, bewirkt diese
          Delta-Kodierung eine Einsparung an Speicherplatz für den als
          Delta gespeicherten Datensatz &ndash; anstatt den
          Platz der Originaldaten zu belegen, wird hierbei nur soviel
          Platz benötigt, um zu sagen: <quote>Schau mal, ich sehe
          genau so aus, wie der andere Datensatz da drüben, bis auf
          die folgenden paar Änderungen.</quote> Das Ergebnis ist,
          dass die meisten der Daten im Projektarchiv, die normalerweise
          recht voluminös sind &ndash; nämlich der Inhalt
          versionierter Dateien &ndash; in einer viel geringeren Größe
          gespeichert werden als der ursprüngliche Volltext dieser
          Daten. Und für Projektarchive, die mit Subversion 1.4 oder
          später angelegt wurden, ist die Platzersparnis sogar noch
          besser &ndash; jetzt sind die Volltexte der Dateiinhalte
          selbst komprimiert.</para>

        <note>
<!--
          <para>Because all of the data that is subject to
            deltification in a BDB-backed repository is stored in a
            single Berkeley DB database file, reducing the size of the
            stored values will not immediately reduce the size of the
            database file itself.  Berkeley DB will, however, keep
            internal records of unused areas of the database file and
            consume those areas first before growing the size of the
            database file.  So while deltification doesn't produce
            immediate space savings, it can drastically slow future
            growth of the database.</para>
-->
          <para>Da alle delta-kodierten Daten in einem BDB-basierten
            Projektarchiv in einer einzigen Berkeley-DB-Datenbankdatei
            gespeichert werden, wird die verringerte Größe der
            gespeicherten Werte nicht unmittelbar die Größe der
            Datenbankdatei verringern. Berkeley DB führt jedoch intern
            Buch über unbenutzte Bereiche der Datenbankdatei und wird
            zunächst jene aufbrauchen, bevor die Datenbankdatei selbst
            vergrößert wird. Während Delta-Kodierung also nicht
            unmittelbare Platzersparnis bringt, kann sie jedoch das
            künftige Wachstum der Datenbank drastisch
            verlangsamen.</para>
        </note>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.deadtxns">
<!--
        <title>Removing dead transactions</title>
-->
        <title>Entfernen unvollendeter Transaktionen</title>

<!--
        <para>Though they are uncommon, there are circumstances in
          which a Subversion commit process might fail, leaving behind
          in the repository the remnants of the revision-to-be that
          wasn't&mdash;an uncommitted transaction and all the file and
          directory changes associated with it.  This could happen for
          several reasons:  perhaps the client operation was
          inelegantly terminated by the user, or a network failure
          occurred in the middle of an operation.
          Regardless of the reason, dead transactions can happen.
          They don't do any real harm, other than consuming disk
          space.  A fastidious administrator may nonetheless wish to
          remove them.</para>
-->
        <para>Obwohl es selten vorkommt, gibt es Umstände, unter denen
          der Übergabeprozess mit einem Fehler abbricht und die Reste
          einer Revision in Spe  hinterlässt &ndash; eine unvollendete
          Transaktion samt aller Datei- und Verzeichnisänderungen, die
          dazugehören. Dies kann aus verschiedenen Gründen passieren:
          Vielleicht wurde die Operation des Clients vom Benutzer
          unsauber beendet oder es trat mittendrin ein Netzfehler auf.
          Aus welchem Grund auch immer, es können unvollendete
          Transaktionen auftreten. Sie verursachen keine tatsächlichen
          Schäden, außer Plattenplatz zu verschwenden. Ein penibler
          Administrator möchte sie vielleicht dennoch
          entfernen.</para>

<!--
        <para>You can use the <command>svnadmin lstxns</command>
          command to list the names of the currently outstanding
          transactions:</para>
-->
        <para>Sie können den Befehl <command>svnadmin lstxns</command>
          verwenden, um die Namen der aktuell ausstehenden
          Transaktionen anzuzeigen:</para>

        <screen>
$ svnadmin lstxns myrepos
19
3a1
a45
$
</screen>

<!--
        <para>Each item in the resultant output can then be used with
          <command>svnlook</command> (and its
          <option>- -transaction</option> (<option>-t</option>) option)
          to determine who created the transaction, when it was
          created, what types of changes were made in the
          transaction&mdash;information that is helpful in determining
          whether the transaction is a safe candidate for
          removal!  If you do indeed want to remove a transaction, its
          name can be passed to <command>svnadmin rmtxns</command>,
          which will perform the cleanup of the transaction.  In fact,
          <command>svnadmin rmtxns</command> can take its input
          directly from the output of
          <command>svnadmin lstxns</command>!</para>
-->
        <para>Jeder Eintrag der Ausgabe kann dann mit dem Befehl
          <command>svnlook</command> (und seiner Option
          <option>--transaction</option> (<option>-t</option>))
          aufgerufen werden, um festzustellen, wer die Transaktion
          erzeugt hat, wann sie erzeugt wurde und welche Änderungen
          sie beinhaltet &ndash; Informationen, die bei der
          Entscheidung helfen können, ob eine Transaktion ein sicherer
          Kandidat zum Löschen ist! Wenn Sie tatsächlich eine
          Transaktion löschen wollen, kann deren Name an den Befehl
          <command>svnadmin rmtxns</command> übergeben werden, der
          dann die Transaktion aufräumt. <command>svnadmin
          rmtxns</command> kann seine Eingabe auch direkt aus der
          Ausgabe von <command>svnadmin lstxns</command>
          beziehen!</para>

        <screen>
$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`
$
</screen>

<!--
        <para>If you use these two subcommands like this, you should
          consider making your repository temporarily inaccessible to
          clients.  That way, no one can begin a legitimate
          transaction before you start your cleanup.  <xref
          linkend="svn.reposadmin.maint.diskspace.deadtxns.ex-1" />
          contains a bit of shell-scripting that can quickly generate
          information about each outstanding transaction in your
          repository.</para>
-->
        <para>Falls Sie auf diese Weise diese beiden Unterbefehle
          verwenden, sollten Sie vorübergehend das Projektarchiv für
          Clients unzugänglich machen. So kann niemand eine
          berechtigte Transaktion beginnen, bevor Sie aufgeräumt
          haben.  <xref
          linkend="svn.reposadmin.maint.diskspace.deadtxns.ex-1" />
          enthält ein kleines Shell-Script, das schnell eine Übersicht
          über jede ausstehende Transaktion in Ihrem Projektarchiv
          erzeugen kann.</para>

<!--
        <example id="svn.reposadmin.maint.diskspace.deadtxns.ex-1">
          <title>txn-info.sh (reporting outstanding transactions)</title>
-->
        <example id="svn.reposadmin.maint.diskspace.deadtxns.ex-1">
          <title>txn-info.sh (ausstehende Transaktionen anzeigen)</title>

<!--
          <programlisting>
#!/bin/sh

### Generate informational output for all outstanding transactions in
### a Subversion repository.

REPOS="${1}"
if [ "x$REPOS" = x ] ; then
  echo "usage: $0 REPOS_PATH"
  exit
fi

for TXN in `svnadmin lstxns ${REPOS}`; do 
  echo "- -[ Transaction ${TXN} ]- - - - - - - - - - - - - - - - - - - - - -"
  svnlook info "${REPOS}" -t "${TXN}"
done
</programlisting>
-->
          <programlisting>
#!/bin/sh

### Erzeuge Informationen über alle ausstehenden Transaktionen eines
### Subversion Projektarchivs.

REPOS="${1}"
if [ "x$REPOS" = x ] ; then
  echo "Aufruf: $0 REPOS_PATH"
  exit
fi

for TXN in `svnadmin lstxns ${REPOS}`; do 
  echo "---[ Transaktion ${TXN} ]-------------------------------------------"
  svnlook info "${REPOS}" -t "${TXN}"
done
</programlisting>
        </example>

<!--
        <para>The output of the script is basically a concatenation of
          several chunks of <command>svnlook info</command> output
          (see <xref linkend="svn.reposadmin.maint.tk.svnlook"/>) and
          will look something like this:</para>
-->
        <para>Die Ausgabe des Scriptes ist im Grunde genommen eine
          Aneinanderreihung mehrerer Teile von <command>svnlook
          info</command>-Ausgaben (siehe <xref
          linkend="svn.reposadmin.maint.tk.svnlook"/>) und sieht etwa
          so aus:</para>

<!--
        <screen>
$ txn-info.sh myrepos
- -[ Transaction 19 ]- - - - - - - - - - - - - - - - - - - - - -
sally
2001-09-04 11:57:19 -0500 (Tue, 04 Sep 2001)
0
- -[ Transaction 3a1 ]- - - - - - - - - - - - - - - - - - - - - -
harry
2001-09-10 16:50:30 -0500 (Mon, 10 Sep 2001)
39
Trying to commit over a faulty network.
- -[ Transaction a45 ]- - - - - - - - - - - - - - - - - - - - - -
sally
2001-09-12 11:09:28 -0500 (Wed, 12 Sep 2001)
0
$
</screen>
-->
        <screen>
$ txn-info.sh myrepos
---[ Transaktion 19 ]-------------------------------------------
sally
2001-09-04 11:57:19 -0500 (Tue, 04 Sep 2001)
0
---[ Transaktion 3a1 ]-------------------------------------------
harry
2001-09-10 16:50:30 -0500 (Mon, 10 Sep 2001)
39
Versuch, über eine schlechte Netzverbindung abzuliefern.
---[ Transaktion a45 ]-------------------------------------------
sally
2001-09-12 11:09:28 -0500 (Wed, 12 Sep 2001)
0
$
</screen>

<!--
        <para>A long-abandoned transaction usually represents some
          sort of failed or interrupted commit.  A transaction's
          datestamp can provide interesting information&mdash;for
          example, how likely is it that an operation begun nine
          months ago is still active?</para>
-->
        <para>Eine vor langer Zeit aufgegebene Transaktion bedeutet
          normalerweise eine Art fehlgeschlagenen oder unterbrochenen
          Übergabeversuch. Der Zeitstempel einer Transaktion kann eine
          interessante Information sein &ndash; ist es beispielsweise
          wahrscheinlich, dass eine vor neun Monaten begonnene
          Operation immer noch aktiv ist?</para>

<!--
        <para>In short, transaction cleanup decisions need not be made
          unwisely.  Various sources of information&mdash;including
          Apache's error and access logs, Subversion's operational
          logs, Subversion revision history, and so on&mdash;can be
          employed in the decision-making process.  And of course, an
          administrator can often simply communicate with a seemingly
          dead transaction's owner (via email, e.g.) to verify
          that the transaction is, in fact, in a zombie state.</para>
-->
        <para>Kurz gesagt, Entscheidungen zur Bereinigung von
          Transaktionen sollten klug getroffen werden. Verschiedene
          Informationsquellen &ndash; hierzu gehören die Fehler- und
          Zugriffsprotokolldateien von Apache, die operativen
          Protokolldateien von Subversion, die Revisions-Historie von
          Subversion usw. &ndash; können während des
          Entscheidungsprozesses hinzugezogen werden. Natürlich kann
          sich ein Administrator auch einfach  mit dem Eigentümer
          einer anscheinend abgebrochenen Transaktion in Verbindung
          setzen (z.B. per E-Mail), um sicherzustellen, dass die
          Transaktion sich tatsächlich in einem Zombiezustand
          befindet.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.bdblogs">
<!--
        <title>Purging unused Berkeley DB logfiles</title>
-->
        <title>Entfernen unbenutzter Protokolldateien von Berkeley DB</title>

<!--
        <para>Until recently, the largest offender of disk space usage
          with respect to BDB-backed Subversion repositories were the
          logfiles in which Berkeley DB performs its prewrites before
          modifying the actual database files.  These files capture
          all the actions taken along the route of changing the
          database from one state to another&mdash;while the database
          files, at any given time, reflect a particular state, the
          logfiles contain all of the many changes along the way
          <emphasis>between</emphasis> states.  Thus, they can grow
          and accumulate quite rapidly.</para>
-->
        <para>Bis vor kurzer Zeit waren die größten
          Plattenplatzfresser bei BDB-basierten Subversion-Projektarchive
          die Protokolldateien, in die Berkeley DB zunächst alle
          Schritte hineinschreibt, bevor es die eigentlichen
          Datenbankdateien verändert. Diese Dateien halten alle
          Aktionen der Datenbank auf dem Weg von einem Zustand zum
          nächsten fest &ndash; während die Datenbankdateien zu jeder
          Zeit einen bestimmten Zustand widerspiegeln, beinhalten die
          Protokolldateien all die vielen Änderungen auf dem Weg
          <emphasis>zwischen</emphasis> den Zuständen. Somit können
          sie sehr schnell wachsen und sich anhäufen.</para>

<!--
        <para>Fortunately, beginning with the 4.2 release of Berkeley
          DB, the database environment has the ability to remove its
          own unused logfiles automatically.  Any
          repositories created using <command>svnadmin</command>
          when compiled against Berkeley DB version 4.2 or later
          will be configured for this automatic logfile removal.  If
          you don't want this feature enabled, simply pass the
          <option>- -bdb-log-keep</option> option to the
          <command>svnadmin create</command> command.  If you forget
          to do this or change your mind at a later time, simply edit
          the <filename>DB_CONFIG</filename> file found in your
          repository's <filename>db</filename> directory, comment out
          the line that contains the <literal>set_flags
          DB_LOG_AUTOREMOVE</literal> directive, and then run
          <command>svnadmin recover</command> on your repository to
          force the configuration changes to take effect.  See <xref
          linkend="svn.reposadmin.create.bdb"/> for more information about
          database configuration.</para>
-->
        <para>Glücklicherweise hat die Datenbankumgebung beginnend mit
          der Version 4.2 der Berkeley DB die Fähigkeit, ihre eigenen
          unbenutzten Protokolldateien automatisch zu entfernen. Alle
          Projektarchive, die mit einem <command>svnadmin</command>
          angelegt wurden, das mit Berkeley DB Version 4.2 oder später
          übersetzt wurde, werden mit automatischer
          Protokolldateientfernung konfiguriert. Wenn Sie diese
          Funktion nicht möchten, geben Sie dem Befehl
          <command>svnadmin create</command> einfach die Option
          <option>--bdb-log-keep</option> mit. Sollten Sie das
          vergessen oder es sich später anders überlegen, editieren
          Sie einfach die Datei <filename>DB_CONFIG</filename> im
          Verzeichnis <filename>db</filename> Ihres Projektarchivs indem
          Sie die Zeile mit der Direktive <literal>set_flags
          DB_LOG_AUTOREMOVE</literal> auskommentieren und starten dann
          <command>svnadmin recover</command> auf Ihrem Projektarchiv, um
          die Konfigurationsänderung zu aktivieren.  Siehe <xref
          linkend="svn.reposadmin.create.bdb"/> für weitere
          Informationen zur Datenbankkonfiguration.</para>

<!--
        <para>Without some sort of automatic logfile removal in
          place, logfiles will accumulate as you use your repository.
          This is actually somewhat of a feature of the database
          system&mdash;you should be able to recreate your entire
          database using nothing but the logfiles, so these files can
          be useful for catastrophic database recovery.  But
          typically, you'll want to archive the logfiles that are no
          longer in use by Berkeley DB, and then remove them from disk
          to conserve space.  Use the <command>svnadmin
          list-unused-dblogs</command> command to list the unused
          logfiles:</para>
-->
        <para>Ohne eine Art automatische Protokolldateientfernung
          aktiviert zu haben, häufen sich die Protokolldateien während
          der Nutzung des Projektarchivs an. Es ist eigentlich ein
          Merkmal des Datenbanksystems &ndash; Sie sollten
          ausschließlich  mit Hilfe der Protokolldateien in der Lage
          sein, Ihre gesamte Datenbank zu rekonstruieren, so dass
          diese Protokolldateien sehr nützlich für eine
          Wiederherstellung im Katastrophenfall sein können. Jedoch
          möchten Sie normalerweise die nicht mehr von Berkeley DB
          verwendeten Protokolldateien archivieren und sie zur
          Platzersparnis von der Platte entfernen. Verwenden Sie den
          Befehl <command>svnadmin list-unused-dblogs</command>, um
          die unbenutzten Protokolldateien anzuzeigen:</para>

<!--
        <screen>
$ svnadmin list-unused-dblogs /var/svn/repos
/var/svn/repos/log.0000000031
/var/svn/repos/log.0000000032
/var/svn/repos/log.0000000033
&hellip;
$ rm `svnadmin list-unused-dblogs /var/svn/repos`
## disk space reclaimed!
</screen>
-->
        <screen>
$ svnadmin list-unused-dblogs /var/svn/repos
/var/svn/repos/log.0000000031
/var/svn/repos/log.0000000032
/var/svn/repos/log.0000000033
&hellip;
$ rm `svnadmin list-unused-dblogs /var/svn/repos`
## Plattenplatz zurückgewonnen!
</screen>

        <warning>
<!--
          <para>BDB-backed repositories whose logfiles are used as
            part of a backup or disaster recovery plan should
            <emphasis>not</emphasis> make use of the logfile
            autoremoval feature.  Reconstruction of a repository's
            data from logfiles can only be accomplished only when
            <emphasis>all</emphasis> the logfiles are available.  If
            some of the logfiles are removed from disk before the
            backup system has a chance to copy them elsewhere, the
            incomplete set of backed-up logfiles is essentially
            useless.</para> </warning>
-->
          <para>BDB-basierte Projektarchive, deren Protokolldateien ein
            Bestandteil eines Sicherungs- oder Notfallplans sind,
            sollten <emphasis>nicht</emphasis> die automatische
            Entfernung verwenden. Die Wiederherstellung der Daten
            eines Projektarchivs kann nur gewährleistet werden, wenn
            <emphasis>alle</emphasis> Protokolldateien verfügbar sind.
            Falls einige der Protokolldateien von der Platte entfernt
            werden, bevor das Sicherungssystem die Gelegenheit
            bekommt, sie woandershin zu kopieren, ist die
            unvollständige Menge gesicherter Protokolldateien
            tatsächlich nutzlos.</para> </warning>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.recovery">
<!--
      <title>Berkeley DB Recovery</title>
-->
      <title>Wiederherstellung von Berkeley DB</title>

<!--
      <para>As mentioned in <xref
        linkend="svn.reposadmin.basics.backends.bdb"/>, a Berkeley DB
        repository can sometimes be left in a frozen state if not closed
        properly.  When this happens, an administrator needs to rewind
        the database back into a consistent state.  This is unique to
        BDB-backed repositories, though&mdash;if you are using
        FSFS-backed ones instead, this won't apply to you.  And for
        those of you using Subversion 1.4 with Berkeley DB 4.4 or
        later, you should find that Subversion has become much more
        resilient in these types of situations.  Still, wedged
        Berkeley DB repositories do occur, and an administrator needs
        to know how to safely deal with this circumstance.</para>
-->
      <para>Wie in <xref
        linkend="svn.reposadmin.basics.backends.bdb"/> erwähnt wurde,
        kann ein Berkeley-DB-Projektarchiv manchmal einfrieren, falls es
        nicht ordnungsgemäß geschlossen wird. Wenn das passiert, muss
        ein Administrator die Datenbank in einen konsistenten Zustand
        zurückfahren. Das gilt aber nur für BDB-basierte Projektarchive
        &ndash; falls Sie FSFS-basierte verwenden, sind Sie davon
        nicht betroffen. Und falls Sie Subversion 1.4 mit Berkeley DB
        4.4 oder später verwenden, werden Sie feststellen, dass
        Subversion für diese Situationen wesentlich unempfindlicher
        geworden ist. Trotzdem kommt es vor, dass sich
        Berkeley-DB-Projektarchive verklemmen, und Administratoren müssen
        wissen, wie sie sicher damit umgehen.</para>

<!--
      <para>To protect the data in your repository, Berkeley
        DB uses a locking mechanism.  This mechanism ensures that
        portions of the database are not simultaneously modified by
        multiple database accessors, and that each process sees the
        data in the correct state when that data is being read from
        the database.  When a process needs to change something in the
        database, it first checks for the existence of a lock on the
        target data.  If the data is not locked, the process locks the
        data, makes the change it wants to make, and then unlocks the
        data.  Other processes are forced to wait until that lock is
        removed before they are permitted to continue accessing that
        section of the database.  (This has nothing to do with the
        locks that you, as a user, can apply to versioned files within
        the repository; we try to clear up the confusion caused by
        this terminology collision in the sidebar <xref
        linkend="svn.advanced.locking.meanings" />.)</para>
-->
      <para>Um die Daten in Ihrem Projektarchiv zu schützen, verwendet
        Berkeley DB einen Sperrmechanismus. Dieser Mechanismus stellt
        sicher, dass Teile der Datenbank nicht gleichzeitig durch
        mehrere Zugriffe verändert werden und jeder Prozess die Daten
        beim Lesen aus der Datenbank im korrekten Zustand sieht.  Wenn
        ein Prozess irgendetwas in der Datenbank ändern muss, prüft er
        zunächst, ob eine Sperre auf den Zieldaten liegt.  Sind die
        Daten nicht gesperrt, sperrt der Prozess die Daten, nimmt die
        Änderungen vor und entsperrt die Daten wieder.  Andere
        Prozesse müssen auf die Freigabe der Sperre warten, bevor sie
        wieder auf diesen Datenbankabschnitt zugreifen dürfen. (Das
        hat nichts mit den Sperren zu tun, die Sie als Benutzer auf
        versionierte Dateien im Projektarchiv vergeben können; wir
        versuchen die Verwirrung, die durch diese Terminologie
        verursacht wird, in <xref
        linkend="svn.advanced.locking.meanings" /> zu klären.)</para>

<!--
      <para>In the course of using your Subversion repository, fatal
        errors or interruptions can prevent a process from having the
        chance to remove the locks it has placed in the database.  The
        result is that the backend database system gets
        <quote>wedged.</quote>  When this happens, any attempts to
        access the repository hang indefinitely (since each new
        accessor is waiting for a lock to go away&mdash;which isn't
        going to happen).</para>
-->
      <para>Während der Nutzung Ihres Projektarchivs können fatale Fehler
        oder Unterbrechungen einen Prozess daran hindern, die von ihm
        in der Datenbank gesetzten Sperren wieder zu entfernen. Als
        Ergebnis ist das Datenbanksystem <quote>verklemmt</quote>.
        Wenn das passiert, laufen alle Versuche ins Leere, auf die
        Datenbank zuzugreifen (da jeder neue Prozess darauf wartet,
        dass die Sperre entfernt wird &ndash; was aber nicht passieren
        wird).</para>

<!--
      <para>If this happens to your repository, don't panic.  The
        Berkeley DB filesystem takes advantage of database
        transactions, checkpoints, and prewrite journaling to
        ensure that only the most catastrophic of events
        <footnote>
          <para>For example, hard drive + huge electromagnet = disaster.</para>
        </footnote>
        can permanently destroy a database environment.  A
        sufficiently paranoid repository administrator will have made
        off-site backups of the repository data in some fashion, but
        don't head off to the tape backup storage closet just yet.</para>
-->
      <para>Keine Panik, falls das Ihrem Projektarchiv widerfahren
        sollte! Das Berkeley-DB-Dateisystem nutzt die Vorteile von
        Datenbanktransaktionen, Sicherungspunkten sowie
        vorausschreibender Journalierung, um zu gewährleisten, dass
        nur die katastrophalsten Ereignisse
        <footnote>
          <para>Beispielsweise Festplatte + starker Elektromagnet =
            Desaster.</para>
        </footnote>
        dauerhaft die Datenbankumgebung zerstören können. Ein
        ausreichend paranoider Projektarchiv-Administrator wird irgendwie
        Sicherungen der Daten des Projektarchivs an einem anderen Ort
        verwahren, doch rennen Sie noch nicht zum Schrank mit den
        Sicherungsbändern.</para>

<!--
      <para>Instead, use the following recipe to attempt to
        <quote>unwedge</quote> your repository:</para>
-->
      <para>Verwenden Sie stattdessen das folgende Rezept, um Ihr
        Projektarchiv zu <quote>entklemmen</quote>:</para>

      <orderedlist>
        <listitem>
<!--
          <para>Make sure no processes are accessing (or
            attempting to access) the repository.  For networked
            repositories, this also means shutting down the Apache HTTP
            Server or svnserve daemon.</para>
-->
          <para>Stellen Sie sicher, dass keine Prozesse auf das
            Projektarchiv zugreifen (oder einen Zugriffsversuch machen).
            Für netzbasierte Projektarchive bedeutet das, auch den
            Apache-HTTP-Server oder den svnserve-Dämon zu
            stoppen.</para>
        </listitem>
        <listitem> 
<!--
          <para>Become the user who owns and manages the repository.
            This is important, as recovering a repository while
            running as the wrong user can tweak the permissions of the
            repository's files in such a way that your repository will
            still be inaccessible even after it is 
            <quote>unwedged.</quote></para>
-->
          <para>Melden Sie sich als der Benutzer an, dem das
            Projektarchiv gehört und der es verwaltet. Das ist wichtig,
            da eine Wiederherstellung unter einer falschen
            Benutzerkennung dazu führen kann, dass die Berechtigungen
            auf den Dateien eines Projektarchivs derart verändert werden
            können, dass der Zugriff auf das Projektarchiv auch dann
            nicht mehr möglich wird, wenn es <quote>entklemmt</quote>
            ist.</para>
        </listitem>
        <listitem>
<!--
          <para>Run the command <userinput>svnadmin recover
            /var/svn/repos</userinput>.  You should see output such as
            this:</para>
-->
          <para>Starten Sie den Befehl <userinput>svnadmin recover
            /var/svn/repos</userinput>. Sie sollten eine Ausgabe
              ähnlich dieser sehen:</para>

<!--
          <screen>
Repository lock acquired.
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 19.
</screen>
-->
          <screen>
Exklusiven Zugriff auf das Projektarchiv erlangt
Bitte warten, die Wiederherstellung des Projektarchivs kann einige Zeit dauern ...

Wiederherstellung vollständig abgeschlossen. 
Die neueste Revision des Projektarchivs ist 19.
</screen>
<!--
          <para>This command may take many minutes to complete.</para>
-->
          <para>Die Ausführung dieses Befehls kann viele Minuten
            dauern.</para>
        </listitem>
        <listitem>
<!--
          <para>Restart the server process.</para>
-->
          <para>Machen Sie einen Neustart des Server-Prozesses.</para>
        </listitem>
      </orderedlist>

<!--
      <para>This procedure fixes almost every case of repository
        wedging.  Make sure that you run this command as the user that
        owns and manages the database, not just as
        <literal>root</literal>.  Part of the recovery process might
        involve re-creating from scratch various database files (shared
        memory regions, e.g.).  Recovering as
        <literal>root</literal> will create those files such that they
        are owned by <literal>root</literal>, which means that even
        after you restore connectivity to your repository, regular
        users will be unable to access it.</para>
-->
      <para>Dieses Vorgehen behebt fast jeden Fall von
        Projektarchiv-Verklemmung. Stellen Sie sicher, dass Sie diesen
        Befehl als der Benutzer ausführen, der Eigentümer und
        Verwalter der Datenbank ist, nicht einfach als
        <literal>root</literal>. Ein Teil des
        Wiederherstellungsprozesses könnte diverse Datenbankdateien
        völlig neu erzeugen (z.B. gemeinsame Speicherbereiche). Wenn
        Sie die Wiederherstellung als <literal>root</literal>
        ausführen, werden diese Dateien dem Benutzer
        <literal>root</literal> zugeordnet, was bedeutet, dass selbst
        nach der Wiederherstellung der Verbindung zur Außenwelt
        gewöhnliche Benutzer keinen Zugriff mehr bekommen
        werden.</para>

<!--
      <para>If the previous procedure, for some reason, does not
        successfully unwedge your repository, you should do two
        things.  First, move your broken repository directory aside
        (perhaps by renaming it to something like
        <filename>repos.BROKEN</filename>) and then restore your
        latest backup of it.  Then, send an email to the Subversion
        users mailing list (at <email>users@subversion.tigris.org</email>)
        describing your problem in detail.  Data integrity is an
        extremely high priority to the Subversion developers.</para>
-->
      <para>Falls das oben beschriebene Vorgehen aus irgendwelchen
        Gründen die Verklemmung Ihres Projektarchivs nicht beseitigt,
        sollten Sie zwei Dinge tun. Schieben Sie zunächst ihr
        beschädigtes Projektarchiv an die Seite (indem Sie es etwa in
        <filename>repos.BROKEN</filename> umbenennen) und spielen
        seine jüngste Sicherung ein. Schicken Sie dann eine E-Mail an
        die Subversion-Mailing-Liste
        (<email>users@subversion.tigris.org</email>), in der Sie Ihr
        Problem detailliert beschreiben. Die Integrität der Daten
        genießt bei den Entwicklern von Subversion allerhöchste
        Priorität.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.migrate">
<!--
      <title>Migrating Repository Data Elsewhere</title>
-->
      <title>Projektarchiv-Daten woandershin verschieben</title>

<!--
      <para>A Subversion filesystem has its data spread throughout
        files in the repository, in a fashion generally
        understood by (and of interest to) only the Subversion
        developers themselves.  However, circumstances may arise that
        call for all, or some subset, of that data to be copied or
        moved into another repository.</para>
-->
      <para>Ein Subversion-Dateisystem hält seine Daten in Dateien,
        die auf eine Art und Weise über das Projektarchiv verstreut sind,
        die im Allgemeinen nur die Subversion-Entwickler selbst
        verstehen (und auch nur sie interessieren).  Allerdings können
        es bestimmte Umstände erforderlich machen, alle Daten oder nur
        Teile davon in ein anderes Projektarchiv zu kopieren oder zu
        verschieben.</para>

<!--
      <para>Subversion provides such functionality by way of
        <firstterm>repository dump streams</firstterm>.  A repository
        dump stream (often referred to as a <quote>dump file</quote>
        when stored as a file on disk) is a portable, flat file format
        that describes the various revisions in your
        repository&mdash;what was changed, by whom, when, and so on.
        This dump stream is the primary mechanism used to marshal
        versioned history&mdash;in whole or in part, with or without
        modification&mdash;between repositories.  And Subversion
        provides the tools necessary for creating and loading these
        dump streams: the <command>svnadmin dump</command> and
        <command>svnadmin load</command> subcommands,
        respectively.</para>
-->
      <para>Subversion stellt solche Funktionen durch
        <firstterm>Projektarchiv-Auszugs-Datenströme</firstterm>
        (repository dump streams) bereit.  Ein
        Projektarchiv-Auszugs-Datenstrom (oft als
        <quote>Auszugsdatei</quote> bezeichnet, wenn er als Datei auf
        Platte gespeichert wird) ist ein portables, flaches
        Dateiformat, das die zahlreichen Revisionen in Ihrem
        Projektarchiv beschreibt &ndash; was geändert wurde, von wem usw.
        Dieser Datenstrom ist der primäre Mechanismus zum
        Herumschieben der versionierten Historie &ndash; als Ganzes
        oder in Teilen, mit oder ohne Änderung &ndash; zwischen
        Projektarchiven. Und Subversion stellt die Werkzeuge zum Erzeugen
        und Laden dieser Datenströme zur Verfügung: die Unterbefehle
        <command>svnadmin dump</command> bzw.  <command>svnadmin
        load</command>.</para>

      <warning>
<!--
        <para>While the Subversion repository dump format contains
          human-readable portions and a familiar structure (it
          resembles an RFC 822 format, the same type of format used
          for most email), it is <emphasis>not</emphasis> a plain-text
          file format.  It is a binary file format, highly sensitive
          to meddling.  For example, many text editors will corrupt
          the file by automatically converting line endings.</para>
-->
        <para>Obwohl das Format der Subversion Auszugsströme
          menschenlesbare Teile enthält und das Format eine gewohnte
          Struktur besitzt (es gleicht einem RFC 822 Format, das
          meistens für E-Mail verwendet wird), ist es
          <emphasis>kein</emphasis> reines Textformat. Es ist ein
          Binärformat, das sehr empfindlich gegenüber Herumgepfusche
          ist. Beispielsweise würden viele Texteditoren die Datei
          beschädigen, indem sie automatisch die Zeilenenden
          umformen.</para> </warning>

<!--
      <para>There are many reasons for dumping and loading Subversion
        repository data.  Early in Subversion's life, the most common
        reason was due to the evolution of Subversion itself.  As
        Subversion matured, there were times when changes made to the
        backend database schema caused compatibility issues with
        previous versions of the repository, so users had to dump
        their repository data using the previous version of
        Subversion and load it into a freshly created repository with
        the new version of Subversion.  Now, these types of schema
        changes haven't occurred since Subversion's 1.0 release, and
        the Subversion developers promise not to force users to dump
        and load their repositories when upgrading between minor
        versions (such as from 1.3 to 1.4) of Subversion.  But there
        are still other reasons for dumping and loading, including
        re-deploying a Berkeley DB repository on a new OS or CPU
        architecture, switching between the Berkeley DB and FSFS
        backends, or (as we'll cover later in this chapter in <xref
        linkend="svn.reposadmin.maint.filtering" />) purging versioned
        data from repository history.</para>
-->
      <para>Es gibt viele Gründe, Auszüge von
        Subversion-Projektarchiv-Daten zu machen und zu laden. In der
        Anfangsphase von Subversion war der häufigste Grund die
        Weiterentwicklung von Subversion an sich. Während Subversion
        reifte, gab es Zeiten, als Änderungen an der Datenbankbasis zu
        Kompatibilitätsproblemen mit früheren Projektarchiv-Versionen
        führten, so dass Benutzer mit der vorherigen Version von
        Subversion Auszüge von ihren Projektarchiv-Daten machen und sie
        mit der neueren Version von Subversion in ein frisch erzeugtes
        Projektarchiv laden mussten. Diese Schemaänderungen haben seit
        Subversion 1.0 nicht mehr stattgefunden, und die
        Subversion-Entwickler versprechen, dass die Benutzer zwischen
        Unterversionen von Subversion (wie etwa von 1.3 nach 1.4)
        keine Abzüge ihrer Projektarchive machen und neu laden müssen.
        Jedoch gibt es noch andere Gründe, die es erforderlich machen,
        zu denen Dinge gehören wie das erneute Aufsetzen eines
        Berkeley-DB-Projektarchivs auf einem neuen Betriebssystem oder
        einer CPU-Architektur, der Wechsel von einem
        Berkeley-DB-basierten auf ein FSFS-basiertes Projektarchiv oder
        (was wir später in diesem Kapitel in <xref
        linkend="svn.reposadmin.maint.filtering" /> behandeln werden)
        das Entfernen versionierter Daten aus der
        Projektarchiv-Historie.</para>

      <note>
<!--
        <para>The Subversion repository dump format describes
          versioned repository changes only.  It will not carry any
          information about uncommitted transactions, user locks on
          filesystem paths, repository or server configuration
          customizations (including hook scripts), and so on.</para>
-->
        <para>Das Auszugsformat eines Subversion Projektarchivs
          beschreibt nur versionierte Änderungen. Es beinhaltet keine
          Informationen über unvollendete Transaktionen, von Benutzern
          gesetzte Sperren auf Pfade im Projektarchiv, Anpassungen an
          Projektarchiv- oder Server-Konfigurationen (inklusive
          Hook-Scripten) usw.</para> </note>

<!--
      <para>Whatever your reason for migrating repository history,
        using the <command>svnadmin dump</command> and
        <command>svnadmin load</command> subcommands is
        straightforward.  <command>svnadmin dump</command> will output
        a range of repository revisions that are formatted using
        Subversion's custom filesystem dump format.  The dump format
        is printed to the standard output stream, while informative
        messages are printed to the standard error stream.  This
        allows you to redirect the output stream to a file while
        watching the status output in your terminal window.  For
        example:</para>
-->
      <para>Welche Gründe für den Umzug der Projektarchiv-Historie für
        Sie auch immer eine Rolle spielen, die Verwendung der
        Unterbefehle <command>svnadmin dump</command> und
        <command>svnadmin load</command> sind der direkte Weg.
        <command>svnadmin dump</command> gibt ein Intervall von
        Projektarchiv-Revisionen im speziellen Subversion-Auszugsformat
        aus. Der Auszug wird zur Standardausgabe geschrieben, während
        Mitteilungen an die Standardfehlerausgabe gehen. Das erlaubt
        Ihnen, den Ausgabestrom in eine Datei umzuleiten, während Sie
        Statusausgaben im Terminalfenster verfolgen können. Zum
        Beispiel:</para>

<!--
      <screen>
$ svnlook youngest myrepos
26
$ svnadmin dump myrepos &gt; dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
&hellip;
* Dumped revision 25.
* Dumped revision 26.
</screen>
-->
      <screen>
$ svnlook youngest myrepos
26
$ svnadmin dump myrepos &gt; dumpfile
* Revision 0 ausgegeben.
* Revision 1 ausgegeben.
* Revision 2 ausgegeben.
&hellip;
* Revision 25 ausgegeben.
* Revision 26 ausgegeben.
</screen>

<!--
      <para>At the end of the process, you will have a single file
        (<filename>dumpfile</filename> in the previous example) that
        contains all the data stored in your repository in the
        requested range of revisions.  Note that <command>svnadmin
        dump</command> is reading revision trees from the repository
        just like any other <quote>reader</quote> process would
        (e.g., <command>svn checkout</command>), so it's safe
        to run this command at any time.</para>
-->
      <para>Am Ende haben Sie eine einzelne Datei (im vorangegangenen
        Beispiel <filename>dumpfile</filename>), die alle im
        Projektarchiv gespeicherten Daten aus dem gewählten Intervall von
        Revisionen beinhaltet. Beachten Sie, dass <command>svnadmin
        dump</command> wie jeder andere <quote>lesende</quote> Prozess
        (z.B. <command>svn checkout</command>) Revisionsbäume aus dem
        Projektarchiv liest, so dass Sie diesen Befehl jederzeit aufrufen
        können.</para>

<!--
      <para>The other subcommand in the pair, <command>svnadmin
        load</command>, parses the standard input stream as a
        Subversion repository dump file and effectively replays those
        dumped revisions into the target repository for that
        operation.  It also gives informative feedback, this time
        using the standard output stream:</para>
-->
      <para>Der andere Unterbefehl dieses Paars, <command>svnadmin
        load</command>, liest den Standardeingabestrom als eine
        Subversion-Projektarchiv-Auszugsdatei und spielt diese Revisionen
        aus dem Auszug gewissermaßen neu in das Ziel-Projektarchiv. Auch
        dieser Befehl erzeugt Meldungen, dieses Mal aber über die
        Standardausgabe:</para>

<!--
      <screen>
$ svnadmin load newrepos &lt; dumpfile
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : A ... done.
     * adding path : A/B ... done.
     &hellip;
- - - - Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 2
     * editing path : A/mu ... done.
     * editing path : A/D/G/rho ... done.

- - - - Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;

&hellip;

&lt;&lt;&lt; Started new txn, based on original revision 25
     * editing path : A/D/gamma ... done.

- - - - Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 26
     * adding path : A/Z/zeta ... done.
     * editing path : A/mu ... done.

- - - - Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;

</screen>
-->
      <screen>
$ svnadmin load newrepos &lt; dumpfile
&lt;&lt;&lt; Neue Transaktion basierend auf Originalrevision 1 gestartet
     * Füge Pfad hinzu: A ... erledigt.
     * Füge Pfad hinzu: A/B ... erledigt.
     &hellip;
------- Neue Revision 1 übertragen (geladen aus Original 1) &gt;&gt;&gt;

&lt;&lt;&lt; Neue Transaktion basierend auf Originalrevision 2 gestartet
     * Bearbeite Pfad: A/mu ... erledigt.
     * Bearbeite Pfad: A/D/G/rho ... erledigt.

------- Neue Revision 2 übertragen (geladen aus Original 2) &gt;&gt;&gt;

&hellip;

&lt;&lt;&lt; Neue Transaktion basierend auf Originalrevision 25 gestartet
     * Bearbeite Pfad: A/D/gamma ... erledigt.

------- Neue Revision 25 übertragen (geladen aus Original 25) &gt;&gt;&gt;

&lt;&lt;&lt; Neue Transaktion basierend auf Originalrevision 26 gestartet
     * Füge Pfad hinzu: A/Z/zeta ... erledigt.
     * Bearbeite Pfad: A/mu ... erledigt.

------- Neue Revision 26 übertragen (geladen aus Original 26) &gt;&gt;&gt;

</screen>

<!--
      <para>The result of a load is new revisions added to a
        repository&mdash;the same thing you get by making commits
        against that repository from a regular Subversion client.
        Just as in a commit, you can use hook programs to perform
        actions before and after each of the commits made during a
        load process.  By passing the
        <option>- -use-pre-commit-hook</option> and
        <option>- -use-post-commit-hook</option> options to
        <command>svnadmin load</command>, you can instruct Subversion
        to execute the pre-commit and post-commit hook programs,
        respectively, for each loaded revision.  You might use these,
        for example, to ensure that loaded revisions pass through the
        same validation steps that regular commits pass through.  Of
        course, you should use these options with care&mdash;if your
        post-commit hook sends emails to a mailing list for each new
        commit, you might not want to spew hundreds or thousands of
        commit emails in rapid succession at that list!  You can read more about the use of hook
        scripts in <xref
        linkend="svn.reposadmin.create.hooks"/>.</para>
-->
      <para>Das Ergebnis eines Ladevorgangs sind neue Revisionen, die
        dem Projektarchiv hinzugefügt wurden &ndash; dasselbe, was Sie
        erhalten, wenn Sie mit einem normalen Subversion-Client
        Übergaben an das Projektarchiv machen. Ebenso wie bei einer
        Übergabe können können Sie Hook-Programme verwenden, um
        Aktionen vor und nach jeder Übergabe während des Ladevorgangs
        auszuführen. Indem Sie die Optionen
        <option>--use-pre-commit-hook</option> und
        <option>--use-post-commit-hook</option> an <command>svnadmin
        load</command> übergeben, können Sie Subversion befehlen, für
        jede zu ladende Revision die Hook-Programme pre-commit bzw.
        post-commit auszuführen. Sie könnten diese beispielsweise
        verwenden, um sicherzustellen, dass die geladenen Revisionen
        dieselben Validierungsschritte durchlaufen müssen wie reguläre
        Übergaben. Natürlich sollten Sie diese Optionen mit Sorgfalt
        verwenden &ndash; wenn Ihr post-commit-Hook für jede neue
        Übergabe E-Mails an eine Mailing-Liste verschickt, wollen Sie
        bestimmt nicht, das innerhalb kürzester Zeit hunderte oder
        tausende Übergabe-E-Mails in diese Liste hineinhageln! Sie
        können mehr über Hook-Scripte in <xref
        linkend="svn.reposadmin.create.hooks"/> lesen.</para>

<!--
      <para>Note that because <command>svnadmin</command> uses
        standard input and output streams for the repository dump and
        load processes, people who are feeling especially saucy can try
        things such as this (perhaps even using different versions of
        <command>svnadmin</command> on each side of the pipe):</para>
-->
      <para>Beachten Sie, dass Menschen, die sich besonders gewitzt
        fühlen, weil <command>svnadmin</command> für den Auszug und
        den Ladevorgang den Standardeingabe- und den
        Standardausgabestrom benutzt, Dinge wie dieses ausprobieren
        können (vielleicht sogar unterschiedliche Versionen von
        <command>svnadmin</command> auf jeder Seite der Pipe):</para>

      <screen>
$ svnadmin create newrepos
$ svnadmin dump oldrepos | svnadmin load newrepos
</screen>

<!--
      <para>By default, the dump file will be quite large&mdash;much
        larger than the repository itself.  That's because by default
        every version of every file is expressed as a full text in the
        dump file.  This is the fastest and simplest behavior, and
        it's nice if you're piping the dump data directly into some other
        process (such as a compression program, filtering program, or
        loading process).  But if you're creating a dump file
        for longer-term storage, you'll likely want to save disk space
        by using the <option>- -deltas</option> option.  With this
        option, successive revisions of files will be output as
        compressed, binary differences&mdash;just as file revisions
        are stored in a repository.  This option is slower, but it
        results in a dump file much closer in size to the original
        repository.</para>
-->
      <para>Im Normalfall wird die Auszugsdatei ziemlich groß &ndash;
        viel größer als das Projektarchiv selbst. Das liegt daran, dass
        standardmäßig jede Version jeder Datei als vollständiger Text
        in der Auszugsdatei dargestellt wird. Dies ist das schnellste
        und einfachste Verhalten, und es ist nett, wenn Sie die
        Auszugsdaten über eine Pipe direkt an einen weiteren Prozess
        weiterleiten (etwa ein Komprimierprogramm, ein Filterprogramm
        oder einen Prozess zum Laden). Wenn Sie jedoch eine
        Auszugsdatei für die Langzeitspeicherung erzeugen, möchten Sie
        wahrscheinlich Plattenplatz sparen, indem Sie die Option
        <option>--deltas</option> verwenden. Mit dieser Option werden
        aufeinanderfolgende Revisionen von Dateien als komprimierte
        binäre Unterschiede ausgegeben &ndash; so wie Dateirevisionen
        im Projektarchiv gespeichert werden. Diese Option ist langsamer,
        führt jedoch zu einer Größe der Auszugsdatei, die der Größe
        des Original-Projektarchivs näher kommt.</para>

<!--
      <para>We mentioned previously that <command>svnadmin
        dump</command> outputs a range of revisions.  Use the
        <option>- -revision</option> (<option>-r</option>) option to
        specify a single revision, or a range of revisions, to dump.
        If you omit this option, all the existing repository revisions
        will be dumped.</para>
-->
      <para>Wir haben eben erwähnt, dass <command>svnadmin
        dump</command> einen Bereich von Revisionen ausgibt. Verwenden
        Sie die Option <option>--revision</option>
        (<option>-r</option>), um eine einzelne Revision oder einen
        Bereich von Revisionen für den Auszug anzugeben. Wenn Sie
        diese Option weglassen, wird ein Auszug aller
        Projektarchiv-Revisionen erstellt.</para>

      <screen>
$ svnadmin dump myrepos -r 23 &gt; rev-23.dumpfile
$ svnadmin dump myrepos -r 100:200 &gt; revs-100-200.dumpfile
</screen>

<!--
      <para>As Subversion dumps each new revision, it outputs only
        enough information to allow a future loader to re-create that
        revision based on the previous one.  In other words, for any
        given revision in the dump file, only the items that were
        changed in that revision will appear in the dump.  The only
        exception to this rule is the first revision that is dumped
        with the current <command>svnadmin dump</command>
        command.</para>
-->
      <para>Beim Erstellen eines Auszugs jeder Revision gibt
        Subversion gerade soviel Information aus, dass später ein
        Ladeprozess in der Lage ist, diese Revision auf der Basis der
        Vorgängerrevision wiederherzustellen. Mit anderen Worten: Für
        jede Revision befinden sich nur die Dinge in der Auszugsdatei,
        die sich in dieser Revision geändert haben. Die einzige
        Ausnahme von dieser Regel ist die erste Revision, die mit dem
        aktuellen <command>svnadmin dump</command> erstellt
        wird.</para>

<!--
      <para>By default, Subversion will not express the first dumped
        revision as merely differences to be applied to the previous
        revision.  For one thing, there is no previous revision in the
        dump file!  And second, Subversion cannot know the state of
        the repository into which the dump data will be loaded (if it
        ever is).  To ensure that the output of each
        execution of <command>svnadmin dump</command> is
        self-sufficient, the first dumped revision is, by default, a
        full representation of every directory, file, and property in
        that revision of the repository.</para>
-->
      <para>Standardmäßig wird Subversion den Auszug der ersten
        Revision nicht bloß als Unterschied ausdrücken, der auf die
        Vorgängerrevision anzuwenden ist. Zum Ersten gibt es keine
        Vorgängerrevision in der Auszugsdatei. Und zum Zweiten kann
        Subversion den Zustand des Projektarchivs, in das der Auszug
        (falls überhaupt) geladen werden soll, nicht kennen. Um
        sicherzustellen, dass die Ausgabe jedes Aufrufs von
        <command>svnadmin dump</command> unabhängig ist, ist der
        Auszug der ersten Revision standardmäßig eine vollständige
        Darstellung jedes Verzeichnisses, jeder Datei und jedes
        Propertys aus dieser Revision im Projektarchiv.</para>

<!--
      <para>However, you can change this default behavior.  If you add
        the <option>- -incremental</option> option when you dump your
        repository, <command>svnadmin</command> will compare the first
        dumped revision against the previous revision in the
        repository&mdash;the same way it treats every other revision that
        gets dumped.  It will then output the first revision exactly
        as it does the rest of the revisions in the dump
        range&mdash;mentioning only the changes that occurred in that
        revision.  The benefit of this is that you can create several
        small dump files that can be loaded in succession, instead of
        one large one, like so:</para>
-->
      <para>Sie können dieses Standardverhalten jedoch ändern. Falls
        Sie die Option <option>--incremental</option> angeben,
        vergleicht <command>svnadmin</command> die erste Revision für
        die ein Auszug erstellt werden soll mit der vorhergehenden
        Revision im Projektarchiv &ndash; auf dieselbe Art und Weise, wie
        jede andere Revision behandelt wird, für die ein Auszug
        erstellt werden soll &ndash; indem lediglich die Änderungen
        aus dieser Revision erwähnt werden. Der Vorteil dabei ist,
        dass Sie mehrere kleinere Auszugsdateien erstellen können, die
        hintereinander geladen werden können, anstatt eine
        große:</para>

      <screen>
$ svnadmin dump myrepos -r 0:1000 &gt; dumpfile1
$ svnadmin dump myrepos -r 1001:2000 --incremental &gt; dumpfile2
$ svnadmin dump myrepos -r 2001:3000 --incremental &gt; dumpfile3
</screen>

<!--
      <para>These dump files could be loaded into a new repository
        with the following command sequence:</para>
-->
      <para>Diese Auszugsdateien können mit der folgenden Befehlsfolge
        in ein neues Projektarchiv geladen werden:</para>

      <screen>
$ svnadmin load newrepos &lt; dumpfile1
$ svnadmin load newrepos &lt; dumpfile2
$ svnadmin load newrepos &lt; dumpfile3
</screen>

<!--
      <para>Another neat trick you can perform with this
        <option>- -incremental</option> option involves appending to an
        existing dump file a new range of dumped revisions.  For
        example, you might have a <literal>post-commit</literal> hook
        that simply appends the repository dump of the single revision
        that triggered the hook.  Or you might have a script that runs
        nightly to append dump file data for all the revisions that
        were added to the repository since the last time the script
        ran.  Used like this, <command>svnadmin dump</command> can be
        one way to back up changes to your repository over time in case
        of a system crash or some other catastrophic event.</para>
-->
      <para>Ein weiterer toller Trick, den Sie mit der Option
        <option>--incremental</option> anwenden können besteht darin,
        einen neuen Bereich von Revisionsauszügen an eine existierende
        Revisionsdatei anzuhängen. Beispielsweise könnten Sie einen
        <literal>post-commit</literal>-Hook haben, der der Datei einen
        Auszug derjenigen Revision anfügt, die den Hook ausgelöst hat.
        Oder Sie haben ein Script, das jede Nacht läuft, um Auszüge
        sämtlicher Revisionen seit dem letzten Lauf anzufügen. Wenn es
        auf diese Weise verwendet wird, stellt <command>svnadmin
        dump</command> eine Möglichkeit dar, laufend die Änderungen an
        Ihrem Projektarchiv für den Fall eines Systemabsturzes oder eines
        anderen katastrophalen Ereignisses zu sichern.</para>
<!--
      <para>The dump format can also be used to merge the contents of
        several different repositories into a single repository.  By
        using the <option>- -parent-dir</option> option of
        <command>svnadmin load</command>, you can specify a new
        virtual root directory for the load process.  That means if
        you have dump files for three repositories&mdash;say
        <filename>calc-dumpfile</filename>,
        <filename>cal-dumpfile</filename>, and
        <filename>ss-dumpfile</filename>&mdash;you can first create a new
        repository to hold them all:</para>

-->
      <para>Das Auszugsformat kann auch dazu verwendet werden, um die
        Inhalte mehrerer verschiedener Projektarchive in ein Projektarchiv
        zusammenzuführen. Indem Sie die Option
        <option>--parent-dir</option> von <command>svnadmin
        load</command> benutzen, können Sie ein neues virtuelles
        Wurzelverzeichnis für den Ladevorgang angeben. Das heißt,
        falls Sie beispielsweise die Auszugsdateien von drei
        Projektarchiven haben &ndash; etwa
        <filename>calc-dumpfile</filename>,
        <filename>cal-dumpfile</filename> und
        <filename>ss-dumpfile</filename> &ndash; können Sie zunächst
        ein Projektarchiv anlegen, das alle beherbergt:</para>

      <screen>
$ svnadmin create /var/svn/projects
$
</screen>

<!--
      <para>Then, make new directories in the repository that will
        encapsulate the contents of each of the three previous
        repositories:</para>
-->
      <para>Erstellen Sie dann neue Verzeichnisse im Projektarchiv, die
        den Inhalt der vorherigen drei Projektarchive aufnehmen
        werden:</para>

<!--
      <screen>
$ svn mkdir -m "Initial project roots" \
      file:///var/svn/projects/calc \
      file:///var/svn/projects/calendar \
      file:///var/svn/projects/spreadsheet
Committed revision 1.
$ 
</screen>
-->
      <screen>
$ svn mkdir -m "Initial project roots" \
      file:///var/svn/projects/calc \
      file:///var/svn/projects/calendar \
      file:///var/svn/projects/spreadsheet
Revision 1 übertragen.
$ 
</screen>

<!--
      <para>Lastly, load the individual dump files into their
        respective locations in the new repository:</para>
-->
      <para>Laden Sie schließlich die Auszugsdateien an ihren
        jeweiligen Ort im neuen Projektarchiv:</para>

      <screen>
$ svnadmin load /var/svn/projects --parent-dir calc &lt; calc-dumpfile
&hellip;
$ svnadmin load /var/svn/projects --parent-dir calendar &lt; cal-dumpfile
&hellip;
$ svnadmin load /var/svn/projects --parent-dir spreadsheet &lt; ss-dumpfile
&hellip;
$
</screen>

<!--
      <para>We'll mention one final way to use the Subversion
        repository dump format&mdash;conversion from a different
        storage mechanism or version control system altogether.
        Because the dump file format is, for the most part,
        human-readable, it should be relatively easy to describe
        generic sets of changes&mdash;each of which should be treated
        as a new revision&mdash;using this file format.  In fact, the
        <command>cvs2svn</command> utility (see <xref
        linkend="svn.forcvs.convert"/>) uses the dump format to
        represent the contents of a CVS repository so that those
        contents can be copied into a Subversion repository.</para>
-->
      <para>Zum Schluss erwähnen wir noch einen Anwendungsfall für
        das Auszugsformat &ndash; die Umwandlung aus einem
        unterschiedlichen Speicherverfahren oder gar aus einem
        unterschiedlichen Versionskontrollsystem. Da das Format der
        Auszugsdatei größtenteils menschenlesbar ist, sollte es
        einfach sein, gewöhnliche Änderungsmengen &ndash; von denen
        jede als Revision behandelt werden sollte &ndash; mit diesem
        Format zu beschreiben. Tatsächlich verwendet das
        Dienstprogramm <command>cvs2svn</command> (siehe <xref
        linkend="svn.forcvs.convert"/>) dieses Auszugsformat, um den
        Inhalt eines CVS-Projektarchivs darzustellen, so dass er in ein
        Subversion-Projektarchiv kopiert werden kann.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.filtering">
<!--
      <title>Filtering Repository History</title>
-->
      <title>Filtern der Projektarchiv-Historie</title>

<!--
      <para>Since Subversion stores your versioned history using, at
        the very least, binary differencing algorithms and data
        compression (optionally in a completely opaque database
        system), attempting manual tweaks is unwise if not quite
        difficult, and at any rate strongly discouraged.  And once
        data has been stored in your repository, Subversion
        generally doesn't provide an easy way to remove that data.
        <footnote>
          <para>That's rather the reason you use version control at
            all, right?</para>
        </footnote>
        But inevitably, there will be times when you would like to
        manipulate the history of your repository.  You might need
        to strip out all instances of a file that was accidentally
        added to the repository (and shouldn't be there for whatever
        reason).
        <footnote>
          <para>Conscious, cautious removal of certain bits of
            versioned data is actually supported by real use cases.
            That's why an <quote>obliterate</quote> feature has been
            one of the most highly requested Subversion features,
            and one which the Subversion developers hope to soon
            provide.</para>
        </footnote>
        Or, perhaps you have multiple projects sharing a
        single repository, and you decide to split them up into
        their own repositories.  To accomplish tasks such as these,
        administrators need a more manageable and malleable
        representation of the data in their repositories&mdash;the
        Subversion repository dump format.</para>
-->
      <para>Da Subversion Ihre versionierte Historie mindestens mit
        binären Differenzalgorithmen und Datenkompression abspeichert
        (optional in einem völlig undurchsichtigen Datenbanksystem),
        ist der Versuch manueller Eingiffe unklug, zumindest
        schwierig und unter allen Umständen nicht angeraten. Sobald
        Daten im Projektarchiv gespeichert sind, bietet Subversion im
        Allgemeinen keine einfache Möglichkeit, diese Daten zu
        entfernen.
        <footnote>
          <para>Das ist doch überhaupt der Grund dafür,
            Versionskontrolle einzusetzen, oder?</para>
        </footnote>
        Doch zwangsläufig werden sich Gelegenheiten ergeben, bei denen
        Sie die Historie Ihres Projektarchivs manipulieren müssen. Es
        könnte sein, dass Sie alle Instanzen einer Datei entfernen
        müssen, die versehentlich dem Projektarchiv hinzugefügt worden
        ist, aber aus welchen Gründen auch immer nicht hineingehört).
        <footnote>
          <para>Das bewusste, vorsichtige Entfernen bestimmter Teile
            versionierter Daten wird tatsächlich von wirklichen
            Anwendungsfällen verlangt. Das ist der Grund, warum eine
            <quote>Auslösch</quote>-Funktion eine der am häufigsten
            gewünschten Funktionen von Subversion ist, von der die
            Subversion-Entwickler hoffen, sie bald zur Verfügung
            stellen zu können.</para>
        </footnote>
        Oder Sie haben vielleicht mehrere Projekte, die sich ein
        Projektarchiv teilen und entscheiden sich nun, jedem Projekt sein
        eigenes Projektarchiv zu geben. Um Aufgaben wie diese
        bewerkstelligen zu können, benötigen Administratoren eine
        besser handhabbare und bearbeitbare Repräsentation der Daten
        in den Projektarchiven &ndash; das
        Subversion-Projektarchiv-Auszugsformat.</para>

<!--
      <para>As we described earlier in <xref
        linkend="svn.reposadmin.maint.migrate" />, the Subversion
        repository dump format is a human-readable representation of
        the changes that you've made to your versioned data over time.
        Use the <command>svnadmin dump</command> command to generate
        the dump data, and <command>svnadmin load</command> to
        populate a new repository with it.  The great thing about the
        human-readability aspect of the dump format is that, if you
        aren't careless about it, you can manually inspect and modify
        it.  Of course, the downside is that if you have three years'
        worth of repository activity encapsulated in what is likely to
        be a very large dump file, it could take you a long, long time
        to manually inspect and modify it.</para>
-->
      <para>Wie bereits in <xref
        linkend="svn.reposadmin.maint.migrate" /> beschrieben, ist das
        Subversion-Projektarchiv-Auszugsformat eine menschenlesbare
        Wiedergabe der Änderungen, die Sie an Ihren versionierten
        Daten im Laufe der Zeit vorgenommen haben. Verwenden Sie den
        Befehl <command>svnadmin dump</command>, um den Auszug
        anzulegen und <command>svnadmin load</command>, um ein neues
        Projektarchiv damit zu füllen. Das Tolle an der
        Menschenlesbarkeit des Auszugsformates ist, dass Sie, sofern
        es Ihnen nicht egal ist, die Daten manuell untersuchen und
        verändern können. Natürlich besteht ein Nachteil darin, dass
        eine Auszugsdatei eines Projektarchivs, in das über drei Jahre
        Änderungen eingeflossen sind, riesig groß sein wird, und es
        Sie eine lange, lange Zeit kosten wird, die Daten manuell zu
        untersuchen und zu verändern.</para>

<!--
      <para>That's where <command>svndumpfilter</command> becomes
        useful.  This program acts as a path-based filter for
        repository dump streams.  Simply give it either a list of
        paths you wish to keep or a list of paths you wish to not
        keep, and then pipe your repository dump data through this
        filter.  The result will be a modified stream of dump data
        that contains only the versioned paths you (explicitly or
        implicitly) requested.</para>
-->
      <para>Hierbei hilft <command>svndumpfilter</command>.  Dieses
        Programm verhält sich wie ein pfadbasierter Filter für
        Auszugsströme. Geben Sie ihm einfach eine Liste von Pfaden
        mit, die Sie behalten möchten oder eine Liste von Pfaden, die
        Sie nicht behalten möchten, und leiten Sie Ihre Auszugsdaten
        durch diesen Filter. Das Ergebnis ist ein modifizierter Strom
        der Auszugsdaten, der nur die versionierten Pfade beinhaltet,
        die Sie (explizit oder implizit) verlangt haben.</para>

<!--
      <para>Let's look at a realistic example of how you might use this
        program.  Earlier in this chapter (see <xref
        linkend="svn.reposadmin.projects.chooselayout"/>), we discussed the
        process of deciding how to choose a layout for the data in
        your repositories&mdash;using one repository per project or
        combining them, arranging stuff within your repository, and
        so on.  But sometimes after new revisions start flying in,
        you rethink your layout and would like to make some changes.
        A common change is the decision to move multiple projects
        that are sharing a single repository into separate
        repositories for each project.</para>
-->
      <para>Lassen Sie uns an einem realistischen Beispiel betrachten,
      wie Sie diesen Programm verwenden könnten. Früher in diesem
      Kapitel (siehe <xref
      linkend="svn.reposadmin.projects.chooselayout"/>) erörterten wir
      das Entscheidungsfindungsverfahren, wie Sie Ihre Daten im
      Projektarchiv anordnen sollen &ndash; ein Projektarchiv pro Projekt
      oder kombiniert, wie Sie die Daten im Projektarchiv verteilen usw.
      Doch manchmal, nachdem bereits einige Revisionen hinzugekommen
      sind, überdenken Sie die Anordnung und würden gerne einige
      Änderungen vornehmen. Eine verbreitete Änderung ist die
      Entscheidung, mehrere Projekte, die sich ein Projektarchiv teilen,
      auf getrennte Projektarchive pro Projekt aufzuteilen.</para>

<!--
      <para>Our imaginary repository contains three projects:
        <literal>calc</literal>, <literal>calendar</literal>, and
        <literal>spreadsheet</literal>.  They have been living
        side-by-side in a layout like this:</para>
-->
      <para>Unser imaginäres Projektarchiv beinhaltet drei Projekte:
        <literal>calc</literal>, <literal>calendar</literal> und
        <literal>spreadsheet</literal>. Sie waren miteinander in der
        folgenden Anordnung abgelegt:</para>

      <screen>
/
   calc/
      trunk/
      branches/
      tags/
   calendar/
      trunk/
      branches/
      tags/
   spreadsheet/
      trunk/
      branches/
      tags/
</screen>

<!--
      <para>To get these three projects into their own repositories,
        we first dump the whole repository:</para>
-->
      <para>Um diese drei Projekte in ihre eigenen Projektarchive zu
        bekommen, erstellen wir zunächst einen Auszug des gesamten
        Projektarchivs:</para>

<!--
      <screen>
$ svnadmin dump /var/svn/repos &gt; repos-dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
* Dumped revision 3.
&hellip;
$
</screen>
-->
      <screen>
$ svnadmin dump /var/svn/repos &gt; repos-dumpfile
* Revision 0 ausgegeben.
* Revision 1 ausgegeben.
* Revision 2 ausgegeben.
* Revision 3 ausgegeben.
&hellip;
$
</screen>

<!--
      <para>Next, run that dump file through the filter, each time
        including only one of our top-level directories.  This results
        in three new dump files:</para>
-->
      <para>Dann leiten wir die Auszugsdatei durch die Filter, wobei
        jedesmal nur jeweils eins der obersten Verzeichnisse
        ausgewählt wird.  Als Ergebnis erhalten wir drei
        Auszugsdateien:</para>

      <screen>
$ svndumpfilter include calc &lt; repos-dumpfile &gt; calc-dumpfile
&hellip;
$ svndumpfilter include calendar &lt; repos-dumpfile &gt; cal-dumpfile
&hellip;
$ svndumpfilter include spreadsheet &lt; repos-dumpfile &gt; ss-dumpfile
&hellip;
$
</screen>

<!--
      <para>At this point, you have to make a decision.  Each of your
        dump files will create a valid repository, but will preserve
        the paths exactly as they were in the original repository.
        This means that even though you would have a repository solely
        for your <literal>calc</literal> project, that repository
        would still have a top-level directory named
        <filename>calc</filename>.  If you want your
        <filename>trunk</filename>, <filename>tags</filename>, and
        <filename>branches</filename> directories to live in the root
        of your repository, you might wish to edit your dump files,
        tweaking the <literal>Node-path</literal> and
        <literal>Node-copyfrom-path</literal> headers so that they no
        longer have that first <filename>calc/</filename> path
        component.  Also, you'll want to remove the section of dump
        data that creates the <filename>calc</filename> directory.  It
        will look something like the following:</para>
-->
      <para>An dieser Stelle müssen sie eine Entscheidung treffen.
        Jede Ihrer Auszugsdateien wird ein gültiges Projektarchiv
        erzeugen, allerdings unter Beibehaltung der Pfade wie sie im
        ursprünglichen Projektarchiv waren. Das bedeutet, dass, obwohl
        Sie ein Projektarchiv ausschließlich für Ihr
        <literal>calc</literal> Projekt haben, wird es immer noch ein
        Wurzelverzeichnis namens <filename>calc</filename> besitzen.
        Falls Sie möchten, dass die Verzeichnisse
        <filename>trunk</filename>, <filename>tags</filename> und
        <filename>branches</filename> direkt im Wurzelverzeichnis
        Ihres Projektarchivs liegen, sollten Sie Ihre Auszugsdateien
        editieren, indem Sie die Einträge <literal>Node-path</literal>
        und <literal>Node-copyfrom-path</literal> verändern, so dass
        sie nicht mehr die erste Komponente <filename>calc/</filename>
        im Pfad haben. Sie sollten auch den Abschnitt entfernen, der
        das Verzeichnis <filename>calc</filename> anlegt. Es sollte
        etwa wie folgt aussehen:</para>

      <screen>
Node-path: calc
Node-action: add
Node-kind: dir
Content-length: 0
  
</screen>

<!--
      <warning>
        <para>If you do plan on manually editing the dump file to
          remove a top-level directory, make sure your editor is
          not set to automatically convert end-of-line characters to
          the native format (e.g., <literal>\r\n</literal> to
          <literal>\n</literal>), as the content will then not agree
          with the metadata.  This will render the dump file
          useless.</para>
      </warning>
-->
      <warning>
        <para>Falls Sie sich entscheiden sollten, die Auszugsdatei
          manuell zu editieren, um eins der obersten Verzeichnisse zu
          entfernen, sollten Sie sicherstellen, dass Ihr Editor nicht
          automatisch Zeilenenden in das native Format umwandelt (z.B.
          <literal>\r\n</literal> in <literal>\n</literal>), da sonst
          der Inhalt nicht zu den Metadaten passt. Das würde Ihre
          Auszugsdatei nutzlos machen.</para>
      </warning>

<!--
      <para>All that remains now is to create your three new
        repositories, and load each dump file into the right
        repository, ignoring the UUID found in the dump stream:</para>
-->
      <para>Alles, was jetzt noch übrig bleibt, ist, Ihre drei neuen
        Projektarchive zu erstellen und jede Auszugsdatei in das richtige
        Projektarchiv zu laden, wobei die UUID aus dem Auszugsstrom
        ignoriert wird:</para>

<!--
      <screen>
$ svnadmin create calc
$ svnadmin load - -ignore-uuid calc &lt; calc-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : button.c ... done.
&hellip;
$ svnadmin create calendar
$ svnadmin load - -ignore-uuid calendar &lt; cal-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : cal.c ... done.
&hellip;
$ svnadmin create spreadsheet
$ svnadmin load - -ignore-uuid spreadsheet &lt; ss-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : ss.c ... done.
&hellip;
$
</screen>
-->
      <screen>
$ svnadmin create calc
$ svnadmin load --ignore-uuid calc &lt; calc-dumpfile
&lt;&lt;&lt; Neue Transaktion basierend auf Originalrevision 1 gestartet
     * Füge Pfad hinzu: Makefile ... erledigt.
     * Füge Pfad hinzu: button.c ... erledigt.
&hellip;
$ svnadmin create calendar
$ svnadmin load --ignore-uuid calendar &lt; cal-dumpfile
&lt;&lt;&lt; Neue Transaktion basierend auf Originalrevision 1 gestartet
     * Füge Pfad hinzu: Makefile ... erledigt.
     * Füge Pfad hinzu: cal.c ... erledigt.
&hellip;
$ svnadmin create spreadsheet
$ svnadmin load --ignore-uuid spreadsheet &lt; ss-dumpfile
&lt;&lt;&lt; Neue Transaktion basierend auf Originalrevision 1 gestartet
     * Füge Pfad hinzu: Makefile ... erledigt.
     * Füge Pfad hinzu: ss.c ... erledigt.
&hellip;
$
</screen>

<!--
      <para>Both of <command>svndumpfilter</command>'s subcommands
        accept options for deciding how to deal with
        <quote>empty</quote> revisions.  If a given revision
        contains only changes to paths that were filtered out, that
        now-empty revision could be considered uninteresting or even
        unwanted.  So to give the user control over what to do with
        those revisions, <command>svndumpfilter</command> provides
        the following command-line options:</para>
-->
      <para>Beide Unterbefehle von <command>svndumpfilter</command>
        akzeptieren Optionen, die angeben, wie <quote>leere</quote>
        Revisionen behandelt werden sollen. Falls eine Revision nur
        Änderungen an herausgefilterten Pfaden beinhaltet, könnte die
        neue Revision als uninteressant oder gar unerwünscht gelten.
        Um dem Benutzer die Kontrolle darüber zu geben, wie hiermit
        verfahren werden soll, bietet <command>svndumpfilter</command>
        die folgenden Kommandozeilenoptionen:</para>

      <variablelist>
        <varlistentry>
          <term><option>--drop-empty-revs</option></term>
          <listitem>
<!--
            <para>Do not generate empty revisions at all&mdash;just
              omit them.</para>
-->
            <para>Überhaupt keine leeren Revisionen erzeugen &ndash;
              einfach auslassen.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><option>--renumber-revs</option></term>
          <listitem>
<!--
            <para>If empty revisions are dropped (using the
              <option>- -drop-empty-revs</option> option), change the
              revision numbers of the remaining revisions so that
              there are no gaps in the numeric sequence.</para>
-->
            <para>Falls leere Revisionen ausgelassen werden (mit der
              Option <option>--drop-empty-revs</option>), die
              Nummern der übrig gebliebenen Revisionen ändern, so dass
              keine Lücken in der Nummernfolge auftreten.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><option>--preserve-revprops</option></term>
          <listitem>
<!--
            <para>If empty revisions are not dropped, preserve the
              revision properties (log message, author, date, custom
              properties, etc.) for those empty revisions.
              Otherwise, empty revisions will contain only the
              original datestamp, and a generated log message that
              indicates that this revision was emptied by
              <command>svndumpfilter</command>.</para>
-->
            <para>Falls leere Revisionen nicht ausgelassen werden, die
              Eigenschaften der leeren Revisionen bewahren
              (Protokolleintrag, Autor, Datum, Propertys usw.). Sonst
              beinhalten leere Revisionen lediglich den Zeitstempel
              und einen erzeugten Protokolleintrag, der darauf
              hinweist, dass diese Revision von
              <command>svndumpfilter</command> geleert wurde.</para>
          </listitem>
        </varlistentry>
      </variablelist>

<!--
      <para>While <command>svndumpfilter</command> can be very
        useful and a huge timesaver, there are unfortunately a
        couple of gotchas.  First, this utility is overly sensitive
        to path semantics.  Pay attention to whether paths in your
        dump file are specified with or without leading slashes.
        You'll want to look at the <literal>Node-path</literal> and
        <literal>Node-copyfrom-path</literal> headers.</para>
-->
      <para>Obwohl <command>svndumpfilter</command> sehr nützlich und
        eine Zeitersparnis sein kann, gibt es unglücklicherweise ein
        paar Fallstricke. Erstens ist das Dienstprogramm
        überempfindlich gegenüber der Pfadsemantik. Achten Sie darauf,
        ob die Pfade in Ihrer Auszugsdatei mit oder ohne führende
        Schrägstriche angegeben werden. Sie sollten sich die Einträge
        <literal>Node-path</literal> und
        <literal>Node-copyfrom-path</literal> ansehen.</para>

      <screen>
&hellip;
Node-path: spreadsheet/Makefile
&hellip;
</screen>

<!--
      <para>If the paths have leading slashes, you should
        include leading slashes in the paths you pass to
        <command>svndumpfilter include</command> and
        <command>svndumpfilter exclude</command> (and if they don't,
        you shouldn't).  Further, if your dump file has an inconsistent
        usage of leading slashes for some reason,
        <footnote>
          <para>While <command>svnadmin dump</command> has a
            consistent leading slash policy (to not include
            them), other programs that generate dump data might
            not be so consistent.</para>
        </footnote>
        you should probably normalize those paths so that they all
        have, or all lack, leading slashes.</para>
-->
      <para>Falls die Pfade führende Schrägstriche haben, sollten auch
        Sie Schrägstriche in den Pfaden angeben, die Sie an
        <command>svndumpfilter include</command> und
        <command>svndumpfilter exclude</command> übergeben (und wenn
        sie keine haben, sollten Sie auch keine angeben). Falls Ihre
        Auszugsdatei aus irgendwelchen Gründen einen nicht
        konsistenten Gebrauch von führenden Schrägstrichen macht,
        <footnote>
          <para>Obwohl <command>svnadmin dump</command> ein
            konsistentes Vorgehen bezüglich führender Schrägstriche
            vorweisen kann (indem es sie nicht einfügt), sind andere
            Programme, die Auszugsdateien erzeugen eventuell nicht so
            konsistent.</para>
        </footnote>
        sollten Sie diese Pfade normalisieren, so dass sie alle
        entweder Schrägstriche haben oder nicht.</para>

<!--
      <para>Also, copied paths can give you some trouble.
        Subversion supports copy operations in the repository, where
        a new path is created by copying some already existing path.
        It is possible that at some point in the lifetime of your
        repository, you might have copied a file or directory from
        some location that <command>svndumpfilter</command> is
        excluding, to a location that it is including.  To
        make the dump data self-sufficient,
        <command>svndumpfilter</command> needs to still show the
        addition of the new path&mdash;including the contents of any
        files created by the copy&mdash;and not represent that
        addition as a copy from a source that won't exist in your
        filtered dump data stream.  But because the Subversion
        repository dump format shows only what was changed in each
        revision, the contents of the copy source might not be
        readily available.  If you suspect that you have any copies
        of this sort in your repository, you might want to rethink
        your set of included/excluded paths, perhaps including the
        paths that served as sources of your troublesome copy
        operations, too.</para>
-->
      <para>Ebenso können kopierte Pfade Probleme bereiten. Subversion
        unterstützt Kopieroperationen im Projektarchiv, bei denen ein
        neuer Pfad erzeugt wird, indem ein bereits bestehender kopiert
        wird. Es kann vorkommen, dass Sie zu irgendeinem Zeitpunkt der
        Lebenszeit Ihres Projektarchivs eine Datei oder ein Verzeichnis
        von einer durch <command>svndumpfilter</command> ausgelassenen
        Stelle an eine durch <command>svndumpfilter</command>
        berücksichtigte Stelle kopiert haben. Um die Auszugsdateien
        unabhängig zu machen, muss <command>svndumpfilter</command>
        trotzdem das Hinzufügen des neuen Pfades anzeigen &ndash; mit
        dem Inhalt aller durch die Kopie erzeugten Dateien &ndash;
        allerdings nicht als eine Kopie aus einer Quelle, die es gar
        nicht im gefilterten Auszugsstrom gibt. Da allerdings das
        Subversion Auszugsdateiformat nur Änderungen von Revisionen
        beinhaltet, kann es sein, dass der Inhalt der Quelle der Kopie
        nicht verfügbar ist. Wenn Sie mutmaßen, dass Sie solche Kopien
        in Ihrem Projektarchiv haben, sollten Sie die Auswahl der
        ausgelassenen/berücksichtigten Pfade überdenken, indem Sie
        vielleicht die Pfade, die als Quellen für die problematischen
        Kopien dienten, hinzunehmen.</para>

<!--
      <para>Finally, <command>svndumpfilter</command> takes path
        filtering quite literally.  If you are trying to copy the
        history of a project rooted at
        <filename>trunk/my-project</filename> and move it into a
        repository of its own, you would, of course, use the
        <command>svndumpfilter include</command> command to keep all
        the changes in and under
        <filename>trunk/my-project</filename>.  But the resultant
        dump file makes no assumptions about the repository into
        which you plan to load this data.  Specifically, the dump
        data might begin with the revision that added the
        <filename>trunk/my-project</filename> directory, but it will
        <emphasis>not</emphasis> contain directives that would
        create the <filename>trunk</filename> directory itself
        (because <filename>trunk</filename> doesn't match the
        include filter).  You'll need to make sure that any
        directories that the new dump stream expects to exist
        actually do exist in the target repository before trying to
        load the stream into that repository.</para>
-->
      <para>Schließlich behandelt <command>svndumpfilter</command>
        Pfadfilterung ziemlich wörtlich. Wenn Sie die Historie eines
        Projektes mit dem Wurzelverzeichnis
        <filename>trunk/my-project</filename> kopieren und sie in ein
        eigenes Projektarchiv verschieben möchten, werden Sie
        selbstverständlich den Befehl <command>svndumpfilter
        include</command> verwenden, um alle Änderungen in und
        unterhalb von <filename>trunk/my-project</filename> zu
        bewahren. Doch macht die entstehende Auszugsdatei keinerlei
        Annahmen bezüglich des Projektarchivs, in das Sie die Daten zu
        laden beabsichtigen. In diesem besonderen Fall könnten die
        Auszugsdaten mit der Revision beginnen, die das Verzeichnis
        <filename>trunk/my-project</filename> hinzugefügt hat, doch
        sie werden <emphasis>keine</emphasis> Direktiven enthalten,
        dir das Verzeichnis <filename>trunk</filename> selbst anlegen
        (weil <filename>trunk</filename> nicht zum Filter der zu
        berücksichtigenden Pfade passt). Sie müssen sicherstellen,
        dass alle Verzeichnisse, die der Auszugsstrom erwartet,
        tatsächlich im Ziel-Projektarchiv vorhanden sind, bevor Sie
        versuchen, den Strom in dieses Projektarchiv zu laden.</para>

    </sect2>
  
    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.replication">
<!--
      <title>Repository Replication</title>
-->
      <title>Projektarchiv Replikation</title>

<!--
      <para>There are several scenarios in which it is quite handy to
        have a Subversion repository whose version history is exactly
        the same as some other repository's.  Perhaps the most obvious
        one is the maintenance of a simple backup repository, used
        when the primary repository has become inaccessible due to a
        hardware failure, network outage, or other such annoyance.
        Other scenarios include deploying mirror repositories to
        distribute heavy Subversion load across multiple servers, use
        as a soft-upgrade mechanism, and so on.</para>
-->
      <para>Es gibt mehrere Szenarien, in denen es sehr passend ist,
        ein Subversion-Projektarchiv zu haben, dessen Versionshistorie
        genau dieselbe wie die eines anderen Projektarchivs ist.
        Vielleicht das offensichtlichste ist die Aufrechterhaltung
        eines Projektarchivs als einfache Sicherheitskopie, das verwendet
        wird, wenn das primäre Projektarchiv wegen Materialdefekt,
        Netzausfall oder ähnlichen Ärgernissen unzugänglich geworden
        ist. Andere Szenarien umfassen den Einsatz von
        Spiegel-Projektarchiven, um heftige Subversion-Last über mehrere
        Server zu verteilen, zum sanften Aufrüsten usw.</para>

<!--
      <para>As of version 1.4, Subversion provides a program for
        managing scenarios such as
        these&mdash;<command>svnsync</command>.  This works by
        essentially asking the Subversion server to
        <quote>replay</quote> revisions, one at a time.  It then uses
        that revision information to mimic a commit of the same to
        another repository.  Neither repository needs to be locally
        accessible to the machine on which <command>svnsync</command> is
        running&mdash;its parameters are repository URLs, and it does
        all its work through Subversion's Repository Access (RA)
        interfaces.  All it requires is read access to the source
        repository and read/write access to the destination
        repository.</para>
-->
      <para>Seit Version 1.4 stellt Subversion ein Programm zur
        Handhabung solcher Szenarien zur Verfügung &ndash;
        <command>svnsync</command>. Im Wesentlichen funktioniert das,
        indem der Subversion-Server aufgefordert wird, Revisionen zu
        <quote>wiederholen</quote>, eine nach der anderen. Dann wird
        die Information dieser Revision benutzt, um eine Übergabe
        derselben an ein anderes Projektarchiv zu imitieren. Keins der
        Projektarchive muss lokal auf der Maschine liegen, auf der
        <command>svnsync</command> läuft &ndash; seine Parameter sind
        Projektarchiv-URLs, und es verrichtet seine gesamte Arbeit über
        die Projektarchiv-Access-Schnittstellen (RA) von Subversion. Das
        Einzige, was benötigt wird, ist Lesezugriff auf das
        Quell-Projektarchiv und Lese-/Schreibzugriff auf das
        Ziel-Projektarchiv.</para>

      <note>
<!--
        <para>When using <command>svnsync</command> against a remote
          source repository, the Subversion server for that repository
          must be running Subversion version 1.4 or later.</para>
-->
        <para>Wenn Sie <command>svnsync</command> mit einem entfernt
          liegenden Quell-Projektarchiv verwenden, muss auf dem
          Subversion-Server für dieses Projektarchiv Subversion 1.4 oder
          neuer laufen.</para>
      </note>

<!--
      <para>Assuming you already have a source repository that you'd
        like to mirror, the next thing you need is an empty target
        repository that will actually serve as that mirror.  This
        target repository can use either of the available filesystem
        data-store backends (see <xref
        linkend="svn.reposadmin.basics.backends" />), but it must not
        yet have any version history in it.  The protocol that
        <command>svnsync</command> uses to communicate revision information
        is highly sensitive to mismatches between the versioned
        histories contained in the source and target repositories.
        For this reason, while <command>svnsync</command> cannot
        <emphasis>demand</emphasis> that the target repository be
        read-only,
        <footnote>
          <para>In fact, it can't truly be read-only, or
            <command>svnsync</command> itself would have a tough time
            copying revision history into it.</para>
        </footnote>
        allowing the revision history in the target repository to
        change by any mechanism other than the mirroring process is a
        recipe for disaster.</para>
-->
      <para>Angenommen, Sie haben bereits ein Projektarchiv, das Sie
        gerne spiegeln möchten. Als nächstes brauchen Sie ein leeres
        Ziel-Projektarchiv, das als Spiegel dienen soll. Dieses
        Projektarchiv kann eins der verfügbaren Speicherverfahren
        benutzen (siehe <xref
        linkend="svn.reposadmin.basics.backends" />), doch es darf
        noch keine Versionshistorie enthalten. Das von
        <command>svnsync</command> verwendete Protokoll zur
        Übermittlung der Revisionsinformation ist sehr empfindlich
        gegenüber nicht übereinstimmenden Versionshistorien im
        Quell- und Ziel-Projektarchiv. Aus dem Grund, dass
        <command>svnsync</command> nicht
        <emphasis>verlangen</emphasis> kann, dass das Ziel-Projektarchiv
        nur lesbar ist,
        <footnote>
          <para>Tatsächlich kann es gar nicht nur lesbar sein, denn
            sonst hätte <command>svnsync</command> ein echtes Problem,
            die Versionshistorie hineinzukopieren.</para>
        </footnote>
        ist die Katastrophe programmiert, wenn erlaubt wird, die
        Revisions-Historie im Ziel-Projektarchiv mit anderen Mitteln als
        durch das Spiegeln zu verändern.</para>

      <warning>
<!--
        <para>Do <emphasis>not</emphasis> modify a mirror repository
          in such a way as to cause its version history to deviate
          from that of the repository it mirrors.  The only commits
          and revision property modifications that ever occur on that
          mirror repository should be those performed by the
          <command>svnsync</command> tool.</para>
-->
        <para>Verändern Sie ein Spiegel-Projektarchiv
          <emphasis>nicht</emphasis> auf eine Art und Weise, die dazu
          führt, dass die Versionshistorie von der des
          Original-Projektarchivs abweicht. Die einzigen Übergaben und
          Änderungen an Revisions-Propertys die in diesem
          Spiegel-Projektarchiv stattfinden, sollten ausschließlich durch
          den Befehl <command>svnsync</command> vorgenommen
          werden.</para>
      </warning>

<!--
      <para>Another requirement of the target repository is that the
        <command>svnsync</command> process be allowed to modify
        revision properties.  Because <command>svnsync</command> works
        within the framework of that repository's hook system, the
        default state of the repository (which is to disallow revision
        property changes; see <xref
        linkend="svn.ref.reposhooks.pre-revprop-change" />) is
        insufficient.  You'll need to explicitly implement the
        pre-revprop-change hook, and your script must allow
        <command>svnsync</command> to set and change revision
        properties.  With those provisions in place, you are ready to
        start mirroring repository revisions.</para>
-->
      <para>Eine weitere Anforderung an das Ziel-Projektarchiv ist, dass
        dem <command>svnsync</command>-Prozess erlaubt wird,
        Revisions-Propertys zu verändern. Da
        <command>svnsync</command> im Rahmen des Hook-Systems
        ausgeführt wird, ist der standardmäßige Zustand des
        Projektarchivs (welcher keine Änderungen an Revisions-Propertys
        zulässt; siehe <xref
        linkend="svn.ref.reposhooks.pre-revprop-change" />) nicht
        ausreichend. Sie müssen ausdrücklich den
        pre-revprop-change-Hook bereitstellen, der
        <command>svnsync</command> erlaubt, Revisions-Propertys zu
        definieren und zu ändern. Mit diesen Vorkehrungen sind Sie
        gerüstet, um Projektarchiv-Revisionen zu spiegeln.</para>

      <tip>
<!--
        <para>It's a good idea to implement authorization measures
          that allow your repository replication process to perform
          its tasks while preventing other users from modifying the
          contents of your mirror repository at all.</para>
-->
        <para>Es ist eine gute Idee, Autorisierungsmaßnahmen zu
          ergreifen, um Ihrem Projektarchiv-Replikations-Prozess die
          Arbeit zu ermöglichen, wohingegen anderen Benutzern die
          Veränderung der Inhalte des Spiegel-Projektarchivs verwehrt
          wird.</para>
      </tip>

<!--
      <para>Let's walk through the use of <command>svnsync</command>
        in a somewhat typical mirroring scenario.  We'll pepper this
        discourse with practical recommendations, which you are free to
        disregard if they aren't required by or suitable for your
        environment.</para>
-->
      <para>Lassen Sie uns nun die Benutzung von
        <command>svnsync</command> bei einem Rundgang in einem
        typischen Spiegel-Szenario erklären. Wir werden diesen Diskurs
        mit Empfehlungen würzen, die Sie jedoch getrost missachten
        können, falls sie für Ihre Umgebung nicht benötigt werden oder
        nicht passend sind.</para>

<!--
      <para>As a service to the fine developers of our favorite
        version control system, we will be mirroring the public
        Subversion source code repository and exposing that mirror
        publicly on the Internet, hosted on a different machine than
        the one on which the original Subversion source code
        repository lives.  This remote host has a global configuration
        that permits anonymous users to read the contents of
        repositories on the host, but requires users to authenticate
        to modify those repositories.  (Please forgive us for
        glossing over the details of Subversion server configuration
        for the moment&mdash;those are covered thoroughly in <xref
        linkend="svn.serverconfig" />.)  And for no other reason than
        that it makes for a more interesting example, we'll be driving
        the replication process from a third machine&mdash;the one that
        we currently find ourselves using.</para>
-->
      <para>Als Dienst an den ausgezeichneten Entwicklern unseres
        Lieblings-Versionskontrollsystems wollen wir das öffentliche
        Subversion-Quelltext-Projektarchiv spiegeln und diesen Spiegel
        von einer anderen Maschine als der, auf der das ursprüngliche
        Subversion-Quelltext-Projektarchiv untergebracht ist, im Internet
        veröffentlichen. Dieser entfernt liegende Rechner besitzt eine
        globale Konfiguration, die es anonymen Benutzern erlaubt, den
        Inhalt von Projektarchivs auf diesem Rechner zu lesen, aber zum
        Ändern dieser Projektarchive eine Authentifizierung der Benutzer
        erforderlich macht. (Vergeben Sie uns bitte, dass wir für den
        Augenblick über die Details der
        Subversion-Server-Konfiguration hinwegsehen &ndash; sie werden
        in <xref linkend="svn.serverconfig" /> behandelt.) Und aus dem
        alleinigen Grund, es noch interessanter machen zu wollen,
        werden wir den Replikationsprozess von einer dritten Maschine
        aus steuern &ndash; diejenige, die wir aktuell
        benutzen.</para>

<!--
      <para>First, we'll create the repository which will be our
        mirror.  This and the next couple of steps do require shell
        access to the machine on which the mirror repository will
        live.  Once the repository is all configured, though, we
        shouldn't need to touch it directly again.</para>
-->
      <para>Zunächst erstellen wir das Projektarchiv, das unser Spiegel
        sein soll. Dieser und die folgenden paar Schritte erfordern
        einen Shell-Zugang auf die Maschine, die das
        Spiegel-Projektarchiv beherbergen soll. Sobald das Projektarchiv
        jedoch konfiguriert ist, sollten wir nicht mehr direkt darauf
        zugreifen müssen.</para>

      <screen>
$ ssh admin@svn.example.com \
      "svnadmin create /var/svn/svn-mirror"
admin@svn.example.com's password: ********
$
</screen>

<!--
      <para>At this point, we have our repository, and due to our
        server's configuration, that repository is now
        <quote>live</quote> on the Internet.  Now, because we don't
        want anything modifying the repository except our replication
        process, we need a way to distinguish that process from other
        would-be committers.  To do so, we use a dedicated username
        for our process.  Only commits and revision property
        modifications performed by the special username
        <literal>syncuser</literal> will be allowed.</para>
-->
      <para>Zu diesem Zeitpunkt haben wir unser Projektarchiv, und wegen
        unserer Server-Konfiguration ist das Projektarchiv nun
        <quote>live</quote> im Internet. Da wir aber außer unserem
        Replikationsprozess niemanden erlauben wollen, das Projektarchiv
        zu ändern, benötigen wir eine Möglichkeit, diesen Prozess von
        anderen potentiellen Zugriffen zu unterscheiden. Um dies zu
        machen, verwenden wir einen ausgezeichneten Benutzernamen für
        unseren Prozess. Nur Übergaben und Änderungen an
        Revisions-Propertys unter dem Benutzerkonto
        <literal>syncuser</literal> werden erlaubt.</para>

<!--
      <para>We'll use the repository's hook system both to allow the
        replication process to do what it needs to do and to enforce
        that only it is doing those things.  We accomplish this by
        implementing two of the repository event
        hooks&mdash;pre-revprop-change and start-commit.  Our
        <filename>pre-revprop-change</filename> hook script is found
        in <xref
        linkend="svn.reposadmin.maint.replication.pre-revprop-change"
        />, and basically verifies that the user attempting the
        property changes is our <literal>syncuser</literal> user.  If
        so, the change is allowed; otherwise, it is denied.</para>
-->
      <para>Wir verwenden das Hook-System des Projektarchivs sowohl, um
        dem Replikationsprozess seine Arbeit zu ermöglichen, als auch,
        um sicherzustellen, dass nur er diese Dinge tut. Wir
        bewerkstelligen dies, indem wir zwei der
        Projektarchiv-Ereignis-Hooks implementieren &ndash;
        pre-revprop-change und start-commit. Unser
        <filename>pre-revprop-change</filename>-Hook-Script finden Sie
        in <xref
        linkend="svn.reposadmin.maint.replication.pre-revprop-change"
        />; grundsätzlich stellt es sicher, dass der Benutzer, der die
        Propertys ändern möchte, unser <literal>syncuser</literal>
        ist. Falls dies zutrifft, ist die Änderung erlaubt,
        anderenfalls wird die Änderung abgelehnt.</para>

      <example id="svn.reposadmin.maint.replication.pre-revprop-change">
<!--
        <title>Mirror repository's pre-revprop-change hook script</title>
-->
        <title>pre-revprop-change-Hook-Script des Spiegel-Projektarchivs</title>

<!--
        <programlisting>
#!/bin/sh 

USER="$3"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Only the syncuser user may change revision properties" &gt;&amp;2
exit 1
</programlisting>
-->
        <programlisting>
#!/bin/sh 

USER="$3"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Ausschließlich der Benutzer syncuser darf Revisions-Propertys ändern" &gt;&amp;2
exit 1
</programlisting>
      </example>

<!--
      <para>That covers revision property changes.  Now we need to
        ensure that only the <literal>syncuser</literal> user is
        permitted to commit new revisions to the repository.  We do
        this using a <filename>start-commit</filename> hook scripts
        such as the one in <xref
        linkend="svn.reposadmin.maint.replication.start-commit"
        />.</para>
-->
      <para>Das deckt Änderungen an Revisions-Propertys ab. Nun müssen
        wir sicherstellen, dass nur der Benutzer
        <literal>syncuser</literal> neue Revisionen an das Projektarchiv
        übergeben darf. Wir machen das, indem wir ein
        <filename>start-commit</filename>-Hook-Script wie das in <xref
        linkend="svn.reposadmin.maint.replication.start-commit" />
        benutzen.</para>

      <example id="svn.reposadmin.maint.replication.start-commit">
<!--
        <title>Mirror repository's start-commit hook script</title>
-->
        <title>start-commit-Hook-Script des Spiegel-Projektarchivs</title>

<!--
        <programlisting>
#!/bin/sh 

USER="$2"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Only the syncuser user may commit new revisions" &gt;&amp;2
exit 1
</programlisting>
-->
        <programlisting>
#!/bin/sh 

USER="$2"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Ausschließlich der Benutzer syncuser darf neue Revisionen übergeben" &gt;&amp;2
exit 1
</programlisting>
      </example>

<!--
      <para>After installing our hook scripts and ensuring that they
        are executable by the Subversion server, we're finished with
        the setup of the mirror repository.  Now, we get to actually
        do the mirroring.</para>
-->
      <para>Nachdem wir unsere Hook-Scripte installiert und uns
        vergewissert haben, dass sie auf dem Subversion-Server
        ausführbar sind, sind wir mit dem Aufsetzen des
        Spiegel-Projektarchivs fertig. Nun kommen wir zum eigentlichen
        Spiegeln.</para>

<!--
      <para>The first thing we need to do with
        <command>svnsync</command> is to register in our target
        repository the fact that it will be a mirror of the source
        repository.  We do this using the <command>svnsync
        initialize</command> subcommand.  The URLs we provide point to
        the root directories of the target and source repositories,
        respectively.  In Subversion 1.4, this is required&mdash;only
        full mirroring of repositories is permitted.  In Subversion
        1.5, though, you can use <command>svnsync</command> to mirror
        only some subtree of the repository, too.</para>
-->
      <para>Das Erste, was wir machen müssen ist, unserem
        Ziel-Projektarchiv mit <command>svnsync</command> zu sagen, dass
        es ein Spiegel des Quell-Projektarchivs sein wird. Wir machen das
        mit dem Unterbefehl <command>svnsync initialize</command>. Die
        URLs, die wir mitgeben, zeigen auf die Wurzelverzeichnisse des
        Ziel- bzw. Quell-Projektarchivs. In Subversion 1.4 ist das
        erforderlich &ndash; nur die vollständige Spiegelung von
        Projektarchiven ist erlaubt. In Subversion 1.5 jedoch können Sie
        <command>svnsync</command> auch zum Spiegeln von Teilbäumen
        des Projektarchivs verwenden.</para>

<!--
      <screen>
$ svnsync help init
initialize (init): usage: svnsync initialize DEST_URL SOURCE_URL

Initialize a destination repository for synchronization from
another repository.
&hellip;
$ svnsync initialize http://svn.example.com/svn-mirror \
                     http://svn.collab.net/repos/svn \
                     - -sync-username syncuser - -sync-password syncpass
Copied properties for revision 0.
$
</screen>
-->
      <screen>
$ svnsync help init
initialize (init): Aufruf: svnsync initialize ZIEL_URL QUELL_URL

Bereitet ein Zielprojektarchiv auf die Synchronisation mit einem
anderen Projektarchiv vor.
&hellip;
$ svnsync initialize http://svn.example.com/svn-mirror \
                     http://svn.collab.net/repos/svn \
                     --sync-username syncuser --sync-password syncpass
Eigenschaften für Revision 0 kopiert.
$
</screen>

<!--
      <para>Our target repository will now remember that it is a
        mirror of the public Subversion source code repository.
        Notice that we provided a username and password as arguments
        to <command>svnsync</command>&mdash;that was required by the
        pre-revprop-change hook on our mirror repository.</para>
-->
      <para>Unser Ziel-Projektarchiv wird sich nun erinnern, dass es ein
        Spiegel des öffentlichen Subversion-Quelltext-Projektarchivs ist.
        Beachten Sie, dass wir einen Benutzernamen und ein Passwort an
        <command>svnsync</command> übergeben haben &ndash; das war für
        den pre-revprop-change-Hook in unserem Spiegel-Projektarchiv
        erforderlich.</para>

      <note>
<!--
        <para>In Subversion 1.4, the values given to
          <command>svnsync</command>'s <option>- -username</option> and
          <option>- -password</option> command-line options were used
          for authentication against both the source and destination
          repositories.  This caused problems when a user's
          credentials weren't exactly the same for both repositories,
          especially when running in noninteractive mode (with the
          <option>- -non-interactive</option> option).</para>
-->
        <para>In Subversion 1.4 wurden die an die
          Kommandozeilenoptionen <option>--username</option> und
          <option>--password</option> von <command>svnsync</command>
          übergebenen Werte sowohl für die Authentifizierung gegenüber
          dem Quell-Projektarchiv als auch gegenüber dem Ziel-Projektarchiv
          verwendet. Das führte zu Problemen, falls die Zugangsdaten
          eines Benutzers nicht für beide Projektarchive identisch waren,
          insbesonders im nicht-interaktiven Modus (mit der Option
          <option>--non-interactive</option>).</para>

<!--
        <para>This has been fixed in Subversion 1.5 with the
          introduction of two new pairs of options.  Use
          <option>- -source-username</option> and
          <option>- -source-password</option> to provide authentication
          credentials for the source repository; use
          <option>- -sync-username</option> and
          <option>- -sync-password</option> to provide credentials for
          the destination repository.  (The old
          <option>- -username</option> and <option>- -password</option>
          options still exist for compatibility, but we advise against
          using them.)</para>
-->
        <para>Dies ist in Subversion 1.5 mit der Einführung von zwei
          neuen Optionspaaren behoben worden. Benutzen Sie
          <option>--source-username</option> und
          <option>--source-password</option> für die Zugangsdaten des
          Quell-Projektarchivs sowie <option>--sync-username</option> und
          <option>--sync-password</option> für das Ziel-Projektarchiv.
          (Die alten Optionen <option>--username</option> und
          <option>--password</option> bleiben aus
          Kompatibilitätsgründen bestehen, doch raten wir von deren
          Verwendung ab.)</para>

      </note>

<!--
      <para>And now comes the fun part.  With a single subcommand, we
        can tell <command>svnsync</command> to copy all the
        as-yet-unmirrored revisions from the source repository to the
        target.
        <footnote>
          <para>Be forewarned that while it will take only a few
            seconds for the average reader to parse this paragraph and
            the sample output that follows it, the actual time
            required to complete such a mirroring operation is, shall
            we say, quite a bit longer.</para>
        </footnote>
        The <command>svnsync synchronize</command> subcommand will
        peek into the special revision properties previously stored on
        the target repository, and determine both what repository it
        is mirroring as well as that the most recently mirrored
        revision was revision 0.  Then it will query the source
        repository and determine what the latest revision in that
        repository is.  Finally, it asks the source repository's
        server to start replaying all the revisions between 0 and that
        latest revision.  As <command>svnsync</command> get the
        resultant response from the source repository's server, it
        begins forwarding those revisions to the target repository's
        server as new commits.</para>
-->
      <para>Und nun kommt der lustige Teil. Mit einem einfachen
        Unterbefehl können wir <command>svnsync</command> auffordern,
        alle bislang ungespiegelten Revisionen aus dem
        Quell-Projektarchiv zum Ziel zu kopieren.
        <footnote>
          <para>Seien Sie jedoch vorgewarnt, dass, obwohl der
            durchschnittliche Leser nur ein paar Sekunden benötigt, um
            diesen Absatz und die ihm folgende Beispielausgabe zu
            erfassen, die tatsächlich für eine vollständige Spiegelung
            erforderliche Zeit um Einiges länger ist.</para>
        </footnote>
        Der Unterbefehl <command>svnsync synchronize</command> wird
        die bereits vorher im Ziel-Projektarchiv gespeicherten besonderen
        Revisions-Propertys untersuchen und sowohl ermitteln, welches
        Projektarchiv es spiegelt und dass die zuletzt gespiegelte
        Revision die Revision 0 war. Dann fragt es das Quell-Projektarchiv
        ab, welches die jüngste Revision in diesem Projektarchiv ist.
        Schließlich fordert es den Server des Quell-Projektarchivs auf,
        alle Revisionen zwischen 0 und dieser letzten Revision
        zu wiederholen. Sobald <command>svnsync</command> die
        entsprechende Antwort vom Quell-Projektarchiv-Server erhält,
        leitet es diese Revisionen als neue Übergaben an den Server
        des Ziel-Projektarchivs weiter.</para>

<!--
      <screen>
$ svnsync help synchronize
synchronize (sync): usage: svnsync synchronize DEST_URL

Transfer all pending revisions to the destination from the source
with which it was initialized.
&hellip;
$ svnsync synchronize http://svn.example.com/svn-mirror
Transmitting file data ........................................
Committed revision 1.
Copied properties for revision 1.
Transmitting file data ..
Committed revision 2.
Copied properties for revision 2.
Transmitting file data .....
Committed revision 3.
Copied properties for revision 3.
&hellip;
Transmitting file data ..
Committed revision 23406.
Copied properties for revision 23406.
Transmitting file data .
Committed revision 23407.
Copied properties for revision 23407.
Transmitting file data ....
Committed revision 23408.
Copied properties for revision 23408.
$
</screen>
-->
      <screen>
$ svnsync help synchronize
synchronize (sync): Aufruf: svnsync synchronize ZIEL_URL

Überträgt alle laufenden Revisionen von der Quelle, mit der es
initialisiert wurde, zum Ziel.
&hellip;
$ svnsync synchronize http://svn.example.com/svn-mirror
Übertrage Daten ........................................
Revision 1 übertragen.
Eigenschaften für Revision 1 kopiert.
Übertrage Daten ..
Revision 2 übertragen.
Eigenschaften für Revision 2 kopiert.
Übertrage Daten .....
Revision 3 übertragen.
Eigenschaften für Revision 3 kopiert.
&hellip;
Übertrage Daten ..
Revision 23406 übertragen.
Eigenschaften für Revision 23406 kopiert.
Übertrage Daten .
Revision 23407 übertragen.
Eigenschaften für Revision 23407 kopiert.
Übertrage Daten ....
Revision 23408 übertragen.
Eigenschaften für Revision 23408 kopiert.
$
</screen>

<!--
      <para>Of particular interest here is that for each mirrored
        revision, there is first a commit of that revision to the
        target repository, and then property changes follow.  This is
        because the initial commit is performed by (and attributed to)
        the user <literal>syncuser</literal>, and it is datestamped
        with the time as of that revision's creation.  Also,
        Subversion's underlying repository access interfaces don't
        provide a mechanism for setting arbitrary revision properties
        as part of a commit.  So <command>svnsync</command> follows up
        with an immediate series of property modifications that copy
        into the target repository all the revision properties found
        for that revision in the source repository.  This also has the
        effect of fixing the author and datestamp of the revision to
        match that of the source repository.</para>
-->
      <para>Von besonderem Interesse ist hier, dass für jede
        gespiegelte Revision zunächst eine Übergabe der Revision an
        das Ziel-Projektarchiv erfolgt und dann die Änderungen der
        Propertys folgen. Das kommt daher, dass die anfängliche
        Übergabe durch den Benutzer <literal>syncuser</literal>
        durchgeführt (und ihm auch zugeschrieben) wird und mit dem
        Zeitstempel der Erzeugung dieser Revision versehen wird.
        Darüberhinaus erlauben die Subversion zugrundeliegenden
        Projektarchiv-Zugriffs-Schnittstellen nicht das beliebige Setzen
        von Revisions-Propertys als Teil einer Übergabe. Deshalb folgt
        <command>svnsync</command> mit einer unmittelbaren Serie von
        Änderungen an den Propertys, die all die Propertys dieser
        Revision vom Quell-Projektarchiv ins Ziel-Projektarchiv kopieren.
        Das hat auch den Effekt, dass der Autor und der Zeitstempel so
        korrigiert werden, dass diese den entsprechenden Werten im
        Quell-Projektarchiv entsprechen.</para>

<!--
      <para>Also noteworthy is that <command>svnsync</command>
        performs careful bookkeeping that allows it to be safely
        interrupted and restarted without ruining the integrity of the
        mirrored data.  If a network glitch occurs while mirroring a
        repository, simply repeat the <command>svnsync
        synchronize</command> command, and it will happily pick up
        right where it left off.  In fact, as new revisions appear in
        the source repository, this is exactly what you to do
        to keep your mirror up to date.</para>
-->
      <para>Bemerkenswert ist ebenfalls, dass
        <command>svnsync</command> eine sorgfältige Buchführung
        vornimmt, die es ihm erlaubt, sicher unterbrochen und erneut
        gestartet zu werden, ohne die Integrität der gespiegelten
        Daten zu gefährden. Falls während des Spiegelns ein
        Netzproblem entsteht, wiederholen Sie einfach den Befehl
        <command>svnsync synchronize</command>, und er wird einfach
        damit weitermachen, womit er aufgehört hat. Das ist
        tatsächlich genau das, was Sie machen, um Ihren Spiegel
        aktuell zu halten, wenn neue Revisionen im Quell-Projektarchiv
        auftauchen.</para>

      <sidebar>
<!--
        <title>svnsync Bookkeeping</title>
-->
        <title>svnsync-Buchhaltung</title>

<!--
        <para><command>svnsync</command> needs to be able to set and
          modify revision properties on the mirror repository because
          those properties are part of the data it is tasked with
          mirroring.  As those properties change in the source
          repository, those changes need to be reflected in the mirror
          repository, too.  But <command>svnsync</command> also uses a
          set of custom revision properties&mdash;stored in revision 0
          of the mirror repository&mdash;for its own internal
          bookkeeping.  These properties contain information such as
          the URL and UUID of the source repository, plus some
          additional state-tracking information.</para>
-->
        <para><command>svnsync</command> muss in der Lage sein,
          Revisions-Propertys im Ziel-Projektarchiv zu setzen und zu
          verändern, da diese Propertys Teil der Daten sind, die es
          spiegeln soll. Wenn sich diese Propertys im Quell-Projektarchiv
          ändern, müssen sie im Ziel-Projektarchiv nachgezogen werden.
          Allerdings verwendet <command>svnsync</command> auch eine
          Menge von speziellen Revisions-Propertys &ndash;
          gespeichert in Revision 0 des Spiegel-Projektarchivs &ndash;
          für seine eigene interne Buchhaltung. Diese Propertys
          beinhalten Informationen wie etwa der URL oder die UUID des
          Quell-Projektarchivs plus einige Informationen zur
          Zustandsverfolgung.</para>

<!--
        <para>One of those pieces of state-tracking information is a
          flag that essentially just means <quote>there's a
          synchronization in progress right now.</quote>  This is used
          to prevent multiple <command>svnsync</command> processes
          from colliding with each other while trying to mirror data
          to the same destination repository.  Now, generally you
          won't need to pay any attention whatsoever to
          <emphasis>any</emphasis> of these special properties (all of
          which begin with the prefix <literal>svn:sync-</literal>).
          Occasionally, though, if a synchronization fails
          unexpectedly, Subversion never has a chance to remove this
          particular state flag.  This causes all future
          synchronization attempts to fail because it appears that a
          synchronization is still in progress when, in fact, none is.
          Fortunately, recovering from this situation is as simple as
          removing the <literal>svn:sync-lock</literal> property which
          serves as this flag from revision 0 of the mirror
          repository:</para>
-->
        <para>Ein Teil dieser Zustandsverfolgungsinformation ist ein
          Flag, das bedeutet: <quote>momentan findet eine
          Synchronisierung statt</quote>. Dies wird verwendet, um zu
          verhindern, dass mehrere <command>svnsync</command>-Prozesse
          miteinander kollidieren, während sie versuchen, Daten in
          dasselbe Ziel-Projektarchiv zu spiegeln. Im Allgemeinen
          brauchen Sie auf <emphasis>keins</emphasis> dieser
          besonderen Propertys zu achten (sie beginnen alle mit dem
          Präfix <literal>svn:sync-</literal>). Gelegentlich jedoch,
          falls eine Synchronisierung unerwartet fehlschlägt, bekommt
          Subversion keine Chance, dieses besondere Zustands-Flag zu
          entfernen. Das führt dazu, dass alle weiteren
          Synchronisierungsversuche fehlschlagen, da es scheint, dass
          eine Synchronisierung gerade durchgeführt wird, obwohl
          tatsächlich keine stattfindet. Glücklicherweise kann dies
          behoben werden, indem einfach das Property
          <literal>svn:sync-lock</literal> von Revision 0 des
          Spiegel-Projektarchivs entfernt wird, das als dieses Flag
          dient.</para>

<!--
        <screen>
$ svn propdel - -revprop -r0 svn:sync-lock http://svn.example.com/svn-mirror
property 'svn:sync-lock' deleted from repository revision 0
$
</screen>
-->
        <screen>
$ svn propdel --revprop -r0 svn:sync-lock http://svn.example.com/svn-mirror
Eigenschaft »svn:sync-lock« wurde von Revision 0 im Projektarchiv gelöscht
$
</screen>

<!--
        <para>That <command>svnsync</command> stores the source
          repository URL in a bookkeeping property on the mirror
          repository is the reason why you have to specify that
          URL only once, during <command>svnsync init</command>.  Future
          synchronization operations against that mirror simply
          consult the special <literal>svn:sync-from-url</literal>
          property stored on the mirror itself to know where
          to synchronize from.  This value is used literally by the
          synchronization process, though.  So while from within
          CollabNet's network you can perhaps access our example
          source URL as <literal>http://svn/repos/svn</literal>
          (because that first <literal>svn</literal> magically gets
          <literal>.collab.net</literal> appended to it by DNS
          voodoo), if you later need to update that mirror from
          another machine outside CollabNet's network, the
          synchronization might fail (because the hostname
          <literal>svn</literal> is ambiguous).  For this reason, it's
          best to use fully qualified source repository URLs when
          initializing a mirror repository rather than those that
          refer to only hostnames or IP addresses (which can change
          over time).  But here again, if you need an existing mirror
          to start referring to a different URL for the same source
          repository, you can change the bookkeeping property which
          houses that information:</para>
-->
        <para>Dass <command>svnsync</command> den URL des
          Quell-Projektarchivs zur Buchhaltung in einem Property des
          Spiegel-Projektarchivs speichert, ist der Grund dafür, dass Sie
          diesen URL nur einmal angeben müssen: bei <command>svnsync
          init</command>. Künftige Synchronisierungs-Operationen mit
          diesem Spiegel lesen einfach das besondere Property
          <literal>svn:sync-from-url</literal>, das auf dem Spiegel
          gespeichert ist, um zu wissen, woher synchronisiert werden
          soll. Dieser Wert wird vom Synchronisierungsprozess jedoch
          wortwörtlich benutzt. Während Sie vielleicht innerhalb des
          Netzes von CollabNet auf unseren Beispiel-URL
          <literal>http://svn/repos/svn</literal> zugreifen können
          (weil das erste <literal>svn</literal> durch
          DNS-Voodoo-Zauber ein <literal>.collab.net</literal>
          angehängt bekommt), kann der Zugriff fehlschlagen, falls Sie
          später einmal den Spiegel von außerhalb des CollabNet-Netzes
          aktualisieren müssen (da der Rechnername
          <literal>svn</literal> mehrdeutig ist). Aus diesem Grund ist
          es am besten, beim Initialisieren von Spiegel-Projektarchivs
          vollqualifizierte Quell-Projektarchiv-URLs zu verwenden,
          anstatt solche, die nur auf Rechnernamen oder IP-Adressen
          verweisen (die sich im Lauf der Zeit ändern können). Aber
          auch hier können Sie das Property zur Buchhaltung ändern,
          falls ein bestehender Spiegel einen unterschiedlichen URL
          für dasselbe Quell-Projektarchiv benötigt:</para>

<!--
        <screen>
$ svn propset - -revprop -r0 svn:sync-from-url <replaceable>NEW-SOURCE-URL</replaceable> \
      http://svn.example.com/svn-mirror
property 'svn:sync-from-url' set on repository revision 0
$
</screen>
-->
        <screen>
$ svn propset --revprop -r0 svn:sync-from-url <replaceable>NEUER-QUELL-URL</replaceable> \
      http://svn.example.com/svn-mirror
Eigenschaft »svn:sync-from-url« wurde für Revision 0 im Projektarchiv gesetzt
$
</screen>

<!--
        <para>Another interesting thing about these special
          bookkeeping properties is that <command>svnsync</command>
          will not attempt to mirror any of those properties when they
          are found in the source repository.  The reason is probably
          obvious, but basically boils down to
          <command>svnsync</command> not being able to distinguish the
          special properties it has merely copied from the source
          repository from those it needs to consult and maintain for
          its own bookkeeping needs.  This situation could occur if,
          for example, you were maintaining a mirror of a mirror of a
          third repository.  When <command>svnsync</command> sees its
          own special properties in revision 0 of the source
          repository, it simply ignores them.</para>
-->
        <para>Eine weitere interessante Angelegenheit an diesen
          speziellen Propertys zur Buchhaltung ist, dass
          <command>svnsync</command> nicht versucht, diese Propertys
          zu spiegeln, wenn sie im Quell-Projektarchiv gefunden werden.
          Der Grund ist wahrscheinlich offensichtlich, aber im Grunde
          läuft es darauf hinaus, dass <command>svnsync</command>
          nicht zu unterscheiden vermag, welche der speziellen
          Propertys es bloß aus dem Quell-Projektarchiv kopiert hat und
          welche es für seine Buchhaltung benötigt und verwaltet.
          Diese Situation kann auftreten, falls Sie beispielsweise
          einen Spiegel eines Spiegels eines dritten Projektarchivs
          vorhalten. Wenn <command>svnsync</command> seine eigenen
          speziellen Propertys in Revision 0 des Quell-Projektarchivs
          entdeckt, ignoriert es sie einfach.</para>

      </sidebar>

<!--
      <para>There is, however, one bit of inelegance in the process.
        Because Subversion revision properties can be changed at any
        time throughout the lifetime of the repository, and because
        they don't leave an audit trail that indicates when they were
        changed, replication processes have to pay special attention
        to them.  If you've already mirrored the first 15 revisions of
        a repository and someone then changes a revision property on
        revision 12, <command>svnsync</command> won't know to go back
        and patch up its copy of revision 12.  You'll need to tell it
        to do so manually by using (or with some additional tooling
        around) the <command>svnsync copy-revprops</command>
        subcommand, which simply rereplicates all the revision
        properties for a particular revision or range thereof.</para>
-->
      <para>In diesem Prozess ist jedoch eine kleine Unfeinheit. Da
        die Revisions-Propertys von Subversion jederzeit während der
        Lebenszeit eines Projektarchivs geändert werden können, ohne zu
        protokollieren, wann sie geändert wurden, müssen replizierende
        Prozesse ein besonderes Augenmerk auf sie richten. Wenn Sie
        bereits die ersten 15 Revisionen eines Projektarchivs gespiegelt
        haben, und dann jemand ein Revisions-Property von Revision 12
        ändert, weiß <command>svnsync</command> nicht, dass es
        zurückgehen und die Kopie der Revision 12 korrigieren muss.
        Sie müssen es ihm manuell mitteilen, indem Sie den Unterbefehl
        <command>svnsync copy-revprops</command> verwenden, der
        einfach alle Propertys einer bestimmten Revision oder eines
        Revisionsintervalls erneut repliziert.</para>

<!--
      <screen>
$ svnsync help copy-revprops
copy-revprops: usage: svnsync copy-revprops DEST_URL [REV[:REV2]]

Copy the revision properties in a given range of revisions to the
destination from the source with which it was initialized.
&hellip;
$ svnsync copy-revprops http://svn.example.com/svn-mirror 12
Copied properties for revision 12.
$
</screen>
-->
      <screen>
$ svnsync help copy-revprops
copy-revprops: Aufruf: svnsync copy-revprops ZIEL_URL [REV[:REV2]]

Kopiert die Revisionseigenschaften in einem gegebenen Revisionsbereich
von der Quelle, mit der es initialisiert wurde, auf das Ziel.
&hellip;
$ svnsync copy-revprops http://svn.example.com/svn-mirror 12
Eigenschaften für Revision 12 kopiert.
$
</screen>

<!--
      <para>That's repository replication in a nutshell.  You'll
        likely want some automation around such a process.  For
        example, while our example was a pull-and-push setup, you
        might wish to have your primary repository push changes to one
        or more blessed mirrors as part of its post-commit and
        post-revprop-change hook implementations.  This would enable
        the mirror to be up to date in as near to real time as is
        likely possible.</para>
-->
      <para>Das ist Projektarchiv-Replikation in aller Kürze.
        Sehrwahrscheinlich möchten Sie einen solchen Prozess etwas
        automatisieren. Während unser Beispiel ein
        Ziehen-und-Schieben-Szenario beschrieb, möchten Sie
        vielleicht, dass Ihr primäres Projektarchiv als Teil der
        post-commit- und post-revprop-change-Hooks Änderungen an einen
        oder mehrere ausgesuchte Spiegel weiterschiebt. Das würde es
        ermöglichen, dass der Spiegel beinahe in Echtzeit aktuell
        gehalten werden kann.</para>

<!--
      <para>Also, while it isn't very commonplace to do so,
        <command>svnsync</command> does gracefully mirror repositories
        in which the user as whom it authenticates has only partial
        read access.  It simply copies only the bits of the repository
        that it is permitted to see.  Obviously, such a mirror is not
        useful as a backup solution.</para>
-->
      <para>Es ist auch möglich, wenn auch nicht sehr verbreitet, dass
        <command>svnsync</command> Projektarchive spiegelt, in denen der
        Benutzer unter dessen Kennung es läuft, nur eingeschränkte
        Rechte besitzt. Es werden dann einfach nur die Teile des
        Projektarchivs kopiert, die der Benutzer sehen darf.
        Offensichtlich taugt so ein Spiegel nicht als
        Sicherheitskopie.</para>

<!--
      <para>In Subversion 1.5, <command>svnsync</command> grew the
        ability to also mirror a subset of a repository rather than
        the whole thing.  The process of setting up and maintaining
        such a mirror is exactly the same as when mirroring a whole
        repository, except that instead of specifying the source
        repository's root URL when running <command>svnsync
        init</command>, you specify the URL of some subdirectory
        within that repository.  Synchronization to that mirror will
        now copy only the bits that changed under that source
        repository subdirectory.  There are some limitations to this
        support, though.  First, you can't mirror multiple disjoint
        subdirectories of the source repository into a single mirror
        repository&mdash;you'd need to instead mirror some parent
        directory that is common to both.  Second, the filtering
        logic is entirely path-based, so if the subdirectory you are
        mirroring was renamed at some point in the past, your mirror
        would contain only the revisions since the directory appeared
        at the URL you specified.  And likewise, if the source
        subdirectory is renamed in the future, your synchronization
        processes will stop mirroring data at the point that the
        source URL you specified is no longer valid.</para>
-->
      <para>In Subversion 1.5 entwickelte <command>svnsync</command>
        auch die Fähigkeit, eine Teilmenge eines Projektarchivs statt des
        Ganzen zu spiegeln. Das Anlegen und Pflegen eines solchen
        Spiegels unterscheidet sich nicht vom Spiegeln eines
        kompletten Projektarchivs; anstatt den Wurzel-URL des
        Quell-Projektarchivs bei <command>svnsync init</command>
        anzugeben, nennen Sie einfach den URL eines
        Unterverzeichnisses dieses Projektarchivs. Hierbei gibt es
        allerdings einige Einschränkungen. Als Erstes können Sie nicht
        mehrere disjunkte Unterverzeichnisse des Quell-Projektarchivs in
        ein einzelnes Ziel-Projektarchiv spiegeln &ndash; stattdessen
        müssen Sie ein Eltern-Verzeichnis spiegeln, das allen
        gemeinsam ist. Zum Zweiten ist die Filterlogik vollständig
        pfadbasiert, so dass bei Verzeichnissen, die in der
        Vergangenheit einmal umbenannt wurden, Ihr Spiegel nur die
        Revisionen seit dem Zeitpunkt enthält an dem das Verzeichnis
        unter diesem URL zu finden war. Auch wenn das Unterverzeichnis
        künftig umbenannt wird, werden Revisionen nur bis zu dem
        Zeitpunkt gespiegelt, an dem der URL ungültig wird.</para>

<!--
      <para>As far as user interaction with repositories and mirrors
        goes, it <emphasis>is</emphasis> possible to have a single
        working copy that interacts with both, but you'll have to jump
        through some hoops to make it happen.  First, you need to
        ensure that both the primary and mirror repositories have the
        same repository UUID (which is not the case by default).  See
        <xref linkend="svn.reposadmin.maint.uuids" /> later in this
        chapter for more about this.</para>
-->
      <para>Was das Zusammenspiel von Benutzern mit Projektarchiven und
        Spiegeln betrifft, <emphasis>ist</emphasis> es möglich eine
        einzelne Arbeitskopie zu haben, die mit beiden kommuniziert,
        doch müssen Sie hierfür einige Verrenkungen machen. Zunächst
        müssen Sie sicherstellen, dass sowohl das primäre Projektarchiv
        als auch das Spiegel-Projektarchiv dieselbe Projektarchiv-UUID haben
        (was standardmäßig nicht der Fall ist). Mehr darüber unter
        <xref linkend="svn.reposadmin.maint.uuids" /> später in diesem
        Kapitel.</para>

<!--
      <para>Once the two repositories have the same UUID, you can use
        <command>svn switch</command> with the <option>- -relocate</option> option to point your working
        copy to whichever of the repositories you wish to operate
        against, a process that is described in <xref
        linkend="svn.ref.svn.c.switch" />.  There is a possible danger
        here, though, in that if the primary and mirror repositories
        aren't in close synchronization, a working copy up to date
        with, and pointing to, the primary repository will, if
        relocated to point to an out-of-date mirror, become confused
        about the apparent sudden loss of revisions it fully expects
        to be present, and it will throw errors to that effect.  If
        this occurs, you can relocate your working copy back to the
        primary repository and then either wait until the mirror
        repository is up to date, or backdate your working copy to a
        revision you know is present in the sync repository, and then
        retry the relocation.</para>
-->
      <para>Sobald beide Projektarchive dieselbe UUID haben, können Sie
        <command>svn switch</command> mit der Option
        <option>--relocate</option> benutzen, um das Projektarchiv
        auszuwählen, mit dem Sie arbeiten wollen; dieser Prozess ist
        in <xref linkend="svn.ref.svn.c.switch" /> beschrieben. Eine
        mögliche Gefahr besteht allerdings, wenn das Haupt- und das
        Spiegel-Projektarchiv nicht zeitnah synchronisiert sind. Eine
        Arbeitskopie, die auf das Haupt-Projektarchiv zeigt und gegenüber
        diesem aktuell ist, wird nach dem Umschalten auf den nicht
        aktuellen Spiegel durch den plötzlichen Verlust von
        Revisionen, die sie dort erwartet, verwirrt werden und deshalb
        Fehler ausgeben. Falls dies auftritt, können Sie entweder Ihre
        Arbeitskopie wieder zurück auf das Haupt-Projektarchiv schalten
        und warten bis das Spiegel-Projektarchiv aktuell ist oder Ihre
        Arbeitskopie auf eine Revision zurücksetzen, von der Sie
        wissen, dass sie im synchronisierten Projektarchiv vorhanden ist,
        und dann noch einmal das Umschalten versuchen. </para>

<!--
      <para>Finally, be aware that the revision-based replication
        provided by <command>svnsync</command> is only
        that&mdash;replication of revisions.  Only information carried
        by the Subversion repository dump file format is available for
        replication.  As such, <command>svnsync</command> has the same
        sorts of limitations that the repository dump stream has, and
        does not include such things as the hook implementations,
        repository or server configuration data, uncommitted
        transactions, or information about user locks on repository
        paths.</para>
-->
      <para>Zum Schluss sollte Ihnen bewusst sein, dass die von
        <command>svnsync</command> angebotene revisionsbasierte
        Replikation genau das ist &ndash; die Replikation von
        Revisionen. Nur die durch das Format der
        Subversion-Auszugsdateien übertragene Information ist
        replizierbar. Somit hat <command>svnsync</command> dieselben
        Einschränkungen wie der Auszugsstrom und beinhaltet nicht
        Dinge wie Hook-Implementierungen, Projektarchiv- oder
        Server-Konfigurationen, unvollständige Transaktionen oder
        Benutzersperren auf Projektarchiv-Pfaden.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.backup">
<!--
      <title>Repository Backup</title>
-->
      <title>Sicherung des Projektarchivs</title>

<!--
      <para>Despite numerous advances in technology since the birth of
        the modern computer, one thing unfortunately rings true with
        crystalline clarity&mdash;sometimes things go very, very
        awry.  Power outages, network connectivity dropouts, corrupt
        RAM, and crashed hard drives are but a taste of the evil that
        Fate is poised to unleash on even the most conscientious
        administrator.  And so we arrive at a very important
        topic&mdash;how to make backup copies of your repository
        data.</para>
-->
      <para>Trotz zahlreicher technischer Fortschritte seit der Geburt
        des modernen Computers bleibt eine Sache unglücklicherweise
        wahr: manchmal geht etwas richtig schief. Eine kleine Auswahl
        von schlimmen Dingen, die das Schicksal auch auf den
        gewissenhaftesten Administrator loslassen kann, sind
        Stromausfälle, Netzzusammenbrüche, defekter Speicher und
        Festplattenabstürze. So kommen wir zu einem sehr wichtigen
        Thema: Wie mache ich Sicherheitskopien von den Daten meines
        Projektarchivs?</para>

<!--
      <para>There are two types of backup methods available for
        Subversion repository administrators&mdash;full and
        incremental.  A full backup of the repository involves
        squirreling away in one sweeping action all the information
        required to fully reconstruct that repository in the event of
        a catastrophe.  Usually, it means, quite literally, the
        duplication of the entire repository directory (which includes
        either a Berkeley DB or FSFS environment).  Incremental
        backups are lesser things:  backups of only the portion of the
        repository data that has changed since the previous
        backup.</para>
-->
      <para>Dem Administrator stehen zwei Arten von Sicherungsmethoden
        zur Verfügung: vollständig und inkrementell. Eine vollständige
        Sicherungskopie des Projektarchivs beinhaltet eine umfassende
        Speicherung aller Informationen, die für die Wiederherstellung
        des Projektarchivs im Katastrophenfall benötigt werden. Dies
        bedeutet gewöhnlich eine Kopie des gesamten
        Projektarchiv-Verzeichnisses (inklusive der Berkeley-DB- oder
        FSFS-Umgebung). Inkrementelle Sicherungen haben einen
        geringeren Umfang: nur die Teile des Projektarchivs, die sich
        seit der letzten Sicherung geändert haben.</para>

<!--
      <para>As far as full backups go, the naïve approach might seem
        like a sane one, but unless you temporarily disable all other
        access to your repository, simply doing a recursive directory
        copy runs the risk of generating a faulty backup.  In the case
        of Berkeley DB, the documentation describes a certain order in
        which database files can be copied that will guarantee a valid
        backup copy.  A similar ordering exists for FSFS data.  But
        you don't have to implement these algorithms yourself, because
        the Subversion development team has already done so.  The
        <command>svnadmin hotcopy</command> command takes care of the
        minutia involved in making a hot backup of your repository.
        And its invocation is as trivial as the Unix
        <command>cp</command> or Windows <command>copy</command>
        operations:</para>
-->
      <para>Was eine vollständige Sicherung betrifft, scheint der
        naive Ansatz vernünftig zu sein; jedoch besteht beim einfachen
        rekursiven Kopieren des Verzeichnisses das Risiko, eine
        fehlerhafte Sicherung zu erstellen, sofern nicht alle anderen
        Zugriffe auf das Projektarchiv verhindert werden. Für Berkeley DB
        beschreibt die Dokumentation eine bestimmte Reihenfolge, in
        der die Datenbankdateien kopiert werden können, um eine
        gültige Sicherungskopie zu gewährleisten. Eine ähnliche
        Reihenfolge gibt es für FSFS-Daten. Allerdings brauchen Sie
        diese Algorithmen nicht selbst zu implementieren, da das
        Subversion-Entwicklerteam das bereits getan hat. Der Befehl
        <command>svnadmin hotcopy</command> kümmert sich um die
        Details, die für eine Sicherungskopie während des Betriebes
        erforderlich sind. Der Aufruf ist so trivial wie die Bedienung
        von Unix' <command>cp</command> oder Windows'
        <command>copy</command>:</para>

      <screen>
$ svnadmin hotcopy /var/svn/repos /var/svn/repos-backup
</screen>

<!--
      <para>The resultant backup is a fully functional Subversion
        repository, able to be dropped in as a replacement for your
        live repository should something go horribly wrong.</para>
-->
      <para>Das Ergebnis der Sicherung ist ein vollständig
        funktionsfähiges Subversion-Projektarchiv, das jederzeit die
        Aufgaben Ihres Projektarchivs übernehmen kann, falls irgendetwas
        Schlimmes passieren sollte.</para>

<!--
      <para>When making copies of a Berkeley DB repository, you can
        even instruct <command>svnadmin hotcopy</command> to purge any
        unused Berkeley DB logfiles (see <xref
        linkend="svn.reposadmin.maint.diskspace.bdblogs" />) from the
        original repository upon completion of the copy.  Simply
        provide the <option>- -clean-logs</option> option on the
        command line.</para>
-->
      <para>Bei der Erstellung von Kopien eines
        Berkeley-DB-Projektarchivs können Sie <command>svnadmin
        hotcopy</command> sogar mitteilen, nach Abschluss der Kopie
        unbenötigte Berkeley-DB-Protokolldateien (siehe <xref
        linkend="svn.reposadmin.maint.diskspace.bdblogs" />) aus dem
        Original-Projektarchiv  zu löschen. Geben Sie einfach die Option
        <option>--clean-logs</option> auf der Kommandozeile an.</para>

      <screen>
$ svnadmin hotcopy --clean-logs /var/svn/bdb-repos /var/svn/bdb-repos-backup
</screen>

<!--
      <para>Additional tooling around this command is available, too.
        The <filename>tools/backup/</filename> directory of the
        Subversion source distribution holds the
        <command>hot-backup.py</command> script.  This script adds a
        bit of backup management atop <command>svnadmin
        hotcopy</command>, allowing you to keep only the most recent
        configured number of backups of each repository.  It will
        automatically manage the names of the backed-up repository
        directories to avoid collisions with previous backups and
        will <quote>rotate off</quote> older backups, deleting them so
        that only the most recent ones remain.  Even if you also have an
        incremental backup, you might want to run this program on a
        regular basis.  For example, you might consider using
        <command>hot-backup.py</command> from a program scheduler
        (such as <command>cron</command> on Unix systems), which can
        cause it to run nightly (or at whatever granularity of time
        you deem safe).</para>
-->
      <para>Ein zusätzliches Werkzeug für diesen Befehl steht auch zur
        Verfügung. Im Verzeichnis <filename>tools/backup/</filename>
        des Subversion-Quelltextpaketes liegt das Script
        <command>hot-backup.py</command>. Dieses Script ergänzt
        <command>svnadmin hotcopy</command> um ein wenig
        Sicherungsverwaltung, indem es Ihnen erlaubt, lediglich eine
        konfigurierbare Anzahl der letzten Sicherungskopien jedes
        Projektarchivs zu behalten. Es verwaltet automatisch die Namen
        der gesicherten Projektarchiv-Verzeichnisse, um Kollisionen mit
        vorherigen Sicherungen zu vermeiden und löscht ältere
        Sicherungen, so dass nur die jüngsten übrig bleiben. Selbst
        wenn Sie ebenfalls eine inkrementelle Sicherung haben, sollten
        Sie dieses Programm regelmäßig aufrufen. Sie könnten
        beispielsweise <command>hot-backup.py</command> mit einem
        Programmstarter (so wie <command>cron</command> auf Unix
        Systemen) verwenden, der es jede Nacht (oder in einem
        Zeitintervall, das Ihnen sicher erscheint) aufruft.</para>

<!--
      <para>Some administrators use a different backup mechanism built
        around generating and storing repository dump data.  We
        described in <xref linkend="svn.reposadmin.maint.migrate" />
        how to use <command>svnadmin dump</command> with the <option>- -incremental</option> option to
        perform an incremental backup of a given revision or range of
        revisions.  And of course, you can achieve a full backup variation of
        this by omitting the <option>- -incremental</option>
        option to that command.  There is some value in these methods,
        in that the format of your backed-up information is
        flexible&mdash;it's not tied to a particular platform,
        versioned filesystem type, or release of Subversion or
        Berkeley DB.  But that flexibility comes at a cost, namely
        that restoring that data can take a long time&mdash;longer
        with each new revision committed to your repository.  Also, as
        is the case with so many of the various backup methods,
        revision property changes that are made to already backed-up
        revisions won't get picked up by a nonoverlapping,
        incremental dump generation.  For these reasons, we recommend
        against relying solely on dump-based backup approaches.</para>
-->
      <para>Einige Administratoren verwenden einen unterschiedlichen
        Sicherungsmechanismus, der auf der Erzeugung und Speicherung
        von Projektarchiv-Auszugs-Daten basiert. In <xref
        linkend="svn.reposadmin.maint.migrate" /> haben wir
        beschrieben, wie <command>svnadmin dump</command> mit der
        Option <option>--incremental</option> verwendet werden kann,
        um eine inkrementelle Sicherung einer Revision oder eines
        Bereichs von Revisionen zu erstellen. Natürlich können Sie
        davon eine vollständige Sicherung bekommen, wenn Sie die
        Option <option>--incremental</option> weglassen. Der Vorteil
        dieser Methode besteht darin, dass das Format der gesicherten
        Information flexibel ist &ndash; es erfordert keine bestimmte
        Plattform, keinen bestimmten Typ eines versionierten
        Dateisystems, keine bestimmte Version von Subversion oder
        Berkeley DB. Diese Flexibilität kommt allerdings zu dem Preis,
        dass die Wiederherstellung der Daten sehr lange dauern kann
        &ndash; länger mit jeder neuen Revision, die ins Projektarchiv
        übergeben wird. Wie bei vielen verschiedenen
        Sicherungsmethoden werden auch hier Änderungen an
        Revisions-Propertys bereits gesicherter Revisionen nicht
        berücksichtigt, sofern es sich um eine nicht-überlappende
        inkrementelle Sicherung handelt. Wir raten aus diesen Gründen
        davon ab, sich ausschließlich auf Sicherungsstrategien zu
        verlassen, die alleine auf Auszügen basieren.</para>

<!--
      <para>As you can see, each of the various backup types and
        methods has its advantages and disadvantages.  The easiest is
        by far the full hot backup, which will always result in a
        perfect working replica of your repository.  Should something
        bad happen to your live repository, you can restore from the
        backup with a simple recursive directory copy.  Unfortunately,
        if you are maintaining multiple backups of your repository,
        these full copies will each eat up just as much disk space as
        your live repository.  Incremental backups, by contrast, tend
        to be quicker to generate and smaller to store.  But the
        restoration process can be a pain, often involving applying
        multiple incremental backups.  And other methods have their
        own peculiarities.  Administrators need to find the balance
        between the cost of making the backup and the cost of
        restoring it.</para>
-->
      <para>Wie Sie sehen können, hat jeder der verschiedenen
        Sicherungstypen seine Vor- und Nachteile. Bei weitem am
        einfachsten ist die vollständige Sicherungskopie im laufenden
        Betrieb, die stets ein perfektes, einsatzfähiges Abbild Ihres
        Projektarchivs erzeugt. Falls Ihrem Projektarchiv irgendetwas
        Schlimmes widerfahren sollte, können Sie es durch eine
        einfache rekursive Verzeichniskopie aus der Sicherung
        wiederherstellen. Falls Sie mehrere Sicherungen Ihres
        Projektarchivs vorhalten, benötigt leider jede dieser
        vollständigen Kopien genauso viel Plattenplatz wie das
        Original. Im Gegensatz dazu lassen sich inkrementelle
        Sicherungen schneller erzeugen und platzsparender sichern.
        Allerdings kann die Wiederherstellung eine Plage sein, da oft
        mehrere inkrementelle Sicherungen eingespielt werden müssen.
        Andere Methoden wiederum haben auch ihre Besonderheiten.
        Administratoren müssen das Gleichgewicht zwischen den Kosten
        der Sicherung und den Kosten der Wiederherstellung
        finden.</para>

<!--
      <para>The <command>svnsync</command> program (see <xref
        linkend="svn.reposadmin.maint.replication" />) actually
        provides a rather handy middle-ground approach.  If you are
        regularly synchronizing a read-only mirror with your main
        repository, in a pinch your read-only mirror is probably
        a good candidate for replacing that main repository if it
        falls over.  The primary disadvantage of this method is that
        only the versioned repository data gets
        synchronized&mdash;repository configuration files,
        user-specified repository path locks, and other items that
        might live in the physical repository directory but not
        <emphasis>inside</emphasis> the repository's virtual versioned
        filesystem are not handled by <command>svnsync</command>.</para>
-->
      <para>Das Programm <command>svnsync</command> (siehe <xref
        linkend="svn.reposadmin.maint.replication" />) bietet
        tatsächlich einen handlichen Ansatz dazwischen. Falls Sie
        regelmäßig einen nur lesbaren Spiegel mit Ihrem
        Haupt-Projektarchiv synchronisieren, stellt der Spiegel einen
        ausgezeichneten Kandidaten dar, um für Ihr Haupt-Projektarchiv
        einzuspringen, falls es mal umkippt. Der Hauptnachteil dieses
        Ansatzes besteht darin, dass nur versionierte Projektarchiv-Daten
        synchronisiert werden &ndash;
        Projektarchiv-Konfigurationsdateien, benutzerdefinierte Sperren
        auf Projektarchiv-Pfaden und andere Dinge, die sich zwar im
        physikalischen Projektarchiv-Verzeichnis befinden können, jedoch
        nicht <emphasis>innerhalb</emphasis> des virtuellen
        versionierten Dateisystems des Projektarchivs, werden durch
        <command>svnsync</command> nicht berücksichtigt.</para>

<!--
      <para>In any backup scenario, repository administrators need
        to be aware of how modifications to unversioned revision
        properties affect their backups.  Since these changes do not
        themselves generate new revisions, they will not trigger
        post-commit hooks, and may not even trigger the
        pre-revprop-change and post-revprop-change hooks.
        <footnote>
          <para><command>svnadmin setlog</command> can be called in a
            way that bypasses the hook interface altogether.</para>
        </footnote>  
        And since you can change revision properties without respect
        to chronological order&mdash;you can change any revision's
        properties at any time&mdash;an incremental backup of the
        latest few revisions might not catch a property modification
        to a revision that was included as part of a previous 
        backup.</para>
-->
      <para>In jedem Sicherungsszenario müssen sich
        Projektarchiv-Administratoren bewusst sein, inwiefern Änderungen
        an unversionierten Revisions-Propertys Auswirkungen auf die
        Sicherungen haben. Da diese Änderungen allein keine Revisionen
        erzeugen, werden auch keine post-commit-Hooks ausgelöst; es
        kann sogar sein, dass die Hooks pre-revprop-change und
        post-revprop-change nicht ausgelöst werden.
        <footnote>
          <para><command>svnadmin setlog</command> kann auf eine Art
            aufgerufen werden, dass die Hook-Schnittstelle völlig
            umgangen wird.</para>
        </footnote>  
        Und da Sie Revisions-Propertys ohne Rücksicht auf die
        zeitliche Abfolge ändern können &ndash; Sie können jederzeit
        die Propertys jeder Revision ändern &ndash; könnte eine
        inkrementelle Sicherung der letzten paar Revisionen eine
        Änderung an einer Revision aus einer vorangegangenen Sicherung
        übersehen.</para>

<!--
      <para>Generally speaking, only the truly paranoid would need to
        back up their entire repository, say, every time a commit
        occurred.  However, assuming that a given repository has some
        other redundancy mechanism in place with relatively fine
        granularity (such as per-commit emails or incremental dumps), a
        hot backup of the database might be something that a
        repository administrator would want to include as part of a
        system-wide nightly backup.  It's your data&mdash;protect it
        as much as you'd like.</para>
-->
      <para>Im Allgemeinen braucht nur ein echter Paranoiker nach
        jeder Übergabe eine vollständige Sicherung des Projektarchivs.
        Eine vollständige Sicherheitskopie des Projektarchivs im
        laufenden Betrieb im Rahmen einer systemweiten, nächtlichen
        Sicherung sollte ein Projektarchiv-Administrator jedoch erwägen,
        unter der Voraussetzung, dass das Projektarchiv bereits
        irgendeinen Redundanzmechanismus mit der nötigen Granularität
        verwendet (etwa Übergabe-E-Mails oder inkrementelle Auszüge).
        Es sind Ihre Daten &ndash; schützen Sie sie, wie es Ihnen
        passt.</para>

<!--
      <para>Often, the best approach to repository backups is a
        diversified one that leverages combinations of the methods
        described here.  The Subversion developers, for example, back
        up the Subversion source code repository nightly using
        <command>hot-backup.py</command> and an off-site
        <command>rsync</command> of those full backups; keep multiple
        archives of all the commit and property change notification
        emails; and have repository mirrors maintained by various
        volunteers using <command>svnsync</command>.  Your solution
        might be similar, but should be catered to your needs and that
        delicate balance of convenience with paranoia.  And whatever
        you do, validate your backups from time to time&mdash;what
        good is a spare tire that has a hole in it?  While all of this
        might not save your hardware from the iron fist of Fate,
        <footnote>
          <para>You know&mdash;the collective term for all of her
            <quote>fickle fingers.</quote></para>
        </footnote>
        it should certainly help you recover from those trying 
        times.</para>
-->
      <para>Oftmals ist der beste Ansatz für die Projektarchiv-Sicherung
        ein diversifizierter, der die Stärken von Kombinationen der
        hier beschriebenen Methoden ausspielt. Die
        Subversion-Entwickler beispielsweise sichern jede Nacht das
        Subversion-Quelltext-Projektarchiv mit
        <command>hot-backup.py</command> und einem
        <command>rsync</command> dieser vollständigen Sicherungen von
        einem entfernten Standort aus; sie halten mehrere Archive
        aller Übergabe- und Property-Änderungs-E-Mails vor und sie
        haben Spiegel des Projektarchivs, die von Freiwilligen mit
        <command>svnsync</command> verwaltet werden. Ihre Lösung
        könnte ähnlich aussehen, sollte aber Ihren Bedürfnissen
        entsprechen und das empfindliche Gleichgewicht zwischen
        Bequemlichkeit und Paranoia aufrechterhalten. Egal, was Sie
        machen: überprüfen Sie Ihre Sicherungen ab und an &ndash; was
        nutzt ein Reservereifen mit einem Loch? Obwohl all das Ihr
        Material nicht vor der eisernen Faust des Schicksals zu retten
        vermag, sollte es Ihnen sicherlich helfen, sich aus diesen
        schwierigen Zeiten zu erholen.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.uuids">
<!--
      <title>Managing Repository UUIDs</title>
-->
      <title>Verwaltung von Projektarchiv UUIDs</title>

<!--
      <para>Subversion repositories have a universally unique
        identifier (UUID) associated with them.  This is used by
        Subversion clients to verify the identity of a repository when
        other forms of verification aren't good enough (such as
        checking the repository URL, which can change over time).
        Most Subversion repository administrators rarely, if ever,
        need to think about repository UUIDs as anything more than a
        trivial implementation detail of Subversion.  Sometimes,
        however, there is cause for attention to this detail.</para>
-->
      <para>Subversion-Projektarchive haben eine mit ihnen verknüpfte,
        universelle, eindeutige Identifizierung (universally unique
        identifier, UUID). Dieser UUID wird von Subversion-Clients
        verwendet, um die Identität eines Projektarchivs zu verifizieren,
        falls andere Methoden nicht ausreichend sind (wie die
        Überprüfung des Projektarchiv-URLs, der sich im Lauf der Zeit
        ändern kann). Selten, wenn überhaupt, müssen sich
        Subversion-Projektarchiv-Administratoren weitergehende
        Gedanken über Projektarchiv UUIDs machen, anstatt sie als
        triviales Implementierungsdetail von Subversion zu betrachten.
        Manchmal jedoch gibt es einen Grund, der Aufmerksamkeit für
        dieses Detail verlangt.</para>

<!--
      <para>As a general rule, you want the UUIDs of your live
        repositories to be unique.  That is, after all, the point of
        having UUIDs.  But there are times when you want the
        repository UUIDs of two repositories to be exactly the same.
        For example, if you make a copy of a repository for backup
        purposes, you want the backup to be a perfect replica of the
        original so that, in the event that you have to restore that
        backup and replace the live repository, users don't suddenly
        see what looks like a different repository.  When dumping and
        loading repository history (as described earlier in <xref
        linkend="svn.reposadmin.maint.migrate" />), you get to decide
        whether to apply the UUID encapsulated in the data dump
        stream to the repository in which you are loading the data.  The
        particular circumstance will dictate the correct
        behavior.</para>
-->
      <para>Im Allgemeinen möchten Sie, dass die UUIDs Ihrer aktiven
        Projektarchive eindeutig sind. Das ist schließlich der Sinn von
        UUIDs. Jedoch gibt es Gelegenheiten, bei denen Sie möchten,
        dass die UUIDs zweier Projektarchive identisch sind. Wenn Sie
        beispielsweise zu Sicherungszwecken eine Kopie eines
        Projektarchivs machen, möchten Sie, dass die Sicherungskopie ein
        perfektes Abbild des Originals ist, so dass die Benutzer nach
        einer Wiederherstellung des Projektarchivs aus der
        Sicherheitskopie nicht das Gefühl haben, es mit einem
        unterschiedlichen Projektarchiv zu tun zu haben. Beim Erstellen
        bzw. beim Laden eines Auszugs der Projektarchiv-Historie (wie
        oben in <xref linkend="svn.reposadmin.maint.migrate" />
        beschrieben) können Sie entscheiden, ob der im Auszugsstrom
        befindliche UUID auf das Projektarchiv angewendet werden soll, in
        das Sie die Daten laden. Die besonderen Umstände diktieren
        hier das richtige Verhalten.</para>

<!--
      <para>There are a couple of ways to set (or reset) a
        repository's UUID, should you need to.  As of Subversion 1.5,
        this is as simple as using the <command>svnadmin
        setuuid</command> command.  If you provide this subcommand
        with an explicit UUID, it will validate that the UUID is
        well-formed and then set the repository UUID to that value.
        If you omit the UUID, a brand-new UUID will be generated for
        your repository.</para>
-->
      <para>Eine Projektarchiv-UUID kann auf verschiedene Art und Weise
        gesetzt (oder zurückgesetzt) werden, falls sie es müssen.
        Seit Subversion 1.5 wird einfach der Befehl <command>svnadmin
        setuuid</command> verwendet. Wenn Sie diesem Befehl einen
        ausdrücklichen UUID mitgeben, wird die Wohlgeformtheit des
        UUID überprüft und der UUID des Projektarchivs auf diesen Wert
        gesetzt. Wenn Sie den UUID weglassen, wird ein nagelneuer UUID
        für Ihr Projektarchiv erzeugt.</para>

<!--
      <screen>
$ svnlook uuid /var/svn/repos
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$ svnadmin setuuid /var/svn/repos   # generate a new UUID
$ svnlook uuid /var/svn/repos
3c3c38fe-acc0-11dc-acbc-1b37ff1c8e7c
$ svnadmin setuuid /var/svn/repos \
           cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec  # restore the old UUID
$ svnlook uuid /var/svn/repos
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$
</screen>
-->
      <screen>
$ svnlook uuid /var/svn/repos
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$ svnadmin setuuid /var/svn/repos   # neuen UUID erzeugen
$ svnlook uuid /var/svn/repos
3c3c38fe-acc0-11dc-acbc-1b37ff1c8e7c
$ svnadmin setuuid /var/svn/repos \
           cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec  # alten UUID wiederherstellen
$ svnlook uuid /var/svn/repos
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$
</screen>

<!--
      <para>For folks using versions of Subversion earlier than 1.5,
        these tasks are a little more complicated.  You can explicitly
        set a repository's UUID by piping a repository dump file stub
        that carries the new UUID specification through
        <userinput>svnadmin load - -force-uuid <replaceable>REPOS-PATH</replaceable></userinput>.</para>
-->
      <para>Für Benutzer älterer Versionen als Subversion 1.5 sieht
        die Sache etwas komplizierter aus. Sie können den UUID eines
        Projektarchivs ausdrücklich setzen, indem Sie einen
        Projektarchiv-Auszugs-Fragment mit dem neuen UUID durch den
        Befehl <userinput>svnadmin load --force-uuid
        <replaceable>REPOS-PATH</replaceable></userinput>
        leiten.</para>

      <screen>
$ svnadmin load --force-uuid /var/svn/repos &lt;&lt;EOF
SVN-fs-dump-format-version: 2

UUID: cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
EOF
$ svnlook uuid /var/svn/repos
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$
</screen>

      <para>Die Erzeugung eines nagelneuen UUID mit älteren Versionen
        von Subversion gestaltet sich jedoch nicht so einfach. Am
        besten finden Sie eine andere Möglichkeit zum Erzeugen des
        UUIDs und setzen anschließend den Projektarchiv-UUID auf diesen
        Wert.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.maint.moving-and-removing">
<!--
    <title>Moving and Removing Repositories</title>
-->
    <title>Verschieben und Entfernen von Projektarchiven</title>

<!--
    <para>Subversion repository data is wholly contained within the
      repository directory.  As such, you can move a Subversion
      repository to some other location on disk, rename a repository,
      copy a repository, or delete a repository altogether using the
      tools provided by your operating system for manipulating
      directories&mdash;<command>mv</command>, <command>cp
      -a</command>, and <command>rm -r</command> on Unix platforms;
      <command>copy</command>, <command>move</command>, and
      <command>rmdir /s /q</command> on Windows; vast numbers of mouse
      and menu gyrations in various graphical file explorer
      applications, and so on.</para>
-->
    <para>Sämtliche Daten eines Subversion-Projektarchivs befinden sich
      innerhalb des Projektarchiv-Verzeichnisses. Als solches können Sie
      ein Subversion-Projektarchiv an einen anderen Ort auf der Platte
      verschieben, ein Projektarchiv umbenennen, kopieren oder
      vollständig löschen, indem Sie die Werkzeuge Ihres
      Betriebssystems zum Manipulieren von Verzeichnissen verwenden
      &ndash; <command>mv</command>, <command>cp
      -a</command> und <command>rm -r</command> auf Unix-Plattformen;
      <command>copy</command>, <command>move</command> und
      <command>rmdir /s /q</command> unter Windows; eine riesige
      Anzahl an Maus- und Menüoperationen in verschiedenen graphischen
      Dateiverwaltungs-Anwendungen, usw.</para>

<!--
    <para>Of course, there's often still more to be done when trying
      to cleanly affect changes such as this.  For example, you might
      need to update your Subversion server configuration to point to
      the new location of a relocated repository or to remove
      configuration bits for a now-deleted repository.  If you have
      automated processes that publish information from or about your
      repositories, they may need to be updated.  Hook scripts might
      need to be reconfigured.  Users may need to be notified.  The list
      can go on indefinitely, or at least to the extent that you've
      built processes and procedures around your Subversion
      repository.</para>
-->
    <para>Natürlich gehört bei derartigen Änderungen mehr dazu, wenn
      deren Auswirkungen sauber behandelt werden sollen.
      Beispielsweise sollten Sie ihre Server-Konfiguration
      aktualisieren, so dass sie auf den neuen Ort des verschobenen
      Projektarchivs zeigt oder die Konfigurationseiträge für ein nun
      gelöschtes Projektarchiv entfernen. Sollten Sie automatisierte
      Prozesse haben, die Informationen aus Ihrem oder über Ihr
      Projektarchiv veröffentlichen, sollten auch sie gegebenenfalls
      aktualisiert werden. Auch Hook-Scripte könnten eventuell eine
      Neukonfigurierung benötigen. Benutzer müssten vielleicht
      benachrichtigt werden. Die Liste könnte beliebig verlängert
      werden oder zumindest bis zu dem Punkt, dass Ihre um das
      Subversion-Projektarchiv gebauten Prozesse und Prozeduren
      berücksichtigt werden.</para>

<!--
    <para>In the case of a copied repository, you should also consider
      the fact that Subversion uses repository UUIDs to distinguish
      repositories.  If you copy a Subversion repository using a
      typical shell recursive copy command, you'll wind up with two
      repositories that are identical in every way&mdash;including their UUIDs.
      In some circumstances, this might be desirable.  But in the
      instances where it is not, you'll need to generate a new UUID
      for one of these identical repositories.  See <xref
      linkend="svn.reposadmin.maint.uuids" /> for more about managing
      repository UUIDs.</para>
-->
    <para>Im Fall eines kopierten Projektarchivs sollten Sie auch die
      Tatsache berücksichtigen, dass Subversion Projektarchiv-UUIDs zur
      Unterscheidung von Projektarchivs benutzt. Wenn Sie ein
      Subversion-Projektarchiv mit einem typischen rekursiven
      Kommandozeilen-Kopierprogramm kopieren, haben Sie nachher zwei
      völlig identische Projektarchive &ndash; einschließlich ihrer
      UUIDs. Manchmal mag das erwünscht sein; anderenfalls müssen Sie
      für eins dieser identischen Projektarchivs einen neuen UUID
      erzeugen. Für weitere Informationen über Projektarchiv-UUIDs, siehe
      <xref linkend="svn.reposadmin.maint.uuids" />.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.summary">
<!--
    <title>Summary</title>
-->
    <title>Zusammenfassung</title>

<!--
    <para>By now you should have a basic understanding of how to
      create, configure, and maintain Subversion repositories.  We
      introduced you to the various tools that will assist you with
      this task.  Throughout the chapter, we noted common
      administration pitfalls and offered suggestions for avoiding
      them.</para>
-->
    <para>Sie sollten bis jetzt ein grundlegendes Verständnis darüber
      haben, wie Subversion-Projektarchive angelegt, konfiguriert und
      gewartet werden. Wir haben Ihnen die verschiedenen Werkzeuge
      vorgestellt, die Ihnen bei diesen Aufgaben helfen. Im Verlauf
      dieses Kapitels haben wir auf verbreitete Fallstricke bei der
      Verwaltung hingewiesen und Vorschläge zu deren Vermeidung
      gegeben.</para>

<!--
    <para>All that remains is for you to decide what exciting data to
      store in your repository, and finally, how to make it available
      over a network.  The next chapter is all about networking.</para>
-->
    <para>Was jetzt noch bleibt ist, dass Sie entscheiden müssen,
      welche aufregenden Daten Sie in Ihrem Projektarchiv unterbringen
      und wie sie schließlich über das Netz verfügbar gemacht werden
      sollen. Das nächste Kapitel ist ganz dem Netz gewidmet.</para>

  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
