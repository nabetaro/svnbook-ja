<chapter id="svn-ch-7">
  <title>高级主题</title>

  <simplesect>

    <para>如果你是从头到尾按章节阅读本书，你一定已经具备了使用Subversion客户端执行大多数不同的版本控制操作足够的知识，你理解了怎样从Subversion版本库取出一个工作拷贝，你已经熟悉了通过<command>svn commit</command>和<command>svn update</command>来提交和接收修改，你一定也养成了使用<command>svn status</command>在的无意识的条件反射，为了所有的目的和意图，你已经准备好了在普通环境中使用Subversion。</para>

    <para>但是Subversion的特性集不只是<quote>普通的版本控制操作</quote>。</para>

    <para>本章重点介绍一些Subversion不常用的特性，在这里，我们会讨论Subversion的属性（或者说<quote>元数据</quote>）支持，和怎样通过更改它的运行中配置区域来修改Subversion的缺省行为方式，我们会描述怎样使用外部定义来指导Subversion从多个版本库得到数据，我们会覆盖一些Subversion分发版本附加的客户端和服务器端的工具的细节。</para>

    <para>在阅读本章之前，你一定要熟悉Subversion对文件和目录的基本版本操作能力，如果你已经阅读了哪些，或者是你需要一个复习，我们建议你检查<xref
      linkend="svn-ch-2" />和<xref linkend="svn-ch-3" />，一旦你已经掌握了基础知识和本章，你会是一个Subversion的超级用户！
    </para>

  </simplesect>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 1:  RUNTIME CONFIGURATION AREA                      *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-7-sect-1">
    <title>运行中配置区域</title>
    
    <para>Subversion提供了许多用户可以控制的可选行为方式，许多是那种用户希望添加到所有的Subversion操作中的选项，所以胜于强制用户记住命令行参数并且使用这些选项，并且在每个命令中使用，Subversion使用配置文件各离岛Subversion的配置区域。</para>

    <para>Subversion<firstterm>配置区域</firstterm>是一个双重层次选项名称和他们的值。通常，这归结为一个保存<firstterm>配置文件</firstterm>的特殊目录（第一层），知识一些标准的INI格式（包含<quote>部分</quote>支持第二层）的文本文件。这些文件可以简单用你喜欢的文本编辑器编辑（如Emacs或vi），而且保存了客户端可以读取的指示，用来指导用户的一些行为选项。</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-7-sect-1.1">
      <title>配置区域布局</title>

      <para><command>svn</command>命令行客户端第一次执行时，它会创建一个每用户的配置区域，在类Unix系统，这个区域在用户主目录，是一个名字为<filename>.subversion</filename>的目录。在Win32系统，Subversion在创建了一个<filename>Subversion</filename>目录，通常是在用户的profile目录（顺便说一句，通常是一个隐藏目录）的<filename>Application Data</filename>区域。然而，在这个平台上具体的位置在各个系统是不一样的，是Windows注册表决定的。
        <footnote>
          <para><literal>APPDATA</literal>环境变量指向<filename>Application Data</filename>区域，所以你可以一直通过<filename>%APPDATA%\Subversion</filename>引用这个目录。
          </para>
        </footnote>
        我们会通过它的Unix名字<filename>.subversion</filename>来饮用每用户配置区域。
      </para>

      <para>除了每用户的配置区域，Subversion也会识别系统级的配置区域，这给了系统管理员有能力来建立缺省值给所有的给定机器的用户，注意那个系统级的配置区域不会规定不变的策略&mdash;每用户的配置区域会覆盖系统级的配置，<command>svn</command>命令行的参数决定最后的行为。在类Unix的平台，系统级的配置区域会在<filename>/etc/subversion</filename>目录，在Windows的机器，它会寻找<filename>Application Data</filename>（再说一次，是由Windows注册表决定）的<filename>Subversion</filename>目录。不像每用户的情况，<command>svn</command>不会试图创建系统级的配置区域。</para>

      <para>配置区域现在保存三个文件&mdash;两个配置文件（<filename>config</filename>和<filename>servers</filename>），和一个描述INI格式的<filename>README.txt</filename>文件。他们创建的时候，文件保存缺省的Subversion选项，大多数已经加了注释，并且用文字描述分组，记述了这些值对Subversion的关键影响，为了修改期望的选项值，如果在任何时候你希望恢复缺省的配置，可以直接删除（或者重命名）你的配置目录，并且运行一些无影响的<command>svn</command>命令，如<command>svn --version</command>，一个包含缺省值的新配置目录就会创建起来。</para>

      <para>每用户配置区域也保存了认证数据的一个缓存，<filename>auth</filename>目录保存了一些子目录中缓存了一些Subversion各种支持的认证方法的信息，这个目录创建为只可以被它的用户读取内容。</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-7-sect-1.2">
      <title>配置和Windows注册表</title>

      <para>作为INI为基础的配置趋于的补充，运行在Windows平台Subversion客户端也可以使用Windows猪膘来保存配置数据，选项名称和它们的值与INI文件的一样，<quote>file/section</quote>层级也已经保存，尽管使用不同的样式&mdash;在这种模式里，文件和小节也是注册表树的层级。</para>

      <para>Subversion查找系统级的配置值得位置是键<literal>HKEY_LOCAL_MACHINE\Software\Tigris.org\Subversion</literal>，举个例子，<literal>global-ignores</literal>选项是在<filename>config</filename>文件的<literal>miscellany</literal>小节，会在<literal>HKEY_LOCAL_MACHINE\Software\Tigris.org\Subversion\Config\Miscellany\global-ignores</literal>看到，每用户的配置值是存放在<literal>HKEY_CURRENT_USER\Software\Tigris.org\Subversion</literal>下。
      </para>

      <para>注册表为基础的配置选项在它的文件为基础的对应部分<emphasis>之前</emphasis>被解析，所以会被配置文件中的值覆盖，换句话说，在Windows系统下配置级别是下面的次序：</para>
      
      <orderedlist>
        <listitem>
          <para>命令行选项</para>
        </listitem>
        <listitem>
          <para>每用户INI文件</para>
        </listitem>
        <listitem>
          <para>每用户注册表值</para>
        </listitem>
        <listitem>
          <para>系统级INI文件</para>
        </listitem>
        <listitem>
          <para>系统级注册表值</para>
        </listitem>
      </orderedlist>

      <para>所以，Windows注册表不会真的支持<quote>注释掉了</quote>这种概念，但是Subversion会忽略所有以井号（<literal>#</literal>）开始的字符，这允许你快速的取消一个选项而不需要删除整个注册表，很明显简化了保存选项的过程。</para>

      <para><command>svn</command>命令行客户端决不会尝试写Windows注册表，不会创建你需要使用<command>REGEDIT</command>创建的键，作为选择，你可以创建一个<filename>.reg</filename>文件，并且双击这个文件，这回倒这数据合并到你的注册表。</para>

      <example id="svn-ch-7-sect-1.2-ex-1">
        <title>注册表条目（.reg）样本文件。</title>

        <programlisting>
REGEDIT4

[HKEY_LOCAL_MACHINE\Software\Tigris.org\Subversion\Servers\groups]

[HKEY_LOCAL_MACHINE\Software\Tigris.org\Subversion\Servers\global]
"#http-proxy-host"=""
"#http-proxy-port"=""
"#http-proxy-username"=""
"#http-proxy-password"=""
"#http-proxy-exceptions"=""
"#http-timeout"="0"
"#http-compression"="yes"
"#neon-debug-mask"=""
"#ssl-authority-files"=""
"#ssl-trust-default-ca"=""
"#ssl-client-cert-file"=""
"#ssl-client-cert-password"=""

[HKEY_CURRENT_USER\Software\Tigris.org\Subversion\Config\auth]
"#store-auth-creds"="no"

[HKEY_CURRENT_USER\Software\Tigris.org\Subversion\Config\helpers]
"#editor-cmd"="notepad"
"#diff-cmd"=""
"#diff3-cmd"=""
"#diff3-has-program-arg"=""

[HKEY_CURRENT_USER\Software\Tigris.org\Subversion\Config\miscellany]
"#global-ignores"="*.o *.lo *.la #*# .*.rej *.rej .*~ *~ .#* .DS_Store"
"#log-encoding"=""
"#use-commit-times"=""
"#template-root"=""
"#enable-auto-props"=""

[HKEY_CURRENT_USER\Software\Tigris.org\Subversion\Config\tunnels]

[HKEY_CURRENT_USER\Software\Tigris.org\Subversion\Config\auto-props]
</programlisting>
      </example>

      <para>前一个例子里展现了<filename>.reg</filename>文件的内容，保存了一些最常用的配置选项和它们的缺省值，注意包括了系统级（关于网络代理相关的选项）和每用户的设置（编辑器程序和密码保存，还有其它）。也应该注意所有的选项已经有效的注释掉了，你只需要删除选项名称前面的井号（<literal>#</literal>），然后设置你希望的值就可以了。</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-7-sect-1.3">
      <title>配置选项</title>
      
      <para>在本小节，我们会详细讨论Subversion目前支持的运行配置选项。</para>

      <sect3 id="svn-ch-7-sect-1.3.1">
        <title>服务器</title>

        <para><filename>servers</filename>文件保存了Subversion关于网络层的配置选项，这个文件有两个特别的小节&mdash;<literal>groups</literal> 和<literal>global</literal>，<literal>groups</literal>小节是一个交叉引用表，这个小节的关键字是这个文件其它的小节的名称；它们的值是一个组合&mdash;文本符号有可能包含通配符字符&mdash;对应Subversion请求发送的到的主机名。</para>

        <programlisting>
[groups]
beanie-babies = *.red-bean.com
collabnet = svn.collab.net

[beanie-babies]
&hellip;

[collabnet]
&hellip;
</programlisting>

        <para>当Subversion是通过网络使用的，它会设法用正在尝试连接的服务器的名字和<literal>groups</literal>小节的组名称匹配，如果发现匹配，Subversion会在<filename>servers</filename>文件的查找匹配这个group名称的小节，在那个小节它会去读取真实的网络配置设置。</para>

        <para><literal>global</literal>小节保存了没有<literal>groups</literal>小节匹配时的设置，这个小节存在的选项与其他服务器一样（当然是除了<literal>groups</literal>小节），是以下这些：</para>

        <variablelist>
          <varlistentry>
            <term><literal>http-proxy-host</literal></term>
            <listitem>
              <para>代理服务器的详细主机名，是HTTP为基础的Subversion请求必须通过的，缺省值是空的，意味着Subversion不会去尝试通过代理服务器进行HTTP请求，而会直接尝试去连接目标机器。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>http-proxy-port</literal></term>
            <listitem>
              <para>代理服务器的详细端口，缺省值是空。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>http-proxy-username</literal></term>
            <listitem>
              <para>代理服务器的用户名，缺省值是空。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>http-proxy-password</literal></term>
            <listitem>
              <para>代理服务器使用的密码，缺省是空。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>http-timeout</literal></term>
            <listitem>
              <para>等待服务器响应的时间，以秒为单位，如果你经历到过慢的网络速度，导致Subversion的操作超时，你可以增加这个值，缺省值是<literal>0</literal>会告诉HTTP库Neon使用自己的缺省值。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>http-compression</literal></term>
            <listitem>
              <para>这说明是否在与设置好DAV的服务器通讯时使用网络压缩请求，缺省值是<literal>yes</literal>（尽管只有在这个能力编译到网络层时压缩才会有效），设置<literal>no</literal>来关闭压缩，如调试网络传输时。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>neon-debug-mask</literal></term>
            <listitem>
              <para>只是一个整形的掩码，底层的HTTP库Neon用来选择产生调试的输出，缺省值是<literal>0</literal>，关闭所有的调试输出，关于Subversion使用Neon的详细信息，见<xref linkend="svn-ch-8" />。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>ssl-authority-files</literal></term>
            <listitem>
              <para>这是一个分号分割的路径和文件列表，这些文件包含了Subversion客户端在用HTTPS访问时可以接受的认证授权（或者CA）的证书。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>ssl-trust-default-ca</literal></term>
            <listitem>
              <para>如果你希望Subversion可以自动相信OpenSSL携带的缺省的CA，可以设置为<literal>yes</literal>。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>ssl-client-cert-file</literal></term>
            <listitem>
              <para>如果一个主机（或是一些主机）需要一个SSL客户端证书，你会收到一个提示说需要证书的路径。通过设置这个路径你的Subversion客户端可以自动找到你的证书而不会打扰你。没有标准的存放位置；Subversion会从任何你指定得只得到这个文件。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>ssl-client-cert-password</literal></term>
            <listitem>
              <para>如果你的SSL客户端证书文件是用密码加密的，Subversion会在每次使用证书时请你输入密码，如果你发现这很讨厌（并且不介意把密码存放在<filename>servers</filename>文件），你可以设置这个参数为证书的密码，你不会再收到密码输入提示了。</para>
            </listitem>
          </varlistentry>
        </variablelist>

      </sect3>
      <sect3 id="svn-ch-7-sect-1.3.2">
        <title>config</title>

        <para><filename>config</filename>文件保存了剩下的当前存在的Subversion运行选项，这些与网络连接无关，这些只是一些现在使用的选项，但是为了将来期望的增加也是分组为小节。</para>

        <para><literal>auth</literal>小节保存了Subversion相关的认证和授权的设置，它包括：</para>

        <variablelist>
          <varlistentry>
            <term><literal>store-passwords</literal></term>
            <listitem>
              <para>这告诉Subversion是否缓存服务器认证要求时用户需要提供的密码，缺省值是<literal>yes</literal>。设置为<literal>no</literal>可以关闭在存盘的密码缓存，你可以通过<command>svn</command>的<option>--no-auth-cache</option>命令行参数（那些支持这个的字命令）来覆盖这个设置，，详细信息请见<xref
                linkend="svn-ch-6-sect-2.2"/>。
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>store-auth-creds</literal></term>
            <listitem>
              <para>这个设置与<literal>store-passwords</literal>相似，除了是否开启和关闭<emphasis>所有</emphasis>认证信息：用户名、密码、服务器证书和其他任何类型的可以缓存的凭证。</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para><literal>helpers</literal>小节控制完成Subversion任务的外部程序，正确的选项包括：</para>

        <variablelist>
          <varlistentry>
            <term><literal>editor-cmd</literal></term>
            <listitem>
              <para>Subversion在提交操作时用来询问用户日志信息的程序，例如使用<command>svn
                commit</command>而没有指定<option>--message</option>（<option>-m</option>）或者<option>--file</option>（<option>-F</option>）选项。这个程序也会与<command>svn
                propedit</command>一起使用&mdash;一个临时文件跳出来包含已经存在的用户希望编辑的属性，这个编辑只发生在编辑器程序（见<xref
                linkend="svn-ch-7-sect-2" />），这个选项的缺省值是空，如果这个选项没有设置，Subversion会回头检查环境变量<literal>SVN_EDITOR</literal>、<literal>VISUAL</literal>和<literal>EDITOR</literal>（这个顺序）来找到一个编辑器命令。</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>diff-cmd</literal></term>
            <listitem>
              <para>这个命令是区别程序的绝对路径，当Subversion生成了<quote>diff</quote>输出时（例如当使用<command>svn diff</command>命令）就会使用，缺省Subversion会使用一个内置的区别库&mdash;设置这个参数会导致它会使用外部程序执行这个任务。
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>diff3-cmd</literal></term>
            <listitem>
              <para>这指定了一个三向的区别程序，Subversion使用这个程序来合并用户和从版本库接受的修改，缺省Subversion会使用一个内置的区别库&mdash;设置这个参数会导致它会使用外部程序执行这个任务。
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>diff3-has-program-arg</literal></term>
            <listitem>
              <para>如果<literal>diff3-cmd</literal>选项设置的程序接受一个<option>--diff-program</option>命令行参数，这个标记必须设置为<literal>true</literal>。</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para><literal>tunnels</literal>小节允许你定义一个<command>svnserve</command>和<literal>svn://</literal>客户端连接使用的管道模式，更多细节见<xref
          linkend="svn-ch-6-sect-3.4"/>。</para>

        <para><literal>miscellany</literal>小节是一些没法归到别处的选项，***
          <footnote>
            <para>任何人为了一顿家常便饭？</para> 
          </footnote>
          在本小节，你会找到：</para>

        <variablelist>
          <varlistentry>
            <term><literal>global-ignores</literal></term>
            <listitem>
              <para>当运行<command>svn status</command>命令时，Subversion会和版本化的文件一样列出未版本化的文件和目录，使用<literal>?</literal>字符（见see <xref
                linkend="svn-ch-3-sect-5.3.1" />）标记，有时候察看不关心的为版本化的文件会很讨厌&mdash;举个例子，程序编译产生的对象文件&mdash;会显示。<literal>global-ignores</literal>选项是一个空格分隔的列表，用来描述Subversion在它们版本化之前不想现实的文件和目录，缺省值是<literal>*.o *.lo *.la #*# .*.rej *.rej .*~ *~
                .#* .DS_Store</literal>。</para>

              <para>就像<command>svn status</command>，<command>svn add</command>和<command>svn import</command>命令也会忽略匹配这个列表的文件，你可以用单个的<option>--no-ignore</option>命令行参数来覆盖这个选项，关于更加细致的控制忽略的项目，见<xref linkend="svn-ch-7-sect-2.3.3"
                />。</para>
            </listitem>
          </varlistentry>
          
          <varlistentry>
            <term><literal>enable-auto-props</literal></term>
            <listitem>
              <para>这里指示Subversion自动对新加的或者导入的文件设置属性，缺省值是<literal>no</literal>，所以设置为<literal>yes</literal>来开启自动添加属性，这个文件的<literal>auto-props</literal>小节会说明那些属性设置到那些文件。</para>
            </listitem>            
          </varlistentry>

          <varlistentry>
            <term><literal>log-encoding</literal></term>
            <listitem>         
              <para>这个变量设置提交日志缺省的字符集，是<option>--encoding</option>选项（见<xref linkend="svn-ch-9-sect-1.1"/>）的永久形式，Subversion版本库保存了一些UTF8的日志信息，并且假定你的日志信息是用操作系统的本地编码，如果你提交的信息使用别的编码方式，你一定要指定不同的编码。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>use-commit-times</literal></term>
            <listitem>         
              <para>通常你的工作拷贝文件会有最后一次被进程访问的时间戳，不管是你自己的编辑器还是用<command>svn</command>子命令。这通常是对人们开发软件很方便，因为编译系统通常会通过察看时间戳来决定那些文件需要重新编译。</para>

              <para>在其他情形，有时候如果工作拷贝的文件德时间戳反映了上一次在版本库中更改的时间会非常好，<command>svn export</command>命令会一直放置这些<quote>上次提交的时间戳</quote>放到它创建的目录树。通过设置config参数为<literal>yes</literal>，<command>svn
                checkout</command>、<command>svn update</command>、
                <command>svn switch</command>和<command>svn
                revert</command>命令也会为他们接触的文件设置上次提交的时间戳。</para>
            </listitem>
          </varlistentry>
          
	  <!-- ###TODO add description of other options shown in example
          registry file, e.g., template-root -->
        </variablelist>

        <para><literal>auto-props</literal>小节控制Subversion客户端自动设置提交和导入的文件的属性的能力，它包含了任何数量的键-值对，格式是<literal>PATTERN = PROPNAME=PROPVALUE</literal>，其中<literal>PATTERN</literal>十一个文件模式，匹配一系列文件名，此行剩下的属性和值。如果一个文件匹配多次，会导致有多个属性集；然而，没有手段保障自动属性不会按照配置文件中的顺序应用，所以你可以一个规则<quote>覆盖</quote>另一个。你可以在<filename>config</filename>文件找到许多自动属性的用法实例。最后，如果你希望开启自动属性，不要忘了设置<literal>miscellany</literal>小节的<literal>enable-auto-props</literal>为<literal>yes</literal>。</para>

      </sect3>

    </sect2>
  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 2:  PROPERTIES                                      *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-7-sect-2">
    <title>属性</title>

    <para>我们已经覆盖了Subversion存储和检索版本库中不同版本的文件和目录的细节，整个章节来论述这个工具的基本功能，如果版本支持到此为止，Subversion还只是一个普通的版本控制观点，但是还没有结束。</para>

    <para>作为目录和文件版本化的补充，Subversion提供了对每一个版本化的目录和文件添加、修改和删除版本化的元数据的接口，我们用<firstterm>properties</firstterm>来表示这些元数据，我们可以认为他们是一个两列的表，附加到你的工作拷贝每个条目上，影射属性名到任意的值。一般来说，属性的名称和值可以是你希望的任何值，限制就是名称必须是可读的文本，并且最好的一点是这些属性也是版本化的，就像你的文本内容文件，你可以像提交文本修改一样修改、提交和恢复属性修改，当你的更新时也会接收到别人的属性修改。</para>

    <sidebar>
      <title>Subversion的其他属性</title>

      <para>Subversion也会在别的地方露面，就像文件和目录可能附加有任意的属性名和值，每个修订版本作为一个整体也可以附加任意的属性，也有同样的限制&mdash;可读的文本名称和任何你希望的，***二进制值&mdash;除了修订版本不是版本化的，见<xref linkend="svn-ch-5-sect-1.2" />来察看为版本化的属性信息。</para>
    </sidebar>

    <para>在本小节，我们将会检验这个工具&mdash;不仅是对Subversion的用户，也对Subversion本身&mdash;关于属性支持。你会学好属性相关的<command>svn</command>子命令，和属性怎样影响你的普通Subversion工作流，很期待你会确信Subversion的属性可以提高你的版本控制体验。</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-7-sect-2.1">
      <title>为什么是属性？</title>

      <para>属性会是你的工作拷贝有用的补充，实际上，Subversion本身使用属性来存放特殊的信息，作为帮助特别操作的一种方法，同样，你可以使用属性来实现自己的目的，当然，你对属性作的任何事情也可以针对普通的版本化文件，但是先考虑下面Subversion使用属性的例子。</para>

      <para>假定你希望设计一个网站存放许多数码图片，并且显示他们的标题和时间戳，现在你的图片集经常修改，所以你希望你的网站能够尽量的自动化，这些图片可能非常大，所以根据这个网站的特性，你希望在网站给用户提供图标图像。你可以用传统的文件做这件事，你可以有一个<filename>image123.jpg</filename>和一个<filename>image123-thumbnail.jpg</filename>对应在同一个目录，有时候你希望保持文件名相同，你可以使用不同的目录，如<filename>thumbnails/image123.jpg</filename>。你可以用一种相似的样式来保存你的标题和时间戳，再一次同原始图像文件分开。很快你的目录树会是一团糟，每个新图片的添加都会成倍的增加混乱。</para>

      <para>现在考虑使用Subversion文件的属性来做相同的设置，想象我们有一个单独的图像文件<filename>image123.jpg</filename>，然后这个文件的属性集包括<literal>caption</literal>、<literal>datestamp</literal>甚至<literal>thumbnail</literal>。现在你的工作拷贝目录看起来更佳的可管理&mdash;实际上，它看起来只有图像文件，但是你的自动化脚本知道得更多，它们知道可以用<command>svn</command>（更好的选择是使用Subversion的语言绑定&mdash;见<xref
        linkend="svn-ch-8-sect-2.3" />）来挖掘更多的站点显示需要的额外信息，而不必去阅读一个索引文件或者是玩一个路径处理的游戏。</para>

      <para>你怎样（而且如果）使用Subversion完全在你，像我们提到的，Subversion拥有它自己的属性集，我们会在后面的章节讨论，但首先，让我们讨论怎样使用<command>svn</command>的处理选项。</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-7-sect-2.2">
      <title>处理属性</title>

      <para><command>svn</command>命令提供一些方法来添加和修改文件或目录的属性，对于短的，可读的属性，最简单的添加方法是在<command>propset</command>子命令里指定正确的名称和值。
     </para>

      <screen>
$ svn propset copyright '(c) 2003 Red-Bean Software' calc/button.c
property 'copyright' set on 'calc/button.c'
$
</screen>
       
      <para>但是我们已经吹捧过Subversion提供过的属性值得灵活性，如果你计划有一个多行的可读文本，甚至是二进制文件的属性值，你通常不会希望在命令行里指定，所以<command>propset</command>子命令使用<option>--file</option>（<option>-F</option>）选项来指定一个保存新的属性值的文件的名字。</para>

      <screen>
$ svn propset license -F /path/to/LICENSE calc/button.c
property 'license' set on 'calc/button.c'
$
</screen>

      <para>作为<command>propset</command>命令的补充，<command>svn</command>提供了一个<command>propedit</command>命令，这个命令使用配制的编辑器程序（见<xref
        linkend="svn-ch-7-sect-1.3.2" />）来添加和修改属性。当你运行这个命令，<command>svn</command>调用你的编辑器程序到一个临时文件，保存了当前的属性值（或者是空的，如果你添加了一个新的属性）。然后你只需要修改那些值，改为你需要的值，保存你的临时文件，然后离开编辑器程序，如果Subversion发现你已经修改了属性存在的值，就会接受新的值，如果你未作任何修改离开，没有属性修改会发生。</para>

      <screen>
$ svn propedit copyright calc/button.c  ### exit the editor without changes
No changes to property 'copyright' on 'calc/button.c'
$
</screen>

      <para>我们必须注意，就像其他<command>svn</command>子命令，，这些关联的属性可以一次加到多个路径上，这让你可以通过一个命令修改一组文件的属性，举个例子，我们可以这样做：</para>

      <screen>
$ svn propset copyright '(c) 2002 Red-Bean Software' calc/*
property 'copyright' set on 'calc/Makefile'
property 'copyright' set on 'calc/button.c'
property 'copyright' set on 'calc/integer.c'
&hellip;
$
</screen>

      <para>如果你不容易得到存储的属性值，所有的属性的添加和编辑不会很容易，所以<command>svn</command>提供了两个子命令来显示文件和目录存储的属性名和值，<command>svn proplist</command>命令会列出路径上存在的所有属性名称，一旦你知道了某个节点的属性名称，你可以用<command>svn
        propget</command>要求他们的值，这个命令通过给定的路径（或者是一组路径）和属性名称，打印这个属性值到标准输出。</para>

      <screen>
$ svn proplist calc/button.c
Properties on 'calc/button.c':
  copyright
  license
$ svn propget copyright calc/button.c
(c) 2003 Red-Bean Software
</screen>

      <para>也有一个<command>proplist</command>变种命令会列出所有属性的名称和值，只需要提供<option>--verbose</option>（<option>-v</option>）选项。</para>

      <screen>
$ svn proplist --verbose calc/button.c
Properties on 'calc/button.c':
  copyright : (c) 2003 Red-Bean Software
  license : ================================================================
Copyright (c) 2003 Red-Bean Software.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions 
are met:

1. Redistributions of source code must retain the above copyright
notice, this list of conditions, and the recipe for Fitz's famous
red-beans-and-rice.
&hellip;
</screen>

      <para>最后一个属性相关的子命令是<command>propdel</command>，因为Subversion允许你来存储属性为空值，你不能所以你不能用<command>propedit</command>或者<command>propset</command>删除一个属性，举个例子，这个命令<emphasis>不会</emphasis>产生期望的效果：</para>

      <screen>
$ svn propset license '' calc/button.c
property 'license' set on 'calc/button.c'
$ svn proplist --verbose calc/button.c
Properties on 'calc/button.c':
  copyright : (c) 2003 Red-Bean Software
  license : 
$
</screen>

      <para>你需要使用<command>propdel</command>来删除属性，语法与其他属性命令相似：
      </para>

      <screen>
$ svn propdel license calc/button.c
property 'license' deleted from ''.
$ svn proplist --verbose calc/button.c
Properties on 'calc/button.c':
  copyright : (c) 2003 Red-Bean Software
$
</screen>

      <para>现在你已经熟悉了所有属性相关的<command>svn</command>子命令，让我们看看属性修改如何影响Subversion的工作流，我们前面提到过，文件和目录的属性是版本化的，就像你的文件内容。作为结果，Subversion提供了同样的机会来合并&mdash;用干净或者冲突的方式&mdash;其他人的修改进入到你的修改。</para>

      <sidebar>
        <title>修改修订版本的属性</title>

        <para>记住这些未版本化的属性？你也可以修改这些，使用<command>svn</command>命令。只需要添加<option>--revprop</option>命令参数，并且说明希望修改的修订版本。因为修订版本是全局的，你不需要指定一个路径，只要你已经位于你希望修改属性的工作拷贝路径，举个例子，你希望修改一个存在版本的提交日志信息。
          <footnote>
            <para>修正提交日志信息的拼写错误，文法错误和<quote>简单的错误</quote>是<option>--revprop</option>选项最常见用例。
            </para>
          </footnote></para>

        <screen>
$ svn propset svn:log '* button.c: Fix a compiler warning.' -r11 --revprop
property 'svn:log' set on repository revision '11'
$
</screen>

        <para>注意，修改这些未版本化的属性的能力一定要明确的添加给版本库管理员（见xref linkend="svn-ch-5-sect-2.1" />）。因为属性没有版本化，你如果不小心编辑，你会冒丢失信息的风险，版本库管理员可以设置方法来保护这种丢失，缺省情况下，修改未版本化的属性是禁止的。</para>

      </sidebar>

      <para>就像文件内容，你的属性修改是本地修改，只有提交<command>svn commit</command>后才会成为持久性存储，你的属性修改也可以容易的取消&mdash;<command>svn
        revert</command>命令会恢复你的文件和目录为未编辑状态，内容，属性和其他。另外，你可以使用<command>svn status</command>和<command>svn diff</command>接受感兴趣的文件和目录属性的状态信息。</para>

      <screen>
$ svn status calc/button.c
 M     calc/button.c
$ svn diff calc/button.c
Property changes on: calc/button.c
___________________________________________________________________
Name: copyright
   + (c) 2003 Red-Bean Software

$
</screen>

      <para>注意<command>status</command>子命令显示的<literal>M</literal>在第二列而不是在第一列，这是因为我们修改了<filename>calc/button.c</filename>的属性，而不是它的文本内容，如果我们都修改了，我们也会看到<literal>M</literal>出现在第一列（见<xref
        linkend="svn-ch-3-sect-5.3.1" />）。
        </para>

      <sidebar>
        <title>属性冲突</title>

        <para>与文件内容一样，本地的属性修改也会同别人的提交冲突，如果你更新你的工作拷贝目录并且接收到有资源属性修改与你的修改冲突，Subversion会报告资源处于冲突状态。</para>
 
        <screen>
% svn update calc
M  calc/Makefile.in
 C calc/button.c
Updated to revision 143.
$ 
</screen>
         
        <para>Subversion也会在冲突资源的同一个目录创建一个<filename>.prej</filename>扩展名的文件，保存了冲突细节。你一定要检验这个文件的内容来决定如何解决冲突，在你解决冲突之前，你会在使用<command>svn
          status</command>时看到这个资源的输出的第二列是一个<literal>C</literal>，提交本地修改的尝试会失败。</para>

        <screen>
$ svn status calc
 C     calc/button.c
?      calc/button.c.prej
$ cat calc/button.c.prej 
prop 'linecount': user set to '1256', but update set to '1301'.
$
</screen>
 
        <para>为了解决属性冲突，只需要确定冲突的属性保存了他们应该的值，然后使用<command>svn resolved</command>命令告诉Subversion你已经手工解决了问题。</para>

      </sidebar>

      <para>你也许已经注意到了Subversion现在显示属性区别的非标准方式。你还可以运行<command>svn diff</command>并且重定向输出来产生一个有用的补丁文件，<command>patch</command>程序会忽略属性补丁&mdash;作为规则，它会忽略任何不理解的噪音。很遗憾，这意味着完全应用<command>svn diff</command>产生的补丁时，任何属性修改必须手工应用。
      </para>

      <para>就象你看到的，属性修改的出现并没有对典型的Subversion工作流有显著的影响，你通常模式的更新工作拷贝，检查文件和目录的状态，报告你所做的修改和提交修改到版本库完全与属性的存在与否无关。<command>svn</command>程序有一些额外的子命令用来进行属性修改，但是那是唯一显而易见的不对称。
     </para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-7-sect-2.3">
      
      <title>特别属性</title>

      <para>Subversion没有关于属性的特殊政策&mdash;你可以通过它们实现自己的目的。Subversion只是要求你不要使用<literal>svn:</literal>开头的命名空间作为属性名，这是Subversion自己使用的命名空间。实际上，Subversion定义对这些属性他们所附加的文件和目录有特殊的效果。在本小节，我们会解开这个谜团，并且描述这些属性怎样让你的生活更加容易。</para>
      
      <sect3 id="svn-ch-7-sect-2.3.1">
        <title><literal>svn:executable</literal></title>
 
        <para><literal>svn:executable</literal>属性用来控制一个版本化的文件自动执行文件权限设定，这个属性没有特定的值&mdash;它只是说明一个Subversion可以保留的文件权限的期望值，删除这个属性会恢复操作系统对这些权限的完全控制。</para>

        <para>在多数操作系统，执行一个文件或命令的能力是由执行位管理的，这些位通常是关闭的，必须由用户显示的指定，这意味着你必须改变文件的执行位，然后更新你的工作拷贝，燃火如果你的文件成为更新的一部分，它的执行位会被关闭，所以Subversion提供了<literal>svn:executable</literal>这个属性来保持打开执行位。</para>

        <para>这个属性对于没有可执行权限位的文件系统无效，如FAT32和NTFS。
          <footnote>
            <para>Windows文件系统使用文件扩展名（如<literal>.EXE</literal>、<literal>.BAT</literal>和<literal>.COM</literal>）来标示可执行文件。
           </para>
          </footnote>
          也就是说，尽管它没有定义的值，在设置这个属性时，Subversion会强制它的值为<literal>*</literal>，最终，这个属性只对文件有效，目录无效。
         </para>

      </sect3>

      <sect3 id="svn-ch-7-sect-2.3.2">
        <title><literal>svn:mime-type</literal></title>
        
        <para><literal>svn:mime-type</literal>属性为Subversion的许多目的服务，除了保存一个文件的多用途网际邮件扩展（MIME）分类以外，这个属性值也描述了一些Subversion自己使用的行为特性。
        </para>

        <para>举个例子，如果一个文件<literal>svn:mime-type</literal>属性设置为非文本的MIME类型（通常是那些不是<literal>text/</literal>开头的类型，但也有例外），Subversion会假定这个文件保存了二进制内容&mdash;也就是不可读的&mdash;数据。一个好处就是Subversion通常在更新到工作拷贝时提供了一个前后相关的以行为基础的修改合并，但是对于保存二进制数据的文件，没有<quote>行</quote>的概念，所以对这些文件，Subversion不会在更新时尝试执行合并操作，相反，任何时候你在本地修改的一个二进制文件有了更新，你的文件会被重命名为<filename>.orig</filename>为扩展名，然后Subversion保存一个新的工作拷贝文件，保存更新时得到的修改，但原来的文件名已经不是你自己的本地修改。这个行为模式是用来保护用户在对不可文本合并的文件尝试执行文本的合并时失败的情形。</para>

        <para>另外，如果<literal>svn:mime-type</literal>属性被设置，Subversion的Apache模块会使用这个值来在HTTP头里输入<literal>Content-type:</literal>，这给了web浏览器如何显示一个文件提供了至关重要的线索。
        </para>

      </sect3>

      <sect3 id="svn-ch-7-sect-2.3.3">
        <title><literal>svn:ignore</literal></title>

        <para>这个<literal>svn:ignore</literal>属性保存了一个Subversion特定操作忽略的文件模式列表，或许这个是最常用的属性，它可以与<literal>global-ignores</literal>运行配置选项配合使用（见<xref linkend="svn-ch-7-sect-1.3.2" />）来过滤<command>svn status</command>、<command>svn
          add</command>和<command>svn import</command>命令中操作的未版本化文件。
          </para>

        <para><literal>svn:ignore</literal>背后的基本原理很容易解释，Subversion不会假定工作拷贝中的所有文件或子目录是版本控制的一部分，资源必须被显示的使用<command>svn add</command>或者<command>svn import</command>放到Subversion的管理控制之下，作为结果，经常有许多工作拷贝的资源并没有版本化。
       </para>

        <para>现在，<command>svn status</command>命令会的显示会包括所有未纳入版本控制且没有用<literal>global-ignores</literal>（或是内置的缺省值）过滤掉的文件和子目录，这样可以帮助用户查看是否忘记了把某些自愿加入到版本控制。</para>

        <para>但是Subversion不可能猜测到需要忽略的资源的名字，但是也有一些资源是<emphasis>所有</emphasis>特定版本库的工作拷贝都有忽略的，强制版本库的每个用户来添加这些模式到他们的运行配置区域不仅仅是一个负担，也会与用户取出的其他工作拷贝配置需要存在潜在的冲突。</para>

        <para>解决方案是保存的忽略模式必须对出现在给定目录和这个目录本身的资源是独立的，一个常见的例子就是一个未版本化资源对一个目录来说是唯一的，会出现在那个位置，包括程序编译的输出，或者是&mdash;用一个本书的例子&mdash;DocBook的文件生成的HTML、PDF或者是PostScript文件。
       </para>

        <sidebar>
          <title>CVS用户的忽略模式</title>
        
          <para>Subversion的<literal>svn:ignore</literal>属性与CVS的<filename>.cvsignore</filename>文件的语法和功能非常类似，实际上，如果你移植一个CVS的工作拷贝到Subversion，你可以直接使用<filename>.cvsignore</filename>作为<command>svn propset</command>输入文件参数：
         </para>
       
          <screen>
$ svn propset svn:ignore -F .cvsignore .
property 'svn:ignore' set on '.'
$
</screen>        

          <para>但是CVS和Subversion处理忽略模式的方式有一些不同，这两个系统在不同的时候使用忽略模式，忽略模式应用的对象也由微小的不同，但是Subversion不会识别重置回到没有忽略模式的<literal>!</literal>模式的使用。
         </para>

        </sidebar>

        <para>为了这个目的，<literal>svn:ignore</literal>属性是解决方案，它的值是一个多行的文件模式集，一行一个模式，这个属性已经设置到这个你希望应用模式的目录。
          <footnote>
            <para>这个模式对那个目录是严格的&mdash;不会迭代的应用到子目录。
            </para>
          </footnote>
          举个例子，你的<command>svn status</command>有如下的输出：
          </para>

        <screen>
$ svn status calc
 M     calc/button.c
?      calc/calculator
?      calc/data.c
?      calc/debug_log
?      calc/debug_log.1
?      calc/debug_log.2.gz
?      calc/debug_log.3.gz
</screen>

        <para>在这个例子里，你对<filename>button.c</filename>文件作了一些属性修改，但是你的工作拷贝也有一些未版本化的文件：你从源代码编译的最新的<filename>计算器</filename>程序是<filename>data.c</filename>，一系列调试输出日志文件，现在你知道你的编译系统会编译<filename>calculator</filename>程序。
        In this example, you have made some property
          modifications to <filename>button.c</filename>, but in your
          working copy you also have some unversioned files:
          the latest <filename>calculator</filename> program
          that you've compiled from your source code, a source file
          named <filename>data.c</filename>, and a set of debugging
          output log files.  Now, you know that your build system
          always results in the <filename>calculator</filename>
          program being generated.
          <footnote>
            <para>这不是编译系统的基本功能吗？</para>
          </footnote>
          就像你知道的，你的测试组件总是会留下这些调试日志，这对所有的工作拷贝都是一样的，不仅仅使你的。你也知道你不会有兴趣在<command>svn status</command>命令中显示这些信息，所以使用<command>svn
          propedit svn:ignore calc</command>来为<filename>calc</filename>目录增加一些忽略模式，举个例子，你或许会添加如下的值作为<literal>svn:ignore</literal>属性：</para>

        <programlisting>
calculator
debug_log*
</programlisting>

        <para>当你添加完这些属性，你会在<filename>calc</filename>目录有一个本地修改，但是注意你的<command>svn status</command>输出有什么其他的不同：</para>

        <screen>
$ svn status
 M     calc
 M     calc/button.c
?      calc/data.c
</screen>

        <para>现在，所有多余的输出不见了！当然，这些文件还在工作拷贝，Subversion仅仅是不再提醒你它们的存在和未版本化。现在所有讨厌的噪音都已经删除了，你留下了更加感兴趣的项目&mdash;如你忘记添加到版本控制的源代码文件。
       </para>

        <para>If you want to see the ignored files, you can pass the 
          <option>--no-ignore</option> option to Subversion:</para>

<screen>
$ svn status --no-ignore
 M     calc/button.c
I      calc/calculator
?      calc/data.c
I      calc/debug_log
I      calc/debug_log.1
I      calc/debug_log.2.gz
I      calc/debug_log.3.gz
</screen>

        <para><command>svn add</command>和<command>svn
          import</command>也会使用这个忽略模式列表，这两个操作都包括了询问Subversion来开始管理一组文件和目录。比强制用户挑拣目录树中那个文件要纳入版本控制的方式更好，Subversion使用忽略模式来检测那个文件不应该在大的迭代添加和导入操作中进入版本控制系统。
         </para>
   
      </sect3>

      <sect3 id="svn-ch-7-sect-2.3.4">
        <title><literal>svn:keywords</literal></title>

        <para>Subversion具备有添加<firstterm>关键字</firstterm>的能力&mdash;一些有用的，关于版本化的文件动态信息的片断&mdash;不必直接添加到文件本身。关键字通常会用来描述文件最后一次修改的一些信息，因为这些信息每次都有改变，更重要的一点，这是在文件修改<emphasis>之后</emphasis>，除了版本控制系统，对于任何处理完全保持最新的数据都是一场争论，作为人类作者，信息变得陈旧是不可避免的。</para>

        <para>举个例子，你有一个文档希望显示最后修改的日期，你需要麻烦每个作者提交之前做这件事情，同时会改变描述这部分细细的部分，但是迟早会有人忘记做这件事，不选择简单的告诉Subversion来执行替换<literal>LastChangedDate</literal>关键字的操作，在你的文档需要放置这个关键字的地方放置一个<firstterm>keyword anchor</firstterm>，这个anchor只是一个格式为<literal>$</literal><replaceable>KeywordName</replaceable><literal>$</literal>字符串。
       </para>

        <para>所有作为anchor出现在文件里的关键字是大小写敏感的：为了关键字的扩展，你必须使用正确的按顺序大写。你必须考虑<literal>svn:keywords</literal>的属性值也是大小写敏感&mdash;特定的关键字名会忽略大小写，但是这个特性已经被废弃了。</para>

        <para>Subversion定义了用来替换的关键字列表，这个列表保存了如下五个关键字，有一些也包括了可用的别名：
       </para>

        <variablelist>
          <varlistentry>
            <term><literal>Date</literal></term>
            <listitem>
              <para>这个关键字保存了文件最后一次在版本库修改的日期，看起来类似于<literal>$Date:
                2002-07-22 21:42:37 -0700 (Mon, 22 Jul 2002)
                $</literal>，它也可以用<literal>LastChangedDate</literal>来指定。
                </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>Revision</literal></term>
            <listitem>
              <para>这个关键字描述了这个文件最后一次修改的修订版本，看起来像<literal>$Revision: 144 $</literal>，也可以通过<literal>LastChangedRevision</literal>或者<literal>Rev</literal>引用。
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>Author</literal></term>
            <listitem>
              <para>这个关键字描述了最后一个修改这个文件的用户，看起来类似<literal>$Author: harry $</literal>，也可以用<literal>LastChangedBy</literal>来指定。
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>HeadURL</literal></term>
            <listitem>
              <para>这个关键字描述了这个文件在版本库最新的版本的完全URL，看起来类似<literal>$HeadURL:
                http://svn.collab.net/repos/trunk/README $</literal>，可以缩写为<literal>URL</literal>。
                </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>Id</literal></term>
            <listitem>
              <para>这个关键字是其他关键字一个压缩组合，它看起来就像literal>$Id: calc.c 148 2002-07-28 21:30:43Z sally
                $</literal>，可以解释为文件<filename>calc.c</filename>上一次修改的修订版本号是148，时间是2002年7月28日，作者是<literal>sally</literal>。
               </para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>只需要在你的文件增加关键字anchor不会做什么特别的事情，Subversion不会尝试对你的文件内容执行文本替换，除非明确的被告知这样做，毕竟，你可以撰写一个文档
          <footnote>
            <para>&hellip; 或者可能是一本书的一个小节 &hellip; </para>
          </footnote> 
          关于如何使用关键字，你希望Subversion不会替代你漂亮的关于不需要替换的关键字anchor实例！
          </para>

        <para>为了告诉Subversion是否替代某个文件的关键字，我们要再次求助于属性相关的子命令，当<literal>svn:keywords</literal>属性设置到一个版本化的文件，这些属性控制了那些关键字将会替换到那个文件。这个值是空格分隔的前面列表的名称或是别名列表。</para>

        <para>举个例子，假定你有一个版本化的文件<filename>weather.txt</filename>，内容如下：
        </para>

        <programlisting>
Here is the latest report from the front lines.
$LastChangedDate$
$Rev$
Cumulus clouds are appearing more frequently as summer approaches.
</programlisting>
        
        <para>当没有<literal>svn:keywords</literal>属性设置到这个文件，Subversion不会有任何特别操作，现在让我们允许<literal>LastChangedDate</literal>关键字的替换。
       </para>

        <screen>
$ svn propset svn:keywords "Date Author" weather.txt
property 'svn:keywords' set on 'weather.txt'
$
</screen>        

        <para>现在你已经对<filename>weather.txt</filename>的属性作了修改，你会看到文件的内容没有改变（除非你之前做了一些属性设置），注意这个文件包含了<literal>Rev</literal>的关键字anchor，但我们没有在属性值中包括这个关键字，Subversion会高兴的忽略替换这个文件中的关键字，也不会替换<literal>svn:keywords</literal>属性中没有出现的关键字。
       </para>

        <sidebar>
          <title>关键字和虚假的差异</title>

          <para>用户可见的关键字替换会让你以为每一个具有此特性的文件的每个版本都会与前一个版本至少在关键字替换的地方不同，但是实际上并不是如此，当用<command>svn
            diff</command>检查本地修改时，或者是在使用<command>svn commit</command>传输修改之前，Subversion不会<quote>取消替换</quote>任何上次替换的关键字，结果就是版本库保存的文件只保存用户实际做的修改。
            </para>

        </sidebar>

        <para>在你提交了属性修改后，Subversion会立刻更新你的工作文件为新的替代文本，不会寻找你的<literal>$LastChangedDate$</literal>关键字anchor，你会看到替换的结果，这个结果也保存了关键字的名字，与美元符号（<literal>$</literal>）绑定在一起，而且我们预测的，<literal>Rev</literal>关键字不会被替换，因为我们没有要求这样做。</para>

        <para>注意我们设置<literal>svn:keywords</literal>属性为"Date Author"，关键字anchor使用别名<literal>$LastChangedDate$</literal>并且正确的扩张。
        </para>

        <screen>
Here is the latest report from the front lines.
$LastChangedDate: 2002-07-22 21:42:37 -0700 (Mon, 22 Jul 2002) $
$Rev$
Cumulus clouds are appearing more frequently as summer approaches.
</screen>
        
        <para>如果有其他人提交了<filename>weather.txt</filename>的修改，你的此文件的拷贝还会显示同样的替换关键字值&mdash;直到你更新你的工作拷贝，此时你的<filename>weather.txt</filename>重的关键字将会被替换来反映最新的提交信息。
       </para>

      </sect3>

      <sect3 id="svn-ch-7-sect-2.3.5">
        <title><literal>svn:eol-style</literal></title>

        <para>Unless otherwise noted using a versioned file's
          <literal>svn:mime-type</literal> property, Subversion
          assumes the file contains human-readable data.  Generally
          speaking, Subversion only uses this knowledge to determine
          if contextual difference reports for that file are
          possible.  Otherwise, to Subversion, bytes are bytes.</para>
        
        <para>This means that by default, Subversion doesn't pay any
          attention to the type of <firstterm>end-of-line (EOL)
          markers</firstterm> used in your files.  Unfortunately,
          different operating system use different tokens to represent
          the end of a line of text in a file.  For example, the usual
          line ending token used by software on the Windows platform
          is a pair of ASCII control characters&mdash;carriage return
          (<literal>CR</literal>) and line feed
          (<literal>LF</literal>).  Unix software, however, just uses
          the <literal>LF</literal> character to denote the end of a
          line.</para>

        <para>Not all of the various tools on these operating systems
          are prepared to understand files that contain line endings
          in a format that differs from the <firstterm>native line
          ending style</firstterm> of the operating system on which
          they are running.  Common results are that Unix programs
          treat the <literal>CR</literal> character present in Windows
          files as a regular character (usually rendered as
          <literal>^M</literal>), and that Windows programs combine
          all of the lines of a Unix file into one giant line because
          no carriage return-linefeed (or <literal>CRLF</literal>)
          character combination was found to denote the end of
          line.</para>

        <para>This sensitivity to foreign EOL markers can become
          frustrating for folks who share a file across different
          operating systems.  For example, consider a source code
          file, and developers that edit this file on both Windows and
          Unix systems.  If all the developers always use tools which
          preserve the line ending style of the file, no problems
          occur.</para>

        <para>But in practice, many common tools either fail to
          properly read a file with foreign EOL markers, or they
          convert the file's line endings to the native style when the
          file is saved.  If the former is true for a developer, he
          has to use an external conversion utility (such as
          <command>dos2unix</command> or its companion,
          <command>unix2dos</command>) to prepare the file for
          editing.  The latter case requires no extra preparation.
          But both cases result in a file that differs from the
          original quite literally on every line!  Prior to committing
          his changes, the user has two choices.  Either he can use a
          conversion utility to restore the modified file to the same
          line ending style that it was in before his edits were made.
          Or, he can simply commit the file&mdash;new EOL markers and
          all.</para>

        <para>The result of scenarios like these include wasted time
          and unnecessary modifications to committed files.  Wasted
          time is painful enough.  But when commits change every line
          in a file, this complicates the job of determining which of
          those lines were changed in a non-trivial way.  Where was
          that bug really fixed?  On what line was a syntax error
          introduced?</para>

        <para>The solution to this problem is the
          <literal>svn:eol-style</literal> property.  When this
          property is set to a valid value, Subversion uses it to
          determine what special processing to perform on the file so
          that the file's line ending style isn't flip-flopping with
          every commit that comes from a different operating
          system.  The valid values are:</para>

        <variablelist>
          <varlistentry>
            <term><literal>native</literal></term>
            <listitem>
              <para>This causes the file to contain the EOL markers
                that are native to the operating system on which
                Subversion was run.  In other words, if a user on a
                Windows machine checks out a working copy that
                contains a file with an
                <literal>svn:eol-style</literal> property set to
                <literal>native</literal>, that file will contain
                <literal>CRLF</literal> EOL markers.  A Unix user
                checking out a working copy which contains the same
                file will see <literal>LF</literal> EOL markers in his
                copy of the file.</para>

              <para>Note that Subversion will actually store the file
                in the repository using normalized
                <literal>LF</literal> EOL markers regardless of the
                operating system.  This is basically transparent to
                the user, though.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>CRLF</literal></term>
            <listitem>
              <para>This causes the file to contain
                <literal>CRLF</literal> sequences for EOL markers,
                regardless of the operating system in use.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>LF</literal></term>
            <listitem>
              <para>This causes the file to contain
                <literal>LF</literal> characters for EOL markers,
                regardless of the operating system in use.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>CR</literal></term>
            <listitem>
              <para>This causes the file to contain
                <literal>CR</literal> characters for EOL markers,
                regardless of the operating system in use.  This line
                ending style is not very common.  It was used on older
                Macintosh platforms (on which Subversion doesn't even
                run).</para>
            </listitem>
          </varlistentry>
        </variablelist>
        
      </sect3>

      <sect3 id="svn-ch-7-sect-2.3.6">
        <title><literal>svn:externals</literal></title>

        <para>The <literal>svn:externals</literal> property contains
          instructions for Subversion to populate a versioned
          directory with one or more other checked-out Subversion
          working copies.  For more information on this keyword and
          its use, see <xref linkend="svn-ch-7-sect-3"/>.</para>

      </sect3>

      <sect3 id="svn-ch-7-sect-2.3.7">
        <title><literal>svn:special</literal></title>

        <para>The <literal>svn:special</literal> property is the only
          <literal>svn:</literal> property that isn't meant to be
          directly set or modified by users.  Subversion automatically
          sets this property whenever a <quote>special</quote> object
          is scheduled for addition, such as a symbolic link.  The
          repository stores an <literal>svn:special</literal> object as
          an ordinary file.  However, when a client sees this property
          during checkouts or updates, it interprets the contents of
          the file and translates the item back into the special type
          of object.  In Subversion 1.1, only versioned symbolic links
          have this property attached, but in future versions of
          Subversion other special types of nodes will probably use
          this property as well.</para>

        <para>Note: Windows clients don't have symbolic links, and
          thus ignore any <literal>svn:special</literal> files coming
          from a repository that claim to be symbolic links.  On
          Windows, the user ends up with an ordinary versioned file in
          the working copy.</para>
      </sect3>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-7-sect-2.4">
      <title>Automatic Property Setting</title>

      <para>Properties are a powerful feature of Subversion, acting as
        key components of many Subversion features discussed elsewhere
        in this and other chapters&mdash;textual diff and merge
        support, keyword substitution, newline translation, etc.  But
        to get the full benefit of properties, they must be set on the
        right files and directories.  Unfortunately, that can be a
        step easily forgotten in the routine of things, especially
        since failing to set a property doesn't usually result in an
        obvious error condition (at least compared to, say, failing to
        add a file to version control).  To help your properties get
        applied to the places that need them, Subversion provides a
        couple of simple but useful features.</para>

      <para>Whenever you introduce a file to version control using the
        <command>svn add</command> or <command>svn import</command>
        commands, Subversion runs a very basic heuristic to determine
        if that file consists of human-readable or non-human-readable
        content.  If the latter is the decision made, Subversion will
        automatically set the <literal>svn:mime-type</literal>
        property on that file to
        <literal>application/octet-stream</literal> (the generic
        <quote>this is a collection of bytes</quote> MIME type).  Of
        course, if Subversion guesses incorrectly, or if you wish to
        set the <literal>svn:mime-type</literal> property to something
        more precise&mdash;perhaps <literal>image/png</literal> or
        <literal>application/x-shockwave-flash</literal>&mdash;you can
        always remove or edit that property.</para>

      <para>Subversion also provides the auto-props feature, which
        allows you to create mappings of filename patterns to property
        names and values.  These mappings are made in your runtime
        configuration area.  They again affect adds and imports, and
        not only can override any default MIME type decision made by
        Subversion during those operations, they can also set
        additional Subversion or custom properties, too.  For example,
        you might create a mapping that says that any time you add
        JPEG files&mdash;ones that match the pattern
        <literal>*.jpg</literal>&mdash;Subversion should automatically
        set the <literal>svn:mime-type</literal> property on those
        files to <literal>image/jpeg</literal>.  Or perhaps any files
        that match <literal>*.cpp</literal> should have
        <literal>svn:eol-style</literal> set to
        <literal>native</literal>, and <literal>svn:keywords</literal>
        set to <literal>Id</literal>.  Auto-prop support is perhaps
        the handiest property related tool in the Subversion toolbox.
        See <xref linkend="svn-ch-7-sect-1.3.2"/> for more about
        configuring that support.</para>

    </sect2>     
  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 2 1/2:  PEG AND OPERATIVE REVISIONS                 *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-7-sect-2b">
    <title>Peg and Operative Revisions</title>

    <para>The ability to copy, move, and rename files and directories;
      to be able to create an object, then delete it and then add a
      new one at the same path&mdash;those are operations which we
      perform on files and directories on our computers all the time,
      and operations we tend to take for granted.  And Subversion
      would like you to think they are granted.  Subversion's file
      management support is quite liberating, affording almost as much
      flexibility for versioned files that you'd expect when
      manipulating your unversioned ones.  But that flexibility means
      that across the lifetime of your repository, a given versioned
      resource might have many paths, and a given path might represent
      serveral entirely different versioned resources.</para>

    <para>Subversion is pretty smart about noticing when an object's
      version history includes such <quote>changes of address</quote>.
      For example, if you ask for all the logs of a particular file
      that was renamed last week, Subversion happily provides all
      those logs&mdash;the revision in which the rename itself
      happened, plus the logs of relevant revisions both before and
      after that rename.  So, most of the time, you don't even have to
      think about such things.  But occasionally, Subversion needs
      your help to clear up ambiguities.</para>

    <para>The simplest example of this occurs when a directory or file
      is deleted from version control, and then a new directory or
      file is created with the same name and added to version control.
      Clearly the thing you deleted and the thing you later added
      aren't the same thing, they merely happen to have had the same
      path, which we'll call <filename>/trunk/object</filename>.
      What, then, does it mean to ask Subversion about the history of
      <filename>/trunk/object</filename>?  Are you asking about the
      thing currently at that location, or the old thing you deleted
      from that location?  Are you asking about the operations that
      have happened to all the objects that have lived at that path?
      Clearly, Subversion needs a hint about what you are really
      asking.</para>

    <para>And thanks to moves, versioned resource history can get far
      more twisted than that, even.  For example, you might have a
      directory named <filename>concept</filename>, containing some
      nascent software project you've been toying with.  Eventually,
      though, that project matures to the point that the idea seems to
      actually have some wings, so you do the unthinkable and decide
      to give the project a name.
      <footnote>
        <para><quote>You're not supposed to name it.  Once you name it,
          you start getting attached to it.</quote> &mdash; Mike
          Wazowski</para>
      </footnote>
      Let's say you called your software Frabnaggilywort.  At this
      point, it makes sense to rename the directory to reflect the
      project's new name, so <filename>concept</filename> is renamed
      to <filename>frabnaggilywort</filename>.  Life goes on,
      Frabnaggilywort releases a 1.0 version, and is downloaded and
      used daily by hordes of people aiming to improve their
      lives.</para>
    
    <para>It's a nice story, really, but it doesn't end there.
      Entrepreneur that you are, you've already got another think in
      the tank.  So you make a new directory,
      <filename>concept</filename>, and the cycle begins again.  In
      fact, the cycle begins again many times over the years, each
      time starting with that old <filename>concept</filename>
      directory, then sometimes seeing that directory renamed as the
      idea cures, sometimes seeing it deleted when you scrap the idea.
      Or, to get really sick, maybe you rename
      <filename>concept</filename> to something else for a while, but
      later rename the thing back to <filename>concept</filename> for
      some reason.</para>

    <para>When scenarios like these occur, attempting to instruct
      Subversion to work with these re-used paths can be a little like
      instructing a motorist in Chicago's West Suburbs to drive east
      down Roosevelt Road and turn left onto Main Street.  In a mere
      twenty minutes, you can cross <quote>Main Street</quote> in
      Wheaton, Glen Ellyn, and Lombard.  And no, they aren't the same
      street.  Our motorist&mdash;and our Subversion&mdash;need a
      little more detail in order to do the right thing.</para>

    <para>In version 1.1, Subversion introduced a way for you to tell
      it exactly which Main Street you meant.  It's called the
      <firstterm>peg revision</firstterm>, and it is a revision
      provided to Subversion for the sole purpose of identifying a
      unique line of history.  Because at most one versioned resource
      may occupy a path at any given time&mdash;or, more precisely, in
      any one revision&mdash;the combination of a path and a peg
      revision is all that is needed to refer to a specific line of
      history.  Peg revisions are specified to the Subversion
      command-line client using <firstterm>at syntax</firstterm>, so
      called because the syntax involves appending an <quote>at
      sign</quote> (<literal>@</literal>) and the peg revision to the
      end of the path with which the revision is associated.</para>

    <para>But what of the <option>--revision (-r)</option> of which
      we've spoken so much in this book?  That revision (or set of
      revisions) is called the <firstterm>operative
      revision</firstterm> (or <firstterm>operative revision
      range</firstterm>).  Once a particular line of history has been
      identified using a path and peg revision, Subversion performs
      the requested operation using the operative revision(s).  To map
      this to our Chicagoland streets analogy, if we are told to go to
      606 N. Main Street in Wheaton,
      <footnote>
        <para>606 N. Main Street, Wheaton, Illinois, is the home of
          the Wheaton History Center.  Get it&mdash;<quote>History
          Center</quote>?  It seemed appropriate&hellip;.</para>
      </footnote>
      we can think of <quote>Main Street</quote> as our path and
      <quote>Wheaton</quote> as our peg revision.  These two pieces of
      information identify a unique path which can travelled (north or
      south on Main Street), and will keep us from travelling up and
      down the wrong Main Street in search of our destination.  Now we
      throw in <quote>606 N.</quote> as our operative revision, of
      sorts, and we know <emphasis>exactly</emphasis> where to
      go.</para>

    <para>Subversion performs a fairly straightforward algorithm when
      using peg and operative revisions to find real stuff to work on.
      First, the path associated with the peg revision is located in
      that revision in the repository.  From there, Subversion begins
      stepping backwards through historical predecessors of the object
      located at that path and peg revision.  Each of these
      predecessors represents an earlier version of the object, and
      each stores a record of which revision it was created in, and at
      what path.  So, while traversing the set of predecessors,
      Subversion notices whenever one of them is the youngest version
      of the object to exist as of one of the operative revisions, and
      if so, maps that operative revision to the created path/created
      revision pair of the predecessor.  The algorithm terminates
      either when all the operative revisions have been mapped to real
      object locations, or once there are no more predecessors to
      traverse, in which case any unmapped operative revisions are
      marked as invalid for the object being operated on.</para>

    <para>Say that long ago we created our repository, and in revision 1
      added our first <filename>concept</filename> directory, plus an
      <filename>IDEA</filename> file in that directory talking about
      the concept.  After several revisions in which real code was
      added and tweaked, we, in revision 20, renamed this directory to
      <filename>frabnaggilywort</filename>.  By revision 27, we had a
      new concept, a new <filename>concept</filename> directory to
      hold it, and a new <filename>IDEA</filename> file to describe
      it.  And then five years and twenty thousand revisions flew by,
      just like they would in any good romance story.</para>

    <para>Now, years later, we wonder what the
      <filename>IDEA</filename> file looked like back in revision 1.
      But Subversion needs to know if we are asking about how the
      <emphasis>current</emphasis> file looked back in revision 1, or
      are we asking for the contents of whatever file lived at
      <filename>concepts/IDEA</filename> in revision 1?  Certainly
      those questions have different answers, and because of peg
      revisions, you can ask either of them.  To find out how the
      current <filename>IDEA</filename> file looked in that old
      revision, you run:</para>

    <screen>
$ svn cat -r 1 concept/IDEA 
subversion/libsvn_client/ra.c:775: (apr_err=20014)
svn: Unable to find repository location for 'concept/IDEA' in revision 1
</screen>

    <para>Of course, in this example, the current
      <filename>IDEA</filename> file didn't exist yet in revision 1,
      so Subversion gives an error.  The command above is shorthand
      for a longer notation which explicitly lists a peg revision.
      The expanded notation is:</para>

    <screen>
$ svn cat -r 1 concept/IDEA@BASE
subversion/libsvn_client/ra.c:775: (apr_err=20014)
svn: Unable to find repository location for 'concept/IDEA' in revision 1
</screen>

    <para>And when executed, has the expected results.  Peg revisions
      generally default to a value of <literal>BASE</literal> (the
      revision currently present in the working copy) when applied to
      working copy paths, and of <literal>HEAD</literal> when applied
      to URLs.</para>

    <para>Let's ask the other question, then&mdash;in revision 1, what
      were the contents of whatever file occupied the address
      <filename>concepts/IDEA</filename> at the time?  We'll use an
      explicit peg revision to help us out.</para>

    <screen>
$ svn cat concept/IDEA@1
The idea behind this project is to come up with a piece of software
that can frab a naggily wort.  Frabbing naggily worts is tricky
business, and doing it incorrectly can have serious ramifications, so
we need to employ over-the-top input validation and data verification
mechanisms.
</screen>

    <para>This appears to be the right output.  The text even mentions
      frabbing naggily worts, so this is almost certainly the file
      which describes the software now called Frabnaggilywort.  In
      fact, we can verify this using the combination of an explicit
      peg revision and explicit operative revision.  We know that in
      <literal>HEAD</literal>, the Frabnaggilywort project is located
      in the <filename>frabnaggilywort</filename> directory.  So we
      specify that we want to see how the line of history identified
      in <literal>HEAD</literal> as the path
      <filename>frabnaggilywort/IDEA</filename> looked in revision
      1.</para>

    <screen>
$ svn cat -r 1 frabnaggilywort/IDEA@HEAD
The idea behind this project is to come up with a piece of software
that can frab a naggily wort.  Frabbing naggily worts is tricky
business, and doing it incorrectly can have serious ramifications, so
we need to employ over-the-top input validation and data verification
mechanisms.
</screen>

    <para>And the peg and operative revisions need not be so trivial,
      either.  For example, say <filename>frabnaggilywort</filename>
      had beed deleted from <literal>HEAD</literal>, but we know it
      existed in revision 20, and we want to see the diffs for its
      <filename>IDEA</filename> file between revisions 4 and 10.  We
      can use the peg revision 20 in conjunction with the URL that
      would have held Frabnaggilywort's <filename>IDEA</filename> file
      in revision 20, and then use 4 and 10 as our operative revision
      range.</para>

    <screen>
$ svn diff -r 4:10 http://svn.red-bean.com/projects/frabnaggilywort/IDEA@20
Index: frabnaggilywort/IDEA
===================================================================
--- frabnaggilywort/IDEA	(revision 4)
+++ frabnaggilywort/IDEA	(revision 10)
@@ -1,5 +1,5 @@
-The idea behind this project is to come up with a piece of software
-that can frab a naggily wort.  Frabbing naggily worts is tricky
-business, and doing it incorrectly can have serious ramifications, so
-we need to employ over-the-top input validation and data verification
-mechanisms.
+The idea behind this project is to come up with a piece of
+client-server software that can remotely frab a naggily wort.
+Frabbing naggily worts is tricky business, and doing it incorrectly
+can have serious ramifications, so we need to employ over-the-top
+input validation and data verification mechanisms.
</screen>

    <para>Fortunately, most folks aren't faced with such complex
      situations.  But when you are, remember that peg revisions are
      that extra hint Subversion needs to clear up ambiguity.</para>

  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 3:  EXTERNALS DEFINITIONS                           *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-7-sect-3">
    <title>Externals Definitions</title>
    
    <para>Sometimes it is useful to construct a working copy that is
      made out of a number of different checkouts.  For example, you
      may want different subdirectories to come from different
      locations in a repository, or perhaps from different
      repositories altogether.  You could certainly setup such a
      scenario by hand&mdash;using <command>svn checkout</command> to
      create the sort of nested working copy structure you are trying
      to achieve.  But if this layout is important for everyone who
      uses your repository, every other user will need to perform the
      same checkout operations that you did.</para>

    <para>Fortunately, Subversion provides support for
      <firstterm>externals definitions</firstterm>.  An externals
      definition is a mapping of a local directory to the
      URL&mdash;and possibly a particular revision&mdash;of a
      versioned resource.  In Subversion, you declare externals
      definitions in groups using the <literal>svn:externals</literal>
      property.  You can create or modify this property using
      <command>svn propset</command> or <command>svn
      propedit</command> (see <xref linkend="svn-ch-7-sect-2.1"/>).  
      It can be set on any versioned directory,
      and its value is a multi-line table of subdirectories (relative
      to the versioned directory on which the property is set) and
      fully qualified, absolute Subversion repository URLs.</para>

    <screen>
$ svn propget svn:externals calc
third-party/sounds             http://sounds.red-bean.com/repos
third-party/skins              http://skins.red-bean.com/repositories/skinproj
third-party/skins/toolkit -r21 http://svn.red-bean.com/repos/skin-maker
</screen>

    <para>The convenience of the <literal>svn:externals</literal>
      property is that once it is set on a versioned directory,
      everyone who checks out a working copy with that directory also
      gets the benefit of the externals definition.  In other words,
      once one person has made the effort to define those nested
      working copy checkouts, no one else has to
      bother&mdash;Subversion will, upon checkout of the original
      working copy, also checkout the external working copies.</para>

    <para>Note the previous externals definition example.  When
      someone checks out a working copy of the
      <filename>calc</filename> directory, Subversion also continues
      to checkout the items found in its externals definition.</para>

    <screen>
$ svn checkout http://svn.example.com/repos/calc
A  calc
A  calc/Makefile
A  calc/integer.c
A  calc/button.c
Checked out revision 148.

Fetching external item into calc/third-party/sounds
A  calc/third-party/sounds/ding.ogg
A  calc/third-party/sounds/dong.ogg
A  calc/third-party/sounds/clang.ogg
&hellip;
A  calc/third-party/sounds/bang.ogg
A  calc/third-party/sounds/twang.ogg
Checked out revision 14.

Fetching external item into calc/third-party/skins
&hellip;
</screen>

    <para>If you need to change the externals definition, you can do
      so using the regular property modification subcommands.  When
      you commit a change to the <literal>svn:externals</literal>
      property, Subversion will synchronize the checked-out items
      against the changed externals definition when you next run
      <command>svn update</command>.  The same thing will happen when
      others update their working copies and receive your changes to
      the externals definition.</para>

    <para>The <command>svn status</command> command also recognizes
      externals definitions, displaying a status code of
      <literal>X</literal> for the disjoint subdirectories into which
      externals are checked out, and then recursing into those
      subdirectories to display the status of the external items
      themselves.</para>

    <para>The support that exists for externals definitions in
      Subversion today can be a little misleading, though.  First, an
      externals definition can only point to directories, not files.
      Second, the externals definition cannot point to relative paths
      (paths like <filename>../../skins/myskin</filename>).  Third, the
      working copies created via the externals definition support are
      still disconnected from the primary working copy (on whose
      versioned directories the <literal>svn:externals</literal>
      property was actually set).  And Subversion still only truly
      operates on non-disjoint working copies.  So, for example, if
      you want to commit changes that you've made in one or more of
      those external working copies, you must run <command>svn
      commit</command> explicitly on those working
      copies&mdash;committing on the primary working copy will not
      recurse into any external ones.</para>

    <para>Also, since the definitions themselves use absolute URLs,
      moving or copying a directory to which they are attached will
      not affect what gets checked out as an external (though the
      relative local target subdirectory will, of course, move with
      renamed directory).  This can be confusing&mdash;even
      frustrating&mdash;in certain situations.  For example, if you
      use externals definitions on a directory in your
      <filename>/trunk</filename> development line which point to
      other areas of that same line, and then you use <command>svn
      copy</command> to branch that line to some new location
      <filename>/branches/my-branch</filename>, the externals
      definitions on items in your new branch will still refer to
      versioned resources in <filename>/trunk</filename>.  Also, be
      aware that if you need to re-parent your working copy (using
      <command>svn switch --relocate</command>), externals definitions
      will <emphasis>not</emphasis> also be re-parented.</para>

  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 4:  VENDOR BRANCHES                                 *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-7-sect-4">
    <title>Vendor branches</title>

    <para>As is especially the case when developing software, the data
      that you maintain under version control is often closely related
      to, or perhaps dependent upon, someone else's data.  Generally,
      the needs of your project will dictate that you stay as
      up-to-date as possible with the data provided by that external
      entity without sacrificing the stability of your own project.
      This scenario plays itself out all the time&mdash;anywhere that
      the information generated by one group of people has a direct
      effect on that which is generated by another group.</para>
 
    <para>For example, software developers might be working on an
      application which makes use of a third-party library.
      Subversion has just such a relationship with the Apache Portable
      Runtime library (see <xref linkend="svn-ch-8-sect-2.1" />).  The
      Subversion source code depends on the APR library for all its
      portability needs.  In earlier stages of Subversion's
      development, the project closely tracked APR's changing API,
      always sticking to the <quote>bleeding edge</quote> of the
      library's code churn.  Now that both APR and Subversion have
      matured, Subversion attempts to synchronize with APR's library
      API only at well-tested, stable release points.</para>

    <para>Now, if your project depends on someone else's information,
      there are several ways that you could attempt to synchronize that
      information with your own.  Most painfully, you could issue oral
      or written instructions to all the contributors of your project,
      telling them to make sure that they have the specific versions
      of that third-party information that your project needs.  If the
      third-party information is maintained in a Subversion
      repository, you could also use Subversion's externals
      definitions to effectively <quote>pin down</quote> specific
      versions of that information to some location in your own
      working copy directory (see <xref linkend="svn-ch-7-sect-3" />).</para>

    <para>But sometimes you want to maintain custom modifications to
      third-party data in your own version control system.  Returning
      to the software development example, programmers might need to
      make modifications to that third-party library for their own
      purposes.  These modifications might include new functionality
      or bug fixes, maintained internally only until they become part
      of an official release of the third-party library.  Or the
      changes might never be relayed back to the library maintainers,
      existing solely as custom tweaks to make the library further
      suit the needs of the software developers.</para>

    <para>Now you face an interesting situation.  Your project could
      house its custom modifications to the third-party data in some
      disjointed fashion, such as using patch files or full-fledged
      alternate versions of files and directories.  But these quickly
      become maintenance headaches, requiring some mechanism by which
      to apply your custom changes to the third-party data, and
      necessitating regeneration of those changes with each successive
      version of the third-party data that you track.</para>

    <para>The solution to this problem is to use <firstterm>vendor
      branches</firstterm>.  A vendor branch is a directory tree in
      your own version control system that contains information
      provided by a third-party entity, or vendor.  Each version of
      the vendor's data that you decide to absorb into your project is
      called a <firstterm>vendor drop</firstterm>.</para> 

    <para>Vendor branches provide two key benefits.  First, by storing
      the currently supported vendor drop in your own version control
      system, the members of your project never need to question
      whether they have the right version of the vendor's data.  They
      simply receive that correct version as part of their regular
      working copy updates.  Secondly, because the data lives in your
      own Subversion repository, you can store your custom changes to
      it in-place&mdash;you have no more need of an automated (or
      worse, manual) method for swapping in your customizations.</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-7-sect-4.1">
      <title>General Vendor Branch Management Procedure</title>

      <para>Managing vendor branches generally works like this.  You
        create a top-level directory (such as
        <filename>/vendor</filename>) to hold the vendor branches.
        Then you import the third party code into a subdirectory of
        that top-level directory.  You then copy that subdirectory
        into your main development branch (for example,
        <filename>/trunk</filename>) at the appropriate location.  You
        always make your local changes in the main development branch.
        With each new release of the code you are tracking you bring
        it into the vendor branch and merge the changes into
        <filename>/trunk</filename>, resolving whatever conflicts
        occur between your local changes and the upstream
        changes.</para>

      <para>Perhaps an example will help to clarify this algorithm.
        We'll use a scenario where your development team is creating a
        calculator program that links against a third-party complex
        number arithmetic library, libcomplex.  We'll begin with the
        initial creation of the vendor branch, and the import of the
        first vendor drop.  We'll call our vendor branch directory
        <filename>libcomplex</filename>, and our code drops will go
        into a subdirectory of our vendor branch called
        <filename>current</filename>.  And since <command>svn
        import</command> creates all the intermediate parent
        directories it needs, we can actually accomplish both of these
        steps with a single command.</para>

      <screen>
$ svn import /path/to/libcomplex-1.0 \
             http://svn.example.com/repos/vendor/libcomplex/current \
             -m 'importing initial 1.0 vendor drop'
&hellip;
</screen>
    
      <para>We now have the current version of the libcomplex source
        code in <filename>/vendor/libcomplex/current</filename>.  Now,
        we tag that version (see <xref linkend="svn-ch-4-sect-6" />)
        and then copy it into the main development branch.  Our copy
        will create a new directory called
        <filename>libcomplex</filename> in our existing
        <filename>calc</filename> project directory.  It is in this
        copied version of the vendor data that we will make our
        customizations.</para>
    
      <screen>
$ svn copy http://svn.example.com/repos/vendor/libcomplex/current  \
           http://svn.example.com/repos/vendor/libcomplex/1.0      \
           -m 'tagging libcomplex-1.0'
&hellip;
$ svn copy http://svn.example.com/repos/vendor/libcomplex/1.0  \
           http://svn.example.com/repos/calc/libcomplex        \
           -m 'bringing libcomplex-1.0 into the main branch'
&hellip;
</screen>

      <para>We check out our project's main branch&mdash;which now
        includes a copy of the first vendor drop&mdash;and we get to
        work customizing the libcomplex code.  Before we know it, our
        modified version of libcomplex is now completely integrated
        into our calculator program.
        <footnote>
          <para>And entirely bug-free, of course!</para>
        </footnote>
      </para>

      <para>A few weeks later, the developers of libcomplex release a
        new version of their library&mdash;version 1.1&mdash;which
        contains some features and functionality that we really want.
        We'd like to upgrade to this new version, but without losing
        the customizations we made to the existing version.  What we
        essentially would like to do is to replace our current
        baseline version of libcomplex 1.0 with a copy of libcomplex
        1.1, and then re-apply the custom modifications we previously
        made to that library to the new version.  But we actually
        approach the problem from the other direction, applying the
        changes made to libcomplex between versions 1.0 and 1.1 to our
        modified copy of it.</para>
      
      <para>To perform this upgrade, we checkout a copy of our vendor
        branch, and replace the code in the
        <filename>current</filename> directory with the new libcomplex
        1.1 source code.  We quite literally copy new files on top of
        existing files, perhaps exploding the libcomplex 1.1 release
        tarball atop our existing files and directories.  The goal
        here is to make our <filename>current</filename> directory
        contain only the libcomplex 1.1 code, and to ensure that all
        that code is under version control.  Oh, and we want to do
        this with as little version control history disturbance as
        possible.</para>

      <para>After replacing the 1.0 code with 1.1 code, <command>svn
        status</command> will show files with local modifications as
        well as, perhaps, some unversioned or missing files.  If we
        did what we were supposed to do, the unversioned files are
        only those new files introduced in the 1.1 release of
        libcomplex&mdash;we run <command>svn add</command> on those to
        get them under version control.  The missing files are files
        that were in 1.0 but not in 1.1, and on those paths we run
        <command>svn delete</command>.  Finally, once our
        <filename>current</filename> working copy contains only the
        libcomplex 1.1 code, we commit the changes we made to get it
        looking that way.</para>

      <para>Our <filename>current</filename> branch now contains the
        new vendor drop.  We tag the new version (in the same way we
        previously tagged the version 1.0 vendor drop), and then merge
        the differences between the tag of the previous version and
        the new current version into our main development
        branch.</para>

      <screen>
$ cd working-copies/calc
$ svn merge http://svn.example.com/repos/vendor/libcomplex/1.0      \
            http://svn.example.com/repos/vendor/libcomplex/current  \
            libcomplex
&hellip; # resolve all the conflicts between their changes and our changes
$ svn commit -m 'merging libcomplex-1.1 into the main branch'
&hellip;
</screen>

      <para>In the trivial use case, the new version of our
        third-party tool would look, from a files-and-directories
        point of view, just like the previous version.  None of the
        libcomplex source files would have been deleted, renamed or
        moved to different locations&mdash;the new version would
        contain only textual modifications against the previous one.
        In a perfect world, our modifications would apply cleanly to
        the new version of the library, with absolutely no
        complications or conflicts.</para>

      <para>But things aren't always that simple, and in fact it is
        quite common for source files to get moved around between
        releases of software.  This complicates the process of
        ensuring that our modifications are still valid for the new
        version of code, and can quickly degrade into a situation
        where we have to manually recreate our customizations in the
        new version.  Once Subversion knows about the history of a
        given source file&mdash;including all its previous
        locations&mdash;the process of merging in the new version of
        the library is pretty simple.  But we are responsible for
        telling Subversion how the source file layout changed from
        vendor drop to vendor drop.</para>

    </sect2>

    <!-- TODO: Try to clarify some of the steps for svn_load_dirs.pl
         (Garrett sez they've been "glossed over".  Also, consider
         another section on bypassing svn_load_dirs.pl altogether and
         running with just svn merge, now that it ignores ancestry. -->

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-7-sect-4.2">
      <title><command>svn_load_dirs.pl</command></title>

      <para>Vendor drops that contain more than a few deletes,
        additions and moves complicate the process of upgrading to
        each successive version of the third-party data.  So
        Subversion supplies the <command>svn_load_dirs.pl</command>
        script to assist with this process.  This script automates the
        importing steps we mentioned in the general vendor branch
        management procedure to make sure that mistakes are minimized.
        You will still be responsible for using the merge commands to
        merge the new versions of the third-party data into your main
        development branch, but <command>svn_load_dirs.pl</command>
        can help you more quickly and easily arrive at that
        stage.</para>

      <para>In short, <command>svn_load_dirs.pl</command> is an
        enhancement to <command>svn import</command> that has several
        important characteristics:</para>

      <itemizedlist>
        <listitem>
          <para>It can be run at any point in time to bring an existing
            directory in the repository to exactly match an external
            directory, performing all the necessary adds and deletes,
            and optionally performing moves, too.</para>
        </listitem>
        <listitem>
          <para>It takes care of complicated series of operations between
            which Subversion requires an intermediate commit&mdash;such
            as before renaming a file or directory twice.</para>
        </listitem>
        <listitem>
          <para>It will optionally tag the newly imported directory.</para>
        </listitem>
        <listitem>
          <para>It will optionally add arbitrary properties to files and
            directories that match a regular expression.</para>
        </listitem>
      </itemizedlist>

      <para><command>svn_load_dirs.pl</command> takes three mandatory
        arguments.  The first argument is the URL to the base
        Subversion directory to work in.  This argument is followed by
        the URL&mdash;relative to the first argument&mdash;into which the
        current vendor drop will be imported.  Finally, the third
        argument is the local directory to import.  Using our previous
        example, a typical run of <command>svn_load_dirs.pl</command>
        might look like:</para>

      <screen>
$ svn_load_dirs.pl http://svn.example.com/repos/vendor/libcomplex \
                   current                                        \
                   /path/to/libcomplex-1.1
&hellip;
</screen>

      <para>You can indicate that you'd like
        <command>svn_load_dirs.pl</command> to tag the new vendor drop
        by passing the <option>-t</option> command-line option and
        specifying a tag name.  This tag is another URL relative to
        the first program argument.</para>

      <screen>
$ svn_load_dirs.pl -t libcomplex-1.1                              \
                   http://svn.example.com/repos/vendor/libcomplex \
                   current                                        \
                   /path/to/libcomplex-1.1
&hellip;
</screen>

      <para>When you run <command>svn_load_dirs.pl</command>, it
        examines the contents of your existing <quote>current</quote>
        vendor drop, and compares them with the proposed new vendor
        drop.  In the trivial case, there will be no files that are in
        one version and not the other, and the script will perform the
        new import without incident.  If, however, there are
        discrepancies in the file layouts between versions,
        <command>svn_load_dirs.pl</command> will prompt you for how
        you would like to resolve those differences.  For example, you
        will have the opportunity to tell the script that you know
        that the file <filename>math.c</filename> in version 1.0 of
        libcomplex was renamed to <filename>arithmetic.c</filename> in
        libcomplex 1.1.  Any discrepancies not explained by moves
        are treated as regular additions and deletions.</para>

      <para>The script also accepts a separate configuration file for
        setting properties on files and directories matching a regular
        expression that are <emphasis>added</emphasis> to the
        repository.  This configuration file is specified to
        <command>svn_load_dirs.pl</command> using the
        <option>-p</option> command-line option.  Each line of the
        configuration file is a whitespace-delimited set of two or
        four values: a Perl-style regular expression to match the
        added path against, a control keyword (either
        <literal>break</literal> or <literal>cont</literal>), and then
        optionally a property name and value.</para>

      <screen>
\.png$              break   svn:mime-type   image/png
\.jpe?g$            break   svn:mime-type   image/jpeg
\.m3u$              cont    svn:mime-type   audio/x-mpegurl
\.m3u$              break   svn:eol-style   LF
.*                  break   svn:eol-style   native
</screen>

      <para>For each added path, the configured property changes whose
        regular expression matches the path are applied in order,
        unless the control specification is <literal>break</literal>
        (which means that no more property changes should be applied
        to that path).  If the control specification is
        <literal>cont</literal>&mdash;an abbreviation for
        <literal>continue</literal>&mdash;then matching will continue
        with the next line of the configuration file.</para>

      <para>Any whitespace in the regular expression, property name,
        or property value must be surrounded by either single or
        double quote characters.  You can escape quote characters that
        are not used for wrapping whitespace by preceding them with a
        backslash (<literal>\</literal>) character.  The backslash
        escapes only quotes when parsing the configuration file, so do
        not protect any other characters beyond what is necessary for
        the regular expression.</para>

    </sect2>
  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 5:  LOCALIZATION                                    *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-7-sect-5">
    <title>Localization</title>

    <para><firstterm>Localization</firstterm> is the act of making
      programs behave in a region-specific way.  When a program
      formats numbers or dates in a way specific to your part of the
      world, or prints messages (or accepts input) in your native
      language, the program is said to
      be <firstterm>localized</firstterm>.  This section describes
      steps Subversion has made towards localization.</para>

    <sect2 id="svn-ch7-sect-5.1">
      <title>Understanding locales</title>

      <para>Most modern operating systems have a notion of the
        <quote>current locale</quote>&mdash;that is, the region or
        country whose localization conventions are honored.  These
        conventions&mdash;typically chosen by some runtime
        configuration mechanism on the computer&mdash;affect the way
        in which programs present data to the user, as well as the way
        in which they accept user input.</para>

      <para>On Unix-like systems, you can check the values of the
        locale-related runtime configuration options by running the
        <command>locale</command> command:</para>

      <screen>
$ locale
LANG=
LC_COLLATE="C"
LC_CTYPE="C"
LC_MESSAGES="C"
LC_MONETARY="C"
LC_NUMERIC="C"
LC_TIME="C"
LC_ALL="C"
</screen>

      <para>The output is a list of locale-related environment
        variables and their current values.  In this example, the
        variables are all set to the default <literal>C</literal>
        locale, but users can set these variables to specific
        country/language code combinations.  For example, if one were
        to set the <literal>LC_TIME</literal> variable to
        <literal>fr_CA</literal>, then programs would know to present
        time and date information formatted according a
        French-speaking Canadian's expectations.  And if one were to
        set the <literal>LC_MESSAGES</literal> variable to
        <literal>zh_TW</literal>, then programs would know to present
        human-readable messages in Traditional Chinese.  Setting the
        <literal>LC_ALL</literal> variable has the effect of changing
        every locale variable to the same value.  The value of
        <literal>LANG</literal> is used as a default value for any
        locale variable that is unset.  To see the list of available
        locales on a Unix system, run the command <command>locale
        -a</command>.</para>

      <para>On Windows, locale configuration is done via the
        <quote>Regional and Language Options</quote> control panel
        item.  There you can view and select the values of individual
        settings from the available locales, and even customize (at a
        sickening level of detail) several of the display formatting
        conventions.</para>

    </sect2>

    <sect2 id="svn-ch7-sect-5.2">
      <title>Subversion's use of locales</title>

      <para>The Subversion client, <command>svn</command>, honors the
        current locale configuration in two ways.  First, it notices
        the value of the <literal>LC_MESSAGES</literal> variable and
        attempts to print all messages in the specified language.  For
        example:</para>

      <screen>
$ export LC_MESSAGES=de_DE
$ svn help cat
cat: Ausgabe des Inhaltes der angegebenen Dateien oder URLs
Aufruf: cat ZIEL...
&hellip;
</screen>

      <para>This behavior works identically on both Unix and Windows
        systems.  Note, though, that while your operating system might
        have support for a certain locale, the Subversion client still
        may not be able to speak the particular language.  In order to
        produce localized messages, human volunteers must provide
        translations for each language.  The translations are written
        using the GNU gettext package, which results in translation
        modules that end with the <filename>.mo</filename> filename
        extension.  For example, the German translation file is named
        <filename>de.mo</filename>.  These translation files are
        installed somewhere on your system.  On Unix, they typically
        live in <filename>/usr/share/locale/</filename>, while
        on Windows they're often found in the
        <filename>\share\locale\</filename> folder in Subversion's
        installation area.  Once installed, a module is named after
        the program it provides translations for.  For example, the
        <filename>de.mo</filename> file may ultimately end up
        installed as
        <filename>/usr/share/locale/de/LC_MESSAGES/subversion.mo</filename>.
        By browsing the installed <filename>.mo</filename> files, you
        can see which languages the Subversion client is able to
        speak.</para>

      <para>The second way in which the locale is honored involves how
        <command>svn</command> interprets your input.  The repository
        stores all paths, filenames, and log messages in Unicode,
        encoded as UTF-8.  In that sense, the repository is
        <firstterm>internationalized</firstterm>&mdash; that is, the
        repository is ready to accept input in any human language.
        This means, however, that the Subversion client is responsible
        for sending only UTF-8 filenames and log messages into the
        repository.  In order to do this, it must convert the data
        from the native locale into UTF-8.</para>

      <para>For example, suppose you create a file
        named<filename>caff猫.txt</filename>, and then when committing
        the file, you write the log message as <quote>Adesso il caff猫
        猫 pi霉 forte</quote>.  Both the filename and log message
        contain non-ASCII characters, but because your locale is set
        to <literal>it_IT</literal>, the Subversion client knows to
        interpret them as Italian.  It uses an Italian character set
        to convert the data to UTF-8 before sending them off to the
        repository.</para>

      <para>Note that while the repository demands UTF-8 filenames and
        log messages, it <emphasis>does not</emphasis> pay attention
        to file contents.  Subversion treats file contents as opaque
        strings of bytes, and neither client nor server makes an
        attempt to understand the character set or encoding of the
        contents.</para>

      <sidebar>
        <title>Character set conversion errors</title>

        <para>While using Subversion, you might get hit with an error
          related to character set conversions:</para>

        <screen>
svn: Can't recode string.
</screen>
    
        <para>The message is cryptic, but generally occurs when the
          Subversion client has received a UTF-8 string from the
          repository, but the characters can't be converted to the
          current locale.  For example, if your locale is
          <literal>en_US</literal> but a collaborator has committed a
          Japanese filename, you're likely to see this error when you
          receive the file during an <command>svn
          update</command>.</para>

        <para>The solution is either to set your locale to something
          which <emphasis>can</emphasis> represent the incoming UTF-8
          data, or to change the filename or log message in the
          repository.  (And don't forget to slap your collaborator's
          hand&mdash;projects should decide on common languages ahead of
          time, so that all participants are using the same
          locale.)</para>
      </sidebar>

    </sect2>

  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 6:  SUBVERSION REPOSITORY URLS                      *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-7-sect-6">
    <title>Subversion Repository URLs</title>

    <para>As illustrated throughout this book, Subversion uses URLs to
      identify versioned resources in Subversion repositories.  For
      the most part, these URLs use the standard syntax, allowing for
      server names and port numbers to be specified as part of the
      URL:</para>

    <screen>
$ svn checkout http://svn.example.com:9834/repos
&hellip;
</screen>

    <para>But there are some nuances in Subversion's handling of URLs
      that are notable.  For example, URLs containing the
      <literal>file:</literal> access method (used for local
      repositories) must, in accordance with convention, have either a
      server name of <literal>localhost</literal> or no server name at
      all:</para>
 
    <screen>
$ svn checkout file:///path/to/repos
&hellip;
$ svn checkout file://localhost/path/to/repos
&hellip;
</screen>

    <para>Also, users of the <literal>file:</literal> scheme on
      Windows platforms will need to use an unofficially
      <quote>standard</quote> syntax for accessing repositories
      that are on the same machine, but on a different drive than
      the client's current working drive.  Either of the two
      following URL path syntaxes will work where
      <literal>X</literal> is the drive on which the repository
      resides:</para>

    <screen>
C:\&gt; svn checkout file:///X:/path/to/repos
&hellip;
C:\&gt; svn checkout "file:///X|/path/to/repos"
&hellip;
</screen>
 
    <para>In the second syntax, you need to quote the URL so that the
      vertical bar character is not interpreted as a pipe.  Also, note
      that a URL uses ordinary slashes even though the native
      (non-URL) form of a path on Windows uses backslashes.</para>
    
    <para>Finally, it should be noted that the Subversion client will
      automatically encode URLs as necessary, just like a web browser
      does.  For example, if a URL contains a space or upper-ASCII
      character:</para>

    <screen>
$ svn checkout "http://host/path with space/project/espa帽a"
</screen>
    
    <para>&hellip;then Subversion will escape the unsafe characters
      and behave as if you had typed:</para>

    <screen>
$ svn checkout http://host/path%20with%20space/project/espa%C3%B1a
</screen>

    <para>If the URL contains spaces, be sure to place it within quote
      marks, so that your shell treats the whole thing as a single
      argument to the <command>svn</command> program.</para>

  </sect1>
  
</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
