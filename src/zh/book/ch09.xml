<chapter id="svn.ref">
  <title>Subversion完全参考</title>
  
  <simplesect>
    <para>本章是使用Subversion的一个完全手册，包括了命令行客户端（<command>svn</command>）和它的所有子命令，也有版本库管理程序（<command>svnadmin</command>和<command>svnlook</command>）和它们各自的子命令。
    </para>
  </simplesect>
  
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.ref.svn">
    <title>Subversion命令行客户端：<command>svn</command></title>
    
    <para>为了使用命令行客户端，只需要输入<command>svn</command>和它的子命令<footnote>
        <para>是的，使用<option>--version</option>选项不需要子命令，几分钟后我们会到达那个部分。
        </para>
        </footnote>以及相关的选项或操作的对象&mdash;输入的子命令和选项没有特定的顺序，下面使用<command>svn
      status</command>的方式都是合法的：</para>

    <screen>
$ svn -v status
$ svn status -v 
$ svn status -v myfile
</screen>

    <para>你可以在<xref linkend="svn.tour"/>发现更多使用客户端命令的例子，以及<xref linkend="svn.advanced.props"/>中的管理属性的命令。</para>
    
    <!-- =============================================================== -->
    <sect2 id="svn.ref.svn.sw">
      <title><command>svn</command>选项</title> 
      
      <para>虽然Subversion的子命令有一些不同的选项，但有的选项是全局的&mdash;也就是说，每个选项保证是表示同样的事情，而不管是哪个子命令使用的。举个例子，<option>--verbose</option>（<option>-v</option>）一直意味着<quote>冗长输出</quote>，而不管使用它的命令是什么。</para>

      <variablelist>
        
        <varlistentry>
          <term><option>--auto-props</option></term>
          <listitem>
            <para>开启auto-props，覆盖<filename>config</filename>文件中的<literal>enable-auto-props</literal>指示。</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><option>--config-dir</option>
            <replaceable>DIR</replaceable></term>
          <listitem>
            <para>指导Subversion从指定目录而不是默认位置（用户主目录的<filename>.subversion</filename>）读取配置信息。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--diff-cmd</option>
            <replaceable>CMD</replaceable></term>
          <listitem>
            <para>指定用来表示文件区别的外部程序，当<command>svn
              diff</command>调用时，会使用Subversion的内置区别引擎，默认会提供统一区别输出，如果你希望使用一个外置区别程序，使用<option>--diff-cmd</option>。你可以通过<option>--extensions</option>（本小节后面有更多介绍）把选项传递到区别程序。</para>
          </listitem>
        </varlistentry>
      
        <varlistentry>
          <term><option>--diff3-cmd</option>
            <replaceable>CMD</replaceable></term>
          <listitem>
            <para>指定一个外置程序用来合并文件。</para>
          </listitem>
        </varlistentry>
      
        <varlistentry>
          <term><option>--dry-run</option></term>
          <listitem>
            <para>检验运行一个命令的效果，但没有实际的修改&mdash;可以用在磁盘和版本库。</para>
          </listitem>
        </varlistentry>
      
        <varlistentry>
          <term><option>--editor-cmd</option>
            <replaceable>CMD</replaceable></term>
          <listitem>
            <para>指定一个外部程序来编辑日志信息或是属性值。</para>
          </listitem>
        </varlistentry>
      
        <varlistentry>
          <term><option>--encoding</option> <replaceable>ENC</replaceable></term>
          <listitem>
            <para>告诉Subversion你的提交日志信息是通过提供的字符集编码的，缺省时是你的操作系统的本地编码，如果你的提交信息使用其它编码，你一定要指定这个值。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--extensions</option> (<option>-x</option>)
          <replaceable>ARGS</replaceable></term>
          <listitem>
            <para>指定一个或多个Subversion传递给提供文件区别的外部区别程序的参数，如果你要传递多个参数，你一定能够要用引号（例如，<command>svn diff --diff-cmd /usr/bin/diff -x
              "-b -E"</command>）括起所有的参数。这个选项<emphasis>只有</emphasis>在使用<option>--diff-cmd</option>选项时使用。</para>
          </listitem>
        </varlistentry>
      
        <varlistentry>
          <term><option>--file</option> (<option>-F</option>)
            <replaceable>FILENAME</replaceable>
          </term>
          <listitem>
            <para>使用传递的文件内容作为特定子命令的选项。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--force</option></term>
          <listitem>
            <para>强制一个特定的命令或操作运行。Subversion有一些操作防止你做普通的使用，但是你可以传递force选项告诉Subversion<quote>我知道我做的事情，也知道这样的结果，所以让我做吧</quote>。这个选项在程序上等同于在打开电源的情况下做你自己的电子工作<!--***-->&mdash;如果你不知道你在做什么，你很有可能会得到一个威胁的警告。
           </para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><option>--force-log</option></term>
          <listitem>
            <para>将传递给<option>--message</option>（<option>-m</option>）或者<option>--file</option>（<option>-F</option>）的可疑参数指定为有效可接受。缺省情况下，如果选项的参数看起来会成为子命令的目标，Subversion会提出一个错误，例如，你传递一个版本化的文件路径给<option>--file</option>（<option>-F</option>）选项，Subversion会认为出了点错误，认为你将目标对象当成了参数，而你并没有提供其它的&mdash;未版本化的文件作为日志信息的文件。为了确认你的意图并且不考虑这类错误，传递<option>--force-log</option>选项给命令来接受它作为日志信息。
            </para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><option>--help</option> (<option>-h</option> or
                <option>-?</option>)
          </term>
          <listitem>
            <para>如果同一个或多个子命令一起使用，会显示每个子命令内置的帮助文本，如果单独使用，它会显示常规的客户端帮助文本。</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><option>--ignore-ancestry</option></term>
          <listitem>
            <para>告诉Subversion在计算区别（只依赖于路径内容）时忽略祖先。</para>
          </listitem>
        </varlistentry>
      
        <varlistentry>
          <term><option>--ignore-externals</option></term>
          <listitem>
            <para>告诉Subversion忽略外部定义和外部定义管理的工作拷贝。</para>
          </listitem>
        </varlistentry>      

        <varlistentry>
          <term><option>--incremental</option></term>
          <listitem>
            <para>打印适合串联的输出格式。</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><option>--limit</option>
            <replaceable>NUM</replaceable></term>
          <listitem>
            <para>只显示第一个<replaceable>NUM</replaceable>日志信息。</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><option>--message</option> (<option>-m</option>)
            <replaceable>MESSAGE</replaceable>
          </term>
          <listitem>
            <para>表示你会在命令行中指定日志信息，紧跟这个开关，例如：</para>
            
            <screen>
$ svn commit -m "They don't make Sunday."
</screen>
          </listitem>
        </varlistentry>
      
        <varlistentry>
          <term><option>--new</option> <replaceable>ARG</replaceable></term>
          <listitem>
            <para>使用<replaceable>ARG</replaceable>作为新的目标。</para>
          </listitem>
        </varlistentry>
      
        <varlistentry>
          <term><option>--no-auth-cache</option></term>
          <listitem>
            <para>阻止在Subversion管理区缓存认证信息（如用户名密码）。
            </para>
          </listitem>
        </varlistentry>
      
        <varlistentry>
          <term><option>--no-auto-props</option></term>
          <listitem>
            <para>关闭auto-props，覆盖<filename>config</filename>文件中的<literal>enable-auto-props</literal>指示。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--no-diff-added</option></term>
        <listitem>
          <para>防止Subversion打印添加文件的区别。缺省的行为方式是，当添加一个文件时，<command>svn diff</command>打印的信息和比较一个空白文件相同。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--no-diff-deleted</option></term>
        <listitem>
            <para>防止Subversion打印删除文件的区别信息，缺省的行为方式是当你删除了一个文件后运行<command>svn diff</command>打印的区别与删除文件所有的内容得到的结果一样。
           </para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><option>--no-ignore</option></term>
          <listitem>
            <para>在状态列表中显示<literal>global-ignores</literal>配置选项或者是<literal>svn:ignore</literal>属性忽略的文件。见<xref
              linkend="svn.advanced.confarea.opts.config"/>和<xref
              linkend="svn.advanced.props.special.ignore"/>查看详情。</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><option>--no-unlock</option></term>
          <listitem>
            <para>不自动解锁文件（缺省的提交行为是解锁提交列出的所有文件），更多信息见<xref 
            linkend="svn.advanced.locking"/>。
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--non-interactive</option></term>
          <listitem>
            <para>如果认证失败，或者是不充分的凭证时，防止出现要求凭证的提示（例如用户名和密码）。这在运行自动脚本时非常有用，只是让Subversion失败而不是提示更多的信息。
           </para>
          </listitem>
        </varlistentry>
      
        <varlistentry>
          <term><option>--non-recursive</option> (<option>-N</option>)</term>
          <listitem>
            <para>防止子命令迭代到子目录，大多数子命令缺省是迭代的，但是一些子命令&mdash;通常是那些潜在的删除或者是取消本地修改的命令&mdash;不是。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--notice-ancestry</option></term>
          <listitem>
            <para>在计算区别时关注祖先。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--old</option> <replaceable>ARG</replaceable></term>
          <listitem>
            <para>使用<replaceable>ARG</replaceable>作为旧的目标。</para>
          </listitem>
        </varlistentry>
      
        <varlistentry>
          <term><option>--password</option>
            <replaceable>PASS</replaceable></term>
          <listitem>
            <para>指出在命令行中提供你的密码&mdash;另外，如果它是需要的，Subversion会提示你输入。</para>
          </listitem>
        </varlistentry>
      
        <varlistentry>
          <term><option>--quiet</option> (<option>-q</option>)</term>
          <listitem>
            <para>请求客户端在执行操作时只显示重要信息。</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><option>--recursive</option> (<option>-R</option>)</term>
          <listitem>
            <para>让子命令迭代到子目录，大多数子命令缺省是迭代的。</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><option>--relocate</option> <replaceable>FROM TO
          [PATH...]</replaceable></term>
          <listitem>
            <para><command>svn switch</command>子命令中使用，用来修改你的工作拷贝所引用的版本库位置。当版本库的位置修改了，而你有一个工作拷贝，希望继续使用时非常有用。见<command>svn switch</command>的例子。
            </para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><option>--revision</option> (<option>-r</option>)
            <replaceable>REV</replaceable>
          </term>
          <listitem>
            <para>指出你将为特定操作提供一个修订版本（或修订版本的范围），你可以提供修订版本号，修订版本关键字或日期（在华括号中）作为修订版本开关的参数。如果你希望提供一个修订版本范围，你可以提供用冒号隔开的两个修订版本，举个例子：</para>

            <screen>
$ svn log -r 1729
$ svn log -r 1729:HEAD
$ svn log -r 1729:1744
$ svn log -r {2001-12-04}:{2002-02-17}
$ svn log -r 1729:{2002-02-17}
</screen>

            <para>见<xref linkend="svn.tour.revs.keywords"/>查看更多信息。</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><option>--revprop</option></term>
          <listitem>
            <para>操作是针对一个修订版本的属性而不是一个文件或目录的属性。这个开关需要你也要通过<option>--revision</option>（<option>-r</option>）传递一个修订版本号，见<xref
              linkend="svn.reposadmin.basics.revprops"/>关于未版本化的属性的细节。
              </para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><option>--show-updates</option> (<option>-u</option>)</term>
          <listitem>
            <para>导致客户端显示本地拷贝哪些文件已经过期，这不会实际更新你的任何文件&mdash;只是显示了如果你运行<command>svn update</command>时更新的文件。
            </para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><option>--stop-on-copy</option></term>
          <listitem>
            <para>导致Subversion子命令在传递历史时会在版本化资源拷贝时停止收集历史信息&mdash;也就是历史中资源从另一个位置拷贝过来时。</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><option>--strict</option></term>
          <listitem>
            <para>导致Subversion使用严格的语法，也就是选择含糊，除非谈论特定的子命令。</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><option>--targets</option>
            <replaceable>FILENAME</replaceable></term>
          <listitem>
            <para>告诉Subversion从你提供的文件中得到希望操作的文件列表，而不是在命令行列出所有的文件。
            </para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><option>--username</option>
            <replaceable>NAME</replaceable></term>
          <listitem>
            <para>表示你要在命令行提供认证的用户名&mdash;否则如果需要，Subversion会提示你这一点。</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><option>--verbose</option> (<option>-v</option>)</term>
          <listitem>
            <para>请求客户端在运行子命令打印尽量多的信息，会导致Subversion打印额外的字段，每个文件的细节信息或者是关于动作的附加信息。</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><option>--version</option></term>
          <listitem>
            <para>打印客户端版本信息，这个信息不仅仅包括客户端的版本号，也有所有客户端可以用来访问Subversion版本库的版本库访问模块列表。</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><option>--xml</option></term>
          <listitem>
            <para>使用XML格式打印输出。</para>
          </listitem>
        </varlistentry>
        
      </variablelist>
      
    </sect2>
    
    <!-- =============================================================== -->
    <sect2 id="svn.ref.svn.c">
      <title><command>svn</command>子命令</title>

      <refentry id="svn.ref.svn.c.add">
        <refnamediv>
          <refname>svn add</refname>
          <refpurpose>添加文件、目录或符号链。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title> 
          <programlisting>svn add PATH...</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>
          
          <para>添加文件、目录或符号链到你的工作拷贝并且预定添加到版本库。它们会在下次提交上传并添加到版本库，如果你在提交之前改变了主意，你可以使用<command>svn revert</command>取消预定。</para>
        </refsect1>
        
        <refsect1>
          <title>别名</title>
          <para>无</para>
        </refsect1>
        
        <refsect1>
          <title>变化</title>
          <para>工作拷贝</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>否</para>
        </refsect1>
        
        <refsect1>
          <title>选项</title>

          <screen>
--targets FILENAME
--non-recursive (-N)
--quiet (-q)
--config-dir DIR
--auto-props
--no-auto-props
--force
</screen>
        </refsect1>
        
        <refsect1>
          <title>例子</title>
          
          <para>添加一个文件到工作拷贝：</para>

          <screen>
$ svn add foo.c 
A         foo.c
</screen>

          <para>当添加一个目录，<command>svn add</command>缺省的行为方式是递归的：</para>
          
          <screen>
$ svn add testdir
A         testdir
A         testdir/a
A         testdir/b
A         testdir/c
A         testdir/d
</screen>

          <para>你可以只添加一个目录而不包括其内容：</para>
          
          <screen>
$ svn add --non-recursive otherdir
A         otherdir
</screen>

          <para>通常情况下，命令<command>svn add *</command>会忽略所有已经在版本控制之下的目录，有时候，你会希望添加所有工作拷贝的未版本化文件，包括那些隐藏在深处的文件，可以使用<command>svn
            add</command>的<option>--force</option>递归到版本化的目录下：
            </para>

          <screen>
$ svn add * --force
A         foo.c
A         somedir/bar.c
A         otherdir/docs/baz.doc
&hellip;
</screen>

        </refsect1>
      </refentry>

      <refentry id="svn.ref.svn.c.blame">
        <refnamediv>
          <refname>svn blame</refname>
          <refpurpose>显示特定文件和URL内嵌的作者和修订版本信息。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svn blame TARGET[@REV]...</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>
          
          <para>显示特定文件和URL内嵌的作者和修订版本信息。每一行文本在开头都放了最后修改的作者（用户名）和修订版本号。</para>
        </refsect1>

        <refsect1>
          <title>别名</title>
          <para>praise、annotate、ann</para>
        </refsect1>

        <refsect1>
          <title>变化</title>
          <para>无</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>是</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--revision (-r) REV
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
--verbose
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>如果你希望在测试版本库看到blame标记的<filename>readme.txt</filename>源代码：
          </para>
          <screen>
$ svn blame http://svn.red-bean.com/repos/test/readme.txt
     3      sally This is a README file.
     5      harry You should read this.
</screen>

        </refsect1>
      </refentry>

      <refentry id="svn.ref.svn.c.cat">
        <refnamediv>
          <refname>svn cat</refname>
          <refpurpose>输出特定文件或URL的内容。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svn cat TARGET[@REV]...</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>
          
          <para>输出特定文件或URL的内容。列出目录的内容可以使用<command>svn
            list</command>。
            </para>
        </refsect1>

        <refsect1>
          <title>别名</title>
          <para>无</para>
        </refsect1>

        <refsect1>
          <title>变化</title>
          <para>无</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>是</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--revision (-r) REV
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>如果你希望不检出而察看版本库的readme.txt的内容：</para>
          <screen>
$ svn cat http://svn.red-bean.com/repos/test/readme.txt
This is a README file.
You should read this.
</screen>

          <tip>
            <para>如果你的工作拷贝已经过期（或者你有本地修改），并且希望察看工作拷贝的<literal>HEAD</literal>修订版本的一个文件，如果你给定一个路径，<command>svn cat</command>会自动取得<literal>HEAD</literal>的修订版本：
           </para>
          </tip>

          <screen>
$ cat foo.c
This file is in my local working copy 
and has changes that I've made.

$ svn cat foo.c
Latest revision fresh from the repository!
</screen>
          
        </refsect1>
      </refentry>

      <refentry id="svn.ref.svn.c.checkout">
        <refnamediv>
          <refname>svn checkout</refname>
          <refpurpose>从版本库取出一个工作拷贝。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svn checkout URL[@REV]... [PATH]</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>
          
          <para>从版本库取出一个工作拷贝，如果省略<replaceable>PATH</replaceable>，URL的基名称会作为目标，如果给定多个URL，每一个都会检出到<replaceable>PATH</replaceable>的子目录，使用URL基名称的子目录名称。
         </para>

        </refsect1>

        <refsect1>
          <title>别名</title>
          <para>co</para>
        </refsect1>

        <refsect1>
          <title>变化</title>
          <para>创建一个工作拷贝。</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>是</para>
        </refsect1>

        <refsect1>
          <title>选项</title>
          
          <screen>
--revision (-r) REV
--quiet (-q)
--non-recursive (-N)
--username USER
--password PASS
--no-auth-cache
--non-interactive
--ignore-externals
--config-dir DIR
</screen>
        </refsect1>
        
        <refsect1>
          <title>例子</title>

          <para>取出一个工作拷贝到<filename>mine</filename>：</para>

          <screen>
$ svn checkout file:///tmp/repos/test mine
A  mine/a
A  mine/b
Checked out revision 2.
$ ls
mine
</screen>

          <para>检出两个目录到两个单独的工作拷贝：</para>

          <screen>
$ svn checkout file:///tmp/repos/test  file:///tmp/repos/quiz
A  test/a
A  test/b
Checked out revision 2.
A  quiz/l
A  quiz/m
Checked out revision 2.
$ ls
quiz  test
</screen>

          <para>检出两个目录到两个单独的工作拷贝，但是将两个目录都放到<filename>working-copies</filename>：
          </para>

          <screen>
$ svn checkout file:///tmp/repos/test  file:///tmp/repos/quiz working-copies
A  working-copies/test/a
A  working-copies/test/b
Checked out revision 2.
A  working-copies/quiz/l
A  working-copies/quiz/m
Checked out revision 2.
$ ls
working-copies
</screen>

         <para>如果你打断一个检出（或其它打断检出的事情，如连接失败。），你可以使用同样的命令重新开始或者是更新不完整的工作拷贝：
        </para>

          <screen>
$ svn checkout file:///tmp/repos/test test
A  test/a
A  test/b
^C
svn: The operation was interrupted
svn: caught SIGINT

$ svn checkout file:///tmp/repos/test test
A  test/c
A  test/d
^C
svn: The operation was interrupted
svn: caught SIGINT

$ cd test
$ svn update
A  test/e
A  test/f
Updated to revision 3.
</screen>

        </refsect1>
      </refentry>

      <refentry id="svn.ref.svn.c.cleanup">
        <refnamediv>
          <refname>svn cleanup</refname>
          <refpurpose>递归清理工作拷贝。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svn cleanup [PATH...]</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>递归清理工作拷贝，删除未完成的操作锁定。如果你得到一个<quote>工作拷贝已锁定</quote>的错误，运行这个命令可以删除无效的锁定，让你的工作拷贝再次回到可用的状态。
            </para>

          <para>如果，因为一些原因，运行外置的区别程序（例如，用户输入或是网络错误）有时候会导致一个<command>svn update</command>失败，使用<option>--diff3-cmd</option>选项可以完全清除你的外置区别程序所作的合并，你也可以使用<option>--config-dir</option>指定任何配置目录，但是你应该不会经常使用这些选项。</para>

        </refsect1>

        <refsect1>
          <title>别名</title>
          <para>无</para>
        </refsect1>

        <refsect1>
          <title>变化</title>
          <para>工作拷贝</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>否</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--diff3-cmd CMD
--config-dir DIR
</screen>

        </refsect1>

        <refsect1>
          <title>例子</title>

          <para><command>svn cleanup</command>没有输出，没有太多的例子，如果你没有传递<replaceable>PATH</replaceable>，会使用<quote><filename>.</filename></quote>。</para>

          <screen>
$ svn cleanup

$ svn cleanup /path/to/working-copy
</screen>

        </refsect1>
      </refentry>

      <refentry id="svn.ref.svn.c.commit">
        <refnamediv>
          <refname>svn commit</refname>
          <refpurpose>将修改从工作拷贝发送到版本库。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svn commit [PATH...]</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>将修改从工作拷贝发送到版本库。如果你没有使用<option>--file</option>或<option>--message</option>提供一个提交日志信息，<command>svn</command>会启动你的编辑器来编写一个提交信息，见<xref
            linkend="svn.advanced.confarea.opts.config"/>的<literal>editor-cmd</literal>小节。</para>

          <para><command>svn commit</command> will send found lock
            tokens and release locks on all
            <replaceable>PATHS</replaceable> committed (recursively)
            unless <option>--no-unlock</option> is passed.</para>
            
          <tip>
            <para>如果你开始一个提交并且Subversion启动了你的编辑器来编辑提交信息，你仍可以退出而不会提交你的修改，如果你希望取消你的提交，只需要退出编辑器而不保存你的提交信息，Subversion会提示你是选择取消提交、空信息继续还是重新编辑信息。</para>
          </tip>

        </refsect1>


        
        <refsect1>
          <title>别名</title>
          <para>ci（<quote>check in</quote>的缩写；不是<quote>checkout</quote>的缩写<quote>co</quote>。）</para>
        </refsect1>

        <refsect1>
          <title>变化</title>
          <para>工作拷贝，版本库</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>是</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--message (-m) TEXT
--file (-F) FILE
--quiet (-q)
--no-unlock
--non-recursive (-N)
--targets FILENAME
--force-log
--username USER
--password PASS
--no-auth-cache
--non-interactive
--encoding ENC
--config-dir DIR
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>使用命令行提交一个包含日志信息的文件修改，当前目录（<quote><filename>.</filename></quote>）是没有说明的目标路径：</para>
          
          <screen>
$ svn commit -m "added howto section."
Sending        a
Transmitting file data .
Committed revision 3.
</screen>

          <para>提交一个修改到<filename>foo.c</filename>（在命令行明确指明），并且<literal>msg</literal>文件中保存了提交信息：</para>

          <screen>
$ svn commit -F msg foo.c
Sending        foo.c
Transmitting file data .
Committed revision 5.
</screen>

          <para>如果你希望使用在<option>--file</option>选项中使用在版本控制之下的文件作为参数，你需要使用<option>--force-log</option>选项：</para>

          <screen>
$ svn commit --file file_under_vc.txt foo.c
svn: The log message file is under version control
svn: Log message file is a versioned file; use '--force-log' to override

$ svn commit --force-log --file file_under_vc.txt foo.c
Sending        foo.c
Transmitting file data .
Committed revision 6.
</screen>

          <para>提交一个已经预定要删除的文件：</para>

          <screen>
$ svn commit -m "removed file 'c'."
Deleting       c

Committed revision 7.
</screen>
          
        </refsect1>
      </refentry>

      <refentry id="svn.ref.svn.c.copy">
        <refnamediv>
          <refname>svn copy</refname>
          <refpurpose>拷贝工作拷贝的一个文件或目录到版本库。</refpurpose>
        </refnamediv>

        <refsect1>
          <title>概要</title>
          <programlisting>svn copy SRC DST</programlisting>
        </refsect1>

        <refsect1>
          <title>描述</title>
          
          <para>拷贝工作拷贝的一个文件或目录到版本库。<replaceable>SRC</replaceable>和<replaceable>DST</replaceable>既可以是工作拷贝（WC）路径也可以是URL：</para>
            
            <variablelist>

              <varlistentry>
                <term>WC  -&gt; WC</term>
                <listitem>
                  <para>拷贝并且预定一个添加的项目（包含历史）。</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>WC  -&gt; URL</term>
                <listitem>
                  <para>将WC或URL的拷贝立即提交。</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>URL -&gt; WC</term>
                <listitem>
                  <para>检出URL到WC，并且加入到添加计划。</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>URL -&gt; URL</term>
                <listitem>
                  <para>完全的服务器端拷贝，通常用在分支和标签。</para>
                </listitem>
              </varlistentry>

            </variablelist>

          <note>
            <para>你只可以在单个版本库中拷贝文件，Subversion还不支持跨版本库的拷贝。</para>
          </note>

        </refsect1>

        <refsect1>
          <title>别名</title>
          <para>cp</para>
        </refsect1>

        <refsect1>
          <title>变化</title>
          <para>如果目标是URL则包括版本库。</para>
          <para>如果目标是WC路径，则是工作拷贝。</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>如果目标是版本库，或者需要查看修订版本号，则会访问版本库。</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--message (-m) TEXT
--file (-F) FILE
--revision (-r) REV
--quiet (-q)
--username USER
--password PASS
--no-auth-cache
--non-interactive
--force-log
--editor-cmd EDITOR
--encoding ENC
--config-dir DIR
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>拷贝工作拷贝的一个项目（只是预定要拷贝&mdash;在提交之前不会影响版本库）：</para>

          <screen>
$ svn copy foo.txt bar.txt
A         bar.txt
$ svn status
A  +   bar.txt
</screen>

          <para>拷贝你的工作拷贝的一个项目到版本库的URL（直接的提交，所以需要提供一个提交信息）：</para>

          <screen>
$ svn copy near.txt file:///tmp/repos/test/far-away.txt -m "Remote copy."

Committed revision 8.
</screen>

          <para>拷贝版本库的一个项目到你的工作拷贝（只是预定要拷贝&mdash;在提交之前不会影响版本库）：</para>

          <tip>
            <para>这是恢复死掉文件的推荐方式！</para>
          </tip>

          <screen>
$ svn copy file:///tmp/repos/test/far-away near-here
A         near-here
</screen>

          <para>最后，是在URL之间拷贝：</para>

          <screen>
$ svn copy file:///tmp/repos/test/far-away file:///tmp/repos/test/over-there -m "remote copy."

Committed revision 9.
</screen>

          <tip>
            <para>这是在版本库里作<quote>标签</quote>最简单的方法&mdash;<command>svn
              copy</command>那个修订版本（通常是<literal>HEAD</literal>）到你的tags目录。</para>
          </tip>

          <screen>
$ svn copy file:///tmp/repos/test/trunk file:///tmp/repos/test/tags/0.6.32-prerelease -m "tag tree"

Committed revision 12.
</screen>

          <para>不要担心忘记作标签&mdash;你可以在以后任何时候给一个旧版本作标签：</para>

          <screen>
$ svn copy -r 11 file:///tmp/repos/test/trunk file:///tmp/repos/test/tags/0.6.32-prerelease -m "Forgot to tag at rev 11"

Committed revision 13.
</screen>
        </refsect1>
      </refentry>

      <refentry id="svn.ref.svn.c.delete">
        <refnamediv>
          <refname>svn delete</refname>
          <refpurpose>从工作拷贝或版本库删除一个项目。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svn delete PATH...</programlisting>
          <programlisting>svn delete URL...</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para><replaceable>PATH</replaceable>指定的项目会在下次提交删除，文件（和没有提交的目录）会立即从版本库删除，这个命令不会删除任何未版本化或已经修改的项目；使用<option>--force</option>选项可以覆盖这种行为方式。</para>

          <para>URL指定的项目会在直接提交中从版本库删除，多个URL的提交是原子操作。</para>
        </refsect1>

        <refsect1>
          <title>别名</title>
          <para>del, remove, rm</para>
        </refsect1>

        <refsect1>
          <title>变化</title>
          <para>如果操作对象是文件则是工作拷贝变化，对象是URL则会影响版本库。</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>对URL操作时访问</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--force
--force-log
--message (-m) TEXT
--file (-F) FILE
--quiet (-q)
--targets FILENAME
--username USER
--password PASS
--no-auth-cache
--non-interactive
--editor-cmd EDITOR
--encoding ENC
--config-dir DIR
</screen>
        </refsect1>
        
        <refsect1>
          <title>例子</title>

          <para>使用<command>svn</command>从工作拷贝删除文件只是预定要删除，当你提交，文件才会从版本库删除。</para>

          <screen>
$ svn delete myfile
D         myfile

$ svn commit -m "Deleted file 'myfile'."
Deleting       myfile
Transmitting file data .
Committed revision 14.
</screen>

          <para>然而直接删除一个URL，你需要提供一个日志信息：</para>

          <screen>
$ svn delete -m "Deleting file 'yourfile'" file:///tmp/repos/test/yourfile

Committed revision 15.
</screen>

          <para>如下是强制删除本地已修改文件的例子：</para>

          <screen>
$ svn delete over-there 
svn: Attempting restricted operation for modified resource
svn: Use --force to override this restriction
svn: 'over-there' has local modifications

$ svn delete --force over-there 
D         over-there
</screen>
          
        </refsect1>
      </refentry>

      <refentry id="svn.ref.svn.c.diff">
        <refnamediv>
          <refname>svn diff</refname>
          <refpurpose>比较两条路径的区别。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>diff [-r N[:M]] [TARGET[@REV]...]</programlisting>
          <programlisting>diff [-r N[:M]] --old OLD-TGT[@OLDREV] [--new NEW-TGT[@NEWREV]] [PATH...]</programlisting>
          <programlisting>diff OLD-URL[@OLDREV] NEW-URL[@NEWREV]</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>显示两条路径的区别，<command>svn diff</command>有三种使用方式：</para>

          <para><command>svn diff [-r N[:M]] [--old OLD-TGT] [--new
            NEW-TGT] [PATH...]</command>会显示<replaceable>OLD-TGT</replaceable>和<replaceable>NEW-TGT</replaceable>的区别。如果给定路径<replaceable>PATH</replaceable>，它会被看作<replaceable>OLD-TGT</replaceable>和<replaceable>NEW-TGT</replaceable>的相对路径，输出也会限制在这些路径的区别上。<replaceable>OLD-TGT</replaceable>和<replaceable>NEW-TGT</replaceable>可以是工作拷贝路径或者是<replaceable>URL</replaceable><literal>[@</literal><replaceable>REV</replaceable><literal>]</literal>。<replaceable>OLD-TGT</replaceable>缺省是当前工作目录，而<replaceable>NEW-TGT</replaceable>缺省是<replaceable>OLD-TGT</replaceable>。<replaceable>N</replaceable>缺省是<literal>BASE</literal>，<replaceable>M</replaceable>缺省时当前目录的版本，但如果<replaceable>NEW-TGT</replaceable>是一个URL，则默认是<literal>HEAD</literal>。<command>svn diff -r N</command>设置<replaceable>OLD-TGT</replaceable>的修订版本为<replaceable>N</replaceable>，<command>svn diff -r
            N:M</command>设置<replaceable>NEW-TGT</replaceable>的修订版本是<replaceable>M</replaceable>。</para>

          <para><command>svn diff [-r N[:M]] URL1[@N]
            URL2[@M]</command>是<command>svn diff [-r
            N[:M]] --old=URL1 --new=URL2</command>的缩写。
          </para>

          <para><replaceable>TARGET</replaceable>是一个URL，然后可以使用前面提到的<option>--revision</option>或<quote>@</quote>符号来指定N和M。
          </para>

          <para>如果<replaceable>TARGET</replaceable>是工作拷贝路径，则<option>--revision</option>选项的含义是：
          </para>

          <variablelist>

            <varlistentry>
              <term><option>--revision N:M</option></term>
              <listitem>
                <para>服务器比较
                  <replaceable>TARGET</replaceable>@<replaceable>N</replaceable>和<replaceable>TARGET</replaceable>@<replaceable>M</replaceable>。</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><option>--revision N</option></term>
              <listitem>
                <para>客户端比较<replaceable>TARGET</replaceable>@<replaceable>N</replaceable>和工作拷贝。</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>（无<option>--revision</option>）</term>
              <listitem>
                <para>客户端比较base和 <replaceable>TARGET</replaceable>的<replaceable>TARGET</replaceable>。</para>
              </listitem>
            </varlistentry>

          </variablelist>

          <para>如果使用其他语法，服务器会比较<replaceable>URL1</replaceable>和<replaceable>URL2</replaceable>各自的<replaceable>N</replaceable>和<replaceable>M</replaceable>。如果省掉<replaceable>N</replaceable>或<replaceable>M</replaceable>，会假定为<literal>HEAD</literal>。</para>

          <para>缺省情况下，<command>svn diff</command>忽略文件的祖先，只会比较两个文件的内容。如果你使用<option>--notice-ancestry</option>，比较修订版本（也就是，当你运行<command>svn
            diff</command>比较两个内容相同，但祖先历史不同的对象会看到所有的内容被删除又再次添加）时就会考虑路径的祖先。
           </para>

        </refsect1>
        <refsect1>
          <title>别名</title>
          <para>di</para>
        </refsect1>

        <refsect1>
          <title>变化</title>
          <para>无</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>获得工作拷贝非<literal>BASE</literal>修订版本的区别时会</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--revision (-r) REV
--old OLD-TARGET
--new NEW-TARGET
--extensions (-x) "ARGS"
--non-recursive (-N)
--diff-cmd CMD
--notice-ancestry
--username USER
--password PASS
--no-auth-cache
--non-interactive
--no-diff-deleted
--config-dir DIR
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>比较<literal>BASE</literal>和你的工作拷贝（<command>svn
            diff</command>最经常的用法）：</para>

          <screen>
$ svn diff COMMITTERS 
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 4404)
+++ COMMITTERS	(working copy)
</screen>

          <para>察看你的工作拷贝对旧的修订版本的修改：</para>

          <screen>
$ svn diff -r 3900 COMMITTERS 
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3900)
+++ COMMITTERS	(working copy)
</screen>

          <para>使用<quote>@</quote>语法与修订版本3000和35000比较：</para>

          <screen>
$ svn diff http://svn.collab.net/repos/svn/trunk/COMMITTERS@3000 \
http://svn.collab.net/repos/svn/trunk/COMMITTERS@3500
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3000)
+++ COMMITTERS	(revision 3500)
&hellip;
</screen>

          <para>使用范围符号来比较修订版本3000和3500（在这种情况下只能传递一个URL）：
</para>

          <screen>
$ svn diff -r 3000:3500 http://svn.collab.net/repos/svn/trunk/COMMITTERS
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3000)
+++ COMMITTERS	(revision 3500)
</screen>


          <para>使用范围符号比较修订版本3000和3500<filename>trunk</filename>中的所有文件：</para>

          <screen>
$ svn diff -r 3000:3500 http://svn.collab.net/repos/svn/trunk
          </screen>


          <para>使用范围符号比较修订版本3000和3500<filename>trunk</filename>中的三个文件：</para>

          <screen>
$ svn diff -r 3000:3500 --old http://svn.collab.net/repos/svn/trunk COMMITTERS README HACKING
          </screen>

          <para>如果你有工作拷贝，你不必输入这么长的URL：</para>

          <screen>
$ svn diff -r 3000:3500 COMMITTERS 
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3000)
+++ COMMITTERS	(revision 3500)
</screen>

          <para>使用<option>--diff-cmd</option>
            <replaceable>CMD</replaceable> <option>-x</option>来指定外部区别程序</para>
          
          <screen>
$ svn diff --diff-cmd /usr/bin/diff -x "-i -b" COMMITTERS 
Index: COMMITTERS
===================================================================
0a1,2
&gt; This is a test
&gt; 
</screen>
          
        </refsect1>
      </refentry>

      <refentry id="svn.ref.svn.c.export">
        <refnamediv>
          <refname>svn export</refname>
          <refpurpose>导出一个干净的目录树。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svn export [-r REV] URL[@PEGREV] [PATH]</programlisting>
          <programlisting>svn export [-r REV] PATH1[@PEGREV] [PATH2]</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>第一种从版本库导出干净工作目录树的形式是指定URL，如果指定了修订版本<replaceable>REV</replaceable>，会导出相应的版本，如果没有指定修订版本，则会导出<literal>HEAD</literal>，导出到<replaceable>PATH</replaceable>。如果省略<replaceable>PATH</replaceable>，<replaceable>URL</replaceable>的最后一部分会作为本地目录的名字。</para>

          <para>从工作拷贝导出干净目录树的第二种形式是指定<replaceable>PATH1</replaceable>到<replaceable>PATH2</replaceable>，所有的本地修改将会保留，但是不再版本控制下的文件不会拷贝。</para>
        </refsect1>

        <refsect1>
          <title>别名</title>
          <para>无</para>
        </refsect1>

        <refsect1>
          <title>变化</title>
          <para>本地磁盘</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>只有当从URL导出时会访问</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--revision (-r) REV
--quiet (-q)
--force
--username USER
--password PASS
--no-auth-cache
--non-interactive
--non-recursive
--config-dir DIR
--native-eol EOL
--ignore-externals
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>从你的工作拷贝导出（不会打印每一个文件和目录）：</para>

          <screen>
$ svn export a-wc my-export
Export complete.
</screen>

          <para>从版本库导出目录（打印所有的文件和目录）：</para>

          <screen>
$ svn export file:///tmp/repos my-export
A  my-export/test
A  my-export/quiz
&hellip;
Exported revision 15.
</screen>

          <para>当使用操作系统特定的分发版本，使用特定的EOL字符作为行结束符号导出一棵树会非常有用。<option>--native-eol</option>选项会这样做，但是如果影响的文件拥有<literal>svn:eol-style =
            native</literal>属性，举个例子，导出一棵使用CRLF作为行结束的树（可能是为了做一个Windows的.zip文件分发版本）：</para>

          <screen>
$ svn export file://tmp/repos my-export --native-eol CRLF
A  my-export/test
A  my-export/quiz
&hellip;
Exported revision 15.
</screen>

        </refsect1>
      </refentry>

      <refentry id="svn.ref.svn.c.help">
        <refnamediv>
          <refname>svn help</refname>
          <refpurpose>帮助！</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svn help [SUBCOMMAND...]</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>当手边没有这本书时，这是你使用Subversion最好的朋友！</para>
        </refsect1>
        
        <refsect1>
          <title>别名</title>
          <para>?, h</para>
        </refsect1>

        <refsect1>
          <title>变化</title>
          <para>无</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>不访问</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--version
--quiet (-q)
</screen>
        </refsect1>
      </refentry>

      <refentry id="svn.ref.svn.c.import">
        <refnamediv>
          <refname>svn import</refname>
          <refpurpose>递归提交一个路径的拷贝到版本库。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svn import [PATH] URL</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>递归提交一个路径的拷贝到URL。如果省略<replaceable>PATH</replaceable>，默认是<quote><filename>.</filename></quote>。版本库中对应的父目录必须已经创建。</para>
        </refsect1>

        <refsect1>
          <title>别名</title>
          <para>无</para>
        </refsect1>

        <refsect1>
          <title>变化</title>
          <para>版本库</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>是</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--message (-m) TEXT
--file (-F) FILE
--quiet (-q)
--non-recursive (-N)
--username USER
--password PASS
--no-auth-cache
--non-interactive
--force-log
--editor-cmd EDITOR
--encoding ENC
--config-dir DIR
--auto-props
--no-auto-props
--ignore-externals
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>这会导入本地目录<filename>myproj</filename>到版本库的 根目录：</para>

          <screen>
$ svn import -m "New import" myproj http://svn.red-bean.com/repos/test
Adding         myproj/sample.txt
&hellip;
Transmitting file data .........
Committed revision 16.
</screen>

          <para>这将本地目录<filename>myproj</filename>导入到版本库的<filename>trunk/misc</filename>，<filename>trunk/misc</filename>在导入之前不需要存在&mdash;<command>svn import</command>会递归的为你创建目录：</para>
          <screen>
$ svn import -m "New import" myproj \
    http://svn.red-bean.com/repos/test/trunk/misc/myproj
Adding         myproj/sample.txt
&hellip;
Transmitting file data .........
Committed revision 19.
</screen>

          <para>在导入数据之后，你会发现原先的目录树<emphasis>并没有</emphasis>纳入版本控制，为了开始工作，你还是要运行<command>svn checkout</command>得到一个干净的目录树工作拷贝。</para>
          
        </refsect1>
      </refentry>

      <refentry id="svn.ref.svn.c.info">
        <refnamediv>
          <refname>svn info</refname>
          <refpurpose>显示本地或远程条目的信息。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svn info [TARGET...]</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>打印你的工作拷贝路径和URL的信息，包括：</para>

          <itemizedlist>
            <listitem><para>路经</para></listitem>
            <listitem><para>名称</para></listitem>
            <listitem><para>URL</para></listitem>
            <listitem><para>修订版本</para></listitem>
            <listitem><para>版本库的根</para></listitem>
            <listitem><para>版本库的UUID</para></listitem>
            <listitem><para>节点类型</para></listitem>
            <listitem><para>最后修改的作者</para></listitem>
            <listitem><para>最后修改的修订版本</para></listitem>
            <listitem><para>最后修改的日期</para></listitem>
            <listitem><para>最后更新的文本</para></listitem>
            <listitem><para>最后更新的属性</para></listitem>
            <listitem><para>核对</para></listitem>
            <listitem><para>锁定令牌</para></listitem>
            <listitem><para>锁定拥有者</para></listitem>
            <listitem><para>锁定创建时间</para></listitem>
          </itemizedlist>
        </refsect1>

        <refsect1>
          <title>别名</title>
          <para>无</para>
        </refsect1>

        <refsect1>
          <title>变化</title>
          <para>无</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>对URL操作时访问</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--targets FILENAME
--recursive (-R)
--revision (-r)
--config-dir DIR
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para><command>svn info</command>会展示所有项目的所有有用信息，它会显示文件的信息：</para>

          <screen>
$ svn info foo.c
Path: foo.c
Name: foo.c
URL: http://svn.red-bean.com/repos/test/foo.c
Repository Root: http://svn.red-bean.com/repos/test
Repository UUID: 5e7d134a-54fb-0310-bd04-b611643e5c25
Revision: 4417
Node Kind: file
Schedule: normal
Last Changed Author: sally
Last Changed Rev: 20
Last Changed Date: 2003-01-13 16:43:13 -0600 (Mon, 13 Jan 2003)
Text Last Updated: 2003-01-16 21:18:16 -0600 (Thu, 16 Jan 2003)
Properties Last Updated: 2003-01-13 21:50:19 -0600 (Mon, 13 Jan 2003)
Checksum: /3L38YwzhT93BWvgpdF6Zw==
</screen>

          <para>它也会展示目录的信息：</para>

          <screen>
$ svn info vendors
Path: vendors
URL: http://svn.red-bean.com/repos/test/vendors
Repository Root: http://svn.red-bean.com/repos/test
Repository UUID: 5e7d134a-54fb-0310-bd04-b611643e5c25
Revision: 19
Node Kind: directory
Schedule: normal
Last Changed Author: harry
Last Changed Rev: 19
Last Changed Date: 2003-01-16 23:21:19 -0600 (Thu, 16 Jan 2003)
</screen>


           <para><command>svn info</command> also acts on URLs (also
             note that the file readme.doc in this example is locked,
             so lock information is also provided):</para>

           <screen>
$ svn info http://svn.red-bean.com/repos/test/readme.doc
Path: readme.doc
Name: readme.doc
URL: http://svn.red-bean.com/repos/test/readme.doc
Repository Root: http://svn.red-bean.com/repos/test
Repository UUID: 5e7d134a-54fb-0310-bd04-b611643e5c25
Revision: 1
Node Kind: file
Schedule: normal
Last Changed Author: sally
Last Changed Rev: 42
Last Changed Date: 2003-01-14 23:21:19 -0600 (Tue, 14 Jan 2003)
Text Last Updated: 2003-01-14 23:21:19 -0600 (Tue, 14 Jan 2003)
Checksum: d41d8cd98f00b204e9800998ecf8427e
Lock Token: opaquelocktoken:14011d4b-54fb-0310-8541-dbd16bd471b2
Lock Owner: harry
Lock Created: 2003-01-15 17:35:12 -0600 (Wed, 15 Jan 2003)
</screen>

          
        </refsect1>
      </refentry>

      <refentry id="svn.ref.svn.c.list">
        <refnamediv>
          <refname>svn list</refname>
          <refpurpose>列出版本库目录的条目。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svn list [TARGET[@REV]...]</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>列出每一个<replaceable>TARGET</replaceable>文件和<replaceable>TARGET</replaceable>目录的内容，如果<replaceable>TARGET</replaceable>是工作拷贝路径，会使用对应的版本库URL。
         </para>

          <para>缺省的<replaceable>TARGET</replaceable>是<quote><filename>.</filename></quote>，意味着当前工作拷贝的版本库URL。</para>

          <para>伴随<option>--verbose</option>，如下的字段展示了项目的状态：</para>

          <itemizedlist>
            <listitem><para>最后一次提交的修订版本号</para></listitem> <listitem><para>最后一次提交的作者</para></listitem> <listitem><para>大小（单位字节）</para></listitem> <listitem><para>最后提交的日期时间</para></listitem>
          </itemizedlist>

          <para>使用选项<option>--xml</option>，输出是XML格式（如果没有指定<option>--incremental</option>，会包括一个头和一个围绕的元素）。会展示所有的信息；不接受<option>--verbose</option>选项。</para>
        </refsect1>

        <refsect1>
          <title>别名</title>
          <para>ls</para>
        </refsect1>

        <refsect1>
          <title>变化</title>
          <para>无</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>是</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--revision (-r) REV
--verbose (-v)
--recursive (-R)
--incremental
--xml
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>如果你希望在没有下载工作拷贝时察看版本库有哪些文件，<command>svn list</command>会非常有用：</para>

          <screen>
$ svn list http://svn.red-bean.com/repos/test/support
README.txt
INSTALL
examples/
&hellip;
</screen>

          <para>你也可以传递<option>--verbose</option>选项来得到额外信息，非常类似UNIX的<command>ls -l</command>命令：</para>

          <screen>
$ svn list --verbose file:///tmp/repos
     16 sally         28361 Jan 16 23:18 README.txt
     27 sally             0 Jan 18 15:27 INSTALL
     24 harry               Jan 18 11:27 examples/
</screen>

          <para>更多细节见<xref
            linkend="svn.tour.history.list"/>。</para>

        </refsect1>
      </refentry>


      <refentry id="svn.ref.svn.c.lock">
        <refnamediv>
          <refname>svn lock</refname> 
            <refpurpose>锁定版本库的工作拷贝路径或URL，所以没有其他用户可以提交这些文件的修改。
            </refpurpose>
        </refnamediv>
        <refsect1>
          <title>Synopsis</title>
          <programlisting>svn lock TARGET...</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>锁定每个<replaceable>TARGET</replaceable>。如果任何<replaceable>TARGET</replaceable>已经被另一个用户锁定，则会打印警告信息并且继续锁定剩下的<replaceable>TARGET</replaceable>。可以使用<option>--force</option>从其它用户来窃取锁定。
         </para>

        </refsect1>

        <refsect1>
          <title>别名</title>
          <para>无</para>
        </refsect1>

        <refsect1>
          <title>变化</title>
          <para>工作拷贝，版本库</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>是</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--targets ARG
--message (-m) ARG
--file (-F) ARG
--force-log
--encoding ARG
--username ARG
--password ARG
--no-auth-cache
--non-interactive
--config-dir ARG
--force
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>在工作拷贝锁定两个文件：</para>

          <screen>

$ svn lock tree.jpg house.jpg
'tree.jpg' locked by user 'harry'.
'house.jpg' locked by user 'harry'.
</screen>

          <para>锁定工作拷贝的一个被其它用户锁定的文件：</para>

          <screen>
$ svn lock tree.jpg
svn: warning: Path '/tree.jpg is already locked by user 'harry in \
     filesystem '/svn/repos/db'

$ svn lock --force foo
'tree.jpg' locked by user 'sally'.
</screen>

          <para>没有工作拷贝的情况下锁定文件：</para>

          <screen>
$ svn lock http://svn.red-bean.com/repos/test/tree.jpg
'tree.jpg' locked by user 'sally'.
</screen>

          <para>更多细节见<xref
            linkend="svn.advanced.locking"/>。</para>

        </refsect1>
      </refentry>


      <refentry id="svn.ref.svn.c.log">
        <refnamediv>
          <refname>svn log</refname>
          <refpurpose>显示提交日志信息。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svn log [PATH]</programlisting>
          <programlisting>svn log URL [PATH...]</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>缺省目标是你的当前目录的路径，如果没有提供参数，<command>svn
            log</command>会显示当前目录下的所有文件和目录的日志信息，你可以通过指定路径来精炼结果，一个或多个修订版本，或者是任何两个的组合。对于本地路径的缺省修订版本范围<literal>BASE:1</literal>。
           </para>

          <para>如果你只是指定一个URL，就会打印这个URL上所有的日志信息，如果添加部分路径，只有这条路径下的URL信息会被打印，URL缺省的修订版本范围是<literal>HEAD:1</literal>。</para>

          <para><command>svn log</command>使用<option>--verbose</option>选项也会打印所有影响路径的日志信息，使用<option>--quiet</option>选项不会打印日志信息正文本身（这与<option>--verbose</option>协调一致）。</para>

          <para>每个日志信息只会打印一次，即使是那些明确请求不止一次的路径，日志会跟随在拷贝过程中，使用<option>--stop-on-copy</option>可以关闭这个特性，可以用来监测分支点。</para>

        </refsect1>
        <refsect1>
          <title>别名</title>
          <para>无</para>
        </refsect1>

        <refsect1>
          <title>变化</title>
          <para>无</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>是</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--revision (-r) REV
--quiet (-q)
--verbose (-v)
--targets FILENAME
--stop-on-copy
--incremental
--limit NUM
--xml
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>你可以在顶级目录运行<command>svn
            log</command>看到工作拷贝中所有修改的路径的日志信息：</para>

          <screen>
$ svn log
------------------------------------------------------------------------
r20 | harry | 2003-01-17 22:56:19 -0600 (Fri, 17 Jan 2003) | 1 line

Tweak.
------------------------------------------------------------------------
r17 | sally | 2003-01-16 23:21:19 -0600 (Thu, 16 Jan 2003) | 2 lines
&hellip;
</screen>

          <para>检验一个特定文件所有的日志信息：</para>

          <screen>
$ svn log foo.c
------------------------------------------------------------------------
r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line

Added defines.
------------------------------------------------------------------------
r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines
&hellip;
</screen>

          <para>如果你手边没有工作拷贝，你可以查看一个URL的日志：</para>

          <screen>
$ svn log http://svn.red-bean.com/repos/test/foo.c
------------------------------------------------------------------------
r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line

Added defines.
------------------------------------------------------------------------
r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines
&hellip;
</screen>

          <para>如果你希望查看某个URL下面不同的多个路径，你可以使用<literal>URL [PATH...]</literal>语法。
          </para>

          <screen>
$ svn log http://svn.red-bean.com/repos/test/ foo.c bar.c
------------------------------------------------------------------------
r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line

Added defines.
------------------------------------------------------------------------
r31 | harry | 2003-01-10 12:25:08 -0600 (Fri, 10 Jan 2003) | 1 line

Added new file bar.c
------------------------------------------------------------------------
r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines
&hellip;
</screen>

          <para>当你想¿接多个队日志命令的调用结果，你会希望使用<option>--incremental</option>选项。<command>svn
            log</command>通常会在日志信息的开头和每一小段间打印一行虚线，如果你对一段修订版本运行<command>svn log</command>，你会得到下面的结果：</para>
          <screen>
$ svn log -r 14:15
------------------------------------------------------------------------
r14 | ... 

------------------------------------------------------------------------
r15 | ... 

------------------------------------------------------------------------
</screen>

          <para>然而，如果你希望收集两个不连续的日志信息到一个文件，你会这样做：
          </para>

          <screen>
$ svn log -r 14 &gt; mylog
$ svn log -r 19 &gt;&gt; mylog
$ svn log -r 27 &gt;&gt; mylog
$ cat mylog
------------------------------------------------------------------------
r14 | ... 

------------------------------------------------------------------------
------------------------------------------------------------------------
r19 | ... 

------------------------------------------------------------------------
------------------------------------------------------------------------
r27 | ... 

------------------------------------------------------------------------
</screen>

          <para>你可以使用incremental选项来避免两行虚线带来的混乱：</para>


          <screen>
$ svn log --incremental -r 14 &gt; mylog
$ svn log --incremental -r 19 &gt;&gt; mylog
$ svn log --incremental -r 27 &gt;&gt; mylog
$ cat mylog
------------------------------------------------------------------------
r14 | ... 

------------------------------------------------------------------------
r19 | ... 

------------------------------------------------------------------------
r27 | ... 
</screen>

          <para><option>--incremental</option>选项为<option>--xml</option>提供了一个相似的输出控制。
          </para>



          <tip>
            <para>如果你在特定路径和修订版本运行<command>svn log</command>，输出结果为空</para>

            <screen>
$ svn log -r 20 http://svn.red-bean.com/untouched.txt
------------------------------------------------------------------------
</screen>

            <para>这只意味着这条路径在那个修订版本没有修改，如果从版本库的顶级目录运行这个命令，或者是你知道那个修订版本修改了那个文件，你可以明确的指定它：</para>
            
            <screen>
$ svn log -r 20 touched.txt 
------------------------------------------------------------------------
r20 | sally | 2003-01-17 22:56:19 -0600 (Fri, 17 Jan 2003) | 1 line

Made a change.
------------------------------------------------------------------------
</screen>
          </tip>

        </refsect1>
      </refentry>

      <refentry id="svn.ref.svn.c.merge">
        <refnamediv>
          <refname>svn merge</refname>
          <refpurpose>应用两组源文件的差别到工作拷贝路径。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svn merge sourceURL1[@N] sourceURL2[@M] [WCPATH]</programlisting>
          <programlisting>svn merge sourceWCPATH1@N sourceWCPATH2@M [WCPATH]</programlisting>
          <programlisting>svn merge -r N:M SOURCE[@REV] [WCPATH]</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>第一种和第二种形式里，源路径（第一种是URL，第二种是工作拷贝路径）用修订版本号<replaceable>N</replaceable>和<replaceable>M</replaceable>指定，这是要比较的两组源文件，如果省略修订版本号，缺省是<literal>HEAD</literal>。
         </para>

          <para>第三种形式，<replaceable>SOURCE</replaceable>可以是URL或者工作拷贝项目，与之对应的URL会被使用。在修订版本号<replaceable>N</replaceable>和<replaceable>M</replaceable>的URL定义了要比较的两组源。</para>

          <para><replaceable>WCPATH</replaceable>是接收变化的工作拷贝路径，如果省略<replaceable>WCPATH</replaceable>，会假定缺省值<quote><filename>.</filename></quote>，除非源有相同基本名称与<quote><filename>.</filename></quote>中的某一文件名字匹配：在这种情况下，区别会应用到那个文件。
         </para>

          <para>不像<command>svn diff</command>，合并操作在执行时会考虑文件的祖先，当你从一个分支合并到另一个分支，而这两个分支有各自重命名的文件时，这一点会非常重要。
          </para>

        </refsect1>
        <refsect1>
          <title>别名</title>
          <para>无</para>
        </refsect1>

        <refsect1>
          <title>变化</title>
          <para>工作拷贝</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>只有在对URL操作时会</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--revision (-r) REV
--non-recursive (-N)
--quiet (-q)
--force
--dry-run
--diff3-cmd CMD
--ignore-ancestry
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>将一个分支合并回主干（假定你有一份主干的工作拷贝，分支在修订版本250创建）：</para>

          <screen>
$ svn merge -r 250:HEAD http://svn.red-bean.com/repos/branches/my-branch
U  myproj/tiny.txt
U  myproj/thhgttg.txt
U  myproj/win.txt
U  myproj/flo.txt
</screen>

          <para>如果你的分支在修订版本23，你希望将主干的修改合并到分支，你可以在你的工作拷贝的分支上这样做：
         </para>

          <screen>
$ svn merge -r 23:30 file:///tmp/repos/trunk/vendors
U  myproj/thhgttg.txt
&hellip;
</screen>
          
        <para>合并一个单独文件的修改：</para>

        <screen>
$ cd myproj
$ svn merge -r 30:31 thhgttg.txt 
U  thhgttg.txt
</screen>

        </refsect1>
      </refentry>

      <refentry id="svn.ref.svn.c.mkdir">
        <refnamediv>
          <refname>svn mkdir</refname>
          <refpurpose>创建一个纳入版本控制的新目录。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svn mkdir PATH...</programlisting>
          <programlisting>svn mkdir URL...</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>创建一个目录，名字是提供的<replaceable>PATH</replaceable>或者URL的最后一部分，工作拷贝<replaceable>PATH</replaceable>指定的目录会预定要添加，而通过URL指定的目录会作为一次立即提交在版本库建立。多个目录URL的提交是原子操作，在两种情况下，中介目录必须已经存在。
         </para>
        </refsect1>

        <refsect1>
          <title>别名</title>
          <para>无</para>
        </refsect1>

        <refsect1>
          <title>变化</title>
          <para>如果是对URL操作则会影响版本库，否则是工作拷贝</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>只有在对URl操作时会</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--message (-m) TEXT
--file (-F) FILE
--quiet (-q)
--username USER
--password PASS
--no-auth-cache
--non-interactive
--editor-cmd EDITOR
--encoding ENC
--force-log
--config-dir DIR
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>在工作拷贝创建一个目录：</para>

          <screen>
$ svn mkdir newdir
A         newdir
</screen>

          <para>在版本库创建一个目录（立即提交，所以需要日志信息）：
          </para>

          <screen>
$ svn mkdir -m "Making a new dir." http://svn.red-bean.com/repos/newdir

Committed revision 26.
</screen>
          
        </refsect1>
      </refentry>

      <refentry id="svn.ref.svn.c.move">
        <refnamediv>
          <refname>svn move</refname>
          <refpurpose>移动一个文件或目录。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svn move SRC DST</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>这个命令移动文件或目录到你的工作拷贝或者是版本库。
          </para>

          <tip>
            <para>这个命令同<command>svn
              copy</command>加一个<command>svn
              delete</command>等同。
              </para>
          </tip>

          <note>
            <para>Subversion不支持在工作拷贝和URL之间拷贝，此外，你只可以一个版本库内移动文件&mdash;Subversion不支持跨版本库的移动。</para>
          </note>

          <variablelist>

            <varlistentry>
              <term>WC  -&gt; WC</term>
              <listitem>
                <para>移动和预订一个文件或目录将要添加（包含历史）。
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>URL -&gt; URL</term>
              <listitem>
                <para>完全服务器端的重命名。</para>
              </listitem>
            </varlistentry>

          </variablelist>
        </refsect1>

        <refsect1>
          <title>别名</title>
          <para>mv, rename, ren</para>
        </refsect1>

        <refsect1>
          <title>变化</title>
          <para>如果对URL操作会影响版本库，否则只影响工作拷贝</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>只有在对URL操作时会</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--message (-m) TEXT
--file (-F) FILE
--revision (-r) REV
--quiet (-q)
--force
--username USER
--password PASS
--no-auth-cache
--non-interactive
--editor-cmd EDITOR
--encoding ENC
--force-log
--config-dir DIR
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>移动工作拷bede一个文件：</para>

          <screen>
$ svn move foo.c bar.c
A         bar.c
D         foo.c
</screen>

          <para>移动版本库中的一个文件（一个立即提交，所以需要提交信息）：
          </para>

          <screen>
$ svn move -m "Move a file" http://svn.red-bean.com/repos/foo.c \
                            http://svn.red-bean.com/repos/bar.c

Committed revision 27.
</screen>

        </refsect1>
      </refentry>

      <refentry id="svn.ref.svn.c.propdel">
        <refnamediv>
          <refname>svn propdel</refname>
          <refpurpose>删除一个项目的一个属性。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svn propdel PROPNAME [PATH...]</programlisting>
          <programlisting>svn propdel PROPNAME --revprop -r REV [URL]</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>这会删除文件、目录或修订版本的属性。第一种形式是在工作拷贝删除版本化属性，第二种是在一个版本库修订版本中删除未版本化的属性。</para>
        </refsect1>

        <refsect1>
          <title>别名</title>
          <para>pdel, pd</para>
        </refsect1>

        <refsect1>
          <title>变化</title>
          <para>如果对URL操作会影响版本库，否则只影响工作拷贝</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>只有在对URL操作时会</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--quiet (-q)
--recursive (-R)
--revision (-r) REV
--revprop
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>删除你的工作拷贝中一个文件的一个属性</para>

          <screen>
$ svn propdel svn:mime-type  some-script
property 'svn:mime-type' deleted from 'some-script'.
</screen>

          <para>删除一个修订版本的属性：</para>

          <screen>
$ svn propdel --revprop -r 26 release-date 
property 'release-date' deleted from repository revision '26'
</screen>

        </refsect1>
      </refentry>

      <refentry id="svn.ref.svn.c.propedit">
        <refnamediv>
          <refname>svn propedit</refname>
          <refpurpose>修改一个或多个版本控制之下文件的属性。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svn propedit PROPNAME PATH...</programlisting>
          <programlisting>svn propedit PROPNAME --revprop -r REV [URL]</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>使用喜欢的编辑器编辑一个或多个属性，第一种形式是在工作拷贝编辑版本化的属性，第二种形式是远程编辑未版本化的版本库修订版本属性。
         </para>
        </refsect1>

        <refsect1>
          <title>别名</title>
          <para>pedit, pe</para>
        </refsect1>

        <refsect1>
          <title>变化</title>
          <para>如果对URL操作会影响版本库，否则只影响工作拷贝</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>只有在对URL操作时会</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--revision (-r) REV
--revprop
--username USER
--password PASS
--no-auth-cache
--non-interactive
--encoding ENC
--editor-cmd EDITOR
--config-dir DIR
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para><command>svn propedit</command>对修改多个值的属性非常简单：
          </para>

          <screen>
$ svn propedit svn:keywords  foo.c 
    &lt;svn will launch your favorite editor here, with a buffer open
    containing the current contents of the svn:keywords property.  You
    can add multiple values to a property easily here by entering one
    value per line.&gt;
Set new value for property 'svn:keywords' on 'foo.c'
</screen>

        </refsect1>
      </refentry>

      <refentry id="svn.ref.svn.c.propget">
        <refnamediv>
          <refname>svn propget</refname>
          <refpurpose>打印一个属性的值。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svn propget PROPNAME [TARGET[@REV]...]</programlisting>
          <programlisting>svn propget PROPNAME --revprop -r REV [URL]</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>打印一个文件、目录或修订版本的一个属性的值，第一种形式是打印工作拷贝中一个或多个项目的版本化的属性，第二种形式是远程打印版本库修订版本的未版本化的属性。属性的详情见<xref
            linkend="svn.advanced.props"/>。</para>
        </refsect1>

        <refsect1>
          <title>别名</title>
          <para>pget, pg</para>
        </refsect1>

        <refsect1>
          <title>变化</title>
          <para>如果对URL操作会影响版本库，否则只影响工作拷贝</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>只有在对URL操作时会</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--recursive (-R)
--revision (-r) REV
--revprop
--strict
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>检查工作拷贝的一个文件的一个属性：
          </para>
          
          <screen>
$ svn propget svn:keywords foo.c
Author
Date
Rev
</screen>

          <para>对于修订版本属性相同：</para>

          <screen>
$ svn propget svn:log --revprop -r 20 
Began journal.
</screen>
          
        </refsect1>
      </refentry>

      <refentry id="svn.ref.svn.c.proplist">
        <refnamediv>
          <refname>svn proplist</refname>
          <refpurpose>列出所有的属性。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svn proplist [TARGET[@REV]...]</programlisting>
          <programlisting>svn proplist --revprop -r REV [URL]</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>列出文件、目录或修订版本的属性，第一种形式是列出工作拷贝的所有版本化的属性，第二种形式是列出版本库修订版本的未版本化的属性。
         </para>
        </refsect1>

        <refsect1>
          <title>别名</title>
          <para>plist, pl</para>
        </refsect1>

        <refsect1>
          <title>变化</title>
          <para>如果对URL操作会影响版本库，否则只影响工作拷贝</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>只有在对URL操作时会</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--verbose (-v)
--recursive (-R)
--revision (-r) REV
--quiet (-q)
--revprop
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
</screen>
        </refsect1>
        
        <refsect1>
          <title>例子</title>

          <para>你可以使用proplist察看你的工作拷贝的一个项目的属性：
          </para>

          <screen>
$ svn proplist foo.c
Properties on 'foo.c':
  svn:mime-type
  svn:keywords
  owner
</screen>

          <para>通过<option>--verbose</option>选项，svn
            proplist也可以非常便利的显示属性的值：</para>

          <screen>
$ svn proplist --verbose foo.c
Properties on 'foo.c':
  svn:mime-type : text/plain
  svn:keywords : Author Date Rev
  owner : sally
</screen>
          
        </refsect1>
      </refentry>

      <refentry id="svn.ref.svn.c.propset">
        <refnamediv>
          <refname>svn propset</refname>
          <refpurpose>设置文件、目录或者修订版本的属性PROPNAME为PROPVAL。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svn propset PROPNAME [PROPVAL | -F VALFILE] PATH...</programlisting>
          <programlisting>svn propset PROPNAME --revprop -r REV [PROPVAL | -F VALFILE] [URL]</programlisting>
        </refsect1>

        <refsect1>
          <title>描述</title>

          <para>设置文件、目录或者修订版本的属性<replaceable>PROPNAME</replaceable>为<replaceable>PROPVAL</replaceable>。第一个例子在工作拷贝创建了一个版本化的本地属性修改，第二个例子创建了一个未版本化的远程的对版本库修订版本的属性修改。
         </para>

          <tip>
            <para>Subversion有一系列<quote>特殊的</quote>影响行为方式的属性，关于这些属性的详情请见<xref
              linkend="svn.advanced.props.special"/>。
            </para>
          </tip>

        </refsect1>
        <refsect1>
          <title>别名</title>
          <para>pset, ps</para>
        </refsect1>

        <refsect1>
          <title>变化</title>
          <para>如果对URL操作会影响版本库，否则只影响工作拷贝</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>只有在对URL操作时会</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--file (-F) FILE
--quiet (-q)
--revision (-r) REV
--targets FILENAME
--recursive (-R)
--revprop
--username USER
--password PASS
--no-auth-cache
--non-interactive
--encoding ENC
--force
--config-dir DIR
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>设置文件的mimetype：</para>

          <screen>
$ svn propset svn:mime-type image/jpeg foo.jpg 
property 'svn:mime-type' set on 'foo.jpg'
</screen>

          <para>在UNIX系统，如果你希望一个文件设置执行权限：
          </para>

          <screen>
$ svn propset svn:executable ON somescript
property 'svn:executable' set on 'somescript'
</screen>

          <para>或许为了合作者的利益你有一个内部的属性设置：</para>

          <screen>
$ svn propset owner sally foo.c
property 'owner' set on 'foo.c'
</screen>

          <para>如果你在特定修订版本的日志信息里有一些错误，并且希望修改，可以使用<option>--revprop</option>设置<literal>svn:log</literal>为新的日志信息：
          </para>

          <screen>
$ svn propset --revprop -r 25 svn:log "Journaled about trip to New York."
property 'svn:log' set on repository revision '25'
</screen>

          <para>或者，你没有工作拷贝，你可以提供一个URL。</para>
          
          <screen>
$ svn propset --revprop -r 26 svn:log "Document nap." http://svn.red-bean.com/repos
property 'svn:log' set on repository revision '25'
</screen>

          <para>最后，你可以告诉propset从一个文件得到输入，你甚至可以使用这个方式来设置一个属性为二进制内容：
         </para>

          <screen>
$ svn propset owner-pic -F sally.jpg moo.c 
property 'owner-pic' set on 'moo.c'
</screen>

          <note>
            <para>缺省，你不可以在Subversion版本库修改修订版本属性，你的版本库管理员必须显示的通过创建一个名字为<literal>pre-revprop-change</literal>的钩子来允许修订版本属性修改，关于钩子脚本的详情请见<xref
              linkend="svn.reposadmin.create.hooks"/>。
              </para>
          </note>

        </refsect1>
      </refentry>

      <refentry id="svn.ref.svn.c.resolved">
        <refnamediv>
          <refname>svn resolved</refname>
          <refpurpose>删除工作拷贝文件或目录的<quote>冲突</quote>状态。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svn resolved PATH...</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>删除工作拷贝文件或目录的<quote>conflicted</quote>状态。这个程序不是语义上的改变冲突标志，它只是删除冲突相关的人造文件，从而重新允许<replaceable>PATH</replaceable>提交；也就是说，它告诉Subversion冲突已经<quote>解决了</quote>。关于解决冲突更深入的考虑可以查看<xref
            linkend="svn.tour.cycle.resolve"/>。</para>
        </refsect1>

        <refsect1>
          <title>别名</title>
          <para>无</para>
        </refsect1>

        <refsect1>
          <title>变化</title>
          <para>工作拷贝</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>否</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--targets FILENAME
--recursive (-R)
--quiet (-q)
--config-dir DIR
</screen>
        </refsect1>
        
        <refsect1>
          <title>例子</title>
          
          <para>如果你在更新时得到冲突，你的工作拷贝会产生三个新的文件：</para>

          <screen>
$ svn update
C  foo.c
Updated to revision 31.
$ ls
foo.c
foo.c.mine
foo.c.r30
foo.c.r31
</screen>

          <para>当你解决了<filename>foo.c</filename>的冲突，并且准备提交，运行<command>svn resolved</command>让你的工作拷贝知道你已经完成了所有事情。
          </para>

          <warning>
            <para>你<emphasis>可以</emphasis>仅仅删除冲突的文件并且提交，但是<command>svn
              resolved</command>除了删除冲突文件，还修正了一些记录在工作拷贝管理区域的记录数据，所以我们推荐你使用这个命令。</para>
          </warning>

        </refsect1>
      </refentry>

      <refentry id="svn.ref.svn.c.revert">
        <refnamediv>
          <refname>svn revert</refname>
          <refpurpose>取消所有的本地编辑。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svn revert PATH...</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>恢复所有对文件和目录的修改，并且解决所有的冲突状态。<command>svn
            revert</command>不会只是恢复工作拷贝中一个项目的内容，也包括了对属性修改的恢复。最终，你可以使用它来取消所有已经做过的预定操作（例如，文件预定要添加或删除可以<quote>恢复</quote>）。
           </para>
        </refsect1>

        <refsect1>
          <title>别名</title>
          <para>无</para>
        </refsect1>

        <refsect1>
          <title>变化</title>
          <para>工作拷贝</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>否</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--targets FILENAME
--recursive (-R)
--quiet (-q)
--config-dir DIR
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>丢弃对一个文件的修改：</para>

          <screen>
$ svn revert foo.c
Reverted foo.c
</screen>

          <para>如果你希望恢复一整个目录的文件，可以使用<option>--recursive</option>选项：
          </para>

          <screen>
$ svn revert --recursive .
Reverted newdir/afile
Reverted foo.c
Reverted bar.txt
</screen>

          <para>最后，你可以取消预定的操作：</para>

          <screen>
$ svn add mistake.txt whoops
A         mistake.txt
A         whoops
A         whoops/oopsie.c

$ svn revert mistake.txt whoops
Reverted mistake.txt
Reverted whoops

$ svn status
?      mistake.txt
?      whoops
</screen>

          <note>
            <para>如果你没有给<command>svn
              revert</command>提供了目标，它不会做任何事情&mdash;为了保护你不小心失去对工作拷贝的修改，<command>svn revert</command>需要你提供至少一个目标。
             </para>
          </note>

        </refsect1>
      </refentry>

      <refentry id="svn.ref.svn.c.status">
        <refnamediv>
          <refname>svn status</refname>
          <refpurpose>打印工作拷贝文件和目录的状态。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svn status [PATH...]</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>打印工作拷贝文件和目录的状态。如果没有参数，只会打印本地修改的项目（不会访问版本库），使用<option>--show-updates</option>选项，会添加工作修订版本和服务器过期信息。使用<option>--verbose</option>会打印每个项目的完全修订版本信息。
         </para>

          <para>输出的前六列都是一个字符宽，每一列给出了工作拷贝项目的每一方面的信息。
          </para>
          
          <para>第一列指出一个项目的是添加、删除还是其它的修改。</para>

          <variablelist>
            
            <varlistentry>
              <term>' '</term>
              <listitem>
                <para>没有修改。</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>'A'</term>
              <listitem>
                <para>预定要添加的项目。</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>'D'</term>
              <listitem>
                <para>预定要删除的项目。</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>'M'</term>
              <listitem>
                <para>项目已经修改了。</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>'R'</term>
              <listitem>
                <para>项目在工作拷贝中已经被替换了。</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>'C'</term>
              <listitem>
                  <para>项目的内容（相对于属性）与更新得到的数据冲突了。
                  </para>  
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>'X'</term>
              <listitem>
                <para>项目与外部定义相关。</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>'I'</term>
              <listitem>
                <para>项目被忽略（例如使用<literal>svn:ignore</literal>属性）。</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>'?'</term>
              <listitem>
                <para>项目不在版本控制之下。</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>'!'</term>
              <listitem>
                <para>项目已经丢失（例如，你使用<command>svn</command>移动或者删除了它）。这也说明了一个目录不是完整的（一个检出或更新中断）。
               </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>'~'</term>
              <listitem>
                <para>项目作为一种对象（文件、目录或链接）纳入版本控制，但是已经被另一种对象替代。
                </para>
              </listitem>
            </varlistentry>

          </variablelist>

          <para>第二列告诉一个文件或目录的属性的状态。</para>

          <variablelist>
            
            <varlistentry>
              <term>' '</term>
              <listitem>
                <para>没有修改。</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>'M'</term>
              <listitem>
                <para>这个项目的属性已经修改。</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>'C'</term>
              <listitem>
                <para>这个项目的属性与从版本库得到的更新有冲突。
                </para>
              </listitem>
            </varlistentry>

          </variablelist>

          <para>第三列只在工作拷贝锁定时才会出现。</para>

          <variablelist>
            
            <varlistentry>
              <term>' '</term>
              <listitem>
                <para>项目没有锁定。</para>
              </listitem>
            </varlistentry>
            
            <varlistentry>
              <term>'L'</term>
              <listitem>
                <para>项目已经锁定。</para>
              </listitem>
            </varlistentry>

          </variablelist>

          <para>第四列只在预定包含历史添加的项目出现。</para>
          
          <variablelist>
            
            <varlistentry>
              <term>' '</term>
              <listitem>
                <para>没有历史预定要提交。</para>
              </listitem>
            </varlistentry>
            
            <varlistentry>
              <term>'+'</term>
              <listitem>
                <para>历史预定要伴随提交。</para>
              </listitem>
            </varlistentry>

          </variablelist>

          <para>第五列只在项目跳转到相对于它的父目录时出现（见<xref
            linkend="svn.branchmerge.switchwc"/>）。
            </para>

          <variablelist>
            
            <varlistentry>
              <term>' '</term>
              <listitem>
                <para>项目是它的父目录的孩子。</para>
              </listitem>
            </varlistentry>
            
            <varlistentry>
              <term>'S'</term>
              <listitem>
                <para>项目已经转换。</para>
              </listitem>
            </varlistentry>

          </variablelist>

          <para>第六列显示锁定信息。</para>
          
          <variablelist>
            
            <varlistentry>
              <term>' '</term>
              <listitem>
                <para>当使用<option>--show-updates</option>，文件没有锁定。如果<emphasis>不</emphasis>使用<option>--show-updates</option>，这意味着文件在工作拷贝被锁定。
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>K</term>
              <listitem>
                <para>文件锁定在工作拷贝。</para>
              </listitem>
            </varlistentry>
            
            <varlistentry>
              <term>O</term>
              <listitem>
                <para>文件被另一个工作拷贝的另一个用户锁定，只有在使用<option>--show-updates</option>时显示。
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>T</term>
              <listitem>
                <para>文件锁定在工作拷贝，但是锁定被<quote>窃取</quote>而不可用。文件当前锁定在版本库，只有在使用<option>--show-updates</option>时显示。</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>B</term>
              <listitem>
                <para>文件锁定在工作拷贝，但是锁定被<quote>破坏</quote>而不可用。文件当前锁定在版本库，只有在使用<option>--show-updates</option>时显示。</para>
              </listitem>
            </varlistentry>

          </variablelist>


          <para>过期信息出现在第七列（只在使用<option>--show-updates</option>选项时出现）。</para>

          <variablelist>
            
            <varlistentry>
              <term>' '</term>
              <listitem>
                <para>这个项目在工作拷贝是最新的。</para>
              </listitem>
            </varlistentry>
            
            <varlistentry>
              <term>'*'</term>
              <listitem>
                <para>在服务器这个项目有了新的修订版本。</para>
              </listitem>
            </varlistentry>

          </variablelist>

          <para>余下的字段是可变得宽度且使用空格分隔，如果使用<option>--show-updates</option>或<option>--verbose</option>选项，工作修订版本是下一个字段。
          </para>
          
          <para>如果传递<option>--verbose</option>选项，最后提交的修订版本和最后的提交作者会在后面显示。
          </para>
          
          <para>工作拷贝路径永远是最后一个字段，所以它可以包括空格。</para>

        </refsect1>

        <refsect1>
          <title>别名</title>
          <para>stat, st</para>
        </refsect1>

        <refsect1>
          <title>变化</title>
          <para>无</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>只有使用<option>--show-updates</option>时会访问</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--show-updates (-u)
--verbose (-v)
--non-recursive (-N)
--quiet (-q)
--no-ignore
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir
--ignore-externals
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>这是查看你在工作拷贝所做的修改的最简单的方法。</para>

          <screen>
$ svn status wc
 M     wc/bar.c
A  +   wc/qax.c
</screen>

          <para>如果你希望找出工作拷贝哪些文件是最新的，使用<option>--show-updates</option>选项（这不会对工作拷贝有任何修改）。这里你会看到<filename>wc/foo.c</filename>在上次更新后有了修改：</para>

          <screen>
$ svn status --show-updates wc
 M           965    wc/bar.c
       *     965    wc/foo.c
A  +         965    wc/qax.c
Status against revision:    981
</screen>

          <note>
            <para><option>--show-updates</option>
              <emphasis>只会</emphasis>在过期的项目（如果你运行<command>svn
              update</command>，就会更新的项目）旁边安置一个星号。<option>--show-updates</option>不会导致状态列表反映项目的版本库版本。
              </para>
          </note>

          <para>最后，是你能从status子命令得到的所有信息：</para>

          <screen>
$ svn status --show-updates --verbose wc
 M           965       938 sally        wc/bar.c
       *     965       922 harry        wc/foo.c
A  +         965       687 harry        wc/qax.c
             965       687 harry        wc/zig.c
Head revision:   981
</screen>

          <para>关于<command>svn status</command>的更多例子可以见<xref linkend="svn.tour.cycle.examine.status"/>。
          </para>

        </refsect1>
      </refentry>

      <refentry id="svn.ref.svn.c.switch">
        <refnamediv>
          <refname>svn switch</refname>
          <refpurpose>把工作拷贝更新到别的URL。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svn switch URL [PATH]</programlisting>

          <programlisting>switch --relocate FROM TO [PATH...]</programlisting>


        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>这个子命令更新你的工作拷贝来反映新的URL&mdash;通常是一个与你的工作拷贝分享共同祖先的URL，尽管这不是必需的。这是Subversion移动工作拷贝到分支的方式。更深入的了解请见<xref
            linkend="svn.branchmerge.switchwc"/>。</para>
        </refsect1>

        <refsect1>
          <title>别名</title>
          <para>sw</para>
        </refsect1>

        <refsect1>
          <title>变化</title>
          <para>工作拷贝</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>是</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--revision (-r) REV
--non-recursive (-N)
--quiet (-q)
--diff3-cmd CMD
--relocate
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
</screen>
        </refsect1>
        
        <refsect1>
          <title>例子</title>

          <para>如果你目前所在目录<filename>vendors</filename>分支到<filename>vendors-with-fix</filename>，你希望转移到那个分支：
          </para>

          <screen>
$ svn switch http://svn.red-bean.com/repos/branches/vendors-with-fix .
U  myproj/foo.txt
U  myproj/bar.txt
U  myproj/baz.c
U  myproj/qux.c
Updated to revision 31.
</screen>

          <para>为了跳转回来，只需要提供最初取出工作拷贝的版本库URL：
          </para>

          <screen>
$ svn switch http://svn.red-bean.com/repos/trunk/vendors .
U  myproj/foo.txt
U  myproj/bar.txt
U  myproj/baz.c
U  myproj/qux.c
Updated to revision 31.
</screen>

          <tip>
            <para>如果你不希望跳转所有的工作拷贝，你可以只跳转一部分。
            </para>
          </tip>

          <para>有时候管理员会修改版本库的<quote>基本位置</quote>&mdash;换句话说，版本库的内容并不改变，但是访问根的主URL变了。举个例子，主机名变了、URL模式变了或者是URL中的任何一部分改变了。我们不选择重新检出一个工作拷贝，你可以使用<command>svn switch</command>来重写版本库所有URL的开头。使用<option>--relocate</option>来做这种替换，没有文件内容会改变，访问的版本库也不会改变。只是像在工作拷贝<filename>.svn/</filename>运行了一段Perl脚本<command>s/OldRoot/NewRoot/</command>。
         </para>

          <screen>
$ svn checkout file:///tmp/repos test
A  test/a
A  test/b
&hellip;

$ mv repos newlocation
$ cd test/

$ svn update
svn: Unable to open an ra_local session to URL
svn: Unable to open repository 'file:///tmp/repos'

$ svn switch --relocate file:///tmp/repos file:///tmp/newlocation .
$ svn update
At revision 3.
</screen>

          <warning>
            <para>小心使用<option>--relocate</option>选项，如果你输入了错误的选项，你会在工作拷贝创建无意义的URL，会导致整个工作区不可用并且难于修复。理解何时应该使用<option>--relocate</option>也是非常重要的，下面是一些规则：
            </para>
            
            <itemizedlist>
              <listitem><para>如果工作拷贝需要反映一个版本库的新目录，只需要使用<command>svn
                  switch</command>。
                  </para></listitem>

              <listitem><para>如果你的工作拷贝还是反映相同的版本库目录，但是版本库本身的位置改变了，使用<command>svn
                  switch --relocate</command>。
                  </para></listitem>
            </itemizedlist>
          </warning>

        </refsect1>
      </refentry>

      <refentry id="svn.ref.svn.c.unlock">
        <refnamediv>
          <refname>svn unlock</refname> 
            <refpurpose>解锁工作拷贝路径或URL。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svn unlock TARGET...</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>解锁每个<replaceable>TARGET</replaceable>。如果任何另一个用户锁定了<replaceable>TARGET</replaceable>，或者没有正确工作拷贝的锁定令牌，打印警告并继续解锁余下的<replaceable>TARGET</replaceable>。使用<option>--force</option>可以打破其它用户或工作拷贝的锁定。</para>

        </refsect1>

        <refsect1>
          <title>别名</title>
          <para>无</para>
        </refsect1>

        <refsect1>
          <title>变化</title>
          <para>工作拷贝，版本库</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>是</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--targets ARG
--username ARG
--password ARG
--no-auth-cache
--non-interactive
--config-dir ARG
--force
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>解锁工作拷贝中的两个文件：</para>

          <screen>

$ svn unlock tree.jpg house.jpg
'tree.jpg' unlocked.
'house.jpg' unlocked.
</screen>

          <para>解锁工作拷贝的一个被其他用户锁定的文件：</para>

          <screen>
$ svn unlock tree.jpg
svn: 'tree.jpg' is not locked in this working copy
$ svn unlock --force tree.jpg
'tree.jpg' unlocked.
</screen>

          <para>没有工作拷贝时解锁一个文件：</para>

          <screen>
$ svn unlock http://svn.red-bean.com/repos/test/tree.jpg
'tree.jpg unlocked.
</screen>

          <para>更多细节见<xref
            linkend="svn.advanced.locking"/>.</para>

        </refsect1>
      </refentry>


      <refentry id="svn.ref.svn.c.update">
        <refnamediv>
          <refname>svn update</refname>
          <refpurpose>更新你的工作拷贝。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svn update [PATH...]</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para><command>svn update</command>会把版本库的修改带到工作拷贝，如果没有给定修订版本，它会把你的工作拷贝更新到<literal>HEAD</literal>修订版本，否则，它会把工作拷贝更新到你用<option>--revision</option>指定的修订版本。为了保持同步，也会删除所有在工作拷贝发现的无效锁定。
          </para>

          <para>对于每一个更新的项目开头都有一个表示所做动作的字符，这些字符有下面的意思：
          </para>

          <variablelist>

            <varlistentry>
              <term>A</term>
              <listitem>
                <para>添加</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>D</term>
              <listitem>
                <para>删除</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>U</term>
              <listitem>
                <para>更新</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>C</term>
              <listitem>
                <para>冲突</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>G</term>
              <listitem>
                <para>合并</para>
              </listitem>
            </varlistentry>

          </variablelist>

          <para>第一列的字符反映文件本身的更新，而第二列会反映文件属性的更新。
          </para>
        </refsect1>

        <refsect1>
          <title>别名</title>
          <para>up</para>
        </refsect1>

        <refsect1>
          <title>变化</title>
          <para>工作拷贝</para>
        </refsect1>

        <refsect1>
          <title>是否访问版本库</title>
          <para>是</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--revision (-r) REV
--non-recursive (-N)
--quiet (-q)
--diff3-cmd CMD
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
--ignore-externals
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>获取你上次更新之后版本库的修改：</para>

          <screen>
$ svn update
A  newdir/toggle.c
A  newdir/disclose.c
A  newdir/launch.c
D  newdir/README
Updated to revision 32.
</screen>

          <para>你也可以将工作拷贝更新到旧的修订版本（Subversion没有CVS的<quote>sticky</quote>文件的概念；见<xref
            linkend="svn.forcvs"/>）：</para>

          <screen>
$ svn update -r30
A  newdir/README
D  newdir/toggle.c
D  newdir/disclose.c
D  newdir/launch.c
U  foo.c
Updated to revision 30.
</screen>

          <tip>
            <para>如果你希望检查单个文件的旧的修订版本，你会希望使用<command>svn
              cat</command>。</para>
          </tip>
          
        </refsect1>
      </refentry>
    </sect2>
    
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.ref.svnadmin">
    <title><command>svnadmin</command></title>
    
    <para><command>svnadmin</command>是一个用来监控和修改Subversion版本库的管理工具，详情请见<xref
      linkend="svn.reposadmin.maint.tk.svnadmin"/>。</para>

    <para>因为<command>svnadmin</command>直接访问版本库（因此只可以在存放版本库的机器上使用），它通过路径访问版本库，而不是URL。
   </para>
      
    <!-- =============================================================== -->
    <sect2 id="svn.ref.svnadmin.sw">
      <title><command>svnadmin</command> Switches</title> 
      
      <variablelist>
        
        <varlistentry>
          <term><option>--bdb-log-keep</option></term>
          <listitem>
            <para>（Berkeley DB特定）关闭数据库日志自动日志删除功能。
            </para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><option>--bdb-txn-nosync</option></term>
          <listitem>
            <para>（Berkeley DB特定）当提交数据库事务时关闭fsync。</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><option>--bypass-hooks</option></term>
          <listitem>
            <para>绕过版本库钩子系统。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--clean-logs</option></term>
          <listitem>
            <para>删除不使用的Berkeley DB日志。</para>
          </listitem>
        </varlistentry>

        <!-- TODO config-dir? Is it really used? -->

        <varlistentry>
          <term><option>--force-uuid</option></term>
          <listitem>
            <para>缺省情况下，当版本库加载已经包含修订版本的数据时<command>svnadmin</command>会忽略流中的<literal>UUID</literal>，这个选项会导致版本库的<literal>UUID</literal>设置为流的<literal>UUID</literal>。
           </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--ignore-uuid</option></term>
          <listitem>
            <para>缺省情况下，当加载空版本库时，<command>svnadmin</command>会使用来自流中的<literal>UUID</literal>，这个选项会导致忽略UUID。
           </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--incremental</option></term>
          <listitem>
            <para>导出一个修订版本针对前一个修订版本的区别，而不是通常的完全结果。
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--parent-dir
          <replaceable>DIR</replaceable></option></term>
          <listitem>
            <para>当加载一个转储文件时，根路径为<replaceable>DIR</replaceable>而不是<filename>/</filename>。
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--revision</option> (<option>-r</option>)
          <replaceable>ARG</replaceable></term>
          <listitem>
            <para>指定一个操作的修订版本。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--quiet</option></term>
          <listitem>
            <para>不显示通常的过程&mdash;只显示错误。</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><option>--use-post-commit-hook</option></term>
          <listitem>
            <para>当导入使用一个转储文件时，在每次新的修订版本产生时运行版本库post-commit钩子。
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--use-pre-commit-hook</option></term>
          <listitem>
            <para>当加载一个转储文件时，每次新加修订版本之前运行版本库的pre-commit钩子。如果钩子失败，终止提交并中断加载进程。
            </para>
          </listitem>
        </varlistentry>
        
      </variablelist>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.ref.svnadmin.c">
      <title><command>svnadmin</command> Subcommands</title>

      <refentry id="svn.ref.svnadmin.c.create">
        <refnamediv>
          <refname>svnadmin create</refname>
          <refpurpose>创建一个新的空的版本库。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnadmin create REPOS_PATH</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

            <para>在提供的路径上创建一个新的空的版本库，如果提供的目录不存在，它会为你创建。<footnote><para>记住<command>svnadmin</command>只工作在本地<emphasis>路径</emphasis>，而不是<emphasis>URL</emphasis>。
           </para></footnote>对于Subversion 1.2，<command>svnadmin</command>缺省使用<literal>fsfs</literal>文件系统后端创建版本库。</para>
          </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--bdb-txn-nosync
--bdb-log-keep
--config-dir DIR
--fs-type TYPE
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>创建一个版本库就是这样简单：</para>

          <screen>
$ svnadmin create /usr/local/svn/repos
</screen>
          
          <para>在Subversion 1.0，一定会创建一个Berkeley DB版本库，在Subversion 1.1，Berkeley DB版本库是缺省类型，但是一个FSFS版本库也是可以创建，使用<option>--fs-type</option>选项：
          </para>

          <screen>
$ svnadmin create /usr/local/svn/repos --fs-type fsfs
</screen>

        </refsect1>
      </refentry>

      <refentry id="svn.ref.svnadmin.c.deltify">
        <refnamediv>
          <refname>svnadmin deltify</refname>
          <refpurpose>修订版本范围的路径的增量变化。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnadmin deltify [-r LOWER[:UPPER]] REPOS_PATH</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para><command>svnadmin deltify</command>因为历史原因之存在于1.0.x，这个命令已经废弃，不再需要。
          </para>

          <para>它开始于当Subversion提供了管理员控制版本库压缩策略的能力，结果是复杂工作得到了<emphasis>非常</emphasis>小的收益，所以这个<quote>特性</quote>被废弃了。
         </para>

            </refsect1>
        <refsect1>
          <title>选项</title>
          
          <screen>
--revision (-r)
--quiet
</screen>
        </refsect1>
      </refentry>

      <refentry id="svn.ref.svnadmin.c.dump">
        <refnamediv>
          <refname>svnadmin dump</refname>
          <refpurpose>将文件系统的内容转储到标准输出。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnadmin dump REPOS_PATH [-r LOWER[:UPPER]] [--incremental]</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>使用<quote>dumpfile</quote>可移植格式将文件系统的内容转储到标准输出，将反馈发送到标准错误，导出的修订版本从<replaceable>LOWER</replaceable>到<replaceable>UPPER</replaceable>。如果没有提供修订版本，会导出所有的修订版本树，如果只提供<replaceable>LOWER</replaceable>，导出一个修订版本树，通常的用法见<xref linkend="svn.reposadmin.maint.migrate"/>。
         </para>

         <para>缺省情况下，Subversion的转储流包含了一个包括所有文件和目录的单独修订版本（请求的修订版本范围的第一个），后面是其它的只包含本修订所修改的文件和目录的修订版本（请求范围的其它版本）。对于修改的文件，转储文件包括所有的内容和属性，对于目录，包括所有的属性。</para>

          <para>有一对有用的选项可以改变转储文件产生的方式，第一个是<option>--incremental</option>，使得第一个修订版本只显示其修改的文件和目录，而不是整个目录树，就像转储文件中其它的修订版本。这对产生一个准备导入到已经有数据的版本库时非常有用。
          </para>

          <para>第二个有用的选项是<option>--deltas</option>，这个选项导致<command>svnadmin dump</command>不会保留修改文件的所有内容，而只是记录修改的部分。这样减少（有些情况下是非常大的）了<command>svnadmin dump</command>产生的转储文件的大小。然而，也有缺点&mdash;增量转储文件需要更多的CPU来创建，也不可以用<command>svndumpfilter</command>操作，也不如非增量文件容易被如<command>gzip</command>和<command>bzip2</command>等第三方工具压缩。</para>
            </refsect1>
        <refsect1>
          <title>选项</title>
          
          <screen>
--revision (-r)
--incremental
--quiet
--deltas
</screen>
        </refsect1>
        
        <refsect1>
          <title>例子</title>

          <para>转储整个版本库：</para>

          <screen>
$ svnadmin dump /usr/local/svn/repos
SVN-fs-dump-format-version: 1
Revision-number: 0
* Dumped revision 0.
Prop-content-length: 56
Content-length: 56
&hellip;
</screen>

          <para>从版本库增量转储一个单独的事务：</para>

          <screen>
$ svnadmin dump /usr/local/svn/repos -r 21 --incremental 
* Dumped revision 21.
SVN-fs-dump-format-version: 1
Revision-number: 21
Prop-content-length: 101
Content-length: 101
&hellip;
</screen>

        </refsect1>
      </refentry>

      <refentry id="svn.ref.svnadmin.c.help">
        <refnamediv>
          <refname>svnadmin help</refname>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnadmin help [SUBCOMMAND...]</programlisting>
        </refsect1>

        <refsect1>
          <title>描述</title>

          <para>当你困于一个没有网络连接和本书的沙漠岛屿时，这个子命令非常有用。
          </para>

        </refsect1>

        <refsect1>
          <title>别名</title>
          <para>?, h</para>
        </refsect1>

      </refentry>

      <refentry id="svn.ref.svnadmin.c.hotcopy">
        <refnamediv>
          <refname>svnadmin hotcopy</refname>
          <refpurpose>制作一个版本库的热备份。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnadmin hotcopy REPOS_PATH NEW_REPOS_PATH</programlisting>
        </refsect1>

        <refsect1>
          <title>描述</title>

          <para>这个子命令会制作一个版本库的完全<quote>热</quote>拷贝，包括所有的钩子，配置文件，当然还有数据库文件。如果你传递<option>--clean-logs</option>选项，<command>svnadmin</command>会执行热拷贝操作，然后删除不用的Berkeley DB日志文件。你可以在任何时候运行这个命令得到一个版本库的安全拷贝，不管其它进程是否使用这个版本库。
         </para>

        </refsect1>

        <refsect1>
          <title>选项</title>
          
          <screen>
--clean-logs
</screen>
        </refsect1>

      </refentry>

      <refentry id="svn.ref.svnadmin.c.list-dblogs">
        <refnamediv>
          <refname>svnadmin list-dblogs</refname> <refpurpose>询问Berkeley DB在给定的Subversion版本库有哪些日志文件存在（只有在版本库使用<literal>bdb</literal>作为后端时使用）。
          </refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnadmin list-dblogs REPOS_PATH</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>Berkeley DB创建了记录所有版本库修改的日志，允许我们在面对大灾难时恢复。除非你开启了<literal>DB_LOG_AUTOREMOVE</literal>，否则日志文件会累积，尽管大多数是不再使用可以从磁盘删除得到空间。详情见<xref
            linkend="svn.reposadmin.maint.diskspace"/>。
            </para>
        </refsect1>

      </refentry>

      <refentry id="svn.ref.svnadmin.c.list-unused-dblogs">
        <refnamediv>
          <refname>svnadmin list-unused-dblogs</refname>
          <refpurpose>询问Berkeley DB哪些日志文件可以安全的删除（只有在版本库使用<literal>bdb</literal>作为后端时使用）。
          </refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnadmin list-unused-dblogs REPOS_PATH</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>
          Berkeley DB创建了记录所有版本库修改的日志，允许我们在面对大灾难时恢复。除非你开启了<literal>DB_LOG_AUTOREMOVE</literal>，否则日志文件会累积，尽管大多数是不再使用，可以从磁盘删除得到空间。详情见<xref
            linkend="svn.reposadmin.maint.diskspace"/>。</para>
        </refsect1>

        <refsect1>
          <title>例子</title>
          
          <para>删除所有不用的日志文件：</para>

        <screen>
$ svnadmin list-unused-dblogs /path/to/repos
/path/to/repos/log.0000000031
/path/to/repos/log.0000000032
/path/to/repos/log.0000000033

$ svnadmin list-unused-dblogs /path/to/repos | xargs rm
## disk space reclaimed!
</screen>

        </refsect1>
      </refentry>

      <refentry id="svn.ref.svnadmin.c.load">
        <refnamediv>
          <refname>svnadmin load</refname> <refpurpose>从标准输出读取<quote>转储文件</quote>格式流。
          </refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnadmin load REPOS_PATH</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>从标准输出读取<quote>转储文件</quote>格式流，提交新的修订版本到版本库文件系统，发送进展反馈到标准输出。
         </para>
        </refsect1>

        <refsect1>
          <title>选项</title>
          
          <screen>
--quiet (-q)
--ignore-uuid
--force-uuid
--use-pre-commit-hook
--use-post-commit-hook
--parent-dir
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>这里显示了加载一个备份文件到版本库（当然，使用<command>svnadmin
            dump</command>）：
            </para>

          <screen>
$ svnadmin load /usr/local/svn/restored &lt; repos-backup
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : test ... done.
     * adding path : test/a ... done.
&hellip;
</screen>

          <para>或者你希望加载到一个子目录：</para>

          <screen>
$ svnadmin load --parent-dir new/subdir/for/project /usr/local/svn/restored &lt; repos-backup
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : test ... done.
     * adding path : test/a ... done.
&hellip;
</screen>

        </refsect1>
      </refentry>

      <refentry id="svn.ref.svnadmin.c.lslocks">
        <refnamediv>
          <refname>svnadmin lslocks</refname> 
          <refpurpose>打印所有锁定的描述。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnadmin lslocks REPOS_PATH</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>打印版本库所有锁定的描述。</para>
        </refsect1>

        <refsect1>
          <title>选项</title>
          
          <para>无</para>
        </refsect1>

        <refsect1>
          <title>例子</title>


          <para>显示了版本库<filename>/svn/repos</filename>中一个锁定的文件：</para>

          <screen>
$ svnadmin lslocks /svn/repos
Path: /tree.jpg
UUID Token: opaquelocktoken:ab00ddf0-6afb-0310-9cd0-dda813329753
Owner: harry
Created: 2005-07-08 17:27:36 -0500 (Fri, 08 Jul 2005)
Expires: 
Comment (1 line):
Rework the uppermost branches on the bald cypress in the foreground.
</screen>
        </refsect1>
      </refentry>

      <refentry id="svn.ref.svnadmin.c.lstxns">
        <refnamediv>
          <refname>svnadmin lstxns</refname>
          <refpurpose>打印所有未提交的事物名称。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnadmin lstxns REPOS_PATH</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>打印所有未提交的事物名称。关于未提交事物是怎样创建和如何使用的信息见<xref linkend="svn.reposadmin.maint.cleanup"/>。
          </para>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>列出版本库所有突出的事物。</para>

          <screen>
$ svnadmin lstxns /usr/local/svn/repos/ 
1w
1x
</screen>

        </refsect1>
      </refentry>

      <refentry id="svn.ref.svnadmin.c.recover">
        <refnamediv>
          <refname>svnadmin recover</refname>
          <refpurpose>将版本库数据库恢复到稳定状态（只有在版本库使用<literal>bdb</literal>作为后端时使用），此外，如果<filename>repos/conf/passwd</filename>不存在，它会创建一个默认的密码文件。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnadmin recover REPOS_PATH</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>在你得到的错误说明你需要恢复版本库时运行这个命令。</para>
        </refsect1>
        <refsect1>
          <title>选项</title>
          <screen>
--wait
</screen>
        </refsect1>
        <refsect1>
          <title>例子</title>
          
          <para>恢复挂起的版本库：</para>

          <screen>
$ svnadmin recover /usr/local/svn/repos/ 
Repository lock acquired.
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 34.
</screen>

          <para>恢复数据库需要一个版本库的独占锁，如果另一个进程访问版本库，<command>svnadmin recover</command>会出错：
          </para>
          <screen>
$ svnadmin recover /usr/local/svn/repos
svn: Failed to get exclusive repository access; perhaps another process
such as httpd, svnserve or svn has it open?

$
</screen>

          <para><option>--wait</option>选项可以导致<command>svnadmin recover</command>一直等待其它进程断开连接：
          </para>

          <screen>
$ svnadmin recover /usr/local/svn/repos --wait
Waiting on repository lock; perhaps another process has it open?

### time goes by...

Repository lock acquired.
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 34.
</screen>

        </refsect1>
      </refentry>

<refentry id="svn.ref.svnadmin.c.rmlocks">
        <refnamediv>
          <refname>svnadmin rmlocks</refname>
          <refpurpose>无条件的删除版本库的一个或多个锁定。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnadmin rmlocks REPOS_PATH LOCKED_PATH...</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>从<replaceable>LOCKED_PATH</replaceable>删除没个锁定。</para>
        </refsect1>

        <refsect1>
          <title>选项</title>
          
          <para>无</para>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>这删除了版本库<filename>/svn/repos</filename>里<filename>tree.jpg</filename>和<filename>house.jpg</filename>文件上的锁定：</para>

          <screen>
$ svnadmin rmlocks /svn/repos tree.jpg house.jpg
Removed lock on '/tree.jpg.
Removed lock on '/house.jpg.
</screen>
        </refsect1>
      </refentry>


      <refentry id="svn.ref.svnadmin.c.rmtxns">
        <refnamediv>
          <refname>svnadmin rmtxns</refname>
          <refpurpose>从版本库删除事物。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnadmin rmtxns REPOS_PATH TXN_NAME...</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>删除版本库突出的事物，更多细节在<xref
            linkend="svn.reposadmin.maint.cleanup"/>。
            </para>
        </refsect1>

        <refsect1>
          <title>选项</title>
          
          <screen>
--quiet (-q)
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>删除命名的事物：</para>

          <screen>
$ svnadmin rmtxns /usr/local/svn/repos/ 1w 1x
</screen>

          <para>很幸运，<command>lstxns</command>的输出作为<command>rmtxns</command>输入工作良好：
          </para>

          <screen>
$ svnadmin rmtxns /usr/local/svn/repos/  `svnadmin lstxns /usr/local/svn/repos/`
</screen>

          <para>从版本库删除所有未提交的事务。</para>

        </refsect1>
      </refentry>


      <refentry id="svn.ref.svnadmin.c.setlog">
        <refnamediv>
          <refname>svnadmin setlog</refname>
          <refpurpose>设置某个修订版本的日志信息。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnadmin setlog REPOS_PATH -r REVISION FILE</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>设置修订版本REVISION的日志信息为FILE的内容。
          </para>

          <para>这与使用<command>svn propset
            --revprop</command>设置某一修订版本的<literal>svn:log</literal>属性效果一样，除了你也可以使用<option>--bypass-hooks</option>选项绕过的所有pre-或post-commit的钩子脚本，这在pre-revprop-change钩子脚本中禁止修改修订版本属性时非常有用。</para>

          <warning>
            <para>修订版本属性不在版本控制之下的，所以这个命令会永久覆盖前一个日志信息。
            </para>
          </warning>

        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--revision (-r) ARG
--bypass-hooks
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>设置修订版本19的日志信息为文件<filename>msg</filename>的内容：
          </para>

          <screen>
$ svnadmin setlog /usr/local/svn/repos/ -r 19 msg
</screen>

        </refsect1>
      </refentry>

      <refentry id="svn.ref.svnadmin.c.verify">
        <refnamediv>
          <refname>svnadmin verify</refname>
          <refpurpose>验证版本库保存的数据。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnadmin verify REPOS_PATH</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>如果希望验证版本库的完整性可以运行这个命令，原理是通过在内部转储遍历所有的修订版本并且丢掉输出。
         </para>
        </refsect1>

        <refsect1>
          <title>例子</title>
          
          <para>检验挂起的版本库：</para>

          <screen>
$ svnadmin verify /usr/local/svn/repos/ 
* Verified revision 1729.
</screen>

        </refsect1>
      </refentry>

    </sect2>

  </sect1>
  
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.ref.svnlook">
    <title><command>svnlook</command></title>
    
    <para><command>svnlook</command>是检验Subversion版本库不同方面的命令行工具，它不会对版本库有任何修改&mdash;它只是用来<quote>看</quote>。<command>svnlook</command>通常被版本库钩子使用，但是版本库管理也会发现它在诊断目的上也非常有用。
   </para>

    <para>因为<command>svnlook</command>通过直接版本库访问（因此只可以在保存版本库的机器上工作）工作，所以他通过版本库的路径访问，而不是URL。</para>

    <para>如果没有指定修订版本或事物，<command>svnlook</command>缺省的是版本库最年轻的（最新的）修订版本。
    </para>
    
    <!-- =============================================================== -->
    <sect2 id="svn.ref.svnlook.sw">
      <title><command>svnlook</command>选项</title>
      
      <para><command>svnlook</command>的选项是全局的，就像<command>svn</command>和<command>svnadmin</command>；然而，大多数选项只会应用到一个子命令，因为<command>svnlook</command>的功能是（有意的）限制在一定范围的。
     </para>

      <variablelist>

        <varlistentry>
          <term><option>--no-diff-deleted</option></term>
          <listitem>
            <para>防止<command>svnlook</command>打印删除文件的区别，缺省的行为方式是当一个文件在一次事物/修订版本中删除后，得到的结果与保留这个文件的内容变成空相同。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--revision</option>
            (<option>-r</option>)</term>
          <listitem>
            <para>指定要进行检查的特定修订版本。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--revprop</option></term>
          <listitem>
            <para>操作针对修订版本属性，而不是Subversion文件或目录的属性。这个选项需要你传递<option>--revision</option>
              (<option>-r</option>)选项，更多关于未版本化属性的细节见<xref
              linkend="svn.reposadmin.basics.revprops"/></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--transaction</option>
            (<option>-t</option>)</term>
          <listitem>
            <para>指定一个希望检查的特定事物ID。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--show-ids</option></term>
          <listitem>
            <para>显示文件系统树中每条路径的文件系统节点修订版本ID。</para>
          </listitem>
        </varlistentry>

      </variablelist>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.ref.svnlook.c">
      <title><command>svnlook</command></title>

      <refentry id="svn.ref.svnlook.c.author">
        <refnamediv>
          <refname>svnlook author</refname>
          <refpurpose>打印作者。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnlook author REPOS_PATH</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>打印版本库一个修订版本或者事物的作者。</para>
        </refsect1>

        <refsect1>
          <title>选项</title>
          
          <screen>
--revision (-r)
--transaction (-t)
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

        <para><command>svnlook author</command>垂手可得，但是并不令人激动：
        </para>

          <screen>
$ svnlook author -r 40 /usr/local/svn/repos 
sally
</screen>            

        </refsect1>
      </refentry>

      <refentry id="svn.ref.svnlook.c.cat">
        <refnamediv>
          <refname>svnlook cat</refname>
          <refpurpose>打印一个文件的内容。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnlook cat REPOS_PATH PATH_IN_REPOS</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>打印一个文件的内容。</para>

          </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--revision (-r)
--transaction (-t)
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>这会显示事物<literal>ax8</literal>中一个文件的内容，位于<filename>/trunk/README</filename>：
         </para>

          <screen>
$ svnlook cat -t ax8 /usr/local/svn/repos /trunk/README

               Subversion, a version control system.
               =====================================

$LastChangedDate: 2003-07-17 10:45:25 -0500 (Thu, 17 Jul 2003) $

Contents:

     I. A FEW POINTERS
    II. DOCUMENTATION
   III. PARTICIPATING IN THE SUBVERSION COMMUNITY
&hellip;
</screen>
          
        </refsect1>
      </refentry>

      <refentry id="svn.ref.svnlook.c.changed">
        <refnamediv>
          <refname>svnlook changed</refname>
          <refpurpose>打印修改的路径。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnlook changed REPOS_PATH</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>打印在特定修订版本或事物修改的路径，也是在前两列使用<quote>svn
            update样式的</quote>状态字符：
           </para>          
           <variablelist>
            
            <varlistentry>
              <term>'<literal>A </literal>'</term>
              <listitem>
                <para>条目添加到版本库。</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>'<literal>D </literal>'</term>
              <listitem>
                <para>条目从版本库删除。</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>'<literal>U </literal>'</term>
              <listitem>
                <para>文件内容改变了。</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>'<literal>_U</literal>'</term>
              <listitem>
                <para>条目属性改变了。</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>'<literal>UU</literal>'</term>
              <listitem>
                <para>文件内容和属性修改了。</para>
              </listitem>
            </varlistentry>

          </variablelist>

          <para>文件和目录可以区分，目录路径后面会显示字符'<literal>/</literal>'。
          </para>

        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--revision (-r)
--transaction (-t)
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>显示在测试版本库修订版本39修改的文件列表：
          </para>

          <screen>
$ svnlook changed -r 39 /usr/local/svn/repos
A   trunk/vendors/deli/
A   trunk/vendors/deli/chips.txt
A   trunk/vendors/deli/sandwich.txt
A   trunk/vendors/deli/pickle.txt
U   trunk/vendors/baker/bagel.txt
_U  trunk/vendors/baker/croissant.txt
UU  trunk/vendors/baker/pretzel.txt
D   trunk/vendors/baker/baguette.txt
</screen>
          
        </refsect1>
      </refentry>

      <refentry id="svn.ref.svnlook.c.date">
        <refnamediv>
          <refname>svnlook date</refname>
          <refpurpose>打印时间戳。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnlook date REPOS_PATH</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>打印版本库一个修订版本或事物的时间戳。</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--revision (-r)
--transaction (-t)
</screen>
        </refsect1>
        
        <refsect1>
          <title>例子</title>
          
          <para>显示测试版本库修订版本40的日期：</para>

          <screen>            
$ svnlook date -r 40 /tmp/repos/
2003-02-22 17:44:49 -0600 (Sat, 22 Feb 2003)
</screen>

        </refsect1>
      </refentry>

      <refentry id="svn.ref.svnlook.c.diff">
        <refnamediv>
          <refname>svnlook diff</refname>
          <refpurpose>打印修改的文件和属性的区别。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnlook diff REPOS_PATH</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>打印版本库中GNU样式的文件和属性修改区别。
          </para>
        </refsect1>

        <refsect1>
          <title>选项</title>
          
          <screen>
--revision (-r)
--transaction (-t)
--no-diff-added
--no-diff-deleted
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>
          
          <para>这显示了一个新添加的（空的）文件，一个删除的文件和一个拷贝的文件：
          </para>

          <screen>
$ svnlook diff -r 40 /usr/local/svn/repos/
Copied: egg.txt (from rev 39, trunk/vendors/deli/pickle.txt)

Added: trunk/vendors/deli/soda.txt
==============================================================================

Modified: trunk/vendors/deli/sandwich.txt
==============================================================================
--- trunk/vendors/deli/sandwich.txt	(original)
+++ trunk/vendors/deli/sandwich.txt	2003-02-22 17:45:04.000000000 -0600
@@ -0,0 +1 @@
+Don't forget the mayo!

Modified: trunk/vendors/deli/logo.jpg
==============================================================================
(Binary files differ)

Deleted: trunk/vendors/deli/chips.txt
==============================================================================

Deleted: trunk/vendors/deli/pickle.txt
==============================================================================
</screen>
          
          <para>如果一个文件有非文本的<literal>svn:mime-type</literal>属性，区别不会明确显示。
          </para>
        </refsect1>
      </refentry>

      <refentry id="svn.ref.svnlook.c.dirs-changed">
        <refnamediv>
          <refname>svnlook dirs-changed</refname>
          <refpurpose>打印本身修改的目录。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnlook dirs-changed REPOS_PATH</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>打印本身修改（属性编辑）或子文件修改的目录。
          </para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--revision (-r)
--transaction (-t)
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>这显示了在我们的实例版本库中在修订版本40修改的目录：</para>

          <screen>
$ svnlook dirs-changed -r 40 /usr/local/svn/repos
trunk/vendors/deli/
</screen>
          
        </refsect1>
      </refentry>

      <refentry id="svn.ref.svnlook.c.help">
        <refnamediv>
          <refname>svnlook help</refname>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>Also svnlook -h and svnlook -?.</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>显示svnlook的帮助信息，这个命令如同<command>svn help</command>的兄弟，也是你的朋友，即使你从不调用它，并且忘掉了邀请它加入你的上一次聚会。
          </para>
        </refsect1>

        <refsect1>
          <title>别名</title>
          <para>?, h</para>
        </refsect1>

      </refentry>

      <refentry id="svn.ref.svnlook.c.history">
        <refnamediv>
          <refname>svnlook history</refname>
          <refpurpose>打印版本库（如果没有路径，则是根目录）某一个路径的历史。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnlook history REPOS_PATH 
            [PATH_IN_REPOS]</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>打印版本库（如果没有路径，则是根目录）某一个路径的历史。
          </para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--revision (-r)
--show-ids
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>这显示了实例版本库中作为修订版本20的路径<filename>/tags/1.0</filename>的历史输出。
          </para>

          <screen>
$ svnlook history -r 20 /usr/local/svn/repos /tags/1.0 --show-ids
REVISION   PATH &lt;ID&gt;
--------   ---------
      19   /tags/1.0 &lt;1.2.12&gt;
      17   /branches/1.0-rc2 &lt;1.1.10&gt;
      16   /branches/1.0-rc2 &lt;1.1.x&gt;
      14   /trunk &lt;1.0.q&gt;
      13   /trunk &lt;1.0.o&gt;
      11   /trunk &lt;1.0.k&gt;
       9   /trunk &lt;1.0.g&gt;
       8   /trunk &lt;1.0.e&gt;
       7   /trunk &lt;1.0.b&gt;
       6   /trunk &lt;1.0.9&gt;
       5   /trunk &lt;1.0.7&gt;
       4   /trunk &lt;1.0.6&gt;
       2   /trunk &lt;1.0.3&gt;
       1   /trunk &lt;1.0.2&gt;
</screen>
          
        </refsect1>
      </refentry>

      <refentry id="svn.ref.svnlook.c.info">
        <refnamediv>
          <refname>svnlook info</refname>
          <refpurpose>打印作者、时间戳、日志信息大小和日志信息。
          </refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnlook info REPOS_PATH</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>打印作者、时间戳、日志信息大小和日志信息。</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--revision (-r)
--transaction (-t)
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>显示了你的实例版本库在修订版本40的信息输出。</para>

          <screen>
$ svnlook info -r 40 /usr/local/svn/repos
sally
2003-02-22 17:44:49 -0600 (Sat, 22 Feb 2003)
15
Rearrange lunch.
</screen>
          
        </refsect1>
      </refentry>


      <refentry id="svn.ref.svnlook.c.lock">
        <refnamediv>
          <refname>svnlook lock</refname>
          <refpurpose>如果版本库路径已经被锁定，描述它。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnlook lock REPOS_PATH PATH_IN_REPOS</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>打印<replaceable>PATH_IN_REPOS</replaceable>锁定的所有信息，如果<replaceable>PATH_IN_REPOS</replaceable>没有锁定，则不打印任何内容。</para>
        </refsect1>

        <refsect1>
          <title>选项</title>
            
          <para>无</para>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>这描述了文件<filename>tree.jpg</filename>的锁定。</para>

          <screen>
$ svnlook lock /svn/repos tree.jpg
UUID Token: opaquelocktoken:ab00ddf0-6afb-0310-9cd0-dda813329753
Owner: harry
Created: 2005-07-08 17:27:36 -0500 (Fri, 08 Jul 2005)
Expires: 
Comment (1 line):
Rework the uppermost branches on the bald cypress in the foreground.
</screen>
          
        </refsect1>
      </refentry>


      <refentry id="svn.ref.svnlook.c.log">
        <refnamediv>
          <refname>svnlook log</refname>
          <refpurpose>打印日志信息。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnlook log REPOS_PATH</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>打印日志信息。</para>
        </refsect1>

        <refsect1>
          <title>选项</title>
          
          <screen>
--revision (-r)
--transaction (-t)
</screen>
        </refsect1>
        
        <refsect1>
          <title>例子</title>
          
          <para>这显示了实例版本库在修订版本40的日志输出：</para>

          <screen>
$ svnlook log /tmp/repos/
Rearrange lunch.
</screen>
          
        </refsect1>
      </refentry>

      <refentry id="svn.ref.svnlook.c.propget">
        <refnamediv>
          <refname>svnlook propget</refname>
          <refpurpose>打印版本库中一个路径一个属性的原始值。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnlook propget REPOS_PATH PROPNAME [PATH_IN_REPOS]</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>列出版本库中一个路径一个属性的值。</para>

          </refsect1>

        <refsect1>
          <title>别名</title>
          <para>pg, pget</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--revision (-r)
--transaction (-t)
--revprop
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>这显示了<literal>HEAD</literal>修订版本中文件<filename>/trunk/sandwich</filename>的<quote>seasonings</quote>属性的值：</para>

          <screen>
$ svnlook pg /usr/local/svn/repos seasonings /trunk/sandwich
mustard
</screen>

        </refsect1>
      </refentry>

      <refentry id="svn.ref.svnlook.c.proplist">
        <refnamediv>
          <refname>svnlook proplist</refname>
          <refpurpose>打印版本化的文件和目录的属性名称和值。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnlook proplist REPOS_PATH [PATH_IN_REPOS]</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>列出版本库中一个路径的属性，使用<option>--verbose</option>选项也会显示所有的属性值。
          </para>

          </refsect1>

        <refsect1>
          <title>别名</title>
          <para>pl, plist</para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--revision (-r)
--transaction (-t)
--verbose (-v)
--revprop
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <para>这显示了<literal>HEAD</literal>修订版本中<filename>/trunk/README</filename>的属性名称：
          </para>

          <screen>
$ svnlook proplist /usr/local/svn/repos /trunk/README
  original-author
  svn:mime-type
</screen>

          <para>这与前一个例子是同一个命令，但是同时显示了属性值：
          </para>

          <screen>
$ svnlook --verbose proplist /usr/local/svn/repos /trunk/README
  original-author : fitz
  svn:mime-type : text/plain
</screen>
          
        </refsect1>
      </refentry>

      <refentry id="svn.ref.svnlook.c.tree">
        <refnamediv>
          <refname>svnlook tree</refname>
          <refpurpose>打印树。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnlook tree REPOS_PATH [PATH_IN_REPOS]</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>打印树，从<replaceable>PATH_IN_REPOS</replaceable>（如果提供，会作为树的根）开始，可以选择显示节点修订版本ID。
         </para>
        </refsect1>

        <refsect1>
          <title>选项</title>

          <screen>
--revision (-r)
--transaction (-t)
--show-ids
</screen>
        </refsect1>

        <refsect1>
          <title>例子</title>
          
          <para>这会显示实例版本库中修订版本40的树输出（包括节点ID）：
          </para>

          <screen>
$ svnlook tree -r 40 /usr/local/svn/repos --show-ids
/ &lt;0.0.2j&gt;
 trunk/ &lt;p.0.2j&gt;
  vendors/ &lt;q.0.2j&gt;
   deli/ &lt;1g.0.2j&gt;
    egg.txt &lt;1i.e.2j&gt;
    soda.txt &lt;1k.0.2j&gt;
    sandwich.txt &lt;1j.0.2j&gt;
</screen>
          
        </refsect1>
      </refentry>

      <refentry id="svn.ref.svnlook.c.uuid">
        <refnamediv>
          <refname>svnlook uuid</refname>
          <refpurpose>打印版本库的<literal>UUID</literal>。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnlook uuid REPOS_PATH</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>打印版本库的<literal>UUID</literal>，UUID是版本库的<emphasis>u</emphasis>niversal <emphasis>u</emphasis>nique
            <emphasis>ID</emphasis>entifier（全局唯一标示），Subversion客户端可以使用这个标示区分不同的版本库。
           </para>
        </refsect1>

        <refsect1>
          <title>例子</title>

          <screen>          
$ svnlook uuid /usr/local/svn/repos
e7fe1b91-8cd5-0310-98dd-2f12e793c5e8
</screen>

        </refsect1>
      </refentry>

      <refentry id="svn.ref.svnlook.c.youngest">
        <refnamediv>
          <refname>svnlook youngest</refname>
          <refpurpose>打印最年轻的修订版本号。</refpurpose>
        </refnamediv>
        <refsect1>
          <title>概要</title>
          <programlisting>svnlook youngest REPOS_PATH</programlisting>
        </refsect1>
        <refsect1>
          <title>描述</title>

          <para>打印一个版本库最年轻的修订版本号。</para>
        </refsect1>

        <refsect1>
          <title>例子</title>

        <para>这显示了在实例版本库显示最年轻的修订版本：</para>

          <screen>          
$ svnlook youngest /tmp/repos/ 
42
</screen>

        </refsect1>
      </refentry>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.ref.svnserve">

    <title><command>svnserve</command></title>
    
    <para><command>svnserve</command>允许Subversion版本库使用<literal>svn</literal>网络协议，你可以作为独立服务器进程运行svnserve，或者是使用其它进程，如<command>inetd</command>、<command>xinetd</command>或<command>sshd</command>为你启动进程。
   </para>

    <para>一旦客户端已经选择了一个版本库来传递它的URL，<command>svnserve</command>会读取版本库目录的<filename>conf/svnserve.conf</filename>文件，来检测版本库特定的设置，如使用哪个认证数据库和应用怎样的授权策略。关于<filename>svnserve.conf</filename>文件的详情见<xref linkend="svn.serverconfig.svnserve"/>。
   </para>
    
    <!-- =============================================================== -->
    <sect2 id="svn.ref.svnserve.sw">
      <title><command>svnserve</command>选项</title>
      
      <para>不象前面描述的例子，<command>svnserve</command>没有子命令&mdash;<command>svnserve</command>完全通过选项控制。
     </para>

      <variablelist>

        <varlistentry>
          <term><option>--daemon</option> (<option>-d</option>)</term>
          <listitem>
            <para>导致<command>svnserve</command>以守护进程方式运行，<command>svnserve</command>维护本身并且接受和服务svn端口（缺省3690）的TCP/IP连接。
           </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--listen-port</option>=<replaceable>PORT</replaceable></term>
          <listitem>
            <para>在守护进程模式时导致svnserve监听<replaceable>PORT</replaceable>端口。
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--listen-host</option>=<replaceable>HOST</replaceable></term>
          <listitem>
            <para><command>svnserve</command>监听的<replaceable>HOST</replaceable>，可能是一个主机名或是一个IP地址。
           </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--foreground</option></term>
          <listitem>
            <para>当与<option>-d</option>一起使用，会导致<command>svnserve</command>停留在前台，主要用来调试。
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--inetd</option> (<option>-i</option>)</term>
          <listitem>
            <para>导致<command>svnserve</command>使用标准输出/标准输入文件描述符，更准确的是使用<command>inetd</command>作为守护进程。
           </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--help</option> (<option>-h</option>)</term>
          <listitem>
            <para>显示有用的摘要和选项。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--version</option></term>
          <listitem>
            <para>显示版本信息，版本库后端存在和可用的模块列表。
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--root</option>=<replaceable>ROOT</replaceable>
          (<option>-r</option>=<replaceable>ROOT</replaceable>)</term>
          <listitem>
            <para>设置<command>svnserve</command>服务的版本库的虚拟根，客户端提供的URL中显示的路径会解释为这个根的相对路径，不会允许离开这个根。
           </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--tunnel</option> (<option>-t</option>)</term>
          <listitem>
            <para>导致<command>svnserve</command>以管道模式运行，很像<command>inetd</command>操作的模式（服务于一个标准输入/标准输出的连接），除了连接是用当前uid的用户名预先认证过的这一点。这个选项在客户端使用如<command>ssh</command>之类的管道时使用。
           </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--tunnel-user NAME</option></term>
          <listitem>
            <para>与<option>--tunnel</option>选项结合使用；告诉svnserve假定<replaceable>NAME</replaceable>就是认证用户，而不是svnserve进程的UID用户，当希望多个用户通过SSH共享同一个系统帐户，但是维护各自的提交标示符时非常有用。
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--threads</option> (<option>-T</option>)</term>
          <listitem>
            <para>当以守护进程模式运行，导致<command>svnserve</command>为每个连接产生一个线程而不是一个进程，<command>svnserve</command>进程本身在启动后会一直在后台。
           </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--listen-once</option> (<option>-X</option>)</term>
          <listitem>
            <para>导致<command>svnserve</command>在svn端口接受一个连接，维护完成它退出。这个选项主要用来调试。
           </para>
          </listitem>
        </varlistentry>

      </variablelist>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.ref.svnversion">

    <title><command>svnversion</command></title>
    
    <refentry id="svn.ref.svnversion.re">
      <refnamediv>
        <refname>svnversion</refname>
        <refpurpose>总结工作拷贝的本地修订版本。</refpurpose>
      </refnamediv>

      <refsect1 id="svn.ref.svnversion.re.syn">
        <title>概要</title>
        <programlisting>svnversion [OPTIONS] WC_PATH [TRAIL_URL]</programlisting>
      </refsect1>

      <refsect1 id="svn.ref.svnversion.re.desc">
        <title>描述</title>

        <para><command>svnversion</command>是用来总结工作拷贝修订版本混合的程序，结果修订版本号或范围会写到标准输出。
       </para>

        <para>如果提供<replaceable>TRAIL_URL</replaceable>，URL的尾端部分用来监测是否<replaceable>WC_PATH</replaceable>本身已经跳转（监测<replaceable>WC_PATH</replaceable>的跳转不需要依赖<replaceable>TRAIL_URL</replaceable>）。</para>

      </refsect1>

      <refsect1 id="svn.ref.svnversion.re.sw">
        <title>选项</title>

        <para>像<command>svnserve</command>，<command>svnversion</command>没有子命令，只有选项。
        </para>

        <variablelist>
    
          <varlistentry>
            <term><option>--no-newline</option> (<option>-n</option>)</term>
            <listitem>
              <para>忽略输出的尾端新行。.</para>
            </listitem>
          </varlistentry>
    
          <varlistentry>
            <term><option>--committed</option> (<option>-c</option>)</term>
            <listitem>
              <para>使用最后修改修订版本而不是当前的（例如，本地存在的最高修订版本）修订版本。
              </para>
            </listitem>
          </varlistentry>
    
          <varlistentry>
            <term><option>--help</option> (<option>-h</option>)</term>
            <listitem>
              <para>打印帮助摘要。</para>
            </listitem>
          </varlistentry>
    
          <varlistentry>
            <term><option>--version</option></term>
            <listitem>
              <para>打印<command>svnversion</command>，如果没有错误退出。
              </para>
            </listitem>
          </varlistentry>

        </variablelist>
      </refsect1>

      <refsect1 id="svn.ref.svnversion.re.examples">
        <title>例子</title>

        <para>如果工作拷贝都是一样的修订版本（例如，在更新后那一刻），会打印修订版本：
        </para>

        <screen>$ svnversion .
4168</screen>

        <para>添加TRAIL_URL来展示工作拷贝不是从你希望的地方跳转过来的：</para>

        <screen>$ svnversion . /repos/svn/trunk
4168</screen>

        <para>对于混合修订版本的工作拷贝，修订版本的范围会被打印：</para>

        <screen>$ svnversion .
4123:4168</screen>

        <para>如果工作拷贝包含修改，后面会紧跟一个"M"：</para>

        <screen>$ svnversion .
4168M</screen>

        <para>如果工作拷贝已经跳转，后面会有一个"S"：</para> 

        <screen>$ svnversion .
4168S</screen>

        <para>因此，这里是一个混合修订版本，跳转的工作拷贝包含了一些本地修改：
        </para>

        <screen>$ svnversion .
4212:4168MS</screen>

        <para>如果从一个目录而不是工作拷贝调用，<command>svnversion</command>假定它是一个导出的工作拷贝并且打印"exported"：
       </para>

        <screen>$ svnversion .
exported</screen>

      </refsect1>

    </refentry>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.ref.mod_dav_svn">

    <title><command>mod_dav_svn</command></title>
    
    <refentry id="svn.ref.mod_dav_svn.conf">
      <refnamediv>

        <refname><literal>mod_dav_svn</literal> Configuration
        Directives</refname> <refpurpose>Apache通过Apache HTTP服务器用来维护Subversion版本库配置指示。
        </refpurpose> 

      </refnamediv>

      <refsect1 id="svn.ref.mod_dav_svn.conf.desc">
        <title>描述</title>

        <para>这个小节主要描述了Subversion Apache配置的每个指示，关于Apache配置Subversion的更多信息见<xref
          linkend="svn.serverconfig.httpd"/>。
          </para>

      </refsect1>

      <refsect1 id="svn.ref.mod_dav_svn.conf.directives">
        <title>指示</title>

        <variablelist>
    
          <varlistentry>
            <term><literal>DAV svn</literal></term>
            <listitem>

              <para>这个指示必须包含在所有Subversion版本库的<literal>Directory</literal>或<literal>Location</literal>块中，它告诉httpd使用Subversion的后端，用mod_dav来处理所有的请求。
             </para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNAutoversioning On</literal></term>
            <listitem>

              <para>这个指示允许WebDAV客户端的请求导致自动提交，每个修订版本会产生一个普通的日志信息。如果你开启了自动版本化，你很可能需要设置<literal>ModMimeUsePathInfo On</literal>，这样<literal>mod_mime</literal>可以自动的（像<literal>mod_mime</literal>一样好，当然）将<literal>svn:mime-type</literal>设置为正确的mime-type值。更多信息见<xref
                linkend="svn.webdav"/>。</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNPath</literal></term>
            <listitem>

              <para>这个指示指定Subversion版本库文件文件系统的位置，在一个Subversion版本库的配置块里，必须提供这个指示或<literal>SVNParentPath</literal>，但不能同时存在。
             </para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNSpecialURI</literal></term>
            <listitem>

              <para>指定特定Subversion资源的URI部分（命名空间），缺省是<quote><literal>!svn</literal></quote>，大多数管理员不会用到这个指示。只有那些必须要在版本库中放一个名字为<filename>!svn</filename>的文件时需要设置。如果你在一个已经使用中的服务器上这样修改，它会破坏所有的工作拷贝，你的用户会拿着叉子和火炬追杀你。
             </para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNReposName</literal></term>
            <listitem>

              <para>指定Subversion版本库在<literal>HTTP GET</literal>请求中使用的名字，这个值会作为所有目录列表（当你用web浏览器察看Subversion版本库时会看到）的标题，这个指示是可选的。
              </para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNIndexXSLT</literal></term>
            <listitem>

              <para>目录列表所使用的XSL转化的URI，这个指示可选。
              </para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNParentPath</literal></term>
            <listitem>

              <para>指定子目录会是版本库的父目录在文件系统的位置，在一个Subversion版本库的配置块里，必须提供这个指示或<literal>SVNPath</literal>，但不能同时存在。</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNPathAuthz</literal></term>
            <listitem>

              <para>控制开启和关闭路径为基础的授权，更多细节见<xref
                linkend="svn.serverconfig.httpd.authz.pathauthzoff"/>。
              </para>

            </listitem>
          </varlistentry>

        </variablelist>
      </refsect1>
    </refentry>
  </sect1>



</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
