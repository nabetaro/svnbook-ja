<?xml version="1.0" encoding="UTF-8"?>
<chapter id="svn-ch-5">
  <title>版本库管理</title>

  <simplesect>
    <para>Subversion版本库是保存任意数量项目版本化数据的中央仓库，因此，版本库成为管理员关怀和爱护的对象。版本库的维护一般并不需要太多的关注，但为了避免一些潜在的问题和解决一些实际问题，理解怎样适当的配置和维护还是非常重要的。</para>

    <para>在这一章里，我们将讨论如何建立和配置一个Subversion版本库，还会讨论版本库的维护，包括<command>svnlook</command>和<command>svnadmin</command>工具的使用（它们都包含在Subversion中）。我们将说明一些常见的问题和错误，并提供一些安排版本库数据的建议。</para>

    <para>如果您只是以普通用户的身份访问版本库对数据进行版本控制（就是说通过Subversion客户端），您完全可以跳过本章。但是如果您已经是或打算成为Subversion版本库的管理员，<footnote>
        <para>这可能听起来很崇高， 但我们所指的只是那些对管理别人工作拷贝数据之外的神秘领域感兴趣的人。</para>
      </footnote>您一定要关注一下本章的内容。</para>
  </simplesect>

  <!-- ******************************************************************* -->

  <!-- *** 第一部分:  版本库基本知识                                   *** -->

  <!-- ******************************************************************* -->

  <sect1 id="svn-ch-5-sect-1">
    <title>版本库基本知识</title>

    <para>在进入版本库管理这块宽广的主题之前，让我们进一步确定一下版本库的定义，它是怎样工作的？让人有什么感觉？它希望茶是热的还是冰的，加糖或柠檬吗？作为一名管理员，你应该既从逻辑视角－数据在版本库中如何展示，又能从物理具体细节的视角－版本库如何响应一个非Subversion的工具，来理解版本库的组成。下面的小节从一个比较高的层面覆盖了这些基本概念。</para>

    <!-- ***************************************************************** -->

    <sect2 id="svn-ch-5-sect-1.1">
      <title>理解事务和修订版本</title>

      <para>从概念上来说，Subversion的版本库就是一串目录树。每一个目录树，就是版本库的文件和目录在某一时刻的快照。这些快照是客户端使用者操作的结果，叫做修订版本。</para>

      <para>每一个修订版本都是以事务树开始其生命周期。做提交操作时，客户端建立了一个映射本地修改的Subversion事务（加上客户端提交操作后任何对版本库的更改），然后指导版本库将该树存储为下一个快照。要是提交成功，这个事务就会成为新的修订版本树，并被赋予新的修订版本号。如果因为某些原因提交失败，事务会被销毁，客户端将被通知这个事务失败。</para>

      <para>更新的动作也类似这样。客户端建立一个临时的事务树，映射工作文件的状态。然后版本库比较事务树和被请求的修订版本树（通常是最新的，也就是最“年轻”的修订版本树），然后发回消息通知客户端哪些变更需要将拷贝发送到修订版本树。更新完成后，临时事务将被删除。</para>

      <para>事务树的使用，是对版本库中版本控制文件系统产生永久变更的唯一方法。一个事务的生命周期非常灵活，了解这一点很重要。在更新的情况下，事务只是马上会被销毁的临时树。在提交的情况下，事务会变成固定的修订版本（如果失败的情况下，则会被删除）。在出现错误或臭虫的情况下，事务可能会被留在版本库中（不会影响任何东西，但是会占据空间）。</para>

      <para>理论上，某天整个流程能够发展到对事务的流程控制更加细密。可以想象一个系统，在客户端完成操作，将要保存到版本库中时，每个加到它的事务都变成一个修订版本。这将会使每一个新的提交都可以被别人查看到，也许是主管，也许是质量保证小组，他们可以决定是要接收这个事务成为修订版本，还是放弃它。</para>
    </sect2>

    <!-- ***************************************************************** -->

    <sect2 id="svn-ch-5-sect-1.2">
      <title>未受版本控制的属性</title>

      <para>事务和修订版本在Subversion版本库中可以附加属性。这些属性通常是属性名和属性值的映射，被用来存储与对应档案树有关的信息。这些属性名和属性值跟你的其他数据一样，被存储在版本库文件系统中。</para>

      <para>修订版本和事务的属性对于跟一个资料树相关，但不是完全与这些目录和文件相关的性质很有用－即并不被客户端工作拷贝所管理的属性。举例来说，当一个新的提交事务在版本库中被创建时，Subversion给这个事务添加一个叫做<literal>svn:date</literal>的属性—一个表示事务何时被创建的时间戳。当提交进程结束，该事务成为一个固定的版本，这个档案树被赋予一个用来存储这个版本作者的用户名属性（<literal>svn:author</literal>）和一个用来存储与这个修订版本关联的日志信息的属性（<literal>svn:log</literal>）。</para>

      <para>修订版本和事务的属性都是未受版本控制的－因为当它们被修改时，先前的值就被完全舍弃了。修订版本树自身是不能变更的，与之关联的属性可以修改。你可在日后添加、删除、修改修订版本的属性。如果你提交一个新的修订版本之后意识到遗漏了一些信息或在日志中有拼写错误，你可以直接以正确的信息覆盖<literal>svn:log</literal>的值。</para>
    </sect2>

    <!-- ***************************************************************** -->

    <sect2 id="svn-ch-5-sect-1.3">
      <title>版本库数据存储</title>

      <para>在Subversion1.1中，有两种方式在版本库中存储数据。一种是在BerkeleyDB数据库中存储数据；另一种是使用通常的格式，在文件中存储。因为Subversion的开发者称版本库为“版本化的文件系统”，他们接受了称后一种存储方式为FSFS，即使用本地操作系统文件系统来存储数据的版本化文件系统的习惯。</para>

      <para>建立一个版本库时，管理员必须决定使用BerkeleyDB还是FSFS。他们各有优缺点，我们将描述一下。它们任何一个都不比另一个更正式，访问版本库的程序与采用哪一种实现方式无关。访问程序并不知道版本库如何存储数据，它们只是从版本库的API读取到修订版本和事务树。</para>

      <para>下面的表从总体上比较了 Berkeley DB 和 FSFS 版本库。下一部分将会详细讲述细节。</para>

      <table id="svn-ch-5-table-1">
        <title>版本库数据存储对照表</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry>特性</entry>

              <entry>Berkeley DB</entry>

              <entry>FSFS</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>对操作中断的敏感</entry>

              <entry>很敏感；系统崩溃或者权限问题会导致数据库<quote>塞住</quote>，需要定期进行恢复。</entry>

              <entry>不敏感。</entry>
            </row>

            <row>
              <entry>可只读加载</entry>

              <entry>不能</entry>

              <entry>可以</entry>
            </row>

            <row>
              <entry>存储平台无关</entry>

              <entry>不能</entry>

              <entry>可以</entry>
            </row>

            <row>
              <entry>可从网络文件系统访问</entry>

              <entry>不能</entry>

              <entry>可以</entry>
            </row>

            <row>
              <entry>版本库大小</entry>

              <entry>稍大</entry>

              <entry>稍小</entry>
            </row>

            <row>
              <entry>可量测性： 修订版本树数量限制</entry>

              <entry>数据库; 没有限制</entry>

              <entry>许多古老的本地文件系统不能处理单一目录中文件过多的情况（上千个文件）。</entry>
            </row>

            <row>
              <entry>可量测性: 文件较多的目录</entry>

              <entry>较慢</entry>

              <entry>较快</entry>
            </row>

            <row>
              <entry>速度：检出最新的代码</entry>

              <entry>较快</entry>

              <entry>较慢</entry>
            </row>

            <row>
              <entry>速度： 大的提交</entry>

              <entry>较慢，但是时间被分配在整个提交操作中</entry>

              <entry>较快，但是最后较长的延时可能会导致客户端操作超时</entry>
            </row>

            <row>
              <entry>组访问权处理</entry>

              <entry>对于用户的umask设置十分敏感，最好只由一个用户访问。</entry>

              <entry>对umask设置不敏感</entry>
            </row>

            <row>
              <entry>功能成熟时间</entry>

              <entry>2001年开始使用</entry>

              <entry>2004年开始使用</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <!-- *****************************************************************-->

      <sect3 id="svn-ch-5-sect-1.3.1">
        <title>Berkeley DB</title>

        <para>在Subversion的初始设计阶段，开发者因为多种原因而决定采用Berkeley
        DB，比如它的开源协议、事务支持、可靠性、性能、简单的API、线程安全、支持游标等。</para>

        <para>BerkeleyDB提供了真正的事务支持－这或许是它最强大的特性。访问你的Subversion版本库的多个进程不必担心偶尔会破坏其他进程的数据。事务系统提供的隔离对于任何给定的操作，Subversion版本库代码看到的只是数据库的静态剪影－而不是一个受其他进程影响不断变化的情况－并能够根据该静态剪影作出操作决定。如果该操作决定正好同其他进程所做操作冲突，整个操作会回滚，就像什么都没有发生一样。然后Subversion优雅的使用一个更新的静态剪影重新开始操作。</para>

        <para>BerkeleyDB另一个强大的特性是热备份－不必“下线”就可以备份数据库环境的能力。我们将会在<xref
        linkend="svn-ch-5-sect-3.6" />讨论如何备份你的版本库，能够不停止系统对版本库做全面备份的好处是显而易见的。</para>

        <para>BerkeleyDB同时是一个可信赖的数据库系统。Subversion使用BerkeleyDB的日志工具，这意味着数据库先在磁盘上写一个日志文件，描述它将要做的修改，然后再做这些修改。这是为了确保如果哪里出了差错，数据库系统能回复到先前的检出点－一个在日志文件中已知的不会冲突的位置，重新开始事务直到数据存储成为一个可用的状态。更多关于BerkeleyDB日志文件的信息请查看<xref
        linkend="svn-ch-5-sect-3.3" />。</para>

        <para>每朵玫瑰都有刺，我们也必须记录一些BerkeleyDB已知的缺陷。首先，BerkeleyDB环境不是跨平台的。你不能简单的拷贝一个创建在Unix上的Subversion版本库到一个Windows系统，也无法期望创建在Unix系统上的版本库能顺利移植到Windows系统正常运行。尽管BerkeleyDB数据库格式架构设计独立，有一些其他环境方面没有独立出来。其次，Subversion使用BerkeleyDB不能在95/98系统上运行－如果你需要将版本库建在一个Windows机器上，请装到Windows2000或WindowsXP上。另外，不要在网络上共享BerkeleyDB版本库。尽管BerkeleyDB承诺如果按照一套特定规范的话，可以在网络共享上正常运行，但实际上已知的共享类型几乎都不满足这套规范。</para>

        <para>最后，因为BerkeleyDB是以连接库的形式被Subversion使用，它对于中断比典型的关系型数据库系统更为敏感。大多数SQL系统，举例来说，有一个主服务进程来协调对数据库表的访问。如果一个访问数据库的程序因为某种原因出现问题，数据库守护进程察觉到连接中断会做一些清理。因为数据库守护进程是唯一访问数据库表的进程，应用程序不需要担心访问许可的冲突。但是，这些情况与BerkeleyDB不同。Subversion（和使用Subversion库的程序）直接访问数据库的表，这意味着如果有一个程序崩溃，就会使数据库处于一个暂时的不一致、不可访问的状态。当这种情况发生时，管理员需要让BerkeleyDB回复到一个检查点，这的确有点讨厌。除了崩溃的进程，还有一些情况能让版本库出现异常，比如程序在所有权上发生冲突或者数据库文件的访问权限。BerkeleyDB版本库非常快，还可以升级，不过最好使用一个单独的服务进程，通过一个用户来访问－比如Apache的<command>httpd</command>或<command>svnserve</command>（参见<xref linkend="svn-ch-6" />）—而不是多用户通过<literal>file:///</literal>或<literal>svn+ssh://</literal>URL的方式多用户访问。如果将BerkeleyDB版本库直接用作多用户访问，请先阅读<xref linkend="svn-ch-6-sect-5" />。</para>
      </sect3>

      <!-- ***************************************************************** -->

      <sect3 id="svn-ch-5-sect-1.3.2">
        <title>FSFS</title>

        <para>在2004年中期，另一种版本库存储系统慢慢形成了：一种不需要数据库的存储系统。FSFS版本库在一个文件中存储修订版本树，所以版本库中所有的修订版本都在一个子文件夹中有限的几个文件里。事务在单独的子目录中被创建，创建完成后，一个单独的事务文件被创建并移动到修订版本目录，这保证提交是原子性的。因为一个修订版本文件是持久不可改变的，版本库也可以做到热备份，就象BerkeleyDB版本库一样。</para>

        <para>修订版本文件格式代表了一个修订版本的目录结构，文件内容，和其他修订版本树中相关信息。不像BerkeleyDB数据库，这种存储格式可跨平台并且与CPU架构无关。因为没有日志或用到共享内存的文件，数据库能被网络文件系统安全的</para>

        <para>访问和检查只读环境。缺少数据库花消同时也意味着版本库的总体体积可以稍小一点。</para>

        <para>FSFS也有一种不同的表现属性。当确定大量文件的存贮目录是，FSFS用O(N) 算法来填加入口，而
        Berkeley数据库则用(N^2)算法来重写整个目录。另一方面，与较早版本相比FSFS将最近版本的文件当作delta写入，这也意味着与在头版本的</para>

        <para>Berkeley数据库中获取整个文件相比检查最近的树会稍慢一点。当完成一个确认时，FSFS也会有一个更长的延迟，在某些极端情况下会导致</para>

        <para>客护端在等待回应时超时。</para>

        <para />

        <para />

        <para>最重要的区别是当出现错误时FSFS停滞不前。假如应用Berkeley处理时发生许可错误或突然崩溃系统，数据库会无法使用直到管理员</para>

        <para>恢复。假如在应用FSFS版本库发生同样的情况，版本库不会受到任何干扰。在最坏情况下也仅仅是一些处理信息被丢弃。</para>

        <para>唯一真正对FSFS不利的是它与Berkeley数据库相比相对不可靠。它没有接受用户的足够多的检验。仅在理论来说，它减少了新管理者的负担，</para>

        <para>以及较少有疑问的问题。在实践中，也只有时间才能在评判。</para>

        <para />
      </sect3>
    </sect2>
  </sect1>

  <!-- ******************************************************************* -->

  <!-- *** 第二部分:  版本库创建和配置                                 *** -->

  <!-- ******************************************************************* -->

  <sect1 id="svn-ch-5-sect-2">
    <title>版本库的创建和配置</title>

    <para>创建一个 Subversion 版本库出乎寻常的简单。 Subversion
    提供的<command>svnadmin</command> 工具，有一个执行这个功能的子命令。要建立一个新的版本库，只需要运行：</para>

    <screen>
$ svnadmin create /path/to/repos
</screen>

    <para>这个命令在目录<filename>/path/to/repos</filename>创建了一个新的版本库。这个新的版本库会以修订版本版本0开始其生命周期，里面除了最上层的根目录(<filename>/</filename>)，什么都没有。刚开始，修订版本0有一个修订版本</para>

    <para>属性<literal>svn:date</literal>，被设置为版本库创建的时间。</para>

    <para>在 Subversion 1.1中，版本库默认使用Berkeley
    DB后端存储方式来创建。在以后的发行版中这个行为会被改变。不管怎样，存储类型可以使用<option>--fs-type</option>
    参数显视的选择。:</para>

    <screen>
$ svnadmin create --fs-type fsfs /path/to/repos
$ svnadmin create --fs-type bdb /path/to/other/repos
</screen>

    <warning>
      <para>不要在网络共享上创建Berkeley DB版本库—它不能存在于诸如NFS， AFS， 或 Windows SMB的远程文件系统中。Berkeley 数据要求底层文件系统实现严格的</para>

      <para>POSIX语义锁定。几乎没有网络文件系统提供这些特征，假如你网络共享Berkeley数据库，结果是不可预知的——你当前发现的错误也许是几个月前的，你的版本库</para>

      <para>也会相当脆弱。</para>

      <para>假如你需要多台计算机来访问，你需要创造网络共享的FSFS版本库，而不是Berkeley数据库的版本库。或者更好的办法，你建立一个真正的服务方式（诸如Apache或<command>svnserve），把版本库放在</command>服务器能访问到的本地文件系统中，以便能通过网络访问。详情请参看<xref linkend="svn-ch-6" /></para>
    </warning>

    <para>你可能已经注意到了，<command>svnadmin</command>命令的路径参数只是一个规则的文件系统路径，而不是一个<command>svn</command>客户端程序访问版本库时使用的URL。<command>svnadmin</command>和<command>svnlook</command>都被认为是服务器端工具－</para>

    <para>它们使用在版本库所在的机器上，被用来检查或修改版本库，不能通过网络来执行任务。一个Subversion的新手通常会犯的错误，就是试图将URL（甚至<quote>本地</quote><literal>file:</literal>路径）传给这两个程序。</para>

    <para>所以，当你运行<command>svnadmin create</command>命令后，就在创建目录中有了一个全新的Subversion版本库。 让我们看一下在目录中实际都创建了什么东西。</para>

    <screen>
$ ls repos
conf/  dav/  db/  format  hooks/  locks/  README.txt
</screen>

    <para>除了<filename>README.txt</filename>和<filename>format</filename>文件，版本库目录由一群子目录组成。就像Subversion其他部分的设计一样，模块化是一个很重要的原则，而且层次化的组织要比杂乱无章好。下面是对新的版本库目录中，各个项目的简要介绍：</para>

    <variablelist>
      <varlistentry>
        <term>conf</term>

        <listitem>
          <para>一个存储版本库配置文件的目录。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>dav</term>

        <listitem>
          <para>提供给Apache和mod_dav_svn的目录，让它们存储自己的数据。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>db</term>

        <listitem>
          <para>你所有的受版本控制数据的所在之处。这个目录或者是个Berkeley DB环境（满是数据表和其他东西）或者是一个包含修订版本文件的FSFS环境。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>format</term>

        <listitem>
          <para>一个包含一个整数的文件，用来表示版本库配置的版本号码。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>hooks</term>

        <listitem>
          <para>一个存储钩子脚本模版的目录（还有钩子脚本本身， 如果你安装了的话）。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>locks</term>

        <listitem>
          <para>一个存储Subversion版本库锁定资料的目录，被用来追踪对版本库的访问。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>README.txt</term>

        <listitem>
          <para>这个文件只是用来告诉它的阅读者，他现在看的是 Subversion 的版本库。</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>一般来说，你不需要手动干预版本库。<command>svnadmin</command>工具应该足以用来处理对版本库的任何修改，或者你也可以使用第三方工具（比如BerkeleyDB的工具包）来调整部分版本库。不过还是会有些例外情况，我们会在这里提到。</para>

    <!-- ***************************************************************** -->

    <sect2 id="svn-ch-5-sect-2.1">
      <title>钩子脚本</title>

      <para>所谓钩子<firstterm>就是与一些版本库事件相关的程序，它由新修订版本所创，或是无形式属性的变更。每个钩子都携带有足够多的信息，说明那是什么事件，操作的对象，和触发事件的用户名。通过钩子的输出或返回状态，钩子程序能继续运行，停止或以某种方式挂起。</firstterm></para>

      <para>
        <firstterm>默认情况下，钩子的子目录中包含各种版本库钩子模板。</firstterm>
      </para>

      <screen>
$ ls repos/hooks/
post-commit.tmpl          pre-revprop-change.tmpl
post-revprop-change.tmpl  start-commit.tmpl
pre-commit.tmpl           
</screen>

      <para />

      <para>对于每个钩子的都有一个模板,该模版由Subversion资源库实现，由模版的脚本检查其内容，这样，你能看到脚本运行时所触发的事件及</para>

      <para>传给脚本的数据。同时，一些模版当于Subversion所提供的程序合用，来完成有用的任务，也提供了模版如何使用脚本的例子。要实际安装一个可用的钩子你需要在<filename>repos/hooks</filename></para>

      <para>目录下安装一些与钩子同名(如 <command>start-commit</command>或者<command>post-commit</command>)的能运行的程序或脚本。</para>

      <para>在Unix平台上，这是指提供一个与钩子同名的脚本或程序(或者是个shell 脚本，Python 程序，编译过的c语言二进制文件， 或其他东西) 。当然，脚本文件提供的信息不仅仅用来在Unix平台上简单的安装钩子，或是把合适模版复制到正好缺少的该模版文件的模版文件中。tmpl的扩充，钩子的客户化，都要确定脚本是可运行的。Windows用文件的扩展名来决定一个程序是否可运行，所以你要使程序的基本名与钩子同名，同时，它的扩展名是Windows系统所能辨认的，诸如<filename>exe</filename>
      或<filename>com</filename> 或<filename>批处理的bat。</filename></para>

      <para>Tip 由于安全原因，Subversion资源库在一个“空”环境中执行钩子脚本，这里所说的”空“是指没有任何环境变量，甚至
      <literal>$PATH</literal> or <literal>%PATH%</literal>。</para>

      <para>由于这个原因，令很多管理者很困惑的是，他们的钩子脚本手工运行是很好，可在Subversion中却不能运行。要注意，必须在你的钩子设置环境变量或为你的程序指定好绝对路径。</para>

      <para>目前Subversion有五种已实现了的钩子</para>

      <variablelist>
        <varlistentry>
          <term>
            <filename>start-commit</filename>
          </term>

          <listitem>
            <para>它在提交事务产生前已运行。它通常用来决定用户进行了特权操作。版本库传给该程序两个变量：到版本库的路径，和要进行操作的用户名。假如程序返回一个非零的返回值，在事务产生前停止该提交操作。假如钩子程序要在stderr中写入数据，它将排队送至客户端。</para>

            <para />
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <filename>pre-commit它在事务完成但在提交操作前运行。通常，该钩子用来保护那些由于内容或是地址不允许访问的commits（例如，你的site也许要求对一个确定的分支</filename>
          </term>

          <listitem>
            <para>的commits要包含从bug tracker中得到的icket number，或者ncoming log是非空的）版本库传给程序两个变量：到版本库的路径和要进行操作的用户名。假如程序返回一个非零的返回值，提交应当取消，事务应被删除。</para>

            <para>假如钩子 程序要在stderr中写入数据，它将排队送至客户端。</para>

            <para>分布式Subversion有一些控制脚本（在Subversion的源代码树的tools/hook-scripts目录中）来在pre-commit中实现pre-commit。另外还有<command>mod_authz_svn</command>Apache httpd可选模式，这可用来对个人目录进行读或写的控制。（详见<xref linkend="svn-ch-6-sect-4.4.2" />）。在以后的Subversion中，我们可以实现在文件系统中直接的访问控制。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <filename>post-commit</filename>
          </term>

          <listitem>
            <para>它在事务完成后运行，创建一个新的修订版本。大多数人用这个钩子来发送关于运行的描述性电子邮件，或者作为资源库的备份。资源库版本库传给程序两个变量：到版本库的路径和被创建的新的修订版本号。退出程序会被忽略。分布式Subversion包括<command>mailer，<command>py</command>和<command>commit-email。<command>pl</command> 脚本（存于Subversion源代码树中的tools/hook-scripts/目录中）可被用于发送给定操作的描述性email。这种mail包含</command></command>变化的路径清单，有关操作的信息日志，操作的日期和作者。</para>

            <para>Subversion提供的另一个有用的工具是hot-backup。<command>py</command>脚本（在Subversion源代码树中的tools/backup/目录中）。这种脚本做为Subversion版本库的热备份使用，可被用来作为版本库的per-commit snapshot。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <filename>pre-revprop-change</filename>
          </term>

          <listitem>
            <para />

            <para>因为Subversion的revision不是versioned，这一属性的修改（例如，<literal>svn“执行信息日志属性）将会重写以前的属性值。因为数据在此可能丢失，Subversion提供了</literal></para>

            <para><literal>这种钩子（及它的类似物，post-revprop-change），资源库管理者可用一些外部方法保持变化记录。</literal>作为一种丢失unversioned属性数据的预先警告，Subversion客户端不能远程修改revision属性，除非为你的资源库实现这个钩子。</para>

            <para>这个钩子只在对资源库修改时才运行。资源库给钩子传递四个参数：到资源库的路径，要修改的属性存在的revision，经过校验的生成变化的用户名，和属性自身的名字。</para>

            <para />
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <filename>post-revprop-change</filename>
          </term>

          <listitem>
            <para>它是一个早期版本的方法，这个钩子是<filename>pre-revprop-change</filename>钩子的类似物。事实上，出于某种偏执这个脚本并不运行，除非存在<filename>pre-revprop-change</filename>钩子。当这两个钩子都存在时，<filename>post-revprop-changehook只在revision版本库被改变时才运行，它通常被用来发送包含变化了的新参数的email。版本库传递</filename></para>

            <para>四个参数给该钩子：到版本库的路径，属性存在的revision，经过校验的产生变化的用户名，和属性自身的名字。</para>

            <para>分布式Subversion包含<command>propchange-email。<command>py</command>
            脚本（在Subversion源代码树中的tools/backup/目录中）被用来发送于revision的属性变</command></para>

            <para>
              <command>化细节有关的email。这种email包含revision和发生变化的属性名，产生变化的用户名，新属性值。</command>
            </para>

            <para />
          </listitem>
        </varlistentry>
      </variablelist>

      <warning>
        <para />

        <para>不要尝试用钩子脚本修改事务。一个通常的例子就是这可能会在运行式自动设置诸如<literal>svn:eol-style</literal>
        或
        <literal>svn:mime-type</literal>属性。这看起来是个好主意，但它会引起问题。主要的问题是客户并不知道由钩子脚本改变的变化，同时没有办法通告客户它的数据是过时的。</para>

        <para>这种不连续会导致出人意料和不能预测的行为。</para>

        <para>检查<filename>pre-commit</filename>
        钩子的事务及假如它不满足要求，通告它，是一种取代修改事务更好的办法。</para>

        <para>Subversion会执行hooks</para>
      </warning>

      <para>Subversion会试图以当前访问版本库的用户身份执行钩子。通常，对版本库的访问总是通过Apache HTTP服务器和mod_dav_svn进行，因此，运行Apache的用户就是执行钩子的用户。要运行钩子，需要具有操作系统级权限的用户对其进行配置。不仅是钩子，其它被钩子使用和调用的文件或程序（包括Subversion版本库本身）也一样以同一个用户的身份访问，不管访问是直接的还是间接的。因此，要注意潜在的用户权限问题，它可能会让你的钩子无法顺利执行。</para>
    </sect2>

    <!-- ***************************************************************** -->

    <sect2 id="svn-ch-5-sect-2.2">
      <title>Berkeley DB 设置</title>

      <para>Berkeley DB 环境是一个或多个数据库、日志文件、 域文件和配置文件的封装。Berkeley DB环境有它自己预设的设定值，像是任何时间可使用的锁定数目、 日志文件的大小等。 Subversion程序会为Berkeley DB配置选项设定默认的值。 不过，有时你的特定版本库需要特定的数据集合和访问类型，可能需要不同的配置选项。</para>

      <para>Sleepycat（BerkeleyDB的制造厂商）的人员清楚不同的版本库有不同的需求，所以他们提供了运行时为BerkeleyDB环境重载配置值的功能。Berkeley在每一个环境目录中检查是否存在一个名叫<filename>DB_CONFIG</filename>的文件，然后解析其中的为某个Berkeley环境所用的选项。</para>

      <para>你的版本库的Berkeley配置文件位于<filename>db</filename>目录，<filename>repos/db/DB_CONFIG</filename>。 Subversion在创建版本库时自己创建了这个文件。这个文件初始化包含一些默认选项，也包含了BerkeleyDB在线文档的参照，使你能够了解这些选项是做什么的。当然，你也可以为你的DB_CONFIG文件添加任何Berkeley DB支持的选项。应当注意，当Subversion不能访问文件或设置没有生效时，不应更改任何配置，因为那会引起Berkeley数据库以一种预料不到的方式执行剩下的程序。更改</para>

      <para><filename>DB_CONFIG</filename>并不会产生任何作用，除非你恢复数据库环境(用
      <command>svnadmin recover</command>)。</para>

      <para />
    </sect2>
  </sect1>

  <!-- ******************************************************************* -->

  <!-- *** SECTION 3:  版本库维护                                      *** -->

  <!-- ******************************************************************* -->

  <sect1 id="svn-ch-5-sect-3">
    <title>版本库维护</title>

    <para>维护一个Subversion版本库是一项令人沮丧的工作，主要因为有数据库后端与生俱来的复杂性。做好这项工作需要知道一些工具——它们是什么，什么时候用以及如何使用。这一节将会向你介绍Subversion带的版本库管理工具，以及如何使用它们来完成诸如版本库移植、升级、备份和整理。</para>

    <!-- ***************************************************************** -->

    <sect2 id="svn-ch-5-sect-3.1">
      <title>管理员的工具箱</title>

      <para>Subversion提供了一些对创建、查看、修改和修复版本库有用的工具。让我们详细了解一下这些工具。然后，我们再看一下在仅在BerkeleyDB发行版中提供的针对资料数据库的工具。</para>

      <sect3 id="svn-ch-5-sect-3.1.1">
        <title>svnlook</title>

        <para><command>svnlook</command>是Subversion提供的用来查看版本库中不同的修订版本和事务。这个程序不会修改版本库内容－这是个“只读”的工具。<command>svnlook</command>通常用在版本库挂钩程序中，用来记录版本库即将提交的变更（<command>用在pre-commit挂钩时）</command>或者已经提交的（用在<command>post-commit</command>挂钩时）。版本库管理员可以将这个工具用于诊断。</para>

        <para><command>svnlook</command> 的语法很直接：</para>

        <screen>
$ svnlook help
general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]
Note: any subcommand which takes the '--revision' and '--transaction'
      options will， if invoked without one of those options， act on
      the repository's youngest revision.
Type "svnlook help &lt;subcommand&gt;" for help on a specific subcommand.
…
</screen>

        <para>几乎<command>svnlook</command>的每一个子命令都能操作修订版本或事务树，显示资料树的信息，或是它与版本库中上一个修订版本的不同。你可以用<option>--revision</option> 和 <option>--transaction</option>选项指定要查看的修订版本或事务。注意，虽然修订版本号看起来像自然数，但是事务名称是包含英文字母与数字的字符串。请记住文件系统只允许浏览未提交的事务（还没有形成一个新的修订版本的事务）。多数版本库没有这种事务，因为事务通常或者被提交了（这样便不能被查看），或者被中止然后删除。</para>

        <para>如果没有<option>--revision</option>和<option>--transaction</option>选项，<command>svnlook</command>会查看版本库中最年轻的修订版本（或“HEAD”）。所以下边的两个命令执行结果完全相同，当位于<filename>/path/to/repos</filename>的版本库中，19是最年轻的修订版本的时候：</para>

        <screen>
$ svnlook info /path/to/repos
$ svnlook info /path/to/repos --revision 19
</screen>

        <para>这些子命令的唯一例外，是<command>svnlook youngest</command>命令，它不需要选项，只会显示出<literal>HEAD</literal>修订版本号。</para>

        <screen>
$ svnlook youngest /path/to/repos
19
</screen>

        <para><command>svnlook</command>的输出被设计为人和机器都易理解。拿<literal>info</literal>子命令举例来说：</para>

        <screen>
$ svnlook info /path/to/repos
sally
2002-11-04 09:29:13 -0600 (Mon， 04 Nov 2002)
27
Added the usual
Greek tree.
</screen>

        <para>info子命令的输出定义如下：</para>

        <orderedlist>
          <listitem>
            <para>作者，后接换行。</para>
          </listitem>

          <listitem>
            <para>日期，后接换行。</para>
          </listitem>

          <listitem>
            <para>日志消息的字数，后接换行。</para>
          </listitem>

          <listitem>
            <para>日志消息， 后接换行。</para>
          </listitem>
        </orderedlist>

        <para>这种输出是人可阅读的，像是时间戳这种有意义的条目，使用文本表示，而不是其他比较晦涩的方式。这种输出也是机器可读的－因为日志信息可以有多行，没有长度的限制，<command>svnlook</command>在日志消息之前提供了消息的长度。这使得脚本或者其他对这个命令进行的封装提供了更强的功能，比如日志消息使用了多少内存，或在这个输出成为最后一个字节之前应该忽略多少字节。</para>

        <para>另一个<command>svnlook</command>常见的用法是查看修订版本树或事务树的内容。
        <command>svnlook tree</command> 命令显示在请求的树中的目录和文件。如果你提供了
        <option>--show-ids</option> 选项，它还会显示每个路径的文件系统节点修订版本ID（这一点对开发者往往很有用）。</para>

        <screen>
$ svnlook tree /path/to/repos --show-ids
/ &lt;0.0.1&gt;
 A/ &lt;2.0.1&gt;
  B/ &lt;4.0.1&gt;
   lambda &lt;5.0.1&gt;
   E/ &lt;6.0.1&gt;
    alpha &lt;7.0.1&gt;
    beta &lt;8.0.1&gt;
   F/ &lt;9.0.1&gt;
  mu &lt;3.0.1&gt;
  C/ &lt;a.0.1&gt;
  D/ &lt;b.0.1&gt;
   gamma &lt;c.0.1&gt;
   G/ &lt;d.0.1&gt;
    pi &lt;e.0.1&gt;
    rho &lt;f.0.1&gt;
    tau &lt;g.0.1&gt;
   H/ &lt;h.0.1&gt;
    chi &lt;i.0.1&gt;
    omega &lt;k.0.1&gt;
    psi &lt;j.0.1&gt;
 iota &lt;1.0.1&gt;
</screen>

        <para>如果你看过树中目录和文件的布局，你可以使用<command>svnlook cat</command>，<command>svnlook propget</command>， 和 <command>svnlook  proplist</command> 命令来查看这些目录和文件的细节。</para>

        <para><command>svnlook</command>
        还可以做很多别的查询，显示我们先前提到的信息的一些子集，报告指定的修订版本或事务中哪些路径曾经被修改过，显示对文件和目录做过的文本和属性的修改，等等。下面是<command>svnlook</command>命令能接受的子命令的介绍，以及这些子命令的输出：</para>

        <variablelist>
          <varlistentry>
            <term>
              <literal>author</literal>
            </term>

            <listitem>
              <para>显示该树的作者。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>cat</literal>
            </term>

            <listitem>
              <para>显示树中某文件的内容。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>changed</literal>
            </term>

            <listitem>
              <para>显示树中被修改过的所有文件和目录。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>date</literal>
            </term>

            <listitem>
              <para>显示该树的时间戳。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>diff</literal>
            </term>

            <listitem>
              <para>显示被修改文件的统一差异格式。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>dirs-changed</literal>
            </term>

            <listitem>
              <para>显示树中本身被修改或者其中文件被修改的目录。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>history</literal>
            </term>

            <listitem>
              <para>显示受到版本控制的路径（更改和复制发生过的地方）中需要的历史信息。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>info</literal>
            </term>

            <listitem>
              <para>显示树的作者、时间戳、日志字数和日志信息。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>log</literal>
            </term>

            <listitem>
              <para>显示树的日志信息。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>propget</literal>
            </term>

            <listitem>
              <para>显示树中属性的值。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>proplist</literal>
            </term>

            <listitem>
              <para>显示树中属性集合的名字与值。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>tree</literal>
            </term>

            <listitem>
              <para>显示树列表，可选的显示与路径有关的文件系统节点的修订版本号。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>uuid</literal>
            </term>

            <listitem>
              <para>显示版本库的UUID--统一资源标志。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>youngest</literal>
            </term>

            <listitem>
              <para>显示最年轻的修订版本号。</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect3>

      <sect3 id="svn-ch-5-sect-3.1.2">
        <title>svnadmin</title>

        <para><command>svnadmin</command> 程序是版本库管理员最好的朋友。除了提供创建Subversion版本库的功能，这个程序使你可以维护这些版本库。<command>svnadmin</command>的语法跟 <command>svnlook</command>类似：</para>

        <screen>
$ svnadmin help
general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp; OPTIONS ...]
Type "svnadmin help &lt;subcommand&gt;" for help on a specific subcommand.

Available subcommands:
   create
   deltify
   dump
   help (?， h)
…
</screen>

        <para>我们已经提过 <command>svnadmin</command> 的<literal>create</literal>子命令（参照 <xref linkend="svn-ch-5-sect-2" />）。本章中我们会详细讲解大多数其他的命令。现在，我们来简单的看一下每个可用的子命令提供了什么功能。</para>

        <variablelist>
          <varlistentry>
            <term>
              <literal>create</literal>
            </term>

            <listitem>
              <para>创建一个新的Subversion版本库。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>deltify</literal>
            </term>

            <listitem>
              <para>在指定的修订版本范围内，对其中修改过的路径做deltification操作。如果没有指定修订版本，这条命令会修改HEAD修订版本。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>dump</literal>
            </term>

            <listitem>
              <para>dump由给定的revisions集限定的版本库的轻便格式化内容。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>hotcopy</literal>
            </term>

            <listitem>
              <para>对版本库做热拷贝。用这个方法你能任何时候安全的备份版本库而不许考虑是否版本库正在使用。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>list-dblogs</literal>
            </term>

            <listitem>
              <para>（Berkeley 数据库的版本库专有）列出Berkeley数据库中与版本库有关的日志文件清单。这个清单包括所有的日志文件--现在仍然被版本库使用的和不在使用的。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>list-unused-dblogs</literal>
            </term>

            <listitem>
              <para>(Berkeley 数据库的版本库专有)列出Berkeley数据库版本库有关的不在使用日志文件路径清单。你能安全的从版本库中删除那些日志文件，也可能将它们存档以用来灾难事件后版本库的恢复。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>load</literal>
            </term>

            <listitem>
              <para>从dump子命令中产生的轻快格式化的数据流中下载一系列revisions装入版本库。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>lstxns</literal>
            </term>

            <listitem>
              <para>列出刚刚退出版本库的没有执行的Subversion事务清单。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>recover</literal>
            </term>

            <listitem>
              <para>恢复版本库，通常在版本库发生致命错误时实行，以预防对Subversion事务的完全关闭。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>rmtxns</literal>
            </term>

            <listitem>
              <para>从版本库中清除Subversion事务（<literal>在lstxns子命令后执行</literal>）。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>setlog</literal>
            </term>

            <listitem>
              <para>重置svn:log属性当前值。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>verify</literal>
            </term>

            <listitem>
              <para>确认版本库的内容。包括校验和比较。</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect3>

      <sect3 id="svn-ch-5-sect-3.1.3">
        <title>svndumpfilter</title>

        <para>Subversion使用底层的数据库储存各类数据，手工调整是不明智的，即使这样做并不困难。何况，一旦你的数据存进了版本库，通常很难再将它们从版本库中删除。<footnote>
            <para>顺便说一句，这是Subversion的<emphasis>特性</emphasis>，而不是bug。</para>
          </footnote>不幸的是，总会有些时候你需要处理版本库的历史数据。你也许想把一个不应该出现的文件从版本库中彻底清除。或者，你曾经用一个版本库管理多个工程，现在又想把它们分开。要完成这样的工作，管理员们需要更易于管理和扩展的方法表示版本库中的数据，Subversion版本库转储文件格式就是一个很好的选择。</para>

        <para>Subversion版本库转储文件记录了所有版本数据的变更信息，而且以易于阅读的格式保存。可以使用<command>svnadmin dump</command>命令生成转储文件，然后用<command>svnadmin load</command>命令生成一个新的版本库。（参见 <xref
        linkend="svn-ch-5-sect-3.5" />）。转储文件易于阅读意味着你可以小心翼翼的查看和修改它。当然，问题是如果你有一个运行了两年的版本库，那么生成的转储文件会很庞大，阅读和手工修改起来都会花费很多时间。</para>

        <para>虽然在管理员的日常工作中并不会经常使用，不过<command>svndumpfilter</command>可以对特定的路径进行过滤。这是有一个独特而很有意义的用法，可以帮助你快速方便的修改转储的数据。使用时，只需提供一个你想要保留的（或者不想保留的）路径列表，然后把你的版本库转储文件送进这个过滤器。最后你就可以得到一个仅包含你想保留的路径的转储数据流。</para>

        <para><command>svndumpfilter</command>的语法如下：</para>

        <screen>
$ svndumpfilter help
general usage: svndumpfilter SUBCOMMAND [ARGS &amp; OPTIONS ...]
Type "svndumpfilter help &lt;subcommand&gt;" for help on a specific subcommand.

Available subcommands:
   exclude
   include
   help (?， h)
</screen>

        <para>有意义的子命令只有两个。你可以使用这两个子命令说明你希望保留和不希望保留的路径：</para>

        <variablelist>
          <varlistentry>
            <term>
              <literal>exclude</literal>
            </term>

            <listitem>
              <para>将指定路径的数据从转储数据流中排除。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>include</literal>
            </term>

            <listitem>
              <para>将指定路径的数据添加到转储数据流中。</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>现在我来演示如何使用这个命令。我们会在其它章节（参见 <xref
        linkend="svn-ch-5-sect-6.1" />）讨论关于如何选择设定版本库布局的问题，比如应该使用一个版本库管理多个项目还是使用一个版本库管理一个项目，或者如何在版本库中安排数据等等。不过，有些时候，即使在项目已经展开以后，你还是希望对版本库的布局做一些调整。最常见的情况是，把原来存放在同一个版本库中的几个项目分开，各自成家。</para>

        <para>假设有一个包含三个项目的版本库：
        <literal>calc</literal>，<literal>calendar</literal>，和
        <literal>spreadsheet</literal>。它们在版本库中的布局如下：</para>

        <screen>
/
   calc/
      trunk/
      branches/
      tags/
   calendar/
      trunk/
      branches/
      tags/
   spreadsheet/
      trunk/
      branches/
      tags/
</screen>

        <para>现在要把这三个项目转移到三个独立的版本库中。首先，转储整个版本库：</para>

        <screen>
$ svnadmin dump /path/to/repos &gt; repos-dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
* Dumped revision 3.
…
$
</screen>

        <para>然后，将转储文件三次送入过滤器，每次仅保留一个顶级目录，就可以得到三个转储文件：</para>

        <screen>
$ cat repos-dumpfile | svndumpfilter include calc &gt; calc-dumpfile
…
$ cat repos-dumpfile | svndumpfilter include calendar &gt; cal-dumpfile
…
$ cat repos-dumpfile | svndumpfilter include spreadsheet &gt; ss-dumpfile
…
$
</screen>

        <para>现在你必须要作出一个决定了。这三个转储文件中，每个都可以用来创建一个可用的版本库，不过它们保留了原版本库的精确路径结构。也就是说，虽然项目<literal>calc</literal>现在独占了一个版本库，但版本库中还保留着名为<filename>calc</filename>的顶级目录。如果希望<filename>trunk</filename>、<filename>tags</filename>和<filename>branches</filename>这三个目录直接位于版本库的根路径下，你可能需要编辑转储文件，调整<literal>Node-path</literal>和<literal>Copyfrom-path</literal>头参数，将路径<filename>calc/</filename>删除。同时，你还要删除转储数据中创建<filename>calc</filename>目录的部分。一般来说，就是如下的一些内容：</para>

        <screen>
Node-path: calc
Node-action: add
Node-kind: dir
Content-length: 0

</screen>

        <warning>
          <para>如果你打算通过手工编辑转储文件来移除一个顶级目录，注意不要让你的编辑器将换行符转换为本地格式（比如将\r\n转换为\n）。否则文件的内容就与所需的格式不相符，这个转储文件也就失效了。</para>
        </warning>

        <para>剩下的工作就是创建三个新的版本库，然后将三个转储文件分别导入：</para>

        <screen>
$ svnadmin create calc; svnadmin load calc &lt; calc-dumpfile
&lt;&lt;&lt; Started new transaction， based on original revision 1
     * adding path : Makefile ... done.
     * adding path : button.c ... done.
…
$ svnadmin create calendar; svnadmin load calendar &lt; cal-dumpfile
&lt;&lt;&lt; Started new transaction， based on original revision 1
     * adding path : Makefile ... done.
     * adding path : cal.c ... done.
…
$ svnadmin create spreadsheet; svnadmin load spreadsheet &lt; ss-dumpfile
&lt;&lt;&lt; Started new transaction， based on original revision 1
     * adding path : Makefile ... done.
     * adding path : ss.c ... done.
…
$
</screen>

        <para><command>svndumpfilter</command>的两个子命令都可以通过选项设定如何处理<quote>空</quote>修订版本。如果某个指定的修订版本仅包含路径的更改，过滤器就会将它删除，因为当前为空的修订版本通常是无用的甚至是让人讨厌的。为了让用户有选择的处理这些修订版本，<command>svndumpfilter</command>提供了以下命令行选项：</para>

        <variablelist>
          <varlistentry>
            <term>
              <option>--drop-empty-revs</option>
            </term>

            <listitem>
              <para>不生成任何空修订版本，忽略它们。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <option>--renumber-revs</option>
            </term>

            <listitem>
              <para>如果空修订版本被剔除（通过使用<option>--drop-empty-revs</option>选项），依次修改其它修订版本的编号，确保编号序列是连续的。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <option>--preserve-revprops</option>
            </term>

            <listitem>
              <para>如果空修订版本被保留，保持这些空修订版本的属性（日志信息，作者，日期，自定义属性，等等）。如果不设定这个选项，空修订版本将仅保留初始时间戳，以及一个自动生成的日志信息，表明此修订版本由<command>svndumpfilter</command>处理过。</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>尽管<command>svndumpfilter</command>十分有用，能节省大量的时间，但它却不折不扣是把双刃剑。首先，这个工具对路径语义极为敏感。仔细检查转储文件中的路径是不是以斜线开头。也许<literal>Node-path</literal>和<literal>Copyfrom-path</literal>这两个头参数对你有些帮助。</para>

        <screen>
…
Node-path: spreadsheet/Makefile
…
</screen>

        <para>如果这些路径以斜线开头，那么你传递给<command>svndumpfilter
        include</command>和<command>svndumpfilter exclude</command>的路径也必须以斜线开头（反之亦然）。如果因为某些原因转储文件中的路径没有统一使用或不使用斜线开头，<footnote>
            <para>尽管<command>svnadmin dump</command>对是否以斜线作为路径的开头有统一的规定——这个规定就是不以斜线作为路径的开头——其它生成转储文件的程序不一定会遵守这个规定。</para>
          </footnote>也许需要修正这些路径，统一使用斜线开头或不使用斜线开头。</para>

        <para>此外，复制操作生成的路径也会带来麻烦。Subversion支持在版本库中进行复制操作，也就是复制一个存在的路径，生成一个新的路径。问题是，<command>svndumpfilter</command>保留的某个文件或目录可能是由某个<command>svndumpfilter</command>排除的文件或目录复制而来的。也就是说，为了确保转储数据的完整性，<command>svndumpfilter</command>需要切断这些复制自被排除路径的文件与源文件的关系，还要将这些文件的内容以新建的方式添加到转储数据中。但是由于Subversion版本库转储文件格式中仅包含了修订版本的更改信息，因此源文件的内容基本上无法获得。如果你不能确定版本库中是否存在类似的情况，最好重新考虑一下到底保留/排除哪些路径。</para>
      </sect3>

      <sect3 id="svn-ch-5-sect-3.1.4">
        <title>svnshell.py</title>

        <para>Subversion源代码树中有一个类似于shell的版本库访问界面。Python脚本<command>svnshell.py</command>（位于源代码树的<filename>tools/examples/</filename>下）通过Subversion语言绑定接口（所以运行这个脚本须要正确的编译和安装这些程序包）连接到版本库和文件系统库。</para>

        <para>运行这个脚本，你可以浏览版本库中的目录，就像在shell下浏览文件系统一样。一开始，你<quote>位于</quote>修订版本<literal>HEAD</literal>的根目录中， 在命令提示符中可以看到相应的提示。 任何时候都可以使用<literal>help</literal>命令显示当前可用的命令帮助。</para>

        <screen>
$ svnshell.py /path/to/repos
&lt;rev: 2 /&gt;$  help
Available commands:
  cat FILE     : dump the contents of FILE
  cd DIR       : change the current working directory to DIR
  exit         : exit the shell
  ls [PATH]    : list the contents of the current directory
  lstxns       : list the transactions available for browsing
  setrev REV   : set the current revision to browse
  settxn TXN   : set the current transaction to browse
  youngest     : list the youngest browsable revision number
&lt;rev: 2 /&gt;$
</screen>

        <para>浏览版本库的目录结构就像在Unix或Windows shell中一样——使用<literal>cd</literal>命令。任何时候，命令提示符中都会显示当前所在的修订版本（前缀为<literal>rev:</literal>）或事务（前缀为<literal>txn:</literal>，以及你所在的路径。你可以用<literal>setrev</literal>和<literal>settxn</literal>切换到其它修订版本或事务中去。你可以想在Unix shell中那样，使用<literal>ls</literal>命令列出目录的内容，使用<literal>cat</literal>命令列出文件的内容。</para>

        <example id="svn-ch-8-sect-3.1.3-ex-1">
          <title>使用svnshell浏览版本库</title>

          <screen>
&lt;rev: 2 /&gt;$ ls
   REV   AUTHOR  NODE-REV-ID     SIZE         DATE NAME
----------------------------------------------------------------------------
     1    sally &lt;     2.0.1&gt;          Nov 15 11:50 A/
     2    harry &lt;     1.0.2&gt;       56 Nov 19 08:19 iota
&lt;rev: 2 /&gt;$ cd A
&lt;rev: 2 /A&gt;$ ls
   REV   AUTHOR  NODE-REV-ID     SIZE         DATE NAME
----------------------------------------------------------------------------
     1    sally &lt;     4.0.1&gt;          Nov 15 11:50 B/
     1    sally &lt;     a.0.1&gt;          Nov 15 11:50 C/
     1    sally &lt;     b.0.1&gt;          Nov 15 11:50 D/
     1    sally &lt;     3.0.1&gt;       23 Nov 15 11:50 mu
&lt;rev: 2 /A&gt;$ cd D/G 
&lt;rev: 2 /A/D/G&gt;$ ls
   REV   AUTHOR  NODE-REV-ID     SIZE         DATE NAME
----------------------------------------------------------------------------
     1    sally &lt;     e.0.1&gt;       23 Nov 15 11:50 pi
     1    sally &lt;     f.0.1&gt;       24 Nov 15 11:50 rho
     1    sally &lt;     g.0.1&gt;       24 Nov 15 11:50 tau
&lt;rev: 2 /A&gt;$ cd ../..
&lt;rev: 2 /&gt;$ cat iota
This is the file 'iota'.
Added this text in revision 2.

&lt;rev: 2 /&gt;$ setrev 1; cat iota
This is the file 'iota'.

&lt;rev: 1 /&gt;$ exit
$
</screen>
        </example>

        <para>在上例中可以看到，可以将几条命令现在同一行中，并以分号隔开。此外，这个shell也能正确处理相对路径和绝对路径，以及特殊的路径<literal>.</literal>和<literal>..</literal></para>

        <para><literal>youngest</literal>命令将列出最年轻的修订版本。这可以用来确定<literal>setrev</literal>命令参数的范围——你可以浏览所有0到最年轻修订版本中的任何一个（它们都以整数为标识）。确定可以浏览的事务就不这么简单了。你需要使用<command>lstxns</command>命令列出哪些事务可以浏览。<command>lstxns</command>命令的输出与<command>svnadmin lstxns</command>的输出相同，设置了<option>--transaction</option>选项的<command>svnlook</command>命令也可以得到相同的结果。</para>

        <para>使用<command>exit</command>命令可以退出这个shell。也可以使用文件结束符——Control-D（在某些Win32的Python版本中用Control-Z代替）。</para>
      </sect3>

      <sect3 id="svn-ch-5-sect-3.1.5">
        <title>Berkeley DB工具</title>

        <para>如果你使用Berkeley DB版本库，那么所有纳入版本控制的文件系统结构和数据都储存在一系列数据库的表中，而这个位于版本库的<filename>db</filename>子目录下。这个子目录是一个标准的Berkeley DB环境目录，可以应用任何Berkeley数据库工具进行操作（参考SleepyCat网站<systemitem class="url">http://www.sleepycat.com/</systemitem>上关于这些工具的介绍）。</para>

        <para>对于Subversion的日常使用来说，这些工具并没有什么用处。大多数Subversion版本库必须的数据库操作都集成到<command>svnadmin</command>工具中。比如，<command>svnadmin list-unused-dblogs</command>和<command>svnadmin list-dblogs</command>实现了Berkeley <command>db_archive</command>命令功能的一个子集，而<command>svnadmin recover</command>则起到了 <command>db_recover</command>工具的作用。</para>

        <para>当然，还有一些Berkeley DB工具有时是有用的。<command>db_dump</command>将Berkeley DB数据库中的键值对以特定的格式写入文件中，而<command>db_load</command>则可以将这些键值对注入到数据库中。Berkeley数据库本身不支持跨平台转移，这两个工具在这样的情况下就可以实现在平台间转移数据库的功能，而无需关心操作系统或机器架构。此外，<command>db_stat</command>工具能够提供关于Berkeley DB环境的许多有用信息，包括详细的锁定和存储子系统的统计信息。</para>
      </sect3>
    </sect2>

    <!-- ***************************************************************** -->

    <sect2 id="svn-ch-5-sect-3.2">
      <title>版本库清理</title>

      <para>Subversion版本库一旦按照需要配置完成，一般情况下不需要特别的关照。不过有些时候还是需要管理员手工干预一下。<command>svnadmin</command>工具就能够帮你完成以下这类工作：</para>

      <itemizedlist>
        <listitem>
          <para>修改提交日志信息，</para>
        </listitem>

        <listitem>
          <para>移除中止的事务，</para>
        </listitem>

        <listitem>
          <para>恢复<quote>塞住</quote>的版本库，以及</para>
        </listitem>

        <listitem>
          <para>将一个版本库中的内容搬移到另一个版本库中。</para>
        </listitem>
      </itemizedlist>

      <para><command>svnadmin</command>的子命令中最经常用到的恐怕就是<literal>setlog</literal>。用户在提交时输入的日志信息随着相关事务提交到版本库并升级成为修订版本后，便作为新修订版本的非版本化（即没有进行版本管理）属性保存下来。换句话说，版本库只记得最新的属性值，而忽略以前的。</para>

      <para>有时用户输入的日志信息有错误（比如拼写错误或者内容错误）。如果配置版本库时设置了（使用<literal>pre-revprop-change</literal>和      <literal>post-revprop-change</literal>钩子；参见<xref
      linkend="svn-ch-5-sect-2.1" />）允许用户在提交后修改日志信息的选项，那么用户可以使用<command>svn</command>程序的<literal>propset</literal>命令（参见<xref linkend="svn-ch-9" />）<quote>修正</quote>日志信息中的错误。不过为了避免永远丢失信息，Subversion版本库通常设置为仅能由管理员修改非版本化属性（这也是默认的选项）。</para>

      <para>如果管理员想要修改日志信息，那么可以使用<command>svnadmin setlog</command>命令。这个命令从指定的文件中读取信息，取代版本库中某个修订版本的日志信息（<literal>svn:log</literal>属性）。</para>

      <screen>
$ echo "Here is the new， correct log message" &gt; newlog.txt
$ svnadmin setlog myrepos newlog.txt -r 388
</screen>

      <para>即使是<command>svnadmin setlog</command>命令也受到限制。<literal>pre-</literal>和
      <literal>post-revprop-change</literal>钩子同样会被触发，因此必须进行相应的设置才能允许修改非版本化属性。不过管理员可以使用<command>svnadmin
      setlog</command>命令的<option>--bypass-hooks</option>选项跳过钩子。</para>

      <warning>
        <para>不过需要注意的是，一旦跳过钩子也就跳过了钩子所提供的所有功能，比如邮件通知（通知属性有改动）、系统备份（可以用来跟踪非版本化的属性变更）等等。换句话说，要留心你所作出的修改，以及你作出修改的方式。</para>
      </warning>

      <para><command>svnadmin</command>的另一个常见用途是查询异常的——可能是已经死亡的——Subversion事务。通常提交操作失败时，与之相关的事务就会被清除。也就是说，事务本身及所有与该事务相关（且仅与该事务相关）的数据会从版本库中删除。不过偶尔也会出现操作失败而事务没有被清除的情况。出现这种情况可能有以下原因：客户端的用户粗暴的结束了操作，操作过程中出现网络故障，等等。不管是什么原因，死亡的事务总是有可能会出现。这类事务不会产生什么负面影响，仅仅是消耗了一点点磁盘空间。不过，严厉的管理员总是希望能够将它们清除出去。</para>

      <para>可以使用<command>svnadmin</command>的<literal>lstxns</literal> 命令列出当前的异常事务名。</para>

      <screen>
$ svnadmin lstxns myrepos
19
3a1
a45
$
</screen>

      <para>将输出的结果条目作为<command>svnlook</command>（设置<option>--transaction</option>选项）的参数，就可以获得事务的详细信息，如事务的创建者、创建时间，事务已作出的更改类型，由这些信息可以判断出是否可以将这个事务安全的删除。如果可以安全删除，那么只需将事务名作为参数输入到<command>svnadmin rmtxns</command>，就可以将事务清除掉了。其实<literal>rmtxns</literal>子命令可以直接以<literal>lstxns</literal>的输出作为输入进行清理。</para>

      <screen>
$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`
$
</screen>

      <para>在按照上面例子中的方法清理版本库之前，你或许应该暂时关闭版本库和客户端的连接。这样在你开始清理之前，不会有正常的事务进入版本库。下面例子中的shell脚本可以用来迅速获得版本库中异常事务的信息：</para>

      <example id="svn-ch-5-sect-3.2-ex-1">
        <title>txn-info.sh（异常事务报告）</title>

        <programlisting>
#!/bin/sh

### Generate informational output for all outstanding transactions in
### a Subversion repository.

REPOS="${1}"
if [ "x$REPOS" = x ] ; then
  echo "usage: $0 REPOS_PATH"
  exit
fi

for TXN in `svnadmin lstxns ${REPOS}`; do 
  echo "---[ Transaction ${TXN} ]-------------------------------------------"
  svnlook info "${REPOS}" --transaction "${TXN}"
done
</programlisting>
      </example>

      <para>可以用下面的命令使用上例中脚本：
      <command>/path/to/txn-info.sh /path/to/repos</command>。该命令的输出主要有多个<command>svnlook info</command>参见<xref linkend="svn-ch-5-sect-3.1.1" />）的输出组成，类似于下面的例子：</para>

      <screen>
$ txn-info.sh myrepos
---[ Transaction 19 ]-------------------------------------------
sally
2001-09-04 11:57:19 -0500 (Tue， 04 Sep 2001)
0
---[ Transaction 3a1 ]-------------------------------------------
harry
2001-09-10 16:50:30 -0500 (Mon， 10 Sep 2001)
39
Trying to commit over a faulty network.
---[ Transaction a45 ]-------------------------------------------
sally
2001-09-12 11:09:28 -0500 (Wed， 12 Sep 2001)
0
$
</screen>

      <para>一个废弃了很长时间的事务通常是提交错误或异常中断的结果。事务的时间戳可以提供给我们一些有趣的信息，比如一个进行了9个月的操作居然还是活动的等等。</para>

      <para>简言之，作出事务清理的决定前应该仔细考虑一下。许多信息源——比如Apache的错误和访问日志，已成功完成的Subversion提交日志等等——都可以作为决策的参考。管理员还可以直接和那些似乎已经死亡事务的提交者直接交流（比如通过邮件），来确认该事务确实已经死亡了。</para>
    </sect2>

    <!-- ***************************************************************** -->

    <sect2 id="svn-ch-5-sect-3.3">
      <title>管理磁盘空间</title>

      <para>虽然存储器的价格在过去的几年里以让人难以致信的速度滑落，但是对于那些需要对大量数据进行版本管理的管理员们来说，磁盘空间的消耗依然是一个重要的因素。版本库每增加一个字节都意味着需要多一个字节的磁盘空间进行备份，对于多重备份来说，就需要消耗更多的磁盘空间。Berkeley DB版本库的主要存储机制是基于一个复杂的数据库系统建立的，因此了解一些数据性质是有意义的，比如哪些数据必须保留。哪些数据需要备份、哪些数据可以安全的删除等等。本节的内容专注于Berkeley DB类型的版本库。FSFS类型的版本库不需要进行数据清理和回收。</para>

      <para>目前为止，Subversion版本库中耗费磁盘空间的最大凶手是日志文件，每次Berkeley DB在修改真正的数据文件之前都会进行预写入（pre-writes）操作。这些文件记录了数据库从一个状态变化到另一个状态的所有动作——数据库文件反应了特定时刻数据库的状态，而日志文件则记录了所有状态变化的信息。因此，日志文件会以很快的速度膨胀起来。</para>

      <para>幸运的是，从版本4.2开始，Berkeley DB的数据库环境无需额外的操作即可删除无用的日志文件。如果编译<command>svnadmin</command>时使用了高于4.2版本的Berkeley DB，那么由此<command>svnadmin</command>程序创建的版本库就具备了自动清除日志文件的功能。如果想屏蔽这个功能，只需设置<command>svnadmin create</command>命令的<option>--bdb-log-keep</option>选项即可。如果创建版本库以后想要修改关于此功能的设置，只需编辑版本库中<filename>db</filename>目录下的<filename>DB_CONFIG</filename>文件，注释掉包含<literal>set_flags DB_LOG_AUTOREMOVE</literal>内容的这一行，然后运行<command>svnadmin
      recover</command>强制设置生效就行了。查阅<xref linkend="svn-ch-5-sect-2.2" />获得更多关于数据库配置的帮助信息。</para>

      <para>如果不自动删除日志文件，那么日志文件会随着版本库的使用逐渐增加。这多少应该算是数据库系统的特性，通过这些日志文件可以在数据库严重损坏时恢复整个数据库的内容。但是一般情况下，最好是能够将无用的日志文件收集起来并删除，这样就可以节省磁盘空间。使用<command>svnadmin list-unused-dblogs</command>命令可以列出无用的日志文件：</para>

      <screen>
$ svnadmin list-unused-dblogs /path/to/repos
/path/to/repos/log.0000000031
/path/to/repos/log.0000000032
/path/to/repos/log.0000000033

$ svnadmin list-unused-dblogs /path/to/repos | xargs rm
## disk space reclaimed!
</screen>

      <para>为了尽可能减小版本库的体积，Subversion在版本库中采用了<firstterm>增量化技术</firstterm>（或称为<quote>增量存储技术</quote>）。增量化技术可以将一组数据表示为相对于另一组数据的不同。如果这两组数据十分相似，增量化技术就可以仅保存其中一组数据以及两组数据的差别，而不需要同时保存两组数据，从而节省了磁盘空间。每次一个文件的新版本提交到版本库，版本库就会将之前的版本（之前的多个版本）相对于新版本做增量化处理。采用了这项技术，版本库的数据量大小基本上是可以估算出来的——主要是版本化的文件的大小——并且远小于<quote>全文</quote>保存所需的数据量。</para>

      <note>
        <para>由于Subversion版本库的增量化数据保存在单一Berkeley DB数据库文件中，减少数据的体积并不一定能够减小数据库文件的大小。但是，Berkeley DB会在内部记录未使用的数据库文件区域，并且在增加数据库文件大小之前会首先使用这些未使用的区域。因此，即使增量化技术不能立杆见影的节省磁盘空间，也可以极大的减慢数据库的膨胀速度。</para>
      </note>
    </sect2>

    <!-- ***************************************************************** -->

    <sect2 id="svn-ch-5-sect-3.4">
      <title>版本库的恢复</title>

      <para><xref linkend="svn-ch-5-sect-1.3.1" />中曾提到，Berkeley DB版本库如果没有正常关闭可能会进入冻结状态。这时，就需要管理员将数据库恢复到正常状态。</para>

      <para>Berkeley DB使用一种锁机制保护版本库中的数据。锁机制确保数据库不会同时被多个访问进程修改，也就保证了从数据库中读取到的数据始终是稳定而且正确的。当一个进程需要修改数据库中的数据时，首先必须检查目标数据是否已经上锁。如果目标数据没有上锁，进程就将它锁上，然后作出修改，最后再将锁解除。而其它进程则必须等待锁解除后才能继续访问数据库中的相关内容。</para>

      <para>在操作Subversion版本库的过程中，致命错误（如内存或硬盘空间不足）或异常中断可能会导致某个进程没能及时将锁解除。结果就是后端的数据库系统被<quote>塞住</quote>了。一旦发生这种情况，任何访问版本库的进程都会挂起（每个访问进程都在等待锁被解除，但是锁已经无法解除了）。</para>

      <para>首先，如果你的版本库出现这种情况，没什么好惊慌的。Berkeley DB的文件系统采用了数据库事务、检查点以及预写入日志等技术来取保只有灾难性的事件<footnote>
          <para>比如：硬盘 + 大号电磁铁 = 毁灭。</para>
        </footnote>才能永久性的破坏数据库环境。所以虽然一个过于稳重的版本库管理员通常都会按照某种方案进行大量的版本库离线备份，不过不要急着通知你的管理员进行恢复。</para>

      <para>然后，使用下面的方法试着<quote>恢复</quote>你的版本库：</para>

      <orderedlist>
        <listitem>
          <para>确保没有其它进程访问（或者试图访问）版本库。对于网络版本库，关闭Apache HTTP服务器是个好办法。</para>
        </listitem>

        <listitem>
          <para>成为版本库的拥有者和管理员。这一点很重要，如果以其它用户的身份恢复版本库，可能会改变版本库文件的访问权限，导致在版本库<quote>恢复</quote>后依旧无法访问。</para>
        </listitem>

        <listitem>
          <para>运行命令<command>svnadmin recover /path/to/repos</command>。 输出如下：</para>

          <screen>
Repository lock acquired。
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 19.
</screen>

          <para>此命令可能需要数分钟才能完成。</para>
        </listitem>

        <listitem>
          <para>重新启动Subversion服务器。</para>
        </listitem>
      </orderedlist>

      <para>这个方法能修复几乎所有版本库锁住的问题。记住，要以数据库的拥有者和管理员的身份运行这个命令，而不一定是<literal>root</literal>用户。恢复过程中可能会使用其它数据存储区（例如共享内存区）重建一些数据库文件。如果以<literal>root</literal>用户身份恢复版本库，这些重建的文件拥有者将变成<literal>root</literal>用户，也就是说，即使恢复了到版本库的连接，一般的用户也无权访问这些文件。</para>

      <para>如果因为某些原因，上面的方法没能成功的恢复版本库，那么你可以做两件事。首先，将破损的版本库保存到其它地方，然后从最新的备份中恢复版本库。然后，发送一封邮件到Subversion用户列表（地址是：<email>users@subversion.tigris.org</email>），写清你所遇到的问题。对于Subversion的开发者来说，数据安全是最重要的问题。</para>
    </sect2>

    <!-- ***************************************************************** -->

    <sect2 id="svn-ch-5-sect-3.5">
      <title>版本库的移植</title>

      <para>Subversion文件系统将数据保存在许多数据库表中，而这些表的结构只有Subversion开发者们才了解（也只有他们才感兴趣）不过，有些时候我们会想到把所有的数据（或者一部分数据）保存在一个独立的、可移植的、普通格式的文件中。Subversion通过<command>svnadmin</command>的两个子命令<literal>dump</literal>和<literal>load</literal>提供了类似的功能。</para>

      <para>对版本库的转储和装载的需求主要还是由于Subversion自身处于变化之中。在Subversion的成长期，后端数据库的设计多次发生变化，这些变化导致之前的版本库出现兼容性问题。当然，将Berkeley DB版本库移植到不同的操作系统或者CPU架构上，或者在Berkeley DB和FSFS后端之间进行转化也需要转储和装载功能。按照下面的介绍，只需简单几步就可以完成数据库的移植：</para>

      <orderedlist>
        <listitem>
          <para>使用<emphasis>当前</emphasis>版本的<command>svnadmin</command>将版本库转储到文件中。</para>
        </listitem>

        <listitem>
          <para>升级Subversion。</para>
        </listitem>

        <listitem>
          <para>移除以前的版本库，并使用<emphasis>新版本</emphasis>的<command>svnadmin</command>在原来版本库的位置建立空的版本库。</para>
        </listitem>

        <listitem>
          <para>还是使用<emphasis>新版本</emphasis>的<command>svnadmin</command>从转储文件中将数据装载到新建的空版本库中。</para>
        </listitem>

        <listitem>
          <para>记住从以前的版本库中复制所有的定制文件到新版本库中，包括<filename>DB_CONFIG</filename>文件和钩子脚本。最好阅读一下新版本的release notes，看看此次升级是否会影响钩子和配置选项。</para>
        </listitem>

        <listitem>
          <para>如果移植的同时改变的版本库的访问地址（比如移植到另一台计算机或者改变了访问策略），那么可以通知用户运行<command>svn switch --relocate</command>来切换他们的工作副本。参见<xref
          linkend="svn-ch-9-sect-1.2-re-switch" />。</para>
        </listitem>
      </orderedlist>

      <para><command>svnadmin dump</command>命令会将版本库中的修订版本数据按照特定的格式输出到转储流中。转储数据会输出到标准输出流，而提示信息会输出到标准错误流。这就是说，可以将转储数据存储到文件中，而同时在终端窗口中监视运行状态。例如：</para>

      <screen>
$ svnlook youngest myrepos
26
$ svnadmin dump myrepos &gt; dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
…
* Dumped revision 25.
* Dumped revision 26.
</screen>

      <para>最后，版本库中的指定的修订版本数据被转储到一个独立的文件中（在上面的例子中是<filename>dumpfile</filename>）。注意，<command>svnadmin dump</command>从版本库中读取修订版本树与其它<quote>读者</quote>（比如<command>svn checkout</command>）的过程相同，所以可以在任何时候安全的运行这个命令。</para>

      <para>另一个命令，<command>svnadmin load</command>，从标准输入流中读取Subversion转储数据，并且高效的将数据转载到目标版本库中。这个命令的提示信息输出到标准输出流中：</para>

      <screen>
$ svnadmin load newrepos &lt; dumpfile
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : A ... done.
     * adding path : A/B ... done.
     …
------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 2
     * editing path : A/mu ... done.
     * editing path : A/D/G/rho ... done.

------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;

…

&lt;&lt;&lt; Started new txn, based on original revision 25
     * editing path : A/D/gamma ... done.

------- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 26
     * adding path : A/Z/zeta ... done.
     * editing path : A/mu ... done.

------- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;

</screen>

      <para>既然<command>svnadmin</command>使用标准输入流和标准输出流作为转储和装载的输入和输出，那么更漂亮的用法是（管道两端可以是不同版本的<command>svnadmin</command>：</para>

      <screen>
$ svnadmin create newrepos
$ svnadmin dump myrepos | svnadmin load newrepos
</screen>

      <para>默认情况下，转储文件的体积可能会相当庞大——比版本库自身大很多。这是因为在转储文件中，每个文件的每个版本都以完整的文本形式保存下来。这种方法速度很快，而且很简单，尤其是直接将转储数据通过管道输入到其它进程中时（比如一个压缩程序，过滤程序，或者一个装载进程）。不过如果要长期保存转储文件，那么可以使用<option>--deltas</option>选项来节省磁盘空间。设置这个选项，同一个文件的数个连续修订版本会以增量式的方式保存——就像储存在版本库中一样。这个方法较慢，但是转储文件的体积则基本上与版本库的体积相当。</para>

      <para>之前我们提到<command>svnadmin dump</command>输出指定的修订版本。使用<option>--revision</option>选项可以指定一个单独的修订版本，或者一个修订版本的范围。如果忽略这个选项，所有版本库中的修订版本都会被转储。</para>

      <screen>
$ svnadmin dump myrepos --revision 23 &gt; rev-23.dumpfile
$ svnadmin dump myrepos --revision 100:200 &gt; revs-100-200.dumpfile
</screen>

      <para>Subversion在转储修订版本时，仅会输出与前一个修订版本之间的差异，通过这些差异足以从前一个修订版本中重建当前的修订版本。换句话说，在转储文件中的每一个修订版本仅包含这个修订版本作出的修改。这个规则的唯一一个例外是当前<command>svnadmin dump</command>转储的第一个修订版本。</para>

      <para>默认情况下，Subversion不会把转储的第一个修订版本看作对前一个修订版本的更改。 首先，转储文件中没有比第一个修订版本更靠前的修订版本了！其次，Subversion不知道装载转储数据时（如果真的需要装载的话）的版本库是什么样的情况。为了保证每次运行<command>svnadmin dump</command>都能得到一个独立的结果，第一个转储的修订版本默认情况下会完整的保存目录、文件以及属性等数据。</para>

      <para>不过，这些都是可以改变的。如果转储时设置了<option>--incremental</option>选项，<command>svnadmin</command>会比较第一个转储的修订版本和版本库中前一个修订版本，就像对待其它转储的修订版本一样。转储时也是一样，转储文件中将仅包含第一个转储的修订版本的增量信息。这样的好处是，可以创建几个连续的小体积的转储文件代替一个大文件，比如：</para>

      <screen>
$ svnadmin dump myrepos --revision 0:1000 &gt; dumpfile1
$ svnadmin dump myrepos --revision 1001:2000 --incremental &gt; dumpfile2
$ svnadmin dump myrepos --revision 2001:3000 --incremental &gt; dumpfile3
</screen>

      <para>这些转储文件可以使用下列命令装载到一个新的版本库中：</para>

      <screen>
$ svnadmin load newrepos &lt; dumpfile1
$ svnadmin load newrepos &lt; dumpfile2
$ svnadmin load newrepos &lt; dumpfile3
</screen>

      <para>另一个有关的技巧是，可以使用<option>--incremental</option>选项在一个转储文件中增加新的转储修订版本。举个例子，可以使用<literal>post-commit</literal>钩子在每次新的修订版本提交后将其转储到文件中。或者，可以编写一个脚本，在每天夜里将所有新增的修订版本转储到文件中。这样，<command>svnadmin</command>的<literal>dump</literal>和<literal>load</literal>命令就变成了很好的版本库备份工具，万一出现系统崩溃或其它灾难性事件，它的价值就体现出来了。</para>

      <para>转储还可以用来将几个独立的版本库合并为一个版本库。使用<command>svnadmin load</command>的<option>--parent-dir</option>选项，可以在装载的时候指定根目录。也就是说，如果有三个不同版本库的转储文件，比如<filename>calc-dumpfile</filename>，<filename>cal-dumpfile</filename>，和<filename>ss-dumpfile</filename>，可以在一个新的版本库中保存所有三个转储文件中的数据：</para>

      <screen>
$ svnadmin create /path/to/projects
$
</screen>

      <para>然后在版本库中创建三个目录分别保存来自三个不同版本库的数据：</para>

      <screen>
$ svn mkdir -m "Initial project roots" \
      file:///path/to/projects/calc \
      file:///path/to/projects/calendar \
      file:///path/to/projects/spreadsheet
Committed revision 1.
$ 
</screen>

      <para>最后，将转储文件分别装载到各自的目录中：</para>

      <screen>
$ svnadmin load /path/to/projects --parent-dir calc &lt; calc-dumpfile
…
$ svnadmin load /path/to/projects --parent-dir calendar &lt; cal-dumpfile
…
$ svnadmin load /path/to/projects --parent-dir spreadsheet &lt; ss-dumpfile
…
$
</screen>

      <para>我们再介绍一下Subversion版本库转储数据的最后一种用途——在不同的存储机制或版本控制系统之间转换。因为转储数据的格式的大部分是可以阅读的，<footnote>
          <para>Subversion版本库的转储文件格式类似于RFC-822格式，后者广泛的应用于电子邮件系统中。</para>
        </footnote>所以使用这种格式描述变更集（每个变更集对应一个新的修订版本）会相对容易一些。事实上，<command>cvs2svn.py</command>工具（参见
      <xref linkend="svn-ap-a-sect-11" />）正是将CVS版本库的内容转换为转储数据格式，如此才能将CVS版本库的数据导入Subversion版本库之中。</para>
    </sect2>

    <!-- ***************************************************************** -->

    <sect2 id="svn-ch-5-sect-3.6">
      <title>版本库备份</title>

      <para>尽管现代计算机的诞生带来了许多便利，但有一件事听起来是完全正确的—有时候，事情变的糟糕，很糟糕，动力损耗、网络中断、坏掉的内存和损坏的硬盘都是对魔鬼的一种体验，即使对于最尽职的管理员，命运也早已注定。所以我们来到了这个最重要的主题—怎样备份你的版本库数据。</para>

      <para>Subversion版本库管理员通常有两种备份方式—增量的和完全的。我们在早先的章节曾经讨论过如何使用<command>svnadmin
      dump --incremental</command>命令执行增量备份（见<xref
      linkend="svn-ch-5-sect-3.5" />），从本质上讲，这个方法只是备份了从你上次备份版本库到现在的变化。</para>

      <para>一个完全的版本库备份照字面上讲就是对整个版本库目录的复制（包括伯克利数据库或者文件FSFS环境），现在，除非你临时关闭了其他对版本库的访问，否则仅仅做一次迭代的拷贝会有产生错误备份的风险，因为有人可能会在并行的写数据库。</para>

      <para>如果是伯克利数据库，恼人的文档描述了保证安全拷贝的步骤，对于FSFS的数据，也有类似的顺序。我们有更好的选择，我们不需要自己去实现这个算法，因为Subversion开发小组已经为你实现了这些算法。Subversion源文件分发版本的<filename>tools/backup/</filename>目录有一个<command>hot-backup.py</command>文件，给定版本库路径和备份路径，<command>hot-backup.py</command>—是一个包裹了<command>svnadmin hotcopy</command>但更加智能的命令—将会执行必要的步骤来备份你的活动的版本库—不需要你首先禁止公共的版本库访问——而且之后会从你的版本库清理死掉的伯克利日志文件。</para>

      <para>甚至当你用了一个增量备份时，你也会希望有计划的运行这个程序。举个例子，你考虑在你的程序调度程序（如Unix下的<command>cron</command>）里加入<command>hot-backup。py</command>，或者你喜欢更加细致的备份解决方案，你可以让你的post-commit的钩子脚本执行<command>hot-backup。py</command>（见see
      <xref
      linkend="svn-ch-5-sect-2.1" />），这样会导致你的版本库的每次提交执行一次备份，只要在你的<filename>hooks/post-commit</filename>脚本里添加如下代码：</para>

      <programlisting>
(cd /path/to/hook/scripts; ./hot-backup.py ${REPOS} /path/to/backups &amp;)
</programlisting>

      <para>作为结果的备份是一个完全功能的版本库，当发生严重错误时可以作为你的活动版本库的替换。</para>

      <para>两种备份方式都有各自的优点，最简单的方式是完全备份，将会每次建立版本库的完美复制品，这意味着如果当你的活动版本库发生了什么事情，你可以用备份恢复。但不幸的是，如果你维护多个备份，每个完全的备份会吞噬掉和你的活动版本库同样的空间。</para>

      <para>增量备份会使用的版本库导出格式在Subversion的数据库模式改变时非常完美，因此当我们升级Subversion数据库模式的时候，一个完整的版本库导出和导入是必须的，做一半工作非常的容易（导出部分），不幸的是，增量备份的创建和恢复会占用很长时间，因为每一次提交都会被重放，对于导出文件和版本库。</para>

      <para>在每一种备份情境下，版本库管理员需要意识到对未版本化的修订版本属性对备份的影响，因为这些修改本身不会产生新的修订，他们不会触发post-commit触发器的钩子程序，也不会触发pre-revprop-change和post-revprop-change的钩子。
      <footnote>
          <para><command>svnadmin setlog</command>可以被绕过钩子程序被调用。</para>
        </footnote>
      而且因为你可以改变修订版本的属性，而不需要遵照时间顺序—你可在任何时刻修改任何修订版本的属性—因此最新版本的增量备份不会捕捉到以前特定修订版本的属性修改。</para>

      <para>通常说来，在每次提交时，只有妄想狂才会备份整个版本库，然而，假设一个给定的版本库拥有一些恰当粒度得冗余机制（如每次提交的邮件），版本库管理员也许会希望将版本库的热备份引入到系统级的每夜备份，对大多数版本库，归档的提交邮件为保存资源提供了足够的冗余措施，至少对于最近的提交。但是它是你的数据—你喜欢怎样保护都可以。</para>

      <para>经常的，最好的版本库备份方式是混合的，你可以平衡完全和增量备份，另外配合提交邮件的归档，Subversion开发者，举个例子，在每个新的修订版本建立时备份Subversion的源代码版本库，并且保留所有的提交和属性修改通知文件。你的解决方案类似，必须迎合你的需要，平衡便利和你的偏执。然而这些不会改变你的硬件来自钢铁的命运。<footnote>
          <para>你知道的— 所有的术语只是她的 <quote>变幻无常的手指</quote>。</para>
        </footnote> 这一定会帮助你减少尝试的时间。</para>
    </sect2>
  </sect1>

  <!-- ******************************************************************* -->

  <!-- *** SECTION 6:  ADDING PROJECTS                                 *** -->

  <!-- ******************************************************************* -->

  <sect1 id="svn-ch-5-sect-6">
    <title>添加项目</title>

    <para>一旦你的版本库已经建立并且配置好了，剩下的就是使用了。如果你已经准备好了需要版本控制的数据，那么可以使用客户端软件<command>svn</command>的<literal>import</literal>子命令来实现你的期望。不过在这样做之前，你最好对版本库仔细的作一个长远的规划。本节，我们会给你一些好的建议，这些建议可以帮助你设计版本库的文件布局，以及如何在特定的布局中安排你的数据。</para>

    <!-- ***************************************************************** -->

    <sect2 id="svn-ch-5-sect-6.1">
      <title>选择一种版本库布局</title>

      <para>在Subversion版本库中，移动版本化的文件和目录不会损失任何信息，但是这样一来那些经常访问版本库并且以为文件总是在同一个路径的用户可能会受到干扰。为将来着想，最好预先对你的版本库布局进行规划。以一种高效的<quote>布局</quote>开始项目，可以减少将来很多不必要的麻烦。</para>

      <para>在建立Subversion版本库之前，有很多事情需要考虑。假如你是一个版本库管理员，需要向多个项目提供版本控制支持。那么，你首先要决定的是，用一个版本库支持多个项目，还是为每个项目建立一个版本库，还是为其中的某些项目提供独立的版本库支持，而将另外一些项目分布在几个版本库中。</para>

      <para>使用一个版本库支持多个项目有很多好处，最明显的无过于不需要维护好几个版本库。单一版本库就意味着只有一个钩子集，只需要备份一个数据库，当Subversion进行不兼容升级时，只需要一次转储和装载操作，等等。还有，你可以轻易的在项目之间移动数据，还不会损失任何历史版本信息。</para>

      <para>单一版本库的缺点是，不同的项目通常都有不同的提交邮件列表或者不同的权限认证和权限要求。还有，别忘了Subversion的修订版本号是针对整个版本库的。即使最近没有对某个项目作出修改，版本库的修订版本号还是会因为其它项目的修改而不停的提升，许多人并不喜欢这样的事实。</para>

      <para>可以采用折中的办法。比如，可以把许多项目按照彼此之间的关联程度划分为几个组合，然后为每一个项目组合建立一个版本库。这样，在相关项目之间共享数据依旧很简单，而如果修订版本号有了变化，至少开发人员知道，改变的东西多少和他们有些关系。</para>

      <para>在决定了如何用版本库组织项目以后，就该决定如何设置版本库的目录层次了。由于Subversion按普通的目录复制方式完成分支和标签操作（参见<xref
      linkend="svn-ch-4" />），Subversion社区建议为每一个项目建立一个<firstterm>项目根目录</firstterm>——项目的<quote>顶级</quote>目录——然后在根目录下建立三个子目录：<filename>trunk</filename>，保存项目的开发主线；<filename>branches</filename>，保存项目的各种开发分支；<filename>tags</filename>，保存项目的标签，也就是创建后永远不会修改的分支（可能会删除）。</para>

      <para>举个例子，一个版本库可能会有如下的布局：</para>

      <screen>
/
   calc/
      trunk/
      tags/
      branches/
   calendar/
      trunk/
      tags/
      branches/
   spreadsheet/
      trunk/
      tags/
      branches/
   …
</screen>

      <para>项目在版本库中的根目录地址并不重要。如果每个版本库中只有一个项目，那么就可以认为项目的根目录就是版本库的根目录。如果版本库中包含多个项目，那么可以将这些项目划分成不同的组合（按照项目的目标或者是否需要共享代码甚至是字母顺序）保存在不同子目录中，下面的例子给出了一个类似的布局：</para>

      <screen>
/
   utils/
      calc/
         trunk/
         tags/
         branches/
      calendar/
         trunk/
         tags/
         branches/
      …
   office/
      spreadsheet/
         trunk/
         tags/
         branches/
      …
</screen>

      <para>按照你因为合适方式安排版本库的布局。Subversion自身并不强制或者偏好某一种布局形式，对于Subversion来说，目录就是目录。最后，在设计版本库布局的时候，不要忘了考虑一下项目参与者们的意见。</para>
    </sect2>

    <!-- ***************************************************************** -->

    <sect2 id="svn-ch-5-sect-6.2">
      <title>创建布局，导入初始数据</title>

      <para>设计好版本库的布局后，就该在版本库中实现布局和导入初始数据了。在Subversion中，有很多种方法完成这项工作。可以使用<command>svn mkdir</command>命令（参见<xref linkend="svn-ch-9" />）在版本库中逐个创建需要的目录。更快捷的方法是使用<command>svn import</command>命令（参见<xref linkend="svn-ch-3-sect-7.3" />）。首先，在硬盘上创建一个临时目录，并按照设计好的布局在其中创建子目录，然后通过导入命令一次性的提交整个布局到版本库中：</para>

      <screen>
$ mkdir tmpdir
$ cd tmpdir
$ mkdir projectA
$ mkdir projectA/trunk
$ mkdir projectA/branches
$ mkdir projectA/tags
$ mkdir projectB
$ mkdir projectB/trunk
$ mkdir projectB/branches
$ mkdir projectB/tags
…
$ svn import . file:///path/to/repos --message 'Initial repository layout'
Adding         projectA
Adding         projectA/trunk
Adding         projectA/branches
Adding         projectA/tags
Adding         projectB
Adding         projectB/trunk
Adding         projectB/branches
Adding         projectB/tags
…
Committed revision 1.
$ cd ..
$ rm -rf tmpdir
$
</screen>

      <para>然后可以使用<command>svn list</command>命令确认导入的结果是否正确：：</para>

      <screen>
$ svn list --verbose file:///path/to/repos
      1 harry               May 08 21:48 projectA/
      1 harry               May 08 21:48 projectB/
…
$
</screen>

      <para>创建了版本库布局以后，如果有项目的初始数据，那么可以将这些数据导入到版本库中。同样有很多中方法完成这项工作。首先，可以使用<command>svn import</command>命令。也可以先从版本库中取出工作副本，将已有的项目数据复制到工作副本中，再使用<command>svn add</command>和<command>svn commit</command>命令提交修改。不过这些工作就不属于版本库管理方面的内容了。如果对<command>svn</command> 客户端程序还不熟悉，阅读<xref linkend="svn-ch-3" />。</para>
    </sect2>
  </sect1>

  <!-- ******************************************************************* -->

  <!-- *** 第七部分:  总结                                             *** -->

  <!-- ******************************************************************* -->

  <sect1 id="svn-ch-5-sect-7">
    <title>总结</title>

    <para>现在，你应该已经对如何创建、配置以及维护Subversion版本库有了个基本的认识。我们向您介绍了几个可以帮助您工作的工具。通过这一章，我们说明了一些通常的管理的误区，并提出了避免陷入误区的建议。</para>

    <para>剩下的，就是由你决定在你的版本库中存放一些什么有趣的资料，并最终通过网络获得这些资料。下一章是关于网络的内容。</para>
  </sect1>
</chapter>
<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->