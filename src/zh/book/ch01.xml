<chapter id="svn.intro">

  <title>介绍</title>

  <simplesect>
    <para>版本控制是管理信息变化的艺术。对于经常对软件改来改去的程序员来说，它早就是重要的工具。但是版本控制软件的价值已远远超出软件开发的领域。总是可以看到人们使用计算机管理易变的信息，这正是版本控制的生存之道，也是Subversion表演的舞台。</para>

    <para>本章综述了Subversion的基本情况&mdash;什么是Subversion？Subversion能做什么？从哪里能获得Subversion？</para>

  </simplesect>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.intro.whatis">

    <title>Subversion是什么？</title>
      
    <para>Subversion是一个自由/开源的版本控制系统。也就是说，在Subversion管理下，文件和目录可以超越时空。Subversion将文件存放在中心<firstterm>版本库</firstterm>里。这个版本库很像一个普通的文件服务器，不同的是，它可以记录每一次文件和目录的修改情况。于是我们就可以籍此将数据回复到以前的版本，并可以查看数据的更改细节。正因为如此，许多人将版本控制系统当作一种神奇的<quote>时间机器</quote>。</para>
    
    <para>Subversion的版本库可以通过网络访问，从而使用户可以在不同的电脑上进行操作。从某种程度上来说，允许用户在各自的空间里修改和管理同一组数据可以促进团队协作。因为修改不再是单线进行（单线进行也就是必须一个一个进行），开发进度会进展迅速。此外，由于所有的工作都已版本化，也就不必担心由于错误的更改而影响软件质量&mdash;如果出现不正确的更改，只要撤销那一次更改操作即可。</para>

    <para>某些版本控制系统本身也是软件配置管理（SCM）系统，这种系统经过精巧的设计，专门用来管理源代码树，并且具备许多与软件开发有关的特性&mdash;比如，对编程语言的支持，或者提供程序构建工具。不过Subversion并不是这样的系统。它是一个通用系统，可以管理<emphasis>任何</emphasis>类型的文件集。对你来说，这些文件这可能是源程序&mdash;而对别人，则可能是一个货物清单或者是数字电影。</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.intro.history">

    <title>Subversion的历史</title>

    <para>早在2000年，CollabNet, Inc. (<ulink url="http://www.collab.net"/>)就开始寻找CVS替代产品的开发人员。CollabNet提供了一个名为CollabNet企业版（CEE）
      <footnote>
        <para>也有一个针对小团队的CollabNet团队版（CTE）。</para>
    </footnote>
    的协作软件套件。这个软件套件的一个组成部分就是版本控制系统。尽管CEE在最初采用了CVS作为其版本控制系统，但是CVS的局限性从一开始就很明显，CollabNet知道，迟早要找到一个更好的替代品。遗憾的是，CVS之所以成为开源世界<foreignphrase>事实上的</foreignphrase>标准，很大程度上是因为<emphasis>没有</emphasis>更好的替代品，至少是没有可以自由使用的替代品。所以CollabNet决定从头编写一个新的版本控制系统，这个系统保留CVS的基本思想，但是要修正其中的错误和不合理的特性。</para>

    <para>2000年2月，他们联系到<citetitle>Open Source Development with CVS</citetitle>(Coriolis, 1999)的作者Karl Fogel，并且询问他是否希望为这个新项目工作。巧合的是，当时Karl正在与朋友Jim Blandy讨论设计一个新的版本控制系统。1995年时，他们两人曾经开办了一个提供CVS支持的公司Cyclic Software，尽管他们最终卖掉了公司，但还是天天使用CVS进行日常工作。在使用CVS时的挫折促使Jim认真的思考如何管理版本化的数据，并且当时他不仅使用了<quote>Subversion</quote>这个名字，并且已经完成了Subversion版本库的最初设计。所以当CollabNet提出邀请的时候，Karl马上同意为这个项目工作，同时Jim也使他的雇主&mdash;Red Hat软件公司&mdash;允许他到这个项目工作，并且没有限定最终的期限。CollabNet雇佣了Karl和Ben Collins Sussman，详细设计工作从三月开始，在Behlendorf 、CollabNet、Jason Robbins和Greg Stein（当时是一个独立开发者，活跃在WebDAV/DeltaV系统规范制订工作中）恰到好处的激励下，Subversion很快吸引了许多活跃的开发者，结果使得许多具有CVS经验的人们很乐于为这个项目做些事情。</para>

    <para>最初，设计小组设定了一些简单的开发目标。他们不想在版本控制方法学中开垦处女地，他们只是希望修正CVS。他们决定Subversion应符合CVS的特性，并保留相同的开发模型，但不再重复CVS的一些显著缺陷。尽管Subversion并不需要成为CVS的完全替代品，但它应该与CVS保持足够的相似性，以使CVS用户可以轻松的转移到Subversion上。</para>

    <para>经过14个月的编码，2001年8月31日，Subversion能够<quote>自己管理自己</quote>了，开发者停止使用CVS保存Subversion的代码，而使用Subversion本身。</para>

    <para>当CollabNet启动了这个项目，并且一直提供了大量的工作支持（它为一些全职的Subversion开发者提供薪水），Subversion像其它许多开源项目一样，被松散的、透明的规则管理着，这样的规则激励着知识界的精英们。CollabNet的版权许可证完全符合Debian的自由软件方针。也就是说，任何人都可以根据自己的意愿自由的下载、修改和重新发布Subversion，不需要CollabNet或其他人的授权。</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.intro.features">

    <title>Subversion的特性</title>

    <para>Subversion将很多新特性引入版本控制领域。在讲解这些特性时，我们会经常性的与CVS进行对比，以说明Subversion比CVS高明在哪里。如果不熟悉CVS，了解所有Subversion的特性会有一定的困难。而如果根本就不熟悉版本控制，你就只有干瞪眼的份儿了。因此，最好首先阅读一下<xref linkend="svn.basic"/>，这一章简单介绍了一些版本控制的基本思想和概念。</para>

    <para>Subversion支持：</para>

    <variablelist>
      <varlistentry>
        <term>版本化的目录</term>
        <listitem>
          <para>CVS只能跟踪单个文件的变更历史，但是Subversion实现的<quote>虚拟</quote>版本化文件系统则可以跟踪目录树的变更。在Subversion中，文件<emphasis>和</emphasis>目录都是版本化的。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>真实的版本历史</term>
        <listitem>
          <para>由于只能跟踪单个文件的变更，CVS无法支持如文件拷贝和改名这些常见的操作&mdash;这些操作改变了目录的内容。同样，在CVS中，目录下的文件只要名字相同即拥有相同的历史，即使这些同名文件在历史上毫无关系。而在Subversion中，可以对文件或目录进行增加、拷贝和改名操作，也解决了同名而无关的文件之间的历史联系问题。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>原子提交</term>
        <listitem>
          <para>一系列相关的更改，要么全部提交到版本库，要么一个也不提交。这样用户就可以将相关的更改组成一个逻辑整体，防止出现部分修改而另一部分未修改的情况提交到版本库中。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>版本化的元数据</term>
        <listitem>
          <para>每一个文件和目录都有自己的一组属性&mdash;键和它们的值。可以根据需要建立并存储任何键/值对。和文件本身的内容一样，属性也在版本控制之下。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>可选的网络层</term>
        <listitem>
          <para>Subversion在版本库访问的实现上具有较高的抽象程度，利于人们实现新的网络访问机制。Subversion可以作为一个扩展模块嵌入到Apache之中。这种方式在稳定性和交互性方面有很大的优势，可以直接使用服务器的成熟技术&mdash;认证、授权和传输压缩等等。此外，Subversion自身也实现了一个轻型的，可独立运行的服务器软件。这个服务器使用了一个特定的协议，这个协议可以轻松的用SSH封装。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>一致的数据操作</term>
        <listitem>
          <para>Subversion用一个二进制差异算法描述文件的变化，对于文本（可读）和二进制（不可读）文件其操作方式是一致的。这两种类型的文件压缩存储在版本库中，而差异信息则在网络上双向传递。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>高效的分支和标签操作</term>
        <listitem>
          <para>在Subversion中，分支与标签操作的开销与工程的大小无关。Subversion的分支和标签操作用只是一种类似于硬链接的机制拷贝整个工程。因而这些操作通常只会花费很少且相对固定的时间。
          </para>
        </listitem>
      </varlistentry>
      
      <varlistentry>
        <term>可修改性</term>
        <listitem>
          <para>Subversion没有历史负担，它以一系列优质的共享C程序库的方式实现，具有定义良好的API。这使得Subversion非常容易维护，和其它语言的互操作性很强。</para>
        </listitem>
      </varlistentry>

    </variablelist>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.intro.architecture">

    <title>Subversion的架构</title>

    <para><xref linkend="svn.intro.architecture.dia-1"/>给出了Subversion设计总体上的<quote>俯视图</quote>。</para>
    
    <figure id="svn.intro.architecture.dia-1">
      <title>Subversion的架构</title>
      <graphic fileref="images/ch01dia1.png"/>
    </figure>

    <para>图中的一端是保存所有在版本控制下数据的Subversion版本库，另一端是Subvesion的客户端程序，管理着所有在版本控制下数据的本地影射（称为<quote>工作拷贝</quote>），在这两极之间是各种各样的版本库访问（RA）层，某些使用电脑网络通过网络服务器访问版本库，某些则绕过网络服务器直接访问版本库。</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.intro.install">

    <title>安装Subversion</title>

    <para>
    Subversion建立在一个可移植层上，叫做APR&mdash;Apache Portable Runtime library，APR库提供了许多Subversion在多种操作系统上需要的功能：磁盘访问、内存管理等等。虽然Subversion可以使用Apache作为服务器程序，这种对APR的依赖并不意味着Apache是必需的组件，APR是可以独立使用的库。这意味着Subversion可以在所有可运行Apache服务器的平台上工作：Windows、Linux、各种BSD、Mac OS X、Netware以及其他。</para>

    <para>
    最简单的安装办法就是下载相应操作系统的二进制包，Subversion的网站（<ulink url="http://subversion.tigris.org"/>）上通常会有志愿者提供的包可以下载，对于微软操作系统，网站上通常会有图形化的安装包，对于类Unix系统，你可以使用它们本身的打包系统（PRMs、DEBs、ports tree等等）得到Subversion。</para>

    <para>
    你也可以选择从源代码直接编译Subversion，从网站下载最新的源代码，解压缩，根据<filename>INSTALL</filename>文件的指导进行编译。注意，通过这些源代码可以完全编译访问服务器的命令行客户端工具（通常是apr，apr-util和neno库）。但是可选部分有许多依赖，如Berkeley DB和Apache httpd。如果你希望做一个完全的编译，确定你有所有<filename>INSTALL</filename>文件中记述的包。如果你计划通过Subversiong本身工作，你可以使用客户端程序取得最新的，带血的源代码，这部分内容见<xref
      linkend="svn.developer.contrib.get-code"/>。</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.intro.components">

    <title>Subversion的组件</title>
    
    <para>
    Subversion安装之后，分为几个部分，这是一个快速浏览。不要害怕这些让你挠头的简略描述，本书有<emphasis>足够的</emphasis>内容来减少这种混乱。</para>

    <variablelist>
      <varlistentry>
        <term>svn</term>
        <listitem>
          <para>命令行客户端。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>svnversion</term>
        <listitem>
          <para>报告工作拷贝状态（当前修订版本的项目）的工具。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>svnlook</term>
        <listitem>
          <para>检查版本库的工具。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>svnadmin</term>
        <listitem>
          <para>建立、调整和修补版本库的工具。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>svndumpfilter</term>
        <listitem>
          <para>过滤Subversion版本库转储文件的工具。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>mod_dav_svn</term>
        <listitem>
          <para>Apache HTTP服务器的一个插件，可以让版本库在网络上可见。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>svnserve</term>
        <listitem>
          <para>一种单独运行的服务器，可以作为守护进程由SSH调用，另一种让版本库在网络上可见的方式。</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>假定你已经将Subversion正确安装，你已经准备好开始，下两章将带领你使用<command>svn</command>，Subversion的客户端程序。</para>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.intro.quickstart">

    <title>快速入门</title>
    
    <para>
    许多人为<quote>从头到尾</quote>的方式读一本介绍有趣新技术的书感到发愁，这一小节是一个很短的介绍，给许多<quote>实用</quote>的用户一个实战的机会，如果你是一个喜欢通过实验进行学习的用户，以下将告诉你怎么做，相对应，我们给出这本书相关的链接。</para>

    <para>
    如果版本控制或者Subversion和CVS都用到的<quote>拷贝-修改-合并</quote>模型对于你来说是完全的新概念，在进一步阅读之前，你首先要读<xref linkend="svn.basic"/>。</para>

    <note>
      <para>
      以下的例子假定你有了1.2或更新的Subversion程序（运行<command>svn --version</command>来检查版本）。</para>
    </note>

    <para>
    Subversion存储所有版本控制的数据到一个中心版本库，作为开始，新建一个版本库：</para>

    <screen>
$ svnadmin create /path/to/repos
$ ls /path/to/repos
conf/  dav/  db/  format  hooks/  locks/  README.txt
</screen>

    <para>
    这个命令建立了一个新的目录<filename>/path/to/repos</filename>，包含了一个Subversion版本库。这个目录保存了一些数据库文件，你打开后看不到你的已经版本化的文件。更多的版本库创建和维护信息，见<xref linkend="svn.reposadmin"/>。</para>

    <para>Subversion没有<quote>项目</quote>的概念，版本库只是一个虚拟的版本化文件系统，可以存放你想要得任何文件。有的管理员倾向于一个版本库只存放一个项目，有的则喜欢存放多个项目到一个版本库不同的目录里，每中方式的优点将会在<xref 
 linkend="svn.reposadmin.projects.chooselayout"/>讨论。每种方式，版本库都是以<quote>项目</quote>管理文件和目录，所以或许你会在整本书中经常发现项目这个词，需要记住我们只是在谈论版本库中的一些目录（或者是一组目录）。</para>

    <para>在这个例子里，我们假定你已经有了一些希望导入到Subversion版本库的项目（一组文件和目录）。首先把这些条目整理到同一个叫做<filename>myproject</filename>（或任何名称）的目录里，你的项目要有<filename>branches</filename>、<filename>tags</filename>和<filename>trunk</filename>三个顶级目录，后面你就会知道这样做的原因。<filename>trunk</filename>目录保存所有的数据，而<filename>branches</filename>和<filename>tags</filename>都是空的：</para>

    <screen>
/tmp/myproject/branches/
/tmp/myproject/tags/
/tmp/myproject/trunk/
                     foo.c
                     bar.c
                     Makefile
                     &hellip;
</screen>

    <para><filename>branches</filename>、<filename>tags</filename>和<filename>trunk</filename>子目录不是Subversion必需的，它们只是稍候你就会希望使用的流行习惯。</para>

    <para>一旦你你已经准备好了数据，就可以使用<command>svn import</command>命令（见<xref linkend="svn.tour.other.import"/>）将其导入到版本库：
    </para>

    <screen>
$ svn import /tmp/myproject file:///path/to/repos/myproject -m "initial import"
Adding         /tmp/myproject/branches
Adding         /tmp/myproject/tags
Adding         /tmp/myproject/trunk
Adding         /tmp/myproject/trunk/foo.c
Adding         /tmp/myproject/trunk/bar.c
Adding         /tmp/myproject/trunk/Makefile
&hellip;
Committed revision 1.
$ 
</screen>

    <para>现在版本库包含了这个目录树的数据，如前所述，直接察看版本库看不到文件和目录；它们存放在数据库当中，但是版本库假想的文件系统现在保存了顶级的目录<filename>myproject</filename>，其中保存了你的数据。
   </para>

    <para>注意最初的<filename>/tmp/myproject</filename>并没有改变，Subversion并没有处理它（实际上，你可以随意删除这个目录）。为了开始处理版本库数据，你需要创建一个新的包含数据的<quote>工作拷贝</quote>，这是一个私有工作区。从Subversion版本库里<quote>check out</quote>出一个<filename>myproject/trunk</filename>目录的工作拷贝：
   </para>

    <screen>
$ svn checkout file:///path/to/repos/myproject/trunk myproject
A  myproject/foo.c
A  myproject/bar.c
A  myproject/Makefile
&hellip;
Checked out revision 1.
</screen>
    <para>
    你现在在<filename>myproject</filename>目录里有了一个版本库的个人拷贝，你可以编辑你的工作备份中的文件，并且提交到版本库。</para>

    <itemizedlist>
      <listitem>
        <para>进入到你的工作备份，编辑一个文件的内容。</para>
      </listitem>
      <listitem>
        <para>运行<command>svn diff</command>来查看你的修改的标准区别输出。</para>
      </listitem>
      <listitem>
        <para>运行<command>svn commit</command>来提交你的改变到版本库。</para>
      </listitem>
      <listitem>
        <para>运行<command>svn update</command>将你的工作拷贝与版本库<quote>同步</quote>。</para>
      </listitem>
    </itemizedlist>

    <para>对于你对工作拷贝可做操作的完全教程可以察看<xref linkend="svn.tour"/>。</para>

    <para>
    目前，你可以选择使你的版本库在网络上可见，可以参考<xref
      linkend="svn.serverconfig"/>，学习使用不同的服务器以及配置。</para>

  </sect1>


</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
