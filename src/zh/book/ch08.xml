<chapter id="svn-ch-8">
  <title>开发者信息</title>
  
  <simplesect>
    <para>Subversion是一个开源的软件项目，使用Apache样式的软件许可证。这个项目由加利福尼亚为基地的CollabNet, Inc.软件开发公司资助。这个关于Subversion开发的社区一直欢迎新成员贡献自己的时间和注意力。鼓励志愿者做他们想做的任何帮助，不管是发现和诊断bug，精炼存在的代码还是补充新的特性。
   </para>
    
    <para>本章是为那些希望亲自参与源代码来帮助Subversion进化的人们准备的，我们会覆盖许多软件内在的细节，关系到开发Subversion本质的技术&mdash;或者是使用Subversion库编写全新的工具&mdash;必须意识到这一点。如果你没有预见到你会以这种层次参与到软件中来，也可以随意掠过这一张你作为Subversion用户的经验不会受到影响。
   </para>

  </simplesect>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 1:  LAYERED LIBRARY DESIGN                          *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-8-sect-1">
    <title>分层的库设计</title>

    <para>Subversion有一个模块化的设计，通过一套C库实现。每一个库都有一套定义良好的目的和接口，每一个模块都属于三层中某一层&mdash;版本库层，版本库访问（RA）层或是客户端层。我们会立刻考察这些层，但是首先让我们看一下<xref linkend="svn-ch-8-table-1"/>中的Subversion库的摘要目录，为了一致性，我们通过他们的Unix库名称（例如libsvn_fs、libsvn_wc和mod_dav_svn）来引用它们。</para>

    <table id="svn-ch-8-table-1">
      <title>A Brief Inventory of the Subversion Libraries</title>
      <tgroup cols="2">
        <thead>
          <row>
            <entry>库</entry>
            <entry>描述</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>libsvn_client</entry> 
            <entry>客户端程序的主要接口</entry>
          </row>
          <row>
            <entry>libsvn_delta</entry>
            <entry>目录树和文本区别程序</entry>
          </row>
          <row>
            <entry>libsvn_fs</entry>
            <entry>Subversion文件系统库</entry>
          </row>
          <row>
            <entry>libsvn_fs_base</entry>
            <entry>Berkeley DB文件系统后端</entry>
          </row>
          <row>
            <entry>libsvn_fs_fs</entry>
            <entry>本地文件系统（FSFS）后端</entry>
          </row>
          <row>
            <entry>libsvn_ra</entry>
            <entry>版本库访问通用组件和模块装载器</entry>
          </row>
          <row>
            <entry>libsvn_ra_dav</entry>
            <entry>WebDAV版本库访问模块</entry>
          </row>
          <row>
            <entry>libsvn_ra_local</entry>
            <entry>本地版本库访问模块</entry>
          </row>
          <row>
            <entry>libsvn_ra_svn</entry>
            <entry>一个自定义版本库访问模块</entry>
          </row>
          <row>
            <entry>libsvn_repos</entry>
            <entry>版本库接口</entry>
          </row>
          <row>
            <entry>libsvn_subr</entry>
            <entry>各种有用的子程序</entry>
          </row>
          <row>
            <entry>libsvn_wc</entry>
            <entry>工作拷贝管理库</entry>
          </row>
          <row>
            <entry>mod_authz_svn</entry>
            <entry>使用WebDAV访问Subversion版本库的Apache授权模块</entry>
          </row>
          <row>
            <entry>mod_dav_svn</entry>
            <entry>影射WebDAV操作为Subversion操作的Apache模块</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>单词<quote>各种</quote>只在列表<xref linkend="svn-ch-8-table-1"/>出现了一次是一个好的迹象。Subversion开发团队十分看重功能所在的层库，或许模块化设计最大的好处就是从开发者角度看减少了复杂性。作为一个开发者，你很快可以明确的说明那副<quote>大图片</quote>，允许你容易的找出某一块功能所在的位置。</para>

    <para>模块化的另一个好处是我们有能力用实现同样API的新模块替换整个给定的模块，而又不会影响代码基础。在一些方面，Subversion已经这样做了。libsvn_ra_dav、libsvn_ra_local和libsvn_ra_svn all都实现了同样的接口，三个都与版本库层通讯&mdash;libsvn_ra_dav和libsvn_ra_svn通过网络，而libsvn_ra_local则是直接连接。
   </para>

    <para>在Subversion的设计中，客户端本身也集萃了许多模块。虽然Subversion目前只是伴随了一个命令行的客户端，但也已经有一些第三方设计的GUI程序，这些GUI程序使用命令行客户端同样的API。Subversion的libsvn_client库集合了作为Subversion客户端的几乎所有必要的功能（见<xref
      linkend="svn-ch-8-sect-1.3"/>）。</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-8-sect-1.1">
      <title>版本库层</title>

      <para>当提到Subversion的版本库层，我们通常会讨论两个库&mdash;版本库库和文件系统库。这两个库为多修订版本中版本控制的数据提供了存储和报告机制，这一层是通过版本库访问层连接到客户端层的，同样，从Subversion用户的角度，这件事是<quote>在绳子的另一端。</quote></para>

      <para>Subversion文件系统是通过libsvn_fs的API访问的，这不是一个可以安装到操作系统（例如Linux ext2或NTFS）的内核级文件系统，而是一个虚拟文件系统。不是用真实的文件和目录（也就是你用shell程序可以导航的那种）保存<quote>文件</quote>和<quote>目录</quote>，而是从两种抽象后端方式中选择一种使用&mdash;一个是Berkeley DB数据库环境或者是一个普通文件表示。（为了了解更多关于版本库后端的信息，请看<xref
        linkend="svn-ch-5-sect-1.3"/>）。然而，社区也非常有兴趣考虑使Subversion具备使用其它后端数据库系统的能力，或许通过一个类似开放式数据库连接（JDBC）的机制。</para>

      <para>libsvn_fs支持的文件系统API包含了所有其他文件系统的功能：你可以创建和删除文件和目录、拷贝和移动、修改文件内容等等。它也包含了一些不太常用的特性，如对任意文件和目录添加、修改和删除元数据（<quote>properties</quote>）的能力。此外，Subversion文件系统是一个版本化的文件系统，意味着你修改你的目录树时，Subversion会记住修改以前的样子。等等，所有的回到开始版本化的时间是在添加到文件系统的时候（且刚刚超过***）。</para>

      <para>所有你对目录树的修改包含在Subversion事务的上下文中，下面描述了修改文件系统的例程：
      </para>

      <orderedlist>
        <listitem>
          <para>开始Subversion事务。</para>
        </listitem>
        <listitem>
          <para>作出修改（添加、删除、属性修改等等。）。</para>
        </listitem>
        <listitem>
          <para>提交事务。</para>
        </listitem>
      </orderedlist>

      <para>一旦你提交了你的事务，你的文件系统修改就会永久的作为历史保存起来，每个这样的周期会产生一个新的树，所有的修订版本都是永远可以访问的一个不变的快照。</para>

      <sidebar>
        <title>事务其它</title>

        <para>Subversion的事务概念，特别是在libsvn_fs中的数据库附近的代码，很容易与低层提供支持的数据库事务混淆。两种类型事务都提供了原子和隔离操作，换句话说，事务给你能力可以用<quote>全部或者没有</quote>样式执行一系列的动作&mdash;所有的动作都完全成功，或者是所有的<emphasis>没有</emphasis>发生&mdash;而且不会干扰别人操作数据。
       </para>

        <para>数据库事务通常围绕着一些对数据库本身的数据修改相关的小操作（如修改表行的内容），Subversion是更大范围的事务，围绕着一些高一级的操作，如下一个修订版本文件系统的一组文件和目录的修改。如果这还不是很混乱，考虑这个：Subversion在创建Subversion事务（所以如果Subversion创建事务失败，数据库会看起来我们从来没有尝试创建）时会使用一个数据库事务！
       </para>

        <para>很幸运的是用户的文件系统API，数据库提供的事务支持本身几乎完全从外表隐藏（也是一个完全模块化的模式所应该的）。只有当你开始研究文件系统本身的实现时，这些事情才可见（或者是开始感兴趣）。
       </para>

      </sidebar>

      <para>大多数文件系统接口提供的功能作为一个动作发生在一个文件系统路径上，也就是，从文件系统的外部，描述和访问文件和目录独立版本的主要机制是经过如<filename>/foo/bar</filename>的路径，就像你在喜欢的shell程序中定位文件和目录。你通过传递它们的路径到相应的API功能来添加新的文件和目录，查询这些信息也是同样的机制。
     </para>

      <para>不像大多数文件系统，尽管，一个单独的路径不足以在Subversion定位一个文件或目录，可以把目录树看作一个二维的系统，一个节点的兄弟代表了一种从左到右的动作，并且递减到子目录是一个向下的动作，<xref linkend="svn-ch-8-dia-1"/>展示了一个典型的树的形式。
     </para>

      <figure id="svn-ch-8-dia-1">
        <title>二维的文件目录</title>
        <graphic fileref="images/ch08dia1.png"/>
      </figure>

      <para>当然，Subversion文件系统有一个其它文件系统的第三维&mdash;时间！
        <footnote>
          <para>我们理解这一定会给科幻小说迷带来一个震撼，他们认为时间是<emphasis>第四</emphasis>维的，我们要为提出这样一个不同理论的断言而伤害了他们的作出道歉。
         </para>
        </footnote>
        在一个文件系统接口，几乎所有的功能都有个<parameter>路径</parameter>参数，也期望一个<parameter>root</parameter>参数。<structname>svn_fs_root_t</structname>参数不仅描述了一个修订版本或一个Subversion事务（通常正好是一个修订版本），而且提供了用来区分修订版本32的<filename>/foo/bar</filename>和修订版本98在同样路径的三维上下文环境。<xref
        linkend="svn-ch-8-dia-2"/>展示了修订版本历史作为添加的纬度进入到Subversion文件系统领域。
        </para>

      <figure id="svn-ch-8-dia-2">
        <title>版本时间&mdash;第三维！</title>
        <graphic fileref="images/ch08dia2.png"/>
      </figure>

      <!-- Perhaps dig into the DAG/tree layers a bit here, talking
           about the hard-link design and how that affords such
           pleasures as cheap copies.  If "bubble-up" isn't covered
           twelve other times in the book, maybe give it a go here. -->

      <para>像之前我们提到的，libsvn_fs的API感觉像是其它文件系统，只是有一个美妙的版本化能力。它设计为为所有对版本化的文件系统有兴趣的程序使用，不是巧合，Subversion本身也对这个功能很有兴趣。但是虽然文件系统API一定必须对基本的文件和目录版本化提供足够的支持，Subversion需要的更多&mdash;这是libsvn_repos到来的地方。
     </para>

      <para>Subversion版本库库（libsvn_repos）是文件系统功能的一个基本包裹库，这个库负责创建版本库布局，确定底层的文件系统已经初始化等等。Libsvn_repos也实现了一组钩子&mdash;当特定动作发生时版本库执行的脚本。这些脚本用来通知，授权或者任何版本库管理员期望的目的。版本库库提供的这些功能和小工具与版本化的文件系统关系不大，所以放到了自己的库里。
     </para>
      
      <para>希望使用libsvn_repos的API的开发者会发现它不是文件系统的一个完全包裹，只有文件系统常规周期中的主要事件使用版本库接口包裹，如包括Subversion事务的创建和提交，修订版本属性的修改。这些特别的事件使用版本库库包裹是因为它们有一些关联的钩子，在将来，别的事件也将会使用版本库API包裹。所有其它的文件系统交互会直接通过libsvn_fs的API发生。
     </para>

      <para>举个例子，这里是使用版本库和文件系统接口创建文件系统新修订版本的代码块，新版本包括添加一个新目录。注意这个例子（和其它本书中的代码），这个<function>SVN_ERR</function>宏只是简单的检查是否有一个非成功的错误从包裹的函数中返回，如果存在就会返回错误。
     </para>

      <example id="svn-ch-8-sect-1.1-ex-1">
        <title>使用版本库层</title>

        <programlisting>
/* Create a new directory at the path NEW_DIRECTORY in the Subversion
   repository located at REPOS_PATH.  Perform all memory allocation in
   POOL.  This function will create a new revision for the addition of
   NEW_DIRECTORY.  */
static svn_error_t *
make_new_directory (const char *repos_path,
                    const char *new_directory,
                    apr_pool_t *pool)
{
  svn_error_t *err;
  svn_repos_t *repos;
  svn_fs_t *fs;
  svn_revnum_t youngest_rev;
  svn_fs_txn_t *txn;
  svn_fs_root_t *txn_root;
  const char *conflict_str;

  /* Open the repository located at REPOS_PATH.  */
  SVN_ERR (svn_repos_open (&amp;repos, repos_path, pool));

  /* Get a pointer to the filesystem object that is stored in
     REPOS.  */
  fs = svn_repos_fs (repos);

  /* Ask the filesystem to tell us the youngest revision that
     currently exists.  */
  SVN_ERR (svn_fs_youngest_rev (&amp;youngest_rev, fs, pool));

  /* Begin a new transaction that is based on YOUNGEST_REV.  We are
     less likely to have our later commit rejected as conflicting if we
     always try to make our changes against a copy of the latest snapshot
     of the filesystem tree.  */
  SVN_ERR (svn_fs_begin_txn (&amp;txn, fs, youngest_rev, pool));

  /* Now that we have started a new Subversion transaction, get a root
     object that represents that transaction.  */
  SVN_ERR (svn_fs_txn_root (&amp;txn_root, txn, pool));
  
  /* Create our new directory under the transaction root, at the path
     NEW_DIRECTORY.  */
  SVN_ERR (svn_fs_make_dir (txn_root, new_directory, pool));

  /* Commit the transaction, creating a new revision of the filesystem
     which includes our added directory path.  */
  err = svn_repos_fs_commit_txn (&amp;conflict_str, repos, 
                                 &amp;youngest_rev, txn, pool);
  if (! err)
    {
      /* No error?  Excellent!  Print a brief report of our success.  */
      printf ("Directory '%s' was successfully added as new revision "
              "'%ld'.\n", new_directory, youngest_rev);
    }
  else if (err->apr_err == SVN_ERR_FS_CONFLICT)
    {
      /* Uh-oh.  Our commit failed as the result of a conflict
         (someone else seems to have made changes to the same area 
         of the filesystem that we tried to modify).  Print an error
         message.  */
      printf ("A conflict occurred at path '%s' while attempting "
              "to add directory '%s' to the repository at '%s'.\n", 
              conflict_str, new_directory, repos_path);
    }
  else
    {
      /* Some other error has occurred.  Print an error message.  */
      printf ("An error occurred while attempting to add directory '%s' "
              "to the repository at '%s'.\n", 
              new_directory, repos_path);
    }

  /* Return the result of the attempted commit to our caller.  */
  return err;
} 
</programlisting>
      </example>

      <para>在前面的代码片断中，同时调用了版本库和文件系统接口，我们可以正像这样简单的用<function>svn_fs_commit_txn</function>提交事务。但是文件系统的API对版本库库的钩子一无所知，如果你希望你的Subversion版本库在每次提交一个事务时自动执行一些非Subversion的任务（例如，给开发者邮件组发送一个描述事务修改的邮件），你需要使用libsvn_repos包裹的功能版本&mdash;<function>svn_repos_fs_commit_txn</function>。这个功能会实际上首先运行一个如果存在的<literal>pre-commit</literal>钩子脚本，然后提交事务，最后会运行一个<literal>post-commit</literal>钩子脚本。钩子提供了一种特别的报告机制，不是真的属于核心文件系统库本身。（关于Subversion版本库钩子的更多信息，见<xref
        linkend="svn-ch-5-sect-2.1" />。）</para>
      
      <para>钩子机制需求是从文件系统代码的其它部分中抽象出单独的版本库库的一个原因，libsvn_repos的API提供了许多其他有用的工具，它们可以做到：
     </para>

      <orderedlist>
        <listitem>
          <para>在Subversion版本库和版本库包括的文件系统的上创建、打开、销毁和执行恢复步骤。</para>
        </listitem>
        <listitem>
          <para>描述两个文件系统树的区别。</para>
        </listitem>
        <listitem>
          <para>关于所有（或者部分）修订版本中的文件系统中的一组文件的提交日志信息的查询</para>
        </listitem>
        <listitem>
          <para>产生可读的文件系统<quote>导出</quote>，一个文件系统修订版本的完整展现。
          </para>
        </listitem>
        <listitem>
          <para>解析导出格式，加载导出的版本到一个不同的Subversion版本库。
          </para>
        </listitem>
      </orderedlist>

      <para>伴随着Subversion的发展，版本库库会随着文件系统提供更多的功能和配置选项而不断成长。
      </para>

    </sect2>

    <!-- ****************************************************************** -->
    <sect2 id="svn-ch-8-sect-1.2">
      <title>版本库访问层</title>

      <para>如果说Subversion版本库层是在<quote>这条线的另一端</quote>，那版本库访问层就是这条线。负责在客户端库和版本库之间编码数据，这一层包括libsvn_ra模块加载模块，RA模块本身（现在包括了libsvn_ra_dav、libsvn_ra_local和libsvn_ra_svn），和所有一个或多个RA模块需要的附加库，例如与Apache模块mod_dav_svn通讯的libsvn_ra_dav或者是libsvn_ra_svn的服务器，<command>svnserve</command>。
     </para>

      <para>因为Subversion使用URL来识别版本库资源，URL模式的URL部分（通常是<literal>file:</literal>、<literal>http:</literal>、<literal>https:</literal>或<literal>svn:</literal>）用来监测那个RA模块用来处理通讯。每个模块注册一组它们知道如何<quote>说话</quote>的协议，所以RA加载器可以在运行中监测在手边的任务中使用那个模块。通过运行<command>svn --version</command>，你可以监测Subversion命令行客户端所支持的RA模块和他们声明支持的协议：</para>
     
      <screen>
$ svn --version
svn, version 1.0.1 (r9023)
   compiled Mar 17 2004, 09:31:13

Copyright (C) 2000-2004 CollabNet.
Subversion is open source software, see http://subversion.tigris.org/
This product includes software developed by CollabNet (http://www.Collab.Net/).

The following repository access (RA) modules are available:

* ra_dav : Module for accessing a repository via WebDAV (DeltaV) protocol.
  - handles 'http' schema
  - handles 'https' schema
* ra_local : Module for accessing a repository on local disk.
  - handles 'file' schema
* ra_svn : Module for accessing a repository using the svn network protocol.
  - handles 'svn' schema
</screen>
    
      <sect3 id="svn-ch-8-sect-1.2.1">
        <title>RA-DAV（使用HTTP/DAV版本库访问）</title>

        <para>libsvn_ra_dav库是给在不同机器使用<literal>http:</literal>或<literal>https:</literal>协议访问服务器的用户设计的，为了理解这个模块的工作，我们首先要知道这种版本库访问层中的特定配置的关键组成部分&mdash;强大的Apache HTTP服务器，和Neon HTTP/WebDAV客户端库。</para>
  
        <para>Subversion的主要网络服务器是Apache HTTP服务器，Apache是久经考验的用来认真使用的开源服务器，它可以支撑很大的网络压力并且可以运行在多种平台。Apache服务器支持多种认证协议，而且可以通过模块扩展使用其它协议。它也支持流水线和缓存之类的网络优化。通过将Apache作为服务器，Subversion轻易得到这些特性。而且因为许多防火墙已经允许HTTP通过，系统管理员通常不会改变防火墙设置来允许Subversion工作。</para>
  
        <para>Subversion使用HTTP和WebDAV（和DeltaV）来与Apache服务器通讯，你可以在本章的WebDAV读到更多信息，但简而言之，WebDAV和DeltaV是标准HTTP 1.1协议的扩展，允许在web上对文件进行分享和版本操作。Apache 2.0版随着一个mod_dav，一个Apache理解HTTP DAV扩展的模块，Subversion本身提供了mod_dav_svn，尽管，这是另一个Apache模块，它与mod_dav结合（实际上mod_dav_svn是作为后端支持）使用来提供Subversion对WebDAV和DeltaV的实现。</para>

        <para>当与版本库通过HTTP通讯时，RA加载器库选择libsvn_ra_dav作为正确的访问模块，Subversion客户端调用原始的RA接口，libsvn_ra_dav把这些调用（包含了大量Subversion操作）影射为一系列HTTP/WebDAV请求。使用Neon库，libsvn_ra_dav把这些请求传递到Apache服务器，Apache接受到这些请求（就像平时web服务器常做的那样处理原始的HTTP请求），注意到这些请求的URL已经配置为DAV的位置（使用<filename>httpd.conf</filename>的<sgmltag>Location</sgmltag>指示），并且会使用自己的mod_dav模块来处理。当正确的配置了mod_dav使之知道了使用mod_dav_svn来处理所有文件系统相关的要求，而不是使用默认的Apache自带的原始mod_dav_fs来处理。所以最终客户端是与mod_dav_svn通讯，直接与Subversion版本库层绑定。</para>
  
        <para>有一个实际交换发生的简单描述，举个例子，Subversion版本库可以使用Apache的授权指示进行保护。这会导致初始的与版本库的通讯会被Apache的授权基础拒绝，在此刻，libsvn_ra_dav将提供不足鉴定的通知返回，并且回调客户端层来得到一些更新的认证数据。如果数据是正确提供，而且用户有访问的权限，会赋予libsvn_ra_dav的下一个对原操作的自动尝试权限，并且一切会很好。如果足够的认证信息不能提供，请求会最后失败，客户端也会报告给用户失败信息。</para>
  
        <!-- A diagram here? -->
  
        <para>通过使用Neon和Apache，Subversion在许多其它领域的轻易得到复杂的功能。举个例子，如果Neon找到OpenSSL库，它允许Subversion客户端尝试与Apache服务器（它自己的mod_ssl<quote>可以说这个语言</quote>）使用SSL加密的通讯。Neon本身和Apache的mod_deflate都可以理解<quote>deflate</quote>算法（PKZIP和gzip共同使用的程序），所以请求可以压缩块方式传输。其它Subversion今后希望支持的复杂特性包括，自动处理服务器重定向（举个例子，当版本库转移到一个新的规范URL）和利用HTTP流水线的能力。
       </para>
  
        <!-- Talk about another difference between CVS and Subversion.
             CVS users had to specify which auth mechanism to use
             (with :ext: vs. :pserver:) and whether or not to use
             compressed communications (with the -z option).  In
             Subversion, Apache takes some of that responsibility.
             The server will tell the client whether it can understand
             compression, and ... hmm.  Is this really true? -->

      </sect3>

      <sect3 id="svn-ch-8-sect-1.2.2">
        <title>RA-SVN（自定义协议版本库访问）</title>

        <para>作为标准HTTP/WebDAV协议的补充，Subversion也提供了一个使用自定义协议的RA实现，libsvn_ra_svn模块实现了自己的网络套接字连接，与一个独立服务器通讯&mdash;<filename>svnserve</filename>程序&mdash;在存放版本库的机器上。客户端可以使用<literal>svn://</literal>访问版本库。
       </para>

        <para>这个RA实现缺乏前面小节提到的Apache的大多数有点；然而虽然如此，系统管理员会非常有兴趣，因为这配置和运行异常的简单；设置一个<filename>svnserve</filename>几乎是立刻的，它与Apache相比也是非常的小（从代码长度这方面说），让它非常容易进行安全或其他方面原因的审核。此外，一些系统管理员或许已经有了一个SSH安全基础，希望Subversion使用它，客户端使用ra_svn可以容易的使用SSH封装这个协议。
       </para>

      </sect3>

      <sect3 id="svn-ch-8-sect-1.2.3">
        <title>RA-Local（直接版本库访问）</title>

        <para>并不是所有与Subversion版本库的通讯需要服务器进程和一个网络层。用户如果只是希望简单的访问本地磁盘的版本库，他们会使用<literal>file:</literal>的URL和libsvn_ra_local提供的功能。RA模块直接与版本库和文件系统库绑定，所以不需要网络通讯。
       </para>

        <para>Subversion需要服务器名称成为<literal>file:</literal>的URL的一部分，是<literal>localhost</literal>或者是为空。换句话说，你的URL必须看起来如<literal>file://localhost/path/to/repos</literal>或者<literal>file:///path/to/repos</literal>。
       </para>

        <para>也必须意识到Subversion的<literal>file:</literal> URL不能和在普通的web服务器中的<literal>file:</literal> URL一样工作。当你尝试在web服务器查看一个<literal>file:</literal>的URL，它会通过直接检测文件系统读取和显示那个位置的文件内容，但是Subversion的资源存在于虚拟文件系统（见<xref
          linkend="svn-ch-8-sect-1.1" />）中，你的浏览器不会理解怎样读取这个文件系统。
          </para>

      </sect3>

      <sect3 id="svn-ch-8-sect-1.2.4">
        <title>你的RA库在这里</title>

        <para>对那些一直希望使用另一个协议来访问Subversion版本库的人，正好是为什么版本库访问层是模块化的！开发者可以简单的编写一个新的库来在一侧实现RA接口并且与另一侧的版本库通讯。你的新库可以使用存在的网络协议，或者发明你自己的。你可以使用进程间的通讯调用，或者&mdash;让我们发狂，我们会吗？&mdash;你甚至可以实现一个电子邮件为基础的协议，Subversion提供了API；你提供创造性。
       </para>

      </sect3>
    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-8-sect-1.3">
      <title>客户端层</title>
      
      <para>在客户端这一面，Subversion工作拷贝是所有动作发生的地方。大多数客户端库实现的功能是为了管理工作拷贝的目的实现的&mdash;满是文件子目录的目录是一个或多个版本库位置的可编辑的本地<quote>影射</quote>&mdash;从版本库访问层来回传递修改。
     </para>

      <para>Subversion的工作拷贝库，libsvn_wc直接负责管理工作拷贝的数据，为了完成这一点，库会在工作拷贝的每个目录的特殊子目录中保存关于工作拷贝的管理性信息。这个子目录叫做<filename>.svn</filename>，出现在所有工作拷贝目录里，保存了各种记录了状态和用来在私有工作区工作的文件和目录。对那些熟悉CVS的用户，<filename>.svn</filename>子目录与<filename>CVS</filename>工作拷贝管理目录的作用类似，关于<filename>.svn</filename>管理区域的更多信息，见本章的<xref
        linkend="svn-ch-8-sect-3"/>。
        </para>

      <para>Subversion客户端库libsvn_client具备最广泛的职责；它的工作是结合工作拷贝库和版本库访问苦的功能，然后为希望普通版本控制的应用提供最高级的API。举个例子，<function>svn_client_checkout</function>方法是用一个URL作为参数，传递这个URL到RA层然后在特定版本库打开一个会话。然后向版本库要求一个特定的目录树，然后把目录树发送给工作拷贝库，然后把完全的工作拷贝写到磁盘（<filename>.svn</filename>目录和一切）。</para>

      <para>客户端库是为任何程序使用设计的，尽管Subversion的源代码包括了一个标准的命令行客户端，用客户端库编写GUI客户端也是很简单，Subversion新的GUI（或者任何新的客户端，真的）不需要紧密围绕包含的命令行客户端&mdash;他们对具有相同功能、数据和回调机制的libsvn_client的API有完全的访问权利。
     </para>

      <sidebar>
        <title>直接绑定&mdash;关于正确性</title>

        <para>为什么GUI程序要直接访问libsvn_client而不以命令行客户端的包裹运行？除了效率以外，这也关系到潜在的正确性问题。一个命令行客户端程序（如Subversion提供的）如果绑定了客户端库，需要将反馈和请求数据字节从C翻译为刻度的输出，这种翻译时有损耗的，程序不能得到API所提供的所有信息，或者是得到紧凑的信息。
       </para>

        <para>如果你已经包裹了这样一个命令行程序，第二个程序只能访问已经经过解释的（如我们提到的，不完全）信息，需要<emphasis>再次</emphasis>转化为<emphasis>它本身的</emphasis>展示格式。由于各层的包裹，原始数据的完整性越来越难以保证，结果很像对喜欢的录音带或录像带反复的拷贝（一个拷贝&hellip;）。
       </para>

      </sidebar>

    </sect2>
  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 2:  USING THE APIS                                  *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-8-sect-2">
    <title>使用API</title>

    <para>Developing applications against the Subversion library APIs
      is fairly straightforward.  All of the public header files live
      in the <filename>subversion/include</filename> directory of the
      source tree.  These headers are copied into your system
      locations when you build and install Subversion itself from
      source.  These headers represent the entirety of the functions
      and types meant to be accessible by users of the Subversion
      libraries.</para>

    <para>The first thing you might notice is that Subversion's
      datatypes and functions are namespace protected.  Every public
      Subversion symbol name begins with <literal>svn_</literal>,
      followed by a short code for the library in which the symbol is
      defined (such as <literal>wc</literal>,
      <literal>client</literal>, <literal>fs</literal>, etc.),
      followed by a single underscore (<literal>_</literal>) and
      then the rest of the symbol name.  Semi-public functions (used
      among source files of a given library but not by code outside
      that library, and found inside the library directories
      themselves) differ from this naming scheme in that instead of a
      single underscore after the library code, they use a double
      underscore (<literal>__</literal>).  Functions that are private
      to a given source file have no special prefixing, and are declared
      <literal>static</literal>.  Of course, a compiler isn't
      interested in these naming conventions, but they help to clarify
      the scope of a given function or datatype.</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-8-sect-2.1">
      <title>The Apache Portable Runtime Library</title>

      <para>Along with Subversion's own datatype, you will see many
        references to datatypes that begin with
        <literal>apr_</literal>&mdash;symbols from the Apache
        Portable Runtime (APR) library.  APR is Apache's portability
        library, originally carved out of its server code as an
        attempt to separate the OS-specific bits from the
        OS-independent portions of the code.  The result was a library
        that provides a generic API for performing operations that
        differ mildly&mdash;or wildly&mdash;from OS to OS.  While the
        Apache HTTP Server was obviously the first user of the APR
        library, the Subversion developers immediately recognized the
        value of using APR as well.  This means that there are
        practically no OS-specific code portions in Subversion itself.
        Also, it means that the Subversion client compiles and runs
        anywhere that the server does.  Currently this list includes
        all flavors of Unix, Win32, BeOS, OS/2, and Mac OS X.</para>

      <para>In addition to providing consistent implementations of
        system calls that differ across operating systems,
        <footnote>
          <para>Subversion uses ANSI system calls and datatypes as much
            as possible.</para>
        </footnote>
        APR gives Subversion immediate access to many custom
        datatypes, such as dynamic arrays and hash tables.  Subversion
        uses these types extensively throughout the codebase.  But
        perhaps the most pervasive APR datatype, found in nearly every
        Subversion API prototype, is the
        <literal>apr_pool_t</literal>&mdash;the APR memory pool.
        Subversion uses pools internally for all its memory allocation
        needs (unless an external library requires a different memory
        management schema for data passed through its API),
        <footnote>
          <para>Neon and Berkeley DB are examples of such libraries.</para>
        </footnote>
        and while a person coding against the Subversion APIs is
        not required to do the same, they are required to provide
        pools to the API functions that need them.  This means that
        users of the Subversion API must also link against APR, must
        call <function>apr_initialize()</function> to initialize the
        APR subsystem, and then must acquire a pool for use with
        Subversion API calls.  See <xref linkend="svn-ch-8-sect-5"/>
        for more information.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-8-sect-2.2">
      <title>URL and Path Requirements</title>

      <para>With remote version control operation as the whole point
        of Subversion's existence, it makes sense that some attention
        has been paid to internationalization (i18n) support.  After
        all, while <quote>remote</quote> might mean <quote>across the
        office</quote>, it could just as well mean <quote>across the
        globe.</quote> To facilitate this, all of Subversion's public
        interfaces that accept path arguments expect those paths to be
        canonicalized, and encoded in UTF-8.  This means, for example,
        that any new client binary that drives the libsvn_client
        interface needs to first convert paths from the
        locale-specific encoding to UTF-8 before passing those paths
        to the Subversion libraries, and then re-convert any resultant
        output paths from Subversion back into the locale's encoding
        before using those paths for non-Subversion purposes.
        Fortunately, Subversion provides a suite of functions (see
        <filename>subversion/include/svn_utf.h</filename>) that can be
        used by any program to do these conversions.</para>

      <para>Also, Subversion APIs require all URL parameters to be
        properly URI-encoded.  So, instead of passing <systemitem
        class="url">file:///home/username/My File.txt</systemitem> as
        the URL of a file named <literal>My File.txt</literal>, you
        need to pass <systemitem
        class="url">file:///home/username/My%20File.txt</systemitem>.
        Again, Subversion supplies helper functions that your
        application can
        use&mdash;<function>svn_path_uri_encode</function> and
        <function>svn_path_uri_decode</function>, for URI encoding and
        decoding, respectively.</para>
    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-8-sect-2.3">
      <title>Using Languages Other than C and C++</title> 

      <para>If you are interested in using the Subversion libraries in
        conjunction with something other than a C program&mdash;say a
        Python script or Java application&mdash;Subversion has some
        initial support for this via the Simplified Wrapper and
        Interface Generator (SWIG).  The SWIG bindings for Subversion
        are located in <filename>subversion/bindings/swig</filename>
        and are slowly maturing into a usable state.  These bindings
        allow you to call Subversion API functions indirectly, using
        wrappers that translate the datatypes native to your
        scripting language into the datatypes needed by Subversion's
        C libraries.</para>

      <para>There is an obvious benefit to accessing the Subversion
        APIs via a language binding&mdash;simplicity.  Generally
        speaking, languages such as Python and Perl are much more
        flexible and easy to use than C or C++.  The sort of
        high-level datatypes and context-driven type checking provided
        by these languages are often better at handling information
        that comes from users.  As you know, humans are proficient at
        botching up input to a program, and scripting languages tend
        to handle that misinformation more gracefully.  Of course,
        often that flexibility comes at the cost of performance.  That
        is why using a tightly-optimized, C-based interface and
        library suite, combined with a powerful, flexible binding
        language, is so appealing.</para>

      <para>Let's look at an example that uses Subversion's Python
        SWIG bindings.  Our example will do the same thing as our last
        example.  Note the difference in size and complexity of the
        function this time!</para>

      <example id="svn-ch-8-sect-2.3-ex-1">
        <title>Using the Repository Layer with Python</title>

        <programlisting>
from svn import fs
import os.path

def crawl_filesystem_dir (root, directory, pool):
  """Recursively crawl DIRECTORY under ROOT in the filesystem, and return
  a list of all the paths at or below DIRECTORY.  Use POOL for all 
  allocations."""

  # Get the directory entries for DIRECTORY.
  entries = fs.dir_entries(root, directory, pool)

  # Initialize our returned list with the directory path itself.
  paths = [directory]

  # Loop over the entries
  names = entries.keys()
  for name in names:
    # Calculate the entry's full path.
    full_path = os.path.join(basepath, name)

    # If the entry is a directory, recurse.  The recursion will return
    # a list with the entry and all its children, which we will add to
    # our running list of paths.
    if fs.is_dir(fsroot, full_path, pool):
      subpaths = crawl_filesystem_dir(root, full_path, pool)
      paths.extend(subpaths)

    # Else, it is a file, so add the entry's full path to the FILES list.
    else:
      paths.append(full_path)

  return paths
</programlisting>
      </example>

      <para>An implementation in C of the previous example would
        stretch on quite a bit longer.  The same routine in C would
        need to pay close attention to memory usage, and need to use
        custom datatypes for representing the hash of entries and the
        list of paths.  Python has hashes (called
        <quote>dictionaries</quote>) and lists as built-in datatypes,
        and provides a wonderful selection of methods for operating on
        those types.  And since Python uses reference counting and
        garbage collection, users of the language don't have to bother
        themselves with allocating and freeing memory.</para>

      <para>In the previous section of this chapter, we mentioned the
        <filename>libsvn_client</filename> interface, and how it
        exists for the sole purpose of simplifying the process of
        writing a Subversion client.  The following is a brief example
        of how that library can be accessed via the SWIG bindings.  In
        just a few lines of Python, you can check out a fully
        functional Subversion working copy!</para>

      <example id="svn-ch-8-sect-2.3-ex-2">
        <title>A Simple Script to Check Out a Working Copy.</title>

        <programlisting>
#!/usr/bin/env python
import sys
from svn import util, _util, _client

def usage():
  print "Usage: " + sys.argv[0] + " URL PATH\n"
  sys.exit(0)

def run(url, path):
  # Initialize APR and get a POOL.
  _util.apr_initialize()
  pool = util.svn_pool_create(None)

  # Checkout the HEAD of URL into PATH (silently)
  _client.svn_client_checkout(None, None, url, path, -1, 1, None, pool)

  # Cleanup our POOL, and shut down APR.
  util.svn_pool_destroy(pool)
  _util.apr_terminate()

if __name__ == '__main__':
  if len(sys.argv) != 3:
    usage()
  run(sys.argv[1], sys.argv[2])
</programlisting>
      </example>

      <para>Subversion's language bindings unfortunately tend to lack
        the level of attention given to the core Subversion modules.
        However, there have been significant efforts towards creating
        functional bindings for Python, Perl, and Java.  Once you have
        the SWIG interface files properly configured, generation of
        the specific wrappers for all the supported SWIG languages
        (which currently includes versions of C#, Guile, Java,
        MzScheme, OCaml, Perl, PHP, Python, Ruby, and Tcl) should
        theoretically be trivial.  Still, some extra programming is
        required to compensate for complex APIs that SWIG needs some
        help generalizing.  For more information on SWIG itself, see
        the project's website at <systemitem
        class="url">http://www.swig.org/</systemitem>.</para>

    </sect2>
  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 3:  INSIDE THE WORKING COPY ADMINISTRATION AREA     *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-8-sect-3">
    <title>Inside the Working Copy Administration Area</title>
    
    <para>As we mentioned earlier, each directory of a Subversion
      working copy contains a special subdirectory called
      <filename>.svn</filename> which houses administrative data about
      that working copy directory.  Subversion uses the information in
      <filename>.svn</filename> to keep track of things like:</para>

    <itemizedlist>
      <listitem>
        <para>Which repository location(s) are represented by the
          files and subdirectories in the working copy
          directory.</para>
      </listitem>
      <listitem>
        <para>What revision of each of those files and directories are
          currently present in the working copy.</para>
      </listitem>
      <listitem>
        <para>Any user-defined properties that might be attached
          to those files and directories.</para>
      </listitem>
      <listitem>
        <para>Pristine (un-edited) copies of the working copy
          files.</para>
      </listitem>
    </itemizedlist>

    <para>While there are several other bits of data stored in the
      <filename>.svn</filename> directory, we will examine only a
      couple of the most important items.</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-8-sect-3.1">
      <title>The Entries File</title>

      <para>Perhaps the single most important file in the
        <filename>.svn</filename> directory is the
        <filename>entries</filename> file.  The entries file is an XML
        document which contains the bulk of the administrative
        information about a versioned resource in a working copy
        directory.  It is this one file which tracks the repository
        URLs, pristine revision, file checksums, pristine text and
        property timestamps, scheduling and conflict state
        information, last-known commit information (author, revision,
        timestamp), local copy history&mdash;practically everything
        that a Subversion client is interested in knowing about a
        versioned (or to-be-versioned) resource!</para>

      <sidebar>
        <title>Comparing the Administrative Areas of Subversion and
          CVS</title>

        <para>A glance inside the typical <filename>.svn</filename>
          directory turns up a bit more than what CVS maintains in its
          <filename>CVS</filename> administrative directories.  The
          <filename>entries</filename> file contains XML which
          describes the current state of the working copy directory,
          and basically serves the purposes of CVS's
          <filename>Entries</filename>, <filename>Root</filename>, and
          <filename>Repository</filename> files combined.</para>

      </sidebar>

      <para>The following is an example of an actual entries
        file:</para>

      <example id="svn-ch-8-sect-3-ex-1">
        <title>Contents of a Typical <filename>.svn/entries</filename>
          File</title>
        <programlisting>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;wc-entries
   xmlns="svn:"&gt;
&lt;entry
   committed-rev="1"
   name=""
   committed-date="2002-09-24T17:12:44.064475Z"
   url="http://svn.red-bean.com/tests/.greek-repo/A/D"
   kind="dir"
   revision="1"/&gt;
&lt;entry
   committed-rev="1"
   name="gamma"
   text-time="2002-09-26T21:09:02.000000Z"
   committed-date="2002-09-24T17:12:44.064475Z"
   checksum="QSE4vWd9ZM0cMvr7/+YkXQ=="
   kind="file"
   prop-time="2002-09-26T21:09:02.000000Z"/&gt;
&lt;entry
   name="zeta"
   kind="file"
   schedule="add"
   revision="0"/&gt;
&lt;entry
   url="http://svn.red-bean.com/tests/.greek-repo/A/B/delta"
   name="delta"
   kind="file"
   schedule="add"
   revision="0"/&gt;
&lt;entry
   name="G"
   kind="dir"/&gt;
&lt;entry
   name="H"
   kind="dir"
   schedule="delete"/&gt;
&lt;/wc-entries&gt;
</programlisting>
      </example>

      <para>As you can see, the entries file is essentially a list of
        entries.  Each <sgmltag>entry</sgmltag> tag represents one of
        three things: the working copy directory itself (called the
        <quote>this directory</quote> entry, and noted as having an
        empty value for its <structfield>name</structfield>
        attribute), a file in that working copy directory (noted by
        having its <structfield>kind</structfield> attribute set to
        <literal>"file"</literal>), or a subdirectory in that working
        copy (<structfield>kind</structfield> here is set to
        <literal>"dir"</literal>).  The files and subdirectories whose
        entries are stored in this file are either already under
        version control, or (as in the case of the file named
        <filename>zeta</filename> above) are scheduled to be added to
        version control when the user next commits this working copy
        directory's changes.  Each entry has a unique name, and each
        entry has a node kind.</para>

      <para>Developers should be aware of some special rules that
        Subversion uses when reading and writing its
        <filename>entries</filename> files.  While each entry has a
        revision and URL associated with it, note that not every
        <sgmltag>entry</sgmltag> tag in the sample file has explicit
        <structfield>revision</structfield> or
        <structfield>url</structfield> attributes attached to it.
        Subversion allows entries to not explicitly store those two
        attributes when their values are the same as (in the
        <structfield>revision</structfield> case) or trivially
        calculable from
        <footnote>
          <para>That is, the URL for the entry is the same as the
            concatenation of the parent directory's URL and the
            entry's name.</para>
        </footnote>
        (in the <structfield>url</structfield> case) the data stored
        in the <quote>this directory</quote> entry.  Note also that
        for subdirectory entries, Subversion stores only the crucial
        attributes&mdash;name, kind, url, revision, and schedule.  In
        an effort to reduce duplicated information, Subversion
        dictates that the method for determining the full set of
        information about a subdirectory is to traverse down into that
        subdirectory, and read the <quote>this directory</quote> entry
        from its own <filename>.svn/entries</filename> file.  However,
        a reference to the subdirectory is kept in its parent's
        <filename>entries</filename> file, with enough information to
        permit basic versioning operations in the event that the
        subdirectory itself is actually missing from disk.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-8-sect-3.2">
      <title>Pristine Copies and Property Files</title>

      <para>As mentioned before, the <filename>.svn</filename>
        directory also holds the pristine <quote>text-base</quote>
        versions of files.  Those can be found in
        <filename>.svn/text-base</filename>.  The benefits of these
        pristine copies are multiple&mdash;network-free checks for
        local modifications and difference reporting, network-free
        reversion of modified or missing files, smaller transmission
        of changes to the server&mdash;but comes at the cost of having
        each versioned file stored at least twice on disk.  These
        days, this seems to be a negligible penalty for most files.
        However, the situation gets uglier as the size of your
        versioned files grows.  Some attention is being given to
        making the presence of the <quote>text-base</quote> an option.
        Ironically though, it is as your versioned files' sizes get
        larger that the existence of the <quote>text-base</quote>
        becomes more crucial&mdash;who wants to transmit a huge file
        across a network just because they want to commit a tiny
        change to it?</para>

      <para>Similar in purpose to the <quote>text-base</quote> files
        are the property files and their pristine
        <quote>prop-base</quote> copies, located in
        <filename>.svn/props</filename> and
        <filename>.svn/prop-base</filename> respectively.  Since
        directories can have properties, too, there are also
        <filename>.svn/dir-props</filename> and
        <filename>.svn/dir-prop-base</filename> files.  Each of these
        property files (<quote>working</quote> and <quote>base</quote>
        versions) uses a simple <quote>hash-on-disk</quote> file
        format for storing the property names and values.</para>

    </sect2>
  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 4:  WEBDAV                                          *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-8-sect-4">
    <title>WebDAV</title>

    <para>WebDAV (shorthand for <quote>Web-based Distributed Authoring
      and Versioning</quote>) is an extension of the standard HTTP
      protocol designed to make the web into a read/write medium,
      instead of the basically read-only medium that exists today.
      The theory is that directories and files can be shared&mdash;as
      both readable and writable objects&mdash;over the web.  RFCs
      2518 and 3253 describe the WebDAV/DeltaV extensions to HTTP, and
      are available (along with a lot of other useful information) at
      <systemitem
      class="url">http://www.webdav.org/</systemitem>.</para>

    <para>A number of operating system file browsers are already able
      to mount networked directories using WebDAV.  On Win32, the
      Windows Explorer can browse what it calls WebFolders (which are
      just WebDAV-ready network locations) as if they were regular
      shared folders.  Mac OS X also has this capability, as do the
      Nautilus and Konqueror browsers (under GNOME and KDE,
      respectively).</para>

    <para>How does all of this apply to Subversion?  The mod_dav_svn
      Apache module uses HTTP, extended by WebDAV and DeltaV, as one
      of its network protocols.  Subversion uses mod_dav_svn to map
      between Subversion's versioning concepts and those of RFCs 2518
      and 3253.
    </para>

    <para>For a more thorough discussion of WebDAV, how it works, and
      how Subversion uses it, see <xref linkend="svn-ap-c"/>.  Among
      other things, that appendix discusses the degree to which
      Subversion adheres to the generic WebDAV specification, and how
      that affects interoperability with generic WebDAV
      clients.</para>
  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 5:  PROGRAMMING WITH MEMORY POOLS                   *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-8-sect-5">
    <title>Programming with Memory Pools</title>

    <para>Almost every developer who has used the C programming
      language has at some point sighed at the daunting task of
      managing memory usage.  Allocating enough memory to use, keeping
      track of those allocations, freeing the memory when you no
      longer need it&mdash;these tasks can be quite complex.  And of
      course, failure to do those things properly can result in a
      program that crashes itself, or worse, crashes the computer.
      Fortunately, the APR library that Subversion depends on for
      portability provides the <structname>apr_pool_t</structname>
      type, which represents a pool from which the application may
      allocate memory.</para>

    <para>A memory pool is an abstract representation of a chunk of
      memory allocated for use by a program.  Rather than requesting
      memory directly from the OS using the standard
      <function>malloc()</function> and friends, programs that link
      against APR can simply request that a pool of memory be created
      (using the <function>apr_pool_create()</function> function).
      APR will allocate a moderately sized chunk of memory from the
      OS, and that memory will be instantly available for use by the
      program.  Any time the program needs some of the pool memory, it
      uses one of the APR pool API functions, like
      <function>apr_palloc()</function>, which returns a generic
      memory location from the pool.  The program can keep requesting
      bits and pieces of memory from the pool, and APR will keep
      granting the requests.  Pools will automatically grow in size to
      accommodate programs that request more memory than the original
      pool contained, until of course there is no more memory
      available on the system.</para>

    <para>Now, if this were the end of the pool story, it would hardly
      have merited special attention.  Fortunately, that's not the
      case.  Pools can not only be created; they can also be cleared
      and destroyed, using <function>apr_pool_clear()</function> and
      <function>apr_pool_destroy()</function> respectively.  This
      gives developers the flexibility to allocate several&mdash;or
      several thousand&mdash;things from the pool, and then clean up
      all of that memory with a single function call!  Further, pools
      have hierarchy.  You can make <quote>subpools</quote> of any
      previously created pool.  When you clear a pool, all of its
      subpools are destroyed; if you destroy a pool, it and its
      subpools are destroyed.</para>

    <para>Before we go further, developers should be aware that they
      probably will not find many calls to the APR pool functions we
      just mentioned in the Subversion source code.  APR pools offer
      some extensibility mechanisms, like the ability to have custom
      <quote>user data</quote> attached to the pool, and mechanisms
      for registering cleanup functions that get called when the pool
      is destroyed.  Subversion makes use of these extensions in a
      somewhat non-trivial way.  So, Subversion supplies (and most of
      its code uses) the wrapper functions
      <function>svn_pool_create()</function>,
      <function>svn_pool_clear()</function>, and
      <function>svn_pool_destroy()</function>.</para>

    <para>While pools are helpful for basic memory management, the
      pool construct really shines in looping and recursive scenarios.
      Since loops are often unbounded in their iterations, and
      recursions in their depth, memory consumption in these areas of
      the code can become unpredictable.  Fortunately, using nested
      memory pools can be a great way to easily manage these
      potentially hairy situations.  The following example
      demonstrates the basic use of nested pools in a situation that
      is fairly common&mdash;recursively crawling a directory tree,
      doing some task to each thing in the tree.</para>

    <example id="svn-ch-8-sect-5-ex-1">
      <title>Effective Pool Usage</title>
      <programlisting>
/* Recursively crawl over DIRECTORY, adding the paths of all its file
   children to the FILES array, and doing some task to each path
   encountered.  Use POOL for the all temporary allocations, and store
   the hash paths in the same pool as the hash itself is allocated in.  */
static apr_status_t 
crawl_dir (apr_array_header_t *files,
           const char *directory,
           apr_pool_t *pool)
{
  apr_pool_t *hash_pool = files-&gt;pool;  /* array pool */
  apr_pool_t *subpool = svn_pool_create (pool);  /* iteration pool */
  apr_dir_t *dir;
  apr_finfo_t finfo;
  apr_status_t apr_err;
  apr_int32_t flags = APR_FINFO_TYPE | APR_FINFO_NAME;

  apr_err = apr_dir_open (&amp;dir, directory, pool);
  if (apr_err)
    return apr_err;

  /* Loop over the directory entries, clearing the subpool at the top of
     each iteration.  */
  for (apr_err = apr_dir_read (&amp;finfo, flags, dir);
       apr_err == APR_SUCCESS;
       apr_err = apr_dir_read (&amp;finfo, flags, dir))
    {
      const char *child_path;

      /* Clear the per-iteration SUBPOOL.  */
      svn_pool_clear (subpool);

      /* Skip entries for "this dir" ('.') and its parent ('..').  */
      if (finfo.filetype == APR_DIR)
        {
          if (finfo.name[0] == '.'
              &amp;&amp; (finfo.name[1] == '\0'
                  || (finfo.name[1] == '.' &amp;&amp; finfo.name[2] == '\0')))
            continue;
        }

      /* Build CHILD_PATH from DIRECTORY and FINFO.name.  */
      child_path = svn_path_join (directory, finfo.name, subpool);

      /* Do some task to this encountered path. */
      do_some_task (child_path, subpool);

      /* Handle subdirectories by recursing into them, passing SUBPOOL
         as the pool for temporary allocations.  */
      if (finfo.filetype == APR_DIR)
        {
          apr_err = crawl_dir (files, child_path, subpool);
          if (apr_err)
            return apr_err;
        }

      /* Handle files by adding their paths to the FILES array.  */
      else if (finfo.filetype == APR_REG)
        {
          /* Copy the file's path into the FILES array's pool.  */
          child_path = apr_pstrdup (hash_pool, child_path);

          /* Add the path to the array.  */
          (*((const char **) apr_array_push (files))) = child_path;
        }
    }

  /* Destroy SUBPOOL.  */
  svn_pool_destroy (subpool);

  /* Check that the loop exited cleanly. */
  if (apr_err)
    return apr_err;

  /* Yes, it exited cleanly, so close the dir. */
  apr_err = apr_dir_close (dir);
  if (apr_err)
    return apr_err;

  return APR_SUCCESS;
}
</programlisting>
    </example>

    <para>The previous example demonstrates effective pool usage in
      <emphasis>both</emphasis> looping and recursive situations.
      Each recursion begins by making a subpool of the pool passed to
      the function.  This subpool is used for the looping region, and
      cleared with each iteration.  The result is memory usage is
      roughly proportional to the depth of the recursion, not to total
      number of file and directories present as children of the
      top-level directory.  When the first call to this recursive
      function finally finishes, there is actually very little data
      stored in the pool that was passed to it.  Now imagine the extra
      complexity that would be present if this function had to
      <function>alloc()</function> and <function>free()</function>
      every single piece of data used!</para>
    
    <para>Pools might not be ideal for every application, but they are
      extremely useful in Subversion.  As a Subversion developer,
      you'll need to grow comfortable with pools and how to wield them
      correctly.  Memory usage bugs and bloating can be difficult to
      diagnose and fix regardless of the API, but the pool construct
      provided by APR has proven a tremendously convenient,
      time-saving bit of functionality.</para>

  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 6:  CONTRIBUTING TO SUBVERSION                      *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-8-sect-6">
    <title>Contributing to Subversion</title>
    
    <para>The official source of information about the Subversion
      project is, of course, the project's website at <systemitem
      class="url">http://subversion.tigris.org/</systemitem>.  There
      you can find information about getting access to the source code
      and participating on the discussion lists.  The Subversion
      community always welcomes new members.  If you are
      interested in participating in this community by contributing
      changes to the source code, here are some hints on how to get
      started.</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-8-sect-6.1">
      <title>Join the Community</title>
      
      <para>The first step in community participation is to find a way
        to stay on top of the latest happenings.  To do this most
        effectively, you will want to subscribe to the main developer
        discussion list (<email>dev@subversion.tigris.org</email>) and
        commit mail list (<email>svn@subversion.tigris.org</email>).
        By following these lists even loosely, you will have access
        to important design discussions, be able to see actual changes
        to Subversion source code as they occur, and be able to
        witness peer reviews of those changes and proposed changes.
        These email based discussion lists are the primary
        communication media for Subversion development.  See the
        Mailing Lists section of the website for other
        Subversion-related lists you might be interested in.</para>

      <para>But how do you know what needs to be done?  It is quite
        common for a programmer to have the greatest intentions of
        helping out with the development, yet be unable to find a good
        starting point.  After all, not many folks come to the
        community having already decided on a particular itch they
        would like to scratch.  But by watching the developer
        discussion lists, you might see mentions of existing bugs or
        feature requests fly by that particularly interest you.  Also,
        a great place to look for outstanding, unclaimed tasks is the
        Issue Tracking database on the Subversion website.  There you
        will find the current list of known bugs and feature requests.
        If you want to start with something small, look for issues
        marked as <quote>bite-sized</quote>.</para>
      
    </sect2>
    
    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-8-sect-6.2">
      <title>Get the Source Code</title>
      
      <para>To edit the code, you need to have the code.  This means
        you need to check out a working copy from the public
        Subversion source repository.  As straightforward as that
        might sound, the task can be slightly tricky.  Because
        Subversion's source code is versioned using Subversion itself,
        you actually need to <quote>bootstrap</quote> by getting a
        working Subversion client via some other method.  The most
        common methods include downloading the latest binary
        distribution (if such is available for your platform), or
        downloading the latest source tarball and building your own
        Subversion client.  If you build from source, make sure to
        read the <filename>INSTALL</filename> file in the top level of
        the source tree for instructions.</para>

      <para>After you have a working Subversion client, you are now
        poised to checkout a working copy of the Subversion source
        repository from <systemitem
        class="url">http://svn.collab.net/repos/svn/trunk/</systemitem>:
        <footnote>
          <para>Note that the URL checked out in the example above
            ends not with <literal>svn</literal>, but with a
            subdirectory thereof called <literal>trunk</literal>.  See
            our discussion of Subversion's branching and tagging model
            for the reasoning behind this.</para>
        </footnote></para>

      <screen>
$ svn checkout http://svn.collab.net/repos/svn/trunk subversion
A  subversion/HACKING
A  subversion/INSTALL
A  subversion/README
A  subversion/autogen.sh
A  subversion/build.conf
&hellip;
</screen>

      <para>The above command will checkout the bleeding-edge, latest
        version of the Subversion source code into a subdirectory
        named <filename>subversion</filename> in your current working
        directory.  Obviously, you can adjust that last argument as
        you see fit.  Regardless of what you call the new working copy
        directory, though, after this operation completes, you will
        now have the Subversion source code.  Of course, you will
        still need to fetch a few helper libraries (apr, apr-util,
        etc.)&mdash;see the <filename>INSTALL</filename> file in the
        top level of the working copy for details.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-8-sect-6.3">
      <title>Become Familiar with Community Policies</title>
      
      <para>Now that you have a working copy containing the latest
        Subversion source code, you will most certainly want to take a
        cruise through the <filename>HACKING</filename> file in that
        working copy's top-level directory.  The
        <filename>HACKING</filename> file contains general
        instructions for contributing to Subversion, including how to
        properly format your source code for consistency with the rest
        of the codebase, how to describe your proposed changes with an
        effective change log message, how to test your changes, and so
        on.  Commit privileges on the Subversion source repository are
        earned&mdash;a government by meritocracy.
        <footnote>
          <para>While this may superficially appear as some sort of
            elitism, this <quote>earn your commit privileges</quote>
            notion is about efficiency&mdash;whether it costs more in
            time and effort to review and apply someone else's changes
            that are likely to be safe and useful, versus the
            potential costs of undoing changes that are
            dangerous.</para>
        </footnote>
        The <filename>HACKING</filename> file is an invaluable
        resource when it comes to making sure that your proposed
        changes earn the praises they deserve without being rejected
        on technicalities.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-8-sect-6.4">
      <title>Make and Test Your Changes</title>
      
      <para>With the code and community policy understanding in hand,
        you are ready to make your changes.  It is best to try to make
        smaller but related sets of changes, even tackling larger
        tasks in stages, instead of making huge, sweeping
        modifications.  Your proposed changes will be easier to
        understand (and therefore easier to review) if you disturb
        the fewest lines of code possible to accomplish your task
        properly.  After making each set of proposed changes, your
        Subversion tree should be in a state in which the software
        compiles with no warnings.</para>

      <para>Subversion has a fairly thorough
        <footnote>
          <para>You might want to grab some popcorn.
            <quote>Thorough</quote>, in this instance, translates to
            somewhere in the neighborhood of thirty minutes of
            non-interactive machine churn.</para>
        </footnote>
        regression test suite, and your proposed changes are expected
        to not cause any of those tests to fail.  By running
        <command>make check</command> (in Unix) from the top of the
        source tree, you can sanity-check your changes.  The fastest
        way to get your code contributions rejected (other than
        failing to supply a good log message) is to submit changes
        that cause failure in the test suite.</para>

      <!-- ### TODO: Describe building and testing on Windows. -->

      <para>In the best-case scenario, you will have actually added
        appropriate tests to that test suite which verify that your
        proposed changes work as expected.  In fact,
        sometimes the best contribution a person can make is solely
        the addition of new tests.  You can write regression tests for
        functionality that currently works in Subversion as a way to
        protect against future changes that might trigger failure in
        those areas.  Also, you can write new tests that demonstrate
        known failures.  For this purpose, the Subversion test suite
        allows you to specify that a given test is expected to fail
        (called an <literal>XFAIL</literal>), and so long as
        Subversion fails in the way that was expected, a test result
        of <literal>XFAIL</literal> itself is considered a success.
        Ultimately, the better the test suite, the less time wasted on
        diagnosing potentially obscure regression bugs.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-8-sect-6.5">
      <title>Donate Your Changes</title>
      
      <para>After making your modifications to the source code,
        compose a clear and concise log message to describe those
        changes and the reasons for them.  Then, send an email to the
        developers list containing your log message and the output of
        <command>svn diff</command> (from the top of your Subversion
        working copy).  If the community members consider your changes
        acceptable, someone who has commit privileges (permission to
        make new revisions in the Subversion source repository) will
        add your changes to the public source code tree.  Recall that
        permission to directly commit changes to the repository is
        granted on merit&mdash;if you demonstrate comprehension of
        Subversion, programming competency, and a <quote>team
        spirit</quote>, you will likely be awarded that
        permission.</para>

    </sect2>
  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
