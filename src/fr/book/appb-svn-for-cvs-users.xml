<appendix id="svn.forcvs">
  <title>Guide Subversion à l'usage des utilisateurs de CVS</title>

  <para>Cette annexe est un guide pour les utilisateurs de CVS qui 
    découvrent Subversion. Il est essentiellement constitué d'une liste 
    de différences, <quote>au doigt mouillé</quote>, entre les deux 
    systèmes. Pour chaque section, nous fournissons autant que possible 
    les références des chapitres pertinents.</para>

  <para>Bien que le but de Subversion soit de s'emparer de la communauté 
    des utilisateurs actuels et futurs de CVS, de nouvelles 
    fonctionnalités et des changements conceptuels étaient nécessaires 
    pour corriger certains comportements <quote>malencontreux</quote> 
    de CVS. Cela signifie que, en tant qu'utilisateur de CVS, vous 
    devrez vous défaire de certaines habitudes &mdash; celles dont vous 
    avez oublié combien elles vous semblaient bizarres au début.</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.revnums">
    <title>Les numéros de révisions sont différents</title>

    <para>Dans CVS, les numéros de révisions sont associés à un fichier. 
      Ceci est du au fait que CVS stocke ses données dans des fichiers 
      RCS&nbsp;; à chaque fichier est associé un fichier RCS dans le 
      dépôt et la structure du dépôt correspond plus ou moins à 
      l'arborescence de votre projet.</para>

    <para>Dans Subversion, le dépôt ressemble à un système de fichiers 
      unique. Chaque propagation conduit à un système de fichiers 
      entièrement nouveau&nbsp;; au fond, le dépôt est un tableau 
      d'arborescences de fichiers. Chacune de ces arborescences est 
      étiquetée avec un numéro de révision. Quand quelqu'un parle de la 
      <quote>révision 54</quote>, il parle d'une arborescence 
      particulière (et indirectement, de l'état du système de fichiers 
      après la cinquante-quatrième propagation).</para>

    <para>Techniquement, il n'est pas correct de parler de 
      <quote>la révision 5 du fichier <filename>machin.c</filename></quote>.
      À la place, on devrait dire <quote><filename>machin.c</filename> 
      tel qu'il était en révision 5</quote>. Soyez également prudent 
      quand vous faites des suppositions sur les évolutions d'un 
      fichier. Dans CVS, les révisions 5 et 6 de
      <filename>machin.c</filename> sont toujours différentes. Dans 
      Subversion, le plus probable est que <filename>machin.c</filename> 
      <emphasis>n'a pas changé</emphasis> entre les révisions 5 et
      6.</para>

    <para>De la même manière, dans CVS, une étiquette et une branche 
      sont des annotations sur un fichier ou sur l'information de 
      version de ce fichier. En revanche, dans Subversion, une branche 
      ou une étiquette sont des copies complètes d'une arborescence 
      (situées respectivement par convention dans les répertoires 
      <filename>/branches</filename> et <filename>/tags</filename> qui 
      se trouvent à la racine de l'arborescence du dépôt, à côté de 
      <filename>/trunk</filename>). Dans l'ensemble du dépôt, plusieurs 
      versions de chaque fichier peuvent être visibles&nbsp;: la 
      dernière version à l'intérieur de chaque branche, la version au 
      sein de chaque étiquette et, bien sûr, la dernière version dans le 
      tronc lui-même (sous <filename>/trunk</filename>). Ainsi, pour 
      être vraiment précis, il convient de dire 
      <quote><filename>machin.c</filename> tel qu'il était dans 
      <filename>/branches/IDEE1</filename> à la révision
      5</quote>.</para>

    <para>Pour plus de détails sur ce sujet, consultez <xref
      linkend="svn.basic.in-action.revs" />.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.directories">
    <title>Suivi de versions des répertoires</title>
    
    <para>Subversion assure le suivi de l'arborescence entière, pas 
      seulement des fichiers. C'est une des raisons majeures pour 
      lesquelles Subversion a été créé, dans le but de se substituer 
      à CVS.</para>

    <para>Voilà ce que cela implique, du point de vue d'un ancien 
      utilisateur de CVS&nbsp;:</para>

    <itemizedlist>
      <listitem>
        <para>Les commandes <command>svn add</command> et <command>svn
          delete</command> fonctionnent désormais aussi sur les 
          répertoires, de la même manière que sur les fichiers. Idem 
          pour <command>svn copy</command> et
          <command>svn move</command>. Cependant, ces commandes n'ont 
          pas d'effet immédiat sur le dépôt&nbsp;; en effet, elles ne 
          font que <emphasis>planifier</emphasis> l'ajout ou la 
          suppression des éléments concernés. Aucun changement n'a lieu 
          dans le dépôt tant que vous n'effectuez pas de propagation 
          (commande <userinput>svn commit</userinput>).</para>
      </listitem>
      <listitem>
        <para>Les répertoires ne sont plus de simples conteneurs&nbsp;; 
          ils possèdent un numéro de révision tout comme les fichiers 
          (ou pour être plus précis, il faut parler du <quote>répertoire
          <filename>machin/</filename> tel qu'il était à la révision 
          5</quote>).</para>
      </listitem>
    </itemizedlist>

    <para>Approfondissons ce dernier point. La gestion de versions d'un 
      répertoire est un problème difficile&nbsp;; comme nous voulons 
      autoriser des copies de travail à cheval sur plusieurs révisions, 
      des limitations apparaissent quand on essaie de pousser le modèle 
      trop loin.</para>

    <para>D'un point de vue théorique, nous définissons <quote>la 
      révision 5 du répertoire <filename>machin</filename></quote> comme 
      un ensemble d'entrées et de propriétés du répertoire. Maintenant, 
      supposons que nous ajoutons et supprimons des fichiers de
      <filename>machin</filename>, puis que nous propageons ces 
      modifications. Dire que nous avons toujours la révision 5 de 
      <filename>machin</filename> est un mensonge. Cependant, si nous 
      changeons le numéro de révision de 
      <filename>machin</filename> après la propagation, c'est aussi un 
      mensonge&nbsp;; il peut y avoir d'autres changements sur 
      <filename>machin</filename> que nous n'avons pas encore reçus 
      parce que nous n'avons pas encore effectué de mise à jour 
      (commande <command>svn update</command>).</para>
    
    <para>Subversion traite ce problème en conservant discrètement, dans 
      la zone <filename>.svn</filename>, le détail des ajouts et des 
      suppressions propagés. Par la suite, quand vous lancez 
      <userinput>svn update</userinput>, ces informations sont prises en 
      compte et combinées avec celles du dépôt et le nouveau numéro de 
      révision du répertoire est alors positionné correctement. Ainsi, 
      <emphasis> c'est seulement après une mise à jour que vous pouvez 
      affirmer, sans risque de vous tromper, que vous disposez d'une 
      révision <quote>parfaite</quote> d'un répertoire.</emphasis> 
      La plupart du temps, votre copie de travail contient des 
      répertoires <quote>imparfaitement</quote> synchronisés.</para>
    
    <para>De la même manière, un problème survient si vous essayez de 
      propager des modifications de propriétés sur un répertoire. 
      Normalement, la propagation devrait ajuster le numéro de révision 
      du répertoire de la copie de travail locale. Mais là encore, ce 
      serait un mensonge puisqu'il peut y avoir des ajouts et des 
      suppressions que le répertoire n'a pas encore reçu en raison de la 
      mise à jour qui n'a pas encore eu lieu.
      <emphasis>En conséquence, il n'est pas permis de propager des 
      changements sur les propriétés d'un répertoire sans que ce 
      répertoire ne soit préalablement mis à jour.</emphasis></para>

    <para>Pour plus d'informations sur les limitations de la gestion
      de versions des répertoires, reportez-vous à <xref 
      linkend="svn.basic.in-action.mixedrevs"/>.</para>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.disconnected">
    <title>Davantage d'opérations en mode déconnecté</title>

    <para>Ces dernières années, l'espace de stockage sur disques est 
      devenu outrageusement bon marché et abondant, alors que ce n'est 
      pas le cas pour la bande passante disponible sur le réseau. En 
      conséquence, les copies de travail Subversion ont été optimisées 
      pour économiser la ressource la plus rare.</para>

    <para>Le répertoire administratif <filename>.svn</filename> a le 
      même objectif que le répertoire <filename>CVS</filename>, à la 
      différence près qu'il stocke également des copies
      <quote>originales</quote> en lecture seule de vos fichiers. Ceci 
      permet beaucoup d'opérations sans connexion réseau&nbsp;:</para>
    
    <variablelist>
      
      <varlistentry>
        <term><command>svn status</command></term>
        <listitem>
          <para>liste les modifications locales que vous avez apportées (voir <xref
            linkend="svn.tour.cycle.examine.status"/>)&nbsp;;</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>svn diff</command></term>
        <listitem>
          <para>donne le détail de vos modifications (voir <xref
            linkend="svn.tour.cycle.examine.diff"/>)&nbsp;;</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>svn revert</command></term>
        <listitem>
          <para>supprime vos modifications locales (voir <xref
            linkend="svn.tour.cycle.revert"/>).</para>
        </listitem>
      </varlistentry>

    </variablelist>

    <para>Par ailleurs, les fichiers originaux en cache permettent au 
      client Subversion de n'envoyer que les différences au moment de la 
      propagation, ce que CVS ne sait pas faire.</para>

    <para>La dernière sous-commande de la liste (<command>svn
      revert</command>) est nouvelle. Elle supprime non seulement les 
      modifications locales mais aussi annule les opérations planifiées 
      telles que les ajouts et les suppressions. Bien que supprimer le 
      fichier puis lancer <userinput>svn
      update</userinput> fonctionne toujours, cette méthode détourne la 
      mise à jour de sa vocation. Et puis, tant que nous y 
      sommes&hellip;</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.status-vs-update">
    <title>Distinction entre les commandes status et update</title>

    <para>Subversion essaie de dissiper la confusion qui règne entre les 
      commandes <command>cvs status</command> et
      <command>cvs update</command>.</para>

    <para>La commande <command>cvs status</command> a deux 
      objectifs&nbsp;: d'abord, lister pour l'utilisateur les 
      modifications locales de la version de travail et, ensuite, 
      indiquer à l'utilisateur quels fichiers ne sont plus à jour. 
      Malheureusement, en raison de l'affichage peu lisible de la 
      commande <userinput>cvs status</userinput>, beaucoup 
      d'utilisateurs de CVS n'utilisent plus cette commande. À la place, 
      ils ont pris l'habitude de lancer <userinput>cvs update</userinput>
      ou <userinput>cvs -n update</userinput> pour visualiser leurs 
      changements rapidement. Si les utilisateurs oublient d'utiliser 
      l'option <option>-n</option>, cela a pour effet de bord de 
      fusionner des changements du dépôt qu'ils ne sont pas forcément 
      prêts à prendre en compte.</para>

    <para>Subversion supprime ce cafouillage en facilitant la lecture de
      <command>svn status</command> à la fois pour les humains et pour 
      les programmes d'analyse de texte. De plus, <command>svn 
      update</command> n'affiche que les informations relatives aux 
      fichiers qui ont été mis à jour côté dépôt,
      <emphasis>pas les modifications locales</emphasis>.</para>

    <sect2 id="svn.forcvs.status-vs-update.status">
      <title>svn status</title>

      <para>La commande <command>svn status</command> liste tous les 
        fichiers qui ont des modifications locales. Par défaut, le dépôt 
        n'est pas contacté. Bien que cette sous-commande accepte un bon 
        nombre d'options, voici les plus utilisées&nbsp;:</para>

      <variablelist>
        <varlistentry>
          <term><option>-u</option></term>
          <listitem>
            <para>contacte le dépôt pour déterminer et lister les 
              informations de mise à jour&nbsp;;</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>-v</option></term>
          <listitem>
            <para>liste <emphasis>tous les éléments</emphasis> 
              suivis en versions&nbsp;;</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>-N</option></term>
          <listitem>
            <para>exécution non récursive (ne pas descendre dans les 
              sous-répertoires).</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>La commande <command>svn status</command> possède deux 
        formats de sortie. Dans le mode <quote>court</quote>, mode par 
        défaut, les modifications locales sont présentées comme 
        ceci&nbsp;:</para>

      <screen>
$ svn status
M      machin.c
M      truc/bidule.c
</screen>

      <para>Si vous spécifiez l'option <option>--show-updates</option>
        (<option>-u</option>), un format d'affichage plus long sera 
        utilisé&nbsp;:</para>

      <screen>
$ svn status -u
M            1047   machin.c
       *     1045   tetes.html
       *            dessin.png
M            1050   truc/bidule.c
État par rapport à la révision  1066
</screen>

      <para>Dans ce cas, deux nouvelles colonnes font leur apparition. 
        La deuxième colonne contient une astérisque si le fichier ou le 
        répertoire n'est plus à jour. La troisième colonne contient le 
        numéro de révision de la copie de travail pour l'élément 
        considéré. Dans l'exemple précédent, l'astérisque indique que
        <filename>tetes.html</filename> serait modifié lors d'une mise à 
        jour et que <filename>dessin.png</filename> est un nouveau 
        fichier dans le dépôt (l'absence d'un numéro de révision pour 
        <filename>dessin.png</filename> indique qu'il n'existe pas dans 
        la copie de travail locale).</para>

      <!-- ###TODO describe -v here as well as -uv. -u and -v use
           different <quote>long</quote> formats and need to be
           documented separately.  Moreover, as you can combine -u and
           -v, it needs to be explained what each of them does.  As -u is
           much more important than -v, and the example following that
           paragraph *is* about -u, not -v, my patch concentrated on
           that. -->

      <para>Vous devriez maintenant jeter un œil à la liste des codes 
        d'état possibles de <xref linkend="svn.ref.svn.c.status"/>. 
        Voici quelques codes d'état courants que vous 
        rencontrerez&nbsp;:</para>

      <screen>
A    L'Ajout de l'élément est planifié
D    La suppression de l'élément est planifiée
M    L'élément a été Modifié localement
C    L'élément est en Conflit (les changements n'ont pas été complètement
       fusionnés entre la version du dépôt et la version de la copie de travail)
X    L'élément est eXterne à cette copie de travail (il vient peut-être 
       d'un autre dépôt). Voir <xref linkend="svn.advanced.externals" />
?    L'élément n'est pas suivi en versions 
!    L'élément est manquant ou incomplet (supprimé par un moyen autre que 
       Subversion)
</screen>

      <para>Pour plus de détails sur la commande <command>svn
        status</command>, consultez <xref 
        linkend="svn.tour.cycle.examine.status" />.</para>

    </sect2>

    <sect2 id="svn.forcvs.status-vs-update.update">
      <title>svn update</title>

      <para>La commande <command>svn update</command> met à jour votre 
      copie de travail et n'affiche que les informations relatives aux 
      fichiers qui ont été mis à jour.</para>

      <para>Subversion combine les codes CVS <literal>P</literal> et
        <literal>U</literal> dans le seul code <literal>U</literal>. 
        Quand une fusion ou un conflit apparaît, Subversion se contente 
        d'afficher <literal>G</literal> ou <literal>C</literal>, plutôt 
        qu'une phrase complète, pour indiquer ce qui se passe.</para>

      <para>Pour plus d'informations sur <command>svn
        update</command>, reportez-vous à <xref 
        linkend="svn.tour.cycle.update" />.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.branches-and-tags">
    <title>Branches et étiquettes</title>

    <para>Subversion ne fait pas de différence entre l'espace du système 
      de fichiers et l'espace des branches&nbsp;; les branches et les 
      étiquettes sont de simples répertoires du système de fichiers. 
      C'est probablement l'obstacle psychologique le plus important que 
      les utilisateurs de CVS doivent franchir. Pour tout savoir sur ce 
      sujet, rendez-vous au <xref linkend="svn.branchmerge"/>.</para>

    <warning>

      <para>Puisque Subversion traite les branches et les étiquettes 
        comme de simples répertoires, les différentes lignes de 
        développement de votre projet sont probablement hébergées dans 
        des sous-répertoires du répertoire du projet principal. En 
        conséquence, n'oubliez pas de faire vos extractions en 
        spécifiant l'URL du sous-répertoire qui contient la ligne de 
        développement que vous désirez et pas l'URL racine du projet. 
        Sinon, il y a de grandes chances pour que vous récupériez une 
        copie complète de votre projet, y compris toutes les branches et 
        toutes les étiquettes<footnote>
          <para>Tout du moins si vous avez suffisamment d'espace disque 
            pour pouvoir terminer l'extraction.</para>
        </footnote>.
      </para>
    </warning>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.properties">
    <title>Propriétés des méta-données</title>

    <para>Une nouvelle fonctionnalité de Subversion est la possibilité 
      d'affecter des méta-données arbitraires (ou 
      <quote>propriétés</quote>) aux fichiers et répertoires. Les 
      propriétés sont des couples nom/valeur arbitraires associés aux 
      fichiers et répertoires de votre copie de travail locale.</para>
    
    <para>Pour définir ou récupérer un nom de propriété, utilisez les 
      sous-commandes <command>svn propset</command> et <command>svn 
      propget</command>. Pour obtenir la liste de toutes les propriétés 
      d'un objet, utilisez <command>svn proplist</command>.</para>

    <para>Pour plus d'informations, reportez-vous à <xref 
      linkend="svn.advanced.props"/>.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.conflicts">
    <title>Résolution des conflits</title>

    <para>CVS signale les conflits par des <quote>marqueurs de 
      conflits</quote> insérés directement dans les fichiers puis 
      affiche un <literal>C</literal> pendant l'opération de mise à jour 
      ou de fusion. Historiquement, ce comportement a généré beaucoup de 
      problèmes, car CVS ne finit pas son travail. Beaucoup 
      d'utilisateurs oublient (ou ne voient pas) le <literal>C</literal> 
      une fois qu'il disparaît de l'écran. Ils oublient aussi souvent 
      que les marqueurs de conflit sont toujours présents et, 
      accidentellement, propagent des fichiers contenant ces marqueurs 
      de conflit.</para>

    <para>Subversion corrige ce problème de deux façons. D'abord, quand 
      un conflit est détecté sur un fichier, Subversion enregistre le 
      fait que le fichier est en conflit et refuse de propager des 
      modifications concernant ce fichier tant que vous ne résolvez pas 
      explicitement le conflit. Ensuite, Subversion 1.5 propose une 
      résolution interactive des conflits, ce qui vous permet de 
      résoudre les conflits au moment où ils apparaissent, plutôt que 
      d'avoir à revenir dessus une fois que la fusion ou la mise à jour 
      est terminée. Consultez <xref linkend="svn.tour.cycle.resolve" /> 
      pour plus d'informations sur la résolution des conflits avec 
      Subversion.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.binary-and-trans">
    <title>Fichiers binaires et conversions</title>

    <para>En général, Subversion se débrouille mieux avec les fichiers 
      binaires que CVS. Comme CVS utilise RCS, il est seulement capable 
      de stocker successivement des copies entières d'un fichier binaire 
      modifié. Subversion, en revanche, utilise un algorithme de 
      différenciation binaire, indépendant du contenu textuel ou binaire 
      des fichiers, pour déterminer les différences entre les fichiers. 
      Cela veut dire que tous les fichiers sont stockés de manière 
      différentielle (compressée) dans le dépôt.</para>
    
    <para>Les utilisateurs de CVS doivent marquer les fichiers binaires 
      avec l'indicateur <option>-kb</option> pour empêcher que les 
      données ne soient corrompues (par l'expansion des mots-clés et les 
      conversions de fins de lignes). Ils oublient quelquefois de le 
      faire.</para>

    <para>Subversion utilise une approche plus paranoïaque. Premièrement, 
      il ne fait aucune substitution de mot-clé ou de fin de ligne à 
      moins qu'on ne le lui demande explicitement (voir <xref
      linkend="svn.advanced.props.special.keywords"/> et <xref
      linkend="svn.advanced.props.special.eol-style"/> pour plus de 
      détails). Par défaut, Subversion considère que les fichiers de 
      données sont des suites littérales d'octets et les fichiers sont 
      toujours stockés dans le dépôt dans un état 
      <quote>non-converti</quote>.</para>

    <para>Deuxièmement, Subversion conserve une notion interne pour le 
      contenu de chaque fichier&nbsp;: <quote>texte</quote> ou 
      <quote>binaire</quote>. Mais <emphasis>cette notion ne s'applique 
      qu'à la copie de travail locale</emphasis>. Lors d'un 
      <command>svn update</command>, Subversion effectue des fusions 
      contextuelles sur les fichiers texte modifiés localement mais ne 
      tente pas d'en faire autant pour les fichiers binaires.</para>

    <para>Pour déterminer si une fusion contextuelle est possible, 
      Subversion examine la propriété <literal>svn:mime-type</literal>.
      Si le fichier ne possède pas la propriété 
      <literal>svn:mime-type</literal> ou si le type MIME est textuel 
      (par exemple <literal>text/*</literal>), Subversion considère que 
      c'est du texte. Sinon, Subversion considère que le fichier est 
      binaire. Subversion aide également les utilisateurs en incluant 
      l'exécution d'un algorithme de détection des fichiers binaires 
      dans les commandes <command>svn import</command>
      et <command>svn add</command>. Ces commandes tentent de deviner 
      puis affectent (éventuellement) un type binaire à la propriété 
      <literal>svn:mime-type</literal> du fichier ajouté (si Subversion 
      se trompe dans la détection, l'utilisateur peut toujours supprimer 
      ou éditer à la main la propriété).</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.modules">

    <title>Gestion de versions des modules</title>

    <para>Contrairement à CVS, une copie de travail locale de Subversion 
      sait qu'elle est l'extraction d'un module. Cela signifie que si 
      quelqu'un change la définition du module (par exemple ajoute ou 
      supprime des composants), un appel à <command>svn update</command> 
      met à jour la copie de travail correctement, en ajoutant et 
      supprimant les composants concernés.</para>

    <para>Subversion définit les modules comme une liste de répertoires 
      formant une propriété d'un répertoire&nbsp;; voir <xref 
      linkend="svn.advanced.externals"/>.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.auth">

    <title>Authentification</title>

    <para>Avec le pserver de CVS, vous devez vous connecter au serveur 
      (en utilisant la commande <command>cvs login</command>) avant 
      n'importe quelle opération de lecture ou d'écriture &mdash; 
      parfois, vous devez même vous authentifier pour des opérations en 
      mode anonyme. Avec un dépôt Subversion utilisant Apache 
      <command>httpd</command> ou <command>svnserve</command>, vous 
      n'avez pas besoin de vous authentifier a priori &mdash; si une 
      opération nécessite que vous vous authentifiez, le serveur vous 
      demande de le faire (que ce soit par identifiant et mot de passe, 
      certificat client ou les deux). Ainsi, si votre dépôt est 
      accessible en lecture pour tous, vous n'avez pas besoin de vous 
      authentifier pour les opérations de lecture.</para>

    <para>Comme CVS, Subversion met en cache sur le disque vos éléments 
      d'authentification (dans votre répertoire 
      <filename>~/.subversion/auth/</filename>) à moins que vous ne lui 
      spécifiez le contraire avec l'option
      <option>--no-auth-cache</option>.</para>

    <para>Ce comportement possède une exception&nbsp;: l'accès à un 
      serveur <command>svnserve</command> via un tunnel SSH, en 
      utilisant les URL de type <literal>svn+ssh://</literal>. Dans ce 
      cas, le programme <command>ssh</command> vous demande toujours de 
      vous authentifier avant d'ouvrir le tunnel.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.convert">

    <title>Conversion d'un dépôt CVS vers Subversion</title>

    <para>La meilleure façon d'habituer les utilisateurs CVS à 
      Subversion est certainement de les laisser continuer à travailler 
      sur leurs projets en utilisant le nouveau système. Et, bien que 
      cela puisse être fait par un import <quote>à plat</quote> dans le 
      dépôt Subversion d'un dépôt CVS exporté, la solution la plus 
      aboutie implique de transférer d'un système à l'autre non 
      seulement la dernière version des données mais aussi tout 
      l'historique qui va avec. C'est un problème particulièrement 
      ardu&nbsp;; cela implique, parmi d'autres complications, de 
      déterminer les modifications qui vont ensemble, en l'absence 
      d'atomicité et de mécanisme de conversion entre les politiques 
      totalement contradictoires de gestion des branches des deux 
      systèmes. Néanmoins, il existe quelques outils qui se prétendent 
      capables de convertir, au moins en partie, des dépôts CVS en 
      dépôts Subversion.</para>

    <para>L'outil le plus populaire (et le plus abouti) est cvs2svn 
      (<ulink url="http://cvs2svn.tigris.org/"/> site en anglais), un 
      programme en Python créé à l'origine par des membres de la 
      communauté de développement Subversion elle-même. Cet outil n'est 
      censé être lancé qu'une seule fois&nbsp;: il analyse votre dépôt 
      CVS en plusieurs passes et essaie d'en déduire des propagations,
      des branches et des étiquettes autant qu'il le peut. Au final, le 
      résultat est soit un dépôt Subversion soit un fichier dump 
      Subversion représentant l'historique du code. Consultez le site 
      web pour le détail des instructions et les précautions 
      d'usage.</para>

  </sect1>

</appendix>

<!--
local variables: 
sgml-parent-document: ("book.xml" "appendix")
end:
-->
