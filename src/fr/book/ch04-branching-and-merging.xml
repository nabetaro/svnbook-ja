<chapter id="svn.branchmerge">
  <title>Gestion des branches</title>

  <blockquote>
    <attribution>Confucius</attribution>
    <para><quote>君子务本
      (C'est sur le Tronc qu'un gentleman travaille.)</quote></para>
  </blockquote>


  <para>La création, l'étiquetage et la fusion de branches sont des
    concepts communs à tous les systèmes de gestion de versions. Si
    vous n'êtes pas familier avec elles, nous fournissons dans ce
    chapitre une bonne introduction à ces idées. Si vous êtes familier
    avec elles, vous devriez, avec un peu de chance, être intéressé
    par la façon dont Subversion les met en pratique.</para>

  <para>La gestion des branches est un élément fondamental de la
    gestion de versions. Si vous comptez utiliser Subversion pour
    gérer vos données, c'est une fonctionnalité dont vous ne pourrez 
    plus vous passer. Ce chapitre suppose que vous êtes
    déjà familier avec les notions de bases de Subversion
    (<xref linkend="svn.basic"/>).</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.whatis">
    <title>Qu'est-ce qu'une branche&nbsp;?</title>

    <para>Supposons que votre travail soit de maintenir un document
      pour une division de votre entreprise, un manuel par exemple.
      Un beau jour, une autre division vous demande le même manuel,
      mais avec quelques parties <quote>modifiées</quote> spécialement
      pour elle, puisqu'elle fait les choses légèrement
      différemment.</para>

    <para>Que faites-vous dans cette situation&nbsp;? Tout naturellement,
      vous créez une seconde copie du document et commencez à maintenir
      les deux copies séparément. Puis, quand chaque division vous
      demande de faire des petites modifications, vous les incorporez
      dans une copie ou dans l'autre.</para>

    <para>Vous voulez souvent faire la même modification dans les deux
      copies. Par exemple, si vous découvrez une coquille dans la
      première copie, il est très probable que la même coquille existe
      dans la deuxième copie. Les deux documents sont presque
      identiques, après tout&nbsp;; ils ne diffèrent qu'en quelques points
      mineurs et spécifiques.</para>

    <para>Voilà le concept de <firstterm>branche</firstterm>,
      c'est-à-dire une ligne de développement qui existe
      indépendamment d'une autre ligne, mais partage cependant une
      histoire commune avec elle, si vous remontez suffisamment loin en
      arrière dans le temps. Une branche commence toujours sa vie en
      tant que copie de quelque chose, puis diffère à partir de là,
      selon une histoire qui lui est propre (voir la
      <xref linkend="svn.branchmerge.whatis.dia-1"/>).</para>

      <figure id="svn.branchmerge.whatis.dia-1">
        <title>Branches de développement</title>
        <graphic fileref="images/ch04dia1.png"/>
      </figure>

    <para>Subversion possède des commandes pour vous aider à maintenir
      des branches parallèles de vos fichiers et répertoires. Il vous
      permet de créer des branches en faisant des copies de vos
      données et se souvient que les copies sont liées les unes aux
      autres. Il vous aide aussi à dupliquer les modifications d'une
      branche vers une autre. Enfin, il permet que des portions de
      votre copie de travail correspondent à différentes branches,
      afin que vous puissiez <quote>mélanger</quote> différentes
      lignes de développement dans votre travail quotidien.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.using">
    <title>Utilisation des branches</title>

    <para>Rendu à ce chapitre, vous devriez avoir compris que chaque
      propagation crée une arborescence de fichiers entièrement
      nouvelle (appelée <quote>révision</quote>) dans le dépôt. Si ce
      n'est pas le cas, retournez vous informer sur les révisions dans
      <xref linkend="svn.basic.in-action.revs"/>.</para>

    <para>Pour ce chapitre, nous reprendrons le même exemple qu'au
      <xref linkend="svn.basic"/>. Souvenez-vous que votre
      collaboratrice Sally et vous partagez un dépôt qui contient
      deux projets, <filename>paint</filename> et
      <filename>calc</filename>. Notez cependant que dans la
       <xref linkend="svn.branchmerge.using.dia-1"/>, le dossier de
       chaque projet contient désormais des sous-dossiers nommés
       <filename>trunk</filename> et <filename>branches</filename>.
       Les raisons de cette arborescence apparaîtront bientôt
       clairement.</para>

      <figure id="svn.branchmerge.using.dia-1">
        <title>Structure initiale du dépôt</title>
        <graphic fileref="images/ch04dia2.png"/>
      </figure>

    <para>Comme avant, supposons que Sally et vous avez tous deux une
      copie de travail du projet <quote>calc</quote>. Plus
      spécifiquement, vous avez chacun une copie de travail de
      <filename>/calc/trunk</filename>. Tous les fichiers du projet
      sont dans ce sous-dossier plutôt que dans
      <filename>/calc</filename> lui-même, parce que votre équipe a
      décidé que la <quote>ligne principale</quote> de développement
      du projet allait se situer
      dans <filename>/calc/trunk</filename>.</para>

    <para>Disons que l'on vous a attribué la tâche d'implémenter une
      fonctionnalité du logiciel qui prendra longtemps à écrire et
      touchera à tous les fichiers du projet. Le problème immédiat est
      que vous ne voulez pas déranger Sally, qui est en train de
      corriger des bogues mineurs ici et là. Elle a besoin que la
      dernière version du projet
      (dans <filename>/calc/trunk</filename>) demeure en permanence
      utilisable. Si vous commencez à propager des changements petit
      à petit, vous allez sûrement rendre les choses difficiles pour
      Sally (ainsi que pour d'autres membres de l'équipe).</para>

    <para>Une stratégie possible est de vous isoler&nbsp;: vous pouvez
      arrêter de partager des informations avec Sally pendant une
      semaine ou deux. C'est-à-dire commencer à modifier et à
      réorganiser les fichiers dans votre copie de travail, mais
      sans effectuer de propagation ni de mise à jour avant que vous
      n'ayez complètement terminé la tâche. Cette stratégie comporte
      certains risques. Premièrement,
      ce n'est pas sans danger. La plupart des gens aiment propager
      leurs modifications fréquemment, au cas où leur copie de travail
      aurait un accident. Deuxièmement, ce n'est pas très flexible. Si
      vous travaillez sur différents ordinateurs (vous avez peut-être
      une copie de travail de <filename>/calc/trunk</filename> sur
      deux machines différentes), vous aurez besoin de transférer
      manuellement vos changements entre les deux, ou bien de
      travailler sur une seule machine. De la même façon, il est
      difficile de partager vos changements en cours avec quelqu'un
      d'autre. Une des <quote>bonnes pratiques</quote> du monde du
      développement logiciel est de permettre à vos pairs de passer
      votre travail en revue au fur et à mesure. Si personne n'a accès
      à vos propagations intermédiaires, vous vous coupez d'éventuelles
      critiques et risquez de partir dans une mauvaise direction
      pendant des semaines avant que quelqu'un ne s'en aperçoive.
      Enfin, quand vous en aurez fini avec tous vos changements,
      vous pourriez avoir du mal à fusionner votre travail avec le
      code du reste de l'équipe. Sally (et les autres) peuvent avoir
      apporté de nombreux autres changements au dépôt, changements qui
      seront difficiles à incorporer dans votre copie de travail,
      notamment si vous lancez <command>svn update</command> après des
      semaines d'isolation.</para>

    <para>Une solution bien meilleure est de créer votre propre
      branche, ou ligne de développement, dans le dépôt. Ceci vous
      permettra de sauvegarder fréquemment votre travail un peu
      boiteux sans interférer avec vos collaborateurs&nbsp;; vous pourrez
      toutefois partager une sélection d'informations avec eux. Vous
      découvrirez comment tout cela fonctionne exactement au fur et à
      mesure de ce chapitre.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.using.create">
      <title>Création d'une branche</title>

      <para>Créer une branche est très simple&nbsp;: il s'agit juste de faire
        une copie du projet dans le dépôt avec la commande
        <command>svn copy</command>. Subversion est capable de copier
        non seulement de simples fichiers, mais aussi des dossiers
        entiers. Dans le cas présent, vous voulez faire une copie du
        dossier <filename>/calc/trunk</filename>. Où doit résider la
        nouvelle copie&nbsp;? Là où vous le désirez, cette décision faisant
        partie de la gestion du projet. Supposons que votre équipe ait
        pour convention de créer les branches dans la zone
        <filename>/calc/branches</filename> du dépôt et que vous
        vouliez nommer votre branche
        <literal>ma-branche-calc</literal>. Vous créez alors un
        nouveau dossier,
        <filename>/calc/branches/ma-branche-calc</filename>,
        qui commence ainsi sa vie en tant que copie de
        <filename>/calc/trunk</filename>.</para>

      <para>Vous avez peut-être déjà utilisé
        <command>svn copy</command> pour copier un fichier vers un
        autre à l'intérieur d'une copie de travail. Mais il peut aussi
        être utilisé pour effectuer une copie <quote>distante</quote>
        entièrement à l'intérieur du dépôt. Il suffit de copier une
        URL vers une autre&nbsp;:</para>

      <screen>
$ svn copy http://svn.exemple.com/depot/calc/trunk \
           http://svn.exemple.com/depot/calc/branches/ma-branche-calc \
      -m "Création d'une branche privée à partir de /calc/trunk."

Révision 341 propagée.
</screen>

      <para>Cette commande entraîne une opération quasi-instantanée
        dans le dépôt, créant un nouveau dossier à la révision 341.
        Ce nouveau dossier est une copie de
        <filename>/calc/trunk</filename>, comme l'illustre la
        <xref linkend="svn.branchmerge.using.create.dia-1"/>
        <footnote>
        <para>Subversion n'accepte pas les copies entre des dépôts
          distincts. Quand vous utilisez des URLs avec
          <command>svn copy</command> et <command>svn move</command>,
          vous ne pouvez copier que des éléments faisant partie du
          même dépôt.</para>
        </footnote>.

        Bien qu'il soit aussi possible de créer une branche en
        utilisant <command>svn copy</command> pour dupliquer un dossier
        à l'intérieur de la copie de travail, cette technique n'est
        pas recommandée. Elle peut s'avérer assez lente, en fait&nbsp;!
        Copier un dossier côté client est une opération linéaire en
        terme de durée, puisque chaque fichier et chaque dossier doit
        être dupliqué sur le disque local. Copier un dossier sur le
        serveur, par contre, est une opération dont la durée est
        constante et c'est ainsi que la plupart des gens créent
        des branches.</para>

      <figure id="svn.branchmerge.using.create.dia-1">
        <title>Dépôt avec nouvelle copie</title>
        <graphic fileref="images/ch04dia3.png"/>
      </figure>

      <sidebar>
        <title>Des copies peu coûteuses</title>

        <para>Le dépôt Subversion a un design particulier. Quand vous
          copiez un dossier, il n'y a pas à s'en faire pour la taille
          du dépôt&nbsp;: en fait Subversion ne duplique aucune donnée. Au
          lieu de ça, il crée une nouvelle entrée de dossier qui pointe
          vers une arborescence <emphasis>existante</emphasis>. Si
          vous êtes un utilisateur expérimenté d'Unix, vous
          reconnaîtrez là le concept de lien matériel
          (<quote>hard link</quote>). Au fur et à mesure des
          modifications faites aux fichiers et dossiers sous le
          dossier copié, Subversion continue à employer ce concept
          de lien matériel quand il le peut. Il duplique les données
          seulement s'il est nécessaire de lever l'ambiguïté entre
          différentes versions d'objets.</para>

        <para>C'est pourquoi vous entendrez souvent les utilisateurs
          de Subversion parler de <quote>copies peu coûteuses</quote>
          (<foreignphrase>cheap copies</foreignphrase> en anglais).
          Peu importe la taille du dossier, la durée de la copie
          est constante et très faible,
          tout comme l'espace disque nécessaire. En fait,
          cette fonctionnalité est à la base du fonctionnement des
          propagations dans Subversion&nbsp;: chaque révision est une
          <quote>copie peu coûteuse</quote> de la révision précédente,
          avec juste quelques éléments modifiés à l'intérieur (pour en
          savoir plus à ce sujet, visitez le site web de Subversion et
          lisez les paragraphes concernant la méthode
          <quote>bubble up</quote> dans les documents de conception
          de Subversion).</para>

        <para>Bien sûr, cette mécanique interne de copie et de partage
          des données est transparente pour l'utilisateur, qui n'y
          voit que de simples copies d'arborescences. Le point
          essentiel ici est que les copies sont peu coûteuses, aussi
          bien en temps qu'en espace disque. Si vous créez une branche
          entièrement à l'intérieur du dépôt (en lançant
          <userinput>svn copy <replaceable>URL1</replaceable>
          <replaceable>URL2</replaceable></userinput>), c'est une
          opération rapide, à durée constante. Créez des branches
          aussi souvent que vous le souhaitez.</para>
      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.using.work">
      <title>Travail sur votre branche</title>

      <para>Maintenant que vous avez créé votre branche du projet,
        vous pouvez extraire une nouvelle copie de travail et
        commencer à l'utiliser&nbsp;:</para>

      <screen>
$ svn checkout http://svn.exemple.com/depot/calc/branches/ma-branche-calc
A  ma-branche-calc/Makefile
A  ma-branche-calc/entier.c
A  ma-branche-calc/bouton.c
Révision 341 extraite.
</screen>

      <para>Cette copie de travail n'a rien de spéciale&nbsp;; elle
        correspond juste à un dossier différent du dépôt. Cependant,
        quand vous propagerez vos modifications, Sally ne les verra
        pas quand elle effectuera une mise à jour, car sa copie de
        travail correspond à <filename>calc/trunk</filename> (pensez
        bien à lire <xref linkend="svn.branchmerge.switchwc"/> plus
        loin dans ce chapitre&nbsp;: la commande
        <command>svn switch</command> est une méthode alternative
        pour créer une copie de travail d'une branche).</para>

      <para>Imaginons qu'une semaine passe et que les propagations
        suivantes ont lieu&nbsp;:</para>

      <itemizedlist>
        <listitem><para>
          Vous modifiez
          <filename>/calc/branches/ma-branche-calc/bouton.c</filename>,
          ce qui crée la révision 342.</para>
        </listitem>

        <listitem><para>
          Vous modifiez
          <filename>/calc/branches/ma-branche-calc/entier.c</filename>,
          ce qui crée la révision 343.</para>
        </listitem>

        <listitem><para>
          Sally modifie
          <filename>/calc/trunk/entier.c</filename>,
          ce qui crée la révision 344.</para>
        </listitem>
      </itemizedlist>

      <para>À présent, deux lignes de développement indépendantes (voir
      la <xref linkend="svn.branchmerge.using.work.dia-1"/>) existent
      pour <filename>entier.c</filename>.</para>

      <figure id="svn.branchmerge.using.work.dia-1">
        <title>Historique des branches d'un fichier</title>
        <graphic fileref="images/ch04dia4.png"/>
      </figure>

      <para>Les choses deviennent intéressantes quand on regarde
        l'historique des modifications apportées à votre copie de
        <filename>entier.c</filename>&nbsp;:</para>

      <screen>
$ pwd
/home/utilisateur/ma-branche-calc

$ svn log -v entier.c
------------------------------------------------------------------------
r343 | utilisateur | 2002-11-07 15:27:56 -0600 (jeu. 07 nov. 2002) | 2 lignes
Chemins modifiés :
   M /calc/branches/ma-branche-calc/entier.c

* entier.c:  machiné le bidule.

------------------------------------------------------------------------
r341 | utilisateur | 2002-11-03 15:27:56 -0600 (jeu. 07 nov. 2002) | 2 lignes
Chemins modifiés :
   A /calc/branches/ma-branche-calc (from /calc/trunk:340)

Création d'une branche privée à partir de /calc/trunk.

------------------------------------------------------------------------
r303 | sally | 2002-10-29 21:14:35 -0600 (mar. 29 oct. 2002) | 2 lignes
Chemins modifiés :
   M /calc/trunk/entier.c

* entier.c:  modifié une docstring.

------------------------------------------------------------------------
r98 | sally | 2002-02-22 15:35:29 -0600 (ven. 22 fev. 2002) | 2 lignes
Chemins modifiés :
  A /calc/trunk/entier.c
* entier.c:  ajout du fichier dans ce projet.

------------------------------------------------------------------------
</screen>

      <para>Notez bien que Subversion reprend tout l'historique du
        <filename>entier.c</filename> de votre branche à travers le
        temps, remontant même au delà du point où il a été copié. Il
        liste la création d'une branche en tant qu'élément de
        l'historique, parce qu'<filename>entier.c</filename> a été
        copié implicitement lorsque <filename>calc/trunk</filename>
        tout entier a été copié. Maintenant regardez ce qui se passe
        quand Sally lance la même commande sur sa copie du
        fichier&nbsp;:</para>

      <screen>
$ pwd
/home/sally/calc

$ svn log -v entier.c
------------------------------------------------------------------------
r344 | sally | 2002-11-07 15:27:56 -0600 (jeu. 07 nov. 2002) | 2 lignes
 Chemins modifiés :
    M /calc/trunk/entier.c

 * entier.c:  corrigé un ensemble de coquilles.

 ------------------------------------------------------------------------
 r303 | sally | 2002-10-29 21:14:35 -0600 (mar. 29 oct. 2002) | 2 lignes
 Chemins modifiés :
    M /calc/trunk/entier.c

 * entier.c:  modifié une docstring.

 ------------------------------------------------------------------------
 r98 | sally | 2002-02-22 15:35:29 -0600 (ven. 22 fev. 2002) | 2 lignes
 Chemins modifiés :
   A /calc/trunk/entier.c

* entier.c:  ajout du fichier dans ce projet.

------------------------------------------------------------------------
</screen>

      <para>Sally voit la modification due à sa propre révision 344,
        mais pas le changement que vous avez effectué dans la révision
        343. Pour Subversion, ces deux propagations ont touché des
        fichiers différents dans des dossiers distincts. Néanmoins,
        Subversion indique bien que les deux fichiers partagent une
        histoire commune. Avant que la copie de branche n'ait été
        faite en révision 341, les fichiers ne faisaient qu'un. C'est
        pourquoi Sally et vous voyez tous les deux les modifications
        apportées en révisions 303 et 98.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.using.concepts">
      <title>Gestion des branches par Subversion&nbsp;: notions clé</title>

      <para>Il y a deux leçons importantes à retenir de ce paragraphe.
        Premièrement, Subversion n'a pas de notion interne de
        branche &mdash; il sait seulement faire des copies. Quand
        vous copiez un dossier, le dossier qui en résulte n'est une
        <quote>branche</quote> que parce que <emphasis>vous</emphasis>
        le considérez comme tel. Vous aurez beau envisager ce dossier
        différemment ou le traiter différemment, pour
        Subversion c'est juste un dossier ordinaire auquel sont
        associées des informations extra-historiques.</para>

      <para>Deuxièmement, à cause de ce mécanisme de copie, les
        branches de Subversion existent en tant que
        <emphasis>dossiers classiques du système de fichiers</emphasis>
        du dépôt. En cela, Subversion diffère des autres systèmes
        de gestion de versions, où les branches sont définies par
        l'ajout d'<quote>étiquettes</quote> extra-dimensionnelles
        à des groupes de fichiers. L'emplacement du dossier de votre
        branche importe peu à Subversion. La plupart des équipes ont
        pour convention de placer toutes les branches dans un dossier
        <filename>/branches</filename>, mais vous êtes libre
        d'inventer la convention qui vous plaît.</para>

    </sect2>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.basicmerging">
    <title>Fusions&nbsp;: pratiques de base</title>

    <para>Désormais, Sally et vous travaillez sur des branches
      parallèles du projet&nbsp;: vous travaillez sur une branche
      privée et Sally travaille sur le <firstterm>tronc</firstterm>,
      la branche de développement principale.</para>

    <para>Pour les projets qui ont un grand nombre de contributeurs,
      il est d'usage que la plupart des gens aient des copies
      de travail du tronc. Dès que quelqu'un doit faire des
      modifications de longue haleine, susceptibles de perturber
      le tronc, une procédure standard est qu'il crée une branche
      privée et qu'il y propage les modifications jusqu'à ce que tout
      le travail soit terminé.</para>

    <para>Bref, la bonne nouvelle est que Sally et vous n'empiétez
      pas l'un sur l'autre. La mauvaise nouvelle est qu'il est très
      facile de <emphasis>dériver</emphasis> chacun de son côté.
      Rappelez-vous qu'un des problèmes lié à la stratégie
      d'<quote>isolement</quote> est que lorsque vous en aurez fini
      avec votre branche, il risque d'être quasi impossible de
      refusionner vos modifications dans le tronc sans avoir à faire
      face à un grand nombre de conflits.</para>

    <para>À la place, Sally et vous pourriez continuer de partager
      vos changements au fur et à mesure de votre travail. C'est à
      vous de décider quelles modifications valent la peine d'être
      partagées&nbsp;; Subversion vous offre la possibilité de
      <quote>copier</quote> sélectivement des modifications entre
      les branches. Et quand vous aurez tout fini dans votre branche,
      l'ensemble de vos modifications pourra être recopié en entier
      vers le tronc. Dans la terminologie Subversion, l'action
      générale de réplication des modifications d'une branche vers
      une autre s'appelle la <firstterm>fusion</firstterm> et elle
      s'effectue à l'aide de plusieurs exécutions de la commande
      <command>svn merge</command>.</para>

    <para>Dans les exemples qui suivent, nous supposerons que le
      client et le serveur Subversion sont tous deux en version 1.5
      (ou plus récente). Si l'un ou l'autre sont en version plus
      ancienne, les choses sont plus compliquées&nbsp;: le système
      ne gére pas les changements de façon automatique et vous
      devrez utiliser des méthodes manuelles pénibles pour obtenir
      des résultats similaires. Vous devrez en effet toujours utiliser
      la syntaxe détaillée de la fusion spécifiant l'éventail des
      révisions à répliquer
      (voir <xref linkend="svn.branchmerge.advanced.advancedsyntax"/>
       plus loin dans ce chapitre) et penser à garder trace de ce qui
       a déjà été fusionné et de ce qui ne l'a pas encore été. Pour
       cette raison, nous recommandons <emphasis>fortement</emphasis>
       de vous assurer que client et serveur sont au moins
       en version 1.5.</para>

  <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.changesets">
      <title>Ensembles de modifications</title>

      <para>Avant que nous n'allions plus loin, nous devons vous
        avertir que les pages suivantes contiennent de nombreuses
        discussions portant sur les <quote>modifications</quote>.
        Beaucoup de gens ayant de l'expérience dans les systèmes de
        gestion de versions utilisent le terme
        <quote>modifications</quote> et le terme <quote>ensemble de
        modifications</quote> de façon interchangeable et nous allons
        donc clarifier ce que Subversion entend par
        <firstterm>ensemble de modifications</firstterm>.</para>

      <para>Chacun semble avoir sa propre définition, variant
        légèrement, d'un ensemble de modifications, ou tout du moins
        a une attente différente quant à leur traitement par le système 
        de gestion de versions. En ce qui nous concerne, disons
        qu'un ensemble de modifications n'est qu'un simple regroupement
        de modifications identifié par un nom unique. Les modifications
        peuvent inclure des changements textuels du contenu des
        fichiers, des modifications de l'arborescence ou des
        ajustements portant sur les méta-données. En langage plus
        courant, un ensemble de modifications n'est qu'un correctif
        avec un nom auquel vous pouvez vous référer.</para>

      <para>Dans Subversion, un numéro de révision globale N désigne
        une arborescence dans le dépôt&nbsp;: c'est ce à quoi le dépôt
        ressemblait après la N-ième propagation. C'est aussi le nom d'un
        ensemble de modifications implicite&nbsp;: si vous comparez
        l'arborescence N avec l'arborescence N&minus;1, vous pouvez en
        déduire exactement le correctif qui a été propagé. Pour cette
        raison, il est facile de se représenter une révision N non
        seulement comme une arborescence, mais aussi comme un ensemble
        de modifications. Si vous utilisez un système de gestion des
        incidents pour gérer vos bogues, vous pouvez utiliser les
        numéros de révision pour vous référer à des correctifs
        particuliers permettant de résoudre des bogues &mdash; par
        exemple, <quote>cet incident a été corrigé par r9238</quote>.
        Quelqu'un peut alors lancer
        <userinput>svn log -r 9238</userinput> pour obtenir le détail
        des modifications qui ont corrigé le bogue et lancer
        <userinput>svn diff -c 9238</userinput> pour voir le
        correctif lui-même. De plus (comme nous le verrons bientôt),
        la commande <command>svn merge</command> de Subversion est
        capable d'utiliser les numéros de révision. Vous pouvez
        fusionner des listes de modifications spécifiques d'une
        branche à une autre en les nommant dans les paramètres de
        la fusion&nbsp;: donner comme argument
        <userinput>-c 9238</userinput> à <command>svn merge</command>
        fusionne la liste de modifications r9238 avec
        votre copie de travail.</para>

    </sect2>

  <!-- =============================================================== -->
    <sect2 id="svn.branchemerge.basicmerging.stayinsync">
      <title>Comment garder une branche synchronisée</title>

      <para>Continuons avec notre exemple précédent et imaginons
        qu'une semaine a passé depuis que vous avez commencé à
        travailler sur votre branche privée. Votre nouvelle
        fonctionnalité n'est pas encore terminée, mais en même temps
        vous savez que d'autres personnes de votre équipe ont continué
        à faire des modifications importantes sur le
        <filename>/trunk</filename> du projet. Vous avez intérêt à
        recopier ces modifications dans votre propre branche, juste
        pour vous assurer qu'elles se combinent bien avec vos propres
        modifications. En fait, c'est là une bonne pratique&nbsp;:
        synchroniser fréquemment votre branche avec la ligne de
        développement principale permet d'éviter les conflits
        <quote>surprise</quote> le jour où vous reversez vos
        modifications dans le tronc.</para>

      <para>Subversion connaît l'historique de votre branche et sait
        à quel moment elle s'est séparée du tronc. Afin de récupérer
        les modifications du tronc les plus récentes et les plus
        importantes, assurez-vous en premier lieu que votre copie de
        travail est <quote>propre</quote>, c'est-à-dire que
        <command>svn status</command> ne liste aucune modification
        locale. Puis lancez juste&nbsp;:</para>

      <screen>
$ pwd
/home/user/ma-branche-calc

$ svn merge http://svn.exemple.com/depot/calc/trunk
--- Fusion de r345 à r356 dans '.':
U    bouton.c
U    entier.c
</screen>

      <para>La syntaxe de base, <userinput>svn merge
      <replaceable>URL</replaceable></userinput>, indique à Subversion
      qu'il doit fusionner toutes les modifications récentes depuis
      l'URL vers le répertoire de travail actuel (qui est bien souvent
      la racine de votre copie de travail). Après l'exécution de la
      commande de l'exemple précédent, la copie de travail de votre
      branche contient de nouvelles modifications locales, ces
      changements étant des duplications de toutes les modifications
      qui ont eu lieu sur le tronc depuis que vous avez créé votre
      branche&nbsp;:</para>

      <screen>
$ svn status
 M     .
M      bouton.c
M      entier.c
</screen>

      <para>Une fois rendu là, le plus sage est d'examiner
        attentivement les modifications avec
        <command>svn diff</command> et ensuite de compiler et de
        tester votre branche. Notez que le répertoire de travail
        actuel (<quote><filename>.</filename></quote>) a aussi été
        modifié&nbsp;; <command>svn diff</command> indique que sa
        propriété <literal>svn:mergeinfo</literal> a été créée ou
        modifiée. Ceci est une méta-information importante liée à la
        fusion, à laquelle vous ne devriez <emphasis>pas</emphasis>
        toucher, puisqu'elle sera nécessaire aux futures commandes
        <command>svn merge</command> (nous en apprendrons plus sur
        cette métadonnée plus loin dans ce chapitre).</para>

      <para>Après avoir effectué la fusion, vous aurez peut-être aussi
        besoin de résoudre des conflits (comme vous le faites pour
        <command>svn update</command>) ou éventuellement d'effectuer
        de petites modifications afin que les choses fonctionnent
        correctement (souvenez-vous, ce n'est pas parce qu'il n'y a
        pas de conflits <emphasis>syntaxiques</emphasis> qu'il n'y a
        pas de conflits <emphasis>sémantiques</emphasis>&nbsp;!).
        Si vous rencontrez de graves difficultés, vous pouvez toujours
        annuler les modifications locales en lançant
        <userinput>svn revert . -R</userinput> (qui annule toutes
        les modifications locales) et entamer avec vos collègues
        une longue discussion sur le thème
        <quote>Qu'est-ce qui se passe&nbsp;?</quote>. Par contre, si les
        choses se passent bien, vous pouvez propager ces
        modifications dans le dépôt&nbsp;:</para>

      <screen>
$ svn commit -m "Fusionné les dernières modifications de trunk avec ma-branche-calc"
Envoi          .
Envoi          bouton.c
Envoi          entier.c
Transmission des données ..
Révision 357 propagée.
</screen>

      <para>À présent, votre branche privée est désormais
        <quote>synchro</quote> avec le tronc, vous pouvez donc vous
        détendre, sachant qu'en continuant votre travail en isolation,
        vous ne dériverez pas trop loin de ce que
        les autres font.</para>

      <sidebar>
        <title>Pourquoi ne pas utiliser des correctifs de type patch à la place&nbsp;?</title>

        <para>Une question vous trotte peut-être dans la tête, surtout
          si vous êtes un utilisateur d'Unix&nbsp;: pourquoi s'embêter à
          utiliser <command>svn merge</command>&nbsp;? Pourquoi ne pas tout
          simplement utiliser la commande <command>patch</command> du
          système d'exploitation pour accomplir la même tâche&nbsp;?
          Par exemple&nbsp;:</para>

        <screen>
$ cd ma-branche-calc
$ svn diff -r 341:HEAD http://svn.exemple.com/depot/calc/tronc &gt; fichierpatch
$ patch -p0 &lt; fichierpatch
Patching file entier.c using Plan A...
Hunk #1 succeeded at 147.
Hunk #2 succeeded at 164.
Hunk #3 succeeded at 241.
Hunk #4 succeeded at 249.
done
</screen>

        <para>Dans cet exemple, il n'y a pas vraiment pas grande
          différence. Mais <command>svn merge</command> possède des
          fonctionnalités spécifiques qui surpassent le programme
          <command>patch</command>. Le format de fichier utilisé par
          <command>patch</command> est assez limité&nbsp;; il ne sait
          manipuler que les contenus de fichier. Il n'y a pas moyen de
          représenter des changements dans
          <emphasis>l'arborescence</emphasis>, tels que l'ajout,
          la suppression ou le renommage de fichiers ou de dossiers.
          Le programme <command>patch</command> n'est pas non plus
          capable de prendre en compte des modifications de propriétés.
          Si Sally avait, par exemple, ajouté un nouveau dossier,
          <command>svn diff</command> ne l'aurait pas mentionné du
          tout en sortie. Le résultat de <command>svn diff</command>
          n'est qu'au format <quote>patch</quote>, il y a donc des
          concepts qu'il ne peut tout simplement pas exprimer.</para>

        <para>La commande <command>svn merge</command>, par contre,
          peut gérer des modifications dans l'arborescence et dans
          les propriétés en les appliquant directement à votre copie
          de travail. Et, ce qui est encore plus important, cette
          commande enregistre les modifications qui ont été
          dupliquées vers votre branche de telle sorte que Subversion
          sait exactement quelles modifications existent dans chaque
          endroit (voir <xref
          linkend="svn.branchmerge.basicmerging.mergeinfo"/>).
          C'est une fonctionnalité cruciale qui rend la gestion des
          branches utilisable&nbsp;; sans elle, les utilisateurs
          seraient forcés de conserver des notes manuelles relatant
          quelles listes de modifications ont été fusionnées
          (et lesquelles ne l'ont pas été).</para>
      </sidebar>

      <para>Supposons qu'une autre semaine s'est écoulée. Vous avez
        propagé des modifications supplémentaires dans votre branche
        et vos camarades ont également continué à améliorer le
        tronc. Une fois encore, vous aimeriez répercuter les dernières
        modifications du tronc vers votre branche et ainsi être synchro.
        Lancez juste la même commande <command>svn merge</command>
        à nouveau&nbsp;!</para>

      <screen>
$ svn merge http://svn.exemple.com/depot/calc/trunk
--- Fusion de r357 à r380 dans '.':
U    bouton.c
U    Makefile
A    LISEZMOI
</screen>

      <para>Subversion sait quelles sont les modifications du tronc
        que vous avez déjà répercutées vers votre branche, il ne
        répercute donc que les modifications que vous n'avez pas
        encore. Une fois de plus, vous devrez compiler, tester et
        propager les modifications locales à votre branche.</para>

      <para>Cependant, que se passe-t-il quand vous finissez enfin
        votre travail&nbsp;? Votre nouvelle fonctionnalité est
        terminée et vous êtes prêt à fusionner les changements de
        votre branche avec le tronc (pour que votre équipe puisse
        bénéficier du fruit de votre travail). La procédure est
        simple. Premièrement, synchronisez à nouveau votre branche
        avec le tronc, comme vous le faites depuis le début&nbsp;:</para>

      <screen>
$ svn merge http://svn.exemple.com/repos/calc/tronc
--- Fusion de r381 à r385 dans '.':
U    bouton.c
U    LISEZMOI

$ # compiler, tester, ...

$ svn commit -m "Fusion finale des modifications du tronc dans ma-branche-calc."
Envoi          .
Envoi          bouton.c
Envoi          LISEZMOI
Transmission des données ..
Révision 390 propagée.
</screen>

      <para>À présent, utilisez <command>svn merge</command>
        pour répercuter les modifications de votre branche sur le tronc.
        Vous avez alors besoin d'une copie de travail de
        <filename>/trunk</filename> qui soit à jour. Vous pouvez
        vous la procurer soit en effectuant un
        <command>svn checkout</command>, soit en reprenant une vieille
        copie de travail du tronc, soit en utilisant
        <command>svn switch</command> (voir
        <xref linkend="svn.branchmerge.switchwc"/>). Quelle que soit
        la manière dont vous obtenez une copie de travail,
        souvenez-vous qu'une bonne méthode est d'effectuer la fusion
        dans une copie de travail qui n'a <emphasis>pas</emphasis>
        été modifiée localement et qui a été mise à jour récemment
        (en d'autres termes, qui n'est pas un mélange de révisions
        locales). Si votre copie de travail n'est pas
        <quote>propre</quote> comme expliqué à l'instant, vous risquez
        de rencontrer des problèmes facilement évitables liés à des
        conflits et <command>svn merge</command> renverra probablement
        une erreur en retour.</para>

      <para>Une fois que vous avez une copie de travail propre du
        tronc, vous êtes prêt pour y fusionner
        votre branche&nbsp;:</para>

      <screen>
$ pwd
/home/user/calc-tronc

$ svn update  # (s'assurer que la copie de travail est à jour)
À la révision 390.

$ svn merge --reintegrate http://svn.exemple.com/depot/calc/branches/ma-branche-calc
--- Fusionne toutes les modifications non fusionnées des URLs sources dans '.':
U    bouton.c
U    entier.c
U    Makefile
U   .

$ # compiler, tester, vérifier, ...

$ svn commit -m "Fusionner ma-branche-calc dans le tronc !"
Envoi          .
Envoi          bouton.c
Envoi          entier.c
Envoi          Makefile
Transmission des données ..
Révision 391 propagée.
</screen>

      <para>Félicitations, votre branche a maintenant réintégré la
        ligne de développement principale. Notez bien l'utilisation
        de l'option <option>--reintegrate</option> à cette occasion.
        L'option est essentielle pour répercuter les modifications
        d'une branche sur sa ligne de développement d'origine, ne
        l'oubliez pas&nbsp;! Elle est nécessaire car ce type de
        <quote>réintégration</quote> est un type de tâche différent
        de ce que vous avez fait jusqu'à présent. Précédemment,
        nous demandions à <command>svn merge</command> de faire la
        liste des modifications ayant eu lieu dans une ligne de
        développement (le tronc) et de les dupliquer vers une autre
        (votre branche). C'est assez simple à réaliser et à chaque
        fois Subversion sait reprendre là où il s'était arrêté. Dans
        nos exemples précédents, vous pouvez voir qu'il fusionne en
        premier les modifications 345:356 du tronc vers la branche&nbsp;;
        ensuite il continue en fusionnant le groupe contigu
        immédiatement suivant, 356:380. Quand il effectue la
        synchronisation finale, il fusionne le groupe 380:385.</para>

      <para>Cependant, lors de la réintégration d'une branche dans
        le tronc, la logique sous-jacente est assez
        différente. Votre branche dédiée est à présent un
        amoncellement de modifications provenant à la fois du tronc
        et de votre branche privée et il n'y a donc pas de groupe
        de révisions contigu à recopier. En spécifiant l'option
        <option>--reintegrate</option>, vous demandez explicitement
        à Subversion de ne recopier <emphasis>que</emphasis> les
        modifications spécifiques à votre branche (et en fait il le
        fait en comparant l'arborescence la plus récente du tronc
        avec l'arborescence la plus récente de la branche&nbsp;:
        la différence qui en résulte constitue exactement les
        modifications de votre branche&nbsp;!).</para>

      <para>Votre branche privée ayant réintégré le tronc, vous
        voudrez peut-être la supprimer du dépôt&nbsp;:</para>

      <screen>
$ svn delete http://svn.exemple.com/depot/calc/branches/ma-branche-calc \
      -m "Supprime ma-branche-calc."
Révision 392 propagée.
</screen>

      <para>Mais attendez&nbsp;! L'historique de votre branche ne
        possède-t-il pas une certaine valeur&nbsp;? Et si un beau
        jour quelqu'un voulait auditer l'évolution de votre
        fonctionnalité et examiner toutes les modifications de
        votre branche&nbsp;? Pas la peine de s'inquiéter.
        Souvenez-vous que même si votre branche n'est plus visible
        dans le dossier <filename>/branches</filename>, son existence
        demeure une partie immuable de l'historique du dépôt. Une
        simple commande <command>svn log</command> appliquée à l'URL
        <filename>/branches</filename> vous renverra l'historique
        complet de votre branche. Votre branche pourrait même
        ressusciter un jour ou l'autre, si vous le désirez (voir
        <xref linkend="svn.branchmerge.basicmerging.resurrect"/>).</para>

      <para>Dans Subversion 1.5, une fois que la fusion d'une branche
        vers le tronc a été faite avec l'option
        <option>--reintegrate</option>, la branche n'est plus
        utilisable. Elle ne peut absorber correctement de nouvelles
        modifications du tronc, ni être réintégrée à nouveau
        proprement dans le tronc. Pour cette raison, si vous voulez
        continuer à travailler sur la branche de votre fonctionnalité,
        nous vous recommandons de la détruire et de la recréer
        depuis le tronc&nbsp;:</para>

      <screen>
$ svn delete http://svn.exemple.com/depot/calc/branches/ma-branche-calc \
      -m "Supprime ma-branche-calc."
Révision 392 propagée.

$ svn copy http://svn.exemple.com/depot/calc/trunk \
           http://svn.exemple.com/depot/calc/branches/nouvelle-branche
      -m "Crée une nouvelle branche a partir du tronc."
Révision 393 propagée.

$ cd ma-branche-calc

$ svn switch http://svn.exemple.com/depot/calc/branches/nouvelle-branche
À la révision 393.
</screen>

      <para>La dernière commande de l'exemple précédent,
        <command>svn switch</command>, est une façon de mettre à
        jour une copie de travail existante afin qu'elle pointe vers
        un autre dossier du dépôt. Nous en parlerons plus en détail
        dans <xref linkend="svn.branchmerge.switchwc"/>.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.mergeinfo">
      <title>Mergeinfo et aperçus</title>

      <para>Le mécanisme de base que Subversion utilise pour gérer
        les ensembles de modifications, c'est-à-dire quelles
        modifications ont été fusionnées dans quelles branches, est
        l'enregistrement de données dans les propriétés. Plus
        précisément, les informations de fusion sont conservées dans
        la propriété <literal>svn:mergeinfo</literal> qui est
        associée aux fichiers et aux dossiers (si les propriétés de
        Subversion ne vous sont pas familières, c'est le moment de
        lire <xref linkend="svn.advanced.props"/>).</para>

      <para>Vous pouvez examiner cette propriété comme n'importe
        quelle autre&nbsp;:</para>

      <screen>
$ cd ma-branche-calc
$ svn propget svn:mergeinfo .
/trunk:341-390
</screen>

      <para>Il est <emphasis>déconseillé</emphasis> de changer
        soi-même la valeur de cette propriété, à moins de savoir
        vraiment ce que vous faites. Cette propriété est manipulée
        automatiquement par Subversion à chaque fois que vous lancez
        <command>svn merge</command>. Sa valeur indique quelles
        modifications (pour un chemin donné) ont été recopiées dans
        le dossier en question. Dans le cas présent, le chemin est
        <filename>/trunk</filename> et le dossier qui a reçu les
        modifications spécifiées est
        <filename>/branches/ma-branche-calc</filename>.</para>

      <para>Il existe également une sous-commande,
        <command>svn mergeinfo</command>, qui peut être utile pour
        voir non seulement quels ensembles de modifications un
        dossier a absorbés, mais aussi quels ensembles de modifications
        il est encore susceptible de recevoir. Ceci donne une sorte
        d'aperçu du prochain ensemble de modifications que
        <command>svn merge</command> recopiera vers
        votre branche.</para>

      <screen>
$ cd ma-branche-calc

# Quelles modifications ont déjà été fusionnées du tronc vers la branche ?
$ svn mergeinfo http://svn.exemple.com/depot/calc/trunk
r341
r342
r343
&hellip;
r388
r389
r390

# Quelles modifications sont encore susceptibles d'être fusionnées du tronc vers la branche ?
$ svn mergeinfo http://svn.exemple.com/depot/calc/trunk --show-revs eligible
r391
r392
r393
r394
r395
</screen>

      <para>La commande <command>svn mergeinfo</command> prend en
        paramètres une URL <quote>source</quote> (d'où les
        modifications viennent) et une URL <quote>cible</quote>
        optionnelle (vers laquelle les modifications sont
        fusionnées). Si aucune URL cible n'est fournie, elle suppose
        que le dossier actuel est la cible. Dans l'exemple précédent,
        puisque nous interrogeons la copie de travail de notre
        branche, la commande suppose que ce qui nous intéresse est de
        recevoir les modifications de l'URL spécifiée du tronc vers
        <filename>/branches/ma-branche-calc</filename>.</para>

      <para>Une autre manière d'obtenir un aperçu plus précis d'une
        opération de fusion est d'utiliser l'option
        <option>--dry-run</option>&nbsp;:</para>

      <screen>
$ svn merge http://svn.exemple.com/depot/calc/trunk --dry-run
U    entier.c

$ svn status
#  rien ne s'affiche, la copie de travail n'a pas changé.
</screen>

      <para>L'option <option>--dry-run</option> n'effectue en fait
        pas de modification locale sur la copie de travail. Elle ne
        fait qu'indiquer les codes d'état qui
        <emphasis>seraient</emphasis> affichés par une vraie fusion.
        Ceci permet d'obtenir un <quote>aperçu général</quote>
        d'une fusion potentielle, pour les fois où
        <command>svn diff</command> renvoie trop de détails.</para>

      <tip>
        <para>Après avoir effectué une opération de fusion, mais avant
          d'en avoir propagé les résultats, vous pouvez utiliser
          <userinput>svn diff --depth=empty
          <replaceable>/chemin/vers/la/cible/de/la/fusion</replaceable>
          </userinput>pour visualiser uniquement les modifications
          apportées à la cible immédiate de votre fusion. Si la cible
          de la fusion est un dossier, seules les différences de
          propriétés sont alors affichées. C'est un moyen très
          pratique pour voir les modifications de la propriété
          <literal>svn:mergeinfo</literal> enregistrées par
          l'opération de fusion, qui vous rappellera
          ce que vous venez juste de fusionner.</para>
      </tip>

      <para>Bien sûr, la meilleure façon d'avoir un aperçu d'une
        opération de fusion est tout simplement de la réaliser&nbsp;!
        Souvenez-vous que lancer <command>svn merge</command> n'est
        pas une opération risquée en soi (à moins que vous ayez
        effectué des modifications locales dans votre copie de
        travail, mais nous avons déjà souligné que vous ne devriez
        pas faire de fusion dans un tel environnement). Si les
        résultats de la fusion ne vous plaisent pas, lancez juste
        <userinput>svn revert . -R</userinput> pour ôter les
        modifications de votre copie de travail et réessayez la
        commande avec des options différentes. La fusion n'est
        définitive qu'une fois que vous en avez propagé
        les résultats.</para>

      <tip>
        <para>Bien qu'il soit parfaitement légitime de lancer
          <command>svn merge</command> et<command> svn revert</command>
          à plusieurs reprises pour préparer la fusion, vous risquez
          de rencontrer quelques obstacles (facilement surmontables).
          Par exemple, si l'opération de fusion ajoute un nouveau
          fichier (ou plus exactement programme son ajout),
          <command>svn revert</command> ne supprime pas
          le fichier&nbsp;; il va juste déprogrammer l'ajout. Vous
          vous retrouvez avec un fichier non suivi en versions. Si
          ensuite vous tentez à nouveau de lancer la fusion, il
          risque d'y avoir des conflits dus au fichier non suivi
          en versions resté <quote>en travers du chemin</quote>. La
          Solution&nbsp;? Après avoir effectué un retour en arrière à 
          l'aide de <command>svn revert</command>, pensez à nettoyer la
          copie de travail et supprimer les fichiers et dossiers
          non suivis en versions. Il faut que le résultat de
          <command>svn status</command> soit le plus propre possible,
          et dans l'idéal vide.</para>
          </tip>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.undo">
      <title>Retour en arrière sur des modifications</title>

      <para>Un usage très répandu de <command>svn merge</command>
        est le retour en arrière sur une modification qui a déjà
        été propagée. Supposons que vous travaillez tranquillement
        sur une copie de travail de <filename>/calc/trunk</filename>
        et que vous découvrez tout à coup que la modification faite
        il y a longtemps lors de la révision 303, qui affectait
        <filename>entier.c</filename>, est complètement incorrecte.
        Elle n'aurait jamais du être propagée. Vous pouvez utiliser
        <command>svn merge</command> pour revenir en arrière sur
        cette modification dans votre copie de travail, puis propager
        la modification locale au dépôt. Il suffit juste de spécifier
        une différence <emphasis>inversée</emphasis> (en indiquant
        soit <option>--revision 303:302</option>, soit
        <option>--change -303</option>, les deux se valent).</para>

      <screen>
$ svn merge -c -303 http://svn.exemple.com/depot/calc/trunk
--- Fusion inverse de r303 dans 'entier.c':
U    entier.c

$ svn status
 M     .
M      entier.c

$ svn diff
&hellip;
# vérifier que la modification est supprimée
&hellip;

$ svn commit -m "Retour en arrière sur la modification propagée en r303."
Envoi          entier.c
Transmission des données .
Révision 350 propagée.
</screen>

      <para>Comme nous l'avons signalé précédemment, une façon de se
        représenter une révision du dépôt est de la considérer comme
        un ensemble de modifications spécifique. En utilisant l'option
        <option>-r</option>, vous pouvez demander à
        <command>svn merge</command> d'appliquer un ensemble de
        modifications, ou tout un groupe d'ensembles de modifications,
        à votre copie de travail. Dans le cas présent, pour revenir
        en arrière, nous demandons à <command>svn merge</command>
        d'appliquer <emphasis>dans le sens inverse</emphasis>
        l'ensemble de modifications nº303 à notre copie de travail.</para>

        <para>Gardez à l'esprit que revenir en arrière sur une
          modification de cette façon est similaire à toute autre
          opération <command>svn merge</command>, vous devez donc
          ensuite utiliser <command>svn status</command> et
          <command>svn diff</command> pour vous assurer que votre
          travail est dans l'état que vous voulez, puis utiliser
          <command>svn commit</command> pour propager la version
          finale au dépôt. Après la propagation, cet ensemble de
          modifications particulier n'est plus présent dans la
          révision <literal>HEAD</literal>.</para>

      <para>À nouveau vous vous dites&nbsp;: bon, ceci n'a pas
        vraiment annulé la propagation, n'est-ce pas&nbsp;? La
        modification existe toujours en révision 303. Si quelqu'un
        extrait une version du projet calc entre les révisions 303
        et 349, il verra toujours la mauvaise modification,
        non&nbsp;?</para>

      <para>Oui, c'est vrai. Quand nous parlons de
        <quote>supprimer</quote> une modification, il s'agit de la
        supprimer de la révision <literal>HEAD</literal>. La
        modification originale existe toujours dans l'historique du
        dépôt. Dans la plupart des situations, c'est suffisant. La
        plupart des gens ne s'intéressent d'ailleurs qu'à la révision
        <literal>HEAD</literal> du projet. Il y a des cas particuliers,
        cependant, où l'on voudra vraiment détruire toute preuve de
        la propagation (quelqu'un a peut-être accidentellement propagé
        un document confidentiel). Cela ne s'avère pas si facile, parce
        que Subversion a été conçu délibérément pour ne jamais perdre
        d'information. Les révisions sont des arborescences immuables
        qui sont empilées les unes par dessus les autres. Supprimer
        une révision de l'historique créerait un effet domino,
        engendrant le chaos dans les révisions ultérieures et
        invalidant potentiellement toutes les copies de travail
        <footnote>
          <para>Le projet Subversion prévoit néanmoins
            d'implémenter, un jour, une commande qui accomplirait
            la tâche de supprimer des informations de façon
            permanente. En attendant, en guise de palliatif,
            voir <xref
            linkend="svn.reposadmin.maint.tk.svndumpfilter"/>.</para>
        </footnote>.
      </para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.resurrect">
      <title>Résurrection des éléments effacés</title>

      <para>Ce qu'il y a de formidable dans les systèmes de gestion
        de versions, c'est que les informations ne sont jamais
        perdues. Même si vous effacez un fichier ou un dossier, s'il
        disparaît bien de la révision <literal>HEAD</literal>, l'objet
        existe toujours dans les révisions précédentes. Une des
        questions les plus courantes que posent les nouveaux
        utilisateurs est&nbsp;: <quote>Comment est-ce que je récupère
        mon ancien fichier ou dossier&nbsp;?</quote></para>

      <para>La première étape est de définir exactement
        <emphasis>quel</emphasis> élément vous essayez de ressusciter.
        Voici une métaphore utile&nbsp;: vous pouvez imaginer votre
        objet dans le dépôt comme existant dans une sorte de système
        à deux dimensions. La première coordonnée est une révision
        correspondant à une arborescence particulière&nbsp;; la
        deuxième coordonnée est un chemin à l'intérieur de cette
        arborescence. Ainsi, toute version d'un fichier ou d'un
        dossier peut être définie par une paire de coordonnées
        qui lui est propre (souvenez-vous de la syntaxe des
        <quote>piquets de révisions</quote>&nbsp;: machin.c@224,
        mentionnée dans <xref linkend="svn.advanced.pegrevs"/>).</para>

      <para>Tout d'abord, vous allez peut-être avoir besoin de
        <command>svn log</command> pour identifier précisément les
        coordonnées du fichier ou dossier que vous voulez ressusciter.
        À cette fin, une bonne stratégie est de lancer
        <userinput>svn log --verbose</userinput> dans un dossier qui
        contenait votre élément effacé. L'option
        <option>--verbose</option> (<option>-v</option>) renvoie la
        liste de tous les éléments modifiés par chaque révision&nbsp;;
        il vous suffit alors de trouver la révision dans laquelle
        vous avez effacé le fichier ou le dossier en question.
        Vous pouvez accomplir cette recherche soit visuellement
        soit en utilisant un autre outil pour examiner
        le résultat de la commande <command>svn log</command>
        (via <command>grep</command> ou peut-être via une recherche
        incrémentale dans un éditeur).</para>

      <screen>
$ cd dossier-parent
$ svn log -v
&hellip;
------------------------------------------------------------------------
r808 | paul | 2003-12-26 14:29:40 -0600 (ven. 26 déc 2003) | 3 lignes
Chemins modifiés :
   D /calc/trunk/reel.c
   M /calc/trunk/entier.c

Ajouté les fonctions des transformées de fourier dans entier.c.
Supprimé reel.c car code désormais dans double.c.
&hellip;
</screen>

      <para>Dans l'exemple ci-dessus, nous supposons que vous
        recherchez un fichier effacé nommé <filename>reel.c</filename>.
        En examinant le journal du dossier parent, vous avez découvert
        que ce fichier a été effacé en révision 808. La dernière
        version du fichier à avoir existé était donc dans la révision
        précédant celle-ci. Conclusion&nbsp;: vous voulez ressusciter
        le chemin <filename>/calc/trunk/reel.c</filename> tel qu'il
        était en révision 807.</para>

      <para>Voilà, c'était la partie difficile&nbsp;: la recherche.
        Maintenant que vous savez ce que vous voulez récupérer,
        deux options s'offrent à vous.</para>

      <para>Une possibilité serait d'utiliser
        <command>svn merge</command> pour appliquer la révision 808
        <quote>à l'envers</quote> (nous avons déjà parlé de comment
        revenir sur des modifications dans <xref
        linkend="svn.branchmerge.basicmerging.undo"/>). Ceci aurait
        pour effet de ré-ajouter <filename>reel.c</filename> en tant
        que modification locale. Le fichier serait alors programmé
        pour être ajouté et après la propagation le fichier existerait
        à nouveau dans <literal>HEAD</literal>.</para>

      <para>Cependant, dans cet exemple particulier, ce n'est
        probablement pas la meilleure stratégie. Appliquer la
        révision 808 à l'envers programmerait non seulement l'ajout
        de <filename>reel.c</filename>, mais le message de propagation
        indique qu'il reviendrait aussi sur certaines modifications
        de <filename>entier.c</filename>, ce que vous ne voulez pas.
        Vous pourriez certainement fusionner à l'envers la révision
        808 et ensuite revenir sur les modifications locales faites
        dans <filename>entier.c</filename>, mais cette technique
        fonctionne mal à plus grande échelle. Que dire, si 90 fichiers
        avaient été modifiés en révision 808&nbsp;?</para>

      <para>Une seconde stratégie plus ciblée est de ne pas utiliser
        <command>svn merge</command> du tout, mais plutôt d'utiliser
        la commande <command>svn copy</command>. Copiez juste la
        révision et le chemin exacts (vos deux
        <quote>coordonnées</quote>) du dépôt
        vers votre copie de travail&nbsp;:</para>

      <screen>
$ svn copy http://svn.exemple.com/depot/calc/trunk/reel.c@807 ./reel.c

$ svn status
A  +   reel.c

$ svn commit -m "Ressuscité reel.c à partir de la révision 807, /calc/trunk/reel.c."
Ajout         reel.c
Transmission des données .
Révision 1390 propagée.
</screen>

      <para>Le symbole plus dans le résultat de la commande
        <command>svn status</command> indique que l'élément n'est
        pas simplement programmé pour ajout, mais programmé pour ajout
        <quote>avec son historique</quote>. Subversion se souviendra
        d'où il a été copié. Dans le futur, lancer
        <command>svn log</command> sur ce fichier parcourra tout son
        historique en passant par la résurrection du fichier ainsi que
        tout ce qui précédait la révision 807. En d'autres termes,
        ce nouveau <filename>reel.c</filename> n'est pas vraiment
        nouveau&nbsp;; c'est un descendant direct du fichier original
        qui avait été effacé. En général c'est une bonne chose, dont
        l'utilité est avérée. Si cependant vous vouliez récupérer
        le fichier <emphasis>sans</emphasis> conserver de lien
        historique avec l'ancien fichier, la technique suivante
        fonctionnerait tout aussi bien&nbsp;:</para>

      <screen>
$ svn cat http://svn.exemple.com/depot/calc/trunk/reel.c@807 &gt; ./reel.c

$ svn add reel.c
A         reel.c

$ svn commit -m "Recréé reel.c à partir de la révision 807."
Ajout         reel.c
Transmission des données .
Révision 1390 propagée.
</screen>

      <para>Bien que notre exemple ne porte que sur la résurrection
        d'un fichier, remarquez que ces mêmes techniques fonctionnent
        tout aussi bien pour ressusciter des dossiers effacés.
        Remarquez aussi que cette résurrection ne doit pas forcément
        avoir lieu dans votre copie de travail&nbsp;; elle peut avoir
        lieu entièrement dans le dépôt&nbsp;:</para>

      <screen>
$ svn copy http://svn.exemple.com/depot/calc/trunk/reel.c@807 \
           http://svn.exemple.com/depot/calc/trunk/ \
      -m "Ressuscite reel.c dans la révision 807."
Révision 1390 propagée.

$ svn update
A    reel.c
À la révision 1390.
</screen>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.advanced">
    <title>Fusions&nbsp;: pratiques avancées</title>

    <para>Ici finit la magie automatisée. Tôt ou tard, une fois que
      vous maîtrisez bien la gestion des branches et les fusions,
      vous allez vous retrouver à demander à Subversion de fusionner
      des modifications spécifiques d'un endroit à un autre. Pour
      faire cela, vous allez devoir commencer à passer des paramètres
      plus compliqués à <command>svn merge</command>. Le paragraphe
      suivant décrit la syntaxe complète de la commande et aborde
      un certain nombre de scénarios d'utilisation courants.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.cherrypicking">
      <title>Sélection à la main</title>

      <para>De la même façon que le terme <quote>ensemble
        de modifications</quote> est utilisé couramment dans les
        systèmes de gestion de versions, le terme <quote>sélectionner
        à la main</quote> pourrait l'être aussi. Il désigne l'action
        de choisir <emphasis>une</emphasis> liste de modifications
        particulière au sein d'une branche et de la recopier dans une
        autre. Sélectionner à la main peut aussi faire référence à
        l'action de dupliquer un ensemble de modifications
        (pas nécessairement contiguës&nbsp;!) d'une branche vers une
        autre. Ceci est en opposition avec des scénarios de fusion
        plus courants, où l'ensemble de révisions contiguës
        <quote>suivant</quote> est dupliqué automatiquement.</para>

      <para>Pourquoi voudrait-on ne recopier qu'une modification
        unique&nbsp;? Cela arrive plus souvent qu'on ne croit.
        Par exemple, remontons le temps et imaginons que vous
        n'avez pas encore réintégré votre branche de développement
        privée dans le tronc. À la machine à café, vous apprenez par
        hasard que Sally a apporté une modification intéressante à
        <filename>entier.c</filename> dans le tronc. Vous reportant à
        l'historique des propagations du tronc, vous vous apercevez
        qu'elle a corrigé un bogue crucial en révision 355, qui
        impacte directement la fonctionnalité sur laquelle vous êtes
        en train de travailler. Vous n'êtes peut-être pas encore prêt
        à fusionner toutes les modifications du tronc dans votre
        branche, mais vous avez certainement besoin de ce correctif
        pour continuer votre travail.</para>

      <screen>
$ svn diff -c 355 http://svn.exemple.com/depot/calc/trunk

Index: entier.c
===================================================================
--- entier.c	(revision 354)
+++ entier.c	(revision 355)
@@ -147,7 +147,7 @@
     case 6:  sprintf(info->operating_system, "HPFS (OS/2 ou NT)"); break;
     case 7:  sprintf(info->operating_system, "Macintosh"); break;
     case 8:  sprintf(info->operating_system, "Z-System"); break;
-    case 9:  sprintf(info->operating_system, "CP/MM");
+    case 9:  sprintf(info->operating_system, "CP/M"); break;
     case 10:  sprintf(info->operating_system, "TOPS-20"); break;
     case 11:  sprintf(info->operating_system, "NTFS (Windows NT)"); break;
     case 12:  sprintf(info->operating_system, "QDOS"); break;
</screen>

      <para>De la même façon que vous avez utilisé
        <command>svn diff</command> dans l'exemple précédent pour
        examiner la révision 355, vous pouvez passer le même
        paramètre à <command>svn merge</command>&nbsp;:</para>

      <screen>
$ svn merge -c 355 http://svn.exemple.com/depot/calc/trunk
U    entier.c

$ svn status
M      entier.c
</screen>

      <para>Vous pouvez à présent lancer les procédures habituelles
        de tests, avant de propager cette modification à votre branche.
        Après la propagation, Subversion marque r355 comme ayant été
        fusionnée dans la branche, afin qu'une future fusion
        <quote>magique</quote> synchronisant votre branche avec le
        tronc sache qu'elle doit sauter r355 (fusionner une même
        modification dans une même branche aboutit presque toujours
        à un conflit&nbsp;!).</para>

      <screen>
$ cd ma-branche-calc

$ svn propget svn:mergeinfo .
/trunk:341-349,355

# Remarquez que r355 n'est pas listée comme "éligible" à la fusion,
# parce qu'elle a déjà été fusionnée.
$ svn mergeinfo http://svn.exemple.com/depot/calc/trunk --show-revs eligible
r350
r351
r352
r353
r354
r356
r357
r358
r359
r360

$ svn merge http://svn.example.com/depot/calc/trunk
--- Fusion de r350 à r354 dans '.':
 U   .
U    entier.c
U    Makefile
--- Fusion de r356 à r360 dans '.':
 U   .
U    entier.c
U    bouton.c
</screen>

      <para>Ce type d'utilisation de la copie (ou rétroportage)
        de correctifs d'une branche à une autre est peut-être la
        raison la plus répandue pour sélectionner à la main des
        modifications&nbsp;; le cas se présente très souvent,
        par exemple lorsqu'une équipe gère une
        <quote>branche de production</quote> du logiciel
        (ce thème est développé dans
        <xref linkend="svn.branchmerge.commonpatterns.release"/>).</para>

      <warning>
        <para>Avez-vous remarqué la façon dont, dans le dernier
          exemple, le lancement de la fusion a eu
          pour effet l'application de deux ensembles distincts de
          fusions&nbsp;? La commande <command>svn merge</command> a
          appliqué deux correctifs indépendants à votre copie de
          travail, afin de sauter l'ensemble de modifications 355,
          que votre branche contenait déjà. Il n'y a rien de mal
          en soi là-dedans, sauf que ça risque de rendre plus
          délicate la résolution des conflits. Si le premier groupe
          de modifications engendre des conflits, vous
          <emphasis>devrez</emphasis> les résoudre de façon
          interactive pour que la procédure de fusion puisse
          continuer et appliquer le deuxième groupe de modifications.
          Si vous remettez à plus tard un conflit lié à la première
          vague de modifications, la commande de fusion renverra au
          final un message d'erreur
          <footnote>
            <para>Ceci est au vrai pour Subversion 1.5 au
              moment où ces lignes sont écrites. Ce fonctionnement
              sera sans doute amélioré dans les versions futures
              de Subversion.</para>
          </footnote>.
        </para>
      </warning>

      <para>Avertissement&nbsp;: bien que <command>svn diff</command>
        et <command>svn merge</command> soient conceptuellement très 
        similaires, leur syntaxe est différente dans de
        nombreux cas. Pour plus de détails, reportez-vous au
        <xref linkend="svn.ref"/> ou consultez
        <command>svn help</command>. Par exemple,
        <command>svn merge</command> demande en entrée, en tant que
        cible, le chemin d'une copie de travail, c'est-à-dire un
        emplacement où il va appliquer le correctif généré. Si la
        cible n'est pas spécifiée, il suppose que vous essayez
        d'exécuter l'une des opérations suivantes&nbsp;:</para>

      <itemizedlist>
        <listitem>
          <para>Vous voulez fusionner les modifications du dossier
            dans votre dossier de travail en cours.</para>
        </listitem>
        <listitem>
          <para>Vous voulez fusionner les modifications d'un fichier
            donné dans un fichier du même nom existant dans votre
            dossier de travail en cours.</para>
        </listitem>
      </itemizedlist>

      <para>Si vous fusionnez un dossier et que vous n'avez pas
        encore spécifié de cible, <command>svn merge</command>
        suppose qu'il est dans la première situation et essaie
        d'appliquer les modifications dans votre dossier en cours.
        Si vous fusionnez un fichier et que ce fichier
        (ou un fichier du même nom) existe dans votre dossier de
        travail en cours, <command>svn merge</command> suppose
        qu'il est dans la seconde situation et essaie d'appliquer
        les modifications au fichier local du même nom.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.advancedsyntax">
      <title>Syntaxe de la fusion&nbsp;: pour tout vous dire</title>

      <para>Nous venons de voir des exemples d'utilisation de la
        commande <command>svn merge</command> et nous allons bientôt
        en voir plusieurs autres. Si vous n'avez pas bien assimilé le
        le fonctionnement des fusions, rassurez-vous, vous n'êtes pas un
        cas isolé. De nombreux utilisateurs (en particulier ceux
        qui découvrent la gestion de versions) commencent par une phase
        de perplexité au sujet de la syntaxe de la commande, ainsi que
        quand et comment utiliser cette fonctionnalité. Mais, en fait,
        cette commande est bien plus simple que
        vous ne le pensez&nbsp;! Il y a une technique très simple
        pour comprendre comment <command>svn merge</command> agit.</para>

      <para>La raison principale de la confusion est le nom de la
        commande. Le terme <quote>merge</quote> indique en quelque
        sorte que les branches vont être combinées, ou qu'un
        mystérieux mélange des données va avoir lieu. Ce n'est pas
        le cas. Un nom plus approprié pour cette commande aurait pu
        être <quote>comparer-et-appliquer</quote>, car c'est là tout
        ce qui se passe&nbsp;: deux arborescences sont comparées et
        les différences sont appliquées à une copie de travail.</para>

      <para>Si vous utilisez svn merge pour effectuer de simples
        copies de modifications entre branches, elle fait généralement
        ce qu'il faut automatiquement. Par exemple, une commande
        telle que&nbsp;:</para>

      <screen>
$ svn merge http://svn.exemple.com/depot/calc/une-branche
</screen>

      <para>tente de dupliquer toutes les modifications faites
        dans <filename>une-branche</filename> vers votre répertoire
        de travail actuel, qui est sans doute une copie de travail
        partageant des liens historiques avec la branche. La commande
        est suffisamment intelligente pour ne copier que les
        modifications que votre copie de travail ne possède pas
        encore. Si vous répétez cette commande une fois par semaine,
        elle ne copie que les modifications
        <quote>les plus récentes</quote> qui ont eu lieu depuis la
        dernière fusion.</para>

      <para>Si vous choisissez d'utiliser la commande
        <command>svn merge</command> dans sa version intégrale en
        lui fournissant les groupes de révisions spécifiques à copier,
        la commande prend trois paramètres&nbsp;:</para>

      <orderedlist>

        <listitem><para>une arborescence initiale (souvent appelée
          <firstterm>côté gauche</firstterm>
          de la comparaison)&nbsp;;</para></listitem>

        <listitem><para>une arborescence finale (souvent appelée
          <firstterm>côté droit</firstterm>
        de la comparaison)&nbsp;;</para></listitem>

        <listitem><para>une copie de travail qui reçoit les
          différences en tant que modifications locales (souvent
          appelée <firstterm>cible</firstterm>
          de la fusion).</para></listitem>

      </orderedlist>

      <para>Une fois ces trois paramètres fournis, les deux
        arborescences sont comparées et les différences sont
        appliquées à la copie de travail cible en tant que
        modifications locales. Une fois que la commande s'est
        terminée, le résultat est le même que si vous aviez édité
        les fichiers à la main ou lancé diverses commandes
        <command>svn add</command> ou <command>svn delete</command>
        vous-même. Si le résultat vous plaît, vous pouvez le propager.
        S'il ne vous plaît pas, vous pouvez toujours lancer
        <command>svn revert</command> pour revenir en arrière sur
        toutes les modifications.</para>

      <para>La syntaxe de <command>svn merge</command> est assez 
        flexible quant à la façon de spécifier les trois paramètres. 
        Voici quelques exemples&nbsp;:</para>

      <screen>
$ svn merge http://svn.exemple.com/depot/branche1@150 \
			 http://svn.exemple.com/depot/branche2@212 \
			 ma-copie-de-travail

$ svn merge -r 100:200 http://svn.exemple.com/depot/trunk ma-copie-de-travail

$ svn merge -r 100:200 http://svn.exemple.com/depot/trunk
</screen>

      <para>La première syntaxe liste les trois arguments de façon
        explicite, spécifiant chaque arborescence sous la forme
        <emphasis>URL@REV</emphasis> et incluant la copie de travail
        cible. La deuxième syntaxe peut être utilisée comme raccourci
        pour les cas où vous comparez des révisions différentes de la
        même URL. La dernière syntaxe indique que le paramètre copie
        de travail est optionnel&nbsp;; s'il est omis, elle utilise
        par défaut le répertoire en cours.</para>

        <para>Si le premier exemple donne la syntaxe
          <quote>complète</quote> de <command>svn merge</command>,
          celle-ci doit être utilisée avec grande prudence&nbsp;;
          elle peut en effet aboutir à des fusions qui
          n'enregistrent pas la moindre méta-donnée
          <literal>svn:mergeinfo</literal>. Le paragraphe suivant
          évoque ceci plus en détail.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.nomergedata">
      <title>Fusions sans mergeinfo</title>

      <para>Subversion essaye de générer des métadonnées de fusion
        dès qu'il le peut, afin de rendre plus intelligentes les
        invocations suivantes de <command>svn merge</command>.
        Néanmoins, il reste des situations où les données
        <literal>svn:mergeinfo</literal> ne sont ni créées ni
        modifiées. Pensez à être prudent avec les scénarios
        suivants&nbsp;:</para>

      <variablelist>
        <varlistentry>
          <term>Fusionner des sources sans lien de parenté</term>
          <listitem>
          <para>Si vous demandez à <command>svn merge</command>
            de comparer deux URLs qui n'ont pas de lien entre elles,
            un correctif est quand même généré et appliqué à votre
            copie de travail, mais aucune métadonnée de fusion n'est
            créée. Il n'y a pas d'historique commun aux deux
            sources et les futures fusions
            <quote>intelligentes</quote> dépendent de cet
            historique commun.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Fusionner avec des dépôts extérieurs</term>
          <listitem>
          <para>Bien qu'il soit possible de lancer une commande telle
            que <userinput>svn merge -r 100:200
            <replaceable>http://svn.projetexterieur.com/depot/trunk</replaceable></userinput>,
            le correctif résultant ne comporte aucune métadonnée
            historique de fusion. À la date d'aujourd'hui, Subversion
            n'est pas capable de représenter des URL de dépôts
            différents au sein de la propriété
            <literal>svn:mergeinfo</literal>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Utiliser <option>--ignore-ancestry</option></term>
          <listitem>
          <para>Si ce paramètre est passé à
            <command>svn merge</command>, il force la logique de
            fusion à générer les différences sans réfléchir, de la
            même façon que <command>svn diff</command> les génère,
            en ignorant toute considération historique. Nous
            traitons ce point plus loin dans ce chapitre dans
            <xref linkend="svn.branchmerge.advanced.ancestry"/>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Appliquer des fusions inversées à l'historique
            naturel de la cible</term>
          <listitem>
            <para>Précédemment dans ce chapitre (dans
              <xref linkend="svn.branchmerge.basicmerging.undo"/>),
              nous avons vu comment utiliser
              <command>svn merge</command> pour appliquer un
              <quote>correctif inversé</quote>, comme moyen de
              revenir en arrière sur des modifications. Si cette
              technique est utilisée pour revenir sur une
              modification faite à l'historique propre d'un objet
              (par exemple, propager r5 au tronc, puis revenir
              immédiatement en arrière sur r5 en utilisant
              <userinput>svn merge . -c -5</userinput>), ce type
              de fusion ne touche pas aux informations de fusion
              (<literal>mergeinfo</literal>) enregistrées
            <footnote>
              <para>À noter qu'après être revenu en arrière sur une
                révision de cette manière, nous ne serions plus
                capables de ré-appliquer cette révision avec
                <userinput>svn merge . -c 5</userinput>, puisque
                les mergeinfo incluraient déjà r5 comme ayant été
                appliquée. Nous serions alors obligés d'utiliser
                l'option <option>--ignore-ancestry</option> pour forcer
                la commande de fusion à ignorer le contenu de
                mergeinfo&nbsp;!</para>
            </footnote>.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>

    </sect2>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
    <sect2 id="svn.branchmerge.advanced.mergeconflicts">
      <title>Plus de détails sur les conflits liés aux fusions</title>

      <para>Tout comme la commande <command>svn update</command>,
        <command>svn merge</command> applique les modifications à
        votre copie de travail. Elle est donc aussi susceptible de
        créer des conflits. Cependant, les conflits engendrés par
        <command>svn merge</command> sont parfois différents et ce
        paragraphe va expliquer ces différences.</para>

      <para>Pour commencer, supposons que votre copie de travail n'a
        pas de modification locale en cours. Quand vous lancez
        <command>svn update</command> pour la mettre à jour à une
        révision particulière, les modifications envoyées par le
        serveur s'appliquent toujours <quote>proprement</quote>
        à votre copie de travail. Le serveur génère le delta en
        comparant deux arborescences&nbsp;: d'une part un
        instantané virtuel de votre copie de travail, d'autre part
        l'arborescence de la révision qui vous intéresse. Parce que
        la partie gauche de la comparaison est parfaitement égale à
        ce que vous avez déjà, il est garanti que le delta va
        convertir correctement votre copie de travail en
        l'arborescence de droite.</para>

      <para>Mais <command>svn merge</command> ne dispose pas de
        telles garanties et peut être bien plus chaotique&nbsp;:
        l'utilisateur avancé peut demander au serveur de comparer
        <emphasis>n'importe quelle</emphasis> paire d'arborescences,
        même des arborescences n'ayant aucun rapport avec la copie
        de travail&nbsp;! Cela laisse potentiellement beaucoup de
        place à l'erreur humaine. Les utilisateurs vont parfois
        comparer deux arborescences qui ne sont pas les bonnes,
        créant ainsi un delta qui ne s'appliquera pas proprement.
        <command>svn merge</command> fera de son mieux pour
        appliquer la plus grande partie possible du delta, mais ça
        risque d'être impossible pour certains morceaux. De la même
        façon que la commande Unix <command>patch</command> se plaint
        parfois de <quote>morceaux ratés</quote>
        (<foreignphrase>failed hunks</foreignphrase>),
        <command>svn merge</command> se plaint de
        <quote>cibles manquantes omises</quote>
        (<foreignphrase>skipped targets</foreignphrase>)&nbsp;:</para>

      <screen>
$ svn merge -r 1288:1351 http://svn.exemple.com/depot/branche
U    truc.c
U    bidule.c
Cible manquante omise : 'baz.c'
U    blob.c
U    machin.h
Conflit découvert dans 'glorb.h'.
Sélectionner : (p) report, (df) diff complet, (e) édite,
        (h) aide pour plus d'options :
</screen>

      <para>Dans l'exemple précédent, il est possible que
        <filename>baz.c</filename> existe dans les deux instantanés
        de la branche en question et que le delta résultant
        tente de modifier le contenu du fichier, mais que le fichier
        n'existe pas dans la copie de travail. Quoi qu'il en soit,
        le message <quote>Cible manquante omise</quote> signifie que
        l'utilisateur compare probablement les mauvaises
        arborescences&nbsp;; c'est le signe classique d'une erreur
        de l'utilisateur. Quand ça arrive, il est facile de revenir
        en arrière de manière récursive sur toutes les modifications
        créées par la fusion
        (<userinput>svn revert . --recursive</userinput>), d'effacer
        tout fichier ou dossier non suivi en versions restant après le
        retour en arrière et de relancer <command>svn merge</command>
        avec des paramètres différents.</para>

      <para>Remarquez également que l'exemple précédent indique un
        conflit sur <filename>glorb.h</filename>. Nous avons déjà
        mentionné que la copie de travail n'a pas de modifications
        locales en cours&nbsp;: comment peut-il donc y avoir
        conflit&nbsp;? Encore une fois, parce que l'utilisateur peut
        utiliser <command>svn merge</command> pour définir et
        appliquer n'importe quel vieux delta à la copie de travail,
        ce delta risque de contenir des modifications textuelles qui
        ne s'appliquent pas proprement à un fichier de la copie de
        travail, même si ce fichier n'a pas de modifications locales
        en cours.</para>

      <para>Une autre petite différence entre
        <command>svn update</command> et <command>svn merge</command>
        concerne les noms des fichiers textes créés quand un conflit
        a lieu. Dans <xref linkend="svn.tour.cycle.resolve"/>,
        nous avons vu qu'une mise à jour génère des fichiers appelés
        <filename>nomdufichier.mine</filename>,
        <filename>nomdufichier.rOLDREV</filename> et
        <filename>nomdufichier.rNEWREV</filename>. Cependant,
        quand <command>svn merge</command> cause un conflit, il crée
        trois fichiers appelés
        <filename>nomdufichier.working</filename>,
        <filename>nomdufichier.left</filename> et
        <filename>nomdufichier.right</filename>. Dans ce cas,
        les termes <quote>left</quote> et <quote>right</quote>
        décrivent de quel côté de la double comparaison d'arborescences
        le fichier venait. Dans tous les cas, ces noms de fichiers
        différents vous aideront à distinguer les conflits résultant
        d'une mise à jour de ceux résultant d'une fusion.</para>

    </sect2>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
    <sect2 id="svn.branchmerge.advanced.blockchanges">
      <title>Blocage de modifications</title>

      <para>Il peut parfois y avoir un ensemble de modifications
        particulier dont vous ne voulez pas qu'il soit fusionné
        automatiquement. Par exemple, peut–être que l'habitude dans
        votre équipe est d'effectuer tout nouveau travail de
        développement dans <filename>/trunk</filename>, mais d'être
        plus conservateur en ce qui concerne le rétroportage des
        modifications vers une branche stable que vous utilisez
        pour la publication. À l'extrême, vous pouvez sélectionner
        à la main des ensembles de modifications individuels du tronc
        à porter vers la branche&nbsp;: juste les changements qui
        sont suffisamment stables pour être acceptables. Peut-être
        que les choses ne sont pas aussi strictes après tout&nbsp;;
        peut-être que la plupart du temps vous aimeriez juste laisser
        <command>svn merge</command> fusionner automatiquement la
        plupart des modifications du tronc vers la branche. Dans ce
        cas, il vous faudrait une façon de masquer quelques
        modifications particulières, c'est-à-dire d'empêcher qu'elles
        ne soient fusionnées automatiquement.</para>

      <para>Dans Subversion 1.5, la seule manière de bloquer une
        liste de modifications est de faire croire au système que
        cette modification a déjà été fusionnée. Pour cela, il est
        possible de lancer la commande de fusion avec l'option
        <option>--record-only</option>&nbsp;:</para>

      <screen>
$ cd ma-branche-calc

$ svn propget svn:mergeinfo .
/trunk:1680-3305

# Marquons l'ensemble de modifications r3328 comme déjà fusionné.
$ svn merge -c 3328 --record-only http://svn.exemple.com/depot/calc/tronc

$ svn status
M     .

$ svn propget svn:mergeinfo .
/trunk:1680-3305,3328

$ svn commit -m "Empêche r3328 d'être fusionnée vers la branche."
&hellip;
</screen>

      <para>Cette technique fonctionne, mais elle est un petit peu
        dangereuse. Le problème principal est que nous ne faisons pas
        clairement la différence entre
        <quote>J'ai déjà cette modification</quote> et
        <quote>Je n'ai pas cette modification</quote>. En fait, nous
        mentons au système, en lui faisant croire que la modification
        a déjà été fusionnée. Ce qui transfère vers vous,
        l'utilisateur, la responsabilité de vous rappeler que la
        modification n'a en fait pas été fusionnée, qu'elle n'était
        tout simplement pas voulue. Il n'y a pas moyen de demander à
        Subversion la liste des <quote>listes de modifications
        bloquées</quote>. Si vous voulez en conserver la trace
        (afin de pouvoir les débloquer un jour), vous devrez les
        consigner dans un fichier texte quelque part, ou peut-être
        dans une propriété inventée de toutes pièces pour l'occasion.
        Dans Subversion 1.5, malheureusement, c'est la seule façon de
        gérer les révisions bloquées&nbsp;; dans les versions futures
        il est prévu d'en améliorer l'interface.</para>

    </sect2>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
    <sect2 id="svn.branchmerge.advanced.logblame">
      <title>Historiques et annotations tenant compte
        des fusions passées</title>

      <para>Une des fonctionnalités principales de tout système de
        gestion de versions est de conserver la trace de qui a
        modifié quoi et quand ils l'ont fait. Les commandes
        <command>svn log</command> et <command>svn blame</command>
        sont les outils adaptés pour cela&nbsp;: quand on les
        applique à des fichiers individuels, ils renvoient non
        seulement l'historique des ensembles de modifications qui
        ont touché le fichier, mais aussi exactement quel
        utilisateur a écrit quelle ligne de code et quand il
        l'a fait.</para>

      <para>Cependant, quand des modifications commencent à être
        copiées entre des branches, les choses commencent à se
        compliquer. Par exemple, si vous interrogiez
        <command>svn log</command> sur l'historique de votre branche
        fonctionnelle, il renverrait exactement toutes les révisions
        qui ont touché cette branche&nbsp;:</para>

      <screen>
$ cd ma-branche-calc
$ svn log -q
------------------------------------------------------------------------
r390 | utilisateur | 2002-11-22 11:01:57 -0600 (ven. 22 nov. 2002) | 1 ligne
------------------------------------------------------------------------
r388 | utilisateur | 2002-11-21 05:20:00 -0600 (jeu. 21 nov. 2002) | 2 lignes
------------------------------------------------------------------------
r381 | utilisateur | 2002-11-20 15:07:06 -0600 (mer. 20 nov. 2002) | 2 lignes
------------------------------------------------------------------------
r359 | utilisateur | 2002-11-19 19:19:20 -0600 (mar. 19 nov. 2002) | 2 lignes
------------------------------------------------------------------------
r357 | utilisateur | 2002-11-15 14:29:52 -0600 (ven. 15 nov. 2002) | 2 lignes
------------------------------------------------------------------------
r343 | utilisateur | 2002-11-07 13:50:10 -0600 (jeu. 07 nov. 2002) | 2 lignes
------------------------------------------------------------------------
r341 | utilisateur | 2002-11-03 07:17:16 -0600 (dim. 03 nov. 2002) | 2 lignes
------------------------------------------------------------------------
r303 | sally | 2002-10-29 21:14:35 -0600 (mar. 29 oct. 2002) | 2 lignes
------------------------------------------------------------------------
r98 | sally | 2002-02-22 15:35:29 -0600 (ven. 22 fev. 2002) | 2 lignes
------------------------------------------------------------------------
</screen>

      <para>Mais est-ce bien là une description adéquate de tous les
        changements qui ont eu lieu sur cette branche&nbsp;? Ce qui manque
        ici, c'est le fait que les révisions 390, 381 et 357
        résultaient en fait de fusions en provenance du tronc. Si
        vous regardez plus en détail l'historique d'une de ces
        révisions, vous ne verrez nulle part les multiples ensembles
        de modifications du tronc qui ont été reportés sur
        la branche&nbsp;:</para>

      <screen>
$ svn log -v -r 390
------------------------------------------------------------------------
r390 | utilisateur | 2002-11-22 11:01:57 -0600 (ven. 22 nov. 2002) | 1 ligne
Chemins modifiés :
   M /branches/ma-branche-calc/bouton.c
   M /branches/ma-branche-calc/LISEZMOI

Fusion finale des modifications du tronc dans ma-branche-calc.
</screen>

      <para>Il se trouve que nous savons que cette fusion vers la
        branche n'était qu'une fusion de modifications du tronc.
        Comment pouvons-nous également voir ces modifications du
        tronc&nbsp;? La réponse est d'utiliser l'option
        <option>--use-merge-history</option> (<option>-g</option>).
        Cette option donne le détail des modifications
        <quote>filles</quote> qui faisaient partie de la fusion.</para>

      <screen>
$ svn log -v -r 390 -g
------------------------------------------------------------------------
r390 | utilisateur | 2002-11-22 11:01:57 -0600 (ven. 22 nov. 2002) | 1 ligne
Chemins modifiés :
   M /branches/ma-branche-calc/bouton.c
   M /branches/ma-branche-calc/LISEZMOI

Fusion finale des modifications du tronc dans ma-branche-calc.
------------------------------------------------------------------------
r383 | sally | 2002-11-21 03:19:00 -0600 (jeu. 21 nov. 2002) | 2 lignes
Chemins modifiés :
   M /branches/ma-branche-calc/bouton.c
Fusion via: r390

Corrige l'erreur d'inversion graphique sur le bouton.
------------------------------------------------------------------------
r382 | sally | 2002-11-20 16:57:06 -0600 (mer. 20 nov. 2002) | 2 lignes
Chemins modifiés :
   M /branches/ma-branche-calc/LISEZMOI
Fusion via: r390

Documente mon dernier correctif dans LISEZMOI.
</screen>

      <para>En forçant l'opération <command>svn log</command> à
        utiliser l'historique des fusions, nous obtenons non seulement
        la révision que nous avions demandé (r390), mais aussi les deux
        révisions qui l'accompagnaient &mdash; deux modifications du
        tronc faites par Sally. C'est une image bien plus complète
        de l'historique&nbsp;!</para>

      <para>La commande <command>svn blame</command> accepte également
        l'option <option>--use-merge-history</option>
        (<option>-g</option>). Si cette option est omise, quelqu'un
        qui regarderait un relevé annoté ligne par ligne pour
        <filename>bouton.c</filename> risquerait d'avoir l'impression
        erronée que vous êtes responsable des lignes qui ont corrigé
        une certaine erreur&nbsp;:</para>

      <screen>
$ svn blame bouton.c
&hellip;
   390    utilisateur  retval = inverse_func(button, path);
   390    utilisateur  return retval;
   390    utilisateur  }
&hellip;
</screen>

      <para>Et bien qu'il soit vrai que vous avez propagé ces trois
        lignes lors de la révision 390, deux d'entre elles ont en fait
        été écrites par Sally auparavant, en révision 383&nbsp;:</para>

      <screen>
$ svn blame bouton.c -g
&hellip;
G    383    sally        retval = inverse_func(button, path);
G    383    sally        return retval;
     390    utilisateur  }
&hellip;
</screen>

      <para>À présent, nous savons qui doit
        <emphasis>réellement</emphasis> être tenu responsable pour
        ces deux lignes de code&nbsp;!</para>

    </sect2>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
    <sect2 id="svn.branchmerge.advanced.ancestry">
      <title>Prise en compte ou non de l'ascendance</title>

      <para>Quand vous discutez avec un développeur Subversion, il
        est très possible qu'il fasse référence au terme
        d'<firstterm>ascendance</firstterm>. Ce mot est utilisé pour
        décrire la relation entre deux objets dans un dépôt&nbsp;:
        s'ils sont liés l'un à l'autre, un des objets est alors
        qualifié d'ancêtre de l'autre.</para>

      <para>Par exemple, supposons que vous propagiez la révision 100
        qui contient une modification d'un fichier
        <filename>truc.c</filename>. Dès lors,
        <filename>truc.c@99</filename> est un <quote>ancêtre</quote>
        de <filename>truc.c@100</filename>. En revanche, supposons
        que vous propagiez la suppression de
        <filename>truc.c</filename> en révision 101 et ensuite
        l'ajout d'un nouveau fichier du même nom en révision 102.
        Dans ce cas, <filename>truc.c@99</filename> et
        <filename>truc.c@102</filename> pourraient sembler
        apparentés (ils ont le même chemin), mais en fait ce sont
        des objets complètement différents au sein du dépôt. Ils ne
        partagent aucun historique ou <quote>ascendance</quote>.</para>

      <para>Nous abordons ce point pour mettre en évidence une
        différence importante entre <command>svn diff</command> et
        <command>svn merge</command>. La première commande ignore
        toute ascendance, tandis que la seconde y est particulièrement
        sensible. Par exemple, si vous demandez à
        <command>svn diff</command> de comparer les révisions 99 et
        102 de <filename>truc.c</filename>, vous obtenez des
        différences basées sur les lignes&nbsp;; la commande
        <command>svn diff</command> compare deux chemins à l'aveugle.
        Mais si vous demandez à <command>svn merge</command> de
        comparer les deux mêmes objets, il remarque qu'ils ne sont
        pas liés et essaie d'abord de supprimer l'ancien fichier,
        puis d'ajouter le nouveau fichier&nbsp;; le résultat indique
        une suppression puis un ajout&nbsp;:</para>

      <screen>
D    truc.c
A    truc.c
</screen>

      <para>La plupart des fusions impliquent de comparer des
        arborescences qui ont une relation d'ascendance de l'une
        à l'autre&nbsp;; c'est pourquoi <command>svn merge</command>
        a ce comportement par défaut. Cependant, à l'occasion, vous
        pourriez vouloir que la commande <command>svn merge</command>
        compare deux arborescences sans relation d'ascendance entre
        elles. Par exemple, vous avez peut-être importé deux
        arborescences de code source représentant des publications
        différentes de deux fournisseurs d'un projet logiciel
        (voir <xref linkend="svn.advanced.vendorbr"/>). Si vous
        demandez à <command>svn merge</command> de comparer les deux
        arborescences, vous verrez la première arborescence
        complètement supprimée, puis l'ajout de la seconde
        arborescence toute entière&nbsp;! Dans ce genre de situations,
        vous attendez de <command>svn merge</command> qu'il effectue
        une comparaison basée sur les chemins uniquement, en ignorant
        toute relation entre les fichiers et les dossiers. Ajoutez
        l'option <option>--ignore-ancestry</option> à votre commande
        <command>svn merge</command> et elle se comportera comme
        <command>svn diff</command> (et inversement, l'option
        <option>--notice-ancestry</option> fera se comporter
        <command>svn diff</command> comme la commande
        <command>svn merge</command>).</para>

    </sect2>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
    <sect2 id="svn.branchmerge.advanced.moves">
      <title>Fusions, copies et renommages</title>

      <para>Il arrive souvent qu'on veuille réorganiser le code source,
        en particulier dans les projets logiciels en Java. Les fichiers
        et les répertoires sont déplacés et renommés, causant souvent
        de grandes perturbations pour tous ceux qui travaillent sur le
        projet. Ceci semble être le cas idéal où utiliser une branche,
        n'est-ce pas&nbsp;? Créer une branche, réorganiser les choses,
        et ensuite fusionner la branche vers le tronc, non&nbsp;?</para>

      <para>Hélas, ce scénario ne fonctionne pas si bien pour le
        moment et est même considéré comme l'une des faiblesses de
        Subversion. Le problème est que la commande
        <command>svn update</command> de Subversion n'est pas aussi
        robuste qu'elle le devrait, en particulier en ce qui
        concerne les opérations de copies et de déplacements.</para>

      <para>Quand vous utilisez <command>svn copy</command> pour
        dupliquer un fichier, le dépôt se souvient d'où venait le
        nouveau fichier, mais il ne transmet pas cette information
        au client qui lance <command>svn update</command> ou
        <command>svn merge</command>. Au lieu de dire au client
        <quote>Copie ce fichier que tu as déjà vers ce nouvel
        emplacement</quote>, il envoie un fichier entièrement nouveau.
        Ceci peut engendrer des problèmes, en particulier parce que le
        fonctionnement est le même pour les fichiers renommés. Un fait
        peu connu à propos de Subversion est qu'il lui manque de
        <quote>vrais renommages</quote> - la commande
        <command>svn move</command> n'est rien de plus que
        l'agrégation de <command>svn copy</command> et
        <command>svn delete</command>.</para>

      <para>Par exemple, supposons que pendant que vous travaillez
        sur votre branche privée, vous renommez
        <filename>entier.c</filename> en <filename>tout.c</filename>.
        Ce faisant, vous avez en fait créé un nouveau fichier dans
        votre branche, qui est une copie du fichier original, et
        vous avez supprimé le fichier original. Pendant ce temps, dans
        le tronc, Sally a propagé des améliorations
        d'<filename>entier.c</filename>. C'est alors que vous décidez
        de fusionner votre branche vers le tronc&nbsp;:</para>

      <screen>
$ cd calc/trunk

$ svn merge --reintegrate http://svn.exemple.com/depot/calc/branches/ma-branche-calc
--- Fusion des différences des URLs du dépôt vers '.' :
D   entier.c
A   tout.c
U   .
</screen>

      <para>Ceci n'a pas l'air si mal à première vue, mais ce n'est
        probablement pas ce à quoi Sally ou vous vous attendiez.
        L'opération de fusion a supprimé la version la plus récente
        du fichier <filename>entier.c</filename> (celle qui contenait
        les dernières modifications de Sally) et a ajouté machinalement
        votre nouveau fichier <filename>tout.c</filename>, qui est une
        copie de l'ancien fichier <filename>entier.c</filename>. Le
        résultat final est que la fusion de votre
        <quote>renommage</quote> a supprimé de la dernière révision
        les modifications récentes de Sally&nbsp;!</para>

      <para>Il ne s'agit pas d'une vraie perte de données. Les
        modifications de Sally font toujours partie de l'historique
        du dépôt, mais le déroulement exact des événements n'est
        peut-être pas immédiatement évident. La morale de l'histoire
        est que jusqu'à ce que Subversion ne s'améliore, vous devrez
        faire très attention aux fusions de copies et de renommages
        d'une branche à une autre.</para>

    </sect2>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
    <sect2 id="svn.branchmerge.advanced.pre1.5clients">
      <title>Blocage des clients qui ne prennent pas en compte
        les fusions</title>

      <para>Si vous venez de mettre à niveau votre serveur Subversion
        à la version 1.5 ou plus, il existe un risque significatif que
        les clients Subversion pré-1.5 sèment la pagaille dans votre
        suivi automatique des fusions. Pourquoi&nbsp;? Quand un client
        Subversion pré-1.5 exécute <command>svn merge</command>, il ne
        modifie pas du tout la valeur de la propriété
        <literal>svn:mergeinfo</literal>. La propagation qui s'ensuit,
        bien qu'elle soit le résultat d'une fusion, n'envoie donc
        aucune indication au dépôt au sujet des modifications
        dupliquées &mdash; ces informations sont perdues. Par la
        suite, lorsque des clients <quote>qui prennent en compte les
        fusions</quote> tentent d'effectuer une fusion automatique,
        ils rencontreront probablement toutes sortes de conflits
        résultant des fusions répétées.</para>

      <para>Si votre équipe et vous dépendez des fonctionnalités de
        suivi des fusions de Subversion, vous voudrez peut-être
        configurer votre dépôt pour qu'il empêche les anciens clients
        de propager des modifications. La méthode la plus simple est
        d'examiner le paramètre <quote>capabilities</quote> dans la
        procédure automatique de début de propagation. Si le client
        indique être capable de gérer les <literal>mergeinfo</literal>,
        la procédure automatique peut l'autoriser à commencer la
        propagation. Si le client n'indique pas en être capable, la
        procédure automatique doit lui refuser la propagation. Nous
        en apprendrons plus sur les procédures automatiques dans le
        chapitre suivant&nbsp;; voir
        <xref linkend="svn.reposadmin.create.hooks"/> et
        <xref linkend="svn.ref.reposhooks.start-commit"/>
        pour les détails.</para>

    </sect2>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
    <sect2 id="svn.branchmerge.advanced.finalword">
      <title>Recommandations finales sur le suivi des fusions</title>

      <para>En fin de compte, la fonctionnalité de suivi des fusions
        de Subversion possède une mécanique interne extrêmement
        complexe et la propriété <literal>svn:mergeinfo</literal>
        est la seule lorgnette dont l'utilisateur dispose pour
        observer cette mécanique. Parce que cette fonctionnalité est
        relativement nouvelle, un certain nombre de cas litigieux et
        de comportements potentiellement inattendus risquent d'être
        rencontrés.</para>

      <para>Par exemple, <literal>mergeinfo</literal> sera parfois
        générée lors d'une simple commande <command>svn copy</command>
        ou <command>svn move</command>. Parfois
        <literal>mergeinfo</literal> apparaîtra sur des fichiers dont
        vous n'auriez pas imaginé qu'ils soient touchés par une
        opération. Parfois <literal>mergeinfo</literal> ne sera pas du
        tout générée, contrairement à ce que vous attendiez. De plus,
        la gestion de la métadonnée <literal>mergeinfo</literal> a tout
        un ensemble de taxonomies et de comportements qui lui sont
        associés, tels que des <literal>mergeinfo</literal>
        <quote>explicites</quote> par opposition à
        <quote>implicites</quote>, des révisions
        <quote>opérationnelles</quote> par opposition à
        <quote>non-opérationnelles</quote>, des mécanismes spécifiques
        d'<quote>élision</quote> de <literal>mergeinfo</literal> et
        même d'<quote>héritage</quote> de répertoires parents à
        sous-répertoires.</para>

      <para>Nous avons choisi de ne pas couvrir en détail ces sujets
        dans ce livre pour plusieurs raisons. Premièrement,
        l'utilisateur moyen serait totalement submergé par le niveau
        de détail disponible. Deuxièmement, au fur et à mesure que
        Subversion s'améliore, nous estimons que l'utilisateur moyen
        <emphasis>ne devrait pas</emphasis> avoir à comprendre ces
        concepts&nbsp;; en tant que détails d'implémentation agaçants,
        ils finiront par disparaître à l'arrière-plan. Malgré tout ce
        qui vient d'être dit, si vous appréciez ce genre de choses,
        vous en trouverez une formidable vue d'ensemble dans un article
        posté sur le site internet de Collabnet&nbsp;: <ulink
        url="http://www.collab.net/community/subversion/articles/merge-info.html"
        />.</para>

      <para>Pour le moment, si vous voulez rester à l'écart des bogues
        et autres comportements inattendus des fusions automatiques,
        l'article de Collabnet recommande que vous vous en teniez
        simplement aux bonnes pratiques suivantes&nbsp;:</para>

      <itemizedlist>
        <listitem>
          <para>Pour les branches fonctionnelles à courte durée de vie,
            suivez la procédure simple décrite dans <xref
            linkend="svn.branchmerge.basicmerging"/>.</para>
        </listitem>
        <listitem>
          <para>Pour les branches de publication à longue durée de vie
            (comme décrites dans <xref
            linkend="svn.branchmerge.commonpatterns"/>), ne pratiquez
            de fusions que sur la racine de la branche, pas sur des
            sous-répertoires.</para>
        </listitem>
        <listitem>
          <para>Ne pratiquez jamais de fusion vers des copies de
            travail contenant un mélange de numéros de révisions de
            travail, ou ayant des sous-répertoires
            <quote>déportés</quote> (comme décrit par la suite dans
            <xref linkend="svn.branchmerge.switchwc"/>). La cible
            d'une fusion doit être une copie de travail qui représente
            un emplacement <emphasis>unique</emphasis> à un moment
            <emphasis>unique</emphasis> dans le dépôt.</para>
        </listitem>
        <listitem>
          <para>Ne modifiez jamais la propriété
            <literal>svn:mergeinfo</literal> directement&nbsp;;
            utilisez <command>svn merge</command> avec l'option
            <option>--record-only</option> pour appliquer une
            modification désirée à cette métadonnée (comme expliqué
            dans <xref
            linkend="svn.branchmerge.advanced.blockchanges"/>).</para>
        </listitem>
        <listitem>
          <para>Assurez-vous de toujours avoir l'accès complet en
            lecture à toutes vos sources de fusion, et vérifiez que
            votre copie de travail cible n'a pas de dossiers
            clairsemés.</para>
        </listitem>
      </itemizedlist>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.switchwc">
    <title>Parcours des branches</title>

    <para>La commande <command>svn switch</command> transforme une
      copie de travail existante de telle sorte qu'elle pointe vers
      une branche différente. Bien que la connaissance de cette
      commande ne soit pas absolument nécessaire pour travailler avec
      des branches, elle fournit un raccourci utile. Dans notre
      exemple précédent, après avoir créé votre branche privée, vous
      avez extrait une toute nouvelle copie de travail du nouveau
      répertoire du dépôt. À la place, vous pouvez simplement
      demander à Subversion de modifier votre copie de travail de
      <filename>/calc/trunk</filename> pour qu'elle pointe vers
      l'emplacement de la nouvelle branche&nbsp;:</para>

    <screen>
$ cd calc

$ svn info | grep URL
URL: http://svn.exemple.com/depot/calc/trunk

$ svn switch http://svn.exemple.com/depot/calc/branches/ma-branche-calc
U   entier.c
U   bouton.c
U   Makefile
Actualisé à la révision 341.

$ svn info | grep URL
URL: http://svn.exemple.com/depot/calc/branches/ma-branche-calc
</screen>

    <para><quote>Faire pointer</quote> (ou <quote>déporter</quote>)
      une copie de travail qui n'a pas de modifications locales vers
      une branche différente a pour résultat que la copie de travail
      a exactement le même aspect que si vous aviez effectué une
      extraction brute du répertoire. C'est en général plus efficace
      d'utiliser cette commande, car les différences entre les
      branches sont souvent minimes. Le serveur n'envoie que le
      minimum de modifications nécessaire pour faire pointer votre
      copie de travail vers le répertoire de la branche.</para>

    <para>La commande <command>svn switch</command> accepte également
      l'option <option>--revision</option> (<option>-r</option>),
      pour que que vous ne soyez pas obligé de faire pointer
      votre copie de travail vers la révision
      <literal>HEAD</literal> de la branche.</para>

    <para>Bien sûr, la plupart des projets sont plus compliqués que
      notre exemple <filename>calc</filename> et contiennent de
      multiples sous-dossiers. Les utilisateurs de Subversion suivent
      souvent un algorithme précis quand ils utilisent
      des branches&nbsp;:</para>

      <orderedlist>
        <listitem>
          <para>Copier le <quote>tronc</quote> entier du projet vers
            une nouvelle branche</para>
        </listitem>
        <listitem>
          <para>Ne déporter qu'<emphasis>une partie</emphasis> de la
            copie de travail du tronc pour qu'elle pointe
            sur la branche.</para>
        </listitem>
      </orderedlist>

    <para>En d'autres termes, si un utilisateur sait que le travail
      sur la branche ne doit avoir lieu que sur un sous-dossier donné,
      il utilise <command>svn switch</command> pour ne faire pointer
      que ce sous-dossier vers la branche (ou parfois des utilisateurs
      ne vont faire pointer qu'un unique fichier de travail vers la
      branche&nbsp;!). De cette façon, l'utilisateur peut continuer à
      recevoir les mises à jour normales du <quote>tronc</quote> vers
      la plus grande partie de sa copie de travail, mais les portions
      déportées ne seront pas touchées (à moins que quelqu'un ne
      propage une modification à sa branche). Cette fonctionnalité
      ajoute une dimension complètement nouvelle au concept de
      <quote>copie de travail mixte</quote>&nbsp;: les copies de
      travail peuvent non seulement contenir un mélange de révisions
      de travail, mais elles peuvent également contenir un mélange
      d'emplacements du dépôt.</para>

    <para>Si votre copie de travail contient un certain nombre de
      sous-arborescences pointant vers des emplacements variés du
      dépôt, elle continue à fonctionner normalement. Quand vous la
      mettez à jour, vous recevez comme il se doit les correctifs
      pour chaque sous-arborescence. Quand vous effectuez une
      propagation, vos modifications locales s'appliquent toujours
      au dépôt en tant qu'une unique modification atomique.</para>

    <para>Remarquez que bien qu'il soit possible pour votre copie de
      travail de pointer vers une variété d'emplacements du dépôt,
      ces emplacements doivent tous faire partie du
      <emphasis>même</emphasis> dépôt. Les dépôts Subversion ne sont
      pas encore capables de communiquer entre eux&nbsp;; cette
      fonctionnalité est prévue à l'avenir
      <footnote>
        <para>Vous <emphasis>pouvez</emphasis> cependant utiliser
          <command>svn switch</command> avec l'option
          <option>--relocate</option> si l'URL de votre serveur
          change et si vous ne voulez pas abandonner votre copie de
          travail existante. Reportez-vous à
          <xref linkend="svn.ref.svn.c.switch"/> pour des détails
          et des exemples.</para>
      </footnote>.
    </para>

    <sidebar>
      <title>Déports et mises à jour</title>

      <para>Avez-vous remarqué que les sorties des commandes
        <command>svn switch</command> et <command>svn update</command>
        se ressemblent&nbsp;? La commande <command>svn switch</command> est
        en fait une généralisation de la commande
        <command>svn update</command>.</para>

      <para>Quand vous lancez <command>svn update</command>, vous
        demandez au dépôt de comparer deux arborescences. C'est ce
        qu'il fait, puis il renvoie au client le détail des
        différences entre les deux. La seule différence entre
        <command>svn switch</command> et <command>svn update</command>
        est que cette dernière commande compare toujours deux chemins
        identiques du dépôt.</para>

      <para>C'est-à-dire que si votre copie de travail pointe vers
        <filename>/calc/trunk</filename>, <command>svn update</command>
        compare automatiquement votre copie de travail de
        <filename>/calc/trunk</filename> au
        <filename>/calc/trunk</filename> de la révision
        <literal>HEAD</literal>. Si vous faites pointer votre copie de
        travail vers une branche, <command>svn switch</command>
        comparera votre copie de travail de
        <filename>/calc/trunk</filename> au répertoire d'une
        <emphasis>autre</emphasis> branche de la révision
        <literal>HEAD</literal>.</para>

      <para>En d'autres termes, <command>svn update</command> déplace
        votre copie de travail à travers le temps.
        <command>svn switch</command> déplace votre copie de travail
        à travers le temps <emphasis>et</emphasis> l'espace.</para>
    </sidebar>

    <para>Parce que <command>svn switch</command> est essentiellement
      une variante de <command>svn update</command>, elle se comporte
      de la même manière&nbsp;; toute modification locale présente
      dans votre copie de travail est préservée lorsque de nouvelles
      données arrivent en provenance du dépôt.</para>

      <tip>
        <para>Vous-êtes vous déjà trouvés dans une situation où vous
          effectuez des modifications complexes (dans votre copie de
          travail de <filename>/trunk</filename>) et réalisez
          soudainement&nbsp;:
          <quote>Mais, ces modifications ne devraient-elles pas être
          dans leur propre branche&nbsp;?</quote>
          Une excellente technique pour accomplir ceci peut être
          résumée en deux étapes&nbsp;:</para>

          <screen>
$ svn copy http://svn.exemple.com/depot/calc/trunk \
           http://svn.exemple.com/depot/calc/branches/nouvelle-branche \
      -m "Création de la branche 'nouvelle-branche'."
Révision 353 propagée.
$ svn switch http://svn.exemple.com/depot/calc/branches/nouvelle-branche
À la révision 353.
</screen>

        <para>La commande <command>svn switch</command>, à l'instar
          de <command>svn update</command>, préserve vos modifications
          locales. Désormais, votre copie de travail pointe vers la
          branche nouvellement créée et la prochaine fois que vous
          lancerez <command>svn commit</command> vos modifications
          y seront envoyées.</para></tip>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.tags">
    <title>Étiquettes</title>

    <para>Un autre concept courant en gestion de versions est
      l'<firstterm>étiquette</firstterm> (parfois appelée
      <foreignphrase>tag</foreignphrase>).
      Une étiquette n'est qu'un <quote>instantané</quote> d'un
      projet à un moment donné. Dans Subversion, cette idée semble
      être présente partout. Chaque révision du dépôt est exactement
      cela&nbsp;: un instantané du système de fichiers pris après
      chaque propagation.</para>

    <para>Cependant les gens veulent souvent donner des noms plus
      conviviaux aux étiquettes, tel que
      <literal>version-1.0</literal>. Et ils veulent prendre des
      instantanés de sous-sections plus restreintes du système de
      fichiers. Après tout, ce n'est pas si facile de se rappeler
      que la version 1.0 d'un logiciel donné correspond à un
      sous-dossier particulier de la révision 4822.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.tags.mksimple">
      <title>Création d'une étiquette simple</title>

      <para>Une fois encore, <command>svn copy</command> vient à la
        rescousse. Si vous voulez créer un instantané de
        <filename>/calc/trunk</filename> identique à ce qu'il est
        dans la révision <literal>HEAD</literal>, faites-en
        une copie&nbsp;:</para>

      <screen>
$ svn copy http://svn.exemple.com/depot/calc/trunk \
           http://svn.exemple.com/depot/calc/tags/version-1.0 \
      -m "Étiquetage de la version 1.0 du projet 'calc'."

Révision 902 propagée.
</screen>

      <para>Cet exemple présuppose qu'un répertoire
        <filename>/calc/tags</filename> existe déjà (s'il n'existe
        pas, vous pouvez le créer en utilisant
        <command>svn mkdir</command>). Une fois la copie terminée,
        le nouveau dossier <filename>version-1.0</filename> sera pour
        toujours un instantané du dossier <filename>/trunk</filename>
        tel qu'il était en révision <literal>HEAD</literal> au moment
        où vous avez effectué la copie. Bien sûr, vous voudriez
        peut-être être plus précis quant à quelle révision vous copiez,
        au cas où quelqu'un d'autre aurait propagé des modifications
        au projet pendant que vous regardiez ailleurs. Donc si vous
        savez que la révision 901 de <filename>/calc/trunk</filename>
        est exactement l'instantané que vous voulez, vous pouvez le
        spécifier en passant <option>-r 901</option> à la commande
        <command>svn copy</command>.</para>

      <para>Mais attendez un moment&nbsp;: cette procédure de création
        d'étiquette, n'est-ce pas la même procédure que nous avons
        utilisé pour créer une branche&nbsp;? En fait, oui. Dans
        Subversion, il n'y pas de différence entre une étiquette et
        une branche. Toutes deux ne sont que des répertoires
        ordinaires qui sont créés par copie. Comme pour les branches,
        la seule raison qui fasse qu'un répertoire copié soit une
        <quote>étiquette</quote> est que les
        <emphasis>humains</emphasis> ont décidé de le traiter
        de cette façon&nbsp;: aussi longtemps que personne
        ne propage de modification à ce répertoire, il reste un
        instantané. Si les gens commencent à y propager des choses,
        il devient une branche.</para>

      <para>Si vous administrez un dépôt, il y a deux approches
        possibles pour gérer les étiquettes. La première approche
        est une politique de <quote>non-intervention</quote>&nbsp;:
        en tant que convention définie pour le projet, vous décidez
        où vos étiquettes sont placées et vous vous assurez que tous
        les utilisateurs savent comment traiter les répertoires qu'ils
        copient (c'est-à-dire que vous vous assurez qu'ils savent
        qu'ils ne doivent rien y propager). La seconde approche est
        plus paranoïaque&nbsp;: vous pouvez utiliser un des contrôles
        d'accès fournis avec Subversion pour empêcher que quiconque ne
        puisse faire autre chose dans la zone des étiquettes que d'y
        créer de nouvelles copies (voir le <xref
        linkend="svn.serverconfig"/>). L'approche paranoïaque n'est
        cependant pas nécessaire, en général. Si un utilisateur propage
        accidentellement une modification à un répertoire d'étiquettes,
        vous pouvez simplement revenir en arrière sur cette modification
        comme expliqué dans le paragraphe précédent. C'est ça la gestion
        de versions, après tout&nbsp;!</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.tags.mkcomplex">
      <title>Création d'une étiquette complexe</title>

      <para>Parfois vous voudrez peut-être que votre
        <quote>instantané</quote> soit plus compliqué qu'un simple
        répertoire à une unique révision donnée.</para>

      <para>Par exemple, imaginons que votre projet est bien plus
        vaste que notre exemple <filename>calc</filename>&nbsp;:
        supposons qu'il contient un bon nombre de sous-répertoires
        et bien plus de fichiers encore. Au cours de votre travail,
        vous pouvez très bien décider que vous avez besoin de créer
        une copie de travail destinée à des fonctionnalités
        particulières et à des corrections de bogues. Pour cela
        vous pouvez antidater de manière sélective des fichiers
        ou dossiers à des révisions données (en utilisant
        généreusement <command>svn update</command> avec l'option
        <option>-r</option>), déporter des fichiers et des
        dossiers vers des branches particulières (au moyen de
        <command>svn switch</command>) ou même effectuer
        manuellement un tas de modifications locales. Quand vous en
        avez terminé, votre copie de travail est un vrai bazar,
        fait d'emplacements du dépôt à des révisions différentes.
        Mais après l'avoir testée, vous êtes alors certain que c'est
        l'exacte combinaison de données que vous vouliez
        étiqueter.</para>

      <para>C'est alors le moment de prendre un cliché. Copier une URL
        vers une autre ne fonctionnera pas cette fois. Dans le cas
        présent, vous voulez prendre un cliché de l'arrangement exact
        de votre copie de travail et le placer dans le dépôt. Par
        chance, <command>svn copy</command> possède en fait quatre
        usages différents (au sujet desquels vous pouvez obtenir des
        informations au <xref linkend="svn.ref"/>), dont la
        possibilité de copier une arborescence de travail vers le
        dépôt&nbsp;:</para>

      <screen>
$ ls
ma-copie-de-travail/

$ svn copy ma-copie-de-travail \
           http://svn.exemple.com/depot/calc/tags/mon-etiquette \
           -m "Étiquette l'état de ma copie de travail existante."

Révision 940 propagée.
</screen>

      <para>Désormais il y a un nouveau répertoire dans le dépôt,
        <filename>/calc/tags/mon-etiquette</filename>, qui est un
        instantané exact de votre copie de travail&nbsp;: révisions
        mixtes, URL, modifications locales et tout
        et tout&hellip;</para>

      <para>D'autres utilisateurs ont trouvé des usages intéressants
        pour cette fonctionnalité. Il y a parfois des situations où
        votre copie de travail contient un paquet de modifications
        locales que vous aimeriez montrer à un collaborateur. Au lieu
        de lancer <command>svn diff</command> et d'envoyer un fichier
        patch (qui ne listera pas les modifications de répertoires,
        de liens symboliques ou de propriétés), vous pouvez utiliser
        <command>svn copy</command> pour <quote>envoyer</quote> votre
        copie de travail vers une zone privée du dépôt. Votre
        collaborateur peut ensuite soit extraire une copie carbone
        de votre copie de travail, soit utiliser
        <command>svn merge</command> pour recevoir exactement vos
        modifications.</para>

      <para>Bien que ce soit une jolie méthode pour mettre à
        disposition un instantané rapide de votre copie de travail,
        remarquez que <emphasis>ce n'est pas</emphasis> une bonne
        manière de créer une branche initialement. La création de
        branche devrait être un évènement en soi, tandis que cette
        méthode combine la création d'une branche avec des
        modifications supplémentaires apportées aux fichiers, le tout
        au sein d'une seule révision. Ceci rend très difficile
        (à terme) d'identifier un unique numéro de révision en tant
        que point de création de la branche.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.maint">
    <title>Maintenance des branches</title>

    <para>À ce stade, vous vous êtes certainement rendu compte que
      Subversion est extrêmement flexible. Parce qu'il implémente les
      branches et les étiquettes avec le même mécanisme sous-jacent
      (des copies de répertoires) et parce que les branches et les
      étiquettes apparaissent au sein de l'espace standard du système
      de fichiers, beaucoup de gens trouvent Subversion intimidant. Il
      est presque <emphasis>trop</emphasis> flexible. Dans ce paragraphe,
      nous proposons des suggestions pour organiser et gérer vos données
      au fil du temps.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.maint.layout">
      <title>Agencement du dépôt</title>

      <para>Il existe des méthodes standard recommandées pour structurer
        un dépôt. La plupart des gens créent un répertoire
        <filename>trunk</filename> pour la
        <quote>ligne de développement principale</quote> (le tronc),
        un répertoire <filename>branches</filename> qui contiendra
        les copies de branches et un répertoire
        <filename>tags</filename> qui contiendra les copies
        étiquetées. Si un dépôt ne comprend qu'un seul projet, les
        gens créent souvent les dossiers suivants
        à la racine&nbsp;:</para>

      <screen>
/trunk
/branches
/tags
</screen>

      <para>Si un dépôt contient plusieurs projets, les
        administrateurs indexent généralement la structure du dépôt
        par projet (voir <xref
        linkend="svn.reposadmin.projects.chooselayout"/> pour en
        savoir plus sur les <quote>dossiers racine d'un
        projet</quote>)&nbsp;:</para>

      <screen>
/paint/trunk
/paint/branches
/paint/tags
/calc/trunk
/calc/branches
/calc/tags
</screen>

      <para>Bien sûr, vous restez libre d'ignorer ces agencements
        courants. Vous pouvez créer toutes sortes de variantes, selon
        ce qui fonctionne le mieux pour vous ou pour votre équipe.
        Souvenez-vous que quel que soit votre choix, ce n'est pas un
        engagement définitif. Vous pouvez réorganiser votre dépôt à
        tout moment. Parce que les branches et les étiquettes sont des
        répertoires ordinaires, la commande <command>svn move</command>
        peut les déplacer ou les renommer selon vos désirs. Passer
        d'un agencement à un autre consiste juste à lancer une série
        d'opérations de déplacement côté serveur&nbsp;; si vous n'aimez
        pas la façon dont les choses sont organisées dans le dépôt,
        modifiez juste leur agencement.</para>

      <para>Souvenez-vous néanmoins que bien qu'il soit facile de
        déplacer des dossiers, vous devez aussi rester attentif à
        vos utilisateurs. Vos modifications sont susceptibles de
        déboussoler ceux qui ont des copies de travail existantes.
        Si un utilisateur a une copie de travail d'un répertoire
        donné du dépôt, votre opération <command>svn move</command>
        risque de supprimer ce chemin de la révision la plus récente.
        Lorsque par la suite l'utilisateur lancera
        <command>svn update</command>, il se verra annoncer que sa
        copie de travail représente un chemin qui n'existe plus et
        sera contraint d'effectuer un <command>svn switch</command>
        vers le nouvel emplacement.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.maint.lifetime">
      <title>Durée de vie des données</title>

      <para>Une autre fonctionnalité intéressante liée aux principes
        de fonctionnement de Subversion est que les branches et les
        étiquettes peuvent avoir des durées de vie limitées, tout
        comme n'importe quel autre élément suivi en versions. Par
        exemple, supposons que vous avez enfin terminé votre travail
        sur votre branche personnelle du projet
        <filename>calc</filename>. Après avoir fusionné toutes vos
        modifications vers <filename>/calc/trunk</filename>, le
        répertoire contenant votre branche privée n'a plus de raison
        d'exister&nbsp;:</para>

      <screen>
$ svn delete http://svn.exemple.com/depot/calc/branches/ma-branche-calc \
             -m "Suppression d'une branche obsolète du projet calc."

Révision 375 propagée.
</screen>

      <para>Et maintenant votre branche a disparu. Bien sûr, elle n'a
        pas vraiment disparu&nbsp;: le répertoire est juste absent de
        la révision <literal>HEAD</literal>, ne gênant plus personne.
        Si vous utilisez <command>svn checkout</command>,
        <command>svn switch</command> ou <command>svn list</command>
        pour examiner une révision plus ancienne, vous pourrez toujours
        voir votre vieille branche.</para>

      <para>Si la navigation dans votre répertoire supprimé ne vous
        suffit pas, vous pouvez toujours le récupérer. Ressusciter
        des données est très facile dans Subversion. S'il y a un
        dossier (ou un fichier) supprimé que vous aimeriez faire
        réapparaître dans <literal>HEAD</literal>, utilisez simplement
        <command>svn copy</command> pour le copier depuis l'ancienne
        révision.</para>

      <screen>
$ svn copy http://svn.exemple.com/depot/calc/branches/ma-branche-calc@374 \
           http://svn.exemple.com/depot/calc/branches/ma-branche-calc \
           -m "Restaure ma-branche-calc."

Révision 376 propagée.
</screen>

      <para>Dans notre exemple, votre branche personnelle a eu une
        durée de vie relativement limitée&nbsp;: vous l'aviez
        peut-être créée pour corriger un bogue ou implémenter une
        nouvelle fonctionnalité. Quand votre tâche est finie, il en
        va de même pour la branche. Cependant, en développement
        logiciel, il est aussi courant d'avoir deux branches
        <quote>principales</quote> côte à côte pour de très longues
        périodes. Par exemple, supposons que le moment est venu de
        publier une version stable du projet <filename>calc</filename>
        pour le public. Vous savez qu'il faudra quelques mois
        pour éliminer les bogues du logiciel. Vous ne voulez pas que
        les gens ajoutent de nouvelles fonctionnalités au projet,
        mais vous ne voulez pas non plus dire à tous les développeurs
        d'arrêter de programmer. Donc à la place, vous créez une
        branche <quote>stable</quote> du logiciel qui ne changera pas
        beaucoup&nbsp;:</para>

      <screen>
$ svn copy http://svn.exemple.com/depot/calc/trunk \
           http://svn.exemple.com/depot/calc/branches/stable-1.0 \
           -m "Création de la branche stable du projet calc."

Révision 377 propagée.
</screen>

      <para>Dès lors les développeurs sont libres de continuer à
        ajouter des fonctionnalités de pointe (ou expérimentales)
        à <filename>/calc/trunk</filename> et vous pouvez poser
        comme convention pour le projet que seules les corrections
        de bogues seront propagées dans
        <filename>/calc/branches/stable-1.0</filename>. C'est-à-dire
        qu'au fur et à mesure que les gens continueront de travailler
        sur le tronc, quelqu'un reportera de façon sélective les
        corrections de bogues vers la branche stable. Même après que
        la branche stable aura été publiée, vous continuerez
        probablement à maintenir la branche pendant longtemps,
        c'est-à-dire pour aussi longtemps que vous continuerez à
        fournir aux clients un support sur cette version. Nous
        évoquons ceci plus en détails dans le
        prochain paragraphe.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.commonpatterns">
    <title>Modèles courants de gestion des branches</title>

    <para>Il existe de nombreux usages pour la création et la fusion
      des branches&nbsp;; ce paragraphe décrit les plus courants.</para>

    <para>Le plus souvent, la gestion de versions est utilisée pour
      le développement de logiciels, voici donc un coup d'œil
      rapide à deux des modèles les plus courants de création et de
      fusion de branches utilisés par les équipes de programmeurs. Si
      vous ne vous servez pas de Subversion pour développer des
      logiciels, n'hésitez pas à sauter ce paragraphe. Si vous êtes
      un développeur de logiciels qui utilise la gestion de versions
      pour la première fois, soyez très attentifs, car ces modèles
      sont souvent considérés comme des bonnes pratiques par les
      développeurs plus expérimentés. Ces procédures ne sont pas
      spécifiques à Subversion&nbsp;; elles sont applicables à tout
      système de gestion de versions. Néanmoins, les voir explicitées
      en termes Subversion peut aider.</para>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
    <sect2 id="svn.branchmerge.commonpatterns.release">
      <title>Branches de publication</title>

      <para>En général un logiciel suit un cycle de vie classique,
        répétant les trois étapes suivantes en boucle&nbsp;: code,
        test, publication. Il y a deux problèmes avec ce processus.
        Premièrement, les développeurs doivent continuer à écrire de
        nouvelles fonctionnalités pendant que les équipes d'assurance
        qualité prennent le temps de tester des versions supposées
        stables du logiciel. Les nouveaux développements ne peuvent pas
        s'arrêter pendant que le logiciel est en cours de test.
        Deuxièmement, l'équipe doit presque toujours effectuer le
        support des versions anciennes et publiées du logiciel&nbsp;;
        si un bogue est découvert dans le code le plus récent, il
        existe probablement aussi dans les versions qui ont été
        publiées et les clients voudront obtenir le correctif pour
        ce bogue sans avoir à attendre la publication d'une nouvelle
        version majeure.</para>

      <para>C'est là où la gestion de versions peut s'avérer utile.
        La procédure standard ressemble à ceci&nbsp;:</para>

      <orderedlist>

        <listitem>
          <para><emphasis>Les développeurs propagent tout nouveau
            travail vers le tronc.</emphasis>

            Les modifications quotidiennes sont propagées vers
            <filename>/trunk</filename>&nbsp;: nouvelles
            fonctionnalités, corrections de bogues,&nbsp;etc.</para>
        </listitem>

        <listitem>
          <para><emphasis>Le tronc est copié vers une branche
          <quote>de publication</quote>.</emphasis>

            Lorsque l'équipe estime que le logiciel est prêt à être
            publié (disons en version 1.0),
            <filename>/trunk</filename> peut être copié vers
            <filename>/branches/1.0</filename>.</para>
        </listitem>

        <listitem>
          <para><emphasis>Les équipes continuent à travailler en
          parallèle.</emphasis>

            Une équipe commence à tester rigoureusement la branche
            de publication, pendant qu'une autre équipe continue avec
            les nouvelles tâches (disons pour la version 2.0) sur
            <filename>/trunk</filename>. Si des bogues sont découverts
            dans l'un ou l'autre des emplacements, les correctifs sont
            reportés de l'un à l'autre selon les besoins. Il arrive
            cependant un moment où même ce processus s'arrête. La
            branche est <quote>gelée</quote> pour les tous derniers
            tests juste avant publication.</para>
        </listitem>

        <listitem>
          <para><emphasis>La branche est étiquetée et
            publiée.</emphasis>

            Quand les tests sont terminés,
            <filename>/branches/1.0</filename> est copiée vers
            <filename>/tags/1.0.0</filename> en tant que cliché
            de référence. L'étiquette est exportée et livrée aux
            clients.</para>
        </listitem>

        <listitem>
          <para><emphasis>La branche est gérée au fil
          du temps.</emphasis>

            Pendant que le travail continue sur
            <filename>/trunk</filename> en vue de la version 2.0,
            les correctifs de bogues continuent à être reportés de
            <filename>/trunk</filename>
            à <filename>/branches/1.0</filename>. Lorsque
            suffisamment de correctifs se sont accumulés, les
            responsables peuvent décider de publier une version
            1.0.1&nbsp;: <filename>/branches/1.0</filename> est
            copiée vers <filename>/tags/1.0.1</filename> et cette
            étiquette est exportée et publiée.</para>
        </listitem>

      </orderedlist>

      <para>Ce processus entier se répète au fur et à mesure que le
        logiciel gagne en maturité&nbsp;: quand le travail pour la
        version 2.0 est terminé, une nouvelle branche de publication
        2.0 est créée, testée, étiquetée et finalement publiée. Au
        bout de quelques années, le dépôt finit par avoir un certain
        nombre de branches de publication en mode
        <quote>maintenance</quote> et un certain nombre
        d'étiquettes représentant les versions finales publiées.</para>

    </sect2>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
    <sect2 id="svn.branchmerge.commonpatterns.feature">
      <title>Branches fonctionnelles</title>

      <para>Une <firstterm>branche fonctionnelle</firstterm> est la
        sorte de branche qui est l'exemple dominant dans ce chapitre
        (celle sur laquelle vous travailliez pendant que Sally
        continuait à travailler sur <filename>/trunk</filename>).
        C'est une branche temporaire créée pour travailler sur un
        changement complexe sans interférer avec la stabilité de
        <filename>/trunk</filename>. À la différence des branches de
        publication (dont le support doit parfois être prolongé très
        longtemps), les branches fonctionnelles naissent, sont
        utilisées pendant un temps, sont fusionnées vers le tronc
        et sont finalement supprimées. Elles ont une utilité limitée
        dans le temps.</para>

      <para>Encore une fois, les stratégies varient énormément au
        sujet du moment approprié pour créer une branche
        fonctionnelle. Certains projets n'utilisent jamais de branche
        fonctionnelle&nbsp;: n'importe qui peut propager des
        modifications à <filename>/trunk</filename>. L'avantage de ce
        système est qu'il est simple&nbsp;: personne n'a besoin d'être
        formé aux branches ou aux fusions. L'inconvénient est que le
        code du tronc est souvent instable ou inutilisable. D'autres
        projets utilisent les branches à l'extrême&nbsp;:
        une modification n'est <emphasis>jamais</emphasis> propagée
        directement dans le tronc. Même les modifications les plus
        triviales sont faites au sein d'une branche à courte durée de
        vie, vérifiées attentivement, puis fusionnées vers le tronc.
        La branche est ensuite supprimée. Ce système garantit que le
        tronc restera exceptionnellement stable et utilisable à tout
        moment, mais aux dépens des coûts de gestion liés à cette
        procédure très lourde.</para>

      <para>La plupart des projets choisissent une approche à mi-chemin
        entre les deux. Ils insistent généralement pour qu'à tout
        moment <filename>/trunk</filename> puisse être compilé et
        passe avec succès les tests de régression. Une branche
        fonctionnelle n'est nécessaire que quand une modification
        nécessite un grand nombre de propagations susceptibles de
        déstabiliser le tronc. Une bonne méthode empirique est de se
        poser la question suivante&nbsp;: si le développeur
        travaillait pendant plusieurs jours en isolation et ensuite
        propageait cette grosse modification en une seule fois
        (afin que <filename>/trunk</filename> ne soit jamais
        déstabilisé), est-ce que ce serait une modification trop
        grosse à vérifier&nbsp;? Si la réponse à cette question est
        <quote>oui</quote>, alors la modification devrait être
        développée sur une branche fonctionnelle. Au fur et à mesure
        que le développeur propage ses modifications incrémentales
        dans la branche, elles peuvent facilement être vérifiées par
        ses pairs.</para>

      <para>Finalement, il reste la question de savoir quelle est la
        meilleure méthode pour garder une branche synchronisée avec le
        tronc au fur et à mesure que le travail avance. Comme nous
        l'avons mentionné précédemment, il est très risqué de
        travailler sur une branche pendant des semaines ou
        des mois&nbsp;; le tronc continuera peut-être à recevoir des
        modifications, au point que les deux lignes de développement
        risquent de s'éloigner tellement l'une de l'autre qu'essayer
        de fusionner la branche vers le tronc devienne un
        cauchemar.</para>

      <para>Le mieux pour éviter une telle situation est de fusionner
        régulièrement les modifications du tronc vers la branche.
        Faites-en une habitude&nbsp;: une fois par semaine, fusionnez
        les modifications du tronc de la semaine précédente vers la
        branche.</para>

      <para>Le moment arrivera où vous serez prêt à fusionner la
        branche fonctionnelle <quote>synchronisée</quote> vers le
        tronc. Commencez donc par effectuer une dernière fusion des
        modifications les plus récentes du tronc vers la branche.
        Une fois que c'est fait, les dernières versions de la branche
        et du tronc sont absolument identiques, mises à part vos
        propres modifications sur la branche. Vous êtes alors en
        mesure de fusionner la branche vers le tronc avec l'option
        <option>--reintegrate</option>&nbsp;:</para>

      <screen>
$ cd copie-de-travail-du-tronc

$ svn update
À la révision 1910.

$ svn merge --reintegrate http://svn.exemple.com/depot/calc/branches/ma-branche
--- Fusion des différences des URLs du dépôt vers '.':
U    reel.c
U    entier.c
A    nouveau-dossier
A    nouveau-dossier/nouveau-fichier
 U   .
&hellip;
</screen>

      <para>Une autre façon de concevoir ce modèle est d'imaginer que
        votre synchronisation hebdomadaire du tronc vers la branche
        est analogue au lancement de <command>svn update</command>
        dans une copie de travail, tandis que l'étape finale de fusion
        est analogue au lancement de <command>svn commit</command>
        depuis une copie de travail. Après tout, une copie de travail
        n'est rien d'autre qu'une branche privée très
        superficielle&nbsp;: c'est une branche qui n'est capable de ne
        contenir qu'une modification à la fois.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.vendorbr">
    <title>Branches fournisseur</title>

    <para>Comme c'est particulièrement le cas en développement
      logiciel, les données que vous gérez dans votre système de
      gestion de versions ont souvent un lien étroit avec les données
      de quelqu'un d'autre, ou en sont peut-être dépendantes.
      Généralement, les besoins de votre projet vous obligeront à rester
      aussi à jour que possible avec les données fournies par cette
      entité externe, sans sacrifier la stabilité de votre propre
      projet. Ce scénario arrive très souvent, partout où les
      informations générées par un groupe de personnes ont un effet
      direct sur celles qui sont générées par un autre groupe de
      personnes.</para>

    <para>Par exemple, il arrive que des développeurs de logiciel
      travaillent sur une application qui utilise une bibliothèque
      tierce. Subversion a justement une relation de ce type avec la
      bibliothèque Apache Portable Runtime (APR) (voir
      <xref linkend="svn.developer.usingapi.apr" />). Le code source
      de Subversion dépend de la bibliothèque APR pour tous ses
      besoins de portabilité. Durant les étapes initiales de
      développement de Subversion, le projet suivait les changements
      de l'interface de programmation d'APR de près, restant toujours
      <quote>à la pointe</quote> des évolutions du code de la
      bibliothèque. Maintenant que APR et Subversion ont tous deux
      gagné en maturité, Subversion n'essaie de se synchroniser avec
      l'interface de programmation de l'APR qu'à des étapes de
      publication stables et bien testées.</para>

    <para>Donc, si votre projet dépend des informations de quelqu'un
      d'autre, vous pourriez tenter de synchroniser ces informations
      avec les vôtres de plusieurs manières. La plus pénible serait de
      donner des instructions orales ou écrites à tous les
      contributeurs de votre projet, leur demandant de s'assurer
      qu'ils disposent des bonnes versions de ces informations tierces
      dont votre projet a besoin. Si les informations tierces sont
      gérées dans un dépôt Subversion, vous pourriez aussi utiliser
      les définitions externes de Subversion pour en fait
      <quote>agrafer</quote> des versions spécifiques de ces
      informations à un endroit quelconque dans le dossier de votre
      copie de travail (voir
      <xref linkend="svn.advanced.externals"/>).</para>

    <para>Mais parfois vous voudrez gérer des modifications
      personnalisées de ce code tierce à l'intérieur de votre propre
      système de gestion de versions. En reprenant l'exemple du
      développement logiciel, les programmeurs pourraient vouloir
      apporter des modifications à cette bibliothèque tierce pour
      leurs propres besoins. Ces modifications incluraient peut-être
      de nouvelles fonctionnalités ou des corrections de bogues,
      gérées en interne seulement jusqu'à ce qu'elles soient
      incluses dans une version officielle de la bibliothèque tierce.
      Ou alors ces changements ne seront peut-être jamais remontés
      vers ceux qui gèrent cette bibliothèque, existant seulement en
      tant qu'optimisations <quote>maison</quote> permettant de mieux
      adapter la bibliothèque aux besoin des développeurs
      du logiciel.</para>

    <para>À présent vous êtes face à une situation intéressante. Votre
      projet pourrait héberger ses modifications maison des données
      tierces de manière désordonnée, comme par exemple en utilisant
      des fichiers de patch ou des versions alternatives complètes des
      fichiers et dossiers. Mais ces méthodes deviennent rapidement de
      vrais casse-tête à gérer, nécessitant des mécanismes pour
      reporter vos modifications maison au code tierce et nécessitant
      le report de ces modifications à chaque version successive du
      code tierce dont vous dépendez.</para>

    <para>La solution de ce problème est d'utiliser des
      <firstterm>branches fournisseur</firstterm>. Une branche
      fournisseur est une arborescence au sein de votre propre système
      de gestion de versions qui contient des informations fournies
      par une entité tierce, ou fournisseur. Chaque version des données
      du fournisseur que vous décidez d'incorporer dans votre projet
      est appelée une
      <firstterm>livraison fournisseur</firstterm>.</para>

    <para>Les branches fournisseur présentent deux avantages.
      Premièrement, en incluant la livraison fournisseur actuellement
      supportée dans votre propre système de gestion de versions, vous
      avez la garantie que les membres de votre projet n'auront jamais
      besoin de se demander s'ils ont la bonne version des données du
      fournisseur. Ils reçoivent simplement la bonne version pendant
      les mises à jour usuelles de leur copie de travail.
      Deuxièmement, parce que ces données font partie de votre propre
      dépôt Subversion, vous pouvez y conserver vos modifications
      maison&nbsp;: vous n'avez plus besoin d'une méthode automatisée
      (ou pire, manuelle) pour reporter vos propres changements.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.vendorbr.general">
      <title>Procédure générale de gestion des
        branches fournisseur</title>

      <para>La gestion des branches fournisseur fonctionne
        généralement de la façon suivante&nbsp;: vous créez d'abord
        un répertoire à la racine (par exemple
        <filename>/fournisseur</filename>) qui contiendra les branches
        fournisseur. Ensuite vous importez le code tierce dans un
        sous-dossier de ce dossier racine. Vous copiez ensuite ce
        sous-répertoire vers l'emplacement approprié de votre branche
        de développement principale (par exemple
        <filename>/trunk</filename>). Vous faites bien attention à
        toujours effectuer vos modifications locales dans la branche
        de développement principale. À chaque nouvelle version du
        code tierce, vous le déposez dans la branche fournisseur
        et en fusionnez les modifications vers
        <filename>/trunk</filename>, en résolvant les conflits qui
        apparaissent entre vos modifications locales et les
        modifications tierces.</para>

      <para>Un exemple va rendre cet algorithme plus clair. Nous
        allons utiliser un scénario dans lequel votre équipe de
        développement crée un programme de calcul qui dépend d'une
        bibliothèque tierce d'arithmétique des nombres complexes,
        libcomplex. Nous commencerons par la création initiale de la
        branche fournisseur et l'import de la première livraison
        fournisseur. Nous appellerons notre dossier contenant la
        branche fournisseur <filename>libcomplex</filename> et nos
        livraisons fournisseur iront dans un sous-dossier de notre
        branche fournisseur appelé <filename>actuel</filename>.
        Et puisque <command>svn import</command> crée tous les
        dossiers parents intermédiaires dont il a besoin, nous pouvons
        en fait accomplir ces deux étapes en une seule
        commande&nbsp;:</para>

      <screen>
$ svn import /chemin/vers/libcomplex-1.0 \
             http://svn.exemple.com/depot/fournisseur/libcomplex/actuel \
             -m 'import initial de la livraison fournisseur 1.0'
&hellip;
</screen>

      <para>Nous avons désormais la version actuelle du code source
        de libcomplex dans
        <filename>/fournisseur/libcomplex/actuel</filename>. À présent,
        nous étiquetons cette version (voir
        <xref linkend="svn.branchmerge.tags"/>) et ensuite nous la 
        copions dans la branche de développement principale. Cette 
        opération de copie crée un nouveau dossier appelé
        <filename>libcomplex</filename> au sein du répertoire de notre
        projet existant <filename>calc</filename>. C'est dans cette copie
        des données du fournisseur que nous ferons nos
        ajustements maison&nbsp;:</para>

      <screen>
$ svn copy http://svn.exemple.com/depot/fournisseur/libcomplex/actuel  \
           http://svn.exemple.com/depot/fournisseur/libcomplex/1.0      \
           -m 'étiquetage de libcomplex-1.0'
&hellip;
$ svn copy http://svn.exemple.com/depot/fournisseur/libcomplex/1.0  \
           http://svn.exemple.com/depot/calc/libcomplex        \
           -m 'amène libcomplex-1.0 dans la branche principale'
&hellip;
</screen>

      <para>Nous extrayons ensuite la branche principale de notre
        projet, qui inclut désormais une copie de la première
        livraison fournisseur, et nous nous mettons au travail pour
        personnaliser le code de libcomplex. Avant même d'en avoir
        pris conscience, notre version modifiée de libcomplex est
        complètement intégrée dans notre programme de calcul
        <footnote>
          <para>Et ne contient pas le moindre bogue, cela va de
            soi&nbsp;!</para>
        </footnote>.
      </para>

      <para>Quelques semaines plus tard, les développeurs de
        libcomplex publient une nouvelle version de leur bibliothèque,
        la version 1.1, qui contient des fonctionnalités dont nous
        avons besoin. Nous aimerions pouvoir utiliser cette nouvelle
        version, sans toutefois perdre les évolutions que nous avons
        apportées à la version existante. En gros, ce que nous
        voudrions faire c'est remplacer notre version actuelle de
        libcomplex, la 1.0, par une copie de libcomplex 1.1 et
        ensuite ré-appliquer les modifications que nous avions
        effectuées précédemment sur cette bibliothèque à la nouvelle
        version. Mais, en fait, nous allons aborder le problème sous un
        autre angle, en appliquant les changements apportés à
        libcomplex entre les versions 1.0 et 1.1 à notre copie
        modifiée de celle-ci.</para>

      <para>Pour effectuer cette mise à niveau, nous allons extraire
        une copie de notre branche fournisseur et remplacer le code
        du répertoire <filename>actuel</filename> par le nouveau code
        source de libcomplex 1.1. Nous copions en fait littéralement
        de nouveaux fichiers par-dessus des fichiers existants, par
        exemple en extrayant le contenu de l'archive de libcomplex 1.1
        à l'endroit où se trouvent nos fichiers et dossiers.
        L'objectif ici est d'aboutir à ce que notre répertoire
        <filename>actuel</filename> ne contienne que le code de
        libcomplex 1.1 et de s'assurer que la totalité de ce code
        est suivi en versions. Ah, et puis nous voulons faire ceci
        avec le moins possible de perturbations liées à l'historique
        de la gestion de versions.</para>

      <para>Après avoir remplacé le code de la 1.0 par le code de la
        1.1, <command>svn status</command> liste les fichiers ayant
        des modifications locales et peut-être aussi des fichiers
        non suivis en versions. Si nous avons fait ce que nous étions
        censés faire, les fichiers non suivis en versions sont
        uniquement de nouveaux fichiers introduits par la version 1.1
        de libcomplex&nbsp;; nous lançons donc
        <command>svn add</command> sur ces fichiers pour les inclure
        dans la gestion de versions. Si le code de la 1.1 ne contient
        plus certains fichiers qui étaient dans l'arborescence de la
        1.0, il sera peut-être difficile de les repérer&nbsp;; il vous
        faudrait comparer les deux arborescences avec un outil
        extérieur et ensuite faire un <command>svn delete</command>
        sur tous les fichiers présents en 1.0 mais pas en 1.1 (bien
        qu'il soit peut-être parfaitement acceptable de laisser
        traîner ces mêmes fichiers, inutilisés, dans l'ombre).
        Finalement, une fois que notre copie de travail de
        <filename>actuel</filename> ne contient plus que le code de
        libcomplex 1.1, nous pouvons propager les modifications que
        nous avons faites pour lui donner cet aspect.</para>

      <para>Notre branche <filename>actuel</filename> contient
        désormais la nouvelle livraison fournisseur. Nous étiquetons 
        donc la nouvelle version en 1.1 (de la même façon que
        nous avions précédemment étiqueté la livraison fournisseur de
        la version 1.0) et ensuite nous fusionnons les différences entre
        les étiquettes de la version précédente et de la nouvelle
        version vers notre branche de développement
        principale&nbsp;:</para>

      <screen>
$ cd copies-de-travail/calc
$ svn merge http://svn.exemple.com/depot/fournisseur/libcomplex/1.0      \
            http://svn.exemple.com/depot/fournisseur/libcomplex/actuel  \
            libcomplex
&hellip; # résoudre tous les conflits entre leurs modifications et nos modifications
$ svn commit -m 'fusion de libcomplex-1.1 vers la branche principale'
&hellip;
</screen>

      <para>Dans le cas le plus trivial, la nouvelle version de notre
        outil tierce ressemblerait à la version précédente, du point
        de vue des fichiers et dossiers. Aucun des fichiers sources de
        libcomplex n'aurait été effacé, renommé, ou déplacé&nbsp;; la
        nouvelle version ne contiendrait que des modifications
        textuelles par rapport à la précédente. Dans l'idéal, nos
        modifications s'appliqueraient proprement à la nouvelle
        version de la bibliothèque, sans la moindre complication ou
        conflit.</para>

      <para>Mais les choses ne sont pas toujours aussi simples et, en
        fait, il arrive assez fréquemment que des fichiers sources
        changent d'emplacement d'une version à l'autre d'un logiciel.
        Ceci complique la tâche de s'assurer que nos
        modifications sont toujours valides pour la nouvelle version
        du code, et les choses peuvent rapidement dégénérer, jusqu'au
        point où nous pouvons être forcés de reporter manuellement nos
        évolutions maison dans la nouvelle version. Une fois que
        Subversion connaît l'historique d'un fichier source donné,
        incluant tous ses emplacements précédents, la procédure pour
        incorporer la nouvelle version de la bibliothèque est assez
        simple. Mais c'est à nous qu'incombe la responsabilité
        d'indiquer à Subversion de quelle manière l'agencement des
        fichiers sources a changé d'une livraison fournisseur à
        une autre.</para>

    </sect2>

    <!-- TODO: Try to clarify some of the steps for svn_load_dirs.pl
         (Garrett sez they've been "glossed over".  Also, consider
         another section on bypassing svn_load_dirs.pl altogether and
         running with just svn merge, now that it ignores ancestry. -->

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.vendorbr.svn_load_dirs">
      <title>svn_load_dirs.pl</title>

      <para>Les livraisons fournisseur comportant plus de
        quelques suppressions, ajouts et déplacements compliquent le
        processus de mise à niveau à chaque version successive des
        données tierces. Subversion fournit donc le script
        <command>svn_load_dirs.pl</command> pour faciliter ce
        processus. Ce script automatise les étapes importantes que
        nous avons mentionnées dans la procédure générale de gestion
        des branches fournisseurs afin de minimiser les erreurs. Vous
        êtes toujours responsable de l'utilisation des commandes
        <command>svn merge</command> pour fusionner les nouvelles
        versions des données tierces vers votre branche de
        développement principale, mais
        <command>svn_load_dirs.pl</command> peut vous aider à parvenir
        à cette étape plus rapidement et plus facilement.</para>

      <para>En bref, <command>svn_load_dirs.pl</command> est une
        version améliorée de <command>svn import</command> qui possède
        plusieurs caractéristiques importantes&nbsp;:</para>

      <itemizedlist>
        <listitem>
          <para>On peut le lancer n'importe quand, dans le but
            d'amener un répertoire existant du dépôt à refléter
            exactement un répertoire extérieur, en effectuant toutes
            les opérations d'ajouts et de suppressions et, en option,
            de déplacements.</para>
        </listitem>
        <listitem>
          <para>Il prend soin de séries compliquées d'opérations entre
            lesquelles Subversion a besoin d'une propagation
            intermédiaire, telles qu'avant de renommer un fichier ou
            un dossier pour la deuxième fois.</para>
        </listitem>
        <listitem>
          <para>En option, il peut étiqueter les nouveaux dossiers
            importés.</para>
        </listitem>
        <listitem>
          <para>En option, il peut ajouter des propriétés arbitraires
            aux fichiers et dossiers qui correspondent à une
            expression régulière.</para>
        </listitem>
      </itemizedlist>

      <para><command>svn_load_dirs.pl</command> prend trois paramètres
        obligatoires. Le premier paramètre est l'URL du répertoire de
        base de Subversion à modifier. Ce paramètre est suivi par l'URL,
        relative au premier paramètre, dans laquelle la livraison
        fournisseur sera importée. Enfin, le troisième paramètre est le
        dossier local à importer. En utilisant notre exemple précédent,
        une exécution type de <command>svn_load_dirs.pl</command>
        donne&nbsp;:</para>

      <screen>
$ svn_load_dirs.pl http://svn.exemple.com/depot/fournisseur/libcomplex \
                   actuel                                              \
                   /chemin/vers/libcomplex-1.1
&hellip;
</screen>

      <para>Vous pouvez indiquer que vous aimeriez que
        <command>svn_load_dirs.pl</command> étiquette la nouvelle
        livraison fournisseur en passant l'option
        <option>-t</option> et en spécifiant un nom d'étiquette.
        Cette étiquette est aussi une URL relative au premier
        paramètre du programme.</para>

      <screen>
$ svn_load_dirs.pl -t libcomplex-1.1                              \
                   http://svn.exemple.com/depot/fournisseur/libcomplex \
                   actuel                                        \
                   /chemin/vers/libcomplex-1.1
&hellip;
</screen>

      <para>Lorsque vous lancez <command>svn_load_dirs.pl</command>,
        il examine le contenu de votre livraison fournisseur
        existante, <filename>actuel</filename>, et le compare à la
        nouvelle livraison fournisseur. Dans le cas le plus trivial,
        aucun fichier n'est présent dans une version sans l'être
        dans l'autre et le script effectue le nouvel import sans
        incident. Cependant, s'il y a des divergences dans
        l'agencement des fichiers entre les versions,
        <command>svn_load_dirs.pl</command> vous demande comment
        résoudre ces différences. Par exemple, vous avez
        l'opportunité d'indiquer au script que vous savez que le
        fichier <filename>math.c</filename> de la version 1.0 de
        libcomplex a été renommé en <filename>arithmetique.c</filename>
        dans libcomplex 1.1. Toutes les divergences qui ne sont pas
        liées à des renommages sont traitées comme des ajouts et des
        suppressions classiques.</para>

      <para>Le script peut également prendre en compte un fichier de
        configuration séparé, permettant de spécifier des propriétés
        sur des fichiers et dossiers, correspondants à une expression
        régulière, qui vont être <emphasis>ajoutés</emphasis> au
        dépôt. Ce fichier de configuration est indiqué à
        <command>svn_load_dirs.pl</command> en utilisant l'option
        <option>-p</option> en ligne de commande. Chaque ligne du
        fichier de configuration est un ensemble de deux ou quatre
        valeurs délimitées par des espaces&nbsp;: une expression
        régulière du style Perl à laquelle comparer le chemin ajouté,
        un mot clé de contrôle (soit <literal>break</literal> soit
        <literal>cont</literal>) et ensuite, en option, un nom de
        propriété et une valeur.</para>

      <screen>
\.png$              break   svn:mime-type   image/png
\.jpe?g$            break   svn:mime-type   image/jpeg
\.m3u$              cont    svn:mime-type   audio/x-mpegurl
\.m3u$              break   svn:eol-style   LF
.*                  break   svn:eol-style   native
</screen>

      <para>Pour chaque chemin ajouté, les modifications de propriétés
        configurées dont l'expression régulière correspond au chemin
        sont appliquées dans l'ordre, sauf si le terme de contrôle est
        <literal>break</literal> (ce qui signifie qu'aucune autre
        modification de propriété ne doit être appliquée à ce chemin).
        Si le terme de contrôle est <literal>cont</literal>
        (abréviation de continuer), la comparaison continue avec la
        ligne suivante du fichier de configuration.</para>

      <para>Toute espace faisant partie de l'expression régulière, du
        nom de la propriété ou de la valeur de la propriété doit être
        entourée d'apostrophes ou de guillemets. Vous pouvez banaliser
        les guillemets et apostrophes qui ne sont pas utilisés pour
        entourer une espace en les faisant précéder d'une barre oblique
        inversée (ou <quote>antislash</quote>&nbsp;:
        <literal>\</literal>). L'antislash ne banalise que les
        guillemets et apostrophes pendant le traitement du fichier de
        configuration, ce n'est donc pas la peine de protéger d'autres
        caractères au-delà de ce qui est nécessaire pour
        l'expression régulière.</para>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.summary">
    <title>Résumé</title>

    <para>Nous avons traité de nombreux sujets dans ce chapitre. Nous
      avons présenté les concepts d'étiquettes et de branches et
      montré comment Subversion implémente ces concepts en copiant des
      répertoires avec la commande <command>svn copy</command>. Nous
      avons expliqué comment utiliser <command>svn merge</command>
      pour copier des modifications d'une branche à l'autre ou pour
      revenir en arrière sur des modifications non-satisfaisantes.
      Nous avons étudié l'utilisation de <command>svn switch</command>
      pour créer des copies de travail mixtes, pointant vers des
      emplacements variés d'un dépôt. Et nous avons évoqué la façon
      dont on peut gérer l'organisation et le cycle de vie des
      branches dans un dépôt.</para>

    <para>Tâchez de garder en mémoire la devise de Subversion&nbsp;:
      les branches et les étiquettes ne coûtent quasiment rien. Donc
      n'ayez pas peur de les utiliser quand vous en
      avez besoin&nbsp;!</para>

    <para>En guise de rappel utile de toutes les opérations dont nous
      avons parlé, voici un tableau de référence très pratique, à
      consulter lorsque vous commencerez à utiliser des branches.</para>

    <table id="svn.branchemerge.summary.tbl-1">
      <title>Commandes de gestion des branches et des fusions</title>
      <tgroup cols="2">
        <thead>
          <row>
            <entry>Action</entry>
            <entry>Commande</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>Créer une branche ou une étiquette</entry>
            <entry><userinput>svn copy <replaceable>URL1</replaceable> <replaceable>URL2</replaceable></userinput></entry>
          </row>

          <row>
            <entry>Faire pointer une copie de travail vers une branche ou une étiquette</entry>
            <entry><userinput>svn switch <replaceable>URL</replaceable></userinput></entry>
          </row>

          <row>
            <entry>Synchroniser une branche avec le tronc</entry>
            <entry><userinput>svn merge <replaceable>trunkURL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
            <entry>Voir l'historique des fusions ou les ensembles de modifications susceptibles d'être fusionnés</entry>
            <entry><userinput>svn mergeinfo target --from-source=<replaceable>URL</replaceable></userinput></entry>
          </row>

          <row>
            <entry>Fusionner une branche vers le tronc</entry>
            <entry><userinput>svn merge --reintegrate <replaceable>branchURL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
            <entry>Fusionner une modification précise</entry>
            <entry><userinput>svn merge -c <replaceable>REV</replaceable> <replaceable>URL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
            <entry>Fusionner un ensemble de modifications</entry>
            <entry><userinput>svn merge -r <replaceable>REV1</replaceable>:<replaceable>REV2</replaceable> <replaceable>URL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
            <entry>Empêcher qu'une modification ne soit fusionnée automatiquement</entry>
            <entry><userinput>svn merge -c <replaceable>REV</replaceable> --record-only <replaceable>URL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
            <entry>Prévisualiser une fusion</entry>
            <entry><userinput>svn merge <replaceable>URL</replaceable> --dry-run</userinput></entry>
          </row>

          <row>
            <entry>Abandonner une fusion</entry>
            <entry><userinput>svn revert -R .</userinput></entry>
          </row>

          <row>
            <entry>Ressusciter un élément de l'historique</entry>
            <entry><userinput>svn copy <replaceable>URL</replaceable>@<replaceable>REV</replaceable> <replaceable>localPATH</replaceable></userinput></entry>
          </row>

          <row>
            <entry>Revenir en arrière sur une modification déjà propagée</entry>
            <entry><userinput>svn merge -c -<replaceable>REV</replaceable> <replaceable>URL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
            <entry>Examiner l'historique en tenant compte des informations de fusion </entry>
            <entry><userinput>svn log -g; svn blame -g</userinput></entry>
          </row>

          <row>
            <entry>Créer une étiquette à partir d'une copie de travail</entry>
            <entry><userinput>svn copy . <replaceable>tagURL</replaceable></userinput></entry>
          </row>

          <row>
            <entry>Réorganiser une branche ou une étiquette</entry>
            <entry><userinput>svn mv <replaceable>URL1</replaceable> <replaceable>URL2</replaceable></userinput></entry>
          </row>

          <row>
            <entry>Supprimer une branche ou une étiquette</entry>
            <entry><userinput>svn rm <replaceable>URL</replaceable></userinput></entry>
          </row>
        </tbody>
      </tgroup>
      </table>

  </sect1>

</chapter>

<!--
local variables:
sgml-parent-document: ("book.xml" "chapter")
end:
-->


