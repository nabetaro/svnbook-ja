<chapter id="svn.developer">
  <title>Intégration de Subversion</title>
  
  <para>Subversion est conçu de manière modulaire&nbsp;: il est 
    constitué d'un ensemble de bibliothèques écrites en langage C. 
    Chaque bibliothèque a un but et une interface de programmation 
    (API, <foreignphrase>application programming
    interface</foreignphrase> en anglais) bien définis&nbsp;;
    cette interface est disponible non seulement pour le 
    propre usage de Subversion mais aussi pour n'importe quel programme 
    qui souhaite inclure ou piloter Subversion d'une manière ou d'une 
    autre. De plus, l'API Subversion est non seulement disponible pour 
    les programmes écrits en langage C, mais aussi pour les programmes 
    écrits dans des langages de plus haut niveau tels que Python, Perl, 
    Java et Ruby.</para>

  <para>Ce chapitre est destiné à ceux qui souhaitent interagir avec 
    Subversion au moyen de son API publique ou d'une de ses nombreuses 
    interfaces avec d'autres langages. Si vous souhaitez écrire des 
    scripts robustes qui encapsulent les fonctionnalités de Subversion 
    afin de vous rendre la vie plus facile, si vous essayez de 
    développer des intégrations plus poussées entre Subversion et 
    d'autres logiciels ou si vous êtes juste intéressé par les nombreux 
    modules de Subversion et ce qu'ils ont à offrir, ce chapitre est 
    fait pour vous. Si, par contre, vous ne vous voyez pas participer 
    à Subversion à ce niveau, vous pouvez sauter ce chapitre sans la 
    moindre crainte pour vos compétences en tant qu'utilisateur de 
    Subversion.</para>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.developer.layerlib">
    <title>Organisation des bibliothèques en couches successives</title>

    <para>Chaque bibliothèque au sein de Subversion peut être classée 
      dans une des trois couches principales&nbsp;: la couche dépôt, la 
      couche d'accès au dépôt (RA pour <foreignphrase>Repository
      Access</foreignphrase> en anglais) et la couche client (voir la
      <xref linkend="svn.intro.architecture.dia-1" /> de la préface).
      Nous allons examiner ces trois couches rapidement mais, d'abord, 
      passons brièvement en revue les différentes bibliothèques de 
      Subversion. Pour des raisons de cohérence, nous nous référons à 
      ces bibliothèques par leurs noms Unix sans extension
      (<filename>libsvn_fs</filename>, <filename>libsvn_wc</filename>,
      <filename>mod_dav_svn</filename>,&nbsp;etc.).</para>

    <variablelist>
      <varlistentry>
        <term>libsvn_client</term> 
        <listitem><para>interface principale pour les programmes 
          clients&nbsp;;</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_delta</term>
        <listitem><para>routines de recherche de différences pour les 
          arborescences et les flux d'octets&nbsp;;</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_diff</term>
        <listitem><para>routines de recherche de différences et de 
          fusions contextuelles&nbsp;;</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_fs</term>
        <listitem><para>chargeur de modules et outils communs pour le 
          système de fichiers&nbsp;;</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_fs_base</term>
        <listitem><para>gestion du magasin de données Berkeley 
          DB&nbsp;;</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_fs_fs</term>
        <listitem><para>gestion du magasin de données natif 
          FSFS&nbsp;;</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_ra</term>
        <listitem><para>outils communs pour l'accès au dépôt et 
          chargeur de modules&nbsp;;</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_ra_local</term>
        <listitem><para>module d'accès au dépôt en 
          local&nbsp;;</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_ra_neon</term>
        <listitem><para>module d'accès au dépôt par 
          WebDAV&nbsp;;</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_ra_serf</term>
        <listitem><para>autre module (expérimental) d'accès au dépôt par 
          WebDAV&nbsp;;</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_ra_svn</term>
        <listitem><para>modèle d'accès au dépôt par le protocole 
          Subversion&nbsp;;</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_repos</term>
        <listitem><para>interface du dépôt&nbsp;;</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_subr</term>
        <listitem><para>diverses routines utiles&nbsp;;</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_wc</term>
        <listitem><para>bibliothèque pour la gestion de la copie de 
          travail locale&nbsp;;</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>mod_authz_svn</term>
        <listitem><para>module Apache d'authentification pour les accès 
          aux dépôts Subversion par WebDAV&nbsp;;</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>mod_dav_svn</term>
        <listitem><para>module Apache de correspondance entre les 
          opérations WebDAV et les opérations Subversion.</para></listitem>
      </varlistentry>
    </variablelist>

    <para>Le fait que le mot <quote>divers</quote> n'apparaisse qu'une 
      seule fois dans la liste précédente est plutôt un bon signe. 
      L'équipe de développement de Subversion est particulièrement 
      soucieuse de placer les fonctionnalités dans les couches et 
      bibliothèques appropriées. Un des plus grands avantages de cette 
      conception modulaire, du point de vue du développeur, est sûrement 
      l'absence de complexité. En tant que développeur, vous pouvez vous 
      forger rapidement une image mentale de cette architecture et ainsi 
      trouver relativement facilement l'emplacement des fonctionnalités 
      qui vous intéressent.</para>

    <para>Un autre avantage de la modularité est la possibilité de 
      remplacer un module par une autre bibliothèque qui implémente la 
      même API sans affecter le reste du code. Dans un certain sens, 
      c'est ce qui se passe déjà dans Subversion. Les bibliothèques
      <filename>libsvn_ra_local</filename>,
      <filename>libsvn_ra_neon</filename>,
      <filename>libsvn_ra_serf</filename> et
      <filename>libsvn_ra_svn</filename> implémentent toutes la même 
      interface et fonctionnent comme des greffons pour 
      <filename>libsvn_ra</filename>. Et toutes les quatre communiquent 
      avec la couche dépôt &mdash; <filename>libsvn_ra_local</filename> 
      se connectant directement au dépôt, les trois autres le faisant à 
      travers le réseau. 
      <filename>libsvn_fs_base</filename> et 
      <filename>libsvn_fs_fs</filename> sont un autre exemple de 
      bibliothèques qui implémentent les mêmes fonctionnalités de 
      différentes manières &mdash; les deux sont des greffons pour la 
      bibliothèque commune <filename>libsvn_fs</filename>.</para>

    <para>Le client lui-même illustre également les avantages de la 
      modularité dans l'architecture de Subversion. La bibliothèque 
      <filename>libsvn_client</filename> est un point d'entrée unique 
      pour la plupart des fonctionnalités nécessaires à la conception 
      d'un client Subversion fonctionnel (voir <xref
      linkend="svn.developer.layerlib.client"/>). Ainsi, bien que la 
      distribution Subversion fournisse seulement le programme en ligne 
      de commande <command>svn</command>, de nombreux programmes tiers 
      fournissent différents types d'IHM. Ces interfaces graphiques 
      utilisent la même API que le client en ligne de commande fourni en 
      standard. Depuis le début, cette modularité joue un rôle majeur 
      dans la prolifération des différents clients Subversion, sous la 
      forme de clients autonomes ou greffés dans des environnements de 
      développement intégrés (<foreignphrase>IDE</foreignphrase> en
      anglais) et, par extension, dans l'adoption formidablement rapide
      de Subversion lui-même.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.layerlib.repos">
      <title>Couche dépôt</title>

      <para>Quand nous faisons référence à la couche dépôt de 
        Subversion, nous parlons généralement de deux concepts de 
        base&nbsp;: l'implémentation du système de fichiers suivi en 
        versions (auquel on a accès via
        <filename>libsvn_fs</filename> et qui est supporté par les 
        greffons associés <filename>libsvn_fs_base</filename> et
        <filename>libsvn_fs_fs</filename>) et la logique du dépôt qui 
        l'habille (telle qu'elle est implémentée dans
        <filename>libsvn_repos</filename>). Ces bibliothèques 
        fournissent les mécanismes de stockage et de comptes-rendus pour 
        les différentes révisions de vos données suivies en versions. 
        Cette couche est connectée à la couche client via la couche 
        d'accès au dépôt et est, du point de vue de l'utilisateur de 
        Subversion, le <quote>truc à l'autre bout de la 
        ligne</quote>.</para>

      <para>Le système de fichiers Subversion n'est pas un système de 
        fichiers de bas niveau que vous pourriez installer sur votre 
        système d'exploitation (tels que NTFS ou ext2 pour Linux) mais 
        un système de fichiers virtuel. Plutôt que de stocker les 
        fichiers et répertoires comme des fichiers et des répertoires 
        réels (du type de ceux dans lesquels vous naviguez avec votre 
        navigateur de fichiers), il utilise un des deux magasins de 
        données abstraits disponibles&nbsp;: soit le système de gestion 
        de bases de données Berkeley DB, soit une représentation dans 
        des fichiers ordinaires, dite <quote>à plat</quote> (pour en 
        apprendre plus sur les deux magasins de données, reportez-vous 
        à <xref linkend="svn.reposadmin.basics.backends"/>). La 
        communauté de développement Subversion a même exprimé le souhait 
        que les futures versions de Subversion puissent utiliser 
        d'autres magasins de données, peut-être à travers un mécanisme 
        tel que ODBC (Open Database Connectivity , standard ouvert de 
        connexion à des bases de données). En fait, Google a fait 
        quelque chose de semblable avant de lancer le service 
        <quote>Google Code Project Hosting</quote> (Hébergement de code 
        source de projets)&nbsp;: ils ont annoncé mi-2006 que les 
        membres de leur équipe open source avaient écrit un nouveau 
        greffon propriétaire de système de fichiers pour Subversion, qui 
        utilisait leur base de données <quote>Google ultra-scalable 
        Bigtable</quote> comme magasin de données.</para>

      <para>L'API du système de fichiers, mise à disposition par
        <filename>libsvn_fs</filename>, contient les fonctionnalités que 
        vous pouvez attendre de n'importe quel autre système de 
        fichiers&nbsp;: vous pouvez créer et supprimer des fichiers et 
        des répertoires, les copier et les déplacer, modifier le contenu 
        d'un fichier,&nbsp;etc. Elle possède également des caractéristiques 
        peu communes comme la capacité d'ajouter, modifier et supprimer 
        des méta-données (<quote>propriétés</quote>) sur chaque fichier 
        ou répertoire. En outre, le système de fichiers Subversion est 
        un système de fichiers suivi en versions, ce qui veut dire que 
        si vous faites des modifications dans votre arborescence, 
        Subversion se souvient de l'état de votre arborescence avant les 
        modifications. Et il se souvient aussi de l'état avant les 
        modifications précédentes, et de l'état encore antérieur, et ainsi 
        de suite. Vous pouvez ainsi remonter le temps (c'est-à-dire les 
        versions) jusqu'au moment où vous avez commencé à ajouter des 
        éléments dans le système de fichiers.</para>

      <para>Toutes les modifications faites sur l'arborescence ont pour 
        contexte les transactions de propagation de Subversion. Ce qui 
        suit est la démarche générale simplifiée de modification du 
        système de fichiers&nbsp;:</para>

      <orderedlist>
        <listitem>
          <para>commencer une transaction de propagation de 
            Subversion&nbsp;;</para>
        </listitem>
        <listitem>
          <para>effectuer les modifications (ajouts, suppressions, 
            modifications de propriétés,&nbsp;etc.)&nbsp;;</para>
        </listitem>
        <listitem>
          <para>clore la transaction.</para>
        </listitem>
      </orderedlist>

      <para>Une fois que la transaction est terminée, les 
        modifications du système de fichiers sont stockées de 
        façon permanente en tant qu'éléments de l'historique. Chacun de 
        ces cycles génère une nouvelle révision de l'arborescence et 
        chaque révision est accessible pour toujours sous la forme d'un 
        cliché, immuable, de l'état de l'arborescence à un moment 
        précis.</para>

      <sidebar>
        <title>Digression sur les transactions</title>

        <para>La notion de transaction Subversion peut être facilement 
          confondue avec la notion de transaction concernant le magasin 
          de données sous-jacent, en particulier à cause de la proximité 
          du code des transactions Subversion dans
          <filename>libsvn_fs_base</filename> et du code du gestionnaire 
          de bases de données Berkeley DB. Ces deux types de 
          transactions assurent l'atomicité et l'isolation. En d'autres 
          termes, les transactions vous permettent d'effectuer un 
          ensemble d'actions avec une logique tout-ou-rien (soit toutes 
          les actions de l'ensemble se terminent avec succès, soit c'est 
          comme si aucune n'avait eu lieu), ce qui permet de ne pas 
          interférer avec les autres processus qui travaillent sur les 
          données.</para>

        <para>Les transactions dans les bases de données comprennent 
          généralement de petites opérations relatives à la modification 
          de données dans la base elle-même (comme changer le contenu 
          d'une ligne dans une table). Les transactions Subversion ont 
          un champ d'action plus large, elles comprennent des opérations 
          de plus haut niveau telles que modifier un ensemble de 
          fichiers et de répertoires qui doivent être stockés dans la 
          prochaine révision de l'arborescence suivie en versions. Pour 
          ajouter à la confusion, Subversion utilise une transaction de 
          base de données pendant la création d'une transaction 
          Subversion (ainsi, si la création de la transaction Subversion 
          échoue, la base de données sera telle que si la demande de 
          création n'avait jamais eu lieu)&nbsp;!</para>

        <para>Heureusement pour les utilisateurs de l'API du système de 
          fichiers, la notion de transaction du système de gestion de 
          bases de données lui-même est presque entièrement masquée 
          (comme on peut s'y attendre dans une architecture modulaire 
          bien construite). C'est seulement si vous commencez à fouiller 
          dans l'implémentation du système de fichiers que de telles 
          choses deviennent visibles (ou intéressantes).</para>

      </sidebar>

      <para>La majeure partie des fonctionnalités offertes par 
        l'interface du système de fichiers traite d'actions relatives à 
        un chemin unique du système de fichiers. C'est-à-dire que, vu de 
        l'extérieur du système de fichiers, le mécanisme de base pour 
        décrire et accéder à une révision donnée d'un fichier ou d'un 
        répertoire utilise des chemins classiques tels que 
        <filename>/machin/bidule</filename>, de la même manière que 
        quand vous indiquez un fichier ou un répertoire dans votre 
        interface en ligne de commande favorite. Vous ajoutez de 
        nouveaux fichiers ou répertoires en passant leur 
        <quote>futur</quote> chemin à la fonction idoine de l'API. Vous 
        faites des requêtes sur ces éléments avec le même 
        mécanisme.</para>

      <para>Cependant, contrairement à la plupart des systèmes de 
        fichiers, le chemin n'est pas une information suffisante pour 
        identifier un fichier ou un répertoire dans Subversion. 
        Représentez-vous l'arborescence des répertoires comme un système 
        à deux dimensions, où l'on atteint les frères d'un nœud en se 
        déplaçant horizontalement, à droite ou à gauche, et où la 
        navigation dans les sous-répertoires de ce nœud peut être 
        assimilée à un mouvement vers le bas. La <xref
        linkend="svn.developer.layerlib.repos.dia-1"/> illustre ce 
        concept pour une arborescence classique.</para>

      <figure id="svn.developer.layerlib.repos.dia-1">
        <title>Fichiers et répertoires en deux dimensions</title>
        <graphic fileref="images/ch08dia1.png"/>
      </figure>

      <para>Ici, la différence est que le système de fichiers Subversion 
        possède une élégante troisième dimension que la plupart des 
        systèmes de fichiers n'ont pas&nbsp;: le temps<footnote>
          <para>Nous comprenons que cela puisse être un choc énorme pour 
            les amateurs de science-fiction, qui ont longtemps cru que 
            le Temps était en fait la quatrième dimension. Nous nous 
            excusons pour le traumatisme psychologique causé par 
            l'affirmation de cette théorie divergente.</para>
        </footnote>.
        Dans l'interface du système de fichiers, presque chaque fonction 
        qui demande un argument de type <literal>chemin</literal> attend 
        également un argument de type <literal>racine</literal> (dénommé 
        en fait <literal>svn_fs_root_t</literal>). Cet argument décrit 
        soit une révision, soit une transaction (qui est en fait la 
        genèse d'une révision) et fournit la troisième dimension, 
        l'élément de contexte indispensable pour différencier 
        <filename>/machin/bidule</filename> dans la révision 32 et le 
        même chemin dans la révision 98. La <xref
        linkend="svn.developer.layerlib.repos.dia-2"/> présente 
        l'historique des révisions comme une dimension supplémentaire de 
        l'univers du système de fichiers Subversion.</para>

      <figure id="svn.developer.layerlib.repos.dia-2">
        <title>Prise en compte du temps &mdash; la 
          troisième dimension de la gestion de versions&nbsp;!</title>
        <graphic fileref="images/ch08dia2.png"/>
      </figure>

      <para>Comme nous l'avons déjà mentionné, l'API de 
        <filename>libsvn_fs</filename> ressemble à s'y méprendre à celle 
        de n'importe quel autre système de fichiers, sauf qu'on y a 
        ajouté la formidable capacité de gestion des versions. Elle a été 
        conçue pour être utilisable par n'importe quel programme ayant 
        besoin d'un système de fichiers suivi en versions. Et ce n'est 
        pas un hasard si Subversion lui-même est intéressé par une telle 
        fonctionnalité. Mais, bien que cette API soit suffisante pour 
        effectuer une gestion de versions basique des fichiers et des 
        répertoires, Subversion en demande plus, et c'est là que 
        <filename>libsvn_repos</filename> entre en scène.</para>

      <para>La bibliothèque du dépôt Subversion
        (<filename>libsvn_repos</filename>) se situe (logiquement 
        parlant) au-dessus de l'API <filename>libsvn_fs</filename> et 
        elle fournit des fonctionnalités supplémentaires allant au-delà 
        de la logique sous-jacente du système de fichiers suivi en 
        versions. Elle ne masque pas entièrement chaque fonction du 
        système de fichiers &mdash; seules certaines étapes importantes 
        dans le cycle général de l'activité du système de fichiers sont 
        encapsulées par l'interface du dépôt. Parmi les fonctions 
        encapsulées, on peut citer la création et la propagation des 
        transactions Subversion et la modification des propriétés de 
        révisions. Ces actions particulières sont encapsulées par la 
        couche dépôt parce qu'elles ont des procédures automatiques 
        associées. Le système des procédures automatiques du dépôt n'est 
        pas strictement concomitant à l'implémentation d'un système de 
        fichiers suivi en versions, c'est pourquoi il réside dans la 
        bibliothèque d'encapsulation du dépôt.</para>
      
      <para>Le mécanisme des procédures automatiques n'est pas l'unique 
        raison qui a conduit à séparer logiquement la bibliothèque du 
        dépôt du reste du code du système de fichiers. L'API de 
        <filename>libsvn_repos</filename> fournit à Subversion un 
        certain nombre d'autres possibilités intéressantes. Parmi elles, 
        on peut citer&nbsp;:</para>

      <itemizedlist>
        <listitem>
          <para>créer, ouvrir, détruire et effectuer des actions de 
            restauration sur un dépôt Subversion et le système de 
            fichiers inclus dans ce dépôt&nbsp;;</para>
        </listitem>
        <listitem>
          <para>décrire les différences entre deux 
            arborescences&nbsp;;</para>
        </listitem>
        <listitem>
          <para>obtenir les messages de propagation associés à toutes 
            les révisions (ou certaines) qui ont modifié un ensemble de 
            fichiers du système de fichiers&nbsp;;</para>
        </listitem>
        <listitem>
          <para>générer des images (<quote>dumps</quote>) du système de 
            fichiers lisibles par l'utilisateur &mdash; ces images étant 
            des représentations complètes des révisions du système de 
            fichiers&nbsp;;</para>
        </listitem>
        <listitem>
          <para>analyser ces images et les charger dans un autre dépôt 
            Subversion.</para>
        </listitem>
      </itemizedlist>

      <para>Comme Subversion continue à évoluer, la bibliothèque du dépôt 
        grandit avec la bibliothèque du système de fichiers pour offrir 
        davantage de fonctionnalités et des options configurables.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.layerlib.ra">
      <title>Couche d'accès au dépôt</title>

      <para>Si la couche Dépôt de Subversion est <quote>à l'autre bout 
        de la ligne</quote>, la couche d'accès au dépôt (RA pour 
        <foreignphrase>repository access</foreignphrase> en anglais)
        est la ligne en tant que telle. Chargée d'organiser les données
        entre les bibliothèques client et le dépôt, cette couche inclut
        la bibliothèque de chargement du module 
        <filename>libsvn_ra</filename>, les modules RA eux-mêmes (qui 
        incluent à l'heure actuelle <filename>libsvn_ra_neon</filename>, 
        <filename>libsvn_ra_local</filename>, 
        <filename>libsvn_ra_serf</filename> et 
        <filename>libsvn_ra_svn</filename>) et toute bibliothèque 
        supplémentaire requise par un ou plusieurs de ces modules RA 
        (par exemple, le module Apache <filename>mod_dav_svn</filename> 
        ou le serveur de <filename>libsvn_ra_svn</filename>, 
        <command>svnserve</command>).</para>

      <para>Comme Subversion utilise les URL pour identifier les dépôts 
        à contacter, la partie de l'URL qui indique le protocole 
        (habituellement <literal>file://</literal>, 
        <literal>http://</literal>,
        <literal>https://</literal>, <literal>svn://</literal> ou
        <literal>svn+ssh://</literal>) est utilisée pour déterminer quel 
        module RA gère les communications. Chaque module indique la 
        liste des protocoles qu'il connaît afin que le chargeur RA 
        puisse déterminer, à l'exécution, quel module utiliser pour la 
        tâche en cours. Vous pouvez obtenir la liste des modules RA 
        disponibles pour votre client Subversion en ligne de commande, 
        ainsi que les protocoles qu'ils prennent en charge, en lançant 
        la commande <userinput>svn --version</userinput>&nbsp;:</para>
     
      <screen>
$ svn --version
svn, version 1.5.0 (r31699)
    compilé Jun 18 2008, 09:57:36

Copyright (C) 2000-2008 CollabNet.
Subversion est un logiciel libre, cf http://subversion.tigris.org/
Il inclut du logiciel développé par CollabNet (http://www.Collab.Net/).

Les modules d'accès à un dépôt (RA) suivants sont disponibles :

* ra_neon : Module d'accès à un dépôt via le protocole WebDAV avec Neon.
  - gère le schéma d'URL 'http'
  - gère le schéma d'URL 'https'
* ra_svn : Module d'accès à un dépôt avec le protocole réseau propre de svn.
  - avec authentification Cyrus SASL
  - gère le schéma d'URL 'svn'
* ra_local : Module d'accès à un dépôt sur un disque local.
  - gère le schéma d'URL 'file'
* ra_serf : Module d'accès à un dépôt via le protocole WebDAV avec serf.
  - gère le schéma d'URL 'http'
  - gère le schéma d'URL 'https'
</screen>

      <para>L'API publique exportée par la couche RA contient les 
        fonctionnalités nécessaires pour envoyer des données suivies en 
        versions vers le dépôt et pour en recevoir. Chacun des greffons 
        RA disponibles est capable d'effectuer ces tâches en utilisant 
        un protocole particulier&nbsp;: <filename>libsvn_ra_dav</filename> 
        utilise le protocole HTTP/WebDAV (avec chiffrement SSL en 
        option) pour communiquer avec un serveur HTTP Apache sur lequel 
        tourne le module serveur Subversion
        <filename>mod_dav_svn</filename>&nbsp;;
        <filename>libsvn_ra_svn</filename> utilise un protocole réseau 
        propre à Subversion pour communiquer avec le programme 
        <command>svnserve</command>, et ainsi de suite.</para>

      <para>Ceux qui désirent accéder à un dépôt Subversion en utilisant 
        un autre protocole comprendront rapidement pourquoi la couche 
        d'accès au dépôt est modulaire&nbsp;! Les développeurs peuvent 
        tout simplement écrire une nouvelle bibliothèque qui implémente 
        l'interface RA d'un côté et qui communique avec le dépôt de 
        l'autre. Votre nouvelle bibliothèque peut utiliser des 
        protocoles réseaux existants ou vous pouvez en inventer de 
        nouveaux. Vous pouvez ainsi utiliser les communications 
        inter-processus (IPC pour <foreignphrase>interprocess 
        communication</foreignphrase> en anglais) ou même, soyons fou, 
        implémenter un protocole basé sur l'email. Subversion apporte 
        les API, à vous d'apporter la créativité.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.layerlib.client">
      <title>Couche client</title>
      
      <para>Côté client, tout se passe dans la copie de travail
        Subversion. Le gros des fonctionnalités implémentées par les 
        bibliothèques client existe dans le seul but de gérer les copies 
        de travail locales &mdash; des répertoires pleins de fichiers et 
        d'autres sous-répertoires qui sont une sorte de copie locale et 
        modifiable d'un ou plusieurs dépôts &mdash; et de propager les 
        changements vers et depuis la couche d'accès au dépôt.</para>

      <para>La bibliothèque de Subversion pour la copie de travail, 
        <filename>libsvn_wc</filename>, est directement responsable de 
        la gestion des données dans les copies de travail. Pour ce 
        faire, la bibliothèque stocke dans un sous-répertoire spécial
        des données d'administration concernant chaque répertoire
        suivi en versions. Ce sous-répertoire, nommé 
        <filename>.svn</filename>, est présent dans chaque répertoire 
        d'une copie de travail&nbsp;; il contient tout un tas de 
        fichiers et de répertoires qui enregistrent l'état du répertoire 
        suivi en versions et fournit un espace privé pour les actions 
        d'administration. Pour les habitués de CVS, ce sous-répertoire 
        <filename>.svn</filename> a des objectifs similaires aux 
        répertoires administratifs <filename>CVS</filename> que l'on
        trouve dans les copies de travail CVS.
        Pour plus d'informations sur la zone d'administration
        <filename>.svn</filename>, reportez-vous à 
        <xref linkend="svn.developer.insidewc"/> plus loin dans ce 
        chapitre.</para>

      <para>La bibliothèque client de Subversion, 
        <filename>libsvn_client</filename>, est celle qui a le plus de 
        responsabilités&nbsp;: son rôle est de mélanger les 
        fonctionnalités de la bibliothèque de la copie de travail avec 
        celles de la couche d'accès au dépôt (RA) afin de fournir l'API 
        de plus haut niveau, utilisable par n'importe quelle application 
        qui voudrait effectuer des actions générales de gestion de 
        versions. Par exemple, la fonction 
        <function>svn_client_checkout()</function> prend une URL en 
        argument. Elle passe cette URL à la couche RA et ouvre une 
        session authentifiée avec le dépôt concerné. Elle demande 
        ensuite au dépôt l'arborescence requise, envoie cette 
        arborescence à la bibliothèque de la copie de travail, qui 
        écrit alors une copie de travail complète sur le disque (les 
        répertoires <filename>.svn</filename> et tout le reste).</para>

      <para>La bibliothèque client est conçue pour être utilisée par 
        n'importe quelle application. Alors que le code source de 
        Subversion inclut un client standard en ligne de commande, le 
        but recherché est qu'il soit très facile d'écrire un nombre 
        quelconque de clients dotés d'un environnement graphique 
        (<foreignphrase>GUI</foreignphrase> en anglais) par-dessus 
        cette bibliothèque client. Il n'y a pas de raison que les 
        nouveaux environnements graphiques (ou les nouveaux clients en
        fait) pour Subversion ne soient que des sur-couches au client 
        en ligne de commande&nbsp;: ils ont un accès total, via 
        l'API <filename>libsvn_client</filename>, aux mêmes 
        fonctionnalités, données et autres mécanismes que le client en 
        ligne de commande utilise. En fait, le code source de Subversion 
        contient un petit programme en C (que vous pouvez trouver dans
        <filename>tools/examples/minimal_client.c</filename>) qui montre 
        comment utiliser en pratique l'API Subversion pour créer un 
        programme client simple.</para>

      <sidebar>
        <title>Un mot sur la pertinence d'utiliser directement les 
          bibliothèques</title>

        <para>Pourquoi utiliser directement 
          <filename>libsvn_client</filename> pour votre interface 
          graphique plutôt que d'encapsuler le programme en ligne de 
          commande&nbsp;? Non seulement c'est plus efficace, mais c'est 
          aussi plus pertinent. Un programme en ligne de commande 
          (tel que celui fourni avec Subversion) qui utilise la 
          bibliothèque client a besoin de traduire effectivement des 
          requêtes et des réponses contenues dans des variables en C en 
          un affichage lisible par l'utilisateur. Ce type de traduction 
          peut induire des pertes. C'est-à-dire que le programme 
          n'affiche peut-être pas l'ensemble des informations qu'il a 
          obtenues de l'API ou qu'il combine peut-être certaines 
          informations pour obtenir une représentation plus 
          compacte.</para>

        <para>Si vous encapsulez le programme en ligne de commande avec 
          un autre programme, cette sur-couche n'a accès qu'à des 
          informations déjà interprétées (et, comme nous venons de le 
          mentionner, potentiellement incomplètes) et elle doit une 
          nouvelle fois traduire ces informations vers son propre format 
          de représentation des données. À chaque couche d'encapsulation 
          supplémentaire, l'intégrité des données originales s'effrite 
          un peu plus, à la manière d'une copie de copie (de copie 
          &hellip;) d'une cassette audio ou vidéo.</para>
 
        <para>Mais l'argument décisif quant à l'utilisation directe des 
          API plutôt que d'encapsuler d'autres programmes est que le 
          projet Subversion assure la compatibilité vis-à-vis de ses 
          API. Lors des changements de version mineure des API (comme 
          par exemple entre la version 1.3 et 1.4), aucun prototype de 
          fonction ne change. En d'autres termes, vous n'êtes pas forcé 
          de mettre à jour le code source de votre programme simplement 
          parce que vous avez mis à jour votre version de Subversion. 
          Certaines fonctions seront peut-être obsolètes, mais elles 
          fonctionneront toujours. Ainsi, cela vous laisse de la marge 
          pour éventuellement adopter les nouvelles API. Ce type de 
          promesse de compatibilité n'existe pas pour les sorties du 
          programme Subversion en ligne de commande, qui sont 
          susceptibles de changer à chaque version.</para>

      </sidebar>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.developer.insidewc">
    <title>Au cœur de la zone d'administration de la copie locale</title>
    
    <para>Comme nous l'avons déjà mentionné, chaque répertoire d'une 
      copie de travail Subversion contient un sous-répertoire spécial 
      nommé <filename>.svn</filename> qui héberge les données 
      administratives concernant le répertoire de la copie de travail. 
      Subversion utilise <filename>.svn</filename> pour gérer des 
      informations telles que&nbsp;:</para>

    <itemizedlist>
      <listitem>
        <para>à quel emplacement du dépôt les fichiers et les 
          sous-répertoires du répertoire de la copie de travail
          font référence&nbsp;;</para>
      </listitem>
      <listitem>
        <para>quelle révision de chacun de ces fichiers et répertoires 
          est présente dans la copie de travail&nbsp;;</para>
      </listitem>
      <listitem>
        <para>toute propriété définie et associée par l'utilisateur à 
          ces fichiers et répertoires&nbsp;;</para>
      </listitem>
      <listitem>
        <para>une copie locale originale des fichiers de la copie de 
          travail.</para>
      </listitem>
    </itemizedlist>

    <para>L'agencement et le contenu de la zone d'administration de la 
      copie de travail Subversion sont considérés comme des détails de 
      l'implémentation non-destinés à être exploités par les utilisateurs. 
      Nous encourageons les développeurs à utiliser les API publiques ou 
      les outils fournis avec Subversion pour accéder aux données de la 
      copie de travail et pour les manipuler, plutôt que de lire et 
      modifier directement ces fichiers. Les formats de fichiers 
      employés par la bibliothèque de la copie de travail pour gérer les 
      données administratives changent de temps en temps et l'API 
      publique réalise un gros travail pour que l'utilisateur moyen ne 
      s'en rende pas compte. Dans cette section, nous abordons crûment 
      certains détails de l'implémentation pour satisfaire votre 
      insatiable curiosité.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.insidewc.entries">
      <title>Le fichier <quote>entries</quote></title>

      <para>Le fichier <filename>entries</filename> est sûrement LE 
        fichier le plus important du répertoire 
        <filename>.svn</filename>. Il contient l'essentiel des 
        informations administratives concernant les éléments suivis en 
        versions du répertoire de la copie de travail. Ce fichier 
        contient l'URL du dépôt, le numéro de révision original, les 
        sommes de contrôle des fichiers, les horodatages des copies 
        originales et des propriétés, les informations d'état sur les 
        conflits et les actions planifiées, les dernières informations 
        connues sur les propagations (auteur, numéro de révision et 
        horodatage) et l'historique de la copie locale&nbsp;: 
        pratiquement tout ce qui intéresse un client Subversion à propos 
        d'un élément suivi (ou à suivre) en versions&nbsp;!</para>

      <para>Les lecteurs familiers avec les répertoires administratifs 
        de CVS auront tout de suite reconnu que le fichier 
        <filename>.svn/entries</filename> a les mêmes objectifs, entre 
        autres choses, que l'ensemble des fichiers
         <filename>CVS/Entries</filename>,
        <filename>CVS/Root</filename> et
        <filename>CVS/Repository</filename> combinés.</para>

      <para>Le format du fichier <filename>.svn/entries</filename> a 
        changé au cours du temps. Au départ, c'était un fichier 
        XML&nbsp;; aujourd'hui, il utilise un format personnalisé mais 
        toujours lisible par l'utilisateur. Le choix d'XML était 
        particulièrement adapté pour les premiers développeurs de 
        Subversion qui déboguaient fréquemment le contenu du fichier (et 
        le comportement associé de Subversion). Cependant, le besoin de 
        débogage a diminué au fur et à mesure que Subversion devenait 
        plus mature et le besoin de performance au profit de 
        l'utilisateur a alors pris le dessus. Soyez conscient que la 
        bibliothèque Subversion de la copie de travail met 
        automatiquement à niveau les copies de travail d'un format à un 
        autre &mdash; elle comprend les vieux formats et utilise pour 
        l'écriture le nouveau format &mdash; ce qui vous épargne 
        l'effort d'extraire une nouvelle copie de travail mais peut 
        aussi compliquer certaines situations&nbsp;: lorsque différentes 
        versions de Subversion essaient de partager la même copie de 
        travail.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.insidewc.base-and-props">
      <title>Copies originales et propriétés des fichiers</title>

      <para>Comme mentionné auparavant, le répertoire 
        <filename>.svn</filename> contient aussi les copies originales 
        (avant modification locale) des fichiers&nbsp;: les 
        <quote>versions de base</quote> (<foreignphrase>text-base 
        versions</foreignphrase> en anglais). Vous pouvez les trouver 
        dans le répertoire <filename>.svn/text-base</filename>. Ces 
        copies originales offrent tout un tas d'avantages &mdash; 
        identification des différences et des modifications, retour en 
        arrière sur les fichiers modifiés ou supprimés, tout cela sans 
        faire appel au réseau&nbsp;; échanges plus performants avec le 
        serveur &mdash; mais au prix d'avoir chaque fichier stocké au 
        moins en double sur le disque. De nos jours, c'est pratiquement 
        négligeable pour la majorité des fichiers. Cependant, la 
        situation se détériore à mesure que vos fichiers suivis en 
        versions grossissent. Nous étudions dorénavant la possibilité de 
        rendre optionnelle la présence de ces <quote>versions de 
        base</quote>. Cependant, c'est justement quand vos fichiers 
        suivis en versions grossissent que l'existence des 
        <quote>versions de base</quote> devient cruciale&nbsp;: qui a 
        envie de transmettre un énorme fichier à travers le réseau juste 
        parce qu'il veut propager une petite modification&nbsp;?</para>

      <para>Dans le même esprit que les fichiers <quote>versions de 
        base</quote>, nous avons les fichiers de propriétés qui, eux 
        aussi, possèdent leurs copies originales <quote>propriétés en 
        version de base</quote>, situés respectivement dans 
        <filename>.svn/props</filename> et 
        <filename>.svn/prop-base</filename>. Comme les répertoires aussi 
        peuvent avoir des propriétés, il existe également des fichiers 
        <filename>.svn/dir-props</filename> et 
        <filename>.svn/dir-prop-base</filename>.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.developer.usingapi">
    <title>Utiliser les API</title>

    <para>Développer des applications utilisant les API des 
      bibliothèques Subversion est plutôt simple. Subversion est d'abord 
      un ensemble de bibliothèques en langage C, avec des fichiers 
      d'en-têtes (<filename>.h</filename>) situés dans le répertoire 
      <filename>subversion/include</filename> de l'arborescence des 
      sources. Ces en-têtes sont copiés dans votre arborescence système 
      (par exemple <filename>/usr/local/include</filename>)
      quand vous compilez et installez Subversion à partir des sources. 
      Ces en-têtes contiennent l'ensemble des fonctions et des types 
      censés être accessibles aux utilisateurs des bibliothèques 
      Subversion. La communauté des développeurs Subversion apporte 
      beaucoup d'attention à la disponibilité et la qualité de la 
      documentation des API publiques &mdash; reportez-vous directement 
      aux fichiers d'en-têtes pour cette documentation.</para>

    <para>Quand vous examinez les fichiers d'en-tête publics, la 
      première chose que vous remarquez est que les types de données 
      et les fonctions ont un espace de nommage réservé. Cela veut dire 
      que tous les noms de symboles Subversion publics commencent par 
      <literal>svn_</literal>, suivi d'un code indiquant la bibliothèque 
      dans laquelle le symbole est défini (par exemple 
      <literal>wc</literal>, <literal>client</literal>, 
      <literal>fs</literal>,&nbsp;etc.), suivi d'un unique caractère 
      souligné (<literal>_</literal>) puis du reste du nom du symbole. Les 
      fonctions semi-publiques (utilisées par plusieurs fichiers au sein 
      d'une bibliothèque mais pas par du code extérieur à cette 
      bibliothèque, on peut les trouver au sein des répertoires de la 
      bibliothèque) suivent une règle de nommage légèrement différente 
      dans le sens où, au lieu d'un unique caractère souligné 
      après le code indiquant la bibliothèque, elles utilisent deux 
      caractères souligné consécutifs (<literal>_&thinsp;_</literal>). 
      Les fonctions qui sont propres à un fichier source (c'est-à-dire 
      privées) n'ont pas de préfixe particulier et sont déclarées avec 
      le mot-clé <literal>static</literal>. Bien sûr, un compilateur n'a 
      que faire de ces conventions de nommage, mais elles sont une aide 
      précieuse pour clarifier la portée d'une fonction ou d'un type de 
      données particuliers.</para>

    <para>Une autre bonne source d'informations sur la programmation 
      avec les API Subversion est constituée par les bonnes pratiques de 
      programmation au sein du projet lui-même, que vous pouvez trouver 
      à l'adresse suivante <ulink
      url="http://subversion.apache.org/docs/community-guide/" /> (pages 
      en anglais). Ce document contient des informations 
      particulièrement utiles qui, bien que destinées aux développeurs 
      (ou aux personnes désireuses de le devenir) de Subversion 
      lui-même, peuvent également servir à tous ceux qui 
      développent des applications utilisant Subversion comme 
      bibliothèque tierce
      <footnote>
        <para>Après tout, Subversion utilise aussi les API 
          Subversion.</para>
      </footnote>.
    </para>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.usingapi.apr">
      <title>APR, la bibliothèque Apache de portabilité des exécutables</title>

      <para>À côté des types de données propres à Subversion, vous 
        trouverez de nombreuses références à des types de données qui 
        commencent par <literal>apr_</literal>&nbsp;: ce sont les 
        symboles de la bibliothèque pour la portabilité d'Apache 
        (<foreignphrase>Apache Portable Runtime</foreignphrase> en 
        anglais, soit APR). APR est un jeu de bibliothèques Apache,
        originellement extraites du code source du serveur 
        pour essayer de séparer ce qui dépendait du système 
        d'exploitation de ce qui n'en dépendait pas. Au final, on 
        obtient une bibliothèque qui fournit une API permettant 
        d'effectuer des opérations qui changent un peu (ou beaucoup) en 
        fonction du système d'exploitation. Alors que le serveur HTTP 
        Apache était le premier utilisateur (et pour cause) de la 
        bibliothèque APR, les développeurs Subversion ont immédiatement 
        perçu les avantages qu'il y a à utiliser APR. Cela signifie 
        qu'il n'y a pratiquement aucun code spécifique à un système 
        d'exploitation dans Subversion en tant que tel. Cela veut aussi 
        dire que le client Subversion peut être compilé et exécuté 
        partout où un serveur Apache peut l'être. Actuellement, cette 
        liste comprend toutes les variantes d'Unix, Win32, BeOS, OS/2 et 
        Mac OS X.</para>

      <para>En plus de fournir des implémentations fiables des appels 
        systèmes qui diffèrent d'un système d'exploitation à l'autre
        <footnote>
          <para>Subversion utilise les appels système et les types de 
            données ANSI autant que possible.</para>
        </footnote>,
        APR fournit à Subversion un accès direct à de nombreux types de 
        données personnalisés tels que les tableaux dynamiques et les 
        tables de hachage. Subversion utilise abondamment ces types de 
        données et le type de données APR le plus utilisé, que l'on 
        retrouve dans presque tous les prototypes de l'API Subversion, 
        est <literal>apr_pool_t</literal> &mdash; le réservoir de 
        mémoire (<foreignphrase>memory pool</foreignphrase> en anglais) 
        APR. Subversion utilise les réservoirs de mémoire 
        en interne pour tous ses besoins d'allocation mémoire 
        (à moins qu'une bibliothèque externe ne requière 
        un autre mécanisme de gestion de la mémoire pour les 
        données transmises via son API)
        <footnote>
          <para>Neon et Berkeley DB par exemple.</para>
        </footnote>
        et, bien qu'une personne qui utilise l'API Subversion ne soit 
        pas obligée d'en faire autant, elle doit fournir des réservoirs 
        aux fonctions de l'API qui en ont besoin. Cela implique que les 
        utilisateurs de l'API Subversion <emphasis>doivent</emphasis> 
        également inclure l'APR lors de l'édition de liens, doivent 
        appeler <function>apr_initialize()</function> pour initialiser 
        le sous-système APR et doivent ensuite créer et gérer des 
        réservoirs de mémoire pour les appels à l'API Subversion, 
        généralement en utilisant <function>svn_pool_create()</function>,
        <function>svn_pool_clear()</function> et
        <function>svn_pool_destroy()</function>.</para>

      <sidebar>
        <title>Programmer avec les réservoirs de mémoire</title>

        <para>Presque tous les développeurs qui ont essayé le langage C 
          se sont heurtés à la tâche dantesque de gestion de la mémoire. 
          Allouer suffisamment de mémoire pour l'exécution, garder une 
          trace de ces allocations, libérer la mémoire quand elle n'est 
          plus utilisée &mdash; ces tâches peuvent devenir 
          particulièrement complexes. Et, bien sûr, si cette gestion est 
          mal faite, cela peut conduire à un plantage du programme, 
          voire de l'ordinateur.</para>

        <para>Les langages de plus haut niveau, quant à eux, soit vous 
          débarrassent complètement de cette tâche, soit vous laissent 
          jouer avec uniquement quand vous faites des optimisations 
          particulièrement pointues de votre programme. Des langages 
          tels que Java ou Python utilisent un 
          <firstterm>ramasse-miettes</firstterm> 
          (<foreignphrase>garbage collector</foreignphrase> en anglais)
          qui alloue de la mémoire aux objets en cas de besoin et la 
          libère automatiquement quand l'objet n'est plus utilisé.</para>

        <para>APR fournit une approche à mi-chemin appelée 
          <firstterm>gestion de mémoire par réservoir</firstterm>. Cela 
          permet au développeur de contrôler l'utilisation de la mémoire 
          à une résolution plus faible &mdash; par morceau (dit 
          <quote>réservoir</quote>) de mémoire au lieu d'une gestion par 
          objet. Plutôt que d'utiliser <function>malloc()</function> et 
          compagnie pour allouer la mémoire à un objet donné, vous 
          demandez à APR d'allouer de la mémoire à l'intérieur d'un 
          réservoir de mémoire. Quand vous avez fini d'utiliser les 
          objets que vous avez créés dans un réservoir, vous détruisez 
          le réservoir tout entier, ce qui libère effectivement la 
          mémoire consommée par <emphasis>tous</emphasis> les objets 
          alloués. Ainsi, plutôt que de gérer individuellement la 
          mémoire qui doit être allouée et libérée pour chaque objet, 
          votre programme n'a plus qu'à se préoccuper de la durée de vie 
          globale des objets et alloue ces objets dans un réservoir dont 
          la durée de vie (le temps entre la création et la suppression 
          du dit réservoir) correspond aux besoins des objets.</para>

      </sidebar>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.usingapi.urlpath">
      <title>Prérequis pour les URL et les chemins</title>

      <para>Subversion a été conçu pour effectuer à distance des 
        opérations de gestion de versions. À ce titre, les possibilités 
        d'internationalisation (i18n) ont fait l'objet d'une attention 
        toute particulière. Après tout, <quote>à distance</quote> peut 
        vouloir dire depuis un ordinateur situé <quote>dans le même 
        bureau</quote>, mais aussi <quote>à l'autre bout de la 
        planète</quote>. Pour faciliter cette prise en compte, toutes 
        les interfaces publiques de Subversion qui acceptent des chemins 
        comme argument s'attendent à ce que ces chemins soient rendus 
        canoniques &mdash; la façon la plus facile de le faire étant de 
        les passer en argument à la fonction 
        <function>svn_path_canonicalize()</function> &mdash; et codés 
        dans le format UTF-8. Cela signifie, par exemple, que tout 
        nouveau programme client qui pilote l'interface 
        <filename>libsvn_client</filename> doit d'abord convertir les 
        chemins depuis le codage local vers UTF-8 avant de fournir ces 
        chemins à la bibliothèque Subversion, puis doit reconvertir tout 
        chemin renvoyé par Subversion vers le codage local avant 
        d'utiliser ce chemin à des fins externes à Subversion. 
        Heureusement, Subversion fournit un ensemble de fonctions (voir
        <filename>subversion/include/svn_utf.h</filename>) que tout 
        programme peut utiliser pour réaliser ces conversions.</para>

      <para>De plus, les API Subversion demandent que toutes les URL 
        passées en paramètres respectent le format URI. Ainsi, au lieu 
        de désigner par <uri>file:///home/utilisateur/Mon fichier.txt</uri> 
        l'URL d'un fichier nommé <filename>Mon fichier.txt</filename> 
        situé dans le répertoire <filename>home/utilisateur</filename>, 
        vous devez utiliser 
        <uri>file:///home/utilisateur/Mon%20fichier.txt</uri>. Là 
        encore, Subversion fournit des fonctions utiles à votre 
        application &mdash; <function>svn_path_uri_encode()</function> 
        et <function>svn_path_uri_decode()</function> pour coder et 
        décoder, respectivement, des URI.</para> </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.usingapi.otherlangs">
      <title>Utiliser d'autres langages que C et C++</title> 

      <para>Si vous désirez utiliser les bibliothèques Subversion à 
        partir d'un autre langage que le C (par exemple un programme 
        Python ou Perl), Subversion offre cette possibilité via le 
        générateur simplifié d'interface et d'encapsulation 
        (<foreignphrase>Simplified Wrapper and Interface 
        Generator</foreignphrase> ou SWIG en anglais). 
        Les interfaces SWIG de Subversion sont situées 
        dans le répertoire <filename>subversion/bindings/swig</filename>. 
        Elles sont toujours en cours d'évolution mais sont utilisables. 
        Elles vous permettent d'appeler les fonctions de l'API 
        Subversion indirectement, en utilisant des interfaces qui 
        traduisent les types de données natifs de votre langage de 
        programmation vers les types de données utilisés par les 
        bibliothèques C de Subversion.</para>

      <para>Des efforts significatifs ont été fournis pour produire des 
        interfaces SWIG pleinement fonctionnelles pour Python, Perl et 
        Ruby. D'une certaine manière, le travail effectué pour réaliser 
        les interfaces vers ces langages est réutilisable pour produire 
        des interfaces vers d'autres langages supportés par SWIG (ce qui 
        inclut, entre autres, des versions de C#, Guile, Java, MzScheme, 
        OCaml, PHP et Tcl). Cependant, vous aurez besoin d'un peu de 
        programmation supplémentaire pour aider SWIG à faire les 
        traductions entre les langages pour les API complexes. Pour plus 
        d'informations sur SWIG lui-même, visitez le site Web du projet 
        à l'adresse suivante&nbsp;: <ulink
        url="http://www.swig.org/"/> (site en anglais).</para>

      <para>Subversion fournit également une interface vers le langage 
        Java. L'interface javahl (située dans 
        <filename>subversion/bindings/java</filename> dans 
        l'arborescence des sources Subversion) n'est pas basée sur SWIG 
        mais est un mélange de Java et de JNI codé à la main. Javahl 
        couvre le plus gros des API du client Subversion et se destine 
        principalement aux développeurs d'environnements de 
        développement intégrés (IDE) et de clients Subversion en 
        Java.</para>

      <para>Les interfaces Subversion vers les langages de programmation 
        ne sont pas suivies avec le même niveau d'exigence que les 
        modules du cœur de Subversion, mais peuvent généralement être 
        utilisées en production. De nombreuses applications, de nombreux 
        scripts, des clients graphiques alternatifs et des outils 
        tiers utilisent aujourd'hui sans problème les interfaces vers 
        les langages de programmation afin d'intégrer les 
        fonctionnalités de Subversion.</para>

      <para>Veuillez tout de même noter qu'il existe d'autres options 
        pour s'interfacer avec Subversion dans d'autres langages&nbsp;: 
        les interfaces pour Subversion qui ne sont pas fournies par la 
        communauté de développement Subversion. Vous pouvez trouver des 
        liens vers ces interfaces alternatives sur la page de liens 
        externes du projet Subversion (à l'adresse <ulink
        url="http://subversion.tigris.org/links.html" />) et, en 
        particulier, nous accordons une mention spéciale à deux d'entre 
        elles. D'abord, l'interface PySVN de Barry Scott (<ulink
        url="http://pysvn.tigris.org/" />) est une interface reconnue 
        vers Python. PySVN se targue d'une interface plus 
        <quote>pythonique</quote> que les API <quote>orientées C</quote> 
        fournies par l'interface standard de Subversion vers Python. Et 
        si vous recherchez une implémentation 100&nbsp;% Java de Subversion, 
        jetez un œil à SVNKit (<ulink
        url="http://svnkit.com/" />), qui est une ré-écriture complète 
        de Subversion en Java.</para>

      <sidebar>
        <title>SVNKit ou javahl&nbsp;?</title>

        <para>En 2005, une petite entreprise du nom de TMate annonçait 
          la sortie de la version 1.0.0 de JavaSVN &mdash; une 
          implémentation 100&nbsp;% Java de Subversion. Depuis, le 
          projet a été renommé en SVNKit (disponible sur le site 
          <ulink url="http://svnkit.com/" />) et connaît un grand succès 
          en étant intégré dans de nombreux clients Subversion, IDE ou 
          autres outils tiers.</para>

        <para>La bibliothèque SVNKit est intéressante dans le sens où, 
          contrairement à la bibliothèque javahl, elle ne se contente 
          pas d'encapsuler les bibliothèques officielles du cœur de 
          Subversion. En fait, elle ne partage aucun code avec 
          Subversion. Cependant, bien qu'il soit facile de confondre 
          SVNKit et javahl, et même encore plus facile de ne pas savoir 
          laquelle de ces bibliothèques vous utilisez, vous devez être 
          conscient que SVNKit diffère de javahl sur certains points 
          particulièrement importants. D'abord, SVNKit n'est pas un 
          logiciel libre et il semble qu'il ne soit développé que par 
          une équipe de quelques personnes. La licence de SVNKit est 
          aussi plus restrictive que celle de Subversion. Enfin, en 
          voulant être une bibliothèque Subversion écrite uniquement en 
          Java, SVNKit est limité dans sa capacité à cloner les 
          fonctionnalités de Subversion au fur et à mesure de la sortie 
          de nouvelles versions de ce dernier. Ce problème est déjà 
          apparu une fois&nbsp;: SVNKit ne peut pas accéder à des dépôts 
          Subversion utilisant une base de données BDB via le protocole 
          <literal>file://</literal> car il n'existe pas 
          d'implémentation 100&nbsp;% Java de Berkeley&nbsp;DB qui soit 
          compatible avec le format de fichier de l'implémentation 
          native de cette bibliothèque.</para>

        <para>Ceci dit, SVNKit est unanimement reconnu pour sa 
          fiabilité. Et une solution 100&nbsp;% Java est beaucoup plus 
          robuste vis-à-vis des erreurs de programmation&nbsp;: un 
          bogue dans SVNKit génère une exception Java que vous pouvez 
          intercepter, tandis qu'un bogue dans une bibliothèque du cœur 
          de Subversion utilisée par javahl peut mettre par terre tout 
          votre environnement d'exécution Java. En conclusion, pesez le 
          pour et le contre avant de choisir une implémentation en Java 
          de Subversion.</para>

      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.usingapi.codesamples">
      <title>Exemples de code</title> 

      <para>L'<xref linkend="svn.developer.layerlib.repos.ex-1" />
        contient un bout de code (écrit en C) qui illustre plusieurs 
        concepts que nous venons d'aborder. Il utilise à la fois 
        l'interface du dépôt et celle du système de fichiers (comme 
        dénoté par les préfixes <literal>svn_repos_</literal> et
        <literal>svn_fs_</literal> des noms de fonctions) pour créer une 
        nouvelle révision dans laquelle un répertoire est ajouté. Vous 
        pouvez y observer l'utilisation du réservoir de mémoire APR qui 
        est utilisé pour les besoins d'allocation mémoire. En outre, le 
        code révèle le côté obscur de la gestion des erreurs de 
        Subversion&nbsp;: toutes les erreurs Subversion doivent être 
        explicitement prises en compte pour éviter des fuites de mémoire 
        (et dans certains cas, le plantage de l'application).</para>

      <example id="svn.developer.layerlib.repos.ex-1">
        <title>Utilisation de la couche dépôt</title>

        <programlisting>
/* Convertit une erreur Subversion en un simple code d'erreur booléen
 *
 * NOTE:  Les erreurs Subversion doivent être effacées (en utilisant 
 *        svn_error_clear()) parce qu'elles sont allouées depuis le 
 *        réservoir global, sinon cela produit une fuite de mémoire.
 */
#define INT_ERR(expr)                           \
  do {                                          \
    svn_error_t *__temperr = (expr);            \
    if (__temperr)                              \
      {                                         \
        svn_error_clear(__temperr);             \
        return 1;                               \
      }                                         \
    return 0;                                   \
  } while (0)

/* Crée un nouveau répertoire NOUVEAU_REP dans le dépôt Subversion
 * situé à CHEMIN_DEPOT. Effectue toutes les allocations mémoire dans
 * RESERVOIR. Cette fonction créera une nouvelle révision pour l'ajout
 * de NOUVEAU_REP. Elle retourne zéro si l'opération se termine 
 * correctement, une valeur différente de zéro sinon.
 */
static int
cree_nouveau_rep(const char *chemin_depot,
                 const char *nouveau_rep,
                 apr_pool_t *reservoir)
{
  svn_error_t *err;
  svn_repos_t *depot;
  svn_fs_t *fs;
  svn_revnum_t derniere_rev;
  svn_fs_txn_t *transaction;
  svn_fs_root_t *racine_transaction;
  const char *chaine_conflit;

  /* Ouvre le dépôt situé à chemin_depot. 
   */
  INT_ERR(svn_repos_open(&amp;depot, chemin_depot, reservoir));

  /* Obtient un pointeur sur l'objet du système de fichiers qui est 
   * stocké dans CHEMIN_DEPOT. 
   */
  fs = svn_repos_fs(depot);

  /* Demande au système de fichiers de nous fournir le numéro de la 
   * révision la plus récente.
   */
  INT_ERR(svn_fs_youngest_rev(&amp;derniere_rev, fs, reservoir));

  /* Commence une nouvelle transaction qui est basée sur DERNIERE_REV.
   * Nous aurons moins de chance de voir notre propagation rejetée pour
   * cause de conflit si nous effectuons toujours nos changements à partir du 
   * dernier instantané de l'arborescence du système de fichiers.
   */
  INT_ERR(svn_repos_fs_begin_txn_for_commit2(&amp;transaction, depot, 
                                             derniere_rev,
                                             apr_hash_make(reservoir), 
                                             reservoir));

  /* Maintenant qu'une nouvelle transaction Subversion est commencée, 
   * obtient l'objet racine qui représente cette transaction.
   */
  INT_ERR(svn_fs_txn_root(&amp;racine_transaction, transaction, reservoir));
  
  /* Crée un nouveau répertoire sous la racine de la transaction, au 
   * chemin NOUVEAU_REP. 
   */
  INT_ERR(svn_fs_make_dir(racine_transaction, nouveau_rep, reservoir));

  /* Propage la transaction, créant une nouvelle révision du système de 
   * fichiers incluant le nouveau répertoire.
   */
  err = svn_repos_fs_commit_txn(&amp;chaine_conflit, depot, 
                                &amp;derniere_rev, transaction, reservoir);
  if (! err)
    {
      /* Pas d'erreur ? Excellent ! Indique brièvement la réussite 
       * de l'opération.
       */
      printf("Le répertoire '%s' a été ajouté en tant que nouvelle "
             "révision '%ld'.\n", nouveau_rep, derniere_rev);
    }
  else if (err->apr_err == SVN_ERR_FS_CONFLICT)
    {
      /* Oh-oh. La propagation a échoué pour cause de conflit (il semble
       * que quelqu'un d'autre a effectué des changements dans la même
       * zone du système de fichiers que celle que nous avons essayé de
       * modifier). Affiche un message d'erreur.
       */
      printf("Un conflit s'est produit pour le chemin '%s' lors de"
             " l'ajout du répertoire '%s' au dépôt '%s'.\n", 
             chaine_conflit, nouveau_rep, chemin_depot);
    }
  else
    {
      /* Une autre erreur s'est produite. Affiche un message d'erreur.
       */
      printf("Une erreur s'est produite lors de l'ajout du "
             "répertoire '%s' au dépôt '%s'.\n", 
             nouveau_rep, chemin_depot);
    }

  INT_ERR(err);
} 
</programlisting>
      </example>

      <para>Notez que dans l'<xref
        linkend="svn.developer.layerlib.repos.ex-1" />, le code aurait 
        tout aussi bien pu propager la transaction en utilisant 
        <function>svn_fs_commit_txn()</function>. Mais l'API du système 
        de fichiers ignore tout des mécanismes de procédures 
        automatiques de la bibliothèque du dépôt. Si vous voulez que 
        votre dépôt Subversion effectue automatiquement certaines tâches 
        externes à Subversion chaque fois qu'une transaction est 
        propagée (par exemple envoyer un mail qui décrit les changements 
        effectués dans la transaction à la liste de diffusion des 
        développeurs), vous devez utiliser la version de la fonction 
        encapsulée dans <filename>libsvn_repos</filename> qui ajoute la 
        fonctionnalité d'activation des procédures automatiques&nbsp;: 
        <function>svn_repos_fs_commit_txn()</function> (pour davantage 
        d'informations sur les procédures automatiques des dépôts 
        Subversion, consultez <xref
        linkend="svn.reposadmin.create.hooks" />).</para>

      <para>Maintenant, changeons de langage. L'<xref
        linkend="svn.developer.usingapi.otherlangs.ex-1" /> est un 
        programme de démonstration qui utilise l'interface SWIG vers 
        Python pour parcourir récursivement la dernière révision du 
        dépôt et afficher les différents chemins trouvés lors de ce 
        parcours.</para>

      <example id="svn.developer.usingapi.otherlangs.ex-1">
        <title>Utilisation de la couche dépôt en Python</title>

        <programlisting>
#!/usr/bin/python

"""Parcourir un dépôt en affichant les chemins des objets suivis en
versions."""

import sys
import os.path
import svn.fs, svn.core, svn.repos

def parcourir_rep_systemedefichiers(racine, repertoire):
    """Parcourt récursivement le REPERTOIRE situé sous RACINE dans le 
       système de fichiers. Renvoie la liste de tous les chemins sous et 
       de REPERTOIRE."""

    # Affiche le nom de ce chemin.
    print repertoire + "/"
    
    # Obtient les entrées du répertoire REPERTOIRE.
    entrees = svn.fs.svn_fs_dir_entries(racine, repertoire)

    # Pour chaque entrée
    noms = entrees.keys()
    for nom in noms:
        # Calcule le chemin complet de l'entrée.
        chemin_complet = repertoire + '/' + nom

        # Si l'entrée est un répertoire, effectue une récursion. La
        # récursion retournera une liste comprenant l'entrée et tous ses
        # enfants, que l'on ajoutera à notre liste.
        if svn.fs.svn_fs_is_dir(racine, chemin_complet):
            parcourir_rep_systemedefichiers(racine, chemin_complet)
        else:
            # Sinon, c'est un fichier donc l'afficher maintenant.
            print chemin_complet

def parcourir_la_plus_recente_revision(chemin_depot):
    """Ouvre le dépôt situé à CHEMIN_DEPOT et effectue un parcours 
       récursif de la révision la plus récente."""
    
    # Ouvre le dépôt situé à CHEMIN_DEPOT et obtient une référence de
    # son système de fichiers suivi en versions.
    objet_depot = svn.repos.svn_repos_open(chemin_depot)
    objet_fs = svn.repos.svn_repos_fs(objet_depot)

    # Obtient la révision la plus récente (HEAD).
    rev_la_plus_recente = svn.fs.svn_fs_youngest_rev(objet_fs)
    
    # Ouvre un objet racine représentant la révision la plus récente.
    objet_racine = svn.fs.svn_fs_revision_root(objet_fs, 
                                               rev_la_plus_recente)

    # Effectue le parcours récursif.
    parcourir_rep_systemedefichiers(objet_racine, "")
    
if __name__ == "__main__":
    # Vérifie que l'on est appelé correctement.
    if len(sys.argv) != 2:
        sys.stderr.write("Usage: %s CHEMIN_DEPOT\n"
                         % (os.path.basename(sys.argv[0])))
        sys.exit(1)

    # Transforme la chaîne en chemin canonique.
    chemin_depot = svn.core.svn_path_canonicalize(sys.argv[1])

    # Et c'est parti !
    parcourir_la_plus_recente_revision(chemin_depot)
</programlisting>
      </example>

      <para>Le même programme en C aurait besoin de faire appel aux 
        réservoirs de mémoire d'APR. Mais Python gère l'utilisation de 
        la mémoire automatiquement et l'interface Subversion vers Python 
        se plie à cette convention. En C, vous auriez utilisé des types 
        de données personnalisés (tels que ceux fournis par la 
        bibliothèque APR) pour représenter la table de hachage des 
        entrées et la liste des chemins, mais Python sait gérer 
        nativement les tables de hachage (appelés 
        <quote>dictionnaires</quote>) ainsi que les listes et possède 
        une riche collection de fonctions pour travailler sur ces types 
        de données. C'est pourquoi SWIG (avec l'aide de la couche 
        d'interface vers les langages de programmation de Subversion, un 
        peu modifiée) prend soin de faire correspondre ces types de 
        données personnalisés aux types de données natifs du langage 
        cible. On obtient ainsi une interface plus intuitive pour les 
        utilisateurs de ce langage.</para>

      <para>L'interface de Subversion vers Python peut également être 
        utilisée pour effectuer des opérations dans la copie de travail. 
        Dans la section précédente de ce chapitre, nous avons mentionné 
        l'interface <filename>libsvn_client</filename> et le fait 
        qu'elle a été conçue dans le seul but de faciliter l'écriture 
        d'un client Subversion. L'<xref
        linkend="svn.developer.usingapi.otherlangs.ex-2" /> est un court 
        exemple d'utilisation de cette bibliothèque via l'interface 
        Python SWIG pour re-créer une version à petite échelle de la 
        commande <command>svn status</command>.</para>

      <example id="svn.developer.usingapi.otherlangs.ex-2">
        <title>Une version de status en Python</title>

        <programlisting>
#!/usr/bin/env python

"""Parcourir un répertoire d'une copie de travail en affichant les 
informations d'état."""

import sys
import os.path
import getopt
import svn.core, svn.client, svn.wc

def generer_code_etat(etat):
    """Traduit la valeur d'état vers un code à un caractère en 
    utilisant la même logique que le client Subversion en ligne de 
    commande."""
    association_etat = { svn.wc.svn_wc_status_none        : ' ',
                         svn.wc.svn_wc_status_normal      : ' ',
                         svn.wc.svn_wc_status_added       : 'A',
                         svn.wc.svn_wc_status_missing     : '!',
                         svn.wc.svn_wc_status_incomplete  : '!',
                         svn.wc.svn_wc_status_deleted     : 'D',
                         svn.wc.svn_wc_status_replaced    : 'R',
                         svn.wc.svn_wc_status_modified    : 'M',
                         svn.wc.svn_wc_status_merged      : 'G',
                         svn.wc.svn_wc_status_conflicted  : 'C',
                         svn.wc.svn_wc_status_obstructed  : '~',
                         svn.wc.svn_wc_status_ignored     : 'I',
                         svn.wc.svn_wc_status_external    : 'X',
                         svn.wc.svn_wc_status_unversioned : '?',
               }
    return association_etat.get(etat, '?')

def trouver_etat(chemin_copie_travail, verbeux):
    # Construit le "bâton" de contexte client.
    ctx = svn.client.svn_client_ctx_t()

    def _status_callback(path, etat):
        """Une fonction de renvoi ("callback") pour svn_client_status."""

        # Affiche le chemin, moins la partie déjà présente
        # dans la racine du parcours.
        text_status = generer_code_etat(etat.text_status)
        prop_status = generer_code_etat(etat.prop_status)
        print '%s%s  %s' % (text_status, prop_status, path)
        
    # Effectue le parcours des états, en utilisant _status_callback() 
    # comme fonction de renvoi ("callback").
    revision = svn.core.svn_opt_revision_t()
    revision.type = svn.core.svn_opt_revision_head
    svn.client.svn_client_status2(chemin_copie_travail, revision, 
                                  _status_callback, 
                                  svn.core.svn_depth_infinity, verbeux,
                                  0, 0, 1, ctx)

def utilisation_et_sortie(code_erreur):
    """Affiche le message d'utilisation et sort avec CODE_ERREUR."""
    stream = code_erreur and sys.stderr or sys.stdout
    stream.write("""Usage: %s OPTIONS CHEMIN_COPIE_TRAVAIL
Options:
  --help, -h    : Affiche ce message d'aide.
  --verbose, -v : Affiche l'état de tous les objets, sans exception.
""" % (os.path.basename(sys.argv[0])))
    sys.exit(code_erreur)
    
if __name__ == '__main__':
    # Analyse les options de la ligne de commande.
    try:
        opts, args = getopt.getopt(sys.argv[1:], "hv", ["help", "verbose"])
    except getopt.GetoptError:
        utilisation_et_sortie(1)
    verbeux = 0
    for opt, arg in opts:
        if opt in ("-h", "--help"):
            utilisation_et_sortie(0)
        if opt in ("-v", "--verbeux"):
            verbeux = 1
    if len(args) != 1:
        utilisation_et_sortie(2)
            
    # Transforme le chemin en chemin canonique.
    chemin_copie_travail = svn.core.svn_path_canonicalize(args[0])

    # Et c'est parti !
    try:
        trouver_etat(chemin_copie_travail, verbeux)
    except svn.core.SubversionException, e:
        sys.stderr.write("Erreur (%d): %s\n" % (e.apr_err, e.message))
        sys.exit(1)
</programlisting>
      </example>

      <para>Comme dans le cas de l'<xref
        linkend="svn.developer.usingapi.otherlangs.ex-1" />, ce 
        programme voit sa mémoire gérée automatiquement et utilise en 
        grande partie les types de données classiques de Python. L'appel 
        de <function>svn_client_ctx_t()</function> est un peu trompeur 
        parce que l'API publique de Subversion ne possède pas de telle 
        fonction &mdash; la génération automatique de fonctions de SWIG 
        ( une sorte d'usine à fonctions pour transformer des structures 
        C complexes vers un équivalent en Python) est à la peine. 
        Notez également que le chemin passé au programme 
        (tout comme dans le programme précédent) est mouliné par 
        <function>svn_path_canonicalize()</function> car, 
        <emphasis>dans le cas contraire</emphasis>, on s'expose à un 
        arrêt rapide et brutal du programme par la bibliothèque C 
        Subversion sous-jacente qui effectue des tests de 
        conformité.</para>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.developer.summary">
    <title>Résumé</title>

    <para>L'une des plus formidables caractéristiques de Subversion n'est 
      pas accessible avec le client en ligne de commande ou via d'autres 
      outils. C'est le fait que Subversion a été conçu pour être 
      modulaire et fournir une API publique stable de manière à ce que 
      des développeurs tiers &mdash; tel que vous, peut-être &mdash; 
      puissent écrire des logiciels qui pilotent les fonctionnalités du 
      cœur de Subversion.</para>

    <para>Dans ce chapitre, nous avons approfondi notre vision de 
      l'architecture de Subversion, examiné ses couches logiques et 
      décrit son API publique, celle-là même qu'utilisent les propres 
      couches de Subversion pour communiquer entre elles. De nombreux 
      développeurs ont imaginé des utilisations intéressantes de l'API 
      Subversion, de la simple procédure automatique jusqu'à des 
      systèmes de gestion de versions complètement différents, en passant 
      par l'intégration de Subversion dans d'autres applications. Et 
      <emphasis>vous</emphasis>, quelle utilisation originale en 
      tirerez-vous&nbsp;?</para>

  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
