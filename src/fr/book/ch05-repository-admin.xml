<chapter id="svn.reposadmin">
  <title>Administration d'un dépôt</title>

  <para>Le dépôt Subversion est le centre de stockage de toutes vos 
    données suivies en versions. Ainsi, il est de facto l'objet de toute 
    l'attention et de tous les soins de l'administrateur. Bien que ce 
    soit un élément ne nécessitant pas énormément de maintenance, il est 
    important de comprendre comment le configurer et le surveiller 
    correctement de manière à éviter d'éventuels problèmes et à résoudre 
    proprement ceux qui se présentent.</para>

  <para>Dans ce chapitre, nous verrons comment créer et configurer un 
    dépôt Subversion. Nous aborderons également la maintenance du dépôt, 
    en donnant des exemples d'utilisation des outils
    <command>svnlook</command> et <command>svnadmin</command> fournis 
    avec Subversion. Nous étudierons quelques questions et erreurs 
    communes et nous donnerons des conseils sur l'organisation des 
    données dans le dépôt.</para>

  <para>Si vous n'envisagez pas d'utiliser un dépôt Subversion autrement 
    qu'en simple utilisateur des données (c'est-à-dire en utilisant un 
    client Subversion), vous pouvez sauter ce chapitre. Cependant, si 
    vous êtes (ou si vous êtes appelé à être) l'administrateur d'un 
    dépôt
    <footnote>
      <para>Cela peut sembler prestigieux et noble, mais il s'agit juste 
        en fait d'une personne intéressée par le monde mystérieux qui se 
        cache derrière la copie de travail que chacun détient.</para>
    </footnote>, ce chapitre est fait pour vous.</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.basics">
    <title>Définition d'un dépôt Subversion</title>

    <para>Avant d'aborder le vaste sujet de l'administration d'un dépôt, 
      définissons plus précisément ce qu'est un dépôt. A quoi 
      ressemble-t-il ? Que ressent-il&nbsp;? Est-ce qu'il préfère son 
      thé chaud ou glacé, sucré, avec une tranche de citron&nbsp;? En 
      tant qu'administrateur, vous vous devez de comprendre de quoi est 
      composé un dépôt, à la fois au niveau du système d'exploitation 
      (à quoi ressemble le dépôt et comment il réagit vis-à-vis des 
      outils autres que Subversion) et au niveau logique de 
      l'organisation des données (comment elles sont représentées
      <emphasis>à l'intérieur</emphasis> du dépôt.</para>

    <para>Du point de vue d'un explorateur de fichiers classique (comme 
      Windows Explorer) ou d'un outil de navigation du système de 
      fichiers en ligne de commande, un dépôt Subversion n'est rien 
      d'autre qu'un répertoire contenant plein de choses. Il y a des 
      sous-répertoires avec des fichiers de configuration lisibles par 
      un humain, des sous-répertoires avec des fichiers de données 
      binaires déjà bien moins lisibles, etc. A l'instar d'autres 
      parties de Subversion, la modularité est une préoccupation majeure 
      et l'organisation hiérarchique prévaut sur le bazar. Un coup 
      d'oeil rapide dans un dépôt typique est suffisant pour obtenir la 
      liste des composants essentiels d'un dépôt&nbsp;:</para>
            
    <screen>
$ ls depot
conf/  dav/  db/  format  hooks/  locks/  README.txt
</screen>

    <para>Effectuons un survol rapide de ce que nous voyons dans ce 
      répertoire (ne vous inquiétez pas si vous ne comprenez pas tous 
      les termes employés, ils sont expliqués dans ce chapitre ou 
      ailleurs dans ce livre)&nbsp;:</para>

    <variablelist>
      <varlistentry>
        <term>conf</term>
        <listitem>
          <para>un répertoire contenant des fichiers de 
            configuration</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>dav</term>
        <listitem>
          <para>un répertoire à disposition de 
            <filename>mod_dav_svn</filename> pour y stocker ses 
              informations privées </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>db</term>
        <listitem>
          <para>le magasin de données pour toutes vos données suivies en 
            versions</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>format</term>
        <listitem>
          <para>un fichier contenant un unique entier qui indique le 
            numéro de version de l'organisation du dépôt</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>hooks</term>
        <listitem>
          <para>un répertoire plein de modèles de procédures 
            automatiques (et les procédures automatiques elles-mêmes, 
            une fois installées)</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>locks</term>
        <listitem>
          <para>un répertoire pour les fichiers de verrous du dépôt 
            Subversion, utilisé pour garder trace de qui accède au 
            dépôt </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>README.txt</term>
        <listitem>
          <para>un fichier qui ne fait qu'informer son lecteur qu'il est 
            tombé sur un dépôt Subversion</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Bien sûr, quand on y accède via les bibliothèques Subversion, 
      cet ensemble de fichiers et de répertoires se transforme en un 
      système virtuel de fichiers suivis en versions, complet et 
      comportant une gestion des événements personnalisable. Ce système 
      de fichiers possède ses propres notions de répertoires et de 
      fichiers, très similaires aux notions des systèmes de fichiers 
      réels (tels que NTFS, FAT32, ext3, etc.). Mais c'est un système de 
      fichiers spécial&nbsp;: il base ces répertoires et ces fichiers 
      sur les révisions, gardant une trace des tous les changements 
      effectués de manière sûre et accessible pour toujours. C'est là 
      que la totalité de vos données suivies en versions réside.</para>

  </sect1>
 
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.planning">
    <title>Stratégies de déploiement d'un dépôt</title>

    <para>En grande partie grâce à la conception épurée du dépôt 
      Subversion et des technologies sous-jacentes, il est 
      particulièrement aisé de créer et configurer un dépôt. Il y a 
      quelques choix préliminaires à faire, mais l'essentiel du travail 
      de création et de configuration d'un dépôt Subversion est simple 
      et convivial, facilement reproductible si vous êtes amené à 
      effectuer des installations multiples.</para>

    <para>Voici quelques questions à se poser avant toute chose&nbsp;:</para>

    <itemizedlist>
      <listitem>
        <para>Quelles données vont être hébergées dans le dépôt (ou les 
          dépôts) et quelle en sera l'organisation&nbsp;?</para>
      </listitem>
      <listitem>
        <para>Où sera placé le dépôt et comment les utilisateurs y 
          accéderont-ils&nbsp;?</para>
      </listitem>
      <listitem>
        <para>De quels types de contrôle d'accès et de notifications 
          d'événements avez-vous besoin&nbsp;?</para>
      </listitem>
      <listitem>
        <para>Quel type de magasin de données désirez-vous 
          utiliser&nbsp;?</para>
      </listitem>
    </itemizedlist>

    <para>Dans cette section, nous allons essayer de vous aider à 
      répondre à ces questions.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.projects.chooselayout">
      <title>Prévoir l'organisation de votre dépôt</title>

      <para>Bien que Subversion vous permette de déplacer des fichiers 
        et des répertoires suivis en versions sans perte d'information, 
        et qu'il fournisse même des outils pour déplacer des ensembles 
        complets de données versionnées d'un dépôt à un autre, ces 
        opérations peuvent perturber le travail des autres 
        collaborateurs qui accèdent souvent au dépôt et qui s'attendent 
        à trouver chaque chose à sa place. Ainsi, avant de créer un 
        nouveau dépôt, essayez de vous projeter un peu dans le 
        futur&nbsp;; préparez à l'avance le passage de vos données en 
        suivi de versions. Cette réflexion sur la manière d'organiser 
        vos données dans le dépôt vous évitera de futurs et nombreux 
        maux de tête.</para>

      <para>Supposons qu'en tant qu'administrateur d'un dépôt, vous 
        serez responsable de l'administration du système de gestion de 
        versions pour plusieurs projets. La première décision à prendre 
        est de choisir entre un seul dépôt pour tous les projets et un 
        dépôt par projet, ou bien un compromis entre ces deux 
        solutions.</para>

      <para>Un seul dépôt pour tous les projets offre des avantages, ne 
        serait-ce que pour la maintenance unifiée. Un seul dépôt 
        signifie qu'il n'y a qu'un seul jeu de procédures automatiques, 
        une seule sauvegarde à gérer, un seul jeu d'opérations de 
        déchargement et de chargement à effectuer si la nouvelle version 
        de Subversion est incompatible avec l'ancienne version, etc. 
        Vous pouvez également déplacer facilement des données entre les 
        projets, sans perdre l'historique de ces informations.</para>

      <para>Les inconvénients à utiliser un seul dépôt sont que les 
        différents projets auront certainement des besoins différents en 
        termes de gestion des événements, comme la notification par 
        e-mail des propagations à des listes d'adresses différentes ou 
        des définitions différentes de ce qui constitue une propagation 
        légitime. Bien sûr, ce ne sont pas des problèmes insurmontables 
        &mdash; cela implique juste que vos procédures automatiques 
        devront tenir compte de l'organisation du dépôt dans lequel 
        elles sont invoquées plutôt que de considérer que l'ensemble du 
        dépôt est associé à un seul groupe d'utilisateurs. Rappelez-vous 
        également que Subversion utilise des numéros de révisions 
        globaux au dépôt. Bien que ces numéros ne possèdent pas de 
        pouvoirs magiques particuliers, certaines personnes n'aiment pas 
        voir le numéro de révision augmenter alors qu'elles n'ont pas 
        touché à leur propre projet.
        <footnote>
          <para>Whether founded in ignorance or in poorly considered
            concepts about how to derive legitimate software
            development metrics, global revision numbers are a silly
            thing to fear, and <emphasis>not</emphasis> the kind of
            thing you should weigh when deciding how to arrange your
            projects and repositories.</para>
        </footnote>
      </para>

      <para>On peut aussi adopter une approche intermédiaire. Par 
        exemple, les projets peuvent être regroupés par thème. Vous 
        pourriez avoir quelques dépôts, avec une poignée de projets dans 
        chaque dépôt. Ainsi, les projets susceptibles de partager des 
        données le font aisément et les développeurs sont tenus au 
        courant des avancées des projets en relation avec les leurs par 
        le biais des nouvelles révisions du dépôt.</para>

      <para>Une fois l'organisation des dépôts définie, il faut se 
        préoccuper de la hiérarchie des répertoires à l'intérieur des 
        dépôts eux-mêmes. Comme Subversion utilise de simples copies de 
        répertoires pour créer les branches et les étiquettes (voir 
        <xref linkend="svn.branchmerge"/>), la communauté Subversion 
        recommande de choisir un endroit dans le dépôt pour la 
        <firstterm>racine</firstterm> de chaque projet (le répertoire 
        dont la sous-arborescence contient toutes les données relatives 
        à un projet) et d'y placer trois sous-répertoires :
        <filename>trunk</filename> (tronc en français), le répertoire 
        qui héberge les principaux développements du projet&nbsp;;
        <filename>branches</filename>, le répertoire dans lequel seront 
        créées les différentes variations de la ligne de développement 
        principale&nbsp;; et <filename>tags</filename>, (étiquettes en 
        français), qui contient un ensemble d'instantanés de 
        l'arborescence (les instantanés sont créés, voire détruits, mais 
        jamais modifiés)
        <footnote>
          <para>Le trio <filename>trunk</filename>, <filename>tags</filename>, 
            and <filename>branches</filename> trio is sometimes referred
            to as <quote>the TTB directories.</quote></para>
        </footnote>.
        </para>

      <para>Par exemple, votre dépôt pourrait ressembler à 
        ceci&nbsp;:</para>

      <screen>
  /
     calculatrice/
        trunk/
        tags/
        branches/
     calendrier/
        trunk/
        tags/
        branches/
     tableur/
        trunk/
        tags/
        branches/
   &hellip;
</screen>

      <para>Veuillez noter que l'emplacement du projet dans le dépôt 
        n'est pas important. Si vous n'avez qu'un seul projet par dépôt, 
        il est logique de placer la racine du projet à la racine du 
        dépôt correspondant. Si vous avez plusieurs projets, vous 
        voudrez peut-être les classer par groupes dans des 
        sous-répertoires communs du dépôt, en fonction des objectifs ou 
        du code à partager par exemple, ou tout simplement en les 
        groupant par ordre alphabétique. Voici un exemple&nbsp;:</para>

      <screen>
  /
     utilitaires/
        calculatrice/
           trunk/
           tags/
           branches/
        calendrier/
           trunk/
           tags/
           branches/
      &hellip;
     bureautique/
        tableur/
           trunk/
           tags/
           branches/
      &hellip;
</screen>

      <para>Organisez votre dépôt comme vous le sentez. Subversion n'a 
        aucune exigence en la matière &mdash; pour lui, un répertoire 
        est un répertoire. L'objectif est d'avoir une organisation qui 
        réponde aux besoins des collaborateurs des différents 
        projets.</para>

      <para>Cependant, par souci de transparence, nous signalerons une 
        autre organisation également très répandue. Dans cette 
        organisation, les répertoires <filename>trunk</filename>, 
        <filename>tags</filename>, et <filename>branches</filename> sont 
        situés à la racine du dépôt et les projets sont placés dans des 
        sous-répertoires juste en dessous, comme ceci&nbsp;:</para>

      <screen>
 /
     trunk/
        calculatrice/
        calendrier/
        tableur/
      &hellip;
     tags/
        calculatrice/
        calendrier/
        tableur/
      &hellip;
     branches/
        calculatrice/
        calendrier/
        tableur/
      &hellip;
</screen>

      <para>Il n'y a rien d'incorrect dans une telle organisation, mais 
        elle peut ne pas être très intuitive pour vos utilisateurs. En 
        particulier dans des situations complexes avec plusieurs projets 
        et un grand nombre d'utilisateurs, dont la plupart ne 
        connaissent qu'un ou deux projets du dépôt. Mais cette approche 
        <quote>plusieurs projets par branche</quote> a tendance à 
        favoriser l'ouverture de chaque projet sur les autres et pousse 
        à envisager l'ensemble des projets comme une seule entité. Cela 
        reste un problème social. Nous aimons l'organisation suggérée au 
        début pour des raisons purement pratiques&nbsp;: il est plus 
        facile de faire des requêtes (ou des modifications, des 
        migrations) sur l'historique complet d'un projet quand une 
        sous-arborescence du dépôt contient l'ensemble des données 
        (passé, présent, étiquettes et branches) de ce projet et elles 
        seules.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.hosting">
      <title>Décider où et comment héberger votre dépôt</title>

      <para>Avant de créer votre dépôt Subversion, vous devrez vous 
        demander où il va résider. C'est fortement lié à une myriade 
        d'autres questions telles que qui sont les utilisateurs 
        (sont-ils à l'intérieur de votre réseau interne, derrière le 
        pare-feu de votre entreprise, ou bien s'agit-il de n'importe 
        qui, n'importe où sur Internet&nbsp;?), comment les utilisateurs 
        accéderont au dépôt (via un serveur Subversion ou directement), 
        quels autres services fournirez-vous autour de Subversion (une 
        interface pour navigateur Web, des notifications par mail des 
        propagations, etc.), quelle sera votre politique de sauvegarde, 
        et ainsi de suite. </para>

      <para>Le choix et la configuration du serveur seront abordés au 
        <xref linkend="svn.serverconfig" />, mais nous voulons signaler 
        dès maintenant que certains choix pour l'une ou l'autre de ces 
        questions ont des implications sur l'endroit où implémenter 
        votre serveur. Par exemple, certains scénarios de déploiement 
        nécessitent l'accès au dépôt via un système de fichiers distant 
        pour plusieurs ordinateurs et, dans ce cas, le choix du type de 
        magasin de données n'en est plus un, puisqu'un seul type de 
        magasin de données convient dans ce scénario.</para>

      <para>Décrire l'ensemble des possibilités de déploiement de 
        Subversion est impossible et n'est pas l'objectif de ce livre. 
        Nous vous encourageons simplement à évaluer vos choix avec ces 
        quelques pages et d'autres ressources en guise de référence pour 
        planifier correctement les opérations.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.backends">
      <title>Choisir un magasin de données</title>

      <para>Depuis la version 1.1, Subversion offre deux types de 
        stockage interne pour le magasin de données &mdash; souvent 
        désigné par <quote>backend</quote> en anglais (sans équivalent 
        en français) ou, ce qui peut être source de confusion, <quote>le 
        système de fichiers (versionné)</quote> &mdash; utilisé par le 
        dépôt. Un des types de magasin de données conserve tout dans une 
        base de données Berkeley DB (ou BDB)&nbsp;; les dépôts qui 
        utilisent ce type de magasin seront qualifiés de <quote>dépôts 
        gérés par BDB</quote> ou <quote>dépôts BDB</quote>. L'autre type 
        de magasin stocke les données dans des fichiers ordinaires, en 
        utilisant un format particulier. Les développeurs de Subversion 
        ont pris l'habitude d'appeler ce type de stockage 
        <firstterm>FSFS</firstterm>
        <footnote>
          <para>Often pronounced <quote>fuzz-fuzz,</quote> if Jack
            Repenning has anything to say about it.  (This book,
            however, assumes that the reader is thinking
            <quote>eff-ess-eff-ess.</quote>)</para>
        </footnote> 
        &mdash; une implémentation d'un système de fichiers suivis 
        en versions qui utilise le système de fichiers natif du système 
        d'exploitation directement plutôt que par l'intermédiaire d'une 
        bibliothèque de gestionnaire de base de données ou toute autre 
        couche d'abstraction.</para>

      <para>Le <xref linkend="svn.reposadmin.basics.backends.tbl-1" />
        offre une présentation comparée des dépôts utilisant Berkeley DB 
        et FSFS.</para>

      <table id="svn.reposadmin.basics.backends.tbl-1">
        <title>Comparaison des magasins de données de dépôts</title>
        <tgroup cols="4">
          <thead>
            <row>
              <entry>Catégorie</entry>
              <entry>Fonctionnalité</entry>
              <entry>Berkeley DB</entry>
              <entry>FSFS</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry morerows="1">Fiabilité</entry>
              <entry>Intégrité des données</entry>
              <entry>Très fiable quand déployé correctement&nbsp;; 
                Berkeley DB 4.4 apporte l'auto-restauration</entry>
              <entry>Les vieilles versions avaient quelques bogues 
                (rarement démontrés) qui détruisaient des 
                données</entry>
            </row>
            <row>
              <entry>Sensibilité aux interruptions</entry>
              <entry>Forte&nbsp;; les <quote>plantages</quote> et les 
                problèmes de droits peuvent laisser la base de données 
                dans un état instable, nécessitant le recours aux 
                procédures de restauration issues de la 
                journalisation</entry>
              <entry>Quasiment insensible</entry>
            </row>
            <row>
              <entry morerows="3">Accessibilité</entry>
              <entry>Utilisable depuis un montage en lecture seule</entry>
              <entry>Non</entry>
              <entry>Oui</entry>
            </row>
            <row>
              <entry>Stockage indépendant de la plate-forme</entry>
              <entry>Non</entry>
              <entry>Oui</entry>
            </row>
            <row>
              <entry>Utilisable sur des systèmes de fichiers en réseau</entry>
              <entry>Généralement non</entry>
              <entry>Oui</entry>
            </row>
            <row>
              <entry>Gestion des droits pour les groupes </entry>
              <entry>Sensible aux problèmes de umask de 
                l'utilisateur&nbsp;; c'est mieux si un seul utilisateur 
                y accède</entry>
              <entry>Contourne les problèmes de umask</entry>
            </row>
            <row>
              <entry morerows="2">Extensibilité</entry>
              <entry>Utilisation des disques sur le dépôt</entry>
              <entry>Plus grande (surtout si les fichiers de 
                journalisation ne sont pas purgés) </entry>
              <entry>Plus faible</entry>
            </row>
            <row>
              <entry>Nombre de révisions</entry>
              <entry>Base de données, pas de problème</entry>
              <entry>De vieux systèmes de fichiers fonctionnent moins 
                bien lorsqu'il y a plusieurs milliers d'entrées dans un 
                seul répertoire</entry>
            </row>
            <row>
              <entry> Répertoires avec beaucoup de fichiers</entry>
              <entry>Plus lent</entry>
              <entry>Plus rapide</entry>
            </row>
            <row>
              <entry morerows="1">Performances</entry>
              <entry>Extraire la dernière révision</entry>
              <entry>Pas de différence significative</entry>
              <entry>Pas de différence significative</entry>
            </row>
            <row>
              <entry>Grosses propagations</entry>
              <entry>Globalement plus lent, mais mais cette lenteur est 
                répartie sur toute la durée de la propagation</entry>
              <entry>Globalement plus rapide, mais le délai de 
                finalisation peut amener le client à considérer que sa 
                requête a expiré avant qu'il ne reçoive la 
                réponse</entry>
            </row>
          </tbody>
        </tgroup>      
      </table>

      <para>Chaque type de magasin de données a ses avantages et ses 
        inconvénients. Aucun n'est plus <quote>officiel</quote> que 
        l'autre, même si le nouveau FSFS est le magasin par défaut 
        depuis Subversion 1.2. Les deux sont suffisamment fiables pour 
        y stocker vos données suivies en versions en toute confiance. 
        Mais comme l'indique le <xref
        linkend="svn.reposadmin.basics.backends.tbl-1" />, FSFS est un 
        peu plus souple à déployer. Plus de souplesse signifie que vous 
        devrez y mettre un peu plus du vôtre pour faire des erreurs lors 
        du déploiement. C'est pourquoi, en plus du fait que ne pas 
        utiliser Berkeley DB permet de compter un composant de moins 
        dans le système, aujourd'hui presque tout le monde utilise FSFS 
        lors de la création de nouveaux dépôts.</para>

      <para>Heureusement, la plupart des programmes qui accèdent aux 
        dépôts Subversion ignorent royalement quel type de magasin de 
        données est utilisé. Et vous n'êtes même pas prisonnier de votre 
        premier choix de magasin&nbsp;: au cas où vous changeriez d'avis 
        plus tard, Subversion offre différentes façons de migrer les 
        données de votre dépôt dans un autre dépôt utilisant un magasin 
        de données différent. Nous en reparlerons plus loin dans ce 
        chapitre.</para>

      <para>Les paragraphes suivants abordent plus en détail les 
        différents types de magasins de données disponibles.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.basics.backends.bdb">
        <title>Berkeley DB</title>
        
        <para>Lors de la conception initiale de Subversion, les 
          développeurs ont décidé d'utiliser le gestionnaire de bases de 
          données Berkeley DB pour tout un tas de raisons, entre autres 
          sa licence Open Source, son support des transactions, sa 
          fiabilité, ses performances, la simplicité de son interface de 
          programmation (API), le bon support des processus légers 
          (threads), le support des curseurs, etc.</para>

        <para>Le gestionnaire de bases de données Berkeley DB apporte un 
          support réel des transactions (c'est peut-être sa 
          fonctionnalité la plus puissante). Si de nombreux processus 
          accèdent en même temps au dépôt, ils n'ont pas à se soucier 
          d'éventuelles corruptions de données de la part des autres 
          processus. L'isolement créé par le système de transaction est 
          tel que pour une opération donnée, Subversion voit une base de 
          données statique &mdash; pas une base de données en perpétuel 
          changement en raison des autres processus &mdash; et peut donc 
          prendre des décisions à partir de cette perspective. Si la 
          décision entraîne un conflit avec ce que fait un autre 
          processus, l'opération complète est annulée, tout se passe 
          comme si elle n'avait jamais eu lieu, et Subversion essaie une 
          nouvelle fois son opération sur la base de données mise à jour 
          (qui apparaît toujours statique).</para>

        <para>Une autre fonctionnalité phare du gestionnaire de bases de 
          données Berkeley DB est la  <firstterm>sauvegarde à 
          chaud </firstterm> &mdash; la capacité de sauvegarde de 
          l'environnement de la base de données sans la couper du 
          réseau. Nous verrons comment réaliser une sauvegarde de votre 
          dépôt plus tard dans ce chapitre (dans <xref
          linkend="svn.reposadmin.maint.backup"/>), mais le bénéfice de 
          pouvoir faire des copies opérationnelles de vos dépôts sans 
          interruption de service doit vous sauter aux yeux.</para>

        <para>Le gestionnaire de bases de données Berkeley DB est aussi 
          très fiable quand il est utilisé correctement. Subversion 
          utilise les fonctions de journalisation du gestionnaire de 
          bases de données Berkeley DB, ce qui veut dire que la base de 
          données consigne d'abord, dans un fichier de journalisation 
          situé sur disque, chaque modification qu'elle s'apprête à 
          effectuer, puis effectue la modification elle-même. Cela 
          garantit que si quelque chose se passe mal, le gestionnaire de 
          base de données peut revenir à un <firstterm>point de 
          contrôle</firstterm> précédent &mdash; un point précis des 
          fichiers de journalisation dont il sait qu'il n'est pas 
          corrompu &mdash; et rejouer les transactions jusqu'à ce que 
          les données soient dans un état opérationnel. Voir <xref 
          linkend="svn.reposadmin.maint.diskspace"/> plus loin dans ce 
          chapitre pour plus de détails sur les fichiers de 
          journalisation Berkeley DB.</para>

        <para>Mais chaque médaille à son revers et nous devons vous 
          avertir de quelques limitations du gestionnaire de bases de 
          données Berkeley DB. Premièrement, les environnements du 
          gestionnaire de bases de données Berkeley DB ne sont pas 
          portables. Vous ne pouvez pas simplement copier un dépôt 
          Subversion qui a été créé sur un système Unix vers un système 
          Windows et espérer qu'il fonctionnera. Bien que la majeure 
          partie de la base de données Berkeley DB soit indépendante de 
          l'architecture, d'autres aspects de l'environnement ne le sont 
          pas. Deuxièmement, Subversion utilise le gestionnaire de bases 
          de données Berkeley DB de telle façon que cela ne fonctionne 
          pas sur un système Windows 95/98&nbsp;: si vous avez besoin 
          d'héberger un dépôt géré par BDB sur une machine Windows, 
          adoptez Windows 2000 ou plus.</para>

        <para>Alors que le gestionnaire de bases de données Berkeley DB 
          prétend fonctionner correctement sur un système de fichiers en 
          réseau pour peu que celui-ci respecte des caractéristiques 
          particulières
          <footnote>
            <para>Berkeley DB requires that the underlying filesystem
              implement strict POSIX locking semantics, and more
              importantly, the ability to map files directly into
              process memory.</para>
          </footnote>
          la plupart des systèmes de fichiers en réseau et des systèmes 
          dédiés <emphasis>n'atteignent pas</emphasis> ces pré-requis. 
          Et en aucun cas il ne vous sera possible de partager ce dépôt 
          sur un système de fichiers en réseau entre plusieurs clients 
          (alors que c'est quand même l'intérêt principal d'un dépôt 
          accessible sur un partage réseau).</para>

        <warning>
          <para>Si vous tentez d'utiliser le gestionnaire de bases de 
            données Berkeley DB sur un système de fichiers en réseau non 
            compatible, les résultats sont imprévisibles&nbsp;: vous 
            vous apercevrez peut-être immédiatement de mystérieuses 
            erreurs, mais il se peut qu'il se passe des mois avant que 
            vous ne découvriez que votre base de données de dépôt est 
            corrompue. Songez sérieusement à utiliser un magasin FSFS 
            pour les dépôts qui doivent être hébergés sur un partage 
            réseau.</para>
        </warning>
          
        <para>Finalement, parce que la bibliothèque du gestionnaire de 
          bases de données Berkeley DB est directement incluse dans 
          Subversion, elle est plus sensible aux interruptions qu'une 
          base de données relationnelle classique. La plupart des 
          systèmes SQL, par exemple, disposent d'un processus serveur 
          dédié qui coordonne tous les accès aux tables. Si un programme 
          qui accède aux tables plante pour une raison ou une autre, le 
          processus serveur de la base de données s'en aperçoit et fait 
          le ménage. Et comme le processus serveur est le seul processus 
          accédant réellement aux tables, les applications n'ont pas à 
          se soucier des conflits de droits. Cependant, ce n'est pas le 
          cas avec le gestionnaire de bases de données Berkeley DB. 
          Subversion (et les programmes utilisant les bibliothèques de 
          Subversion) accèdent aux tables directement, ce qui veut dire 
          que le plantage d'un programme peut laisser la base de données 
          dans un état temporairement incohérent et inaccessible. Quand 
          cela arrive, un administrateur doit demander au gestionnaire 
          de bases de données Berkeley DB de revenir à un point de 
          contrôle, ce qui est assez ennuyeux. D'autres incidents 
          peuvent faire <quote>planter</quote> la base de données, comme 
          des conflits entre programmes pour la possession ou les droits 
          sur les fichiers de la base de données.</para>

        <note>
          <para>La version 4.4 du gestionnaire de bases de données 
            Berkeley DB permet à Subversion (version 1.4 ou plus) de 
            restaurer un environnement Berkeley DB automatiquement et de 
            manière transparente en cas de besoin. Quand un processus 
            Subversion se greffe sur l'environnement d'un dépôt 
            Berkeley DB, il utilise un mécanisme d'enregistrement pour 
            détecter tout problème éventuel de déconnexion antérieur, 
            effectue les restaurations nécessaires puis passe à la suite 
            comme si de rien n'était. Cela n'élimine pas complètement 
            les plantages du dépôt, mais les interactions humaines 
            nécessaires pour revenir à une situation normale sont 
            considérablement réduites.</para>
        </note>

        <para>Ainsi, bien qu'un dépôt Berkeley DB soit rapide et capable 
          de monter en puissance, il faut privilégier une utilisation 
          par un seul processus serveur tournant avec une identité 
          unique (comme le serveur Apache <command>httpd</command>
          ou <command>svnserve</command> (voir <xref
          linkend="svn.serverconfig"/>)&mdash; plutôt qu'un accès par de 
          nombreux utilisateurs via des URL <literal>file://</literal> 
          ou <literal>svn+ssh://</literal>. Si de multiples utilisateurs 
          doivent avoir accès à un dépôt Berkeley DB, lisez
          <xref linkend="svn.serverconfig.multimethod"/> plus loin dans 
          ce chapitre.</para>

      </sect3>
      
      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.basics.backends.fsfs">
        <title>FSFS</title>

        <para>Mi 2004, un deuxième type de stockage pour le dépôt, qui 
          ne fait pas appel à une base de données, a fait son 
          apparition. Un dépôt FSFS stocke les changements associés à 
          une révision dans un fichier unique, ce qui fait que 
          l'ensemble des révisions du dépôt se trouvent dans un seul 
          sous-répertoire rempli de fichiers numérotés. Les transactions 
          sont créées, en tant que fichiers individuels, dans des 
          sous-répertoires séparés. Une fois la transaction terminée, le 
          fichier de transaction est renommé et placé dans le répertoire 
          des révisions, ce qui garantit l'atomicité des propagations. 
          Et puisqu'un fichier de révision est permanent et non 
          modifiable, le dépôt peut également être sauvegardé
          <quote>à chaud</quote> comme un dépôt BDB.</para>

        <para>Les fichiers de révision FSFS décrivent, pour une révision 
          donnée, la structure des répertoires, le contenu des fichiers 
          et les deltas entre les fichiers et les autres arborescences 
          de révisions. Contrairement à une base de données Berkeley DB, 
          le format de stockage est portable, transférable entre 
          différents systèmes d'exploitation, et n'est pas sensible à 
          l'architecture CPU. Comme il n'y a pas de journalisation ou de 
          fichiers en mémoire partagée, le dépôt est accessible sans 
          risque via un partage de fichiers sur le réseau ou depuis un 
          environnement en lecture seule. L'absence des en-têtes liés à 
          une base de données réduit aussi quelque peu la taille globale 
          du dépôt.</para>

        <para>FSF diffère également du point de vue des performances. 
          Quand vous propagez un répertoire comptant un nombre de 
          fichiers très élevé, FSFS est capable d'ajouter plus 
          rapidement les éléments du répertoire. D'un autre côté, FSFS 
          écrit la dernière version d'un fichier sous forme de delta par 
          rapport à la version précédente, par conséquent une extraction 
          de l'arborescence la plus récente sera un peu plus lente que 
          l'obtention des fichiers entiers stockés dans la révision HEAD 
          d'une base de données Berkeley DB. FSFS est également plus 
          long lors de la fin de la propagation, ce qui peut amener le 
          client à considérer, dans des cas extrêmes, que sa requête a 
          expiré avant qu'il ne reçoive la réponse.</para>

        <para>La différence la plus importante reste quand même la 
          résistance aux plantages lorsque quelque chose va mal. Si un 
          processus qui utilise une base de données Berkeley DB 
          rencontre un problème de droits ou plante soudainement, la 
          base de données risque de se retrouver dans un état instable 
          jusqu'à ce qu'un administrateur la restaure. Si la même chose 
          arrive à un processus utilisant un dépôt FSFS, le dépôt n'est 
          en rien affecté. Au pire, quelques données de transaction sont 
          égarées.</para>

        <para>Le seul véritable argument contre FSFS est sa relative 
          immaturité face à Berkeley DB. Berkeley DB a une histoire de 
          plusieurs années, avec une équipe de développement dédiée et, 
          aujourd'hui, il est adossé à la toute-puissante marque 
          Oracle 
          <footnote>
            <para>Oracle bought Sleepycat and its flagship software,
              Berkeley DB, on Valentine's Day in 2006.</para>
          </footnote>. 
          FSFS est d'une conception plus récente. Avant la version 1.4 
          de Subversion, apparaissaient de temps en temps quelques 
          bogues assez sérieux concernant l'intégrité des données qui, 
          bien que n'arrivant que dans de très rares cas, étaient bien 
          réels. Ceci dit, FSFS est rapidement devenu le magasin de 
          données de référence pour quelques-uns des plus vastes dépôts 
          Subversion, publics et privés, et il promet de rendre 
          globalement plus facile le passage à Subversion.</para>

      </sect3>
    </sect2>

  </sect1>
 
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.create">
    <title>Créer et configurer votre dépôt</title>

    <para>Dans ce chapitre (dans <xref 
      linkend="svn.reposadmin.planning" />), nous avons passé en revue 
      quelques décisions importantes à prendre avant de créer et de 
      configurer votre dépôt Subversion. Maintenant, nous allons enfin 
      mettre les mains dans le cambouis&nbsp;! Dans cette section, nous 
      allons voir comment créer un dépôt Subversion et le configurer 
      pour qu'il effectue des actions personnalisées lorsque certains 
      événements ont lieu.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.creating">
      <title>Créer un dépôt</title>
   
      <para>La création d'un dépôt Subversion est une tâche 
        incroyablement simple. L'utilitaire <command>svnadmin</command>, 
        fourni avec Subversion, propose une sous-commande qui est 
        justement destinée à cela (<command>svnadmin
        create</command>) &nbsp;:</para>
          
      <screen>
$ # Créer un dépôt
$ svnadmin create /var/svn/depot
$
</screen>
          
      <para>Cette commande crée un dépôt dans le répertoire 
        <filename>/var/svn/repos</filename> avec le magasin de données 
        par défaut. Avant la version 1.2 de Subversion, le choix par 
        défaut était l'utilisation d'une base de données Berkeley DB&nbsp; 
        maintenant, c'est FSFS. Vous pouvez choisir explicitement le 
        type de système de fichiers avec l'option
        <option>--fs-type</option> qui accepte comme argument soit 
        <literal>fsfs</literal>, soit <literal>bdb</literal>.</para>
 
      <screen>
$ # Créer un dépôt FSFS
$ svnadmin create --fs-type fsfs /var/svn/depot
$
</screen>

      <screen>
$ # Créer un dépôt Berkeley DB
$ svnadmin create --fs-type bdb /var/svn/depot
$
</screen>
              
      <para>Après l'exécution de cette simple commande, vous disposez 
        d'un dépôt Subversion.</para>

      <tip>
        <para>Le chemin en argument de <command>svnadmin</command> est 
          juste un chemin classique du système de fichiers, pas une URL 
          comme celles que le client <command>svn</command> utilise pour 
          spécifier un dépôt. Les commandes <command>svnadmin</command>
          et <command>svnlook</command> sont toutes les deux considérées 
          comme des utilitaires coté serveur&nbsp;: elles sont utilisées 
          sur la machine qui héberge le dépôt pour examiner ou modifier 
          certains aspects du dépôt et ne sont pas capables d'effectuer 
          des actions via le réseau. Une erreur classique des nouveaux 
          utilisateurs de Subversion est d'essayer de passer une URL 
          (même <quote>locale</quote> comme <literal>file://</literal>)
          à ces deux programmes.</para>
      </tip>

      <para>Dans le sous-répertoire <filename>db/</filename> de votre 
        dépôt, vous trouverez l'implémentation du système de fichiers 
        suivi en versions. Le nouveau système de fichiers suivi en 
        versions de votre dépôt commence sa vie à la révision 0, qui est 
        définie comme contenant le répertoire racine 
        (<filename>/</filename>) et lui seul. Initialement, la révision 0 
        possède une seule propriété de révision, 
        <literal>svn:date</literal>, dont la valeur est la date de 
        création du dépôt.</para>

      <para>Maintenant que vous disposez d'un dépôt, il est temps de le 
        personnaliser.</para>

      <warning>
        <para>Alors que certaines parties d'un dépôt Subversion sont 
          conçues pour être examinées et modifiées <quote>à la 
          main</quote> (comme les fichiers de configuration et les 
          procédures automatiques), vous ne devriez pas (et vous ne 
          devriez pas avoir besoin de) modifier les autres parties 
          <quote>à la main</quote>. L'outil <command>svnadmin</command> 
          est censé être suffisant pour toutes les modifications à 
          apporter à votre dépôt, ou alors vous pouvez regarder du côté 
          d'outils tiers (comme la suite d'outils Berkeley DB) pour 
          configurer les parties adéquates du dépôt. Ne tentez 
          <emphasis>surtout pas</emphasis> de manipuler manuellement 
          l'historique du suivi de versions à petits coups par-ci par-là 
          dans les fichiers du magasin de données du dépôt&nbsp;!</para>
      </warning>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.create.hooks">
      <title>Mettre en place des procédures automatiques</title>

      <para>Une <firstterm>procédure automatique</firstterm> (hook en 
        anglais) est un programme activé par certains événements du 
        dépôt, comme la création d'une nouvelle révision ou la 
        modification d'une propriété non suivie en versions. Certaines 
        procédures automatiques (appelées <quote>pre hooks</quote>) sont 
        déclenchées avant l'opération sur le dépôt et permettent à la 
        fois de rendre compte de ce qui va se passer et d'empêcher que 
        cela se passe. D'autres procédures automatiques (appelées 
        <quote>post hooks</quote>) sont déclenchées après la fin d'un 
        événement et servent à effectuer des tâches de surveillance 
        (mais pas de modification) du dépôt. Chaque procédure 
        automatique reçoit suffisamment d'informations pour déterminer 
        la nature de l'événement, les modifications proposées (ou 
        effectuées) du dépôt et le nom d'utilisateur de la personne qui 
        a déclenché l'événement.</para>
            
      <para>Le sous-répertoire <filename>hooks</filename> contient, par 
        défaut, des modèles pour diverses procédures 
        automatiques&nbsp;:</para>
            
      <screen>
$ ls depot/hooks/
post-commit.tmpl          post-unlock.tmpl  pre-revprop-change.tmpl
post-lock.tmpl            pre-commit.tmpl   pre-unlock.tmpl
post-revprop-change.tmpl  pre-lock.tmpl     start-commit.tmpl
$
</screen>
            
      <para>Il y a un modèle pour chaque type de procédure automatique 
        que le dépôt Subversion sait prendre en charge&nbsp;; en 
        examinant le contenu de ces modèles de scripts, vous pourrez 
        voir ce qui déclenche le script et quelles données sont passées 
        en paramètres. Vous trouverez également dans beaucoup de ces 
        scripts des exemples d'utilisation permettant de réaliser des 
        tâches récurrentes utiles, en conjonction avec d'autres 
        programmes fournis avec Subversion. Concrètement, pour activer 
        une procédure automatique, il suffit de placer dans le 
        répertoire <filename>depot/hooks</filename> un programme ou un 
        script exécutable, qui sera invoqué via le nom de la procédure 
        automatique (comme <command>start-commit</command> pour le début 
        d'une propagation ou <command>post-commit</command> pour la fin 
        d'une propagation).</para>

      <para>Sur les plates-formes Unix, cela veut dire fournir un 
        programme ou un script (pouvant être un script shell, un 
        programme Python, l'exécutable binaire d'un programme en C ou 
        tout un tas d'autres choses) dont le nom est exactement le nom 
        de la procédure automatique. Bien sûr, les modèles qui sont 
        fournis ne le sont pas juste à titre d'information. Le moyen le 
        plus facile pour mettre en place une procédure automatique sur 
        les plates-formes Unix consiste tout simplement à copier le 
        fichier du modèle adéquat vers un nouveau fichier qui n'aura 
        pas l'extension <filename>.tmpl</filename>, d'adapter son 
        contenu à votre environnement et de vous assurer qu'il est 
        exécutable. Sous Windows, comme l'extension du fichier détermine 
        s'il est exécutable ou non, vous devrez fournir un programme 
        dont la base du nom est le nom de la procédure automatique et 
        dont l'extension sera une de celles reconnue comme exécutable 
        par Windows, comme <filename>.exe</filename> pour les programmes 
        ou <filename>.bat</filename> pour les fichiers batch.</para>

      <tip>
        <para>Pour des raisons de sécurité, le dépôt Subversion exécute 
          les procédures automatiques avec un environnement vide &mdash; 
          c'est-à-dire sans aucune variable d'environnement définie, 
          même pas <literal>$PATH</literal> (ou <literal>%PATH%</literal>
          sous Windows). C'est ainsi que de nombreux administrateurs 
          sont perplexes lorsque leurs programmes fonctionnent 
          correctement à la main mais pas dans Subversion. Assurez-vous 
          de définir explicitement toutes les variables d'environnement 
          nécessaires dans votre procédure automatique et/ou d'utiliser 
          des chemins absolus vers les programmes.</para>
      </tip>

      <para>Les procédures automatiques de Subversion sont lancées par 
        l'utilisateur propriétaire du processus ayant accès au dépôt 
        Subversion. La plupart du temps, on accède au dépôt via un 
        serveur Subversion, donc cet utilisateur est le même que celui 
        qui fait tourner le processus serveur sur le système. Les 
        procédures automatiques elles-mêmes devront être configurées 
        pour être exécutables, au niveau de l'OS, par ledit utilisateur. 
        Cela implique également que tout programme ou fichier (y compris 
        le dépôt Subversion) utilisé directement ou indirectement par la 
        procédure automatique le sera par ledit utilisateur. En d'autres 
        termes, faites bien attention aux problèmes de droits 
        d'exécution qui pourraient empêcher les scripts d'effectuer 
        correctement les tâches pour lesquelles ils ont été 
        conçus.</para>

      <para>Il y a plusieurs procédures automatiques implémentées dans 
        le dépôt Subversion et vous pouvez obtenir des détails sur 
        chacune d'elles dans <xref linkend="svn.ref.reposhooks" />. En 
        tant qu'administrateur du dépôt, vous devrez décider quelles 
        procédures automatiques vous voulez mettre en oeuvre 
        (c'est-à-dire les nommer correctement et leur donner les droits 
        appropriés) et de quelle manière. Lorsque vous prendrez cette 
        décision, gardez à l'esprit l'architecture de votre dépôt. Par 
        exemple, si vous vous servez de la configuration du serveur pour 
        déterminer les droits de propagation sur votre dépôt, vous 
        n'avez pas besoin de mettre en place un contrôle d'accès de ce 
        style via les procédures automatiques.</para>

      <para>Les exemples de procédures automatiques librement 
        accessibles sont légions, fournis par la communauté Subversion 
        elle-même ou par d'autres. Ces scripts couvrent une large 
        variété de besoins tels que le contrôle d'accès basique, le 
        contrôle de cohérence, l'intégration avec les outils de suivis 
        de bogues, les notifications de propagation par e-mail ou flux 
        RSS, etc. Ou, si vous voulez écrire votre propre programme, 
        penchez-vous sur le <xref linkend="svn.developer" />.</para>

      <warning>
        <para>Bien que les procédures automatiques soient capables de 
          faire tout et n'importe quoi, leurs auteurs devraient faire 
          preuve de modération dans un domaine précis&nbsp;: 
          <emphasis>ne modifiez pas</emphasis> une transaction de 
          propagation en utilisant une procédure automatique. Bien que 
          cela soit tentant de corriger automatiquement certaines 
          erreurs, raccourcis ou violations de politique constatées dans 
          les fichiers propagés, cela peut causer des problèmes. 
          Subversion conserve en cache, côté client, certaines parties 
          des données du dépôt et si vous modifiez une transaction de 
          propagation de cette façon, ces caches seront périmés sans que 
          cela ne puisse être détecté. De telles incohérences peuvent 
          aboutir à des comportements surprenants et inattendus. Au lieu 
          de modifier la transaction, contentez-vous de vérifier la 
          transaction dans la procédure automatique 
          <filename>pre-commit</filename> et rejetez-la si elle ne 
          remplit pas les conditions nécessaires. Entre autre avantages, 
          vos utilisateurs prendront ainsi des habitudes de travail 
          empreintes de respect des procédures et de qualité.</para>
      </warning>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.create.bdb">
      <title>Configuration de la base de données Berkeley DB</title>

      <para>Un environnement Berkeley DB peut encapsuler une ou 
        plusieurs bases de données, fichiers de journalisation, de 
        région et de configuration. L'environnement Berkeley DB a un 
        ensemble propre de valeurs configurées par défaut comme par 
        exemple le nombre de verrous autorisés à un instant donné, la 
        taille maximum des fichiers de journalisation, etc. La logique 
        du système de fichiers Subversion ajoute des valeurs par défaut 
        pour différentes options de configuration du gestionnaire 
        Berkeley DB. Cependant, il se peut que votre dépôt nécessite une 
        configuration différente en raison de l'architecture de vos 
        données et des méthodes d'accès.</para>

      <para>Les concepteurs du gestionnaire de bases de données Berkeley 
        DB comprennent que les besoins varient entre les différentes 
        applications et environnements de bases de données, c'est 
        pourquoi ils fournissent des mécanismes pour modifier, à 
        l'exécution, une grande partie des valeurs des options de 
        configuration. BDB vérifie la présence d'un fichier nommé
        <filename>DB_CONFIG</filename> dans le répertoire 
        d'environnement (à savoir le sous-répertoire <filename>db</filename>
        du dépôt) et en extrait les valeurs des options. Subversion crée 
        ce fichier lorsqu'il crée le reste du dépôt. Le fichier contient 
        initialement des options par défaut ainsi que des pointeurs vers 
        la documentation en ligne de Berkeley DB afin de vous renseigner 
        sur l'utilisation de ces options. Bien sûr, vous êtes libre 
        d'ajouter n'importe quelle option prise en compte par Berkeley 
        DB dans votre fichier <filename>DB_CONFIG</filename>. Soyez 
        juste attentif au fait que, bien que Subversion n'essaie jamais 
        de lire ou interpréter le contenu de ce fichier et qu'il n'en 
        utilise pas directement la configuration, les changements 
        induits dans le comportement de Berkeley DB ne doivent pas aller 
        à l'encontre du comportement attendu par Subversion. Par 
        ailleurs, les changements effectués dans 
        <filename>DB_CONFIG</filename> ne seront pris en considération 
        qu'après avoir effectué une restauration de l'environnement de 
        la base de données avec la commande 
        <command>svnadmin recover</command>).</para>

    </sect2>
  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.maint">
    <title>Maintenance du dépôt</title>

    <para>Assurer la maintenance d'un dépôt Subversion peut être 
      intimidant, certainement parce que les systèmes qui comprennent 
      une base de données sont complexes. Réussir nécessite 
      principalement de connaître les outils &mdash; ceux dont on 
      dispose, quand les utiliser et comment. Cette section vous 
      présentera les outils fournis par Subversion pour assurer 
      l'administration du dépôt et décrira leur maniement pour réaliser 
      des opérations telles que migrations de données, mises à jour, 
      sauvegardes et nettoyages.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.tk">
      <title>Boîte à outils de l'administrateur</title>

      <para>Subversion fournit une poignée d'utilitaires pour créer, 
        inspecter, modifier et réparer votre dépôt. Regardons de plus 
        près chacun de ces outils. Ensuite, nous aborderons rapidement 
        quelques utilitaires inclus dans le gestionnaire de bases de 
        données Berkeley DB qui fournissent des fonctionnalités 
        spécifiques au magasin de données de votre dépôt qui ne sont pas 
        assurées par les propres outils de Subversion.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnadmin">
        <title>svnadmin</title>

        <para>Le programme <command>svnadmin</command> est le meilleur 
          ami de l'administrateur de dépôts. En plus de fournir la 
          possibilité de créer des dépôts Subversion, ce programme vous 
          permet d'effectuer de nombreuses opérations de maintenance sur 
          ces dépôts. La syntaxe de <command>svnadmin</command> est 
          similaire à celle des autres programmes en ligne de commande 
          de Subversion&nbsp;:</para>

        <screen>
$ svnadmin help
usage général : svnadmin SOUS_COMMANDE DÉPÔT [ARGS &amp; OPTIONS ...]
Entrer 'svnadmin help &lt;sous-commande&gt;' pour une aide spécifique.
Entrer 'svnadmin --version' pour avoir la version et les modules de stockages.

Sous-commandes disponibles :
   crashtest
   create
   deltify
&hellip;
</screen>

        <para>Plus tôt dans ce chapitre (dans <xref
          linkend="svn.reposadmin.basics.creating"/>), nous vous avons 
          présenté la sous-commande <command>svnadmin create</command>.
          La plupart des autres sous-commandes <command>svnadmin</command>
          seront couvertes plus loin dans ce chapitre. Vous pouvez 
          également consulter<xref linkend="svn.ref.svnadmin" /> pour 
          une liste complète des sous-commandes et des fonctionnalités 
          qu'elles apportent.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnlook">
        <title>svnlook</title>
            
        <para><command>svnlook</command> est un outil de Subversion pour 
          examiner les différentes révisions et 
          <firstterm>transactions</firstterm> (qui sont des révisions en 
          cours de création) dans un dépôt. Aucune modification n'est 
          faite au dépôt par cet outil. <command>svnlook</command>
          est généralement utilisé par les procédures automatiques du 
          dépôt pour signaler les changements qui vont être propagés 
          (dans le cas de la procédure automatique
          <command>pre-commit</command>) ou qui viennent d'être propagés 
          (dans le cas de la procédure automatique 
          <command>post-commit</command>). Un administrateur peut être 
          amené à utiliser cet outil à des fins de diagnostic.</para>
            
        <para>La syntaxe de <command>svnlook</command> est 
          particulièrement simple : </para>
            
        <screen>
$svnlook help
usage général : svnlook SOUS_COMMANDE CHEMIN_DÉPÔT [ARGS &amp; OPTIONS...]
Note : Quand --revision ou --transaction ne sont pas précisées, les sous-
       commandes qui en ont besoin utilisent la révision la plus récente.
Entrer 'svnlook help &lt;sous-commande&gt;' pour une aide spécifique.
Entrer 'svnlook --version' pour avoir la version et les modules de stockage.
&hellip;
</screen>

        <para>La plupart des sous-commandes <command>svnlook</command>
          peuvent être appliquées soit à une révision soit à une 
          arborescence de transaction, affichant les informations à 
          propos de l'arborescence elle-même ou les différences par 
          rapport à la révision précédente du dépôt. Pour spécifier 
          quelle révision ou transaction examiner, utilisez 
          respectivement les options <option>--revision</option>
          (<option>-r</option>) et <option>--transaction</option>
          (<option>-t</option>). En l'absence des options 
          <option>--revision</option> (<option>-r</option>)
          ou <option>--transaction</option> (<option>-t</option>), 
          <command>svnlook</command> examinera la révision la plus 
          récente (la révision  <literal>HEAD</literal>) du dépôt. 
          Ainsi, les deux commandes suivantes font exactement la même 
          chose si la révision la plus récente du dépôt situé à 
          l'emplacement <filename>/var/svn/repos</filename> porte le 
          numéro 19 &nbsp;:</para>

        <screen>
$ svnlook info /var/svn/repos
$ svnlook info /var/svn/repos -r 19
</screen>

        <para>Signalons une exception à ces règles concernant les 
          sous-commandes&nbsp;: la sous-commande 
          <command>svnlook youngest</command> ne prend aucune option et 
          affiche simplement le numéro de la révision la plus récente du 
          dépôt&nbsp;:</para>

        <screen>
$ svnlook youngest /var/svn/repos
19
$
</screen>

        <note>
          <para>Gardez à l'esprit que les seules transactions que vous 
            pouvez examiner sont celles qui n'ont pas été propagées. La 
            plupart des dépôts ne comportent pas de transactions de ce 
            type parce que les transactions sont habituellement soit 
            propagées (auquel cas vous devriez y avoir accès sous la 
            forme de révisions via l'option <option>--revision</option>
            (<option>-r</option>)), soit annulées et supprimées.</para>
        </note>
            
        <para>La sortie de <command>svnlook</command> est conçue pour 
          être à la fois lisible par un humain et traitable par une 
          machine. Prenons, par exemple, la sortie de la sous-commande 
          <command>svnlook info</command>&nbsp;:</para>

        <screen>
$ svnlook info /var/svn/repos
sally
2002-11-04 09:29:13 -0600 (lun. 04 nov. 2002)
27
J'ai ajouté le traditionnel
Arbre grec.
$
</screen>

        <para>La sortie de <command>svnlook info</command>est constituée 
          des éléments suivants, par ordre d'apparition&nbsp;:</para>

        <orderedlist>
          <listitem>
            <para>l'auteur, suivi d'un passage à la ligne</para>
          </listitem>
          <listitem>
            <para>la date, suivie d'un passage à la ligne</para>
          </listitem>
          <listitem>
            <para>le nombre de caractères du message de propagation, 
              suivi d'un passage à la ligne</para>
          </listitem>
          <listitem>
            <para>le message de propagation lui-même, suivi d'un passage 
              à la ligne </para>
          </listitem>
        </orderedlist>

        <para>Cette sortie est lisible par un humain, ce qui veut dire 
          que les éléments tels que la date sont représentés par du 
          texte simple au lieu d'un obscur code (comme le nombre de 
          nanosecondes depuis le passage aux nouveaux francs). Mais 
          cette sortie est aussi analysable par une machine &mdash; 
          parce que le message de propagation peut comporter plusieurs 
          lignes et n'est pas limité en taille, 
          <command>svnlook</command> affiche la longueur du message 
          avant le message lui-même. Cela permet aux scripts et autres 
          utilitaires utilisant faisant appel à cette commande de 
          prendre des décisions opportunes à propos du message de 
          propagation, comme savoir combien de mémoire allouer pour le 
          message ou au moins savoir combien d'octets sauter dans le cas 
          où les données affichées par <command>svnlook</command> ne 
          sont pas les dernières données du flux.</para>

        <para><command>svnlook</command> peut répondre à un tas d'autres 
          requêtes&nbsp;: afficher des sous-ensembles des informations 
          précédemment citées, lister récursivement les arborescences 
          versionnées des répertoires, lister les chemins modifiés lors 
          de telle révision ou transaction, afficher les différences de 
          contenu et de propriétés pour les fichiers et répertoires, 
          etc. Reportez-vous à <xref linkend="svn.ref.svnlook" /> pour 
          la liste complète des fonctionnalités offertes par 
          <command>svnlook</command>.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svndumpfilter">
        <title>svndumpfilter</title>

        <para>Bien que ce ne soit pas l'outil le plus utilisé mis à 
          disposition de l'administrateur, <command>svndumpfilter</command>
          fournit des fonctionnalités particulièrement singulières et 
          utiles &mdash; la possibilité de modifier rapidement et 
          facilement des flux de l'historique du dépôt Subversion en 
          agissant en tant que filtre sur les chemins.</para>

        <para>La syntaxe de <command>svndumpfilter</command> est la 
        suivante&nbsp;:</para>

        <screen>
$ svndumpfilter help
usage général : svndumpfilter SOUS_COMMANDE [ARGS &amp; OPTIONS ...]
Entrer 'svndumpfilter help &lt;sous-commande&gt;' pour l'aide spécifique.
Entrer 'svndumpfilter --version' pour avoir le numéro de version du programme.

Sous-commandes disponibles :
   exclude
   include
   help (?, h)
</screen>

        <para>Il n'y a que deux sous-commandes intéressantes&nbsp;: 
          <command>svndumpfilter exclude</command> et
          <command>svndumpfilter include</command>. Elles vous 
          permettent de choisir entre l'inclusion implicite ou explicite 
          des chemins dans le flux. Vous pouvez en apprendre plus sur 
          ces sous-commandes et sur l'utilité si particulière de 
          <command>svndumpfilter</command> plus loin dans ce chapitre, 
          dans  <xref linkend="svn.reposadmin.maint.filtering" />.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnsync">
        <title>svnsync</title>

        <para>Le programme <command>svnsync</command>, apparu dans la 
          version 1.4 de Subversion, fournit toutes les fonctionnalités 
          requises pour faire fonctionner un miroir en lecture seule 
          d'un dépôt Subversion. Le programme n'a qu'une et une seule 
          fonction&nbsp;: transférer l'historique d'un dépôt vers un 
          autre dépôt. Et, bien qu'il y ait différentes manières de 
          faire, sa force réside dans sa capacité de travailler à 
          distance&nbsp;: les dépôts <quote>source</quote> et
          <quote>destination</quote>
          <footnote>
            <para>Or is that, the <quote>sync</quote>?</para>
          </footnote>
          peuvent être sur deux ordinateurs différents et 
          <command>svnsync</command> sur un troisième.</para>

        <para>As you might expect, <command>svnsync</command> has a
          syntax that looks very much like every other program we've
          mentioned in this chapter:</para>

        <screen>
$ svnsync help
general usage: svnsync SUBCOMMAND DEST_URL  [ARGS &amp; OPTIONS ...]
Type 'svnsync help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnsync --version' to see the program version and RA modules.

Available subcommands:
   initialize (init)
   synchronize (sync)
   copy-revprops
   help (?, h)
$
</screen>

        <para>We talk more about replicating repositories with
          <command>svnsync</command> later in this chapter (see <xref
          linkend="svn.reposadmin.maint.replication" />).</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.fsfsreshard">
        <title>fsfs-reshard.py</title>

        <para>While not an official member of the Subversion
          toolchain, the <command>fsfs-reshard.py</command> script
          (found in the <filename>tools/server-side</filename>
          directory of the Subversion source distribution) is a useful
          performance tuning tool for administrators of FSFS-backed
          Subversion repositories.  FSFS repositories contain files
          that describe the changes made in a single revision, and
          files that contain the revision properties associated with
          a single revision.  Repositories created in versions of
          Subversion prior to 1.5 keep these files in two
          directories&mdash;one for each type of file.  As new
          revisions are committed to the repository, Subversion drops
          more files into these two directories&mdash;over time, the
          number of these files in each directory can grow to be quite
          large.  This has been observed to cause performance problems
          on certain network-based filesystems.</para>

        <para>Subversion 1.5 creates FSFS-backed repositories using a
          slightly modified layout in which the contents of these two
          directories are <firstterm>sharded</firstterm>, or scattered
          across several subdirectories.  This can greatly reduce the
          time it takes the system to locate any one of these files,
          and therefore increases the overall performance of
          Subversion when reading from the repository.  The number of
          subdirectories used to house these files is configurable,
          though, and that's where
          <command>fsfs-reshard.py</command> comes in.  This script
          reshuffles the repository's file structure into a new
          arrangement that reflects the requested number of sharding
          subdirectories.  This is especially useful for converting an
          older Subversion repository into the new Subversion 1.5
          sharded layout (which Subversion will not automatically do
          for you) or for fine-tuning an already sharded
          repository.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.bdbutil">
        <title>Berkeley DB utilities</title>

        <para>If you're using a Berkeley DB repository, all of
          your versioned filesystem's structure and data live in a set
          of database tables within the <filename>db/</filename>
          subdirectory of your repository.  This subdirectory is a
          regular Berkeley DB environment directory and can therefore
          be used in conjunction with any of the Berkeley database
          tools, typically provided as part of the Berkeley DB
          distribution.</para>

        <para>For day-to-day Subversion use, these tools are
          unnecessary.  Most of the functionality typically needed for
          Subversion repositories has been duplicated in the
          <command>svnadmin</command> tool.  For example,
          <command>svnadmin list-unused-dblogs</command> and
          <command>svnadmin list-dblogs</command> perform a
          subset of what is provided by the Berkeley
          <command>db_archive</command> utility, and <command>svnadmin
          recover</command> reflects the common use cases of the
          <command>db_recover</command> utility.</para>
            
        <para>However, there are still a few Berkeley DB utilities
          that you might find useful.  The <command>db_dump</command>
          and <command>db_load</command> programs write and read,
          respectively, a custom file format that describes the keys
          and values in a Berkeley DB database.  Since Berkeley
          databases are not portable across machine architectures,
          this format is a useful way to transfer those databases from
          machine to machine, irrespective of architecture or
          operating system.  As we describe later in this chapter, you
          can also use <command>svnadmin dump</command> and
          <command>svnadmin load</command> for similar purposes, but
          <command>db_dump</command> and <command>db_load</command>
          can do certain jobs just as well and much faster.  They can
          also be useful if the experienced Berkeley DB hacker needs
          to do in-place tweaking of the data in a BDB-backed
          repository for some reason, which is something Subversion's
          utilities won't allow.  Also, the <command>db_stat</command>
          utility can provide useful information about the status of
          your Berkeley DB environment, including detailed statistics
          about the locking and storage subsystems.</para>

        <para>For more information on the Berkeley DB tool chain,
          visit the documentation section of the Berkeley DB section
          of Oracle's web site, located at <ulink
          url="http://www.oracle.com/technology/documentation/berkeley-db/db/"
          />.</para>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.setlog">
      <title>Commit Log Message Correction</title>
            
      <para>Sometimes a user will have an error in her log message (a
        misspelling or some misinformation, perhaps).  If the
        repository is configured (using the
        <literal>pre-revprop-change</literal> hook; see <xref
        linkend="svn.reposadmin.create.hooks"/>) to accept changes to
        this log message after the commit is finished, the user
        can <quote>fix</quote> her log message remotely using
        <command>svn propset</command> (see <xref
        linkend="svn.ref.svn.c.propset"/>).  However, because of the
        potential to lose information forever, Subversion repositories
        are not, by default, configured to allow changes to
        unversioned properties&mdash;except by an
        administrator.</para>

      <para>If a log message needs to be changed by an administrator,
        this can be done using <command>svnadmin setlog</command>.
        This command changes the log message (the
        <literal>svn:log</literal> property) on a given revision of a
        repository, reading the new value from a provided file.</para>
          
      <screen>
$ echo "Here is the new, correct log message" &gt; newlog.txt
$ svnadmin setlog myrepos newlog.txt -r 388
</screen>
      
      <para>The <command>svnadmin setlog</command> command, by
        default, is
        still bound by the same protections against modifying
        unversioned properties as a remote client is&mdash;the
        <literal>pre-</literal> and
        <literal>post-revprop-change</literal> hooks are still
        triggered, and therefore must be set up to accept changes of
        this nature.  But an administrator can get around these
        protections by passing the <option>--bypass-hooks</option>
        option to the <command>svnadmin setlog</command> command.</para>
 
      <warning>
        <para>Remember, though, that by bypassing the hooks, you are
          likely avoiding such things as email notifications of
          property changes, backup systems that track unversioned
          property changes, and so on.  In other words, be very
          careful about what you are changing, and how you change
          it.</para>
      </warning>


    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.diskspace">
      <title>Managing Disk Space</title>

      <para>While the cost of storage has dropped incredibly in the
        past few years, disk usage is still a valid concern for
        administrators seeking to version large amounts of data.
        Every bit of version history information stored in the live
        repository needs to be backed up
        elsewhere, perhaps multiple times as part of rotating backup
        schedules.  It is useful to know what pieces of Subversion's
        repository data need to remain on the live site, which need to
        be backed up, and which can be safely removed.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.deltas">
        <title>How Subversion saves disk space</title>

        <para>To keep the repository small,
          Subversion uses <firstterm>deltification</firstterm> (or
          deltified storage) within the repository
          itself.  Deltification involves encoding the representation
          of a chunk of data as a collection of differences against
          some other chunk of data.  If the two pieces of data are
          very similar, this deltification results in storage savings
          for the deltified chunk&mdash;rather than taking up space
          equal to the size of the original data, it takes up only
          enough space to say, <quote>I look just like this other
          piece of data over here, except for the following couple of
          changes.</quote>  The result is that most of the repository
          data that tends to be bulky&mdash;namely, the contents of
          versioned files&mdash;is stored at a much smaller size than
          the original full-text representation of that
          data.  And for repositories created with Subversion 1.4 or
          later, the space savings are even better&mdash;now those
          full-text representations of file contents are themselves
          compressed.</para>

        <note>
          <para>Because all of the data that is subject to
            deltification in a BDB-backed repository is stored in a
            single Berkeley DB database file, reducing the size of the
            stored values will not immediately reduce the size of the
            database file itself.  Berkeley DB will, however, keep
            internal records of unused areas of the database file and
            consume those areas first before growing the size of the
            database file.  So while deltification doesn't produce
            immediate space savings, it can drastically slow future
            growth of the database.</para>
        </note>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.deadtxns">
        <title>Removing dead transactions</title>

        <para>Though they are uncommon, there are circumstances in
          which a Subversion commit process might fail, leaving behind
          in the repository the remnants of the revision-to-be that
          wasn't&mdash;an uncommitted transaction and all the file and
          directory changes associated with it.  This could happen for
          several reasons:  perhaps the client operation was
          inelegantly terminated by the user, or a network failure
          occurred in the middle of an operation.
          Regardless of the reason, dead transactions can happen.
          They don't do any real harm, other than consuming disk
          space.  A fastidious administrator may nonetheless wish to
          remove them.</para>

        <para>You can use the <command>svnadmin lstxns</command>
          command to list the names of the currently outstanding
          transactions:</para>

        <screen>
$ svnadmin lstxns myrepos
19
3a1
a45
$
</screen>

        <para>Each item in the resultant output can then be used with
          <command>svnlook</command> (and its
          <option>--transaction</option> (<option>-t</option>) option)
          to determine who created the transaction, when it was
          created, what types of changes were made in the
          transaction&mdash;information that is helpful in determining
          whether the transaction is a safe candidate for
          removal!  If you do indeed want to remove a transaction, its
          name can be passed to <command>svnadmin rmtxns</command>,
          which will perform the cleanup of the transaction.  In fact,
          <command>svnadmin rmtxns</command> can take its input
          directly from the output of
          <command>svnadmin lstxns</command>!</para>

        <screen>
$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`
$
</screen>

        <para>If you use these two subcommands like this, you should
          consider making your repository temporarily inaccessible to
          clients.  That way, no one can begin a legitimate
          transaction before you start your cleanup.  <xref
          linkend="svn.reposadmin.maint.diskspace.deadtxns.ex-1" />
          contains a bit of shell-scripting that can quickly generate
          information about each outstanding transaction in your
          repository.</para>

        <example id="svn.reposadmin.maint.diskspace.deadtxns.ex-1">
          <title>txn-info.sh (reporting outstanding transactions)</title>

          <programlisting>
#!/bin/sh

### Generate informational output for all outstanding transactions in
### a Subversion repository.

REPOS="${1}"
if [ "x$REPOS" = x ] ; then
  echo "usage: $0 REPOS_PATH"
  exit
fi

for TXN in `svnadmin lstxns ${REPOS}`; do 
  echo "---[ Transaction ${TXN} ]-------------------------------------------"
  svnlook info "${REPOS}" -t "${TXN}"
done
</programlisting>
        </example>

        <para>The output of the script is basically a concatenation of
          several chunks of <command>svnlook info</command> output
          (see <xref linkend="svn.reposadmin.maint.tk.svnlook"/>) and
          will look something like this:</para>

        <screen>
$ txn-info.sh myrepos
---[ Transaction 19 ]-------------------------------------------
sally
2001-09-04 11:57:19 -0500 (Tue, 04 Sep 2001)
0
---[ Transaction 3a1 ]-------------------------------------------
harry
2001-09-10 16:50:30 -0500 (Mon, 10 Sep 2001)
39
Trying to commit over a faulty network.
---[ Transaction a45 ]-------------------------------------------
sally
2001-09-12 11:09:28 -0500 (Wed, 12 Sep 2001)
0
$
</screen>

        <para>A long-abandoned transaction usually represents some
          sort of failed or interrupted commit.  A transaction's
          datestamp can provide interesting information&mdash;for
          example, how likely is it that an operation begun nine
          months ago is still active?</para>

        <para>In short, transaction cleanup decisions need not be made
          unwisely.  Various sources of information&mdash;including
          Apache's error and access logs, Subversion's operational
          logs, Subversion revision history, and so on&mdash;can be
          employed in the decision-making process.  And of course, an
          administrator can often simply communicate with a seemingly
          dead transaction's owner (via email, e.g.) to verify
          that the transaction is, in fact, in a zombie state.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.bdblogs">
        <title>Purging unused Berkeley DB logfiles</title>

        <para>Until recently, the largest offender of disk space usage
          with respect to BDB-backed Subversion repositories were the
          logfiles in which Berkeley DB performs its prewrites before
          modifying the actual database files.  These files capture
          all the actions taken along the route of changing the
          database from one state to another&mdash;while the database
          files, at any given time, reflect a particular state, the
          logfiles contain all of the many changes along the way
          <emphasis>between</emphasis> states.  Thus, they can grow
          and accumulate quite rapidly.</para>

        <para>Fortunately, beginning with the 4.2 release of Berkeley
          DB, the database environment has the ability to remove its
          own unused logfiles automatically.  Any
          repositories created using <command>svnadmin</command>
          when compiled against Berkeley DB version 4.2 or later
          will be configured for this automatic logfile removal.  If
          you don't want this feature enabled, simply pass the
          <option>--bdb-log-keep</option> option to the
          <command>svnadmin create</command> command.  If you forget
          to do this or change your mind at a later time, simply edit
          the <filename>DB_CONFIG</filename> file found in your
          repository's <filename>db</filename> directory, comment out
          the line that contains the <literal>set_flags
          DB_LOG_AUTOREMOVE</literal> directive, and then run
          <command>svnadmin recover</command> on your repository to
          force the configuration changes to take effect.  See <xref
          linkend="svn.reposadmin.create.bdb"/> for more information about
          database configuration.</para>

        <para>Without some sort of automatic logfile removal in
          place, logfiles will accumulate as you use your repository.
          This is actually somewhat of a feature of the database
          system&mdash;you should be able to recreate your entire
          database using nothing but the logfiles, so these files can
          be useful for catastrophic database recovery.  But
          typically, you'll want to archive the logfiles that are no
          longer in use by Berkeley DB, and then remove them from disk
          to conserve space.  Use the <command>svnadmin
          list-unused-dblogs</command> command to list the unused
          logfiles:</para>

        <screen>
$ svnadmin list-unused-dblogs /var/svn/repos
/var/svn/repos/log.0000000031
/var/svn/repos/log.0000000032
/var/svn/repos/log.0000000033
&hellip;
$ rm `svnadmin list-unused-dblogs /var/svn/repos`
## disk space reclaimed!
</screen>

        <warning>
          <para>BDB-backed repositories whose logfiles are used as
            part of a backup or disaster recovery plan should
            <emphasis>not</emphasis> make use of the logfile
            autoremoval feature.  Reconstruction of a repository's
            data from logfiles can only be accomplished only when
            <emphasis>all</emphasis> the logfiles are available.  If
            some of the logfiles are removed from disk before the
            backup system has a chance to copy them elsewhere, the
            incomplete set of backed-up logfiles is essentially
            useless.</para> </warning>

      </sect3>

    </sect2>
        
    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.recovery">
      <title>Berkeley DB Recovery</title>

      <para>As mentioned in <xref
        linkend="svn.reposadmin.basics.backends.bdb"/>, a Berkeley DB
        repository can sometimes be left in a frozen state if not closed
        properly.  When this happens, an administrator needs to rewind
        the database back into a consistent state.  This is unique to
        BDB-backed repositories, though&mdash;if you are using
        FSFS-backed ones instead, this won't apply to you.  And for
        those of you using Subversion 1.4 with Berkeley DB 4.4 or
        later, you should find that Subversion has become much more
        resilient in these types of situations.  Still, wedged
        Berkeley DB repositories do occur, and an administrator needs
        to know how to safely deal with this circumstance.</para>

      <para>To protect the data in your repository, Berkeley
        DB uses a locking mechanism.  This mechanism ensures that
        portions of the database are not simultaneously modified by
        multiple database accessors, and that each process sees the
        data in the correct state when that data is being read from
        the database.  When a process needs to change something in the
        database, it first checks for the existence of a lock on the
        target data.  If the data is not locked, the process locks the
        data, makes the change it wants to make, and then unlocks the
        data.  Other processes are forced to wait until that lock is
        removed before they are permitted to continue accessing that
        section of the database.  (This has nothing to do with the
        locks that you, as a user, can apply to versioned files within
        the repository; we try to clear up the confusion caused by
        this terminology collision in the sidebar <xref
        linkend="svn.advanced.locking.meanings" />.)</para>

      <para>In the course of using your Subversion repository, fatal
        errors or interruptions can prevent a process from having the
        chance to remove the locks it has placed in the database.  The
        result is that the backend database system gets
        <quote>wedged.</quote>  When this happens, any attempts to
        access the repository hang indefinitely (since each new
        accessor is waiting for a lock to go away&mdash;which isn't
        going to happen).</para>

      <para>If this happens to your repository, don't panic.  The
        Berkeley DB filesystem takes advantage of database
        transactions, checkpoints, and prewrite journaling to
        ensure that only the most catastrophic of events
        <footnote>
          <para>For example, hard drive + huge electromagnet = disaster.</para>
        </footnote>
        can permanently destroy a database environment.  A
        sufficiently paranoid repository administrator will have made
        off-site backups of the repository data in some fashion, but
        don't head off to the tape backup storage closet just yet.</para>

      <para>Instead, use the following recipe to attempt to
        <quote>unwedge</quote> your repository:</para>
   
      <orderedlist>
        <listitem>
          <para>Make sure no processes are accessing (or
            attempting to access) the repository.  For networked
            repositories, this also means shutting down the Apache HTTP
            Server or svnserve daemon.</para>
        </listitem>
        <listitem> 
          <para>Become the user who owns and manages the repository.
            This is important, as recovering a repository while
            running as the wrong user can tweak the permissions of the
            repository's files in such a way that your repository will
            still be inaccessible even after it is 
            <quote>unwedged.</quote></para>
        </listitem>
        <listitem>
          <para>Run the command <userinput>svnadmin recover
            /var/svn/repos</userinput>.  You should see output such as
            this:</para>
              
          <screen>
Repository lock acquired.
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 19.
</screen>
          <para>This command may take many minutes to complete.</para>
        </listitem>
        <listitem>
          <para>Restart the server process.</para>
        </listitem>
      </orderedlist>
            
      <para>This procedure fixes almost every case of repository
        wedging.  Make sure that you run this command as the user that
        owns and manages the database, not just as
        <literal>root</literal>.  Part of the recovery process might
        involve re-creating from scratch various database files (shared
        memory regions, e.g.).  Recovering as
        <literal>root</literal> will create those files such that they
        are owned by <literal>root</literal>, which means that even
        after you restore connectivity to your repository, regular
        users will be unable to access it.</para>

      <para>If the previous procedure, for some reason, does not
        successfully unwedge your repository, you should do two
        things.  First, move your broken repository directory aside
        (perhaps by renaming it to something like
        <filename>repos.BROKEN</filename>) and then restore your
        latest backup of it.  Then, send an email to the Subversion
        users mailing list (at <email>users@subversion.tigris.org</email>)
        describing your problem in detail.  Data integrity is an
        extremely high priority to the Subversion developers.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.migrate">
      <title>Migrating Repository Data Elsewhere</title>
    
      <para>A Subversion filesystem has its data spread throughout
        files in the repository, in a fashion generally
        understood by (and of interest to) only the Subversion
        developers themselves.  However, circumstances may arise that
        call for all, or some subset, of that data to be copied or
        moved into another repository.</para>

      <para>Subversion provides such functionality by way of
        <firstterm>repository dump streams</firstterm>.  A repository
        dump stream (often referred to as a <quote>dump file</quote>
        when stored as a file on disk) is a portable, flat file format
        that describes the various revisions in your
        repository&mdash;what was changed, by whom, when, and so on.
        This dump stream is the primary mechanism used to marshal
        versioned history&mdash;in whole or in part, with or without
        modification&mdash;between repositories.  And Subversion
        provides the tools necessary for creating and loading these
        dump streams: the <command>svnadmin dump</command> and
        <command>svnadmin load</command> subcommands,
        respectively.</para>

      <warning>
        <para>While the Subversion repository dump format contains
          human-readable portions and a familiar structure (it
          resembles an RFC 822 format, the same type of format used
          for most email), it is <emphasis>not</emphasis> a plain-text
          file format.  It is a binary file format, highly sensitive
          to meddling.  For example, many text editors will corrupt
          the file by automatically converting line endings.</para>
      </warning>

      <para>There are many reasons for dumping and loading Subversion
        repository data.  Early in Subversion's life, the most common
        reason was due to the evolution of Subversion itself.  As
        Subversion matured, there were times when changes made to the
        backend database schema caused compatibility issues with
        previous versions of the repository, so users had to dump
        their repository data using the previous version of
        Subversion and load it into a freshly created repository with
        the new version of Subversion.  Now, these types of schema
        changes haven't occurred since Subversion's 1.0 release, and
        the Subversion developers promise not to force users to dump
        and load their repositories when upgrading between minor
        versions (such as from 1.3 to 1.4) of Subversion.  But there
        are still other reasons for dumping and loading, including
        re-deploying a Berkeley DB repository on a new OS or CPU
        architecture, switching between the Berkeley DB and FSFS
        backends, or (as we'll cover later in this chapter in <xref
        linkend="svn.reposadmin.maint.filtering" />) purging versioned
        data from repository history.</para>

      <note>
        <para>The Subversion repository dump format describes
          versioned repository changes only.  It will not carry any
          information about uncommitted transactions, user locks on
          filesystem paths, repository or server configuration
          customizations (including hook scripts), and so on.</para>
      </note>

      <para>Whatever your reason for migrating repository history,
        using the <command>svnadmin dump</command> and
        <command>svnadmin load</command> subcommands is
        straightforward.  <command>svnadmin dump</command> will output
        a range of repository revisions that are formatted using
        Subversion's custom filesystem dump format.  The dump format
        is printed to the standard output stream, while informative
        messages are printed to the standard error stream.  This
        allows you to redirect the output stream to a file while
        watching the status output in your terminal window.  For
        example:</para>

      <screen>
$ svnlook youngest myrepos
26
$ svnadmin dump myrepos &gt; dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
&hellip;
* Dumped revision 25.
* Dumped revision 26.
</screen>

      <para>At the end of the process, you will have a single file
        (<filename>dumpfile</filename> in the previous example) that
        contains all the data stored in your repository in the
        requested range of revisions.  Note that <command>svnadmin
        dump</command> is reading revision trees from the repository
        just like any other <quote>reader</quote> process would
        (e.g., <command>svn checkout</command>), so it's safe
        to run this command at any time.</para>

      <para>The other subcommand in the pair, <command>svnadmin
        load</command>, parses the standard input stream as a
        Subversion repository dump file and effectively replays those
        dumped revisions into the target repository for that
        operation.  It also gives informative feedback, this time
        using the standard output stream:</para>

      <screen>
$ svnadmin load newrepos &lt; dumpfile
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : A ... done.
     * adding path : A/B ... done.
     &hellip;
------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 2
     * editing path : A/mu ... done.
     * editing path : A/D/G/rho ... done.

------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;

&hellip;

&lt;&lt;&lt; Started new txn, based on original revision 25
     * editing path : A/D/gamma ... done.

------- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 26
     * adding path : A/Z/zeta ... done.
     * editing path : A/mu ... done.

------- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;

</screen>

      <para>The result of a load is new revisions added to a
        repository&mdash;the same thing you get by making commits
        against that repository from a regular Subversion client.
        Just as in a commit, you can use hook programs to perform
        actions before and after each of the commits made during a
        load process.  By passing the
        <option>--use-pre-commit-hook</option> and
        <option>--use-post-commit-hook</option> options to
        <command>svnadmin load</command>, you can instruct Subversion
        to execute the pre-commit and post-commit hook programs,
        respectively, for each loaded revision.  You might use these,
        for example, to ensure that loaded revisions pass through the
        same validation steps that regular commits pass through.  Of
        course, you should use these options with care&mdash;if your
        post-commit hook sends emails to a mailing list for each new
        commit, you might not want to spew hundreds or thousands of
        commit emails in rapid succession at that list!  You can read more about the use of hook
        scripts in <xref
        linkend="svn.reposadmin.create.hooks"/>.</para>

      <para>Note that because <command>svnadmin</command> uses
        standard input and output streams for the repository dump and
        load processes, people who are feeling especially saucy can try
        things such as this (perhaps even using different versions of
        <command>svnadmin</command> on each side of the pipe):</para>
  
      <screen>
$ svnadmin create newrepos
$ svnadmin dump oldrepos | svnadmin load newrepos
</screen>

      <para>By default, the dump file will be quite large&mdash;much
        larger than the repository itself.  That's because by default
        every version of every file is expressed as a full text in the
        dump file.  This is the fastest and simplest behavior, and
        it's nice if you're piping the dump data directly into some other
        process (such as a compression program, filtering program, or
        loading process).  But if you're creating a dump file
        for longer-term storage, you'll likely want to save disk space
        by using the <option>--deltas</option> option.  With this
        option, successive revisions of files will be output as
        compressed, binary differences&mdash;just as file revisions
        are stored in a repository.  This option is slower, but it
        results in a dump file much closer in size to the original
        repository.</para>

      <para>We mentioned previously that <command>svnadmin
        dump</command> outputs a range of revisions.  Use the
        <option>--revision</option> (<option>-r</option>) option to
        specify a single revision, or a range of revisions, to dump.
        If you omit this option, all the existing repository revisions
        will be dumped.</para>

      <screen>
$ svnadmin dump myrepos -r 23 &gt; rev-23.dumpfile
$ svnadmin dump myrepos -r 100:200 &gt; revs-100-200.dumpfile
</screen>

      <para>As Subversion dumps each new revision, it outputs only
        enough information to allow a future loader to re-create that
        revision based on the previous one.  In other words, for any
        given revision in the dump file, only the items that were
        changed in that revision will appear in the dump.  The only
        exception to this rule is the first revision that is dumped
        with the current <command>svnadmin dump</command>
        command.</para>

      <para>By default, Subversion will not express the first dumped
        revision as merely differences to be applied to the previous
        revision.  For one thing, there is no previous revision in the
        dump file!  And second, Subversion cannot know the state of
        the repository into which the dump data will be loaded (if it
        ever is).  To ensure that the output of each
        execution of <command>svnadmin dump</command> is
        self-sufficient, the first dumped revision is, by default, a
        full representation of every directory, file, and property in
        that revision of the repository.</para>

      <para>However, you can change this default behavior.  If you add
        the <option>--incremental</option> option when you dump your
        repository, <command>svnadmin</command> will compare the first
        dumped revision against the previous revision in the
        repository&mdash;the same way it treats every other revision that
        gets dumped.  It will then output the first revision exactly
        as it does the rest of the revisions in the dump
        range&mdash;mentioning only the changes that occurred in that
        revision.  The benefit of this is that you can create several
        small dump files that can be loaded in succession, instead of
        one large one, like so:</para>

      <screen>
$ svnadmin dump myrepos -r 0:1000 &gt; dumpfile1
$ svnadmin dump myrepos -r 1001:2000 --incremental &gt; dumpfile2
$ svnadmin dump myrepos -r 2001:3000 --incremental &gt; dumpfile3
</screen>

      <para>These dump files could be loaded into a new repository
        with the following command sequence:</para>

      <screen>
$ svnadmin load newrepos &lt; dumpfile1
$ svnadmin load newrepos &lt; dumpfile2
$ svnadmin load newrepos &lt; dumpfile3
</screen>

      <para>Another neat trick you can perform with this
        <option>--incremental</option> option involves appending to an
        existing dump file a new range of dumped revisions.  For
        example, you might have a <literal>post-commit</literal> hook
        that simply appends the repository dump of the single revision
        that triggered the hook.  Or you might have a script that runs
        nightly to append dump file data for all the revisions that
        were added to the repository since the last time the script
        ran.  Used like this, <command>svnadmin dump</command> can be
        one way to back up changes to your repository over time in case
        of a system crash or some other catastrophic event.</para>

      <para>The dump format can also be used to merge the contents of
        several different repositories into a single repository.  By
        using the <option>--parent-dir</option> option of
        <command>svnadmin load</command>, you can specify a new
        virtual root directory for the load process.  That means if
        you have dump files for three repositories&mdash;say
        <filename>calc-dumpfile</filename>,
        <filename>cal-dumpfile</filename>, and
        <filename>ss-dumpfile</filename>&mdash;you can first create a new
        repository to hold them all:</para>

      <screen>
$ svnadmin create /var/svn/projects
$
</screen>

      <para>Then, make new directories in the repository that will
        encapsulate the contents of each of the three previous
        repositories:</para>

      <screen>
$ svn mkdir -m "Initial project roots" \
      file:///var/svn/projects/calc \
      file:///var/svn/projects/calendar \
      file:///var/svn/projects/spreadsheet
Committed revision 1.
$ 
</screen>

      <para>Lastly, load the individual dump files into their
        respective locations in the new repository:</para>

      <screen>
$ svnadmin load /var/svn/projects --parent-dir calc &lt; calc-dumpfile
&hellip;
$ svnadmin load /var/svn/projects --parent-dir calendar &lt; cal-dumpfile
&hellip;
$ svnadmin load /var/svn/projects --parent-dir spreadsheet &lt; ss-dumpfile
&hellip;
$
</screen>

      <para>We'll mention one final way to use the Subversion
        repository dump format&mdash;conversion from a different
        storage mechanism or version control system altogether.
        Because the dump file format is, for the most part,
        human-readable, it should be relatively easy to describe
        generic sets of changes&mdash;each of which should be treated
        as a new revision&mdash;using this file format.  In fact, the
        <command>cvs2svn</command> utility (see <xref
        linkend="svn.forcvs.convert"/>) uses the dump format to
        represent the contents of a CVS repository so that those
        contents can be copied into a Subversion repository.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.filtering">
      <title>Filtering Repository History</title>

      <para>Since Subversion stores your versioned history using, at
        the very least, binary differencing algorithms and data
        compression (optionally in a completely opaque database
        system), attempting manual tweaks is unwise if not quite
        difficult, and at any rate strongly discouraged.  And once
        data has been stored in your repository, Subversion
        generally doesn't provide an easy way to remove that data.
        <footnote>
          <para>That's rather the reason you use version control at
            all, right?</para>
        </footnote>
        But inevitably, there will be times when you would like to
        manipulate the history of your repository.  You might need
        to strip out all instances of a file that was accidentally
        added to the repository (and shouldn't be there for whatever
        reason).
        <footnote>
          <para>Conscious, cautious removal of certain bits of
            versioned data is actually supported by real use cases.
            That's why an <quote>obliterate</quote> feature has been
            one of the most highly requested Subversion features,
            and one which the Subversion developers hope to soon
            provide.</para>
        </footnote>
        Or, perhaps you have multiple projects sharing a
        single repository, and you decide to split them up into
        their own repositories.  To accomplish tasks such as these,
        administrators need a more manageable and malleable
        representation of the data in their repositories&mdash;the
        Subversion repository dump format.</para>

      <para>As we described earlier in <xref
        linkend="svn.reposadmin.maint.migrate" />, the Subversion
        repository dump format is a human-readable representation of
        the changes that you've made to your versioned data over time.
        Use the <command>svnadmin dump</command> command to generate
        the dump data, and <command>svnadmin load</command> to
        populate a new repository with it.  The great thing about the
        human-readability aspect of the dump format is that, if you
        aren't careless about it, you can manually inspect and modify
        it.  Of course, the downside is that if you have three years'
        worth of repository activity encapsulated in what is likely to
        be a very large dump file, it could take you a long, long time
        to manually inspect and modify it.</para>

      <para>That's where <command>svndumpfilter</command> becomes
        useful.  This program acts as a path-based filter for
        repository dump streams.  Simply give it either a list of
        paths you wish to keep or a list of paths you wish to not
        keep, and then pipe your repository dump data through this
        filter.  The result will be a modified stream of dump data
        that contains only the versioned paths you (explicitly or
        implicitly) requested.</para>

      <para>Let's look at a realistic example of how you might use this
        program.  Earlier in this chapter (see <xref
        linkend="svn.reposadmin.projects.chooselayout"/>), we discussed the
        process of deciding how to choose a layout for the data in
        your repositories&mdash;using one repository per project or
        combining them, arranging stuff within your repository, and
        so on.  But sometimes after new revisions start flying in,
        you rethink your layout and would like to make some changes.
        A common change is the decision to move multiple projects
        that are sharing a single repository into separate
        repositories for each project.</para>

      <para>Our imaginary repository contains three projects:
        <literal>calc</literal>, <literal>calendar</literal>, and
        <literal>spreadsheet</literal>.  They have been living
        side-by-side in a layout like this:</para>

      <screen>
/
   calc/
      trunk/
      branches/
      tags/
   calendar/
      trunk/
      branches/
      tags/
   spreadsheet/
      trunk/
      branches/
      tags/
</screen>

      <para>To get these three projects into their own repositories,
        we first dump the whole repository:</para>

      <screen>
$ svnadmin dump /var/svn/repos &gt; repos-dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
* Dumped revision 3.
&hellip;
$
</screen>

      <para>Next, run that dump file through the filter, each time
        including only one of our top-level directories.  This results
        in three new dump files:</para>

      <screen>
$ svndumpfilter include calc &lt; repos-dumpfile &gt; calc-dumpfile
&hellip;
$ svndumpfilter include calendar &lt; repos-dumpfile &gt; cal-dumpfile
&hellip;
$ svndumpfilter include spreadsheet &lt; repos-dumpfile &gt; ss-dumpfile
&hellip;
$
</screen>

      <para>At this point, you have to make a decision.  Each of your
        dump files will create a valid repository, but will preserve
        the paths exactly as they were in the original repository.
        This means that even though you would have a repository solely
        for your <literal>calc</literal> project, that repository
        would still have a top-level directory named
        <filename>calc</filename>.  If you want your
        <filename>trunk</filename>, <filename>tags</filename>, and
        <filename>branches</filename> directories to live in the root
        of your repository, you might wish to edit your dump files,
        tweaking the <literal>Node-path</literal> and
        <literal>Node-copyfrom-path</literal> headers so that they no
        longer have that first <filename>calc/</filename> path
        component.  Also, you'll want to remove the section of dump
        data that creates the <filename>calc</filename> directory.  It
        will look something like the following:</para>

      <screen>
Node-path: calc
Node-action: add
Node-kind: dir
Content-length: 0
  
</screen>

      <warning>
        <para>If you do plan on manually editing the dump file to
          remove a top-level directory, make sure your editor is
          not set to automatically convert end-of-line characters to
          the native format (e.g., <literal>\r\n</literal> to
          <literal>\n</literal>), as the content will then not agree
          with the metadata.  This will render the dump file
          useless.</para>
      </warning>

      <para>All that remains now is to create your three new
        repositories, and load each dump file into the right
        repository, ignoring the UUID found in the dump stream:</para>

      <screen>
$ svnadmin create calc
$ svnadmin load --ignore-uuid calc &lt; calc-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : button.c ... done.
&hellip;
$ svnadmin create calendar
$ svnadmin load --ignore-uuid calendar &lt; cal-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : cal.c ... done.
&hellip;
$ svnadmin create spreadsheet
$ svnadmin load --ignore-uuid spreadsheet &lt; ss-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : ss.c ... done.
&hellip;
$
</screen>

      <para>Both of <command>svndumpfilter</command>'s subcommands
        accept options for deciding how to deal with
        <quote>empty</quote> revisions.  If a given revision
        contains only changes to paths that were filtered out, that
        now-empty revision could be considered uninteresting or even
        unwanted.  So to give the user control over what to do with
        those revisions, <command>svndumpfilter</command> provides
        the following command-line options:</para>

      <variablelist>
        <varlistentry>
          <term><option>--drop-empty-revs</option></term>
          <listitem>
            <para>Do not generate empty revisions at all&mdash;just
              omit them.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><option>--renumber-revs</option></term>
          <listitem>
            <para>If empty revisions are dropped (using the
              <option>--drop-empty-revs</option> option), change the
              revision numbers of the remaining revisions so that
              there are no gaps in the numeric sequence.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><option>--preserve-revprops</option></term>
          <listitem>
            <para>If empty revisions are not dropped, preserve the
              revision properties (log message, author, date, custom
              properties, etc.) for those empty revisions.
              Otherwise, empty revisions will contain only the
              original datestamp, and a generated log message that
              indicates that this revision was emptied by
              <command>svndumpfilter</command>.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      
      <para>While <command>svndumpfilter</command> can be very
        useful and a huge timesaver, there are unfortunately a
        couple of gotchas.  First, this utility is overly sensitive
        to path semantics.  Pay attention to whether paths in your
        dump file are specified with or without leading slashes.
        You'll want to look at the <literal>Node-path</literal> and
        <literal>Node-copyfrom-path</literal> headers.</para>

      <screen>
&hellip;
Node-path: spreadsheet/Makefile
&hellip;
</screen>

      <para>If the paths have leading slashes, you should
        include leading slashes in the paths you pass to
        <command>svndumpfilter include</command> and
        <command>svndumpfilter exclude</command> (and if they don't,
        you shouldn't).  Further, if your dump file has an inconsistent
        usage of leading slashes for some reason,
        <footnote>
          <para>While <command>svnadmin dump</command> has a
            consistent leading slash policy (to not include
            them), other programs that generate dump data might
            not be so consistent.</para>
        </footnote>
        you should probably normalize those paths so that they all
        have, or all lack, leading slashes.</para>

      <para>Also, copied paths can give you some trouble.
        Subversion supports copy operations in the repository, where
        a new path is created by copying some already existing path.
        It is possible that at some point in the lifetime of your
        repository, you might have copied a file or directory from
        some location that <command>svndumpfilter</command> is
        excluding, to a location that it is including.  To
        make the dump data self-sufficient,
        <command>svndumpfilter</command> needs to still show the
        addition of the new path&mdash;including the contents of any
        files created by the copy&mdash;and not represent that
        addition as a copy from a source that won't exist in your
        filtered dump data stream.  But because the Subversion
        repository dump format shows only what was changed in each
        revision, the contents of the copy source might not be
        readily available.  If you suspect that you have any copies
        of this sort in your repository, you might want to rethink
        your set of included/excluded paths, perhaps including the
        paths that served as sources of your troublesome copy
        operations, too.</para>

      <para>Finally, <command>svndumpfilter</command> takes path
        filtering quite literally.  If you are trying to copy the
        history of a project rooted at
        <filename>trunk/my-project</filename> and move it into a
        repository of its own, you would, of course, use the
        <command>svndumpfilter include</command> command to keep all
        the changes in and under
        <filename>trunk/my-project</filename>.  But the resultant
        dump file makes no assumptions about the repository into
        which you plan to load this data.  Specifically, the dump
        data might begin with the revision that added the
        <filename>trunk/my-project</filename> directory, but it will
        <emphasis>not</emphasis> contain directives that would
        create the <filename>trunk</filename> directory itself
        (because <filename>trunk</filename> doesn't match the
        include filter).  You'll need to make sure that any
        directories that the new dump stream expects to exist
        actually do exist in the target repository before trying to
        load the stream into that repository.</para>

    </sect2>
  
    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.replication">
      <title>Repository Replication</title>

      <para>There are several scenarios in which it is quite handy to
        have a Subversion repository whose version history is exactly
        the same as some other repository's.  Perhaps the most obvious
        one is the maintenance of a simple backup repository, used
        when the primary repository has become inaccessible due to a
        hardware failure, network outage, or other such annoyance.
        Other scenarios include deploying mirror repositories to
        distribute heavy Subversion load across multiple servers, use
        as a soft-upgrade mechanism, and so on.</para>

      <para>As of version 1.4, Subversion provides a program for
        managing scenarios such as
        these&mdash;<command>svnsync</command>.  This works by
        essentially asking the Subversion server to
        <quote>replay</quote> revisions, one at a time.  It then uses
        that revision information to mimic a commit of the same to
        another repository.  Neither repository needs to be locally
        accessible to the machine on which <command>svnsync</command> is
        running&mdash;its parameters are repository URLs, and it does
        all its work through Subversion's Repository Access (RA)
        interfaces.  All it requires is read access to the source
        repository and read/write access to the destination
        repository.</para>

      <note>
        <para>When using <command>svnsync</command> against a remote
          source repository, the Subversion server for that repository
          must be running Subversion version 1.4 or later.</para>
      </note>

      <para>Assuming you already have a source repository that you'd
        like to mirror, the next thing you need is an empty target
        repository that will actually serve as that mirror.  This
        target repository can use either of the available filesystem
        data-store backends (see <xref
        linkend="svn.reposadmin.basics.backends" />), but it must not
        yet have any version history in it.  The protocol that
        <command>svnsync</command> uses to communicate revision information
        is highly sensitive to mismatches between the versioned
        histories contained in the source and target repositories.
        For this reason, while <command>svnsync</command> cannot
        <emphasis>demand</emphasis> that the target repository be
        read-only,
        <footnote>
          <para>In fact, it can't truly be read-only, or
            <command>svnsync</command> itself would have a tough time
            copying revision history into it.</para>
        </footnote>
        allowing the revision history in the target repository to
        change by any mechanism other than the mirroring process is a
        recipe for disaster.</para>

      <warning>
        <para>Do <emphasis>not</emphasis> modify a mirror repository
          in such a way as to cause its version history to deviate
          from that of the repository it mirrors.  The only commits
          and revision property modifications that ever occur on that
          mirror repository should be those performed by the
          <command>svnsync</command> tool.</para>
      </warning>

      <para>Another requirement of the target repository is that the
        <command>svnsync</command> process be allowed to modify
        revision properties.  Because <command>svnsync</command> works
        within the framework of that repository's hook system, the
        default state of the repository (which is to disallow revision
        property changes; see <xref
        linkend="svn.ref.reposhooks.pre-revprop-change" />) is
        insufficient.  You'll need to explicitly implement the
        pre-revprop-change hook, and your script must allow
        <command>svnsync</command> to set and change revision
        properties.  With those provisions in place, you are ready to
        start mirroring repository revisions.</para>

      <tip>
        <para>It's a good idea to implement authorization measures
          that allow your repository replication process to perform
          its tasks while preventing other users from modifying the
          contents of your mirror repository at all.</para>
      </tip>

      <para>Let's walk through the use of <command>svnsync</command>
        in a somewhat typical mirroring scenario.  We'll pepper this
        discourse with practical recommendations, which you are free to
        disregard if they aren't required by or suitable for your
        environment.</para>

      <para>As a service to the fine developers of our favorite
        version control system, we will be mirroring the public
        Subversion source code repository and exposing that mirror
        publicly on the Internet, hosted on a different machine than
        the one on which the original Subversion source code
        repository lives.  This remote host has a global configuration
        that permits anonymous users to read the contents of
        repositories on the host, but requires users to authenticate
        to modify those repositories.  (Please forgive us for
        glossing over the details of Subversion server configuration
        for the moment&mdash;those are covered thoroughly in <xref
        linkend="svn.serverconfig" />.)  And for no other reason than
        that it makes for a more interesting example, we'll be driving
        the replication process from a third machine&mdash;the one that
        we currently find ourselves using.</para>

      <para>First, we'll create the repository which will be our
        mirror.  This and the next couple of steps do require shell
        access to the machine on which the mirror repository will
        live.  Once the repository is all configured, though, we
        shouldn't need to touch it directly again.</para>

      <screen>
$ ssh admin@svn.example.com \
      "svnadmin create /var/svn/svn-mirror"
admin@svn.example.com's password: ********
$
</screen>

      <para>At this point, we have our repository, and due to our
        server's configuration, that repository is now
        <quote>live</quote> on the Internet.  Now, because we don't
        want anything modifying the repository except our replication
        process, we need a way to distinguish that process from other
        would-be committers.  To do so, we use a dedicated username
        for our process.  Only commits and revision property
        modifications performed by the special username
        <literal>syncuser</literal> will be allowed.</para>

      <para>We'll use the repository's hook system both to allow the
        replication process to do what it needs to do and to enforce
        that only it is doing those things.  We accomplish this by
        implementing two of the repository event
        hooks&mdash;pre-revprop-change and start-commit.  Our
        <filename>pre-revprop-change</filename> hook script is found
        in <xref
        linkend="svn.reposadmin.maint.replication.pre-revprop-change"
        />, and basically verifies that the user attempting the
        property changes is our <literal>syncuser</literal> user.  If
        so, the change is allowed; otherwise, it is denied.</para>

      <example id="svn.reposadmin.maint.replication.pre-revprop-change">
        <title>Mirror repository's pre-revprop-change hook script</title>

        <programlisting>
#!/bin/sh 

USER="$3"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Only the syncuser user may change revision properties" &gt;&amp;2
exit 1
</programlisting>
      </example>

      <para>That covers revision property changes.  Now we need to
        ensure that only the <literal>syncuser</literal> user is
        permitted to commit new revisions to the repository.  We do
        this using a <filename>start-commit</filename> hook scripts
        such as the one in <xref
        linkend="svn.reposadmin.maint.replication.start-commit"
        />.</para>

      <example id="svn.reposadmin.maint.replication.start-commit">
        <title>Mirror repository's start-commit hook script</title>

        <programlisting>
#!/bin/sh 

USER="$2"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Only the syncuser user may commit new revisions" &gt;&amp;2
exit 1
</programlisting>
      </example>

      <para>After installing our hook scripts and ensuring that they
        are executable by the Subversion server, we're finished with
        the setup of the mirror repository.  Now, we get to actually
        do the mirroring.</para>

      <para>The first thing we need to do with
        <command>svnsync</command> is to register in our target
        repository the fact that it will be a mirror of the source
        repository.  We do this using the <command>svnsync
        initialize</command> subcommand.  The URLs we provide point to
        the root directories of the target and source repositories,
        respectively.  In Subversion 1.4, this is required&mdash;only
        full mirroring of repositories is permitted.  In Subversion
        1.5, though, you can use <command>svnsync</command> to mirror
        only some subtree of the repository, too.</para>

      <screen>
$ svnsync help init
initialize (init): usage: svnsync initialize DEST_URL SOURCE_URL

Initialize a destination repository for synchronization from
another repository.
&hellip;
$ svnsync initialize http://svn.example.com/svn-mirror \
                     http://svn.collab.net/repos/svn \
                     --sync-username syncuser --sync-password syncpass
Copied properties for revision 0.
$
</screen>

      <para>Our target repository will now remember that it is a
        mirror of the public Subversion source code repository.
        Notice that we provided a username and password as arguments
        to <command>svnsync</command>&mdash;that was required by the
        pre-revprop-change hook on our mirror repository.</para>

      <note>
        <para>In Subversion 1.4, the values given to
          <command>svnsync</command>'s <option>--username</option> and
          <option>--password</option> command-line options were used
          for authentication against both the source and destination
          repositories.  This caused problems when a user's
          credentials weren't exactly the same for both repositories,
          especially when running in noninteractive mode (with the
          <option>--non-interactive</option> option).</para>

        <para>This has been fixed in Subversion 1.5 with the
          introduction of two new pairs of options.  Use
          <option>--source-username</option> and
          <option>--source-password</option> to provide authentication
          credentials for the source repository; use
          <option>--sync-username</option> and
          <option>--sync-password</option> to provide credentials for
          the destination repository.  (The old
          <option>--username</option> and <option>--password</option>
          options still exist for compatibility, but we advise against
          using them.)</para>

      </note>

      <para>And now comes the fun part.  With a single subcommand, we
        can tell <command>svnsync</command> to copy all the
        as-yet-unmirrored revisions from the source repository to the
        target.
        <footnote>
          <para>Be forewarned that while it will take only a few
            seconds for the average reader to parse this paragraph and
            the sample output that follows it, the actual time
            required to complete such a mirroring operation is, shall
            we say, quite a bit longer.</para>
        </footnote>
        The <command>svnsync synchronize</command> subcommand will
        peek into the special revision properties previously stored on
        the target repository, and determine both what repository it
        is mirroring as well as that the most recently mirrored
        revision was revision 0.  Then it will query the source
        repository and determine what the latest revision in that
        repository is.  Finally, it asks the source repository's
        server to start replaying all the revisions between 0 and that
        latest revision.  As <command>svnsync</command> get the
        resultant response from the source repository's server, it
        begins forwarding those revisions to the target repository's
        server as new commits.</para>

      <screen>
$ svnsync help synchronize
synchronize (sync): usage: svnsync synchronize DEST_URL

Transfer all pending revisions to the destination from the source
with which it was initialized.
&hellip;
$ svnsync synchronize http://svn.example.com/svn-mirror
Transmitting file data ........................................
Committed revision 1.
Copied properties for revision 1.
Transmitting file data ..
Committed revision 2.
Copied properties for revision 2.
Transmitting file data .....
Committed revision 3.
Copied properties for revision 3.
&hellip;
Transmitting file data ..
Committed revision 23406.
Copied properties for revision 23406.
Transmitting file data .
Committed revision 23407.
Copied properties for revision 23407.
Transmitting file data ....
Committed revision 23408.
Copied properties for revision 23408.
$
</screen>

      <para>Of particular interest here is that for each mirrored
        revision, there is first a commit of that revision to the
        target repository, and then property changes follow.  This is
        because the initial commit is performed by (and attributed to)
        the user <literal>syncuser</literal>, and it is datestamped
        with the time as of that revision's creation.  Also,
        Subversion's underlying repository access interfaces don't
        provide a mechanism for setting arbitrary revision properties
        as part of a commit.  So <command>svnsync</command> follows up
        with an immediate series of property modifications that copy
        into the target repository all the revision properties found
        for that revision in the source repository.  This also has the
        effect of fixing the author and datestamp of the revision to
        match that of the source repository.</para>

      <para>Also noteworthy is that <command>svnsync</command>
        performs careful bookkeeping that allows it to be safely
        interrupted and restarted without ruining the integrity of the
        mirrored data.  If a network glitch occurs while mirroring a
        repository, simply repeat the <command>svnsync
        synchronize</command> command, and it will happily pick up
        right where it left off.  In fact, as new revisions appear in
        the source repository, this is exactly what you to do
        to keep your mirror up to date.</para>

      <sidebar>
        <title>svnsync Bookkeeping</title>

        <para><command>svnsync</command> needs to be able to set and
          modify revision properties on the mirror repository because
          those properties are part of the data it is tasked with
          mirroring.  As those properties change in the source
          repository, those changes need to be reflected in the mirror
          repository, too.  But <command>svnsync</command> also uses a
          set of custom revision properties&mdash;stored in revision 0
          of the mirror repository&mdash;for its own internal
          bookkeeping.  These properties contain information such as
          the URL and UUID of the source repository, plus some
          additional state-tracking information.</para>

        <para>One of those pieces of state-tracking information is a
          flag that essentially just means <quote>there's a
          synchronization in progress right now.</quote>  This is used
          to prevent multiple <command>svnsync</command> processes
          from colliding with each other while trying to mirror data
          to the same destination repository.  Now, generally you
          won't need to pay any attention whatsoever to
          <emphasis>any</emphasis> of these special properties (all of
          which begin with the prefix <literal>svn:sync-</literal>).
          Occasionally, though, if a synchronization fails
          unexpectedly, Subversion never has a chance to remove this
          particular state flag.  This causes all future
          synchronization attempts to fail because it appears that a
          synchronization is still in progress when, in fact, none is.
          Fortunately, recovering from this situation is as simple as
          removing the <literal>svn:sync-lock</literal> property which
          serves as this flag from revision 0 of the mirror
          repository:</para>

        <screen>
$ svn propdel --revprop -r0 svn:sync-lock http://svn.example.com/svn-mirror
property 'svn:sync-lock' deleted from repository revision 0
$
</screen>

        <para>That <command>svnsync</command> stores the source
          repository URL in a bookkeeping property on the mirror
          repository is the reason why you have to specify that
          URL only once, during <command>svnsync init</command>.  Future
          synchronization operations against that mirror simply
          consult the special <literal>svn:sync-from-url</literal>
          property stored on the mirror itself to know where
          to synchronize from.  This value is used literally by the
          synchronization process, though.  So while from within
          CollabNet's network you can perhaps access our example
          source URL as <literal>http://svn/repos/svn</literal>
          (because that first <literal>svn</literal> magically gets
          <literal>.collab.net</literal> appended to it by DNS
          voodoo), if you later need to update that mirror from
          another machine outside CollabNet's network, the
          synchronization might fail (because the hostname
          <literal>svn</literal> is ambiguous).  For this reason, it's
          best to use fully qualified source repository URLs when
          initializing a mirror repository rather than those that
          refer to only hostnames or IP addresses (which can change
          over time).  But here again, if you need an existing mirror
          to start referring to a different URL for the same source
          repository, you can change the bookkeeping property which
          houses that information:</para>

        <screen>
$ svn propset --revprop -r0 svn:sync-from-url <replaceable>NEW-SOURCE-URL</replaceable> \
      http://svn.example.com/svn-mirror
property 'svn:sync-from-url' set on repository revision 0
$
</screen>

        <para>Another interesting thing about these special
          bookkeeping properties is that <command>svnsync</command>
          will not attempt to mirror any of those properties when they
          are found in the source repository.  The reason is probably
          obvious, but basically boils down to
          <command>svnsync</command> not being able to distinguish the
          special properties it has merely copied from the source
          repository from those it needs to consult and maintain for
          its own bookkeeping needs.  This situation could occur if,
          for example, you were maintaining a mirror of a mirror of a
          third repository.  When <command>svnsync</command> sees its
          own special properties in revision 0 of the source
          repository, it simply ignores them.</para>

      </sidebar>

      <para>There is, however, one bit of inelegance in the process.
        Because Subversion revision properties can be changed at any
        time throughout the lifetime of the repository, and because
        they don't leave an audit trail that indicates when they were
        changed, replication processes have to pay special attention
        to them.  If you've already mirrored the first 15 revisions of
        a repository and someone then changes a revision property on
        revision 12, <command>svnsync</command> won't know to go back
        and patch up its copy of revision 12.  You'll need to tell it
        to do so manually by using (or with some additional tooling
        around) the <command>svnsync copy-revprops</command>
        subcommand, which simply rereplicates all the revision
        properties for a particular revision or range thereof.</para>

      <screen>
$ svnsync help copy-revprops
copy-revprops: usage: svnsync copy-revprops DEST_URL [REV[:REV2]]

Copy the revision properties in a given range of revisions to the
destination from the source with which it was initialized.
&hellip;
$ svnsync copy-revprops http://svn.example.com/svn-mirror 12
Copied properties for revision 12.
$
</screen>

      <para>That's repository replication in a nutshell.  You'll
        likely want some automation around such a process.  For
        example, while our example was a pull-and-push setup, you
        might wish to have your primary repository push changes to one
        or more blessed mirrors as part of its post-commit and
        post-revprop-change hook implementations.  This would enable
        the mirror to be up to date in as near to real time as is
        likely possible.</para>

      <para>Also, while it isn't very commonplace to do so,
        <command>svnsync</command> does gracefully mirror repositories
        in which the user as whom it authenticates has only partial
        read access.  It simply copies only the bits of the repository
        that it is permitted to see.  Obviously, such a mirror is not
        useful as a backup solution.</para>

      <para>In Subversion 1.5, <command>svnsync</command> grew the
        ability to also mirror a subset of a repository rather than
        the whole thing.  The process of setting up and maintaining
        such a mirror is exactly the same as when mirroring a whole
        repository, except that instead of specifying the source
        repository's root URL when running <command>svnsync
        init</command>, you specify the URL of some subdirectory
        within that repository.  Synchronization to that mirror will
        now copy only the bits that changed under that source
        repository subdirectory.  There are some limitations to this
        support, though.  First, you can't mirror multiple disjoint
        subdirectories of the source repository into a single mirror
        repository&mdash;you'd need to instead mirror some parent
        directory that is common to both.  Second, the filtering
        logic is entirely path-based, so if the subdirectory you are
        mirroring was renamed at some point in the past, your mirror
        would contain only the revisions since the directory appeared
        at the URL you specified.  And likewise, if the source
        subdirectory is renamed in the future, your synchronization
        processes will stop mirroring data at the point that the
        source URL you specified is no longer valid.</para>

      <para>As far as user interaction with repositories and mirrors
        goes, it <emphasis>is</emphasis> possible to have a single
        working copy that interacts with both, but you'll have to jump
        through some hoops to make it happen.  First, you need to
        ensure that both the primary and mirror repositories have the
        same repository UUID (which is not the case by default).  See
        <xref linkend="svn.reposadmin.maint.uuids" /> later in this
        chapter for more about this.</para>
        
      <para>Once the two repositories have the same UUID, you can use
        <command>svn switch</command> with the <option>--relocate</option> option to point your working
        copy to whichever of the repositories you wish to operate
        against, a process that is described in <xref
        linkend="svn.ref.svn.c.switch" />.  There is a possible danger
        here, though, in that if the primary and mirror repositories
        aren't in close synchronization, a working copy up to date
        with, and pointing to, the primary repository will, if
        relocated to point to an out-of-date mirror, become confused
        about the apparent sudden loss of revisions it fully expects
        to be present, and it will throw errors to that effect.  If
        this occurs, you can relocate your working copy back to the
        primary repository and then either wait until the mirror
        repository is up to date, or backdate your working copy to a
        revision you know is present in the sync repository, and then
        retry the relocation.</para>

      <para>Finally, be aware that the revision-based replication
        provided by <command>svnsync</command> is only
        that&mdash;replication of revisions.  Only information carried
        by the Subversion repository dump file format is available for
        replication.  As such, <command>svnsync</command> has the same
        sorts of limitations that the repository dump stream has, and
        does not include such things as the hook implementations,
        repository or server configuration data, uncommitted
        transactions, or information about user locks on repository
        paths.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.backup">
      <title>Repository Backup</title>

      <para>Despite numerous advances in technology since the birth of
        the modern computer, one thing unfortunately rings true with
        crystalline clarity&mdash;sometimes things go very, very
        awry.  Power outages, network connectivity dropouts, corrupt
        RAM, and crashed hard drives are but a taste of the evil that
        Fate is poised to unleash on even the most conscientious
        administrator.  And so we arrive at a very important
        topic&mdash;how to make backup copies of your repository
        data.</para>

      <para>There are two types of backup methods available for
        Subversion repository administrators&mdash;full and
        incremental.  A full backup of the repository involves
        squirreling away in one sweeping action all the information
        required to fully reconstruct that repository in the event of
        a catastrophe.  Usually, it means, quite literally, the
        duplication of the entire repository directory (which includes
        either a Berkeley DB or FSFS environment).  Incremental
        backups are lesser things:  backups of only the portion of the
        repository data that has changed since the previous
        backup.</para>

      <para>As far as full backups go, the naïve approach might seem
        like a sane one, but unless you temporarily disable all other
        access to your repository, simply doing a recursive directory
        copy runs the risk of generating a faulty backup.  In the case
        of Berkeley DB, the documentation describes a certain order in
        which database files can be copied that will guarantee a valid
        backup copy.  A similar ordering exists for FSFS data.  But
        you don't have to implement these algorithms yourself, because
        the Subversion development team has already done so.  The
        <command>svnadmin hotcopy</command> command takes care of the
        minutia involved in making a hot backup of your repository.
        And its invocation is as trivial as the Unix
        <command>cp</command> or Windows <command>copy</command>
        operations:</para>

      <screen>
$ svnadmin hotcopy /var/svn/repos /var/svn/repos-backup
</screen>

      <para>The resultant backup is a fully functional Subversion
        repository, able to be dropped in as a replacement for your
        live repository should something go horribly wrong.</para>

      <para>When making copies of a Berkeley DB repository, you can
        even instruct <command>svnadmin hotcopy</command> to purge any
        unused Berkeley DB logfiles (see <xref
        linkend="svn.reposadmin.maint.diskspace.bdblogs" />) from the
        original repository upon completion of the copy.  Simply
        provide the <option>--clean-logs</option> option on the
        command line.</para>

      <screen>
$ svnadmin hotcopy --clean-logs /var/svn/bdb-repos /var/svn/bdb-repos-backup
</screen>

      <para>Additional tooling around this command is available, too.
        The <filename>tools/backup/</filename> directory of the
        Subversion source distribution holds the
        <command>hot-backup.py</command> script.  This script adds a
        bit of backup management atop <command>svnadmin
        hotcopy</command>, allowing you to keep only the most recent
        configured number of backups of each repository.  It will
        automatically manage the names of the backed-up repository
        directories to avoid collisions with previous backups and
        will <quote>rotate off</quote> older backups, deleting them so
        that only the most recent ones remain.  Even if you also have an
        incremental backup, you might want to run this program on a
        regular basis.  For example, you might consider using
        <command>hot-backup.py</command> from a program scheduler
        (such as <command>cron</command> on Unix systems), which can
        cause it to run nightly (or at whatever granularity of time
        you deem safe).</para>

      <para>Some administrators use a different backup mechanism built
        around generating and storing repository dump data.  We
        described in <xref linkend="svn.reposadmin.maint.migrate" />
        how to use <command>svnadmin dump</command> with the <option>--incremental</option> option to
        perform an incremental backup of a given revision or range of
        revisions.  And of course, you can achieve a full backup variation of
        this by omitting the <option>--incremental</option>
        option to that command.  There is some value in these methods,
        in that the format of your backed-up information is
        flexible&mdash;it's not tied to a particular platform,
        versioned filesystem type, or release of Subversion or
        Berkeley DB.  But that flexibility comes at a cost, namely
        that restoring that data can take a long time&mdash;longer
        with each new revision committed to your repository.  Also, as
        is the case with so many of the various backup methods,
        revision property changes that are made to already backed-up
        revisions won't get picked up by a nonoverlapping,
        incremental dump generation.  For these reasons, we recommend
        against relying solely on dump-based backup approaches.</para>

      <para>As you can see, each of the various backup types and
        methods has its advantages and disadvantages.  The easiest is
        by far the full hot backup, which will always result in a
        perfect working replica of your repository.  Should something
        bad happen to your live repository, you can restore from the
        backup with a simple recursive directory copy.  Unfortunately,
        if you are maintaining multiple backups of your repository,
        these full copies will each eat up just as much disk space as
        your live repository.  Incremental backups, by contrast, tend
        to be quicker to generate and smaller to store.  But the
        restoration process can be a pain, often involving applying
        multiple incremental backups.  And other methods have their
        own peculiarities.  Administrators need to find the balance
        between the cost of making the backup and the cost of
        restoring it.</para>

      <para>The <command>svnsync</command> program (see <xref
        linkend="svn.reposadmin.maint.replication" />) actually
        provides a rather handy middle-ground approach.  If you are
        regularly synchronizing a read-only mirror with your main
        repository, in a pinch your read-only mirror is probably
        a good candidate for replacing that main repository if it
        falls over.  The primary disadvantage of this method is that
        only the versioned repository data gets
        synchronized&mdash;repository configuration files,
        user-specified repository path locks, and other items that
        might live in the physical repository directory but not
        <emphasis>inside</emphasis> the repository's virtual versioned
        filesystem are not handled by <command>svnsync</command>.</para>

      <para>In any backup scenario, repository administrators need
        to be aware of how modifications to unversioned revision
        properties affect their backups.  Since these changes do not
        themselves generate new revisions, they will not trigger
        post-commit hooks, and may not even trigger the
        pre-revprop-change and post-revprop-change hooks.
        <footnote>
          <para><command>svnadmin setlog</command> can be called in a
            way that bypasses the hook interface altogether.</para>
        </footnote>  
        And since you can change revision properties without respect
        to chronological order&mdash;you can change any revision's
        properties at any time&mdash;an incremental backup of the
        latest few revisions might not catch a property modification
        to a revision that was included as part of a previous 
        backup.</para>

      <para>Generally speaking, only the truly paranoid would need to
        back up their entire repository, say, every time a commit
        occurred.  However, assuming that a given repository has some
        other redundancy mechanism in place with relatively fine
        granularity (such as per-commit emails or incremental dumps), a
        hot backup of the database might be something that a
        repository administrator would want to include as part of a
        system-wide nightly backup.  It's your data&mdash;protect it
        as much as you'd like.</para>
            
      <para>Often, the best approach to repository backups is a
        diversified one that leverages combinations of the methods
        described here.  The Subversion developers, for example, back
        up the Subversion source code repository nightly using
        <command>hot-backup.py</command> and an off-site
        <command>rsync</command> of those full backups; keep multiple
        archives of all the commit and property change notification
        emails; and have repository mirrors maintained by various
        volunteers using <command>svnsync</command>.  Your solution
        might be similar, but should be catered to your needs and that
        delicate balance of convenience with paranoia.  And whatever
        you do, validate your backups from time to time&mdash;what
        good is a spare tire that has a hole in it?  While all of this
        might not save your hardware from the iron fist of Fate,
        <footnote>
          <para>You know&mdash;the collective term for all of her
            <quote>fickle fingers.</quote></para>
        </footnote>
        it should certainly help you recover from those trying 
        times.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.uuids">
      <title>Managing Repository UUIDs</title>

      <para>Subversion repositories have a universally unique
        identifier (UUID) associated with them.  This is used by
        Subversion clients to verify the identity of a repository when
        other forms of verification aren't good enough (such as
        checking the repository URL, which can change over time).
        Most Subversion repository administrators rarely, if ever,
        need to think about repository UUIDs as anything more than a
        trivial implementation detail of Subversion.  Sometimes,
        however, there is cause for attention to this detail.</para>

      <para>As a general rule, you want the UUIDs of your live
        repositories to be unique.  That is, after all, the point of
        having UUIDs.  But there are times when you want the
        repository UUIDs of two repositories to be exactly the same.
        For example, if you make a copy of a repository for backup
        purposes, you want the backup to be a perfect replica of the
        original so that, in the event that you have to restore that
        backup and replace the live repository, users don't suddenly
        see what looks like a different repository.  When dumping and
        loading repository history (as described earlier in <xref
        linkend="svn.reposadmin.maint.migrate" />), you get to decide
        whether to apply the UUID encapsulated in the data dump
        stream to the repository in which you are loading the data.  The
        particular circumstance will dictate the correct
        behavior.</para>

      <para>There are a couple of ways to set (or reset) a
        repository's UUID, should you need to.  As of Subversion 1.5,
        this is as simple as using the <command>svnadmin
        setuuid</command> command.  If you provide this subcommand
        with an explicit UUID, it will validate that the UUID is
        well-formed and then set the repository UUID to that value.
        If you omit the UUID, a brand-new UUID will be generated for
        your repository.</para>

      <screen>
$ svnlook uuid /var/svn/repos
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$ svnadmin setuuid /var/svn/repos   # generate a new UUID
$ svnlook uuid /var/svn/repos
3c3c38fe-acc0-11dc-acbc-1b37ff1c8e7c
$ svnadmin setuuid /var/svn/repos \
           cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec  # restore the old UUID
$ svnlook uuid /var/svn/repos
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$
</screen>

      <para>For folks using versions of Subversion earlier than 1.5,
        these tasks are a little more complicated.  You can explicitly
        set a repository's UUID by piping a repository dump file stub
        that carries the new UUID specification through
        <userinput>svnadmin load --force-uuid <replaceable>REPOS-PATH</replaceable></userinput>.</para>

      <screen>
$ svnadmin load --force-uuid /var/svn/repos &lt;&lt;EOF
SVN-fs-dump-format-version: 2

UUID: cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
EOF
$ svnlook uuid /var/svn/repos
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$
</screen>

      <para>Having older versions of Subversion generate a brand-new
        UUID is not quite as simple to do, though.  Your best bet here
        is to find some other way to generate a UUID, and then
        explicitly set the repository's UUID to that value.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.maint.moving-and-removing">
    <title>Moving and Removing Repositories</title>

    <para>Subversion repository data is wholly contained within the
      repository directory.  As such, you can move a Subversion
      repository to some other location on disk, rename a repository,
      copy a repository, or delete a repository altogether using the
      tools provided by your operating system for manipulating
      directories&mdash;<command>mv</command>, <command>cp
      -a</command>, and <command>rm -r</command> on Unix platforms;
      <command>copy</command>, <command>move</command>, and
      <command>rmdir /s /q</command> on Windows; vast numbers of mouse
      and menu gyrations in various graphical file explorer
      applications, and so on.</para>

    <para>Of course, there's often still more to be done when trying
      to cleanly affect changes such as this.  For example, you might
      need to update your Subversion server configuration to point to
      the new location of a relocated repository or to remove
      configuration bits for a now-deleted repository.  If you have
      automated processes that publish information from or about your
      repositories, they may need to be updated.  Hook scripts might
      need to be reconfigured.  Users may need to be notified.  The list
      can go on indefinitely, or at least to the extent that you've
      built processes and procedures around your Subversion
      repository.</para>

    <para>In the case of a copied repository, you should also consider
      the fact that Subversion uses repository UUIDs to distinguish
      repositories.  If you copy a Subversion repository using a
      typical shell recursive copy command, you'll wind up with two
      repositories that are identical in every way&mdash;including their UUIDs.
      In some circumstances, this might be desirable.  But in the
      instances where it is not, you'll need to generate a new UUID
      for one of these identical repositories.  See <xref
      linkend="svn.reposadmin.maint.uuids" /> for more about managing
      repository UUIDs.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.summary">
    <title>Summary</title>

    <para>By now you should have a basic understanding of how to
      create, configure, and maintain Subversion repositories.  We
      introduced you to the various tools that will assist you with
      this task.  Throughout the chapter, we noted common
      administration pitfalls and offered suggestions for avoiding
      them.</para>

    <para>All that remains is for you to decide what exciting data to
      store in your repository, and finally, how to make it available
      over a network.  The next chapter is all about networking.</para>

  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
