<chapter id="svn.reposadmin">
  <title>Administration d'un dépôt</title>

  <para>Le dépôt Subversion est le centre de stockage de toutes vos 
    données suivies en versions. Ainsi, il est de facto l'objet de toute 
    l'attention et de tous les soins de l'administrateur. Bien que ce 
    soit un élément ne nécessitant pas énormément de maintenance, il est 
    important de comprendre comment le configurer et le surveiller 
    correctement de manière à éviter d'éventuels problèmes et à résoudre 
    proprement ceux qui se présentent.</para>

  <para>Dans ce chapitre, nous expliquons comment créer et configurer un 
    dépôt Subversion. Nous abordons également la maintenance du dépôt, 
    en donnant des exemples d'utilisation des outils
    <command>svnlook</command> et <command>svnadmin</command> fournis 
    avec Subversion. Nous étudions quelques questions et erreurs 
    communes et nous donnons des conseils sur l'organisation des 
    données dans le dépôt.</para>

  <para>Si vous n'envisagez pas d'utiliser un dépôt Subversion autrement 
    qu'en simple utilisateur des données (c'est-à-dire en utilisant un 
    client Subversion), vous pouvez sauter ce chapitre. Cependant, si 
    vous êtes (ou si vous êtes appelé à être) l'administrateur d'un 
    dépôt<footnote>
      <para>Cela peut sembler prestigieux et noble, mais il s'agit juste 
        en fait d'une personne intéressée par le monde mystérieux qui se 
        cache derrière la copie de travail que chacun détient.</para>
    </footnote>, ce chapitre est fait pour vous.</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.basics">
    <title>Définition d'un dépôt Subversion</title>

    <para>Avant d'aborder le vaste sujet de l'administration d'un dépôt, 
      définissons plus précisément ce qu'est un dépôt. A quoi 
      ressemble-t-il ? Que ressent-il&nbsp;? Est-ce qu'il préfère son 
      thé chaud ou glacé, sucré, avec une tranche de citron&nbsp;? En 
      tant qu'administrateur, vous vous devez de comprendre de quoi est 
      composé un dépôt, à la fois au niveau du système d'exploitation 
      (à quoi ressemble le dépôt et comment il réagit vis-à-vis des 
      outils autres que Subversion) et au niveau logique de 
      l'organisation des données (comment elles sont représentées
      <emphasis>à l'intérieur</emphasis> du dépôt.</para>

    <para>Du point de vue d'un explorateur de fichiers classique (comme 
      Windows Explorer) ou d'un outil de navigation du système de 
      fichiers en ligne de commande, un dépôt Subversion n'est rien 
      d'autre qu'un répertoire contenant plein de choses. Il y a des 
      sous-répertoires avec des fichiers de configuration lisibles par 
      un humain, des sous-répertoires avec des fichiers de données 
      binaires déjà bien moins lisibles, etc. A l'instar d'autres 
      parties de Subversion, la modularité est une préoccupation majeure 
      et l'organisation hiérarchique prévaut sur le bazar. Un coup 
      d'oeil rapide dans un dépôt typique est suffisant pour obtenir la 
      liste des composants essentiels d'un dépôt&nbsp;:</para>
            
    <screen>
$ ls depot
conf/  dav/  db/  format  hooks/  locks/  README.txt
</screen>

    <para>Effectuons un survol rapide de ce que nous voyons dans ce 
      répertoire (ne vous inquiétez pas si vous ne comprenez pas tous 
      les termes employés, ils sont expliqués dans ce chapitre ou 
      ailleurs dans ce livre)&nbsp;:</para>

    <variablelist>
      <varlistentry>
        <term>conf</term>
        <listitem>
          <para>Un répertoire contenant des fichiers de 
            configuration.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>dav</term>
        <listitem>
          <para>Un répertoire à disposition de 
            <filename>mod_dav_svn</filename> pour y stocker ses 
              informations privées.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>db</term>
        <listitem>
          <para>Le magasin de données pour toutes vos données suivies en 
            versions.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>format</term>
        <listitem>
          <para>Un fichier contenant un unique entier qui indique le 
            numéro de version de l'organisation du dépôt.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>hooks</term>
        <listitem>
          <para>Un répertoire plein de modèles de procédures 
            automatiques (et les procédures automatiques elles-mêmes, 
            une fois installées).</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>locks</term>
        <listitem>
          <para>Un répertoire pour les fichiers de verrous du dépôt 
            Subversion, utilisé pour garder trace de qui accède au 
            dépôt.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>README.txt</term>
        <listitem>
          <para>Un fichier qui ne fait qu'informer son lecteur qu'il est 
            tombé sur un dépôt Subversion.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Bien sûr, quand on y accède via les bibliothèques Subversion, 
      cet ensemble de fichiers et de répertoires se transforme en un 
      système virtuel de fichiers suivis en versions, complet et 
      comportant une gestion des événements personnalisable. Ce système 
      de fichiers possède ses propres notions de répertoires et de 
      fichiers, très similaires aux notions des systèmes de fichiers 
      réels (tels que NTFS, FAT32, ext3, etc.). Mais c'est un système de 
      fichiers spécial&nbsp;: il base ces répertoires et ces fichiers 
      sur les révisions, gardant une trace des tous les changements 
      effectués de manière sûre et accessible pour toujours. C'est là 
      que la totalité de vos données suivies en versions réside.</para>

  </sect1>
 
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.planning">
    <title>Stratégies de déploiement d'un dépôt</title>

    <para>En grande partie grâce à la conception épurée du dépôt 
      Subversion et des technologies sous-jacentes, il est 
      particulièrement aisé de créer et configurer un dépôt. Il y a 
      quelques choix préliminaires à faire mais l'essentiel du travail 
      de création et de configuration d'un dépôt Subversion est simple 
      et convivial, facilement reproductible si vous êtes amené à 
      effectuer des installations multiples.</para>

    <para>Voici quelques questions à se poser avant toute chose&nbsp;:</para>

    <itemizedlist>
      <listitem>
        <para>Quelles données vont être hébergées dans le dépôt (ou les 
          dépôts) et quelle en sera l'organisation&nbsp;?</para>
      </listitem>
      <listitem>
        <para>Où sera placé le dépôt et comment les utilisateurs y 
          accéderont-ils&nbsp;?</para>
      </listitem>
      <listitem>
        <para>De quels types de contrôle d'accès et de notifications 
          d'événements avez-vous besoin&nbsp;?</para>
      </listitem>
      <listitem>
        <para>Quel type de magasin de données désirez-vous 
          utiliser&nbsp;?</para>
      </listitem>
    </itemizedlist>

    <para>Dans cette section, nous essayons de vous aider à 
      répondre à ces questions.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.projects.chooselayout">
      <title>Stratégies d'organisation d'un dépôt</title>

      <para>Bien que Subversion vous permette de déplacer des fichiers 
        et des répertoires suivis en versions sans perte d'information
        et qu'il fournisse même des outils pour déplacer des ensembles 
        complets de données versionnées d'un dépôt à un autre, ces 
        opérations peuvent perturber le travail des autres 
        collaborateurs qui accèdent souvent au dépôt et qui s'attendent 
        à trouver chaque chose à sa place. Ainsi, avant de créer un 
        nouveau dépôt, essayez de vous projeter un peu dans le 
        futur&nbsp;; préparez à l'avance le passage de vos données en 
        suivi de versions. Cette réflexion sur la manière d'organiser 
        vos données dans le dépôt vous évitera de futurs et nombreux 
        maux de tête.</para>

      <para>Supposons qu'en tant qu'administrateur d'un dépôt, vous 
        êtes responsable de l'administration du système de gestion de 
        versions pour plusieurs projets. La première décision à prendre 
        est de choisir entre un seul dépôt pour tous les projets et un 
        dépôt par projet, ou bien un compromis entre ces deux 
        solutions.</para>

      <para>Un seul dépôt pour tous les projets offre des avantages, ne 
        serait-ce que pour la maintenance unifiée. Un seul dépôt 
        signifie qu'il n'y a qu'un seul jeu de procédures automatiques, 
        une seule sauvegarde à gérer, un seul jeu d'opérations de 
        déchargement et de chargement à effectuer si la nouvelle version 
        de Subversion est incompatible avec l'ancienne version, etc. 
        Vous pouvez également déplacer facilement des données entre les 
        projets, sans perdre l'historique de ces informations.</para>

      <para>Les inconvénients à utiliser un seul dépôt sont que les 
        différents projets auront certainement des besoins différents en 
        termes de gestion des événements, comme la notification par 
        e-mail des propagations à des listes d'adresses différentes ou 
        des définitions différentes de ce qui constitue une propagation 
        légitime. Bien sûr, ce ne sont pas des problèmes insurmontables 
        &mdash; cela implique juste que vos procédures automatiques 
        doivent tenir compte de l'organisation du dépôt dans lequel 
        elles sont invoquées plutôt que de considérer que l'ensemble du 
        dépôt est associé à un seul groupe d'utilisateurs. Rappelez-vous 
        également que Subversion utilise des numéros de révisions 
        globaux au dépôt. Bien que ces numéros ne possèdent pas de 
        pouvoirs magiques particuliers, certaines personnes n'aiment pas 
        voir le numéro de révision augmenter alors qu'elles n'ont pas 
        touché à leur propre projet<footnote>
          <para>Que ce soit par ignorance ou par la définition absurde 
            de métriques de développement, les numéros globaux de 
            révision sont craints alors qu'ils sont bien peu de chose et 
            <emphasis>certainement pas</emphasis> à prendre en 
            considération quand vous décidez de l'agencement de vos 
            projets et de vos dépôts.</para>
        </footnote>.
      </para>

      <para>On peut aussi adopter une approche intermédiaire. Par 
        exemple, les projets peuvent être regroupés par thème. Vous 
        pouvez avoir quelques dépôts, avec une poignée de projets dans 
        chaque dépôt. Ainsi, les projets susceptibles de partager des 
        données le font aisément et les développeurs sont tenus au 
        courant des avancées des projets en relation avec les leurs par 
        le biais des nouvelles révisions du dépôt.</para>

      <para>Une fois l'organisation des dépôts définie, il faut se 
        préoccuper de la hiérarchie des répertoires à l'intérieur des 
        dépôts eux-mêmes. Comme Subversion utilise de simples copies de 
        répertoires pour créer les branches et les étiquettes (voir 
        <xref linkend="svn.branchmerge"/>), la communauté Subversion 
        recommande de choisir un endroit dans le dépôt pour la 
        <firstterm>racine</firstterm> de chaque projet (le répertoire 
        dont la sous-arborescence contient toutes les données relatives 
        à un projet) et d'y placer trois sous-répertoires :
        <filename>trunk</filename> (tronc en français), le répertoire 
        qui héberge les principaux développements du projet&nbsp;;
        <filename>branches</filename>, le répertoire dans lequel seront 
        créées les différentes variations de la ligne de développement 
        principale&nbsp;; et <filename>tags</filename> (étiquettes en 
        français), qui contient un ensemble d'instantanés de 
        l'arborescence (les instantanés sont créés, voire détruits, mais 
        jamais modifiés)<footnote>
          <para>Le trio <filename>trunk</filename>, <filename>tags</filename>, 
            et <filename>branches</filename> est quelquefois appelé
            <quote>les répertoires TTB</quote> (<quote>the TTB 
            directories</quote> en anglais).</para>
        </footnote>.
        </para>

      <para>Par exemple, votre dépôt peut ressembler à 
        ceci&nbsp;:</para>

      <screen>
  /
     calculatrice/
        trunk/
        tags/
        branches/
     calendrier/
        trunk/
        tags/
        branches/
     tableur/
        trunk/
        tags/
        branches/
   &hellip;
</screen>

      <para>Veuillez noter que l'emplacement du projet dans le dépôt 
        n'est pas important. Si vous n'avez qu'un seul projet par dépôt, 
        il est logique de placer la racine du projet à la racine du 
        dépôt correspondant. Si vous avez plusieurs projets, vous 
        voulez peut-être les classer par groupes dans des 
        sous-répertoires communs du dépôt, en fonction des objectifs ou 
        du code à partager par exemple, ou tout simplement en les 
        groupant par ordre alphabétique. Voici un exemple&nbsp;:</para>

      <screen>
  /
     utilitaires/
        calculatrice/
           trunk/
           tags/
           branches/
        calendrier/
           trunk/
           tags/
           branches/
      &hellip;
     bureautique/
        tableur/
           trunk/
           tags/
           branches/
      &hellip;
</screen>

      <para>Organisez votre dépôt comme vous le sentez. Subversion n'a 
        aucune exigence en la matière &mdash; pour lui, un répertoire 
        est un répertoire. L'objectif est d'avoir une organisation qui 
        réponde aux besoins des collaborateurs des différents 
        projets.</para>

      <para>Cependant, par souci de transparence, nous indiquons une 
        autre organisation également très répandue. Dans cette 
        organisation, les répertoires <filename>trunk</filename>, 
        <filename>tags</filename>, et <filename>branches</filename> sont 
        situés à la racine du dépôt et les projets sont placés dans des 
        sous-répertoires juste en dessous, comme ceci&nbsp;:</para>

      <screen>
 /
     trunk/
        calculatrice/
        calendrier/
        tableur/
      &hellip;
     tags/
        calculatrice/
        calendrier/
        tableur/
      &hellip;
     branches/
        calculatrice/
        calendrier/
        tableur/
      &hellip;
</screen>

      <para>Il n'y a rien d'incorrect dans une telle organisation, mais 
        elle peut ne pas être très intuitive pour vos utilisateurs. En 
        particulier dans des situations complexes avec plusieurs projets 
        et un grand nombre d'utilisateurs, dont la plupart ne 
        connaissent qu'un ou deux projets du dépôt. Mais cette approche 
        <quote>plusieurs projets par branche</quote> a tendance à 
        favoriser l'ouverture de chaque projet sur les autres et pousse 
        à envisager l'ensemble des projets comme une seule entité. Cela 
        reste un problème social. Nous aimons l'organisation suggérée au 
        début pour des raisons purement pratiques&nbsp;: il est plus 
        facile de faire des requêtes (ou des modifications, des 
        migrations) sur l'historique complet d'un projet quand une 
        sous-arborescence du dépôt contient l'ensemble des données 
        (passé, présent, étiquettes et branches) de ce projet et elles 
        seules.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.hosting">
      <title>Stratégies d'hébergement d'un dépôt</title>

      <para>Avant de créer votre dépôt Subversion, vous devez vous 
        demander où il va résider. C'est fortement lié à une myriade 
        d'autres questions telles que qui sont les utilisateurs 
        (sont-ils à l'intérieur de votre réseau interne, derrière le 
        pare-feu de votre entreprise, ou bien s'agit-il de n'importe 
        qui, n'importe où sur Internet&nbsp;?), comment les utilisateurs 
        accédent au dépôt (via un serveur Subversion ou directement), 
        quels autres services fournissez-vous autour de Subversion (une 
        interface pour navigateur Web, des notifications par mail des 
        propagations, etc.), quelle est votre politique de sauvegarde, 
        et ainsi de suite. </para>

      <para>Le choix et la configuration du serveur sont abordés au 
        <xref linkend="svn.serverconfig" />, mais nous voulons signaler 
        dès maintenant que certains choix pour l'une ou l'autre de ces 
        questions ont des implications sur l'endroit où implémenter 
        votre serveur. Par exemple, certains scénarios de déploiement 
        nécessitent l'accès au dépôt via un système de fichiers distant 
        pour plusieurs ordinateurs et, dans ce cas, le choix du type de 
        magasin de données n'en est plus un, puisqu'un seul type de 
        magasin de données convient dans ce scénario.</para>

      <para>Décrire l'ensemble des possibilités de déploiement de 
        Subversion est impossible et n'est pas l'objectif de ce livre. 
        Nous vous encourageons simplement à évaluer vos choix avec ces 
        quelques pages et d'autres ressources en guise de référence pour 
        planifier correctement les opérations.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.backends">
      <title>Choix du magasin de données</title>

      <para>Depuis la version 1.1, Subversion offre deux types de 
        stockage interne pour le magasin de données<footnote>
          <para>NdT : souvent désigné par <quote>backend</quote> en 
            anglais (sans équivalent en français) ou, ce qui peut être 
            source de confusion, <quote>le système de fichiers 
            (versionné)</quote></para>
        </footnote>
        utilisé par le dépôt. Un des types de magasin de données 
        conserve tout dans une base de données Berkeley DB (ou 
        BDB)&nbsp;; les dépôts qui utilisent ce type de magasin sont 
        qualifiés de <quote>dépôts gérés par BDB</quote> ou 
        <quote>dépôts BDB</quote>. L'autre type de magasin stocke les 
        données dans des fichiers ordinaires, en utilisant un format 
        particulier. Les développeurs de Subversion ont pris l'habitude 
        d'appeler ce type de stockage 
        <firstterm>FSFS</firstterm><footnote>
          <para>Souvent prononcé <quote>fuzz-fuzz</quote> si Jack 
            Repenning en parle (ce livre, cependant, suppose que le 
            lecteur pense <quote>eff-ess-eff-ess</quote>).</para>
        </footnote> 
        &mdash; une implémentation d'un système de fichiers suivis 
        en versions qui utilise le système de fichiers natif du système 
        d'exploitation directement plutôt que par l'intermédiaire d'une 
        bibliothèque de gestionnaire de base de données ou toute autre 
        couche d'abstraction.</para>

      <para>Une comparaison des dépôts utilisant Berkeley DB et FSFS fait
        l'objet du  <xref 
        linkend="svn.reposadmin.basics.backends.tbl-1" />.</para>

      <table id="svn.reposadmin.basics.backends.tbl-1">
        <title>Comparaison des magasins de données de dépôts</title>
        <tgroup cols="4">
          <thead>
            <row>
              <entry>Catégorie</entry>
              <entry>Fonctionnalité</entry>
              <entry>Berkeley DB</entry>
              <entry>FSFS</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry morerows="1">Fiabilité</entry>
              <entry>Intégrité des données</entry>
              <entry>Très fiable quand déployé correctement&nbsp;; 
                Berkeley DB 4.4 apporte l'auto-restauration</entry>
              <entry>Les vieilles versions avaient quelques bogues 
                (rarement démontrés) qui détruisaient des 
                données</entry>
            </row>
            <row>
              <entry>Sensibilité aux interruptions</entry>
              <entry>Forte&nbsp;; les <quote>plantages</quote> et les 
                problèmes de droits peuvent laisser la base de données 
                dans un état instable, nécessitant le recours aux 
                procédures de restauration issues de la 
                journalisation</entry>
              <entry>Quasiment insensible</entry>
            </row>
            <row>
              <entry morerows="3">Accessibilité</entry>
              <entry>Utilisable depuis un montage en lecture seule</entry>
              <entry>Non</entry>
              <entry>Oui</entry>
            </row>
            <row>
              <entry>Stockage indépendant de la plate-forme</entry>
              <entry>Non</entry>
              <entry>Oui</entry>
            </row>
            <row>
              <entry>Utilisable sur des systèmes de fichiers en réseau</entry>
              <entry>Généralement non</entry>
              <entry>Oui</entry>
            </row>
            <row>
              <entry>Gestion des droits pour les groupes </entry>
              <entry>Sensible aux problèmes de umask de 
                l'utilisateur&nbsp;; c'est mieux si un seul utilisateur 
                y accède</entry>
              <entry>Contourne les problèmes de umask</entry>
            </row>
            <row>
              <entry morerows="2">Extensibilité</entry>
              <entry>Utilisation des disques sur le dépôt</entry>
              <entry>Plus grande (surtout si les fichiers de 
                journalisation ne sont pas purgés) </entry>
              <entry>Plus faible</entry>
            </row>
            <row>
              <entry>Nombre de révisions</entry>
              <entry>Base de données, pas de problème</entry>
              <entry>De vieux systèmes de fichiers fonctionnent moins 
                bien lorsqu'il y a plusieurs milliers d'entrées dans un 
                seul répertoire</entry>
            </row>
            <row>
              <entry> Répertoires avec beaucoup de fichiers</entry>
              <entry>Plus lent</entry>
              <entry>Plus rapide</entry>
            </row>
            <row>
              <entry morerows="1">Performances</entry>
              <entry>Extraire la dernière révision</entry>
              <entry>Pas de différence significative</entry>
              <entry>Pas de différence significative</entry>
            </row>
            <row>
              <entry>Grosses propagations</entry>
              <entry>Globalement plus lent, mais mais cette lenteur est 
                répartie sur toute la durée de la propagation</entry>
              <entry>Globalement plus rapide, mais le délai de 
                finalisation peut amener le client à considérer que sa 
                requête a expiré avant qu'il ne reçoive la 
                réponse</entry>
            </row>
          </tbody>
        </tgroup>      
      </table>

      <para>Chaque type de magasin de données a ses avantages et ses 
        inconvénients. Aucun n'est plus <quote>officiel</quote> que 
        l'autre, même si le nouveau FSFS est le magasin par défaut 
        depuis Subversion 1.2. Les deux sont suffisamment fiables pour 
        y stocker vos données suivies en versions en toute confiance. 
        Mais comme l'indique le <xref
        linkend="svn.reposadmin.basics.backends.tbl-1" />, FSFS est un 
        peu plus souple à déployer. Plus de souplesse signifie que vous 
        devez y mettre un peu plus du vôtre pour faire des erreurs lors 
        du déploiement. C'est pourquoi, en plus du fait que ne pas 
        utiliser Berkeley DB permet de compter un composant de moins 
        dans le système, aujourd'hui presque tout le monde utilise FSFS 
        lors de la création de nouveaux dépôts.</para>

      <para>Heureusement, la plupart des programmes qui accèdent aux 
        dépôts Subversion ignorent royalement quel type de magasin de 
        données est utilisé. Et vous n'êtes même pas prisonnier de votre 
        premier choix de magasin&nbsp;: si vous changez d'avis 
        plus tard, Subversion offre différentes façons de migrer les 
        données de votre dépôt dans un autre dépôt utilisant un magasin 
        de données différent. Nous en reparlons plus loin dans ce 
        chapitre.</para>

      <para>Les paragraphes suivants abordent plus en détail les 
        différents types de magasins de données disponibles.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.basics.backends.bdb">
        <title>Berkeley DB</title>
        
        <para>Lors de la conception initiale de Subversion, les 
          développeurs ont décidé d'utiliser le gestionnaire de bases de 
          données Berkeley DB pour tout un tas de raisons, entre autres 
          sa licence Open Source, son support des transactions, sa 
          fiabilité, ses performances, la simplicité de son interface de 
          programmation (API), le bon support des processus légers 
          (threads), le support des curseurs, etc.</para>

        <para>Le gestionnaire de bases de données Berkeley DB apporte un 
          support réel des transactions (c'est peut-être sa 
          fonctionnalité la plus puissante). Si de nombreux processus 
          accèdent en même temps au dépôt, ils n'ont pas à se soucier 
          d'éventuelles corruptions de données de la part des autres 
          processus. L'isolement créé par le système de transaction est 
          tel que, pour une opération donnée, Subversion voit une base de 
          données statique &mdash; pas une base de données en perpétuel 
          changement en raison des autres processus &mdash; et peut donc 
          prendre des décisions à partir de cette perspective. Si la 
          décision entraîne un conflit avec ce que fait un autre 
          processus, l'opération complète est annulée, tout se passe 
          comme si elle n'avait jamais eu lieu et Subversion essaie une 
          nouvelle fois son opération sur la base de données mise à jour 
          (qui apparaît toujours statique).</para>

        <para>Une autre fonctionnalité phare du gestionnaire de bases de 
          données Berkeley DB est la  <firstterm>sauvegarde à 
          chaud </firstterm> &mdash; la capacité de sauvegarde de 
          l'environnement de la base de données sans la couper du 
          réseau. Nous voyons comment réaliser une sauvegarde de votre 
          dépôt plus tard dans ce chapitre (dans <xref
          linkend="svn.reposadmin.maint.backup"/>), mais le bénéfice de 
          pouvoir faire des copies opérationnelles de vos dépôts sans 
          interruption de service doit vous sauter aux yeux.</para>

        <para>Le gestionnaire de bases de données Berkeley DB est aussi 
          très fiable quand il est utilisé correctement. Subversion 
          utilise les fonctions de journalisation du gestionnaire de 
          bases de données Berkeley DB, ce qui veut dire que la base de 
          données consigne d'abord, dans un fichier de journalisation 
          situé sur disque, chaque modification qu'elle s'apprête à 
          effectuer, puis effectue la modification elle-même. Cela 
          garantit que si quelque chose se passe mal, le gestionnaire de 
          base de données peut revenir à un <firstterm>point de 
          contrôle</firstterm> précédent &mdash; un point précis des 
          fichiers de journalisation dont il sait qu'il n'est pas 
          corrompu &mdash; et rejouer les transactions jusqu'à ce que 
          les données soient dans un état opérationnel. Voir <xref 
          linkend="svn.reposadmin.maint.diskspace"/> plus loin dans ce 
          chapitre pour plus de détails sur les fichiers de 
          journalisation Berkeley DB.</para>

        <para>Mais chaque médaille à son revers et nous devons vous 
          avertir de quelques limitations du gestionnaire de bases de 
          données Berkeley DB. Premièrement, les environnements du 
          gestionnaire de bases de données Berkeley DB ne sont pas 
          portables. Vous ne pouvez pas simplement copier un dépôt 
          Subversion qui a été créé sur un système Unix vers un système 
          Windows et espérer qu'il fonctionne. Bien que la majeure 
          partie de la base de données Berkeley DB soit indépendante de 
          l'architecture, d'autres aspects de l'environnement ne le sont 
          pas. Deuxièmement, Subversion utilise le gestionnaire de bases 
          de données Berkeley DB de telle façon que cela ne fonctionne 
          pas sur un système Windows 95/98&nbsp;: si vous avez besoin 
          d'héberger un dépôt géré par BDB sur une machine Windows, 
          adoptez Windows 2000 ou plus.</para>

        <para>Alors que le gestionnaire de bases de données Berkeley DB 
          prétend fonctionner correctement sur un système de fichiers en 
          réseau pour peu que celui-ci respecte des caractéristiques 
          particulières<footnote>
            <para>Berkeley DB requiert que le système de fichiers 
              sous-jacent implémente strictement la sémantique POSIX sur 
              les verrous et, plus important encore, la possibilité de 
              projeter les fichiers directement en mémoire vive.</para>
          </footnote>,
          la plupart des systèmes de fichiers en réseau et des systèmes 
          dédiés <emphasis>n'atteignent pas</emphasis> ces pré-requis. 
          Et en aucun cas il ne vous est possible de partager ce dépôt 
          sur un système de fichiers en réseau entre plusieurs clients 
          (alors que c'est quand même l'intérêt principal d'un dépôt 
          accessible sur un partage réseau).</para>

        <warning>
          <para>Si vous tentez d'utiliser le gestionnaire de bases de 
            données Berkeley DB sur un système de fichiers en réseau non 
            compatible, les résultats sont imprévisibles&nbsp;: vous 
            vous apercevrez peut-être immédiatement de mystérieuses 
            erreurs, mais il se peut qu'il se passe des mois avant que 
            vous ne découvriez que votre base de données de dépôt est 
            corrompue. Songez sérieusement à utiliser un magasin FSFS 
            pour les dépôts qui doivent être hébergés sur un partage 
            réseau.</para>
        </warning>
          
        <para>Finalement, parce que la bibliothèque du gestionnaire de 
          bases de données Berkeley DB est directement incluse dans 
          Subversion, elle est plus sensible aux interruptions qu'une 
          base de données relationnelle classique. La plupart des 
          systèmes SQL, par exemple, disposent d'un processus serveur 
          dédié qui coordonne tous les accès aux tables. Si un programme 
          qui accède aux tables plante pour une raison ou une autre, le 
          processus serveur de la base de données s'en aperçoit et fait 
          le ménage. Et comme le processus serveur est le seul processus 
          accédant réellement aux tables, les applications n'ont pas à 
          se soucier des conflits de droits. Cependant, ce n'est pas le 
          cas avec le gestionnaire de bases de données Berkeley DB. 
          Subversion (et les programmes utilisant les bibliothèques de 
          Subversion) accèdent aux tables directement, ce qui veut dire 
          que le plantage d'un programme peut laisser la base de données 
          dans un état temporairement incohérent et inaccessible. Quand 
          cela arrive, un administrateur doit demander au gestionnaire 
          de bases de données Berkeley DB de revenir à un point de 
          contrôle, ce qui est assez ennuyeux. D'autres incidents 
          peuvent faire <quote>planter</quote> la base de données, comme 
          des conflits entre programmes pour la possession ou les droits 
          sur les fichiers de la base de données.</para>

        <note>
          <para>La version 4.4 du gestionnaire de bases de données 
            Berkeley DB permet à Subversion (version 1.4 ou plus) de 
            restaurer un environnement Berkeley DB automatiquement et de 
            manière transparente en cas de besoin. Quand un processus 
            Subversion se greffe sur l'environnement d'un dépôt 
            Berkeley DB, il utilise un mécanisme d'enregistrement pour 
            détecter tout problème éventuel de déconnexion antérieur, 
            effectue les restaurations nécessaires puis passe à la suite 
            comme si de rien n'était. Cela n'élimine pas complètement 
            les plantages du dépôt, mais les interactions humaines 
            nécessaires pour revenir à une situation normale sont 
            considérablement réduites.</para>
        </note>

        <para>Ainsi, bien qu'un dépôt Berkeley DB soit rapide et capable 
          de monter en puissance, il faut privilégier une utilisation 
          par un seul processus serveur tournant avec une identité 
          unique (comme le serveur Apache <command>httpd</command>
          ou <command>svnserve</command> (voir <xref
          linkend="svn.serverconfig"/>) &mdash; plutôt qu'un accès par de 
          nombreux utilisateurs via des URL <literal>file://</literal> 
          ou <literal>svn+ssh://</literal>. Si de multiples utilisateurs 
          doivent avoir accès à un dépôt Berkeley DB, lisez
          <xref linkend="svn.serverconfig.multimethod"/> plus loin dans 
          ce chapitre.</para>

      </sect3>
      
      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.basics.backends.fsfs">
        <title>FSFS</title>

        <para>Mi 2004, un deuxième type de stockage pour le dépôt, qui 
          ne fait pas appel à une base de données, a fait son 
          apparition. Un dépôt FSFS stocke les changements associés à 
          une révision dans un fichier unique, ce qui fait que 
          l'ensemble des révisions du dépôt se trouvent dans un seul 
          sous-répertoire rempli de fichiers numérotés. Les transactions 
          sont créées, en tant que fichiers individuels, dans des 
          sous-répertoires séparés. Une fois la transaction terminée, le 
          fichier de transaction est renommé et placé dans le répertoire 
          des révisions, ce qui garantit l'atomicité des propagations. 
          Et puisqu'un fichier de révision est permanent et non 
          modifiable, le dépôt peut également être sauvegardé
          <quote>à chaud</quote> comme un dépôt BDB.</para>

        <para>Les fichiers de révision FSFS décrivent, pour une révision 
          donnée, la structure des répertoires, le contenu des fichiers 
          et les deltas entre les fichiers et les autres arborescences 
          de révisions. Contrairement à une base de données Berkeley DB, 
          le format de stockage est portable, transférable entre 
          différents systèmes d'exploitation, et n'est pas sensible à 
          l'architecture CPU. Comme il n'y a pas de journalisation ou de 
          fichiers en mémoire partagée, le dépôt est accessible sans 
          risque via un partage de fichiers sur le réseau ou depuis un 
          environnement en lecture seule. L'absence des en-têtes liés à 
          une base de données réduit aussi quelque peu la taille globale 
          du dépôt.</para>

        <para>FSF diffère également du point de vue des performances. 
          Quand vous propagez un répertoire comptant un nombre de 
          fichiers très élevé, FSFS est capable d'ajouter plus 
          rapidement les éléments du répertoire. D'un autre côté, FSFS 
          écrit la dernière version d'un fichier sous forme de delta par 
          rapport à la version précédente, par conséquent une extraction 
          de l'arborescence la plus récente est un peu plus lente que 
          l'obtention des fichiers entiers stockés dans la révision HEAD 
          d'une base de données Berkeley DB. FSFS est également plus 
          long lors de la fin de la propagation, ce qui peut amener le 
          client à considérer, dans des cas extrêmes, que sa requête a 
          expiré avant qu'il ne reçoive la réponse.</para>

        <para>La différence la plus importante reste quand même la 
          résistance aux plantages lorsque quelque chose va mal. Si un 
          processus qui utilise une base de données Berkeley DB 
          rencontre un problème de droits ou plante soudainement, la 
          base de données risque de se retrouver dans un état instable 
          jusqu'à ce qu'un administrateur la restaure. Si la même chose 
          arrive à un processus utilisant un dépôt FSFS, le dépôt n'est 
          en rien affecté. Au pire, quelques données de transaction sont 
          égarées.</para>

        <para>Le seul véritable argument contre FSFS est sa relative 
          immaturité face à Berkeley DB. Berkeley DB a une histoire de 
          plusieurs années, avec une équipe de développement dédiée et, 
          aujourd'hui, il est adossé à la toute-puissante marque 
          Oracle<footnote>
            <para>Oracle a acheté Sleepycat et son logiciel vedette, 
              Berkeley DB, le jour de la Saint Valentin 2006.</para>
          </footnote>. 
          FSFS est d'une conception plus récente. Avant la version 1.4 
          de Subversion, apparaissaient de temps en temps quelques 
          bogues assez sérieux concernant l'intégrité des données qui, 
          bien que n'arrivant que dans de très rares cas, étaient bien 
          réels. Ceci dit, FSFS est rapidement devenu le magasin de 
          données de référence pour quelques-uns des plus vastes dépôts 
          Subversion, publics et privés, et il promet de rendre 
          globalement plus facile le passage à Subversion.</para>

      </sect3>
    </sect2>

  </sect1>
 
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.create">
    <title>Création et configuration d'un dépôt</title>

    <para>Dans ce chapitre (dans <xref 
      linkend="svn.reposadmin.planning" />), nous avons passé en revue 
      quelques décisions importantes à prendre avant de créer et de 
      configurer votre dépôt Subversion. Maintenant, nous allons enfin 
      mettre les mains dans le cambouis&nbsp;! Dans cette section, nous 
      voyons comment créer un dépôt Subversion et le configurer 
      pour qu'il effectue des actions personnalisées lorsque certains 
      événements ont lieu.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.creating">
      <title>Création d'un dépôt</title>
   
      <para>La création d'un dépôt Subversion est une tâche 
        incroyablement simple. L'utilitaire <command>svnadmin</command>, 
        fourni avec Subversion, propose une sous-commande qui est 
        justement destinée à cela (<command>svnadmin
        create</command>) &nbsp;:</para>
          
      <screen>
$ # Créer un dépôt
$ svnadmin create /var/svn/depot
$
</screen>
          
      <para>Cette commande crée un dépôt dans le répertoire 
        <filename>/var/svn/depot</filename> avec le magasin de données 
        par défaut. Avant la version 1.2 de Subversion, le choix par 
        défaut était l'utilisation d'une base de données Berkeley 
        DB&nbsp;; maintenant, c'est FSFS. Vous pouvez choisir 
        explicitement le type de système de fichiers avec l'option
        <option>--fs-type</option> qui accepte comme argument soit 
        <literal>fsfs</literal>, soit <literal>bdb</literal>.</para>
 
      <screen>
$ # Créer un dépôt FSFS
$ svnadmin create --fs-type fsfs /var/svn/depot
$
</screen>

      <screen>
$ # Créer un dépôt Berkeley DB
$ svnadmin create --fs-type bdb /var/svn/depot
$
</screen>
              
      <para>Après l'exécution de cette simple commande, vous disposez 
        d'un dépôt Subversion.</para>

      <tip>
        <para>Le chemin en argument de <command>svnadmin</command> est 
          juste un chemin classique du système de fichiers, pas une URL 
          comme celles que le client <command>svn</command> utilise pour 
          spécifier un dépôt. Les commandes <command>svnadmin</command>
          et <command>svnlook</command> sont toutes les deux considérées 
          comme des utilitaires coté serveur&nbsp;: elles sont utilisées 
          sur la machine qui héberge le dépôt pour examiner ou modifier 
          certains aspects du dépôt et ne sont pas capables d'effectuer 
          des actions via le réseau. Une erreur classique des nouveaux 
          utilisateurs de Subversion est d'essayer de passer une URL 
          (même <quote>locale</quote> comme <literal>file://</literal>)
          à ces deux programmes.</para>
      </tip>

      <para>Dans le sous-répertoire <filename>db/</filename> de votre 
        dépôt, vous trouvez l'implémentation du système de fichiers 
        suivi en versions. Le nouveau système de fichiers suivi en 
        versions de votre dépôt commence sa vie à la révision 0, qui est 
        définie comme contenant le répertoire racine 
        (<filename>/</filename>) et lui seul. Initialement, la révision 0 
        possède une seule propriété de révision, 
        <literal>svn:date</literal>, dont la valeur est la date de 
        création du dépôt.</para>

      <para>Maintenant que vous disposez d'un dépôt, il est temps de le 
        personnaliser.</para>

      <warning>
        <para>Alors que certaines parties d'un dépôt Subversion sont 
          conçues pour être examinées et modifiées <quote>à la 
          main</quote> (comme les fichiers de configuration et les 
          procédures automatiques), vous ne devez pas (et vous ne 
          devriez pas avoir besoin de) modifier les autres parties 
          <quote>à la main</quote>. L'outil <command>svnadmin</command> 
          est censé être suffisant pour toutes les modifications à 
          apporter à votre dépôt ou alors vous pouvez regarder du côté 
          d'outils tiers (comme la suite d'outils Berkeley DB) pour 
          configurer les parties adéquates du dépôt. Ne tentez 
          <emphasis>surtout pas</emphasis> de manipuler manuellement 
          l'historique du suivi de versions à petits coups par-ci par-là 
          dans les fichiers du magasin de données du dépôt&nbsp;!</para>
      </warning>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.create.hooks">
      <title>Mise en place des procédures automatiques</title>

      <para>Une <firstterm>procédure automatique</firstterm> (hook en 
        anglais) est un programme activé par certains événements du 
        dépôt, comme la création d'une nouvelle révision ou la 
        modification d'une propriété non suivie en versions. Certaines 
        procédures automatiques (appelées <quote>pre hooks</quote>) sont 
        déclenchées avant l'opération sur le dépôt et permettent à la 
        fois de rendre compte de ce qui va se passer et d'empêcher que 
        cela se passe. D'autres procédures automatiques (appelées 
        <quote>post hooks</quote>) sont déclenchées après la fin d'un 
        événement et servent à effectuer des tâches de surveillance 
        (mais pas de modification) du dépôt. Chaque procédure 
        automatique reçoit suffisamment d'informations pour déterminer 
        la nature de l'événement, les modifications proposées (ou 
        effectuées) du dépôt et le nom d'utilisateur de la personne qui 
        a déclenché l'événement.</para>
            
      <para>Le sous-répertoire <filename>hooks</filename> contient, par 
        défaut, des modèles pour diverses procédures 
        automatiques&nbsp;:</para>
            
      <screen>
$ ls depot/hooks/
post-commit.tmpl          post-unlock.tmpl  pre-revprop-change.tmpl
post-lock.tmpl            pre-commit.tmpl   pre-unlock.tmpl
post-revprop-change.tmpl  pre-lock.tmpl     start-commit.tmpl
$
</screen>
            
      <para>Il y a un modèle pour chaque type de procédure automatique 
        que le dépôt Subversion sait prendre en charge&nbsp;; en 
        examinant le contenu de ces modèles de scripts, vous pouvez 
        voir ce qui déclenche le script et quelles données sont passées 
        en paramètres. Vous trouvez également dans beaucoup de ces 
        scripts des exemples d'utilisation permettant de réaliser des 
        tâches récurrentes utiles, en conjonction avec d'autres 
        programmes fournis avec Subversion. Concrètement, pour activer 
        une procédure automatique, il suffit de placer dans le 
        répertoire <filename>depot/hooks</filename> un programme ou un 
        script exécutable, qui sera invoqué via le nom de la procédure 
        automatique (comme <command>start-commit</command> pour le début 
        d'une propagation ou <command>post-commit</command> pour la fin 
        d'une propagation).</para>

      <para>Sur les plates-formes Unix, cela veut dire fournir un 
        programme ou un script (pouvant être un script shell, un 
        programme Python, l'exécutable binaire d'un programme en C ou 
        tout un tas d'autres choses) dont le nom est exactement le nom 
        de la procédure automatique. Bien sûr, les modèles qui sont 
        fournis ne le sont pas juste à titre d'information. Le moyen le 
        plus facile pour mettre en place une procédure automatique sur 
        les plates-formes Unix consiste tout simplement à copier le 
        fichier du modèle adéquat vers un nouveau fichier qui n'aura 
        pas l'extension <filename>.tmpl</filename>, d'adapter son 
        contenu à votre environnement et de vous assurer qu'il est 
        exécutable. Sous Windows, comme l'extension du fichier détermine 
        s'il est exécutable ou non, vous devez fournir un programme 
        dont la base du nom est le nom de la procédure automatique et 
        dont l'extension est l'une de celles reconnue comme exécutable 
        par Windows, comme <filename>.exe</filename> pour les programmes 
        ou <filename>.bat</filename> pour les fichiers batch.</para>

      <tip>
        <para>Pour des raisons de sécurité, le dépôt Subversion exécute 
          les procédures automatiques avec un environnement vide &mdash; 
          c'est-à-dire sans aucune variable d'environnement définie, 
          même pas <literal>$PATH</literal> (ou <literal>%PATH%</literal>
          sous Windows). C'est ainsi que de nombreux administrateurs 
          sont perplexes lorsque leurs programmes fonctionnent 
          correctement à la main mais pas dans Subversion. Assurez-vous 
          de définir explicitement toutes les variables d'environnement 
          nécessaires dans votre procédure automatique et/ou d'utiliser 
          des chemins absolus vers les programmes.</para>
      </tip>

      <para>Les procédures automatiques de Subversion sont lancées par 
        l'utilisateur propriétaire du processus ayant accès au dépôt 
        Subversion. La plupart du temps, on accède au dépôt via un 
        serveur Subversion, donc cet utilisateur est le même que celui 
        qui fait tourner le processus serveur sur le système. Les 
        procédures automatiques elles-mêmes doivent être configurées 
        pour être exécutables, au niveau du système d'exploitation, par 
        ledit utilisateur. Cela implique également que tout programme ou 
        fichier (y compris le dépôt Subversion) utilisé directement ou 
        indirectement par la procédure automatique l'est par ledit 
        utilisateur. En d'autres termes, faites bien attention aux 
        problèmes de droits d'exécution qui peuvent empêcher les scripts 
        d'effectuer correctement les tâches pour lesquelles ils ont été 
        conçus.</para>

      <para>Il y a plusieurs procédures automatiques implémentées dans 
        le dépôt Subversion et vous pouvez obtenir des détails sur 
        chacune d'elles dans <xref linkend="svn.ref.reposhooks" />. En 
        tant qu'administrateur du dépôt, vous devez décider quelles 
        procédures automatiques vous voulez mettre en oeuvre 
        (c'est-à-dire les nommer correctement et leur donner les droits 
        appropriés) et de quelle manière. Lorsque vous prennez cette 
        décision, gardez à l'esprit l'architecture de votre dépôt. Par 
        exemple, si vous vous servez de la configuration du serveur pour 
        déterminer les droits de propagation sur votre dépôt, vous 
        n'avez pas besoin de mettre en place un contrôle d'accès de ce 
        style via les procédures automatiques.</para>

      <para>Les exemples de procédures automatiques librement 
        accessibles sont légions, fournis par la communauté Subversion 
        elle-même ou par d'autres. Ces scripts couvrent une large 
        variété de besoins tels que le contrôle d'accès basique, le 
        contrôle de cohérence, l'intégration avec les outils de suivis 
        de bogues, les notifications de propagation par e-mail ou flux 
        RSS, etc. Ou, si vous voulez écrire votre propre programme, 
        penchez-vous sur le <xref linkend="svn.developer" />.</para>

      <warning>
        <para>Bien que les procédures automatiques soient capables de 
          faire tout et n'importe quoi, leurs auteurs devraient faire 
          preuve de modération dans un domaine précis&nbsp;: 
          <emphasis>ne modifiez pas</emphasis> une transaction de 
          propagation en utilisant une procédure automatique. Bien que 
          cela soit tentant de corriger automatiquement certaines 
          erreurs, raccourcis ou violations de politique constatées dans 
          les fichiers propagés, cela peut causer des problèmes. 
          Subversion conserve en cache, côté client, certaines parties 
          des données du dépôt et si vous modifiez une transaction de 
          propagation de cette façon, ces caches seront périmés sans que 
          cela ne puisse être détecté. De telles incohérences peuvent 
          aboutir à des comportements surprenants et inattendus. Au lieu 
          de modifier la transaction, contentez-vous de vérifier la 
          transaction dans la procédure automatique 
          <filename>pre-commit</filename> et rejetez-la si elle ne 
          remplit pas les conditions nécessaires. Entre autre avantages, 
          vos utilisateurs prendront ainsi des habitudes de travail 
          empreintes de respect des procédures et de qualité.</para>
      </warning>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.create.bdb">
      <title>Configuration de la base de données Berkeley DB</title>

      <para>Un environnement Berkeley DB peut encapsuler une ou 
        plusieurs bases de données, fichiers de journalisation, de 
        région et de configuration. L'environnement Berkeley DB a un 
        ensemble propre de valeurs configurées par défaut comme par 
        exemple le nombre de verrous autorisés à un instant donné, la 
        taille maximum des fichiers de journalisation, etc. La logique 
        du système de fichiers Subversion ajoute des valeurs par défaut 
        pour différentes options de configuration du gestionnaire 
        Berkeley DB. Cependant, il se peut que votre dépôt nécessite une 
        configuration différente en raison de l'architecture de vos 
        données et des méthodes d'accès.</para>

      <para>Les concepteurs du gestionnaire de bases de données Berkeley 
        DB comprennent que les besoins varient entre les différentes 
        applications et environnements de bases de données, c'est 
        pourquoi ils fournissent des mécanismes pour modifier, à 
        l'exécution, une grande partie des valeurs des options de 
        configuration. BDB vérifie la présence d'un fichier nommé
        <filename>DB_CONFIG</filename> dans le répertoire 
        d'environnement (à savoir le sous-répertoire <filename>db</filename>
        du dépôt) et en extrait les valeurs des options. Subversion crée 
        ce fichier lorsqu'il crée le reste du dépôt. Le fichier contient 
        initialement des options par défaut ainsi que des pointeurs vers 
        la documentation en ligne de Berkeley DB afin de vous renseigner 
        sur l'utilisation de ces options. Bien sûr, vous êtes libre 
        d'ajouter n'importe quelle option prise en compte par Berkeley 
        DB dans votre fichier <filename>DB_CONFIG</filename>. Soyez 
        juste attentif au fait que, bien que Subversion n'essaie jamais 
        de lire ou interpréter le contenu de ce fichier et qu'il n'en 
        utilise pas directement la configuration, les changements 
        induits dans le comportement de Berkeley DB ne doivent pas aller 
        à l'encontre du comportement attendu par Subversion. Par 
        ailleurs, les changements effectués dans 
        <filename>DB_CONFIG</filename> ne sont pris en considération 
        qu'après avoir effectué une restauration de l'environnement de 
        la base de données avec la commande 
        <command>svnadmin recover</command>).</para>

    </sect2>
  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.maint">
    <title>Maintenance d'un dépôt</title>

    <para>Assurer la maintenance d'un dépôt Subversion peut être 
      intimidant, certainement parce que les systèmes qui comprennent 
      une base de données sont complexes. Réussir nécessite 
      principalement de connaître les outils &mdash; ceux dont on 
      dispose, quand les utiliser et comment. Cette section vous 
      présente les outils fournis par Subversion pour assurer 
      l'administration du dépôt et décrit leur maniement pour réaliser 
      des opérations telles que migrations de données, mises à jour, 
      sauvegardes et nettoyages.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.tk">
      <title>Boîte à outils de l'administrateur</title>

      <para>Subversion fournit une poignée d'utilitaires pour créer, 
        inspecter, modifier et réparer votre dépôt. Regardons de plus 
        près chacun de ces outils. Ensuite, nous abordons rapidement 
        quelques utilitaires inclus dans le gestionnaire de bases de 
        données Berkeley DB qui fournissent des fonctionnalités 
        spécifiques au magasin de données de votre dépôt qui ne sont pas 
        assurées par les propres outils de Subversion.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnadmin">
        <title>svnadmin</title>

        <para>Le programme <command>svnadmin</command> est le meilleur 
          ami de l'administrateur de dépôts. En plus de fournir la 
          possibilité de créer des dépôts Subversion, ce programme vous 
          permet d'effectuer de nombreuses opérations de maintenance sur 
          ces dépôts. La syntaxe de <command>svnadmin</command> est 
          similaire à celle des autres programmes en ligne de commande 
          de Subversion&nbsp;:</para>

        <screen>
$ svnadmin help
usage général : svnadmin SOUS_COMMANDE DÉPÔT [ARGS &amp; OPTIONS ...]
Entrer 'svnadmin help &lt;sous-commande&gt;' pour une aide spécifique.
Entrer 'svnadmin --version' pour avoir la version et les modules de stockages.

Sous-commandes disponibles :
   crashtest
   create
   deltify
&hellip;
</screen>

        <para>Plus tôt dans ce chapitre (dans <xref
          linkend="svn.reposadmin.basics.creating"/>), nous vous avons 
          présenté la sous-commande <command>svnadmin create</command>.
          La plupart des autres sous-commandes <command>svnadmin</command>
          sont couvertes plus loin dans ce chapitre. Vous pouvez 
          également consulter<xref linkend="svn.ref.svnadmin" /> pour 
          une liste complète des sous-commandes et des fonctionnalités 
          qu'elles apportent.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnlook">
        <title>svnlook</title>
            
        <para><command>svnlook</command> est un outil de Subversion pour 
          examiner les différentes révisions et 
          <firstterm>transactions</firstterm> (qui sont des révisions en 
          cours de création) dans un dépôt. Aucune modification n'est 
          faite au dépôt par cet outil. <command>svnlook</command>
          est généralement utilisé par les procédures automatiques du 
          dépôt pour signaler les changements qui vont être propagés 
          (dans le cas de la procédure automatique
          <command>pre-commit</command>) ou qui viennent d'être propagés 
          (dans le cas de la procédure automatique 
          <command>post-commit</command>). Un administrateur peut être 
          amené à utiliser cet outil à des fins de diagnostic.</para>
            
        <para>La syntaxe de <command>svnlook</command> est 
          particulièrement simple : </para>
            
        <screen>
$svnlook help
usage général : svnlook SOUS_COMMANDE CHEMIN_DÉPÔT [ARGS &amp; OPTIONS...]
Note : Quand --revision ou --transaction ne sont pas précisées, les sous-
       commandes qui en ont besoin utilisent la révision la plus récente.
Entrer 'svnlook help &lt;sous-commande&gt;' pour une aide spécifique.
Entrer 'svnlook --version' pour avoir la version et les modules de stockage.
&hellip;
</screen>

        <para>La plupart des sous-commandes <command>svnlook</command>
          peuvent être appliquées soit à une révision soit à une 
          arborescence de transaction, affichant les informations à 
          propos de l'arborescence elle-même ou les différences par 
          rapport à la révision précédente du dépôt. Pour spécifier 
          quelle révision ou transaction examiner, utilisez 
          respectivement les options <option>--revision</option>
          (<option>-r</option>) et <option>--transaction</option>
          (<option>-t</option>). En l'absence des options 
          <option>--revision</option> (<option>-r</option>)
          ou <option>--transaction</option> (<option>-t</option>), 
          <command>svnlook</command> examine la révision la plus 
          récente (la révision  <literal>HEAD</literal>) du dépôt. 
          Ainsi, les deux commandes suivantes font exactement la même 
          chose si la révision la plus récente du dépôt situé à 
          l'emplacement <filename>/var/svn/depot</filename> porte le 
          numéro 19 &nbsp;:</para>

        <screen>
$ svnlook info /var/svn/depot
$ svnlook info /var/svn/depot -r 19
</screen>

        <para>Signalons une exception à ces règles concernant les 
          sous-commandes&nbsp;: la sous-commande 
          <command>svnlook youngest</command> ne prend aucune option et 
          affiche simplement le numéro de la révision la plus récente du 
          dépôt&nbsp;:</para>

        <screen>
$ svnlook youngest /var/svn/depot
19
$
</screen>

        <note>
          <para>Gardez à l'esprit que les seules transactions que vous 
            pouvez examiner sont celles qui n'ont pas été propagées. La 
            plupart des dépôts ne comportent pas de transactions de ce 
            type parce que les transactions sont habituellement soit 
            propagées (auquel cas vous devriez y avoir accès sous la 
            forme de révisions via l'option <option>--revision</option>
            (<option>-r</option>)), soit annulées et supprimées.</para>
        </note>
            
        <para>La sortie de <command>svnlook</command> est conçue pour 
          être à la fois lisible par un humain et traitable par une 
          machine. Prenons, par exemple, la sortie de la sous-commande 
          <command>svnlook info</command>&nbsp;:</para>

        <screen>
$ svnlook info /var/svn/depot
sally
2002-11-04 09:29:13 -0600 (lun. 04 nov. 2002)
27
J'ai ajouté le traditionnel
Arbre grec.
$
</screen>

        <para>La sortie de <command>svnlook info</command>est constituée 
          des éléments suivants, par ordre d'apparition&nbsp;:</para>

        <orderedlist>
          <listitem>
            <para>L'auteur, suivi d'un passage à la ligne.</para>
          </listitem>
          <listitem>
            <para>La date, suivie d'un passage à la ligne.</para>
          </listitem>
          <listitem>
            <para>Le nombre de caractères du message de propagation, 
              suivi d'un passage à la ligne.</para>
          </listitem>
          <listitem>
            <para>Le message de propagation lui-même, suivi d'un passage 
              à la ligne.</para>
          </listitem>
        </orderedlist>

        <para>Cette sortie est lisible par un humain, ce qui veut dire 
          que les éléments tels que la date sont représentés par du 
          texte simple au lieu d'un obscur code (comme le nombre de 
          nanosecondes depuis le passage aux nouveaux francs). Mais 
          cette sortie est aussi analysable par une machine &mdash; 
          parce que le message de propagation peut comporter plusieurs 
          lignes et n'est pas limité en taille, 
          <command>svnlook</command> affiche la longueur du message 
          avant le message lui-même. Cela permet aux scripts et autres 
          utilitaires utilisant faisant appel à cette commande de 
          prendre des décisions opportunes à propos du message de 
          propagation, comme savoir combien de mémoire allouer pour le 
          message ou au moins savoir combien d'octets sauter dans le cas 
          où les données affichées par <command>svnlook</command> ne 
          sont pas les dernières données du flux.</para>

        <para><command>svnlook</command> peut répondre à un tas d'autres 
          requêtes&nbsp;: afficher des sous-ensembles des informations 
          précédemment citées, lister récursivement les arborescences 
          versionnées des répertoires, lister les chemins modifiés lors 
          de telle révision ou transaction, afficher les différences de 
          contenu et de propriétés pour les fichiers et répertoires, 
          etc. Reportez-vous à <xref linkend="svn.ref.svnlook" /> pour 
          la liste complète des fonctionnalités offertes par 
          <command>svnlook</command>.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svndumpfilter">
        <title>svndumpfilter</title>

        <para>Bien que ce ne soit pas l'outil le plus utilisé mis à 
          disposition de l'administrateur, <command>svndumpfilter</command>
          fournit des fonctionnalités particulièrement singulières et 
          utiles &mdash; la possibilité de modifier rapidement et 
          facilement des flux de l'historique du dépôt Subversion en 
          agissant en tant que filtre sur les chemins.</para>

        <para>La syntaxe de <command>svndumpfilter</command> est la 
        suivante&nbsp;:</para>

        <screen>
$ svndumpfilter help
usage général : svndumpfilter SOUS_COMMANDE [ARGS &amp; OPTIONS ...]
Entrer 'svndumpfilter help &lt;sous-commande&gt;' pour l'aide spécifique.
Entrer 'svndumpfilter --version' pour avoir le numéro de version du programme.

Sous-commandes disponibles :
   exclude
   include
   help (?, h)
</screen>

        <para>Il n'y a que deux sous-commandes intéressantes&nbsp;: 
          <command>svndumpfilter exclude</command> et
          <command>svndumpfilter include</command>. Elles vous 
          permettent de choisir entre l'inclusion implicite ou explicite 
          des chemins dans le flux. Vous pouvez en apprendre plus sur 
          ces sous-commandes et sur l'utilité si particulière de 
          <command>svndumpfilter</command> plus loin dans ce chapitre, 
          dans  <xref linkend="svn.reposadmin.maint.filtering" />.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnsync">
        <title>svnsync</title>

        <para>Le programme <command>svnsync</command>, apparu dans la 
          version 1.4 de Subversion, fournit toutes les fonctionnalités 
          requises pour faire fonctionner un miroir en lecture seule 
          d'un dépôt Subversion. Le programme n'a qu'une et une seule 
          fonction&nbsp;: transférer l'historique d'un dépôt vers un 
          autre dépôt. Et, bien qu'il y ait différentes manières de 
          faire, sa force réside dans sa capacité de travailler à 
          distance&nbsp;: les dépôts <quote>source</quote> et
          <quote>destination</quote> peuvent être sur deux ordinateurs 
          différents et <command>svnsync</command> sur un 
          troisième.</para>

        <para>Comme vous vous en doutez, <command>svnsync</command> 
        possède une syntaxe très proche des autres programmes déjà 
        mentionnés dans ce chapitre&nbsp;:</para>

        <screen>
$svnsync help
usage général : svnsync SOUS_COMMANDE DÉPÔT [ARGS &amp; OPTIONS ...]
Entrer 'svnsync help &lt;sous-commande&gt;' pour une aide spécifique.
Entrer 'svnsync --version' pour la version et les modules d'accès (RA).

Sous-commandes disponibles :
   initialize (init)
   synchronize (sync)
   copy-revprops
   help (?, h)
$
</screen>

        <para>Nous revenons en détail sur la réplication de dépôts avec 
          <command>svnsync</command> plus loin dans ce chapitre (voir 
          <xref linkend="svn.reposadmin.maint.replication" />).</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.fsfsreshard">
        <title>fsfs-reshard.py</title>

        <para>Bien qu'il ne fasse pas officiellement partie des outils 
          Subversion, le script <command>fsfs-reshard.py</command> 
          (situé dans le répertoire <filename>tools/server-side</filename>
          du code source de Subversion) est un outil particulièrement 
          utile à l'administrateur pour optimiser les performances de 
          dépôts Subversion utilisant un magasin de données FSFS. Les 
          dépôts FSFS contiennent des fichiers qui décrivent les 
          changements apportés dans une seule révision et des fichiers 
          qui contiennent les propriétés de révision associées à une 
          seule révision. Les dépôts créés avec Subversion avant la 
          version 1.5 conservent ces fichiers dans deux 
          répertoires&nbsp;: un pour chaque type de fichiers. Au fur et 
          à mesure des révisions propagées dans le dépôt, Subversion 
          dépose de plus en plus de fichiers dans ces deux répertoires 
          &mdash; au bout d'un certain temps, le nombre de fichiers dans 
          chaque répertoire peut devenir particulièrement élevé. On a pu 
          constater dans cette situation des problèmes de performances 
          sur certains systèmes de fichiers en réseau.</para>

        <para>Subversion en version 1.5 crée les dépôts FSFS en 
          utilisant un schéma légèrement différent pour lequel ces deux 
          répertoires sont répartis (<firstterm>sharded</firstterm> en 
          anglais d'où le nom du script) dans plusieurs sous-répertoires. 
          Cela peut réduire de façon drastique le temps de recherche 
          d'un de ces fichiers et, en conséquence, améliore la 
          performance globale de Subversion pour la lecture du dépôt. Le 
          nombre de sous-répertoires utilisés pour héberger ces fichiers 
          est d'ailleurs configurable et c'est là qu'intervient le 
          script <command>fsfs-reshard.py</command>. Le script remanie 
          la structure du dépôt pour se conformer au nombre de 
          sous-répertoires demandés. C'est particulièrement utile pour 
          convertir un vieux dépôt Subversion vers le nouveau schéma 
          réparti de Subversion 1.5 (ce que Subversion ne fait pas 
          automatiquement pour vous) ou pour modifier cette valeur dans 
          un dépôt déjà réparti.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.bdbutil">
        <title>Utilitaires Berkeley DB</title>

        <para>Si vous utilisez un dépôt avec une base Berkeley DB, toute 
          la structure de votre système de fichiers versionnés ainsi que 
          les données résident dans un ensemble de tables de la base de 
          données qui sont situées dans le sous-répertoire 
          <filename>db/</filename> de votre dépôt. Ce sous-répertoire 
          est un répertoire d'environnement classique de base de données 
          Berkeley DB et n'importe quel outil de base de données 
          Berkeley, généralement fourni avec la distribution Berkeley, 
          peut y être utilisé.</para>

        <para>Pour un usage quotidien, ces outils ne sont pas 
          nécessaires. La plupart des fonctionnalités dont les dépôts 
          Subversion ont besoin ont été dupliquées dans l'outil
          <command>svnadmin</command>. Par exemple,
          <command>svnadmin list-unused-dblogs</command> et
          <command>svnadmin list-dblogs</command> fournissent un 
          sous-ensemble des fonctionnalités offertes par l'utilitaire 
          <command>db_archive</command> de Berkeley DB et 
          <command>svnadmin recover</command> reproduit les utilisations 
          courantes de l'utilitaire <command>db_recover</command>.</para>
            
        <para>Cependant, il reste quelques utilitaires Berkeley DB que 
          vous pourriez trouver utile. Les programmes 
          <command>db_dump</command> et <command>db_load</command> 
          écrivent et lisent respectivement un format de fichier 
          personnalisé qui décrit les clés et les valeurs d'une base de 
          données Berkeley DB. Puisque les bases de données Berkeley DB 
          ne sont pas portables d'une architecture de machine à une 
          autre, ce format est utile pour transférer les bases de 
          données entre deux machines, indépendamment de l'architecture 
          et du système d'exploitation. Comme nous le décrivons plus 
          loin dans ce chapitre, vous pouvez aussi utiliser 
          <command>svnadmin dump</command> et
          <command>svnadmin load</command> pour faire la même chose, mais
          <command>db_dump</command> et <command>db_load</command>
          peuvent accomplir certaines tâches tout aussi bien et beaucoup 
          plus vite. Ils peuvent aussi être utiles si un expert Berkeley 
          DB, pour une raison ou pour une autre, doit manipuler les 
          données directement dans la base de données d'un dépôt BDB 
          (les utilitaires Subversion ne le vous permettent pas). De 
          plus, l'utilitaire <command>db_stat</command> peut fournir des 
          informations utiles sur l'état de votre environnement Berkeley 
          DB, y compris des statistiques détaillées concernant les 
          sous-systèmes de verrouillage et de stockage.</para>

        <para>Pour davantage d'informations sur la suite d'outils 
          Berkeley DB, consultez la documentation en ligne sur le site 
          Internet d'Oracle, dans la section Berkeley DB&nbsp;: <ulink
          url="http://www.oracle.com/technology/documentation/berkeley-db/db/"
          /> (ce site est en anglais).</para>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.setlog">
      <title>Correction des messages de propagation</title>
            
      <para>Parfois un utilisateur se trompe dans son message de 
        propagation (une faute d'orthographe ou une coquille, par 
        exemple). Si le dépôt est configuré (en utilisant la procédure 
        automatique <literal>pre-revprop-change</literal>, voir <xref
        linkend="svn.reposadmin.create.hooks"/>) pour accepter les 
        modifications de ce message après la fin de la propagation, 
        l'utilisateur peut corriger son message à distance en utilisant
        <command>svn propset</command> (voir <xref
        linkend="svn.ref.svn.c.propset"/>). Cependant, en raison de la 
        possibilité de perte d'information irrémédiable, les dépôts 
        Subversion ne sont pas configurés, par défaut, pour autoriser 
        les modifications de propriétés non suivies en versions &mdash; 
        sauf de la part d'un administrateur.</para>

      <para>Si un administrateur est amené à changer un message de 
        propagation, il peut le faire avec <command>svnadmin setlog</command>.
        Cette commande change le message de propagation (la propriété 
        <literal>svn:log</literal>) d'une révision donnée du dépôt, 
        la nouvelle valeur étant lue dans un fichier.</para>
          
      <screen>
$ echo "Voici le nouveau message de propagation, en version corrigée" &gt; nouveau-message.txt
$ svnadmin setlog mon-depot nouveau-message.txt -r 388
</screen>
      
      <para>La commande <command>svnadmin setlog</command>, par défaut, 
        possède toujours des garde-fous pour empêcher de modifier des 
        propriétés non suivies en versions de la même manière que pour 
        un client distant &mdash; les procédures automatiques
        <literal>pre-</literal> et
        <literal>post-revprop-change</literal> sont toujours activées et 
        doivent donc être configurées afin d'accepter ce type de 
        changement. Mais un administrateur peut contourner ces 
        protections en passant l'option <option>--bypass-hooks</option>
        à la commande <command>svnadmin setlog</command>.</para>
 
      <warning>
        <para>Souvenez-vous cependant que, en contournant les procédures 
          automatiques, vous êtes susceptible de ne pas activer 
          certaines actions telles que la notification par email du 
          changement des propriétés, la sauvegarde par les systèmes qui 
          surveillent les propriétés non suivies en versions, etc. En 
          d'autres termes, faites particulièrement attention aux 
          changements que vous apportez et à la manière dont vous le 
          faites.</para>
      </warning>


    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.diskspace">
      <title>Gestion de l'espace disque</title>

      <para>Bien que le coût de stockage ait diminué de manière 
        drastique ces dernières années, l'utilisation de l'espace disque 
        reste un des préoccupations de l'administrateur qui doit suivre 
        en versions de grandes quantités de données. Chaque élément de 
        l'historique de chaque donnée stockée dans un dépôt actif doit 
        être sauvegardé ailleurs, peut-être même de nombreuses fois dans 
        le cas de sauvegardes tournantes. Il est utile de savoir quelles 
        données d'un dépôt Subversion doivent rester sur le site de 
        production, lesquelles doivent être sauvegardées et lesquelles 
        peuvent être supprimées sans risque.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.deltas">
        <title>Economie d'espace disque</title>

        <para>Pour garder un dépôt petit, Subversion utilise la 
          <firstterm>différenciation</firstterm> (ou le stockage 
          différentiel) à l'intérieur du dépôt lui-même. La 
          différenciation implique l'encodage de la représentation d'un 
          groupe de données sous la forme d'un ensemble de différences 
          avec un autre groupe de données. Si les deux groupes de 
          données sont très similaires, la différenciation économise
          de l'espace pour le groupe différencié &mdash; au lieu de 
          prendre le même espace que les données originales, le groupe 
          occupe juste l'espace nécessaire pour dire&nbsp;:<quote>je 
          ressemble à l'autre groupe de données là-bas, sauf pour les 
          deux ou trois changements qui suivent</quote>. Au final, 
          l'espace occupé par l'ensemble des données du dépôt &mdash; 
          c'est-à-dire le contenu des fichiers suivis en versions &mdash; 
          est beaucoup plus petit que la représentation textuelle 
          originale de ces données. Et pour les dépôts créés avec 
          Subversion en version 1.4 ou plus, l'espace économisé est 
          encore plus important &mdash; les représentations textuelles 
          des fichiers sont à présent elles-mêmes compressées.</para>

        <note>
          <para>Comme toutes les données sujettes à différenciation dans 
            un dépôt BDB sont stockées dans un unique fichier de la base 
            de données, réduire la taille des données stockées ne 
            réduit pas instantanément la taille du fichier de base de 
            données lui-même. Le gestionnaire de base de données 
            Berkeley DB garde néanmoins une trace des zones 
            non-utilisées du fichier de base de données et utilise ces 
            zones avant d'augmenter la taille du fichier de base de 
            données. Ainsi, même si la différenciation n'économise pas 
            immédiatement de la place, cela ralentit de façon drastique 
            la croissance de la base de données.</para>
        </note>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.deadtxns">
        <title>Suppression des transactions mortes</title>

        <para>Bien que rares, il y a des circonstances dans lesquelles 
          le déroulement d'une propagation Subversion peut mal se 
          terminer, laissant derrière elle dans le dépôt des restes de 
          cette tentative de propagation&nbsp;: une transaction 
          inachevée et toutes les modifications de fichiers et de 
          répertoires associées. Il peut y avoir plusieurs raisons à cet 
          échec&nbsp;: l'utilisateur a peut-être brutalement interrompu 
          l'opération côté client ou bien une coupure réseau s'est 
          peut-être produite au milieu de l'opération. Quoi qu'il en 
          soit, des transactions mortes peuvent apparaître. Elles ne 
          sont pas dangereuses mais elles consomment inutilement de 
          l'espace disque. Un administrateur consciencieux se doit 
          néanmoins de les supprimer.</para>

        <para>Vous pouvez utiliser la commande <command>svnadmin 
          lstxns</command> pour obtenir la liste des noms des 
          transactions non encore réglées&nbsp;:</para>

        <screen>
$ svnadmin lstxns mon-depot
19
3a1
a45
$
</screen>

        <para>Chaque élément de la sortie de cette commande peut être 
          passé en argument de <command>svnlook</command> (avec l'option
          <option>--transaction</option> (<option>-t</option>))
          pour déterminer qui est à l'origine de la transaction, quand 
          elle a eu lieu et quels types de changements ont été effectués 
          &mdash; ces informations sont très utiles pour savoir si on 
          peut supprimer la transaction sans arrière pensée&nbsp;! Si 
          vous décidez effectivement de supprimer la transaction, son 
          nom peut être passé à <command>svnadmin rmtxns</command> qui 
          fera le nettoyage adéquat. En fait, <command>svnadmin 
          rmtxns</command> peut directement prendre en entrée la sortie  
          de <command>svnadmin lstxns</command>&nbsp;!</para>

        <screen>
$ svnadmin rmtxns mon-depot `svnadmin lstxns mon-depot` 
$
</screen>

        <para>Si vous utilisez ces deux sous-commandes ainsi, vous 
          devriez envisager de rendre votre dépôt temporairement 
          indisponible pour les clients. De cette manière, personne ne 
          peut initier une transaction légitime tant que le nettoyage 
          n'est pas commencé. L'exemple <xref
          linkend="svn.reposadmin.maint.diskspace.deadtxns.ex-1" />
          contient quelques lignes de script shell qui peuvent produire 
          les informations relatives à chaque transaction inachevée de 
          votre dépôt.</para>

        <example id="svn.reposadmin.maint.diskspace.deadtxns.ex-1">
          <title>txn-info.sh (lister les transactions inachevées)</title>

          <programlisting>
#!/bin/sh

### Produit les informations relatives à toutes les transactions
### inachevées d'un dépôt Subversion 

DEPOT="${1}"
if [ "x$DEPOT" = x ] ; then
  echo "utilisation: $0 CHEMIN_VERS_LE_DEPOT"
  exit
fi

for TXN in `svnadmin lstxns ${DEPOT}`; do 
  echo "---[ Transaction ${TXN} ]-------------------------------------------"
  svnlook info "${DEPOT}" -t "${TXN}"
done
</programlisting>
        </example>

        <para>La sortie produite par ce script est, en bref, la 
          concaténation des différents groupes d'informations fournis 
          par <command>svnlook info</command> (voir <xref 
          linkend="svn.reposadmin.maint.tk.svnlook"/>) et ressemble à 
          quelque chose comme ça&nbsp;:</para>

        <screen>
$ txn-info.sh mon-depot
---[ Transaction 19 ]-------------------------------------------
sally
2001-09-04 11:57:19 -0500 (mar. 04 sep. 2001)
0
---[ Transaction 3a1 ]-------------------------------------------
harry
2001-09-10 16:50:30 -0500 (lun. 10 sep. 2001)
39
Tentative de propagation dans un réseau pourri 
---[ Transaction a45 ]-------------------------------------------
sally
2001-09-12 11:09:28 -0500 (mer. 12 sep. 2001)
0
$
</screen>

        <para>Une transaction initiée depuis longtemps correspond en 
          général à une propagation qui a été interrompue ou qui a 
          échoué. L'horodatage de la transaction peut fournir des 
          informations intéressantes &mdash; par exemple, quelle est la 
          probabilité qu'une transaction commencée il y a neuf mois soit 
          toujours active&nbsp;?</para>

        <para>En résumé, la décision de supprimer une transaction ne 
          doit pas être prise à la légère. D'autres sources 
          d'informations &mdash; comme les journaux d'Apache sur les 
          erreurs et les accès, les journaux opérationnels de 
          Subversion, l'historique des révisions Subversion, etc. &mdash; 
          peuvent aider à la prise de décision. Et bien sûr, 
          l'administrateur peut toujours entrer en contact (par email, 
          par exemple) avec l'auteur d'une transaction qui semble 
          abandonnée pour vérifier que c'est bien le cas.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.bdblogs">
        <title>Purge des fichiers de journalisation inutilisés de 
          Berkeley DB</title>

        <para>Jusqu'à il y a peu, les plus gros consommateurs d'espace 
          disque pour les dépôts Subversion basés sur BDB étaient les 
          fichiers de journalisation dans lesquels le gestionnaire 
          Berkeley DB effectue les pré-écritures avant de modifier la 
          base de données elle-même. Ces fichiers recensent toutes les 
          actions menées pour modifier la base de données, étape par 
          étape&nbsp;; alors que les fichiers de la base de données, à 
          un instant donné, ne reflètent qu'un état particulier, les 
          fichiers de journalisation contiennent l'ensemble de tous les 
          changements opérés <emphasis>entre</emphasis> chaque état 
          successif. Ainsi, ils peuvent grossir assez rapidement.</para>

        <para>Heureusement, à partir de la version 4.2 de Berkeley DB, 
          l'environnement de la base de données est capable de supprimer 
          ses propres fichiers non utilisés automatiquement. Tout dépôt 
          créé en utilisant <command>svnadmin</command> compilé avec la 
          version 4.2 de Berkeley DB (ou suivantes) est configuré pour 
          supprimer automatiquement les fichiers de journalisation. Si 
          vous ne voulez pas activer cette fonctionnalité, passez 
          simplement l'option <option>--bdb-log-keep</option> à la 
          commande <command>svnadmin create</command>. Si vous oubliez 
          de le faire ou si vous changez d'avis plus tard, éditez 
          simplement le fichier <filename>DB_CONFIG</filename> qui se 
          trouve dans le répertoire <filename>db</filename> de votre 
          dépôt, commentez la ligne qui contient la directive
          <literal>set_flags DB_LOG_AUTOREMOVE </literal> puis lancez 
          <command>svnadmin recover</command> sur votre dépôt pour que 
          le changement de configuration prenne effet. Reportez-vous à 
          <xref linkend="svn.reposadmin.create.bdb"/> pour plus 
          d'informations sur la configuration du gestionnaire de bases 
          de données.</para>

        <para>Sans suppression automatique des fichiers de 
          journalisation, les journaux vont s'accumuler au fur et à 
          mesure de l'utilisation de votre dépôt. Cela peut être 
          considéré comme une fonctionnalité du gestionnaire de bases de 
          données &mdash; vous devez être capable de recréer entièrement 
          votre base de données en utilisant uniquement vos fichiers de 
          journalisation, c'est pourquoi ceux-ci sont utiles pour le 
          rétablissement de la base après une catastrophe. Mais en 
          général, vous voudrez archiver les fichiers de journalisation 
          qui ne sont plus utilisés par la base de données et ensuite 
          les enlever du disque pour conserver de la place. Utilisez la 
          commande <command>svnadmin list-unused-dblogs</command> pour 
          avoir la liste des fichiers de journalisation 
          inutilisés&nbsp;:</para>

        <screen>
$ svnadmin list-unused-dblogs /var/svn/depot
/var/svn/depot/log.0000000031
/var/svn/depot/log.0000000032
/var/svn/depot/log.0000000033
&hellip;
$ rm `svnadmin list-unused-dblogs /var/svn/depot`
## espace disque récupéré !
</screen>

        <warning>
          <para>Les dépôts BDB qui utilisent les fichiers de 
            journalisation pour les sauvegardes ou les rétablissements 
            après incident <emphasis>ne doivent pas</emphasis> activer 
            la suppression automatique des fichiers de journalisation. 
            La reconstruction des données d'un dépôt à partir des 
            fichiers de journalisation ne peut être effectuée que si 
            <emphasis>tous</emphasis> les fichiers de journalisation 
            sont accessibles. Si quelques fichiers de journalisation 
            sont supprimés du disque avant que le système de sauvegarde 
            n'ait pu les copier ailleurs, l'ensemble incomplet des 
            fichiers de journalisation est totalement 
            inutile.</para> </warning>

      </sect3>

    </sect2>
        
    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.recovery">
      <title>Rétablissement de bases de données Berkeley DB</title>

      <para>Comme indiqué dans <xref
        linkend="svn.reposadmin.basics.backends.bdb"/>, un dépôt 
        Berkeley DB peut se retrouver bloqué s'il n'est pas fermé 
        proprement. Quand cela arrive, un administrateur doit faire 
        revenir la base de données en arrière jusque dans un état 
        cohérent. Ceci ne concerne cependant que les dépôts BDB &mdash; 
        si vous utilisez FSFS, vous n'êtes pas concerné. Et pour ceux 
        qui utilisent Subversion 1.4 avec Berkeley DB version 4.4 ou 
        plus, vous constaterez que Subversion est devenu beaucoup plus 
        résilient face à ce type de problème. Certes, mais des plantages 
        de dépôts Berkeley DB arrivent encore et un administrateur doit 
        savoir comment réagir dans de telles circonstances.</para>

      <para>Pour protéger les données du dépôt, le gestionnaire Berkeley 
        DB utilise un mécanisme de verrouillage. Ce mécanisme s'assure 
        que les éléments de la base de données ne sont pas modifiés en 
        même temps par plusieurs utilisateurs et que chaque processus 
        voit les données dans un état cohérent lors de la lecture de la 
        base de données. Quand un processus a besoin de modifier quelque 
        chose dans la base de données, il vérifie d'abord l'existence 
        d'un verrou sur les données concernées. Si les données ne sont 
        pas verrouillées, le processus les verrouille, effectue les 
        changements qu'il veut puis déverrouille les données. Les autres 
        processus sont obligés d'attendre que le verrou soit levé avant 
        d'être autorisés à accéder aux données de cette zone (ceci n'a 
        rien à voir avec les verrous que vous, utilisateur, pouvez 
        appliquer sur les fichiers suivis en versions dans le 
        dépôt&nbsp;; nous essayons de lever l'ambiguïté créée par 
        l'emploi de cette terminologie commune dans l'encadré <xref
        linkend="svn.advanced.locking.meanings" />.)</para>

      <para>Au cours de l'utilisation de votre dépôt Subversion, des 
        erreurs fatales ou des interruptions peuvent empêcher un 
        processus de supprimer des verrous qu'il a placés dans la base 
        de données. Cela conduit à des <quote>plantages</quote> du 
        magasin de données. A ce moment là, toutes les tentatives 
        d'accès au dépôt se soldent par un échec (puisque chaque 
        nouvel arrivant attend que le verrou se libère, ce qui n'est 
        pas prêt d'arriver).</para>

      <para>Si cela arrive à votre dépôt, ne paniquez pas. Le système de 
        fichiers Berkeley DB tire parti des transactions de la base de 
        données, des points de contrôle et de la journalisation 
        préalable à toute écriture pour garantir que seuls les 
        événements les plus catastrophiques<footnote>
          <para>Par exemple, disque dur + gros aimant à côté = 
            désastre.</para>
        </footnote>
        soient à même de détruire définitivement un environnement de 
        base de données. Un administrateur suffisamment paranoïaque 
        conserve des sauvegardes des données du dépôt dans un endroit 
        distinct mais attendez un peu avant de vous diriger vers 
        l'armoire de rangement des sauvegardes.</para>

      <para>Appliquez plutôt la recette suivante pour tenter de
        <quote>faire repartir</quote> votre dépôt&nbsp;:</para>
   
      <orderedlist>
        <listitem>
          <para>Assurez-vous qu'aucun processus n'accède au dépôt (ou ne 
            tente de le faire). Pour les dépôts en réseau, cela implique 
            d'arrêter le serveur HTTP Apache ou le démon svnserve.</para>
        </listitem>
        <listitem> 
          <para>Prenez l'identité de l'utilisateur qui possède et gère 
            le dépôt. C'est important, puisque rétablir un dépôt avec un 
            autre utilisateur peut modifier les droits d'accès des 
            fichiers du dépôt de telle manière que votre dépôt soit 
            toujours inaccessible même après la remise en service</para>
        </listitem>
        <listitem>
          <para>Lancez la commande <userinput>svnadmin recover
            /var/svn/depot</userinput>. Vous devriez voir une sortie du 
            genre&nbsp;:</para>
              
          <screen>
Verrou du dépôt acquis.
Patientez ; le rétablissement du dépôt peut être long...

Fin du rétablissement.
La dernière révision du dépôt est 19
</screen>
          <para>Cette commande peut durer plusieurs minutes.</para>
        </listitem>
        <listitem>
          <para>Redémarrez le processus serveur.</para>
        </listitem>
      </orderedlist>
            
      <para>Cette procédure fonctionne dans presque tous les cas de 
        plantage. Faites attention à ce qu'elle soit lancée par 
        l'utilisateur qui possède et gère la base de données, pas par 
        <literal>root</literal>. La procédure de rétablissement peut 
        impliquer de récréer en repartant de zéro certains fichiers de 
        la base de données (de la mémoire partagée, par exemple). Un 
        rétablissement par <literal>root</literal> créerait ces fichiers 
        avec <literal>root</literal> comme propriétaire, ce qui veut 
        dire que même après que vous ayez rétabli l'accès à votre dépôt, 
        les utilisateurs de base n'y auront pas accès.</para>

      <para>Si la procédure précédente, pour une raison ou pour une 
        autre, ne fait pas repartir votre dépôt, vous devez faire deux 
        choses. D'abord, mettez de côté votre répertoire de dépôt cassé 
        (par exemple en le renommant <filename>depot.CASSE</filename>) 
        puis restaurez la dernière sauvegarde de votre dépôt. Ensuite, 
        envoyez un mail à la liste de diffusion des utilisateurs de 
        Subversion (<email>users@subversion.tigris.org</email>) et 
        décrivez votre problème en détail. L'intégrité des données fait 
        partie des sujets à très haute priorité pour les développeurs 
        Subversion.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.migrate">
      <title>Migration des données d'un dépôt</title>
    
      <para>Un système de fichiers Subversion a ses données réparties 
        dans les fichiers du dépôt, d'une manière que seuls les 
        développeurs Subversion eux-mêmes comprennent (et s'y 
        intéressent). Il peut cependant y avoir des circonstances qui 
        obligent à copier ou déplacer l'ensemble (ou une partie) des 
        données d'un dépôt à un autre.</para>

      <para>Subversion fournit cette fonctionnalité par le biais des 
        <firstterm>flux de déchargement du dépôt</firstterm>. Un flux de 
        déchargement de dépôt (<quote>fichier dump</quote> ou 
        <quote>dump file</quote> en anglais quand il est stocké dans un 
        fichier sur le disque) est un format de fichier portable, 
        contenant des données brutes, qui décrit les différentes 
        révisions de votre dépôt &mdash; ce qui a été modifié, par qui, 
        quand, etc. Ce fichier dump est le principal mécanisme utilisé 
        pour réorganiser des historiques de versions &mdash; en partie 
        ou en totalité, avec ou sans modification &mdash; entre des 
        dépôts. Et Subversion fournit les outils nécessaires à la 
        création et au chargement de ces fichiers dump&nbsp;: les 
        sous-commandes <command>svnadmin dump</command> et
        <command>svnadmin load</command> respectivement.</para>

      <warning>
        <para>Bien que le format des fichiers dump de Subversion 
          contienne des parties lisibles par les humains et une 
          structure familière (elle ressemble au format décrit par la 
          RFC 822, utilisé pour la plupart des emails), <emphasis>ce 
          n'est pas </emphasis> un format de fichier purement textuel. 
          C'est un format de fichier binaire, très sensible aux 
          modifications faites à son contenu. Par exemple, de nombreux 
          éditeurs de textes corrompent le fichier en convertissant 
          les caractères de fin de ligne.</para>
      </warning>

      <para>Il existe de nombreuses raisons de décharger et recharger 
        les données d'un dépôt Subversion. Aux premiers temps de 
        Subversion, la principale raison était l'évolution de Subversion 
        lui-même. Au fur et à mesure que Subversion gagnait en maturité, 
        des changements faits sur les schémas des magasins de données 
        sous-jacents entraînaient des problèmes de compatibilité avec 
        les versions précédentes du dépôt, ce qui obligeait les 
        utilisateurs à décharger les données de leurs dépôts en 
        utilisant la version précédente de Subversion puis à recharger 
        ces données dans un dépôt tout neuf créé avec la nouvelle 
        version de Subversion. Il n'y a pas eu de changement de schéma 
        de ce type depuis la version 1.0 de Subversion et les 
        développeurs ont promis de ne pas forcer les utilisateurs à 
        décharger et recharger leurs dépôts lors du passage d'une 
        version mineure à une autre (comme par exemple entre la 
        version 1.3 et la version 1.4) de Subversion. Mais il y a 
        toujours des raisons pour décharger et recharger ses données, y 
        compris le redéploiement d'un dépôt Berkeley DB sur un nouveau 
        système d'exploitation ou sur une architecture CPU différente, 
        la migration du magasin de données de Berkeley DB à FSFS et 
        réciproquement, ou (comme nous le voyons dans ce chapitre à <xref
        linkend="svn.reposadmin.maint.filtering" />) la purge de données 
        suivies en version de l'historique du dépôt.</para>

      <note>
        <para>Le format de déchargement des dépôts Subversion ne décrit 
          que l'évolution des éléments suivis en version. Il ne contient 
          pas d'information sur les transactions inachevées, les verrous 
          utilisateurs sur les chemins du système de fichiers, la 
          configuration personnalisée du dépôt ou du serveur (y compris 
          les procédures automatiques), et ainsi de suite.</para>
      </note>

      <para>Quelle que soit la raison pour laquelle vous voulez migrer 
        votre historique de dépôt, l'utilisation des sous-commandes 
        <command>svnadmin dump</command> et <command>svnadmin 
        load</command> est simplissime. <command>svnadmin dump</command> 
        affiche un intervalle de révisions du dépôt, chacune utilisant 
        le format des fichiers dump Subversion. Le fichier dump est 
        envoyé sur la sortie standard tandis que les messages 
        d'information sont envoyés sur la sortie d'erreur. Ceci vous 
        permet de rediriger le flux standard vers un fichier tout en 
        visualisant ce qui se passe dans votre terminal. 
        Par exemple&nbsp;:</para>

      <screen>
$svnlook youngest mon-depot
26
$ svnadmin dump mon-depot > fichier-dump
* Révision 0 déchargée.
* Révision 1 déchargée.
* Révision 2 déchargée.
&hellip;
* Révision 25 déchargée.
* Révision 26 déchargée.
</screen>

      <para>A la fin de la procédure, vous obtiendrez un fichier unique 
        (<filename>fichier-dump</filename> dans l'exemple précédent) qui 
        contient toutes les données stockées dans votre dépôt pour 
        l'intervalle de révisions demandé. Notez que <command>svnadmin
        dump</command> lit les arborescences des révisions du dépôt de 
        la même manière que tout autre processus <quote>lecteur</quote> 
        (par exemple <command>svn checkout</command>), vous pouvez donc 
        sans risque lancer cette commande à n'importe quel 
        moment.</para>

      <para>La commande jumelle, <command>svnadmin
        load</command>, recherche dans l'entrée standard la structure 
        d'un fichier dump Subversion puis insère les révisions 
        déchargées dans le dépôt de destination spécifié. Elle fournit 
        elle aussi des informations sur le déroulement de l'opération, 
        cette fois en utilisant la sortie standard&nbsp;:</para>

      <screen>
$ svnadmin load nouveau-depot &lt; fichier-dump
&lt;&lt;&lt; Début d'une nouvelle transaction basée sur la révision 1
       * ajout de : A ... fait.
       * ajout de : A/B ... fait.
       &hellip;
  ------- Révision 1 propagée (commit) &gt;&gt;&gt;
  
  &lt;&lt;&lt; Début d'une nouvelle transaction basée sur la révision 2
       * édition de : A/mu ... fait.
       * édition de : A/D/G/rho ... fait.
  
  ------- Révision 2 propagée (commit) &gt;&gt;&gt;
  
  &hellip;
  
  &lt;&lt;&lt; Début d'une nouvelle transaction basée sur la révision 25
       * édition de : A/D/gamma ... fait.
  
  ------- Révision 25 propagée (commit) &gt;&gt;&gt;
  
  &lt;&lt;&lt; Début d'une nouvelle transaction basée sur la révision 26
       * ajout de : A/Z/zeta ... fait.
       * édition de : A/mu ... fait.
  
  ------- Révision 26 propagée (commit) &gt;&gt;&gt;
</screen>

      <para>Le résultat d'un chargement est l'ajout de nouvelle 
        révisions à un dépôt &mdash; comme si vous faisiez des 
        propagations vers ce dépôt avec un client Subversion classique. 
        De la même manière que pour une propagation, vous pouvez 
        utiliser les procédures automatiques pour effectuer des actions 
        particulières avant et après chaque propagation faite par la 
        procédure de chargement. En passant les options
        <option>--use-pre-commit-hook</option> et
        <option>--use-post-commit-hook</option> (respectivement) à
        <command>svnadmin load</command>, vous demandez à Subversion 
        d'exécuter les procédures automatiques pré-propagation et 
        post-propagation (respectivement) pour chaque révision chargée. 
        Un exemple d'utilisation de ces options est de s'assurer que les 
        révisions chargées passent par les mêmes étapes de validation 
        qu'une propagation normale. Bien sûr, utilisez ces options avec 
        prudence &mdash; si votre script post-propagation envoie des 
        mails à une liste de diffusion pour chaque nouvelle propagation, 
        vous ne voulez peut-être pas envoyer des centaines voire des 
        milliers de mails de notification à la suite vers cette 
        liste&nbsp;! Vous pouvez en apprendre davantage sur 
        l'utilisation des procédures automatiques dans la <xref
        linkend="svn.reposadmin.create.hooks"/>.</para>

      <para>Notez que puisque <command>svnadmin</command> utilise 
        l'entrée et la sortie standards pour le déchargement et le 
        rechargement, les administrateurs les plus intrépides peuvent 
        tenter des choses du genre (peut-être même en utilisant 
        différentes versions de <command>svnadmin</command> de chaque 
        côté du symbole pipe)&nbsp;:</para>
  
      <screen>
$ svnadmin create nouveau-depot
$ svnadmin dump vieux-depot | svnadmin load nouveau-depot
</screen>

      <para>Par défaut, le fichier dump prend beaucoup de place &mdash; 
        beaucoup plus que le dépôt lui-même. C'est parce que, par 
        défaut, chaque version de chaque fichier est écrite en entier 
        dans le fichier dump. C'est le comportement le plus simple et le 
        plus rapide et cela convient bien si vous redirigez le flux de 
        données directement vers un autre processus (comme un programme 
        de compression, de filtrage ou de chargement). Mais si vous 
        créez un fichier dump dans une optique de stockage à long terme, 
        vous voudrez sans doute économiser de l'espace disque en 
        utilisant l'option <option>--deltas</option>. Avec cette option, 
        les révisions successives des fichiers sont écrites en tant 
        que différences binaires et compressées &mdash; de la même 
        manière que pour le stockage des fichiers dans le dépôt. Cette 
        option ralentit le processus mais le fichier résultant a une 
        taille beaucoup plus proche de celle du dépôt original.</para>

      <para>Nous avons mentionné auparavant que <command>svnadmin
        dump</command> affiche un intervalle de révisions. Pour 
        spécifier une révision unique ou un intervalle à décharger, 
        utilisez l'option <option>--revision</option> 
        (<option>-r</option>). Si vous omettez cette option, toutes les 
        révisions existantes sont affichées&nbsp;:</para>

      <screen>
$ svnadmin dump mon-depot -r 23 &gt; rev-23.fichier-dump
$ svnadmin dump mon-depot -r 100:200 &gt; revs-100-200.fichier-dump
</screen>

      <para>Au fur et à mesure que Subversion décharge chaque nouvelle 
        révision, il n'affiche que le minimum d'informations nécessaire 
        à un futur chargement pour re-générer la révision à partir de la 
        précédente. En d'autres termes, pour n'importe quelle révision 
        du fichier dump, seuls les éléments ayant subi une modification 
        dans cette révision apparaissent dans le fichier dump. La seule 
        exception à cette règle est la première révision qui est 
        déchargée par la commande <command>svnadmin dump</command>
        courante.</para>

      <para>Par défaut, Subversion n'exprime pas la première révision 
        déchargée sous forme de différences à appliquer à la révision 
        précédente. En effet, il n'y a pas de révision précédente dans 
        le fichier dump&nbsp;! Et puis Subversion ne peut pas connaître 
        l'état du dépôt dans lequel les données vont être chargées (si 
        jamais elles le sont). Pour s'assurer que la sortie de chaque 
        exécution de <command>svnadmin dump</command> est suffisante, la 
        première révision déchargée est, par défaut, une représentation 
        complète de chaque répertoire, de chaque fichier et de chaque 
        propriété de cette révision du dépôt.</para>

      <para>Vous pouvez toujours modifier ce comportement par défaut. Si 
        vous ajoutez l'option <option>--incremental</option> quand vous 
        déchargez le dépôt, <command>svnadmin</command> compare la 
        première révision déchargée à la révision précédente du dépôt
        &mdash; de la même manière qu'il traite toutes les autres 
        révisions qui sont déchargées. Il affiche alors la première 
        révision de la même manière que le reste des révisions dans 
        l'intervalle demandé &mdash; en ne mentionnant que les 
        changements contenus dans cette révision. L'avantage est que 
        vous pouvez créer plusieurs petits fichiers dump qui peuvent 
        être chargés les uns à la suite des autres au lieu d'un unique 
        gros fichier. Par exemple&nbsp;:</para>

      <screen>
$ svnadmin dump mon-depot -r 0:1000 &gt; fichier-dump1
$ svnadmin dump mon-depot -r 1001:2000 --incremental &gt; fichier-dump2
$ svnadmin dump mon-depot -r 2001:3000 --incremental &gt; fichier-dump3
</screen>

      <para>Ces fichiers dump peuvent maintenant être chargés dans un 
        nouveau dépôt avec la séquence de commandes 
        suivante&nbsp;:</para>

      <screen>
$ svnadmin load nouveau-depot &lt; fichier-dump1
$ svnadmin load nouveau-depot &lt; fichier-dump2
$ svnadmin load nouveau-depot &lt; fichier-dump3
</screen>

      <para>Une autre astuce consiste à utiliser l'option
        <option>--incremental</option> pour ajouter un nouvel intervalle 
        de révisions à un fichier dump existant. Par exemple, vous 
        pouvez avoir une procédure automatique 
        <literal>post-commit</literal> qui ajoute simplement à un 
        fichier dump le contenu de la révision qui a déclenché la 
        procédure. Ou alors, vous pouvez avoir un script qui tourne la 
        nuit pour ajouter à un fichier dump les données de toutes les 
        révisions qui ont eu lieu depuis le dernier lancement du script. 
        Ainsi, <command>svnadmin dump</command> est une manière de 
        réaliser des sauvegardes des changements de votre dépôt au fil 
        du temps, dans l'éventualité d'un plantage système ou de toute 
        autre événement catastrophique.</para>

      <para>Les fichiers dump peuvent aussi être utilisés pour fusionner 
        le contenu de différents dépôts en un seul dépôt. En utilisant 
        l'option <option>--parent-dir</option> de 
        <command>svnadmin load</command>, vous pouvez spécifier un 
        nouveau répertoire racine virtuel pour la procédure de 
        chargement. Cela signifie que si vous avez des fichiers dump 
        pour trois dépôts &mdash; disons
        <filename>fichier-dump-calc</filename>,
        <filename>fichier-dump-cal</filename>, et
        <filename>fichier-dump-tab</filename> &mdash; vous pouvez 
        commencer par créer un nouveau dépôt pour les héberger 
        tous:</para>

      <screen>
$ svnadmin create /var/svn/projets
$
</screen>

      <para>Ensuite, créez dans le dépôt les nouveaux répertoires qui 
        vont encapsuler le contenu de chacun des trois dépôts 
        précédents&nbsp;:</para>

      <screen>
$ svn mkdir -m "Racines initiales des projets" \
      file:///var/svn/projets/calc \
      file:///var/svn/projets/calendrier \
      file:///var/svn/projets/tableur
Révision 1 propagée.
$ 
</screen>

      <para>Enfin, chargez chaque fichier dump dans le répertoire 
        correspondant du nouveau dépôt&nbsp;:</para>

      <screen>
$ svnadmin load /var/svn/projets --parent-dir calc &lt; fichier-dump-calc
&hellip;
$ svnadmin load /var/svn/projets --parent-dir calendrier &lt; fichier-dump-cal
&hellip;
$ svnadmin load /var/svn/projets --parent-dir spreadsheet &lt; fichier-dump-tab
&hellip;
$
</screen>

      <para>Mentionnons une dernière façon d'utiliser les fichiers dump 
        de Subversion &mdash; la conversion depuis un système de 
        stockage différent ou depuis un autre système de gestion de 
        versions. Comme le format des fichiers dump est, pour sa plus 
        grande partie, lisible par un humain, il devrait être 
        relativement facile de décrire des ensembles de modifications 
        &mdash; chaque ensemble constituant une nouvelle révision &mdash; 
        en utilisant ce format de fichier. En fait, l'utilitaire
        <command>cvs2svn</command> (voir <xref
        linkend="svn.forcvs.convert"/>) utilise le format dump pour 
        représenter le contenu d'un dépôt CVS, de manière à pouvoir 
        copier ce contenu vers un dépôt Subversion. .</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.filtering">
      <title>Filtrage de l'historique d'un dépôt</title>

      <para>Puisque Subversion stocke votre historique du suivi de 
        versions en utilisant, au minimum, des algorithmes de 
        différenciation binaire et de la compression de données (le 
        tout, en option, dans un système de gestion de bases de données 
        complètement opaque), il est maladroit, et en tous cas fortement 
        déconseillé, d'essayer de le modifier manuellement, sachant 
        qu'en plus c'est assez difficile. Et une fois que des données 
        ont été stockées dans votre dépôt, Subversion ne fournit 
        généralement pas de moyen simple pour enlever ces 
        données<footnote>
          <para>C'est d'ailleurs pour cela que vous utilisez un système 
            de gestion de versions, non&nbsp;?</para>
        </footnote>.
        Mais, inévitablement, il y a des cas où vous voulez manipuler 
        l'historique de votre dépôt. Par exemple pour supprimer tous les 
        occurrences d'un fichier qui a été accidentellement ajouté au 
        dépôt (alors qu'il ne devrait pas y être)<footnote>
          <para>Des suppressions <quote>consentantes</quote> et avisées 
            de données sur les données suivies en versions sont 
            effectivement demandées par des cas d'utilisation réels. 
            C'est pourquoi une fonctionnalité <quote>d'oblitération</quote> 
            est une des fonctionnalités les plus demandées pour 
            Subversion et les développeurs de Subversion espèrent 
            pouvoir la fournir bientôt.</para>
        </footnote>. 
        Ou peut-être avez-vous plusieurs projets qui partagent le même 
        dépôt et vous décidez de leur attribuer chacun le leur. Pour 
        accomplir ce genre de tâches, les administrateurs ont besoin 
        d'une représentation plus souple et plus facile à gérer de leurs 
        données dans les dépôts&nbsp;: les fichiers dump Subversion.</para>

      <para>Comme indiqué précédemment dans <xref
        linkend="svn.reposadmin.maint.migrate" />, le format des 
        fichiers dump Subversion est une représentation lisible par les 
        humains des modifications apportées au cours du temps aux 
        données suivies en versions. Utilisez la commande 
        <command>svnadmin dump</command> pour extraire les données et 
        <command>svnadmin load</command> pour les charger dans un 
        nouveau dépôt. Le gros atout de l'aspect <quote>lisible par les 
        humains</quote> des fichiers dump est que, si vous y tenez, vous 
        pouvez en inspecter le contenu et le modifier. Bien sûr, la 
        contrepartie est que, si vous avez un fichier dump d'un dépôt 
        actif depuis plusieurs années, cela vous prendra un certain 
        temps pour en inspecter manuellement le contenu et le modifier, 
        un temps certain même.</para>

      <para>C'est là qu'intervient <command>svndumpfilter</command>. Ce 
        programme agit comme un filtre sur les chemins pour les flux de 
        déchargement/chargement dump d'un dépôt. Vous n'avez qu'à lui 
        fournir une liste de chemins que vous voulez conserver ou une 
        liste de chemins que vous voulez éliminer et ensuite rediriger 
        le flux de dump de vos données à travers ce filtre. Vous 
        obtenez un flux modifié qui ne contient que les données 
        versionnées des chemins que vous avez demandés (explicitement ou 
        implicitement).</para>

      <para>Prenons un exemple concret d'utilisation de ce programme. 
        Plus tôt dans ce chapitre (voir <xref
        linkend="svn.reposadmin.projects.chooselayout"/>), nous avons 
        décrit le processus de décision pour choisir l'organisation des 
        données de votre dépôt (utiliser un dépôt par projet ou les 
        combiner, comment organiser les répertoires au sein du dépôt, 
        etc.). Mais il peut arriver qu'après un certain nombre de 
        révisions vous repensiez votre organisation et vouliez la 
        modifier. Une modification classique est de déplacer plusieurs 
        projets qui partagent le même dépôt vers des dépôts propres à 
        chacun d'eux.</para>

      <para>Notre dépôt imaginaire contient trois projets&nbsp;: 
        <literal>calc</literal>, <literal>calendrier</literal> et
        <literal>tableur</literal>. Ils se trouvent côte à côte comme 
        ceci&nbsp;:</para>

      <screen>
/
   calc/
      trunk/
      branches/
      tags/
   calendrier/
      trunk/
      branches/
      tags/
   tableur/
      trunk/
      branches/
      tags/
</screen>

      <para>Pour placer ces trois projets dans leur dépôts propres, nous 
        commençons par décharger tout le dépôt&nbsp;:</para>

      <screen>
$ svnadmin dump /var/svn/depot &gt; fichier-dump-depot
* Révision 0 déchargée.
* Révision 1 déchargée.
* Révision 2 déchargée.
* Révision 3 déchargée.
&hellip;
$
</screen>

      <para>Ensuite, nous passons ce fichier dump à travers le filtre, 
        en incluant à chaque fois qu'un seul répertoire racine. Nous 
        obtenons trois nouveaux fichiers dump&nbsp;:</para>

      <screen>
$ svndumpfilter include calc &lt; fichier-dump-depot &gt; fichier-dump-calc
&hellip;
$ svndumpfilter include calendrier &lt; fichier-dump-depot &gt; fichier-dump-cal
&hellip;
$ svndumpfilter include tableur &lt; fichier-dump-depot &gt; fichier-dump-tab
&hellip;
$
</screen>

      <para>C'est le moment de prendre une décision. Chacun de vos 
        fichiers dump générera un dépôt valide, mais il conservera les 
        chemins exactement comme ils étaient dans le dépôt original. 
        Cela veut dire que même si vous obtenez un dépôt propre à votre 
        projet <literal>calc</literal> ce dépôt aura toujours un 
        répertoire racine <filename>calc</filename>.  Si vous voulez que 
        les répertoires <filename>trunk</filename>, 
        <filename>tags</filename> et <filename>branches</filename> soient 
        placés à la racine de votre dépôt, vous devez alors éditer les 
        fichiers dump, en modifiant les en-têtes 
        <literal>Node-path</literal> et 
        <literal>Node-copyfrom-path</literal> pour qu'ils ne contiennent 
        plus de référence au répertoire <filename>calc/</filename>. Vous 
        devez également supprimer la section des données qui crée le 
        répertoire <filename>calc</filename>. Elle ressemble à quelque 
        chose comme ça&nbsp;:</para>

      <screen>
Node-path: calc
Node-action: add
Node-kind: dir
Content-length: 0
  
</screen>

      <warning>
        <para>Si vous envisagez d'éditer à la main le fichier dump pour 
          enlever un répertoire à la racine, assurez-vous que votre 
          éditeur n'est pas configuré pour convertir les caractères de 
          fin de ligne vers le format natif (par exemple 
          de <literal>\r\n</literal> vers <literal>\n</literal>), sinon 
          le contenu ne serait plus conforme aux métadonnées. Cela 
          corromprait le fichier dump de manière irréversible.</para>
      </warning>

      <para>Tout ce qu'il reste à faire maintenant, c'est de créer vos 
        trois nouveaux dépôts et de charger chaque fichier dump dans le 
        bon dépôt, en ignorant l'UUID contenu dans chaque flux 
        dump&nbsp;:</para>

      <screen>
$ svnadmin create calc
$ svnadmin load --ignore-uuid calc &lt; fichier-dump-calc
&lt;&lt;&lt; Début d'une nouvelle transaction basée sur la révision 1
     * ajout de : Makefile ... fait.
     * ajout de : bouton.c ... fait.
&hellip;
$ svnadmin create calendrier
$ svnadmin load --ignore-uuid calendrier &lt; fichier-dump-cal
&lt;&lt;&lt; Début d'une nouvelle transaction basée sur la révision 1
     * ajout de : Makefile ... fait.
     * ajout de : cal.c ... fait.
&hellip;
$ svnadmin create tableur
$ svnadmin load --ignore-uuid tableur &lt; fichier-dump-tab
&lt;&lt;&lt; Début d'une nouvelle transaction basée sur la révision 1
     * ajout de : Makefile ... fait.
     * ajout de : tableur.c ... fait.
&hellip;
$
</screen>

      <para>Les deux sous-commandes <command>svndumpfilter</command> 
        possèdent des options pour décider comment traiter les révisions 
        <quote>vides</quote>. Si une révision donnée ne contient que des 
        modifications concernant des chemins qui ont été filtrés, cette 
        révision dorénavant vide peut être considérée comme 
        inintéressante voire indésirable. Pour permettre à l'utilisateur 
        de décider que faire de telles révisions, 
        <command>svndumpfilter</command> propose les options 
        suivantes&nbsp;:</para>

      <variablelist>
        <varlistentry>
          <term><option>--drop-empty-revs</option></term>
          <listitem>
            <para>Ne générer aucune révision vide&nbsp;;elles sont tout 
              simplement ignorées.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><option>--renumber-revs</option></term>
          <listitem>
            <para>Si les révisions vides sont ignorées (avec l'option 
              <option>--drop-empty-revs</option>), changer les numéros 
              de révision restants pour qu'il n'y ait pas de trous 
              dans la séquence de numérotation.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><option>--preserve-revprops</option></term>
          <listitem>
            <para>Si les révisions vides ne sont pas ignorées, garder 
              les propriétés de la révision (message de propagation, 
              auteur, date, propriétés personnalisées, etc...) pour ces 
              révisions vides. Autrement les révisions vides ne 
              contiennent que l'horodatage original et un message 
              expliquant que c'est à cause de
              <command>svndumpfilter</command> que cette révision est 
              vide.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      
      <para>Alors que <command>svndumpfilter</command> peut s'avérer 
        très utile et permet de gagner énormément de temps, il est 
        affublé malheureusement de deux chausse-trappes. D'abord, cet 
        utilitaire est extrêmement sensible à la sémantique des chemins. 
        Prêtez attention à la manière dont sont spécifiés les chemins 
        dans votre fichier dump, avec ou sans barre oblique 
        (<literal>/</literal>) initiale. Regardez pour cela les en-têtes 
        <literal>Node-path</literal> et
        <literal>Node-copyfrom-path</literal>.</para>

      <screen>
&hellip;
Node-path: tableur/Makefile
&hellip;
</screen>

      <para>Si les chemins ont une barre oblique initiale, vous devez 
        inclure des barres obliques au début de chaque chemin que vous 
        indiquez à <command>svndumpfilter include</command> et
        <command>svndumpfilter exclude</command> (et s'ils n'en ont pas, 
        n'incluez pas de barre oblique au début). Pour aller plus loin, 
        si votre fichier dump contient à la fois des chemins avec et des 
        chemins sans barre oblique initiale, pour quelque raison que ce 
        soit<footnote>
          <para>Bien que <command>svnadmin dump</command> ait une 
            politique cohérente concernant la barre oblique initiale 
            (ou slash &mdash; il ne l'inclut pas), d'autres programmes 
            qui génèrent des fichiers dump sont susceptibles de ne pas 
            être aussi cohérents.</para>
        </footnote>,
        vous devrez probablement normaliser les chemins en adoptant une 
        des deux conventions.</para>

      <para>En outre, les chemins qui ont été copiés peuvent vous donner 
        quelques soucis. Subversion supporte les opérations de copie 
        dans le dépôt, c'est-à-dire quand un nouveau chemin est créé par 
        la copie d'un autre chemin qui existe déjà. Il est possible qu'à 
        un certain moment de la vie de votre dépôt, vous ayez copié un 
        fichier ou un répertoire d'un endroit que 
        <command>svndumpfilter</command> a exclu vers un endroit qui est 
        inclus. Pour rendre les données du dump cohérentes, 
        <command>svndumpfilter</command> doit bien inclure l'ajout du 
        nouveau chemin &mdash; y compris le contenu de tous les fichiers 
        créés par la copie &mdash; mais en tant que copie d'un chemin 
        source qui n'existe pas dans le flux des données filtrées. Mais 
        puisque le format dump de Subversion ne contient que ce qui a 
        été modifié dans chaque révision, le contenu de la source de la 
        copie risque de ne pas être disponible. Si vous êtes susceptible 
        d'avoir la moindre copie de ce type dans votre dépôt, vous 
        devrez peut-être repenser votre ensemble de chemins à 
        inclure/exclure, pour y inclure aussi les chemins qui ont servi 
        de sources à des opérations de copie qui vous posent 
        problème.</para>

      <para>Enfin, <command>svndumpfilter</command> effectue un filtrage 
        des chemins pour le moins littéral. Si vous essayez de copier 
        l'historique d'un projet dont la racine est 
        <filename>trunk/mon-projet</filename> et de le déplacer dans 
        son propre dépôt, vous utiliserez évidemment la commande 
        <command>svndumpfilter include</command> pour conserver tous les 
        changements dans et sous <filename>trunk/mon-projet</filename>. 
        Mais le fichier dump résultant ne fait aucune hypothèse sur le 
        dépôt dans lequel vous allez charger ces données. En 
        particulier, les données déchargées peuvent commencer par la 
        révision qui a ajouté le répertoire 
        <filename>trunk/mon-projet</filename> mais <emphasis>ne pas
        contenir</emphasis> les directives pour créer le 
        répertoire <filename>trunk</filename> lui-même (parce que 
        <filename>trunk</filename> ne correspond pas au filtre utilisé). 
        Vous devez vous assurer que tous les répertoires à la présence 
        desquels le flux de données déchargées s'attend existent 
        réellement dans le dépôt destination, avant d'essayer de charger 
        le flux de données à l'intérieur.</para>

    </sect2>
  
    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.replication">
      <title>Réplication d'un dépôt</title>

      <para>Divers scénarios montrent l'intérêt d'avoir un dépôt 
        Subversion dont l'historique des versions est exactement le même 
        que celui d'un autre dépôt. Le plus évident est probablement 
        celui de maintenir un dépôt de secours, utilisé quand le dépôt 
        principal est inaccessible en raison d'un problème matériel, 
        d'une coupure réseau ou de tout autre souci de ce type. D'autres 
        scénarios comprennent le déploiement de dépôts redondants pour 
        distribuer la charge sur plusieurs serveurs, les mises à niveau 
        transparentes et d'autres encore.</para>

      <para>Depuis la version 1.4, Subversion fournit un programme pour 
        gérer de tels scénarios&nbsp;: <command>svnsync</command>. Il 
        fonctionne essentiellement en demandant au serveur Subversion de 
        <quote>rejouer</quote> les révisions, une par une. Il utilise ces 
        informations sur les révisions pour répéter une propagation 
        identique sur un autre dépôt. Aucun des deux dépôts n'a besoin 
        d'être accessible localement sur la machine où 
        <command>svnsync</command> tourne&nbsp;: ses paramètres sont 
        des URL de dépôt et tout le travail est effectué via les 
        interfaces d'accès au dépôt (Repository Access en anglais ou RA) 
        de Subversion. Tout ce dont il a besoin est un accès en lecture 
        au dépôt source et un accès en lecture/écriture au dépôt de 
        destination.</para>

      <note>
        <para>Quand vous utilisez <command>svnsync</command> sur un 
          dépôt source distant, le serveur Subversion de ce dépôt doit 
          être en version 1.4 ou supérieure.</para>
      </note>

      <para>Supposons que vous voulez réaliser un miroir d'un de vos 
        dépôts&nbsp; il vous faut alors disposer d'un dépôt destination 
        vide qui servira de miroir. Ce dépôt cible peut utiliser 
        n'importe quel magasin de données disponible (voir <xref
        linkend="svn.reposadmin.basics.backends" />), mais il ne doit 
        comporter aucun historique. Le protocole utilisé par 
        <command>svnsync</command> pour transmettre les informations de 
        révision est particulièrement sensible aux divergences entre les 
        historiques versionnés de la source et de la destination. Pour 
        cette raison, bien que <command>svnsync</command> ne puisse pas 
        <emphasis>exiger</emphasis> que le dépôt destination soit en 
        lecture seule<footnote>
          <para>En fait, le dépôt ne peut pas être complètement en 
            lecture seule, sinon <command>svnsync</command> lui-même 
            aurait du mal à y copier l'historique des révisions.</para>
        </footnote>, 
        autoriser des modifications d'historique sur le dépôt 
        destination par un mécanisme externe autre que le processus de 
        réplication mène droit au désastre.</para>

      <warning>
        <para><emphasis>Ne modifiez pas</emphasis> le dépôt miroir de 
          sorte que son historique de version diffère de celui du dépôt 
          source. Les seules propagations et modifications de propriétés 
          de révisions qui doivent avoir lieu sur ce dépôt miroir sont 
          celles effectuées par l'outil <command>svnsync</command>.</para>
      </warning>

      <para>Une autre exigence concernant le dépôt destination est que 
        le processus <command>svnsync</command> doit être autorisé à 
        modifier les propriétés de révision. Comme 
        <command>svnsync</command> fonctionne dans le cadre du système 
        des procédures automatiques du dépôt, l'état par défaut du dépôt 
        (qui consiste à interdire les modifications des propriétés de 
        révision, voir <xref
        linkend="svn.ref.reposhooks.pre-revprop-change" />) n'est pas 
        suffisant. Vous devez activer explicitement la procédure 
        automatique <filename>pre-revprop-change</filename> et votre 
        script doit autoriser <command>svnsync</command> à définir et à 
        modifier les propriétés de révision. Une fois ces dispositions 
        prises, vous êtes parés pour commencer la réplication des 
        révisions du dépôt.</para>

      <tip>
        <para>Il est de bon ton de mettre un place un contrôle d'accès 
          pour autoriser le processus de réplication de votre dépôt à 
          faire ce qu'il a à faire tout en interdisant aux autres 
          utilisateurs de modifier le contenu de votre dépôt 
          miroir.</para>
      </tip>

      <para>Examinons maintenant l'utilisation de 
        <command>svnsync</command> dans un scénario classique de 
        réplication. Nous saupoudrons le discours de quelques 
        recommandations pratiques que vous êtes libre d'ignorer si elles 
        ne sont pas nécessaires ou pas applicables à votre 
        environnement.</para>

      <para>Pour rendre service aux excellents développeurs de notre 
        système de gestion de versions favori, nous allons répliquer le 
        dépôt public qui contient le code source de Subversion et mettre 
        ce miroir à disposition sur Internet, sur une machine différente 
        de celle qui héberge le dépôt original. Cet hôte distant possède 
        une configuration globale qui autorise les accès anonymes en 
        lecture mais requiert une authentification pour modifier les 
        dépôts (pardonnez-nous de passer rapidement sur les détails de 
        la configuration du serveur Subversion pour le moment, mais ces 
        aspects sont traités en profondeur dans le <xref
        linkend="svn.serverconfig" />.). Et pour rendre l'exemple plus 
        intéressant, et uniquement pour ça, nous piloterons la 
        réplication depuis une troisième machine &mdash; en 
        l'occurrence, celle que nous sommes en train d'utiliser.</para>

      <para>Dans un premier temps, nous allons créer le dépôt qui 
        servira de miroir. Cette étape et les deux suivantes requièrent 
        l'accès à la ligne de commande de la machine sur laquelle le 
        miroir sera hébergé. Toutefois, une fois que ce dépôt sera 
        complètement configuré, nous n'aurons plus besoin d'y avoir 
        accès directement.</para>

      <screen>
$ ssh admin@svn.exemple.com \
      "svnadmin create /var/svn/miroir-svn"
admin@svn.exemple.com's password: ********
$
</screen>

      <para>&Agrave; ce stade, nous disposons d'un dépôt et, en raison 
        de la configuration de notre serveur, ce dépôt est accessible 
        directement depuis Internet. Maintenant, puisque nous ne voulons 
        pas que quoi que ce soit modifie notre dépôt en dehors du 
        processus de réplication, nous devons trouver un moyen de 
        distinguer ce processus des autres prétendants aux propagations. 
        Pour ce faire, nous utilisons un identifiant d'utilisateur 
        dédié à notre processus. Seules les propagations et les 
        modifications de propriétés de révisions effectuées par 
        l'identifiant spécial <literal>id-sync</literal> sont 
        autorisées.</para>

      <para>Nous allons utiliser le système de procédures automatiques 
        du dépôt à la fois pour autoriser le processus de réplication à 
        faire ce qu'il doit faire et pour garantir qu'il soit le seul à 
        le faire. Nous implémentons donc deux des procédures 
        automatiques du dépôt&nbsp;:
        <filename>pre-revprop-change</filename> et 
        <filename>start-commit</filename>.
        Le script <filename>pre-revprop-change</filename> est présenté 
        dans <xref
        linkend="svn.reposadmin.maint.replication.pre-revprop-change"
        /> et, en gros, vérifie que l'utilisateur qui essaie de modifier 
        les propriétés est bien notre utilisateur 
        <literal>id-sync</literal>. Si c'est bien le cas, la 
        modification est autorisée&nbsp;; sinon, elle est 
        refusée.</para>

      <example id="svn.reposadmin.maint.replication.pre-revprop-change">
        <title>Procédure automatique pre-revprop-change du dépôt 
          miroir</title>

        <programlisting>
#!/bin/sh 

USER="$3"

if [ "$USER" = "id-sync" ]; then exit 0; fi

echo "Seul l'utilisateur id-sync est autorisé à modifier les propriétés de révision." &gt;&amp;2
exit 1
</programlisting>
      </example>

      <para>Voilà pour les modifications des propriétés de révision. 
        Maintenant, nous devons nous assurer que seul l'utilisateur 
        <literal>id-sync</literal> est autorisé à propager de nouvelles 
        révisions dans le dépôt. Ce que nous allons faire en utilisant 
        une procédure automatique <filename>start-commit</filename> 
        telle que celle présentée dans l'<xref
        linkend="svn.reposadmin.maint.replication.start-commit"
        />.</para>

      <example id="svn.reposadmin.maint.replication.start-commit">
        <title>Procédure automatique start-commit du dépôt miroir</title>

        <programlisting>
#!/bin/sh 

USER="$2"

if [ "$USER" = "id-sync" ]; then exit 0; fi

echo "Seul l'utilisateur id-sync est autorisé à effectuer des propagations." &gt;&amp;2
exit 1
</programlisting>
      </example>

      <para>Après avoir installé nos procédures automatiques et s'être 
        assuré qu'elles sont exécutables par le serveur Subversion, nous 
        en avons terminé avec l'installation de notre dépôt miroir. 
        Maintenant, nous allons effectivement lancer la 
        réplication.</para>

      <para>La première chose à faire avec 
        <command>svnsync</command> est d'enregistrer dans notre dépôt 
        destination le fait qu'il sera un miroir du dépôt source. Nous 
        utilisons donc la sous-commande <command>svnsync
        initialize</command>. Nous fournissons des URL qui pointent vers 
        les répertoires racines des dépôts destination et source, 
        respectivement. Dans Subversion 1.4, c'est obligatoire &mdash; 
        seule la réplication de dépôts complets est permise. Dans 
        Subversion 1.5, cependant, vous pouvez aussi utiliser 
        <command>svnsync</command> pour répliquer uniquement des 
        sous-arborescence du dépôt.</para>

      <screen>
$ svnsync help init
initialize (init): usage : svnsync initialize DEST_URL SOURCE_URL

Initialise un dépôt destination pour être synchronisé à partir
d'un autre dépôt.
&hellip;
$ svnsync initialize http://svn.exemple.com/miroir-svn \
                     http://svn.collab.net/repos/svn \
                     --sync-username id-sync --sync-password mdp-sync
Propriétés copiées pour la révision 0.
$
</screen>

      <para>Notre dépôt destination se rappelle maintenant qu'il est 
        un miroir du dépôt public du code source Subversion. Notez que 
        nous avons fourni un identifiant et un mot de passe en arguments 
        à <command>svnsync</command> &mdash; c'était exigé par la 
        procédure automatique <filename>pre-revprop-change</filename> de 
        notre dépôt miroir.</para>

      <note>
        <para>Dans Subversion 1.4, les valeurs assignées aux options 
          <option>--username</option> et <option>--password</option> de
          <command>svnsync</command> étaient utilisées pour 
          l'authentification à la fois par le dépôt source et par le 
          dépôt destination. Cela posait des problèmes quand ces valeurs 
          n'étaient pas exactement les mêmes pour les deux dépôts, 
          particulièrement quand le mode non-interactif était utilisé 
          (avec l'option <option>--non-interactive</option>).</para>

        <para>Ce problème a été résolu dans la version 1.5 de Subversion 
          avec l'introduction de deux nouvelles paires d'options. Utilisez
          <option>--source-username</option> et
          <option>--source-password</option> pour vous authentifier 
          auprès du dépôt source&nbsp;; utilisez
          <option>--sync-username</option> et
          <option>--sync-password</option> pour vous authentifier auprès 
          du dépôt destination (les vieilles options 
          <option>--username</option> et <option>--password</option>
          existent encore pour assurer la compatibilité mais nous en 
          déconseillons l'usage).</para>

      </note>

      <para>Abordons maintenant la partie amusante. En une seule 
        sous-commande, nous pouvons demander à 
        <command>svnsync</command> de copier toutes les révisions qui 
        n'ont pas encore été répliquées du dépôt source vers le dépôt 
        destination<footnote>
          <para>Nous avertissons le lecteur que, bien qu'il lui suffise 
            de quelques secondes pour lire ce paragraphe et l'exemple 
            qui suit, le temps nécessaire pour réaliser une opération de 
            réplication est, disons, un peu plus long.</para>
        </footnote>.
        La sous-commande <command>svnsync synchronize</command> 
        fouille dans les propriétés de révision spéciales du dépôt 
        destination pour déterminer aussi bien de quel dépôt source il 
        est le miroir que la dernière révision qui a été répliquée, en 
        l'occurrence la révision 0. Ensuite, elle interroge le dépôt 
        source pour savoir quelle est la dernière révision propagée dans 
        ce dépôt. Enfin, elle demande au dépôt source de commencer à 
        envoyer toutes les révisions entre la révision 0 et la dernière 
        révision. Au moment où <command>svnsync</command> reçoit la 
        réponse du dépôt source, elle commence la retransmission des 
        révisions vers le dépôt destination en tant que nouvelles 
        propagations.</para>

      <screen>
$ svnsync help synchronize
synchronize (sync): usage : svnsync synchronize URL_DEST

Transfère toutes les révisions en attente vers la destination,
à partir de la source avec laquelle elle a été initialisée.
&hellip;
$ svnsync synchronize http://svn.exemple.com/miroir-svn
Transmission des données ........................................
Révision 1 propagée.
Propriétés copiées pour la révision 1.
Transmission des données ..
Révision 2 propagée.
Propriétés copiées pour la révision 2.
Transmission des données .....
Révision 3 propagée.
Propriétés copiées pour la révision 3.
&hellip;
Transmission des données ..
Révision 23406 propagée.
Propriétés copiées pour la révision 23406.
Transmission des données .
Révision 23407 propagée.
Propriétés copiées pour la révision 23407.
Transmission des données ....
Révision 23408 propagée.
Propriétés copiées pour la révision 23408.
$
</screen>

      <para>Il est intéressant de noter ici que, pour chaque révision 
        répliquée, il y a d'abord propagation de la révision dans le 
        dépôt destination, puis des changements de propriétés ont lieu. 
        C'est parce que la propagation initiale est effectuée par (et 
        donc attribuée à) l'utilisateur <literal>id-sync</literal> et 
        qu'elle est horodatée lors de la création de la nouvelle 
        révision. Et aussi parce que les interfaces d'accès au dépôt 
        Subversion n'autorisent pas la définition de propriétés de 
        révision au sein d'une propagation. C'est pourquoi 
        <command>svnsync</command> fait suivre la réplication par une 
        série de modifications de propriétés qui copient dans le dépôt 
        destination toutes les propriétés de révision trouvées dans le 
        dépôt source pour cette révision. Cela a également pour effet de 
        corriger l'auteur et l'horodatage de la révision pour être 
        cohérent avec le dépôt source.</para>

      <para>Notez également que <command>svnsync</command>
        documente tout ce qu'il fait en détail, afin de pouvoir être 
        interrompu ou redémarré sans remettre en cause l'intégrité des 
        données répliquées. Si une panne réseau survient pendant la 
        réplication d'un dépôt, relancez simplement la commande 
        <command>svnsync synchronize</command> et elle reprendra 
        tranquillement là où elle s'était arrêtée. En fait, au fur et à 
        mesure que de nouvelles révisions apparaissent dans le dépôt 
        source, c'est exactement ce qu'il faut faire pour conserver 
        votre miroir à jour.</para>

      <sidebar>
        <title>Propriétés propres à svnsync</title>

        <para><command>svnsync</command> a besoin de pouvoir définir et 
          modifier des propriétés de révision dans le dépôt miroir car 
          ces propriétés font partie intégrante des données à répliquer. 
          Au fur et à mesure que ces propriétés changent dans le dépôt 
          source, ces changements doivent également être répliqués dans 
          le dépôt miroir. Mais <command>svnsync</command> utilise aussi 
          un ensemble de propriétés de révision qui lui sont propres
          &mdash; stockées dans la révision 0 du dépôt miroir &mdash; à 
          ses propres fins de journalisation. Ces propriétés contiennent 
          des informations telles que l'URL et l'UUID du dépôt source, 
          ainsi que quelques informations supplémentaires sur l'état du 
          miroir.</para>

        <para>Une de ces informations sur l'état du miroir est un drapeau 
          indiquant, essentiellement, qu'<quote>il y a une 
          synchronisation en cours</quote>. Il est utilisé pour éviter 
          que de multiples processus <command>svnsync</command> entrent 
          en collision en essayant de répliquer les données vers le même 
          dépôt destination. Quoi qu'il en soit, vous n'aurez 
          généralement pas à vous soucier de ces propriétés spéciales 
          (elles commencent toutes par le préfixe 
          <literal>svn:sync-</literal>). Occasionnellement, cependant, 
          si une synchronisation échoue accidentellement, Subversion ne 
          peut pas enlever ce drapeau indiquant l'état de la 
          synchronisation. Cela fait échouer toute nouvelle tentative de 
          synchronisation puisque le drapeau indique qu'une 
          synchronisation est en cours, alors que ce n'est pas le cas. 
          Heureusement, sortir de cette situation est aussi simple que 
          supprimer la propriété <literal>svn:sync-lock</literal> de la 
          révision 0 du dépôt miroir (c'est le fameux 
          drapeau)&nbsp;:</para>

        <screen>
$ svn propdel --revprop -r0 svn:sync-lock http://svn.exemple.com/miroir-svn
Propriété 'svn:sync-lock' supprimée de la révision 0 du dépôt
$
</screen>

        <para>Le fait que <command>svnsync</command> stocke l'URL du 
          dépôt source dans une propriété qui lui est dédiée au sein du 
          dépôt destination est la raison pour laquelle vous n'avez à 
          renseigner cette URL qu'une seule fois, au moment de
          <command>svnsync init</command>. Les opérations suivantes de 
          synchronisation de ce miroir se contentent de consulter la 
          propriété <literal>svn:sync-from-url</literal> stockée dans le 
          dépôt miroir lui-même pour déterminer la source de la 
          synchronisation. Notez bien que cette valeur est utilisée 
          telle quelle par le processus de synchronisation. Ainsi, 
          depuis l'intérieur du réseau CollabNet vous pouvez peut-être 
          accéder à notre URL source 
          <literal>http://svn/depot/svn</literal> (parce que le premier 
          <literal>svn</literal> se voit ajouter 
          <literal>.collab.net</literal> par la magie du serveur DNS), 
          mais, si vous devez mettre à jour le miroir plus tard depuis 
          une machine en dehors du réseau CollabNet, la synchronisation 
          risque d'échouer (parce que le nom de machine 
          <literal>svn</literal> est ambigu). Pour cette raison, il est 
          préférable d'utiliser le nom complet pour l'URL du dépôt 
          source lors de l'initialisation de votre dépôt miroir plutôt 
          que simplement le nom de machine ou l'adresse IP (qui peut 
          varier au cours du temps). Là encore, si vous devez changer 
          l'URL de la source (ayant le même contenu) d'un dépôt miroir 
          existant, vous pouvez changer la propriété de journalisation 
          qui stocke cette information&nbsp;:</para>

        <screen>
$ svn propset --revprop -r0 svn:sync-from-url <replaceable>NOUVELLE-URL-SOURCE</replaceable> \
      http://svn.exemple.com/miroir-svn
Propriété 'svn:sync-from-url' définie à la révision 0 du dépôt
$
</screen>

        <para>Un autre point intéressant concernant ces propriétés liées 
          à la synchronisation est que <command>svnsync</command> 
          n'essaie pas de répliquer ces propriétés s'il les trouve 
          dans le dépôt source. La raison est probablement évidente
          mais est due en résumé au fait que <command>svnsync</command> 
          n'est pas capable de distinguer les propriétés spéciales qu'il 
          n'a fait que copier à partir du dépôt source de celles qu'il 
          doit consulter et tenir à jour pour ses propres besoins. Cette 
          situation peut arriver si, par exemple, vous hébergez le 
          miroir d'un miroir d'un dépôt. Quand <command>svnsync</command> 
          voit ses propres propriétés de syncrhonisation dans la 
          révision 0 du dépôt source, il les ignore purement et 
          simplement.</para>

      </sidebar>

      <para>Le procédé est cependant peu élégant. Comme les propriétés 
        des révisions Subversion peuvent être modifiées n'importe quand 
        dans la vie du dépôt et comme elles ne conservent pas de trace 
        des modifications effectuées, les processus de réplication 
        doivent faire particulièrement attention à ces propriétés. Si 
        vous avez déjà répliqué les quinze premières révisions d'un 
        dépôt et que quelqu'un modifie une propriété de révision 
        concernant la révision 12, <command>svnsync</command> ne sait
        pas qu'il faut revenir en arrière et modifier la copie de la 
        révision 12. Vous devez le lui indiquer manuellement en 
        utilisant la sous-commande <command>svnsync 
        copy-revprops</command> (ou à l'aide d'autres outils), ce qui 
        re-réplique toutes les propriétés de révision pour une 
        révision particulière ou un ensemble de révisions.</para>

      <screen>
$ svnsync help copy-revprops
copy-revprops: usage: svnsync copy-revprops URL_DEST [REV[:REV2]]

Copie les propriétés de révision pour l'intervalle donné vers la destination
à partir de la source avec laquelle elle a été initialisée.
&hellip;
$ svnsync copy-revprops http://svn.exemple.com/miroir-svn 12
Propriétés copiées pour la révision 12.
$
</screen>

      <para>C'en est fini pour la présentation rapide de la réplication 
        de dépôt. Vous voudrez sûrement automatiser un certain nombre de 
        choses autour de ce processus. Par exemple, alors que notre 
        exemple présentait une mise en place 
        <quote>tirer-et-pousser</quote>, vous êtes susceptible de 
        vouloir que ce soit le dépôt source qui pousse les modifications 
        vers un ou plusieurs miroirs prédéfinis lors de l'exécution des 
        procédures automatiques <filename>post-commit</filename> et 
        <filename>post-revprop-change</filename>. Ceci permettrait au 
        miroir d'être à jour presque en temps réel.</para>

      <para>En outre, et bien que ce ne soit pas très utilisé, 
        <command>svnsync</command> sait répliquer des dépôts pour 
        lesquels l'identifiant qu'il utilise pour s'authentifier n'a que 
        des droits partiels en lecture. Il copie simplement les parties 
        du dépôt qu'il est autorisé à voir. Un tel miroir n'est 
        clairement pas une bonne solution de sauvegarde.</para>

      <para>Avec Subversion 1.5, <command>svnsync</command> a acquis la 
        capacité de répliquer uniquement un sous-ensemble d'un dépôt 
        plutôt que le dépôt entier. La procédure pour configurer et 
        assurer la maintenance d'un tel miroir est exactement la même 
        que pour répliquer un dépôt entier, excepté lors du passage de 
        l'URL du dépôt source à <command>svnsync init</command>&nbsp;: 
        vous spécifiez l'URL d'un sous-répertoire à l'intérieur du 
        dépôt. La synchronisation du miroir ne copie que les 
        modifications relatives à l'arborescence sous le répertoire 
        indiqué. Notez quand même quelques restrictions sur cette 
        fonction&nbsp;: premièrement, vous ne pouvez pas répliquer 
        plusieurs sous-répertoires disjoints du dépôt source vers un 
        unique dépôt miroir &mdash; vous devez dans ce cas répliquer un 
        répertoire parent qui est commun à tous les répertoires que vous 
        voulez répliquer&nbsp;; deuxièmement, la logique de filtrage est 
        entièrement basée sur le chemin d'accès donc, si le 
        sous-répertoire que vous répliquez a été renommé par le passé, 
        votre miroir ne contiendra que les révisions depuis lesquelles 
        il a le nom indiqué dans l'URL que vous avez spécifiée. Et, de 
        la même manière, si le sous-répertoire source est renommé dans 
        le futur, le processus de synchronisation ne répliquera plus les 
        données à partir du moment où l'URL que vous avez spécifiée ne 
        sera plus valide.</para>

      <para>En ce qui concerne les interactions entre les utilisateurs 
        et les dépôts ainsi que les miroirs, <emphasis>il est 
        possible</emphasis> d'avoir une seule copie de travail qui 
        interagisse avec un dépôt et son miroir, mais vous devez faire 
        quelques manipulations pour y arriver. D'abord, vous devez vous 
        assurer que le dépôt source et le dépôt miroir ont bien le même 
        identifiant unique UUID (ce qui n'est pas le cas par défaut). 
        Reportez-vous à <xref linkend="svn.reposadmin.maint.uuids" /> 
        plus loin dans ce chapitre pour plus de détails à ce 
        sujet.</para>
        
      <para>Une fois que les deux dépôts ont le même identifiant unique, 
        vous pouvez utiliser <command>svn switch</command> avec l'option
        <option>--relocate</option> pour faire pointer votre copie de 
        travail vers le dépôt de votre choix&nbsp;; cette procédure est 
        décrite dans <xref linkend="svn.ref.svn.c.switch" />. Cette 
        manoeuvre est potentiellement dangereuse si le miroir et le 
        dépôt original ne sont pas étroitement synchronisés&nbsp;: une 
        copie de travail à jour, pointant vers le dépôt source, que l'on 
        ferait pointer vers un miroir non à jour, est perdue devant 
        l'absence soudaine de révisions qu'elle s'attend à trouver et 
        elle renvoit des erreurs dans ce sens. Si cela arrive, vous 
        pouvez refaire pointer votre copie de travail vers le dépôt 
        original et, soit attendre que le dépôt miroir se mette à jour, 
        soit faire revenir en arrière votre copie de travail jusqu'à un 
        numéro de révision dont vous savez qu'il est présent dans le 
        dépôt miroir, puis retenter le changement de dépôt.</para>

      <para>Enfin, soyez conscient que la réplication fournie par 
        <command>svnsync</command>, basée sur les révisions, n'est rien 
        de plus que de la simple réplication de révisions. Seules les 
        informations incluses dans le format de fichier dump des dépôts 
        Subversion peuvent être répliquées. Ainsi, 
        <command>svnsync</command> possède les mêmes limitations que les 
        flux de chargement/déchargement Subversion et n'inclut donc pas 
        les procédures automatiques, la configuration du dépôt et du 
        serveur, les transactions inachevées ni les informations 
        relatives aux verrous posés par les utilisateurs sur les chemins 
        du dépôt.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.backup">
      <title>Sauvegarde d'un dépôt</title>

      <para>En dépit des nombreux progrès de la technologie depuis 
        l'avènement de l'informatique moderne, une chose reste 
        certaine&nbsp;: le pire n'est jamais très loin. L'alimentation 
        électrique tombe en panne, les réseaux subissent des coupures, 
        les mémoires vives crament, les disques durs flanchent, et ce 
        même pour le plus consciencieux des administrateurs. Nous en 
        venons donc maintenant à un sujet très important&nbsp;: comment 
        réaliser des copies de sauvegarde des données de votre 
        dépôt.</para>

      <para>Les administrateurs de dépôts Subversion disposent de deux 
        méthodes de sauvegarde&nbsp;: la complète et l'incrémentale. Une 
        sauvegarde complète d'un dépôt implique de récupérer d'un seul 
        coup toutes les informations nécessaires pour reconstruire 
        complètement ce dépôt dans le cas d'une catastrophe. 
        Habituellement, cela signifie de dupliquer, littéralement, la 
        totalité du répertoire du dépôt (ce qui inclut l'environnement 
        Berkeley DB ou FSFS). Les sauvegardes incrémentales sont plus 
        restreintes&nbsp;: elles ne sauvegardent que les données du 
        dépôt qui ont changé depuis la sauvegarde précédente.</para>

      <para>Pour ce qui concerne les sauvegardes complètes, l'approche 
        naïve pourrait sembler satisfaisante. Mais à moins d'interdire 
        temporairement tout accès au dépôt, une simple copie récursive 
        du répertoire risque de créer une sauvegarde corrompue. Dans le 
        cas d'une base de données Berkeley DB, la documentation décrit 
        un certain ordre de copie des fichiers qui garantit une copie de 
        sauvegarde valide. Un ordre similaire existe avec les données 
        FSFS. Mais vous n'avez pas à implémenter ces algorithmes 
        vous-même puisque l'équipe de développement de Subversion l'a 
        déjà fait pour vous. La commande <command>svnadmin 
        hotcopy</command> prend soin de tout ça afin de réaliser une 
        copie à chaud de votre dépôt. Et son invocation est aussi 
        triviale que la commande Unix <command>cp</command> ou qu'une 
        copie sous Windows&nbsp;:</para>

      <screen>
$ svnadmin hotcopy /var/svn/depot /var/svn/depot-sauvegarde
</screen>

      <para>La sauvegarde générée est un dépôt Subversion totalement 
        fonctionnel, capable de prendre immédiatement la place de votre 
        dépôt en production si les choses tournent au vinaigre.</para>

      <para>Lors de la copie d'un dépôt Berkeley DB, vous pouvez même 
        ordonner à <command>svnadmin hotcopy</command> de purger les 
        fichiers de journalisation inutilisés (voir <xref
        linkend="svn.reposadmin.maint.diskspace.bdblogs" />) du dépôt 
        original une fois la copie terminée. Ajoutez simplement l'option 
        <option>--clean-logs</option> à la ligne de commande&nbsp;:</para>

      <screen>
$ svnadmin hotcopy --clean-logs /var/svn/depot-bdb /var/svn/depot-bdb-sauvegarde
</screen>

      <para>Des outils additionnels existent également autour de cette 
        commande. Le répertoire <filename>tools/backup</filename> du 
        code source de Subversion contient le script 
        <command>hot-backup.py</command>. Ce script ajoute de la gestion 
        de sauvegardes par-dessus <command>svnadmin hotcopy</command>, 
        permettant de ne garder que les dernières sauvegardes (le nombre 
        de sauvegardes à conserver est configurable) de chaque dépôt. Il 
        gére automatiquement les noms des répertoires sauvegardés pour 
        éviter les collisions avec les précédentes sauvegardes et 
        élimine par rotation les sauvegardes les plus anciennes. Même 
        si vous réalisez aussi des sauvegardes incrémentales, cette 
        commande vous servira peut-être régulièrement. Par exemple, vous 
        pouvez utiliser <command>hot-backup.py</command> dans un outil 
        permettant le lancement différé de commandes (tel que 
        <command>cron</command> sur les systèmes Unix) afin de le lancer 
        toutes les nuits (ou à tout autre intervalle de temps qui vous 
        convient mieux).</para>

      <para>Quelques administrateurs utilisent un autre mécanisme de 
        sauvegarde basé sur la génération et le stockage de flux dump 
        des dépôts. Nous avons décrit dans <xref 
        linkend="svn.reposadmin.maint.migrate" /> comment utiliser 
        <command>svnadmin dump</command> avec l'option 
        <option>--incremental</option> pour réaliser une sauvegarde 
        incrémentale d'une révision ou d'un intervalle de révisions 
        donné. Et bien sûr, vous pouvez réaliser une sauvegarde complète 
        en omettant l'option <option>--incremental</option> dans la 
        commande. Cette méthode comporte certains avantages, entre 
        autres que le format de vos informations sauvegardées est 
        flexible (il n'est pas lié à une plate-forme, à un type de 
        magasin de données ou à une version particulière de Subversion 
        ou de Berkeley DB). Mais cette flexibilité a un coût, à savoir 
        le temps de restauration des données, qui en plus augmente avec 
        chaque nouvelle révision propagée dans le dépôt. Aussi, comme 
        c'est le cas pour un tas d'autres méthodes de sauvegarde, les 
        modifications sur les propriétés de révision qui sont effectuées 
        après une sauvegarde de ladite révision ne sont pas prises en 
        compte par l'utilisation de flux de dump incrémentaux ne se 
        chevauchant pas. C'est pourquoi nous recommandons de ne pas se 
        reposer uniquement sur le type de sauvegarde basé sur les 
        fichiers dump.</para>

      <para>Comme vous pouvez le constater, chaque type de sauvegarde a 
        ses avantages et ses inconvénients. La méthode la plus facile 
        est de loin la sauvegarde à chaud complète, qui fournit 
        toujours une copie conforme et fonctionnelle de votre dépôt. En 
        cas d'accident sur votre dépôt de production, vous pouvez 
        effectuer une restauration à partir de votre sauvegarde par une 
        simple copie récursive de répertoire. Malheureusement, si vous 
        maintenez plusieurs sauvegardes de votre dépôt, chaque 
        sauvegarde consomme autant d'espace disque que votre dépôt en 
        production. Les sauvegardes incrémentales, en revanche, sont 
        plus rapides à réaliser et prennent moins de place. Mais le 
        processus de restauration peut s'avérer pénible, avec souvent 
        plusieurs sauvegardes incrémentales à appliquer. D'autres 
        méthodes ont leurs propres bizarreries. Les administrateurs 
        doivent trouver le juste milieu entre le coût des sauvegardes et 
        le coût de la restauration.</para>

      <para>Le programme <command>svnsync</command> (voir <xref
        linkend="svn.reposadmin.maint.replication" />) fournit en fait 
        une approche médiane assez pratique. Si vous synchronisez 
        régulièrement un miroir en lecture seule avec votre dépôt 
        principal, ce miroir en lecture seule se révèle être un bon 
        candidat pour prendre le relais du dépôt défaillant en cas de 
        besoin. Le principal inconvénient de cette méthode est que 
        seules les données suivies en versions sont synchronisées &mdash; 
        les fichiers de configuration du dépôt, les verrous utilisateurs 
        sur les chemins ou d'autres éléments stockés physiquement dans 
        le répertoire du dépôt mais pas <emphasis>dans le système de fichiers 
        virtuel du dépôt</emphasis> ne sont pas pris en charge par 
        <command>svnsync</command>.</para>

      <para>Quelle que soit la méthode de sauvegarde utilisée, les 
        administrateurs doivent savoir comment les modifications des 
        propriétés non suivies en versions des révisions sont prises en 
        compte (ou pas). Puisque ces modifications elles-mêmes ne créent 
        pas de nouvelles révisions, elles n'activent pas les 
        procédures automatiques <filename>post-commit</filename> ni même 
        éventuellement les procédures automatiques 
        <filename>pre-revprop-change</filename> et 
        <filename>post-revprop-change</filename><footnote>
          <para>La commande <command>svnadmin setlog</command> peut être 
            utilisée de manière à contourner les procédures 
            automatiques.</para>
        </footnote>.
        Et puisque vous pouvez modifier les propriétés de révision sans 
        respecter l'ordre chronologique (vous pouvez changer n'importe 
        quelle propriété de révision à n'importe quel moment), une 
        sauvegarde incrémentale des dernières révisions pourrait ne pas 
        intégrer la modification d'une propriété de révision qui faisait 
        partie d'une sauvegarde précédente.</para>

      <para>En règle générale, seuls les plus paranoïaques ont besoin de 
        sauvegarder le dépôt entier, disons, à chaque propagation. 
        Cependant, en considérant qu'un dépôt donné possède des 
        mécanismes de redondance autres avec une certaine granularité 
        (tels que des e-mails envoyés à chaque propagation ou des 
        fichiers dumps incrémentaux), réaliser une copie à chaud de la 
        base de données, dans le cadre des sauvegardes nocturnes 
        quotidiennes des systèmes, est une bonne pratique 
        d'administration. Ce sont vos données, protégez-les autant que 
        vous le voulez.</para>
            
      <para>Bien souvent, la meilleure approche de sauvegarde d'un dépôt 
        consiste à ne pas mettre tous ses oeufs dans le même panier, en 
        utilisant une combinaison des méthodes décrites ici. Les 
        développeurs Subversion, par exemple, sauvegardent le code 
        source de Subversion chaque nuit en utilisant
        <command>hot-backup.py</command> et effectuent une copie 
        distante par <command>rsync</command> de ces sauvegardes 
        complètes&nbsp;; ils conservent plusieurs archives de tous les 
        mails de notification des propagations et des changements de 
        propriétés&nbsp;; ils ont également des miroirs maintenus par 
        divers volontaires qui utilisent <command>svnsync</command>. 
        Votre solution peut ressembler à cela, mais elle doit être 
        adaptée à vos besoins et maintenir l'équilibre entre commodité 
        et paranoïa. Et quoi que vous fassiez, vérifiez la validité de 
        vos sauvegardes de temps en temps (à quoi servirait une roue de 
        secours crevée&nbsp;?). Bien que tout ceci n'empêche pas votre 
        matériel de subir les affres du destin<footnote>
          <para>Vous savez, le fameux <quote>concours de 
            circonstances</quote>, celui auquel vous êtes arrivé 
            premier.</para>
        </footnote>,
        cela vous aidera certainement à vous sortir de ces situations 
        délicates.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.uuids">
      <title>Gestion des identifiants uniques (UUID) des dépôts</title>

      <para>Chaque dépôt Subversion possède un identifiant unique 
        (<quote>Universally Unique IDentifier</quote> en anglais ou 
        UUID). Cet UUID est utilisé par les clients Subversion pour 
        vérifier l'identité d'un dépôt quand les autres formes de 
        vérification ne sont pas satisfaisantes (telles que l'URL du 
        dépôt qui peut varier avec le temps). La plupart des 
        administrateurs de dépôt n'ont jamais (ou très rarement) à se 
        préoccuper des UUID autrement que comme d'un détail 
        d'implémentation bas niveau de Subversion. Parfois, cependant, 
        il faut prêter attention à ce détail.</para>

      <para>En règle générale, les UUID de vos dépôts de production 
        doivent être uniques. C'est le but, après tout, des UUID. Mais 
        il y a des cas où vous voulez que les UUID de deux dépôts 
        soient identiques. Par exemple, quand vous faites une copie de 
        sauvegarde d'un dépôt, vous voulez que cette sauvegarde soit une 
        réplique exacte de l'original afin que dans le cas où vous 
        restaureriez la sauvegarde pour remplacer le dépôt de 
        production, ceci soit transparent pour les utilisateurs. Quand 
        vous déchargez et chargez l'historique d'un dépôt (comme décrit 
        précédemment dans <xref 
        linkend="svn.reposadmin.maint.migrate" />), vous devez décider 
        si vous incluez l'UUID dans le flux de données déchargées (le 
        fichier dump) qui va dans le nouveau dépôt. Les circonstances 
        vous imposeront la marche à suivre.</para>

      <para>Il y a plusieurs façons de faire pour attribuer (ou 
        modifier) un UUID à un dépôt, le cas échéant. Avec Subversion 1.5, 
        il suffit d'utiliser la commande <command>svnadmin 
        setuuid</command>. Si vous fournissez un UUID explicite à cette 
        sous-commande, elle valide le format de l'UUID et fixe
        l'identifiant unique du dépôt à cette valeur. Si vous omettez 
        l'UUID, un nouvel UUID est généré automatiquement pour votre 
        dépôt.</para>

      <screen>
$ svnlook uuid /var/svn/depot
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$ svnadmin setuuid /var/svn/depot   # créer un nouvel UUID
$ svnlook uuid /var/svn/depot
3c3c38fe-acc0-11dc-acbc-1b37ff1c8e7c
$ svnadmin setuuid /var/svn/depot \
           cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec  # restaure l'ancien UUID
$ svnlook uuid /var/svn/depot
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$
</screen>

      <para>Pour ceux qui utilisent une version de Subversion antérieure 
        à 1.5, ces tâches sont un peu plus compliquées. Vous pouvez 
        attribuer explicitement un UUID en redirigeant le flux d'un 
        fichier dump qui comporte le nouvel UUID avec la commande
        <userinput>svnadmin load --force-uuid <replaceable>CHEMIN-DU-DEPOT</replaceable></userinput>.</para>

      <screen>
$ svnadmin load --force-uuid /var/svn/depot &lt;&lt;EOF
SVN-fs-dump-format-version: 2

UUID: cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
EOF
$ svnlook uuid /var/svn/depot
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$
</screen>

      <para>Faire générer un nouvel UUID à une ancienne version de 
        Subversion n'est pas aussi simple. La meilleure façon de faire 
        est certainement de trouver un moyen de générer un UUID puis 
        d'affecter explicitement cet UUID au dépôt.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.maint.moving-and-removing">
    <title>Déplacement et suppression d'un dépôt</title>

    <para>Les données d'un dépôt Subversion sont toutes contenues dans 
      l'arborescence du répertoire du dépôt. Ainsi, vous pouvez déplacer 
      un dépôt Subversion vers un autre endroit du disque, renommer un 
      dépôt, copier un dépôt ou effacer un dépôt entier en utilisant les 
      outils de votre système d'exploitation pour manipuler les 
      répertoires &mdash; <command>mv</command>, <command>cp -a</command> 
      et <command>rm -r</command> pour les plate-formes Unix&nbsp;; 
      <command>copy</command>, <command>move</command> et 
      <command>rmdir /s /q</command> sous Windows&nbsp;; cliquodrome 
      avec de nombreux explorateurs graphiques, etc.</para>

    <para>Bien sûr, il y a souvent d'autres choses à faire lors de ce 
      genre de manipulations. Par exemple, vous voulez peut-être mettre 
      à jour la configuration de votre serveur Subversion pour le faire 
      pointer vers le nouveau chemin du dépôt déplacé ou pour supprimer 
      les éléments de configuration relatifs à un dépôt ayant été 
      effacé. Si vous avez des processus automatiques qui publient des 
      informations à partir de vos dépôts, ou qui leur sont relatives, 
      ils doivent sûrement être mis à jour. La configuration des 
      procédures automatiques a peut-être besoin d'être modifiée. Les 
      utilisateurs doivent être informés. La liste est longue, mais vous 
      avez sûrement des procédures d'exploitation et des règles 
      d'administration de votre dépôt Subversion qui vous indiquent ce
      qu'il faut faire.</para>

    <para>Dans le cas d'un dépôt copié, vous devez aussi prendre en 
      compte le fait que Subversion utilise l'identifiant unique UUID 
      pour distinguer les dépôts. Si vous copiez un dépôt en utilisant 
      la commande typique de copie récursive de votre interpréteur de 
      commande, vous vous retrouvez avec deux dépôts absolument 
      identiques, y compris en ce qui concerne l'UUID. Dans certains 
      cas, c'est ce que l'on cherche. Dans d'autres cas, non. Vous devez 
      alors générer un nouvel UUID pour l'un des deux dépôts identiques. 
      Lisez <xref linkend="svn.reposadmin.maint.uuids" /> pour plus 
      d'informations sur la gestion des UUID.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.summary">
    <title>Résumé</title>

    <para>A présent vous devez avoir une compréhension de base de la 
      création, la configuration et l'administration des dépôts 
      Subversion. Nous vous avons présenté les différents outils qui 
      vous assistent dans ces tâches. Tout au long de ce chapitre, nous 
      avons identifié quelques chausse-trappes d'administration et 
      proposé quelques solutions pour les éviter.</para>

    <para>Tout ce qui vous reste à faire est de décider quelles données 
      passionnantes vous allez héberger dans votre dépôt et, finalement, 
      comment les mettre à disposition sur un réseau. Le prochain 
      chapitre est entièrement consacré au travail en réseau.</para>

  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
