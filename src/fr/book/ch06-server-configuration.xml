  <chapter id="svn.serverconfig">
  <title>Configuration du serveur</title>

  <para>Un dépôt Subversion hébergé sur une machine donnée est
    accessible simultanément par des clients fonctionnant sur cette même
    machine en utilisant la méthode <literal>file://</literal>. Mais la
    configuration typique de Subversion consiste en une machine serveur
    unique à laquelle accèdent des clients tournant sur les ordinateurs
    de tout le bureau &mdash; ou, peut-être, de partout dans le
    monde.</para>

  <para>Ce chapitre décrit comment rendre visible votre dépôt Subversion
    en dehors de la machine hôte pour qu'il soit utilisable par des clients
    distants. Nous couvrons les mécanismes serveurs disponibles
    actuellement pour Subversion, leur configuration et leur
    utilisation. À la fin de ce chapitre, vous devriez être apte à
    décider quelle configuration réseau convient à vos besoins et
    comprendre comment mettre en place cette configuration sur votre
    machine hôte.</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.overview">

    <title>Présentation générale</title>

    <para>Subversion a été conçu avec une couche réseau abstraite. Cela
      signifie que l'on peut accéder de façon automatisée à un dépôt par
      toute sorte de protocoles client/serveur, et que l'interface
      (l'API) d'accès au dépôt du client permet aux programmeurs
      d'écrire des greffons implémentant les protocoles réseaux
      appropriés. En théorie, Subversion peut utiliser un nombre infini
      d'implémentations réseau. En pratique, il n'existe à ce jour que
      deux serveurs.</para>

    <para>Apache est un serveur web extrêmement populaire&nbsp;; en
      utilisant le module <command>mod_dav_svn</command>, Apache a accès
      au dépôt et peut le rendre accessible aux clients via le protocole
      WebDAV/DeltaV, qui est une extension d'HTTP. Comme Apache est un
      serveur très complet, il inclut un grand nombre de fonctionnalités
      <quote>gratuites</quote>, telles que&nbsp;: communications
      chiffrées par SSL, journalisation, intégration avec bon nombre de
      systèmes d'authentification tiers et navigation web limitée des
      dépôts.</para>

    <para>À l'opposé vous trouvez <command>svnserve</command>&nbsp;: un
      petit programme serveur, léger, qui communique via un protocole
      sur mesure avec les clients. Parce que ce protocole a été conçu
      spécialement pour Subversion et possède la notion d'états (à la
      différence d'HTTP), il offre des opérations significativement plus
      rapides, certes aux dépens de certaines fonctionnalités. Bien
      qu'il sache utiliser SASL pour offrir toute une gamme d'options
      d'authentification et de chiffrement, il ne possède ni
      journalisation ni navigation web intégrée. Il est néanmoins très
      facile à mettre en place et constitue souvent le meilleur choix
      pour de petites équipes débutant avec Subversion.</para>

    <para>Une troisième option consiste à utiliser
      <command>svnserve</command> encapsulé dans une connexion SSH. Même
      si ce scénario utilise toujours <command>svnserve</command>, il
      diffère quelque peu, en termes de fonctionnalités, d'un
      déploiement <command>svnserve</command> traditionnel. SSH sert à
      chiffrer toutes les communications. Par ailleurs,
      l'authentification utilise exclusivement SSH, ce qui nécessite des
      comptes utilisateurs au niveau système sur le serveur hôte (à la
      différence de <quote>svnserve simple</quote>, qui possède ses
      propres comptes utilisateurs privés). Enfin, avec ce type de
      déploiement, un processus <command>svnserve</command> temporaire
      privé est créé pour chaque utilisateur qui se connecte, ce qui
      équivaut (du point de vue des permissions) à permettre à un groupe
      d'utilisateurs locaux d'accéder au dépôt via des URL
      <literal>file://</literal>. Les autorisations d'accès basées sur
      des chemins n'ont donc aucun sens, puisque chaque utilisateur
      accède directement aux fichiers de la base de données du
      dépôt.</para>

    <para>Le <xref linkend="svn.serverconfig.overview.tbl-1"/> présente
      un résumé rapide des trois types courants de déploiements de
      serveurs.</para>

    <table id="svn.serverconfig.overview.tbl-1">
      <title>Comparaison des fonctionnalités des serveurs Subversion</title>
      <tgroup cols="4">
        <thead>
          <row>
            <entry>Fonctionnalité</entry>
            <entry>Apache + mod_dav_svn</entry>
            <entry>svnserve</entry>
            <entry>svnserve sur SSH</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>Authentification</entry>
            <entry>Authentification HTTP(S) de base, certificats X.509,
              LDAP, NTLM, ou tout autre mécanisme compatible avec
              Apache.</entry>
            <entry>CRAM-MD5 par défaut&nbsp;; LDAP, NTLM, ou tout autre
              mécanisme compatible avec SASL.</entry>
            <entry>SSH.</entry>
          </row>

          <row>
            <entry>Comptes utilisateurs</entry>
            <entry>Fichiers privés ou tout autre mécanisme compatible
              avec Apache (LDAP, SQL,&nbsp;etc.).</entry>
            <entry>Fichiers privés ou tout autre mécanisme compatible
              avec SASL (LDAP, SQL,&nbsp;etc.).</entry>
            <entry>Comptes utilisateurs systèmes.</entry>
          </row>

          <row>
            <entry>Contrôle d'accès</entry>
            <entry>L'accès en lecture/écriture peut être autorisé sur le
              dépôt tout entier ou restreint à des chemins
              spécifiés.</entry>
            <entry>L'accès en lecture/écriture peut être autorisé sur le
              dépôt tout entier ou restreint à des chemins
              spécifiés.</entry>
            <entry>L'accès en lecture/écriture ne peut être autorisé que
              sur le dépôt tout entier.</entry>
          </row>

          <row>
            <entry>Chiffrement</entry>
            <entry>Disponible via SSL (option).</entry>
            <entry> Disponible via les fonctionnalités optionnelles de
              SASL.</entry>
            <entry>Inhérent à toute connexion SSH.</entry>
          </row>

          <row>
            <entry>Journalisation</entry>
            <entry>Journaux Apache complets de chaque requête HTTP et,
              en option, la journalisation <quote>de haut niveau</quote>
              des opérations côté client.</entry>
            <entry>Pas de journaux.</entry>
            <entry>Pas de journaux.</entry>
          </row>

          <row>
            <entry>Interopérabilité</entry>
            <entry>Accessible par tout client WebDAV.</entry>
            <entry>Ne peut communiquer qu'avec des clients svn.</entry>
            <entry>Ne peut communiquer qu'avec des clients svn.</entry>
          </row>

          <row>
            <entry>Accès via une interface Web</entry>
            <entry>Support intégré limité ou via des outils tiers tels
              que ViewVC.</entry>
            <entry>Uniquement via des outils tierces tels que
              ViewVC.</entry>
            <entry>Uniquement via des outils tierces tels que
              ViewVC.</entry>
          </row>

          <row>
            <entry>Réplication serveur de type maître-esclave</entry>
            <entry>Possibilité d'un mandataire transparent pour
              l'écriture (de l'esclave vers le maître).</entry>
            <entry>Possibilité de créer seulement des serveurs esclaves
              en lecture seule.</entry>
            <entry>Possibilité de créer seulement des serveurs esclaves
              en lecture seule.</entry>
          </row>


          <row>
            <entry>Vitesse</entry>
            <entry>Relativement plus lent.</entry>
            <entry>Relativement plus rapide.</entry>
            <entry>Relativement plus rapide.</entry>
          </row>

          <row>
            <entry>Mise en place</entry>
            <entry>Relativement complexe.</entry>
            <entry>Extrêmement simple.</entry>
            <entry>Moyennement simple.</entry>
          </row>

        </tbody>
      </tgroup>
    </table>

  </sect1>

  <sect1 id="svn.serverconfig.choosing">

    <title>Choix d'une configuration serveur</title>

    <para>Et alors, quel serveur vous faut-il&nbsp;? Quel est le
      meilleur&nbsp;?</para>

    <para>Bien évidemment, il n'y a pas de bonne réponse à cette
      question. Chaque équipe a des besoins propres et les différents
      serveurs représentent des compromis différents. Le projet
      Subversion lui-même ne recommande pas un serveur plus qu'un autre,
      ni ne considère qu'un serveur est plus <quote>officiel</quote>
      qu'un autre.</para>

    <para>Voici quelques argumentaires qui vous aideront à choisir entre
      un déploiement et un autre, ainsi que quelques raisons de
      <emphasis>ne pas choisir</emphasis> l'un d'entre eux.</para>

    <sect2 id="svn.serverconfig.choosing.svnserve">

      <title>Serveur svnserve</title>

      <variablelist>
        <varlistentry>
          <term>Les bonnes raisons de l'utiliser&nbsp;:</term>
          <listitem>
            <itemizedlist>

            <listitem><para>facile et rapide à mettre en
              place&nbsp;;</para></listitem>

            <listitem><para>le protocole réseau possède la notion
              d'états et est significativement plus rapide que
              WebDAV&nbsp;;</para></listitem>

            <listitem><para>pas besoin de créer des comptes utilisateurs
              système sur le serveur&nbsp;;</para></listitem>

            <listitem><para>le mot de passe ne circule pas sur le
              réseau.</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Pourquoi l'éviter&nbsp;:</term>
          <listitem>
            <itemizedlist>

            <listitem><para>par défaut, seule une méthode
              d'authentification est disponible, le protocole réseau
              n'est pas chiffré et le serveur enregistre les mots de
              passe en clair (tous ces éléments peuvent être modifiés en
              configurant SASL, mais cela requiert un peu plus de
              travail)&nbsp;;</para></listitem>

            <listitem><para>aucune journalisation, de quelque sorte que
              ce soit, n'est disponible, ni même celle des
              erreurs&nbsp;;</para></listitem>

            <listitem><para>pas de navigation web intégrée (il vous
              faut installer un serveur web séparé et un logiciel de
              navigation du dépôt pour ajouter cette
              fonctionnalité).</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

      </variablelist>

    </sect2>

    <sect2 id="svn.serverconfig.choosing.svn-ssh">

      <title>svnserve sur SSH</title>

      <variablelist>
        <varlistentry>
          <term>Les bonnes raisons de l'utiliser&nbsp;:</term>
          <listitem>
            <itemizedlist>

            <listitem><para>le protocole réseau possède la notion
              d'états et est significativement plus rapide que
              WebDAV&nbsp;;</para></listitem>

            <listitem><para>vous pouvez tirer parti des comptes SSH
              existants et de l'infrastructure déjà mise en place pour
              les utilisateurs&nbsp;;</para></listitem>

            <listitem><para>tout le trafic réseau est
              chiffré.</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Pourquoi l'éviter&nbsp;:</term>
          <listitem>
            <itemizedlist>

            <listitem><para>il n'y a qu'un seul choix possible de
              méthode d'authentification&nbsp;;</para></listitem>

            <listitem><para>aucune journalisation, de quelque sorte que
              ce soit, n'est disponible, ni même celle des
              erreurs&nbsp;;</para></listitem>

            <listitem><para>les utilisateurs doivent être membres du
              même groupe système ou utiliser une clé SSH
              partagée&nbsp;;</para></listitem>

            <listitem><para>mal utilisé, il peut aboutir à des problèmes
              de droits sur les fichiers.</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

      </variablelist>

    </sect2>

    <sect2 id="svn.serverconfig.choosing.apache">

      <title>Serveur HTTP Apache</title>

      <variablelist>
        <varlistentry>
          <term>Les bonnes raisons de l'utiliser&nbsp;:</term>
          <listitem>
            <itemizedlist>

              <listitem><para>il permet à Subversion d'utiliser
                n'importe lequel des nombreux systèmes
                d'authentification déjà intégrés dans
                Apache&nbsp;;</para></listitem>

              <listitem><para>pas besoin de créer des comptes système
                sur le serveur&nbsp;;</para></listitem>

              <listitem><para>journalisation Apache complète
                disponible&nbsp;;</para></listitem>

              <listitem><para>le trafic réseau peut être chiffré par
                SSL&nbsp;;</para></listitem>

              <listitem><para>HTTP(S) fonctionne généralement même
                derrière des pare-feu d'entreprise&nbsp;;</para></listitem>

              <listitem><para>la possibilité de parcourir le dépôt avec
                un navigateur Web est disponible
                nativement&nbsp;;</para></listitem>

              <listitem><para>le dépôt peut être monté en tant que
                lecteur réseau à des fins de gestion de versions
                transparente (voir
                  <xref
                  linkend="svn.webdav.autoversioning"/>).</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Pourquoi l'éviter&nbsp;:</term>
          <listitem>
            <itemizedlist>

            <listitem><para>significativement plus lent que
              <command>svnserve</command>, car HTTP est un protocole
              sans état et nécessite plus d'allers et retours
              réseau&nbsp;;</para></listitem>

            <listitem><para>la mise en place initiale peut s'avérer
              complexe.</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

      </variablelist>

    </sect2>

    <sect2 id="svn.serverconfig.choosing.recommendations">

      <title>Recommandations</title>

      <para>En général, les auteurs de ce livre recommandent une
        installation ordinaire de <command>svnserve</command> aux
        petites équipes qui débutent avec Subversion&nbsp;; c'est le
        plus simple à installer et celui qui pose le moins de problèmes
        de maintenance. Vous pouvez toujours passer au déploiement d'un
        serveur plus complexe au fur et à mesure que vos besoins
        évoluent.</para>

      <para>Voici quelques recommandations et astuces générales, basées
        sur des années de support aux utilisateurs&nbsp;:</para>

      <itemizedlist>
        <listitem>
          <para>si vous essayez de mettre en place le serveur le plus
            simple possible pour votre groupe, une installation
            ordinaire de <command>svnserve</command> est la voie la plus
            sûre et la plus rapide. Notez cependant que les données de
            votre dépôt circuleront en clair sur le réseau. Si votre
            déploiement se situe entièrement à l'intérieur du LAN ou du
            VPN de votre compagnie, ce n'est pas un problème. Si le
            dépôt est accessible sur Internet, il serait bon de vous
            assurer que son contenu n'est pas sensible (c'est-à-dire
            qu'il ne contient que du code open source), ou alors de
            faire l'effort supplémentaire de configurer SASL pour
            chiffrer les communications réseau&nbsp;;</para>
        </listitem>

        <listitem>
          <para>si vous devez vous insérer au sein de systèmes
            d'authentification déjà en place (LDAP, Active Directory,
            NTLM, X.509,&nbsp;etc.), il vous faudra utiliser soit le serveur
            basé sur Apache, soit <command>svnserve</command> configuré
            avec SASL. Si vous avez un besoin absolu de journaux des
            erreurs côté serveur ou de journaux des activités côté
            client, le serveur basé sur Apache est le seul choix
            possible&nbsp;;</para>
        </listitem>

        <listitem>
           <para>que vous ayez décidé d'utiliser Apache ou un banal
           <command>svnserve</command>, créez un utilisateur
           <literal>svn</literal> unique sur votre système et
           utilisez-le pour faire tourner le processus serveur.
           Assurez-vous également que la totalité du répertoire du dépôt
           est la propriété de cet utilisateur. Du point de vue de la
           sécurité, les données du dépôt restent ainsi englobées et
           protégées par l'application des droits gérés par le système
           de fichiers du système d'exploitation et sont modifiables
           uniquement par le processus serveur Subversion
           lui-même&nbsp;;</para> </listitem>

        <listitem>
          <para>si vous avez une infrastructure existante basée
            principalement sur des comptes SSH et si vos utilisateurs
            possèdent déjà des comptes système sur la machine qui sert
            de serveur, il est logique de déployer une solution
            <command>svnserve</command> sur SSH. Dans le cas contraire,
            nous ne recommandons généralement pas cette option au
            public. Il est considéré comme plus sûr de donner l'accès au
            dépôt à vos utilisateurs au moyen de comptes (imaginaires)
            gérés par <command>svnserve</command> ou Apache plutôt que
            par de véritables comptes système. Si vous voulez vraiment
            chiffrer les communications, nous vous recommandons
            d'utiliser Apache avec chiffrement SSL ou
            <command>svnserve</command> avec chiffrement SASL à la
            place&nbsp;;</para> </listitem>

        <listitem>
          <para>ne vous laissez pas séduire par l'idée très simple de
            donner l'accès à un dépôt à tous vos utilisateurs
            directement via des URL <literal>file://</literal>. Même si
            le dépôt est accessible à tous sur un lecteur réseau, c'est
            une mauvaise idée. Elle ôte toutes les couches de protection
            entre les utilisateurs et le dépôt&nbsp;: les utilisateurs
            peuvent corrompre accidentellement (ou intentionnellement)
            la base de données du dépôt, il est difficile de mettre
            le dépôt hors ligne pour inspection ou pour mise à niveau et
            vous risquez d'aboutir à de graves problèmes de droits sur
            les fichiers (voir <xref
            linkend="svn.serverconfig.multimethod"/>). Remarquez que
            c'est aussi une des raisons pour laquelle nous déconseillons
            d'accéder aux dépôts via des URL
            <literal>svn+ssh://</literal>&nbsp;: du point de vue de la
            sécurité, c'est en fait comme si les utilisateurs locaux y
            accédaient via <literal>file://</literal>, ce qui peut
            entraîner exactement les mêmes problèmes si l'administrateur
            ne fait pas preuve de prudence.</para>
            </listitem> </itemizedlist>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.svnserve">

    <title>svnserve, un serveur sur mesure</title>

    <para>Le programme <command>svnserve</command> est un serveur léger,
      capable de dialoguer avec des clients sur un réseau TCP/IP en
      utilisant un protocole dédié avec gestion des états. Les clients
      contactent le serveur <command>svnserve</command> en utilisant une
      URL qui commence par <literal>svn://</literal> ou
      <literal>svn+ssh://</literal>. Cette section explique différentes
      mises en œuvre de <command>svnserve</command>, l'authentification
      des clients sur le serveur et la configuration d'un contrôle
      d'accès approprié pour vos dépôts.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.invoking">
      <title>Démarrage du serveur</title>

      <para>Il existe différentes façons de démarrer le programme
        <command>svnserve</command>&nbsp;:</para>

      <itemizedlist>
        <listitem><para>lancer <command>svnserve</command> en tant que
            serveur autonome, à l'écoute de
            requêtes&nbsp;;</para></listitem>
        <listitem><para>utiliser le démon Unix <command>inetd</command>
            pour lancer une instance temporaire de
            <command>svnserve</command> quand une requête arrive sur un
            port déterminé&nbsp;;</para></listitem>
        <listitem><para>utiliser SSH pour lancer une instance temporaire
            de <command>svnserve</command> dans un tunnel
            chiffré&nbsp;;</para></listitem>
        <listitem><para>lancer <command>svnserve</command> en tant que
            service Microsoft Windows.</para></listitem>
      </itemizedlist>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.invoking.daemon">
        <title>svnserve en serveur autonome</title>

        <para>Le plus facile est de démarrer <command>svnserve</command>
          en tant que serveur autonome. Pour ce faire, utilisez l'option
          <option>-d</option> (d pour <quote>daemon</quote> qui est
          l'appellation consacrée pour les serveurs Unix)&nbsp;:</para>

        <screen>
$ svnserve -d
$               # svnserve est maintenant actif, en écoute sur le port 3690
</screen>

        <para>Lorsque vous lancez <command>svnserve</command> en serveur
          autonome, vous pouvez utiliser les options
          <option>--listen-port</option> et
          <option>--listen-host</option> pour spécifier le port et
          l'adresse voulus pour <quote>écouter</quote>.</para>

      <para>Une fois le serveur démarré de cette manière, tous les
        dépôts présents sur votre machine seront accessibles par le
        réseau. Un client doit spécifier un <emphasis>chemin
        absolu</emphasis> dans l'URL du dépôt. Par exemple, si un dépôt
        est situé sous <filename>/var/svn/projet-1</filename>, un client
        l'atteindra par
        <uri>svn://hote.exemple.com/var/svn/projet-1</uri>. Pour
        renforcer la sécurité, vous pouvez passer l'option
        <option>-r</option> à <command>svnserve</command> afin de
        restreindre l'export aux dépôts situés sous le chemin indiqué.
        Par exemple&nbsp;:</para>

      <screen>
$ svnserve -d -r /var/svn
&hellip;
</screen>

      <para>L'utilisation de l'option <option>-r</option> modifie le
        chemin que le serveur considère comme la racine du système de
        fichiers à exporter. Les clients utiliseront alors des URL ne
        comportant pas cette portion du chemin (ce qui rend les URL
        plus courtes et plus discrètes)&nbsp;:</para>

      <screen>
$ svn checkout svn://hote.exemple.com/projet-1
&hellip;
</screen>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.invoking.inetd">
        <title>svnserve via inetd</title>

        <para>Si vous désirez que <command>inetd</command> lance le
          processus, il vous faudra passer l'option <option>-i</option>
          (<option>--inetd</option>). Dans l'exemple suivant, nous
          montrons le résultat de la commande
          <literal>svnserve -i</literal>, mais notez bien que ce c'est
          pas de cette manière que l'on démarre le serveur&nbsp;;
          reportez-vous aux paragraphes qui suivent l'exemple pour
          savoir comment configurer <command>inetd</command> pour qu'il
          démarre <command>svnserve</command>.</para>

      <screen>
$ svnserve -i
( success ( 1 2 ( ANONYMOUS ) ( edit-pipeline ) ) )
</screen>

      <para>Quand on l'invoque avec l'option <option>--inetd</option>,
        <command>svnserve</command> tente de communiquer avec un client
        Subversion via l'entrée et la sortie standards
        (<filename>stdin</filename> et <filename>stdout</filename>) en
        utilisant un protocole spécifique. C'est le comportement
        habituel de tout programme lancé par <command>inetd</command>.
        L'IANA a réservé le port 3690 pour le protocole Subversion&nbsp;;
        sur un système Unix vous pouvez donc ajouter au fichier
         <filename>/etc/services</filename> les lignes suivantes (si
         elles n'existent pas déjà)&nbsp;:</para>

      <screen>
svn           3690/tcp   # Subversion
svn           3690/udp   # Subversion
</screen>

      <para>Si votre système utilise un serveur <command>inetd</command>
        classique de type Unix, vous pouvez ajouter la ligne suivante à
        <filename>/etc/inetd.conf</filename>&nbsp;:</para>

      <screen>
svn stream tcp nowait proprio-svn /usr/bin/svnserve svnserve -i
</screen>

      <para>Assurez-vous que l'utilisateur <quote>proprio-svn</quote>
        possède des droits d'accès appropriés pour vos dépôts. Dès lors,
        quand une connexion client arrive sur le port 3690,
        <command>inetd</command> va créer un processus
        <command>svnserve</command> pour lui répondre. Bien sûr, vous
        pouvez également ajouter l'option <option>-r</option> à cette
        ligne de configuration, pour préciser quels dépôts doivent être
        exportés.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.invoking.tunnel">
        <title>svnserve encapsulé dans un tunnel</title>

        <para>Le mode tunnel est une troisième façon de lancer
          <command>svnserve</command>, via l'option <option>-t</option>.
          Ce mode présuppose qu'un programme de connexion à distance tel
          que <command>rsh</command> ou <command>ssh</command> a permis
          à un utilisateur de s'authentifier avec succès et lance alors
          un processus privé <command>svnserve</command> <emphasis>pour
          le compte de cet utilisateur</emphasis> (remarquez qu'en tant
          qu'utilisateur vous aurez rarement, sinon jamais, l'occasion
          de lancer <command>svnserve</command> avec l'option
          <option>-t</option> en ligne de commande&nbsp;; c'est le
          serveur SSH qui le fait à votre place). Le programme
          <command>svnserve</command> se comporte alors normalement
          (utilisation des entrées/sorties <filename>stdin</filename> et
          <filename>stdout</filename>) et suppose que le trafic est
          redirigé automatiquement vers le client par un tunnel. Quand
          <command>svnserve</command> est lancé par un gestionnaire de
          tunnel comme ici, soyez sans crainte&nbsp;: l'utilisateur
          authentifié possédera les droits de lecture et d'écriture sur
          les fichiers de la base de données. C'est essentiellement la
          même chose que quand un utilisateur local accède au dépôt via
          des URL <literal>file://</literal>.</para>

        <para>Cette option est décrite en détail plus loin dans ce
          chapitre, dans <xref
          linkend="svn.serverconfig.svnserve.sshauth"/>.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.invoking.winservice">
        <title>svnserve en tant que service Windows</title>

        <para>Si votre système Windows est un descendant de Windows NT
          (2000, 2003, XP ou Vista), vous pouvez lancer
          <command>svnserve</command> en tant que service Windows. C'est
          généralement une méthode bien plus plaisante que de le
          lancer en démon indépendant via l'option <option>(-d)</option>.
          Utiliser le mode démon nécessite de lancer une console, de
          taper une commande et ensuite de laisser la fenêtre de la
          console tourner indéfiniment. Un service Windows, au contraire,
          tourne à l'arrière-plan, peut être lancé automatiquement au
          démarrage et peut être démarré ou arrêté à l'aide de la même
          interface d'administration que les autres services
          Windows.</para>

        <para>Vous devrez définir le nouveau service en utilisant
          l'outil en ligne de commande <command>SC.EXE</command>. De
          façon analogue à la ligne de configuration
          <command>inetd</command>, il vous faudra fournir la commande
          de lancement précise de <command>svnserve</command> pour que
          Windows le lance au démarrage&nbsp;:</para>

        <screen>
C:\&gt; sc create svn
        binpath= "C:\svn\bin\svnserve.exe --service -r C:\depot"
        displayname= "Serveur Subversion"
        depend= Tcpip
        start= auto
</screen>

        <para>Ceci définit un nouveau service Windows nommé
          <quote>svn</quote>, qui exécute une commande particulière
          <command>svnserve.exe</command> quand il démarre (dont la
          racine est, dans ce cas, <filename>C:\depot</filename>). Il y
          a toutefois un certain nombre de précautions à prendre avec
          cet exemple.</para>

        <para>Premièrement, remarquez que le programme
          <command>svnserve.exe</command> doit toujours être lancé avec
          l'option <option>--service</option>. Toute autre option de
          <command>svnserve</command> doit ensuite être spécifiée sur la
          même ligne, mais vous ne pouvez pas ajouter d'options qui
          seraient en conflit avec celle-ci, telles que
          <option>--daemon (-d)</option>, <option>--tunnel</option>,
          ou <option>--inetd (-i)</option>. D'autres options, comme
          <option>-r</option> ou <option>--listen-port</option> ne
          posent pas de problème. Deuxièmement, faites attention aux
          espaces quand vous tapez la commande
          <command>SC.EXE</command>&nbsp;: les groupes <literal>clé=
          valeur</literal> ne doivent pas comporter d'espace dans
          <literal>clé=</literal> et doivent comporter exactement une
          espace avant <literal>valeur</literal>. Enfin, faites
          attention aux espaces présentes dans la ligne de commande que
          vous indiquez. Si le nom d'un répertoire contient des espaces
          (ou tout autre caractère qui ait besoin d'être banalisé),
          placez l'ensemble du contenu de <literal>binpath</literal>
          entre guillemets, qui doivent eux-mêmes être banalisés&nbsp;:</para>

        <screen>
C:\&gt; sc create svn
        binpath= "\"C:\program files\svn\bin\svnserve.exe\" --service -r C:\depot"
        displayname= "Serveur Subversion"
        depend= Tcpip
        start= auto
</screen>

        <para>Notez aussi que le terme <literal>binpath</literal> prête
          à confusion&nbsp;: sa valeur est une <emphasis>ligne de
          commande</emphasis>, pas le chemin d'accès à un exécutable.
          C'est pourquoi vous devez l'entourer de guillemets s'il
          contient des espaces.</para>

        <para>Une fois que le service a été crée, il peut être arrêté,
          démarré ou interrogé à l'aide des outils standards de
          l'interface graphique (le programme <quote>Services</quote>
          des outils d'administration) ou de la ligne de
          commande&nbsp;:</para>

        <screen>
C:\&gt; net stop svn
C:\&gt; net start svn
</screen>

        <para>Le service peut aussi être désinstallé (c'est-à-dire
          supprimé) en effaçant sa définition&nbsp;:
          <userinput>sc delete svn</userinput>.
          Prenez soin d'arrêter le service auparavant&nbsp;! Le
          programme <command>SC.EXE</command> possède de nombreuses
          autres sous-commandes&nbsp;; tapez <userinput>sc /?</userinput>
          en ligne de commande pour en savoir plus.</para>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.auth">
      <title>Authentification et contrôle d'accès intégrés</title>

      <para>Lorsqu'un client se connecte au processus
        <command>svnserve</command>, les choses suivantes se
        passent&nbsp;:</para>

      <itemizedlist>
        <listitem><para>Le client sélectionne un répertoire
          particulier.</para></listitem>

        <listitem><para>Le serveur analyse le fichier
          <filename>conf/svnserve.conf</filename> de ce dépôt et
          commence à suivre les politiques d'authentification et de
          contrôle d'accès qui y sont décrites.</para></listitem>

        <listitem><para>Selon les politiques définies, une des choses
          suivantes a lieu&nbsp;:</para>

          <itemizedlist>
            <listitem><para>Le client est autorisé à lancer des requêtes
              anonymes, sans jamais recevoir le moindre défi
              d'authentification.</para></listitem>

            <listitem><para>Le client peut recevoir un défi
              d'authentification à tout instant.</para></listitem>

            <listitem><para>Si l'on est en mode tunnel, le client
              déclare lui-même avoir déjà satisfait à une
              authentification externe (généralement par
              SSH).</para></listitem>
          </itemizedlist>
        </listitem>

      </itemizedlist>

      <para>Le serveur <command>svnserve</command> ne sait envoyer, par
        défaut, que des défis d'authentification CRAM-MD5<footnote>
          <para>Voir la RFC 2195.</para>
        </footnote>.
        Plus précisément, le serveur envoie une petite quantité de
        données aux clients. Le client utilise l'algorithme de hachage
        MD5 pour créer une empreinte combinant les données et le mot de
        passe, puis renvoie l'empreinte en guise de réponse. Le serveur
        effectue le même calcul avec le mot de passe enregistré pour
        vérifier que le résultat est identique. <emphasis>Le mot de passe
        ne circule ainsi jamais en clair sur le réseau.</emphasis></para>

      <para>Si votre serveur <command>svnserve</command> a été compilé
        en incluant le support de SASL, non seulement il sait comment
        envoyer des défis CRAM-MD5, mais il connaît aussi probablement
        un grand nombre d'autres mécanismes d'authentification.
        Consultez <xref linkend="svn.serverconfig.svnserve.sasl"/>
        plus loin dans ce chapitre pour savoir comment configurer
        l'authentification et le chiffrement avec SASL.</para>

      <para>Le client peut bien sûr aussi être authentifié en externe
        par un gestionnaire de tunnel tel que <command>ssh</command>.
        Dans ce cas, le serveur se contente de prendre l'identifiant par
        lequel il a été lancé et de s'en servir comme utilisateur
        authentifié. Pour plus de détails, reportez-vous plus loin à
        <xref linkend="svn.serverconfig.svnserve.sshauth"/>.</para>

      <para>Vous avez sûrement déjà deviné que le fichier
        <filename>svnserve.conf</filename> est le mécanisme central qui
        contrôle les politiques d'authentification et de contrôle
        d'accès. Ce fichier a le même format que d'autres fichiers de
        configuration (voir <xref linkend="svn.advanced.confarea"/>)&nbsp;:
        les noms de paragraphes sont entourés de crochets
        (<literal>[</literal> et <literal>]</literal>), les lignes de
        commentaires commencent par des dièses (<literal>#</literal>) et
        chaque paragraphe contient des variables spécifiques qui peuvent
        être définies (<literal>variable = valeur</literal>). Examinons
        ces fichiers et apprenons à les utiliser.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.auth.users">
        <title>Création d'un fichier utilisateurs et d'un domaine
          d'authentification</title>

        <para>Pour ce qui suit, la section <literal>[general]</literal>
          de <filename>svnserve.conf</filename> contient toutes les
          variables dont vous avez besoin. Commencez par modifier les
          valeurs de toutes les variables&nbsp;: choisissez un nom pour
          le fichier qui contiendra vos noms d'utilisateur ainsi que
          vos mots de passe et choisissez un domaine
          d'authentification&nbsp;:</para>

        <screen>
[general]
password-db = fichier-utilisateurs
realm = exemple de domaine
</screen>

        <para>Le domaine (<literal>realm</literal> dans le fichier de
          configuration) est un nom que vous définissez. Il indique aux
          clients à quelle sorte d'<quote>espace de noms</quote> ils se
          connectent&nbsp;; le client Subversion l'affiche dans l'invite
          d'authentification et l'utilise comme clé (en combinaison avec
          le nom de machine et le port du serveur) pour mettre en cache
          les éléments d'authentification sur le disque (voir <xref
          linkend="svn.serverconfig.netmodel.credcache"/>). La variable
          <literal>password-db</literal> pointe vers un fichier séparé
          qui contient une liste de noms d'utilisateurs et de mots de
          passe, utilisant le même format usuel. Par exemple&nbsp;:</para>

        <screen>
[users]
harry = motdepassemachin
sally = motdepassebidule
</screen>

        <para>La valeur de <literal>password-db</literal> peut
          correspondre à un chemin absolu ou à un chemin relatif pour le
          fichier des utilisateurs. Pour de nombreux administrateurs,
          conserver le fichier dans la zone <filename>conf/</filename>,
          aux côtés de <filename>svnserve.conf</filename>, est une
          solution simple et facile. D'un autre côté, il se pourrait que
          deux dépôts, voire plus, doivent partager le même
          fichier&nbsp;; dans ce cas, le fichier devrait sans doute être
          situé dans un répertoire plus accessible. Les dépôts
          partageant le même fichier utilisateurs devraient aussi être
          configurés de sorte qu'ils soient dans le même domaine,
          puisque la liste des utilisateurs définit, par essence, un
          domaine d'authentification. Quel que soit l'emplacement du
          fichier, faites attention à positionner les droits en
          lecture/écriture de façon appropriée. Si vous savez sous quel
          nom d'utilisateur <command>svnserve</command> fonctionnera,
          restreignez l'accès au fichier utilisateurs en
          conséquence.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.auth.general">
        <title>Mise en place du contrôle d'accès</title>

        <para>Il y a deux variables supplémentaires à définir dans le
          fichier <filename>svnserve.conf</filename>&nbsp;: elles
          déterminent ce que les utilisateurs non-authentifiés
          (anonymes) et les utilisateurs authentifiés ont le droit de
          faire. Les variables <literal>anon-access</literal>
          et <literal>auth-access</literal> peuvent contenir les valeurs
          <literal>none</literal>, <literal>read</literal>, ou
          <literal>write</literal>. Choisir la valeur
          <literal>none</literal> empêche à la fois lecture et
          écriture&nbsp;; <literal>read</literal> autorise l'accès en
          lecture seule au dépôt et <literal>write</literal> autorise
          l'accès complet en lecture/écriture au dépôt.
          Par exemple&nbsp;:</para>

        <screen>
[general]
password-db = fichier-utilisateurs
realm = exemple de domaine

# les utilisateurs anonymes ne peuvent accéder au dépôt qu'en lecture
anon-access = read

# les utilisateurs authentifiés peuvent à la fois lire et écrire
auth-access = write
</screen>

        <para>Les lignes présentes dans le fichier contiennent en fait
          les valeurs par défaut des variables, au cas où vous
          oublieriez de les définir. Si vous voulez être encore plus
          prudent, vous pouvez complètement interdire les accès
          anonymes&nbsp;:</para>

        <screen>
[general]
password-db = fichier-utilisateurs
realm = exemple de domaine

# les utilisateurs anonymes ne sont pas autorisés
anon-access = none

# les utilisateurs authentifiés peuvent à la fois lire et écrire
auth-access = write
</screen>

        <para>Le processus serveur sait interpréter non seulement ce
          contrôle d'accès générique, mais aussi des restrictions
          d'accès plus fines associées à des fichiers et répertoires
          spécifiques du dépôt. Pour utiliser cette fonctionnalité, vous
          devez définir un fichier contenant des règles plus détaillées,
          puis faire pointer la variable <literal>authz-db</literal>
          vers ce fichier&nbsp;:</para>

        <screen>
[general]
password-db = fichier-utilisateurs
realm = exemple de domaine

# Règles d'accès propres à certains emplacements
authz-db = fichier-authz
</screen>

        <para>Nous étudions la syntaxe du fichier authz plus loin dans
          ce chapitre, dans <xref
          linkend="svn.serverconfig.pathbasedauthz"/>. Notez que la
          variable <literal>authz-db</literal> n'est pas mutuellement
          exclusive avec les variables <literal>anon-access</literal>
          et <literal>auth-access</literal>&nbsp;; si toutes les
          variables sont définies en même temps,
          <emphasis>toutes</emphasis> les règles doivent être
          satisfaites pour que l'accès soit autorisé.</para>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.sasl">
      <title>Utilisation de svnserve avec SASL</title>

      <para>L'authentification par CRAM-MD5 suffit aux besoins
        de bon nombre d'équipes. Cependant, si votre serveur (et vos
        clients Subversion) ont été compilés avec la bibliothèque
        <quote>Cyrus Simple Authentication and Security Layer</quote>
        (SASL), vous avez à votre disposition un certain nombre
        d'options d'authentification et de chiffrement.</para>

      <sidebar>
        <title>Qu'est-ce que SASL&nbsp;?</title>
        <para>Cyrus Simple Authentication and Security Layer (ce qui
          signifie <quote>Couche d'authentification et de sécurité
          simple</quote>) est un logiciel libre qui a été écrit par
          l'université Carnegie Mellon. Il ajoute des possibilités
          d'authentification et de chiffrement à n'importe quel
          protocole réseau et, à partir de la version 1.5 de Subversion,
          le serveur <command>svnserve</command> ainsi que le client
          <command>svn</command> sont tous les deux capables de se
          servir de cette bibliothèque. Elle peut ne pas être à votre
          disposition&nbsp;: si vous compilez Subversion vous-même, il
          vous faut au minimum la version 2.1 de SASL d'installée sur
          votre système et vous devez vous assurer qu'elle est bien
          prise en compte durant le processus de compilation de
          Subversion. Si vous utilisez un paquet binaire précompilé de
          Subversion, vous devez vérifier auprès de celui qui maintient
          ce paquet si SASL a été inclus à la compilation. SASL est
          fourni avec de nombreux modules optionnels qui représentent
          différents systèmes d'authentification&nbsp;:
          Kerberos (GSSAPI), NTLM, One-Time-Passwords (OTP), DIGEST-MD5,
          LDAP, Secure-Remote-Password (SRP) et d'autres encore.
          Certains mécanismes seront disponibles, d'autres pas&nbsp;;
          pensez à vérifier quels modules sont inclus.</para>

        <para>Vous pouvez télécharger Cyrus SASL (à la fois le code
          source et la documentation) à l'adresse
          <ulink url="http://asg.web.cmu.edu/sasl/sasl-library.html"/>.</para>
      </sidebar>

      <para>Normalement, quand un client Subversion se connecte à
        <command>svnserve</command>, le serveur envoie un message de
        bienvenue qui liste les fonctionnalités qu'il supporte et le
        client répond avec une liste similaire. Si le serveur est
        configuré pour exiger une authentification, il envoie ensuite un
        défi listant les mécanismes d'authentification disponibles&nbsp;;
        le client répond en choisissant un des mécanismes et
        l'authentification se déroule ensuite par quelques échanges de
        messages. Même quand SASL n'est pas présent dans la liste, le
        client et le serveur sont capables d'utiliser les mécanismes
        CRAM-MD5 et ANONYMOUS (voir <xref
        linkend="svn.serverconfig.svnserve.auth"/>). Si le serveur et le
        client ont été compilés pour inclure SASL, un certain nombre
        d'autres mécanismes d'authentification sont éventuellement
        disponibles. Néanmoins, vous devez configurer explicitement
        SASL sur le serveur pour qu'ils soient proposés.</para>

      <sect3 id="svn.serverconfig.svnserve.sasl.authn">
        <title>Authentification par SASL</title>

        <para>Pour activer les mécanismes spécifiques à SASL sur le
          serveur, il faut faire deux choses. D'abord, créez un
          paragraphe <literal>[sasl]</literal> dans le fichier
          <filename>svnserve.conf</filename> de votre dépôt avec le
          couple clé/valeur initial&nbsp;:</para>

        <programlisting>
          [sasl]
          use-sasl = true
</programlisting>

        <para>Ensuite, créez le fichier principal de configuration de
          SASL, appelé <filename>svn.conf</filename>, à un endroit où la
          bibliothèque SASL saura le trouver &mdash; généralement dans
          un répertoire où sont situés les greffons SASL. Vous devez
          localiser le répertoire des greffons de votre système, tel que
          <filename>/usr/lib/sasl2/</filename> ou
          <filename>/etc/sasl2/</filename> (notez qu'<emphasis>il ne
          s'agit pas</emphasis> là du fichier
          <filename>svnserve.conf</filename> qui réside dans votre
          dépôt&nbsp;!).</para>

        <para>Sur un serveur Windows vous devez aussi éditer la base de
          registre (à l'aide d'un outil tel que <command>regedit</command>)
          pour indiquer à SASL les emplacements où chercher. Créez une
          clé nommée <literal>[HKEY_LOCAL_MACHINE\SOFTWARE\Carnegie
          Mellon\Project Cyrus\SASL Library]</literal> et placez-y deux
          clés&nbsp;: l'une appelée <literal>SearchPath</literal>
          (dont la valeur est le chemin du répertoire contenant les
          bibliothèques de greffons SASL
          <filename>sasl*.dll</filename>) et l'autre appelée
          <literal>ConfFile</literal> (dont la valeur est le chemin du
          répertoire parent contenant le fichier
          <filename>svn.conf</filename> que vous avez créé).</para>

        <para>Parce que SASL fournit de très nombreux mécanismes
          d'authentification, il serait insensé (et bien au-delà du
          cadre de ce livre) d'essayer de décrire toutes les
          configurations serveurs possibles. Nous vous recommandons
          plutôt de lire la documentation fournie dans le
          sous-répertoire <filename>doc/</filename> du code source de
          SASL. Elle décrit en détail chaque mécanisme, ainsi que la
          manière de configurer le serveur correctement pour chacun
          d'entre eux. Dans ce paragraphe, nous nous contentons de
          donner un exemple simple de configuration du mécanisme
          DIGEST-MD5. Par exemple, si votre fichier
          <filename>subversion.conf</filename>
          (ou <filename>svn.conf</filename>) contient ce qui
          suit&nbsp;:</para>

        <screen>
pwcheck_method: auxprop
auxprop_plugin: sasldb
sasldb_path: /etc/ma_bdd_sasl
mech_list: DIGEST-MD5
</screen>

        <para>vous demandez à SASL de proposer le mécanisme DIGEST-MD5
          aux clients et de comparer les mots de passe des utilisateurs
          à une base de mots de passe privée située à l'emplacement
          <filename>/etc/ma_bdd_sasl</filename>. Un administrateur
          système pourra ensuite utiliser le programme
          <command>saslpasswd2</command> pour ajouter ou modifier les
          noms d'utilisateurs et les mots de passe contenus dans cette
          base de données&nbsp;:</para>

        <screen>
$ saslpasswd2 -c -f /etc/ma_bdd_sasl -u domaine utilisateur
</screen>

        <para>Quelques consignes de prudence&nbsp;: tout d'abord,
          l'argument <quote>domaine</quote> qui est passé à
          <command>saslpasswd2</command> doit correspondre au même
          domaine que celui que vous avez défini dans le fichier
          <filename>svnserve.conf</filename>&nbsp;; s'ils ne
          correspondent pas, l'authentification échouera. En outre, à
          cause d'une limitation de SASL, ce domaine commun doit être
          une chaîne sans espace. Enfin, si vous décidez d'utiliser la
          base de données standard de mots de passe SASL, assurez-vous
          que le programme <command>svnserve</command> a accès en
          lecture à ce fichier (et éventuellement aussi en écriture, si
          vous utilisez un mécanisme tel que OTP).</para>

        <para>Ceci est une manière simple de configurer SASL. De
          nombreux autres mécanismes d'authentification sont disponibles
          et les mots de passe peuvent être conservés dans des
          conteneurs différents, par exemple des annuaires LDAP ou des
          bases de données SQL. Reportez-vous à la documentation
          complète de SASL pour plus de détails.</para>

        <para>Souvenez-vous que si vous configurez votre serveur pour
          qu'il n'autorise que certains mécanismes d'authentification
          SASL, tous les clients qui se connectent ont l'obligation
          de supporter SASL. Tout client Subversion compilé sans SASL
          (ce qui inclut tous les clients antérieurs à la version 1.5)
          est incapable de se connecter. D'un autre côté, ce type de
          restriction est peut-être exactement ce que vous recherchez
          (<quote>Mes clients doivent tous utiliser Kerberos&nbsp;!</quote>).
          Néanmoins, si vous voulez permettre à des clients non-SASL de
          se connecter, pensez bien à inclure le mécanisme CRAM-MD5 dans
          les choix possibles. Tous les clients savent utiliser
          CRAM-MD5, qu'ils aient des fonctionnalités SASL ou pas.</para>

        </sect3>

      <sect3 id="svn.serverconfig.svnserve.sasl.encryption">
        <title>Chiffrement SASL</title>

        <para>SASL est également capable d'effectuer le chiffrement des
          données si un mécanisme particulier le supporte. Le mécanisme
          intégré CRAM-MD5 ne supporte pas le chiffrement, mais
          DIGEST-MD5 le supporte et d'autres mécanismes tels que SRP
          requièrent l'utilisation de la bibliothèque OpenSSL. Pour
          activer ou désactiver différents niveaux de chiffrement, vous
          pouvez définir deux variables dans le fichier
          <filename>svnserve.conf</filename> de votre dépôt&nbsp;:</para>

        <screen>
[sasl]
use-sasl = true
min-encryption = 128
max-encryption = 256
</screen>

        <para>Les variables <literal>min-encryption</literal> et
          <literal>max-encryption</literal> contrôlent le niveau de
          chiffrement exigé par le serveur. Pour désactiver complètement
          le chiffrement, mettez les deux valeurs à 0. Pour activer une
          simple somme de contrôle sur les données (par exemple pour
          empêcher toute manipulation douteuse et garantir l'intégrité
          des données sans chiffrement), mettez les deux valeurs à 1.
          Si vous voulez autoriser le chiffrement, sans que ce soit
          obligatoire, mettez 0 pour la valeur minimale et un nombre de
          bits donné pour la valeur maximale. Pour exiger un chiffrement
          inconditionnel, mettez les deux valeurs à un nombre plus grand
          que 1. Dans l'exemple précédent, nous obligeons les clients à
          utiliser au moins un chiffrement 128 bits et au plus un
          chiffrement 256 bits.</para>

        </sect3>

      </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.sshauth">
      <title>Encapsulation de svnserve dans un tunnel SSH</title>

      <para>L'authentification intégrée (ainsi que SASL) peuvent être
        très pratiques, car ils évitent d'avoir à créer de véritables
        comptes systèmes. D'un autre côté, certains administrateurs ont
        déjà des systèmes d'authentification bien établis en place. Dans
        ce cas, tous les utilisateurs du projet possèdent déjà des
        comptes systèmes et peuvent se connecter au serveur par
        SSH.</para>

      <para>Utiliser SSH en conjonction avec <command>svnserve</command>
        est facile. Le client utilise juste une URL
        <literal>svn+ssh://</literal> pour se connecter&nbsp;:</para>

      <screen>
$ whoami
harry

$ svn list svn+ssh://hote.exemple.com/depot/projet
harryssh@hote.exemple.com's password:  *****

truc
machin
bidule
&hellip;
</screen>

      <para>Dans cet exemple, le client Subversion lance un processus
        local <command>ssh</command>, se connecte à
        <literal>hote.exemple.com</literal>, s'authentifie en tant que
        <literal>harryssh</literal> (en accord avec la configuration SSH
        des utilisateurs) puis un processus <command>svnserve</command>
        privé est généré automatiquement sur la machine distante,
        processus dont le propriétaire est l'utilisateur
        <literal>harryssh</literal>. La commande
        <command>svnserve</command> est lancée en mode tunnel
        (<option>-t</option>) et son protocole réseau est encapsulé dans
        la connexion chiffrée par <command>ssh</command>, le
        gestionnaire de tunnel. Si le client effectue une propagation,
        l'auteur de la nouvelle révision sera l'utilisateur authentifié
        (<literal>harryssh</literal>).</para>

      <para>Ce qu'il est important de comprendre ici est que le client
        Subversion <emphasis>ne se connecte pas</emphasis> à un serveur
        <command>svnserve</command> fonctionnant en permanence. Cette
        méthode d'accès ne requiert pas la présence d'un démon, ni ne
        vérifie s'il y en a un qui tourne. Elle se base entièrement sur
        la capacité de <command>ssh</command> à générer un processus
        <command>svnserve</command> temporaire, qui ensuite se termine
        une fois la connexion SSH close.</para>

      <para>Quand vous utilisez des URL <literal>svn+ssh://</literal>
        pour accéder à un dépôt, souvenez-vous que c'est le programme
        <command>ssh</command> qui envoie l'invite d'authentification,
        <emphasis>pas le client</emphasis> <command>svn</command>. Ce
        qui signifie qu'il n'y a pas de mise en cache automatique de
        mots de passe (voir <xref
        linkend="svn.serverconfig.netmodel.credcache"/>). Le
        fonctionnement du client Subversion fait qu'il accède souvent au
        dépôt par des connexions multiples, bien que les utilisateurs ne
        s'en rendent habituellement pas compte grâce à la fonctionnalité
        de mise en cache du mot de passe. Lorsque vous utilisez des URL
        <literal>svn+ssh://</literal>, les utilisateurs risquent de
        trouver ça pénible que <command>ssh</command> demande le mot de
        passe de façon répétitive pour toute connexion vers l'extérieur.
        La solution est d'utiliser un outil séparé de mise en cache du
        mot de passe, tel que <command>ssh-agent</command> sur Unix ou
        <command>pageant</command> sur Windows.</para>

      <para>Quand le trafic passe par un tunnel, les accès sont
        contrôlés principalement par les droits sur les fichiers de la
        base de données liés au système d'exploitation&nbsp;; c'est
        quasiment pareil que si Harry accédait au dépôt directement via
        une URL <literal>file://</literal>. Si plusieurs utilisateurs
        systèmes accèdent au dépôt directement, il est de bon ton de
        les placer dans un même groupe et vous devez faire attention aux
        umasks (prenez soin de lire <xref
        linkend="svn.serverconfig.multimethod"/> plus loin dans ce
        chapitre). Mais même dans le cas de l'encapsulation, vous pouvez
        toujours utiliser le fichier <filename>svnserve.conf</filename>
        pour bloquer l'accès, en spécifiant juste <literal>auth-access =
        read</literal> ou <literal>auth-access = none</literal><footnote>
          <para>Notez qu'utiliser le moindre contrôle d'accès avec
            <command>svnserve</command> ne sert strictement à
            rien&nbsp;; l'utilisateur ayant déjà directement accès à la
            base de données.</para>
        </footnote>.
      </para>

      <para>Vous vous attendez à ce que cette histoire
        d'encapsulation SSH se termine ici, mais ce n'est pas le cas.
        Subversion vous permet de créer des comportements
        d'encapsulation personnalisés dans votre fichier de
        configuration (voir <xref linkend="svn.advanced.confarea"/>).
        Par exemple, supposons que vous vouliez utiliser RSH au lieu de
        SSH<footnote>
          <para>Nous ne le recommandons pas, car RSH est
            significativement moins sécurisé que SSH.</para>
        </footnote>.
        Dans le paragraphe <literal>[tunnels]</literal> de votre fichier
        <filename>config</filename>, définissez-le comme ceci&nbsp;:</para>

      <screen>
[tunnels]
rsh = rsh
</screen>

      <para>À présent vous pouvez utiliser cette nouvelle définition
        d'encapsulation par le biais d'un schéma d'URL qui correspond au
        nom de votre nouvelle variable&nbsp;:
        <literal>svn+rsh://hote/chemin</literal>. Lorsqu'il utilise le
        nouveau type d'URL, le client Subversion lance en fait en
        arrière-plan la commande <userinput>rsh hote
        svnserve -t</userinput>. Si vous incluez un nom d'utilisateur
        dans l'URL (par exemple
        <literal>svn+rsh://nomdutilisateur@hote/chemin</literal>), le
        client va l'inclure dans sa commande (<userinput>rsh
        nomdutilisateur@hote svnserve -t</userinput>). Mais vous pouvez
        définir des schémas d'encapsulation bien plus
        évolués&nbsp;:</para>

      <screen>
[tunnels]
joessh = $JOESSH /opt/alternate/ssh -p 29934
</screen>

      <para>Cet exemple illustre plusieurs choses. D'abord, il indique
        comment faire pour que le client Subversion lance un exécutable
        d'encapsulation particulier (celui situé à l'emplacement
        <filename>/opt/alternate/ssh</filename>) avec des options
        particulières. Dans ce cas, se connecter à une URL
        <literal>svn+joessh://</literal> lance un exécutable SSH
        particulier avec les arguments <option>-p 29934</option> (utile
        si vous voulez que le programme d'encapsulation se connecte à un
        port non standard).</para>

      <para>Ensuite, il indique comment définir une variable
        d'environnement personnalisée capable de remplacer le nom du
        programme d'encapsulation. Configurer la variable d'environnement
        <literal>SVN_SSH</literal> est un moyen simple de modifier le
        programme d'encapsulation par défaut. Mais s'il vous faut
        différents programmes d'encapsulation pour différents serveurs,
        chacun se connectant par exemple à un port différent ou passant
        des options différentes à SSH, vous pouvez utiliser le mécanisme
        illustré dans cet exemple. Concrètement, si nous donnons une
        valeur à la variable d'environnement <literal>JOESSH</literal>,
        cette valeur remplacera la totalité de la valeur de la variable
        d'encapsulation &mdash; <command>$JOESSH</command> serait
        exécuté au lieu de <userinput>/opt/alternate/ssh
        -p 29934</userinput>.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.sshtricks">
      <title>Astuces de configuration de SSH</title>

      <para>Il est possible de contrôler non seulement la manière dont
        le client lance <command>ssh</command>, mais aussi le
        comportement de <command>sshd</command> sur votre machine. Dans
        ce paragraphe, nous indiquons comment contrôler la commande
        <command>svnserve</command> précise qui est exécutée par
        <command>sshd</command>, ainsi que comment faire pour que
        plusieurs utilisateurs partagent un même compte système.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.sshtricks.setup">
        <title>Mise en œuvre initiale</title>

        <para>Pour commencer, localisez le répertoire <quote>home</quote>
          du compte utilisateur que vous utilisez pour lancer
          <command>svnserve</command>. Assurez-vous que ce compte
          possède un bi-clé de clés publique/privée et que l'utilisateur
          peut se connecter en s'authentifiant par la méthode à clé
          publique. L'authentification par mot de passe ne fonctionnera
          pas, puisque toutes les astuces SSH qui suivent consistent à
          utiliser le fichier <filename>authorized_keys</filename>.</para>

        <para>S'il n'existe pas déjà, créez le fichier
          <filename>authorized_keys</filename> (sur Unix, c'est
          généralement <filename>~/.ssh/authorized_keys</filename>).
          Chaque ligne de ce fichier décrit une clé publique autorisée à
          se connecter. Ces ligne sont généralement de la
          forme&nbsp;:</para>

        <screen>
  ssh-dsa AAAABtce9euch&hellip; utilisateur@exemple.com
</screen>

        <para>Le premier champ décrit le type de clé, le second champ
          est la clé elle-même, encodée en base 64, et le troisième
          champ est un commentaire. Cependant, c'est un fait moins connu
          que la ligne toute entière peut être précédée par un champ
          <literal>command</literal>&nbsp;:</para>

        <screen>
  command="programme" ssh-dsa AAAABtce9euch… utilisateur@exemple.com
</screen>

        <para>Quand le champ <literal>command</literal> est présent, le
          serveur SSH va lancer le programme indiqué en lieu et place de
          l'habituel <command>svnserve</command> en mode tunnel que le
          client Subversion a demandé. En découlent un certain nombre
          d'astuces côté serveur. Dans les exemples suivants, nous
          abrégeons les lignes du fichier par&nbsp;:</para>

        <screen>
  command="programme" TYPE CLÉ COMMENTAIRE
</screen>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.sshtricks.fixedcmd">
        <title>Contrôle de la commande à exécuter</title>

        <para>Comme nous pouvons spécifier la commande exécutée côté
          serveur, il devient facile de désigner un exécutable
          <command>svnserve</command> spécifique et d'y passer des
          arguments supplémentaires&nbsp;:</para>

        <screen>
  command="/chemin/vers/svnserve -t -r /racine/virtuelle" TYPE CLÉ COMMENTAIRE
</screen>

        <para>Dans cet exemple, <filename>/chemin/vers/svnserve</filename>
          peut être un script personnalisé construit autour de
          <command>svnserve</command> qui spécifie le umask à utiliser
          (voir <xref linkend="svn.serverconfig.multimethod"/>). Il
          indique aussi comment <quote>ancrer</quote>
          <command>svnserve</command> dans un répertoire racine virtuel,
          ce qui est aussi très souvent utilisé quand
          <command>svnserve</command> fonctionne en tant que démon. Le
          but est soit de restreindre l'accès à certaines parties du
          système, soit simplement d'éviter que l'utilisateur ait à
          taper un chemin absolu dans l'URL
          <literal>svn+ssh://</literal>.</para>

        <para>Il est également possible d'avoir plusieurs utilisateurs
          partageant un compte utilisateur unique. Au lieu de créer un
          compte système distinct pour chaque utilisateur, générez
          plutôt un bi-clé de clés publique/privée pour chaque personne.
          Placez ensuite chaque clé publique dans le fichier
          <filename>authorized_users</filename>, une par ligne, et
          utilisez l'option <option>--tunnel-user</option>&nbsp;:</para>

        <screen>
  command="svnserve -t --tunnel-user=harry" TYPE1 CLÉ1 harry@exemple.com
  command="svnserve -t --tunnel-user=sally" TYPE2 CLÉ2 sally@exemple.com
</screen>

        <para>Cet exemple permet à la fois à Harry et à Sally de se
          connecter au même compte utilisateur avec l'authentification
          via leur clé publique. Chacun d'eux doit exécuter une commande
          qui lui est propre&nbsp;; l'option
          <option>--tunnel-user</option> signale à
          <command>svnserve</command> que l'argument fourni doit être
          considéré comme le nom de l'utilisateur authentifié. Sans
          <option>--tunnel-user</option>, toutes les propagations
          sembleraient venir du même compte utilisateur partagé.</para>

        <para>Finalement, un dernier avertissement&nbsp;: autoriser
          l'accès d'un utilisateur au serveur via une clé publique dans
          un compte partagé n'empêche pas forcément d'autres formes
          d'accès SSH, même si vous avez spécifié une valeur pour le
          champ <literal>command</literal> dans le fichier
          <filename>authorized_keys</filename>. Par exemple,
          l'utilisateur aura toujours accès au shell via SSH, il sera
          capable d'effectuer de la redirection X11 ou de la redirection
          d'un port quelconque de votre serveur. Pour accorder le moins
          de droits possibles à l'utilisateur, vous pouvez spécifier des
          options de restriction immédiatement après la commande
          du champ <literal>command</literal>&nbsp;:</para>

        <screen>
  command="svnserve -t --tunnel-user=harry",no-port-forwarding,no-agent-for
warding,no-X11-forwarding,no-pty TYPE1 CLÉ1 harry@exemple.com
</screen>

        <para>Notez bien que tout ceci doit tenir sur une seule ligne,
          vraiment sur une seule ligne, car les fichiers SSH
          <filename>authorized_keys</filename> n'autorisent même pas le
          caractère habituel de continuation de ligne
          (<literal>\</literal>). L'unique raison pour laquelle nous
          avons rajouté une coupure est pour que cela tienne dans le
          format physique d'un livre.</para>

      </sect3>

    </sect2>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.httpd">

    <title>httpd, le serveur HTTP Apache</title>

    <para>Le serveur HTTP Apache est un serveur réseau à tout faire que
      Subversion sait exploiter. Via un module adapté,
      <command>httpd</command> rend les dépôts Subversion accessibles
      aux clients par le protocole WebDAV/DeltaV, qui est une extension
      de HTTP 1.1 (voir <ulink url="http://www.webdav.org/"/> pour plus
      d'informations). Ce protocole se base sur HTTP, le protocole
      omniprésent à la base du World Wide Web, lui ajoute des
      fonctionnalités d'écriture et, en particulier, d'écriture avec
      gestion de versions. Le résultat est un système robuste et standardisé
      qui est inclus dans le logiciel Apache&nbsp;2.0, supporté par de
      nombreux systèmes d'exploitation et outils tiers, et qui ne demande
      pas aux administrateurs réseaux d'ouvrir un port réseau
      supplémentaire<footnote>
        <para>C'est une chose qu'ils détestent faire.</para>
      </footnote>.
      Bien qu'un serveur Apache-Subversion ait plus de fonctionnalités
      que <command>svnserve</command>, il est aussi plus difficile à
      mettre en place. La flexibilité a bien souvent pour contrepartie
      la complexité.</para>

    <para>Une grande partie de ce qui va suivre fait référence à des
      directives de configuration d'Apache. Bien que l'utilisation de
      ces directives soit illustrée par quelques exemples, les décrire
      complètement va bien au-delà du sujet de ce chapitre. L'équipe
      Apache tient à jour une documentation excellente, disponible
      publiquement sur leur site web à l'adresse
      <ulink url="http://httpd.apache.org"/>. Par exemple, le guide de
      référence complet des directives de configuration est situé à
      l'adresse <ulink url="
      http://httpd.apache.org/docs-2.0/mod/directives.html"/>.</para>

    <para>En outre, au fur et à mesure des changements que vous
      apporterez à votre configuration d'Apache, il est probable que
      vous commettrez des erreurs. Si vous n'êtes pas déjà familier avec
      le sous-système de journalisation d'Apache, vous devrez apprendre
      à le connaître. Dans votre fichier <filename>httpd.conf</filename>,
      des directives spécifient l'emplacement sur le disque des journaux
      d'accès et d'erreurs générés par Apache (les directives
      <literal>CustomLog</literal> et <literal>ErrorLog</literal>
      respectivement). Le module <command>mod_dav_svn</command> de
      Subversion utilise également l'interface de journalisation des
      erreurs d'Apache. Pensez à naviguer dans ces fichiers lorsque vous
      recherchez des informations susceptibles de vous aider à trouver
      l'origine d'un problème.</para>

    <sidebar>
      <title>À propos d'Apache&nbsp;2</title>

      <para>Si vous êtes un administrateur système, il est très probable
        que vous utilisiez déjà le serveur web Apache et que vous en
        ayez une expérience préalable. À l'heure où ces lignes sont
        écrites, Apache&nbsp;1.3 est la version la plus populaire d'Apache.
        Le passage de la communauté à Apache&nbsp;2 est assez lent, pour
        diverses raisons&nbsp;: certains ont peur du changement, en
        particulier quand il s'agit de toucher à quelque chose d'aussi
        essentiel qu'un serveur web. D'autres dépendent de greffons qui
        ne fonctionnent qu'avec l'interface (l'API) de Apache&nbsp;1.3 et
        attendent qu'ils soient portés vers Apache&nbsp;2. Quelle qu'en
        soit la raison, beaucoup de gens commencent à s'inquiéter quand
        ils découvrent que le module Apache de Subversion a été écrit
        spécifiquement pour l'API d'Apache&nbsp;2.</para>

      <para>Mais ne vous inquiétez pas&nbsp;! Il est facile de faire
        fonctionner Apache&nbsp;1.3 et Apache&nbsp;2 côte à côte&nbsp;;
        il suffit de les installer dans des endroits séparés et
        d'utiliser Apache&nbsp;2 en tant que serveur dédié fonctionnant
        sur un port autre que le port 80. Les clients peuvent dès lors
        accéder au dépôt en indiquant le numéro de port dans
        l'URL&nbsp;:</para>

      <screen>
$ svn checkout http://hote.exemple.com:7382/depot/projet
</screen>
    </sidebar>


    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.prereqs">
      <title>Prérequis</title>

      <para>Pour mettre à disposition votre dépôt sur le réseau par
        HTTP, il vous faut quatre composants, disponibles dans deux
        paquets. Il vous faut Apache&nbsp;<command>httpd</command>&nbsp;2.0, le
        module DAV <command>mod_dav</command> fourni avec, Subversion et
        le module <command>mod_dav_svn</command> implémentant le système
        de fichiers, qui est fourni avec Subversion. Une fois que vous
        avez tous ces composants, la procédure de mise en réseau de
        votre dépôt est aussi simple que&nbsp;:</para>

      <itemizedlist>
        <listitem>
          <para>faire fonctionner httpd 2.0 avec le module
            <command>mod_dav</command>&nbsp;;</para>
        </listitem>
        <listitem>
          <para>installer le module <command>mod_dav_svn</command>
            derrière <command>mod_dav</command>
            (<command>mod_dav_svn</command> utilise les bibliothèques
            Subversion pour accéder au dépôt)&nbsp;;</para>
        </listitem>
        <listitem>
          <para>configurer le fichier <filename>httpd.conf</filename>
            pour exporter (ou <quote>exposer</quote>) le dépôt.</para>
        </listitem>
      </itemizedlist>

      <para>Vous pouvez accomplir les deux premières tâches ci-dessus
        soit en compilant <command>httpd</command> et Subversion à
        partir du code source, soit en installant les paquets binaires
        précompilés correspondants sur votre système. Les informations
        les plus récentes sur la façon de compiler Subversion dans le
        cadre d'une utilisation en conjonction avec le serveur
        HTTP&nbsp;Apache, sur la compilation et sur la configuration
        d'Apache lui-même dans cet objectif, sont consultables dans le
        fichier <filename>INSTALL</filename> situé à la racine de 
        l'arborescence du code source de Subversion.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.basic">
      <title>Configuration Apache de base</title>

      <para>Une fois que les composants requis sont installés sur votre
        système, il ne reste plus qu'à configurer Apache au moyen de son
        fichier <filename>httpd.conf</filename>. Indiquez à Apache de
        charger le module <command>mod_dav_svn</command> grâce à la
        directive <literal>LoadModule</literal>. Cette directive doit
        précéder tout autre élément de configuration lié à Subversion.
        Si votre serveur Apache a été installé avec la configuration par
        défaut, votre module <command>mod_dav_svn</command> devrait
        avoir été installé dans le sous-répertoire
        <filename>modules</filename> du répertoire d'installation
        d'Apache (souvent <filename>/usr/local/apache2</filename>). La
        directive <literal>LoadModule</literal> a une syntaxe très
        simple, faisant correspondre un nom de module à l'emplacement
        sur le disque d'une bibliothèque partagée&nbsp;:</para>

        <screen>
LoadModule dav_svn_module     modules/mod_dav_svn.so
</screen>

      <para>Notez que si <command>mod_dav</command> a aussi été compilé
        sous forme de bibliothèque partagée (et non par une édition de
        liens statiques qui le place alors directement dans l'exécutable
        <command>httpd</command>), il vous faudra une directive
        <literal>LoadModule</literal> pour celui-ci. Assurez-vous
        qu'elle est placée avant la ligne
        <command>mod_dav_svn</command>&nbsp;:</para>

        <screen>
LoadModule dav_module         modules/mod_dav.so
LoadModule dav_svn_module     modules/mod_dav_svn.so
</screen>


      <para>Plus loin dans votre fichier de configuration, vous
        devez indiquer à Apache l'endroit où réside votre dépôt (ou vos
        dépôts) Subversion. La directive <literal>Location</literal>
        possède une syntaxe de type XML, qui commence par une balise de
        début, se termine par une balise de fin et contient diverses autres
        directives de configuration au milieu. Le sens de la directive
        <literal>Location</literal> est de faire faire à Apache quelque
        chose de spécial quand il traite les requêtes adressées à une
        URL donnée ou à une de ses filles. Dans le cas de Subversion, il
        faut qu'Apache fasse traiter par la couche DAV les URL pointant
        vers les ressources suivies en versions. Vous pouvez indiquer à
        Apache de déléguer le traitement de toutes les URL dont la
        partie chemin d'accès (la partie de l'URL qui suit le nom du
        serveur et le numéro de port optionnel) commence par
        <filename>/depot/</filename> à un gestionnaire de DAV dont le
        dépôt est situé à l'adresse
        <filename>/var/svn/mon-depot</filename> en utilisant la syntaxe
        <filename>httpd.conf</filename> suivante&nbsp;:</para>

        <screen>
&lt;Location /depot&gt;
  DAV svn
  SVNPath /var/svn/mon-depot
&lt;/Location&gt;
</screen>

      <para>Si vous avez l'intention de gérer plusieurs dépôts
        Subversion résidant dans le même répertoire parent sur votre
        disque local, vous pouvez utiliser une directive alternative,
        <literal>SVNParentPath</literal>, pour faire état de ce
        répertoire parent commun. Par exemple, si vous savez que vous
        allez créer plusieurs dépôts Subversion dans le répertoire
        <filename>/var/svn</filename>, auxquels on accédera par des URL
        telles que <uri>http://mon.serveur.com/svn/depot1</uri>,
        <uri>http://mon.serveur.com/svn/depot2</uri>,&nbsp;etc., vous
        pouvez utiliser la syntaxe de configuration de
        <filename>httpd.conf</filename> de l'exemple suivant&nbsp;:</para>

        <screen>
&lt;Location /svn&gt;
  DAV svn

  # à toute URL "/svn/truc" correspond un dépôt /var/svn/truc
  SVNParentPath /var/svn
&lt;/Location&gt;
</screen>

      <para>Par cette syntaxe, Apache va déléguer le traitement de
        toutes les URL dont le chemin d'accès commence par
        <filename>/svn/</filename> au gestionnaire DAV de Subversion,
        qui ensuite supposera que tous les éléments du répertoire
        spécifié dans la directive <literal>SVNParentPath</literal> sont
        en fait des dépôts Subversion. C'est une syntaxe
        particulièrement pratique dans le sens où, à la différence de
        celles utilisant la directive <literal>SVNPath</literal>, vous
        n'avez pas besoin de redémarrer Apache pour créer et mettre à
        disposition sur le réseau de nouveaux dépôts.</para>

      <para>Vérifiez bien que, quand vous définissez votre nouvelle
        directive <literal>Location</literal>, elle n'interfère pas avec
        d'autres emplacements exportés. Par exemple, si votre
        <literal>DocumentRoot</literal> (c'est-à-dire le répertoire
        racine des fichiers qu'Apache expose sur le web) principal est
        exporté vers <filename>/www</filename>, n'exportez pas de dépôt
        Subversion vers <literal>&lt;Location /www/depot&gt;</literal>.
        Si une requête arrivait pour l'URI
        <filename>/www/depot/machin.c</filename>, Apache ne saurait pas
        s'il doit chercher un fichier <filename>depot/machin.c</filename>
        dans son <literal>DocumentRoot</literal> ou s'il doit déléguer à
        <command>mod_dav_svn</command> la tâche de renvoyer
        <filename>machin.c</filename> qui se trouve dans le dépôt
        Subversion. Ceci aboutit souvent à une erreur du serveur de la
        forme <literal>301 Moved Permanently</literal>.</para>

      <sidebar>
        <title>Noms de serveur et requêtes COPY</title>

        <para>Subversion se sert du type de requête <literal>COPY</literal>
          pour effectuer des copies de fichiers et de répertoires côté
          serveur. Les modules Apache vérifient que la source de la
          copie est bien située sur la même machine que la destination.
          Pour satisfaire cette exigence, vous aurez peut-être besoin de
          déclarer à <command>mod_dav</command> le nom d'hôte de votre
          serveur. En général, la directive
          <literal>ServerName</literal> du fichier
          <filename>httpd.conf</filename> peut être utilisée à cette
          fin.</para>

        <screen>
ServerName svn.exemple.com
</screen>

        <para>Si vous faites usage du support des hôtes virtuels
          d'Apache via la directive <literal>NameVirtualHost</literal>,
          la directive <literal>ServerAlias</literal> vous permettra de
          spécifier des noms additionnels désignant votre serveur.
          Encore une fois, reportez-vous à la documentation Apache pour
          plus de détails.</para>
      </sidebar>

      <para>À présent, il nous faut examiner sérieusement la question
        des droits d'accès. Si vous utilisez Apache depuis un certain
        temps en tant que serveur web principal, vous hébergez
        certainement pas mal de contenu&nbsp;: des pages web, des
        scripts,&nbsp;etc. Ces éléments ont déjà été configurés avec un
        ensemble de droits qui leur permet de fonctionner avec Apache,
        ou plus exactement qui permet à Apache de travailler avec ces
        fichiers. Apache, quand on l'utilise en tant que serveur
        Subversion, a aussi besoin de droits d'accès corrects pour lire
        et écrire dans votre dépôt.</para>

      <para>Vous devez mettre en place les droits d'accès qui satisfont
        les besoins de Subversion sans mettre à mal l'installation des
        pages web et scripts pré-existants. Ceci implique peut-être de
        modifier les droits d'accès de votre dépôt Subversion pour
        qu'ils correspondent à ceux utilisés par les autres éléments
        qu'Apache gère, ou bien utiliser les directives
        <literal>User</literal> et <literal>Group</literal>
        du fichier <filename>httpd.conf</filename> pour spécifier
        qu'Apache doit fonctionner avec l'identifiant et le groupe qui
        est propriétaire de votre dépôt Subversion. Il n'y a pas une
        façon unique de mettre en place les droits d'accès et chaque
        administrateur a ses propres raisons pour faire les choses d'une
        manière ou d'une autre. Soyez juste conscient que les problèmes
        liés aux droits d'accès sont peut-être le point le plus négligé
        lors de la configuration d'un dépôt avec Apache.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.authn">
      <title>Options d'authentification</title>

      <para>À ce stade, si vous avez configuré
        <filename>httpd.conf</filename> avec quelque chose du
        style&nbsp;:</para>

      <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn
&lt;/Location&gt;
</screen>

      <para>votre dépôt est à présent accessible
        <quote>anonymement</quote> au reste du monde. Jusqu'à ce que
        configuriez des politiques d'authentification et de contrôle
        d'accès, les dépôts Subversion que vous rendez disponibles via
        la directive <literal>Location</literal> sont généralement
        accessibles à tous. En d'autres termes&nbsp;:</para>

      <itemizedlist>
        <listitem>
          <para>N'importe qui peut utiliser un client Subversion pour
            extraire une copie de travail d'une URL du dépôt (ou de
            n'importe lequel de ses sous-répertoires).</para>
        </listitem>
        <listitem>
          <para>N'importe qui peut naviguer interactivement dans la
            dernière révision du dépôt rien qu'en allant avec un
            navigateur web à l'URL du dépôt.</para>
        </listitem>
        <listitem>
          <para>N'importe qui peut effectuer des propagations vers le
            dépôt. </para>
        </listitem>
      </itemizedlist>

      <para>Bien sûr, vous avez peut-être déjà mis en place une procédure
        automatique <filename>pre-commit</filename> pour empêcher les
        propagations (voir <xref linkend="svn.reposadmin.create.hooks"/>).
        Mais en progressant dans la lecture de ce chapitre, vous verrez
        qu'il est également possible d'utiliser les méthodes intégrées
        dans Apache pour restreindre les accès de façon
        spécifique.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authn.basic">
        <title>Mise en place de l'authentification HTTP</title>

        <para>La manière la plus facile d'authentifier un client est le
          mécanisme d'authentification <quote>Basic</quote> de HTTP, qui
          utilise juste un nom d'utilisateur et un mot de passe pour
          vérifier que l'utilisateur est bien celui qu'il prétend être.
          Apache fournit un utilitaire <command>htpasswd</command>
          pour gérer la liste des noms d'utilisateurs et mots de passe
          acceptés. Accordons le droit de propager à Sally et à Harry.
          D'abord, il faut les ajouter au fichier des mots de
          passe&nbsp;:</para>

        <screen>
$ ### Première fois : utilisez -c pour créer le fichier
$ ### Ajoutez -m pour MD5 afin de chiffrer le mot de passe et ainsi le rendre plus sûr
$ htpasswd -cm /etc/fichier-auth-svn harry
New password: *****
Re-type new password: *****
Adding password for user harry
$ htpasswd -m /etc/fichier-auth-svn sally
New password: *******
Re-type new password: *******
Adding password for user sally
$
</screen>

        <para>Ensuite, vous devez ajouter des directives dans le bloc
          <literal>Location</literal> du fichier
          <filename>httpd.conf</filename> pour indiquer à Apache comment
          se servir du nouveau fichier des mots de passe. La directive
          <literal>AuthType</literal> spécifie le type d'authentification
          que l'on veut utiliser. Dans notre cas, nous voulons utiliser
          le mode <quote>Basic</quote>. La directive
          <literal>AuthName</literal> permet de donner un nom arbitraire
          au domaine d'authentification. La plupart des navigateurs
          affichent ce nom dans la boîte de dialogue (pop-up)
          qui demande le nom d'utilisateur et le mot de passe. Enfin,
          utilisez la directive <literal>AuthUserFile</literal> pour
          spécifier le chemin du fichier des mots de passe que vous venez
          de créer avec la commande <command>htpasswd</command>.</para>

        <para>Après avoir ajouté ces trois directives, votre bloc
          <literal>&lt;Location&gt;</literal> devrait ressembler à
          ceci&nbsp;:</para>

        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn
  AuthType Basic
  AuthName "Depot Subversion"
  AuthUserFile /etc/fichier-auth-svn
&lt;/Location&gt;
</screen>

        <para>Ce bloc <literal>&lt;Location&gt;</literal> n'est pas
          encore complet et il ne sert pas à grand chose pour l'instant.
          Il indique juste à Apache que, lorsqu'un contrôle d'accès est
          requis, Apache doit demander un nom d'utilisateur et un mot de
          passe au client Subversion. Ce qui manque ici, cependant, ce
          sont les directives qui indiquent à Apache <emphasis>quelles
          sortes de requêtes client</emphasis> requièrent un contrôle
          d'accès. Dès que le contrôle d'accès est demandé, Apache
          exige également l'authentification. La chose la plus simple à
          faire est de protéger toutes les requêtes. Ajouter
          <literal>Require valid-user</literal> signale à Apache que,
          pour toutes les requêtes, l'utilisateur doit être
          authentifié&nbsp;:</para>

        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn
  AuthType Basic
  AuthName "Depot Subversion"
  AuthUserFile /etc/fichier-auth-svn
  Require valid-user
</screen>

        <para>Prenez bien soin de lire <xref
          linkend="svn.serverconfig.httpd.authz"/> qui suit pour plus de 
          détails sur la directive <literal>Require</literal> et sur les 
          autres manières de mettre en œuvre des politiques de contrôle
          d'accès.</para>

        <para>Un petit avertissement&nbsp;: les mots de passe de la
          méthode HTTP Basic Auth circulent pratiquement en clair sur le
          réseau et ne sont donc pas du tout sécurisés.</para>

        <para>Une autre possibilité est de ne pas utiliser la méthode
          d'authentification <literal>Basic</literal> mais d'utiliser la
          méthode d'authentification <literal>Digest</literal> à la
          place. L'authentification <literal>Digest</literal> permet au
          server de vérifier l'identité du client <emphasis>sans envoyer
          le mot de passe en clair</emphasis> sur le réseau. En
          supposant que le client et le serveur connaissent tous les
          deux le mot de passe de l'utilisateur, ils peuvent vérifier
          que le mot de passe est le même en l'utilisant pour appliquer
          une fonction de hachage à une donnée créée pour l'occasion. Le
          serveur envoie au client une chaîne plus ou moins aléatoire de
          petite taille&nbsp;; le client se sert du mot de passe de
          l'utilisateur pour créer un condensat
          (<foreignphrase>hash</foreignphrase> en anglais) de
          cette chaîne&nbsp;; le serveur examine ensuite si le condensat
          correspond à ses attentes.</para>

        <para>Configurer Apache pour la méthode d'authentification
          <literal>Digest</literal> est également assez facile et ne
          comporte qu'une petite variation par rapport à notre exemple
          précédent. Prenez soin de consulter la documentation complète
          d'Apache pour plus de détails.</para>

        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn
  AuthType Digest
  AuthName "Depot Subversion"
  AuthDigestDomain /svn/
  AuthUserFile /etc/fichier-auth-svn
  Require valid-user
&lt;/Location&gt;
</screen>

        <para>Si vous recherchez la sécurité maximale, la cryptographie
          à clé publique est la meilleure solution. Il est sans doute
          mieux d'utiliser du chiffrement SSL afin que les clients
          s'authentifient via <literal>https://</literal> au lieu de
          <literal>http://</literal>&nbsp;; le minimum minimorum
          consiste alors à configurer Apache pour qu'il utilise un
          certificat serveur auto-signé<footnote>
            <para>Bien que les certificats serveurs auto-signés soient
              vulnérables aux attaques du type
              <foreignphrase>man-in-the-middle</foreignphrase>
              (<quote>attaque de l'homme du milieu</quote> en français),
              une telle attaque est bien plus difficile
              à exécuter pour un observateur occasionnel
              que de juste espionner les mots de passe
              qui passent en clair sur le réseau.</para>
          </footnote>.
          Consultez la documentation Apache (et la documentation
          OpenSSL) pour savoir comment faire.</para>

      </sect3>


      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authn.sslcerts">
        <title>Gestion des certificats SSL</title>

        <para>Les entreprises qui ont besoin de rendre leur dépôts
          disponibles au-delà du pare-feu périmétrique de leur société
          doivent être conscientes que des entités non-autorisées auront
          la possibilité d'<quote>écouter</quote> leur trafic réseau.
          SSL permet de diminuer le risque que cette écoute conduise à
          des fuites de données sensibles.</para>

        <para>Si un client Subversion est compilé pour utiliser OpenSSL,
          il obtient la possibilité de communiquer avec le serveur
          Apache via des URL <literal>https://</literal>. La
          bibliothèque Neon utilisée par le client Subversion est non
          seulement capable de vérifier les certificats du serveur, mais
          aussi de renvoyer des certificats clients quand on le lui
          demande. Une fois que le client et le serveur ont échangé des
          certificats SSL et se sont authentifiés mutuellement avec
          succès, tous les échanges qui s'ensuivent sont chiffrés par
          une clé de session.</para>

        <para>Expliquer comment générer des certificats clients et
          serveurs ou comment configurer Apache pour les utiliser
          s'éloigne trop du sujet de ce livre. De nombreux autres
          livres, dont la documentation Apache elle-même, expliquent
          comment le faire. Mais nous <emphasis>pouvons quand
          même</emphasis> traiter ici la question de la gestion des
          certificats clients et serveurs à partir d'un client
          Subversion ordinaire.</para>

        <para>Quand il communique avec Apache via
          <literal>https://</literal>, un client Subversion peut
          recevoir deux types d'informations différentes&nbsp;:</para>

        <itemizedlist>
          <listitem><para>un certificat serveur&nbsp;;</para></listitem>
          <listitem><para>une demande de certificat client.</para></listitem>
        </itemizedlist>

        <para>Si le client reçoit un certificat serveur, il doit
          vérifier que ce certificat est digne de confiance&nbsp;: le
          serveur est-il bien celui qu'il prétend être&nbsp;? La
          bibliothèque OpenSSL effectue cette vérification en examinant
          le signataire du certificat serveur, aussi nommé
          <firstterm>autorité de certification</firstterm> (AC, ou
          <foreignphrase>CA</foreignphrase> en anglais). Si OpenSSL
          n'est pas capable de faire confiance
          automatiquement à l'autorité de certification,
          ou si un autre problème apparaît (tel que l'expiration du
          certificat ou des noms d'hôtes divergents), le client en ligne
          de commande de Subversion vous demande si vous voulez faire
          confiance au certificat serveur malgré tout&nbsp;:</para>

        <screen>
$ svn list https://hote.exemple.com/depot/projet

Erreur de validation du certificat du serveur pour 'https://hote.exemple.com:443' :
 - Le certificat n'est pas signé pas une autorité de confiance.
   Valider le certificat manuellement !
Informations du certificat :
 - nom d'hôte : hote.exemple.com
 - valide de Jan 30 19:23:56 2004 GMT à Jan 30 19:23:56 2006 GMT
 - signataire : CA, exemple.com, Sometown, California, US
 - empreinte : 7d:e1:a9:34:33:39:ba:6a:e9:a5:c4:22:98:7b:76:5c:92:a0:9c:7b

(R)ejet, acceptation (t)emporaire ou (p)ermanente ?
</screen>

        <para>Cette question devrait vous être familière&nbsp;; c'est
          probablement la même que vous avez déjà dû voir posée par
          votre navigateur web (qui n'est rien d'autre qu'un client HTTP
          comme Subversion). Si vous choisissez l'option
          <literal>(p)</literal>ermanente, le certificat du serveur sera
          mis en cache dans votre zone privée <filename>auth/</filename>
          de la même façon que le nom d'utilisateur et le mot de passe y
          sont conservés (voir <xref
          linkend="svn.serverconfig.netmodel.credcache"/>). S'il est en
          cache, Subversion fera automatiquement confiance à ce
          certificat dans les échanges futurs.</para>

        <para>Votre fichier <filename>servers</filename> dans la zone de
          configuration vous permet également d'indiquer au client
          Subversion qu'il doit automatiquement faire confiance à
          certaines autorités de certification spécifiques, soit
          globalement, soit en tenant compte de la machine hôte. Il
          suffit d'attribuer à la variable
          <literal>ssl-authority-files</literal> une liste de certificats
          d'autorités de certification au format PEM, séparés par des
          points-virgules&nbsp;:</para>

        <screen>
[global]
ssl-authority-files = /chemin/vers/certAC-1.pem;/chemin/vers/certAC-2.pem
</screen>

        <para>De nombreuses installations d'OpenSSL possèdent par défaut
          une liste prédéfinie d'autorités de certification auxquelles
          il est fait confiance de manière quasi-universelle. Pour que
          le client Subversion fasse confiance à ces autorités de
          certification automatiquement, mettez la variable
          <literal>ssl-trust-default-ca</literal> à
          <literal>true</literal>.</para>

        <para>Quand il communique avec Apache, un client Subversion peut
          également recevoir une demande (un défi) de certificat client.
          Apache demande au client de s'authentifier&nbsp;: le client
          est-il bien celui qu'il prétend être&nbsp;? Si tout se passe
          bien, le client Subversion renvoie un certificat (public)
          signé par une autorité de certification en laquelle Apache a
          confiance ainsi qu'une preuve que le client possède bien la
          clé privée associée au certificat (la réponse au défi). La clé
          privée, ainsi que le certificat public, sont habituellement
          enregistrés dans un conteneur (un fichier <quote>.p12</quote>,
          fichier au format PKCS#12) sur le
          disque, la clé privée étant chiffrée à l'aide d'un mot de
          passe. Quand Subversion reçoit ce défi, il vous demande le
          chemin d'accès au conteneur ainsi que le mot de passe qui
          protège la clé privée&nbsp;:</para>

        <screen>
$ svn list https://hote.exemple.com/depot/projet

Domaine d'authentification :  https://hote.exemple.com:443
Fichier du certificat client : /chemin/vers/mon/cert.p12
Phrase de passe pour '/chemin/vers/mon/cert.p12' : ********
&hellip;
</screen>

        <para>Pour utiliser un certificat client avec Subversion, il doit
          être dans un conteneur au format PKCS#12, qui est un standard
          portable. La plupart des navigateurs web sont déjà capables
          d'importer et d'exporter des certificats dans ce format. Une
          autre option est d'utiliser les outils en ligne de commande
          d'OpenSSL pour convertir les certificats existants en
          PKCS#12.</para>

        <para>Encore une fois, le fichier <filename>servers</filename>
          de la zone de configuration vous permet d'automatiser la
          réponse à ces demandes en tenant compte de la machine hôte.
          L'une ou l'autre des informations, ou bien les deux, peuvent
          être décrites dans les variables de configuration&nbsp;:</para>

        <screen>
[groups]
exemple-d-hote = hote.exemple.com

[exemple-d-hote]
ssl-client-cert-file = /chemin/vers/mon/cert.p12
ssl-client-cert-password = un-mot-de-passe
</screen>

        <para>Une fois que vous avez défini les variables
          <literal>ssl-client-cert-file</literal> et
          <literal>ssl-client-cert-password</literal>, le client
          Subversion peut répondre automatiquement à une demande de
          certificat client sans la moindre interaction de votre
          part<footnote>
            <para>Les administrateurs qui attachent le plus
              d'importance à la sécurité
              peuvent ne pas vouloir stocker le mot de passe du
              certificat client dans le fichier
              <filename>servers</filename> de la zone de
              configuration.</para>
          </footnote>.
        </para>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.authz">
      <title>Options de contrôle d'accès</title>

      <para>À ce stade, vous avez configuré l'authentification mais pas
        le contrôle d'accès. Apache est capable d'envoyer des défis aux
        clients afin de confirmer leur identité mais on ne lui a pas
        encore dit comment autoriser ou restreindre les accès en
        fonction de l'utilisateur. Ce paragraphe décrit deux stratégies
        pour contrôler les accès au dépôt.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authz.blanket">
        <title>Contrôle d'accès générique</title>

        <para>La forme la plus simple de contrôle d'accès est
          d'autoriser des utilisateurs donnés à accéder à un dépôt en
          lecture seule ou en lecture/écriture.</para>

        <para>Vous pouvez restreindre l'accès à toutes les opérations du
          dépôt en ajoutant la directive
          <literal>Require valid-user</literal> à votre bloc
          <literal>&lt;Location&gt;</literal>. Pour poursuivre dans la
          veine de notre exemple précédent, cela signifie que seuls les
          clients disant être <literal>harry</literal> ou
          <literal>sally</literal> et qui ont fourni le bon mot de passe
          pour leur nom d'utilisateur respectif ont l'autorisation
          d'effectuer des actions sur le dépôt Subversion&nbsp;:</para>

        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn

  # comment authentifier un utilisateur
  AuthType Basic
  AuthName "Depot Subversion"
  AuthUserFile /chemin/vers/fichier/utilisateurs

  # seuls les utilisateurs authentifiés ont le droit d'accès au dépôt
  Require valid-user
&lt;/Location&gt;
</screen>

        <para>Parfois vous n'aurez pas besoin d'être aussi strict. Par
          exemple, le propre dépôt du code source de Subversion, situé à
          l'adresse <ulink 
          url="http://svn.apache.org/repos/asf/subversion/"/>
          autorise toute personne à effectuer des opérations de lecture
          du dépôt (comme extraire des copies de travail ou naviguer
          dans le dépôt avec un navigateur web) mais restreint toutes
          les opérations d'écriture aux utilisateurs authentifiés. Pour
          accomplir ce type de restriction sélective, vous pouvez
          utiliser les directives de configuration
          <literal>Limit</literal> et <literal>LimitExcept</literal>.
          Tout comme la directive <literal>Location</literal>, ces blocs
          doivent débuter et finir par des balises et vous devez les
          imbriquer dans votre bloc <literal>&lt;Location&gt;</literal>.</para>

        <para>Les paramètres présents dans les directives
          <literal>Limit</literal> et <literal>LimitExcept</literal>
          sont des types de requêtes HTTP qui sont concernés par ce
          bloc. Par exemple, si voulez désactiver tout accès au dépôt
          excepté pour les opérations de lecture déjà supportées,
          utilisez la directive <literal>LimitExcept</literal>, en lui
          passant les paramètres de type de requêtes
          <literal>GET</literal>, <literal>PROPFIND</literal>,
          <literal>OPTIONS</literal> et <literal>REPORT</literal>.
          Ensuite placez la directive <literal>Require valid-user</literal>
          mentionnée précédemment à l'intérieur du bloc
          <literal>&lt;LimitExcept&gt;</literal> au lieu de la mettre
          juste à l'intérieur du bloc
          <literal>&lt;Location&gt;</literal>.</para>

        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn

  # comment authentifier un utilisateur
  AuthType Basic
  AuthName "Depot Subversion"
  AuthUserFile /chemin/vers/fichier/utilisateurs

  # Pour toute autre opération que celles-ci, exiger un utilisateur authentifié.
  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;
    Require valid-user
  &lt;/LimitExcept&gt;
&lt;/Location&gt;
</screen>

        <para>Ce ne sont là que quelques exemples simples. Pour des
          informations plus poussées sur le contrôle d'accès d'Apache et
          la directive <literal>Require</literal>, jetez un œil à la
          section <literal>Security</literal> du recueil des didacticiels
          de la documentation Apache à l'adresse <ulink
          url="http://httpd.apache.org/docs-2.0/misc/tutorials.html"/>
          (site en anglais).</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authz.perdir">
        <title>Contrôle d'accès par répertoire</title>

        <para>On peut également mettre en place des droits d'accès avec
          une granularité plus fine en utilisant un second module
          Apache&nbsp;httpd, <command>mod_authz_svn</command>. Ce module
          se saisit des diverses URL opaques qui transitent entre le
          client et le serveur, demande à <command>mod_dav_svn</command>
          de les décoder et ensuite met éventuellement son veto à
          certaines requêtes en se basant sur les politiques d'accès
          définies dans un fichier de configuration.</para>

        <para>Si vous avez compilé Subversion à partir du code source,
          <command>mod_authz_svn</command> est automatiquement inclus et
           installé aux côtés de <command>mod_dav_svn</command>. De
           nombreux exécutables distribués l'installent automatiquement
           aussi. Pour vérifier qu'il est installé correctement,
           assurez-vous qu'il vient juste après la directive
           <literal>LoadModule</literal> de <command>mod_dav_svn</command>
           dans le fichier <filename>httpd.conf</filename>&nbsp;:</para>

        <screen>
LoadModule dav_module         modules/mod_dav.so
LoadModule dav_svn_module     modules/mod_dav_svn.so
LoadModule authz_svn_module   modules/mod_authz_svn.so
</screen>

        <para>Pour activer ce module, vous devez configurer votre bloc
          <literal>Location</literal> pour qu'il utilise la directive
          <literal>AuthzSVNAccessFile</literal>&nbsp;; elle spécifie
          quel fichier contient les politiques de contrôle d'accès aux
          chemins de vos dépôts (nous allons étudier le format de ce
          fichier).</para>

        <para>Apache est flexible, vous avez donc la possibilité de
          configurer votre bloc selon une méthode à choisir parmi trois.
          Pour commencer, choisissez une des méthodes de configuration
          de base (les exemples suivants sont très simples&nbsp;;
          reportez-vous à la documentation Apache qui contient beaucoup
          plus de détails sur les options d'authentification et de
          contrôle d'accès d'Apache).</para>

        <para>Le bloc le plus simple consiste à donner l'accès à tout le
          monde. Dans ce scénario, Apache n'envoie jamais de défi
          d'authentification, tous les utilisateurs sont donc traités en
          tant qu'<quote>anonymes</quote> (voir l'<xref
          linkend="svn.serverconfig.httpd.authz.perdir.ex-1"/>).</para>

        <example id="svn.serverconfig.httpd.authz.perdir.ex-1">
          <title>Exemple-type de configuration&nbsp;: accès anonyme</title>
          <programlisting>
&lt;Location /depot&gt;
  DAV svn
  SVNParentPath /var/svn

  # notre politique de contrôle d'accès
  AuthzSVNAccessFile /chemin/vers/fichier/acces
&lt;/Location&gt;
          </programlisting>
        </example>

        <para>À l'opposé sur l'échelle de la paranoïa, vous pouvez
          configurer votre bloc de telle sorte qu'il exige que tout le
          monde s'authentifie. Ici, tous les clients doivent fournir un
          mot de passe pour prouver leur identité. Votre bloc exige
          l'authentification inconditionnelle via la directive
          <literal>Require valid-user</literal> et définit le moyen de
          s'authentifier (voir l'<xref
          linkend="svn.serverconfig.httpd.authz.perdir.ex-2"/>).</para>

        <example id="svn.serverconfig.httpd.authz.perdir.ex-2">
          <title>Exemple-type de configuration&nbsp;: accès authentifié</title>
          <programlisting>
&lt;Location /depot&gt;
  DAV svn
  SVNParentPath /var/svn

  # notre politique de contrôle d'accès
  AuthzSVNAccessFile /chemin/vers/fichier/acces

  # seuls les utilisateurs authentifiés ont accès au dépôt
  Require valid-user

  # comment authentifier un utilisateur
  AuthType Basic
  AuthName "Depot Subversion"
  AuthUserFile /chemin/vers/fichier/utilisateurs
&lt;/Location&gt;
          </programlisting>
        </example>

        <para>Une troisième méthode largement pratiquée consiste à
          autoriser à la fois des accès anonymes et des accès
          authentifiés. Par exemple, de nombreux administrateurs
          désirent autoriser les utilisateurs anonymes à lire certains
          répertoires dans les dépôts mais ne veulent voir que des
          utilisateurs authentifiés accéder en lecture (ou en écriture)
          dans des zones plus sensibles. Dans cette configuration, tous
          les utilisateurs commencent par accéder au dépôt de façon
          anonyme. Si votre politique de contrôle d'accès exige un
          véritable nom d'utilisateur à un moment ou à un autre, Apache
          demandera au client de s'authentifier. Pour ce faire, vous
          devez utiliser à la fois la directive <literal>Satisfy Any</literal>
          et la directive <literal>Require valid-user</literal> (voir
          l'<xref linkend="svn.serverconfig.httpd.authz.perdir.ex-3"/>).</para>

        <example id="svn.serverconfig.httpd.authz.perdir.ex-3">
          <title>Exemple-type de configuration&nbsp;: accès mixte
            authentifié/anonyme</title>
          <programlisting>
&lt;Location /depot&gt;
  DAV svn
  SVNParentPath /var/svn

  # notre politique de contrôle d'accès
  AuthzSVNAccessFile /chemin/vers/fichier/acces

  # essayer d'abord un accès anonyme,
  # ne demander une véritable authentification
  # que si nécessaire
  Satisfy Any
  Require valid-user

  # comment authentifier un utilisateur
  AuthType Basic
  AuthName "Depot Subversion"
  AuthUserFile /chemin/vers/fichier/utilisateurs
&lt;/Location&gt;
          </programlisting>
        </example>

        <para>Une fois l'un de ces modèles mis en place dans votre
          fichier <filename>httpd.conf</filename>, vous devez créer un
          fichier contenant les règles d'accès particulières pour chaque
          chemin de votre dépôt. Nous en parlons plus en détails
          plus loin dans ce chapitre, à <xref
          linkend="svn.serverconfig.pathbasedauthz"/>.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authz.pathauthzoff">
        <title>Désactivation du contrôle sur les chemins</title>

        <para>Le module <command>mod_dav_svn</command> se donne beaucoup
          de peine pour assurer que les données que vous avez désignées
          comme <quote>interdites</quote> ne soient pas divulguées
          accidentellement. Cela veut dire qu'il doit surveiller
          étroitement tous les chemins d'accès et tous les contenus des
          fichiers renvoyés par des commandes telles que <command>svn
          checkout</command> et <command>svn update</command>.
          Si ces commandes tombent sur un chemin qui n'est pas lisible à
          cause d'une politique de contrôle d'accès, le chemin est
          généralement totalement omis. Dans le cas d'une recherche
          d'historique ou de renommage, par exemple une commande
          telle que <userinput>svn cat -r ANCIENNE_REVISION
          truc.c</userinput> sur un fichier qui a été renommé il y a
          longtemps, le suivi des renommages va simplement s'arrêter si
          un des anciens noms de l'objet se révèle être en accès
          restreint en lecture.</para>

        <para>Ces contrôles sur les chemins peuvent parfois être assez
          coûteux, tout particulièrement dans le cas de <command>svn
          log</command>. Quand il demande une liste de révisions, le
          serveur examine chaque chemin modifié dans chaque révision et
          vérifie qu'il a le droit d'être lu. Si un chemin interdit est
          découvert, il est omis de la liste des chemins modifiés par
          la révision (obtenue habituellement par l'option
          <option>--verbose</option>) et le message de propagation est
          entièrement supprimé. Il va sans dire que ceci peut prendre un
          certain temps pour les révisions qui ont touché à un grand
          nombre de fichiers. C'est le coût de la sécurité&nbsp;: même
          si vous n'avez pas du tout configuré de module tel que
          <command>mod_authz_svn</command>, le module
          <command>mod_dav_svn</command> va quand même demander à
          <command>httpd</command>&nbsp;Apache de vérifier les droits d'accès
          pour chaque chemin. Le module <command>mod_dav_svn</command>
          n'est pas au courant de la liste des modules qui ont été
          installés, donc tout ce qu'il peut faire est de demander à
          Apache de lancer n'importe quel contrôle qui soit présent.</para>

        <para>D'un autre côté, il existe une sorte d'échappatoire qui
          vous permet de faire un compromis entre les fonctions de
          sécurité et la vitesse. Si vous ne mettez pas en œuvre de
          contrôle d'accès sur les chemins (c'est-à-dire, si vous
          n'utilisez ni <command>mod_authz_svn</command> ni un module
          similaire), vous pouvez désactiver tous ces contrôles sur les
          chemins. Dans votre fichier <filename>httpd.conf</filename>,
          utilisez la directive <literal>SVNPathAuthz</literal> comme
          illustré dans l'<xref
          linkend="svn.serverconfig.httpd.authz.pathauthzoff.ex-1"/>.
        </para>

        <example id="svn.serverconfig.httpd.authz.pathauthzoff.ex-1">
          <title>Désactiver complètement les contrôles sur les
            chemins</title>
          <programlisting>
&lt;Location /depot&gt;
  DAV svn
  SVNParentPath /var/svn

  SVNPathAuthz off
&lt;/Location&gt;
          </programlisting>
        </example>

        <para>La directive <literal>SVNPathAuthz</literal> est activée
          (<quote>on</quote>) par défaut. Quand on la désactive
          (<quote>off</quote>), tous les contrôles d'accès basés sur les
          chemins sont désactivés&nbsp;; <command>mod_dav_svn</command>
          arrête de contrôler chaque chemin qu'il traite.</para>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.extra">
      <title>Fonctionnalités bonus</title>

      <para>Nous avons traité la plupart des options d'authentification
        et de contrôle d'accès pour Apache et
        <command>mod_dav_svn</command>. Mais Apache fournit quelques
        autres fonctionnalités sympathiques.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.extra.browsing">
        <title>Navigation dans les dépôts</title>

        <para>Un des avantages les plus frappants d'avoir une
          configuration Apache/WebDAV pour votre dépôt Subversion est
          que les révisions les plus récentes de vos fichiers et
          répertoires suivis en versions sont immédiatement consultables
          à l'aide d'un navigateur web classique. Puisque Subversion
          utilise des URL pour identifier les ressources suivies en
          versions, ces URL utilisées pour accéder aux dépôts via HTTP
          peuvent être tapées directement dans un navigateur web. Votre
          navigateur enverra une requête <literal>HTTP GET</literal>
          pour cette URL&nbsp;; selon que cette URL représente ou non
          un fichier ou un répertoire suivi en versions,
          <command>mod_dav_svn</command> renverra soit la liste des
          éléments du répertoire, soit le contenu du fichier.</para>

        <para>Comme les URL ne contiennent pas d'informations concernant
          la version de la ressource qui vous intéresse,
          <command>mod_dav_svn</command> renverra toujours la version la
          plus récente. Cette fonctionnalité a un merveilleux effet
          secondaire&nbsp;: vous pouvez partager avec vos pairs des
          URL&nbsp;Subversion en guise de références à des documents et
          ces URL pointeront toujours vers la dernière version des
          documents. Bien sûr, vous pouvez aussi utiliser ces URL en
          tant que liens hypertextes dans d'autres sites web.</para>

        <sidebar>
          <title>Puis-je consulter d'anciennes révisions&nbsp;?</title>

          <para>Avec un navigateur web classique&nbsp;? En un mot&nbsp;:
            non. Ou, du moins, pas avec <command>mod_dav_svn</command>
            pour seul outil.</para>

          <para>Votre navigateur web ne sait communiquer qu'en langage
            HTTP ordinaire. Ce qui signifie qu'il sait seulement
            obtenir, par requête <literal>GET</literal>, des URL
            publiques, qui représentent les versions les plus récentes
            des fichiers et répertoires. D'après la spécification de
            WebDAV/DeltaV, chaque serveur définit une syntaxe privée
            d'URL pour les anciennes versions des ressources et cette
            syntaxe est incompréhensible pour les clients. Pour obtenir
            une ancienne version d'un fichier, un client doit suivre
            une procédure spécifique pour <quote>découvrir</quote>
            l'URL appropriée&nbsp;; cette procédure nécessite d'envoyer
            une série de requêtes WebDAV <literal>PROPFIND</literal> et
            de comprendre les concepts DeltaV. C'est quelque chose que
            votre navigateur web n'est pas capable de faire.</para>

          <para>Donc, pour répondre à la question, une méthode évidente
            permettant de consulter d'anciennes versions de fichiers et
            de répertoires est de passer l'argument
            <option>--revision</option> (<option>-r</option>) aux
            commandes <command>svn list</command> et <command>svn
            cat</command>. Pour naviguer dans les anciennes révisions
            avec votre navigateur web, vous pouvez utiliser des
            logiciels tiers. Un bon exemple en est ViewVC (<ulink
            url="http://viewvc.tigris.org/"/>). ViewVC a été écrit à
            l'origine dans le but d'afficher des dépôts CVS sur le
            web<footnote>
              <para>A l'époque, il s'appelait ViewCVS.</para>
            </footnote>
            et les dernières versions sont également capables de
            travailler avec les dépôts Subversion.</para>
        </sidebar>

        <sect4 id="svn.serverconfig.httpd.extra.browsing.mimetype">
          <title>Types MIME appropriés</title>

          <para>Quand il consulte un dépôt Subversion, le navigateur web
            obtient un indice pour savoir comment rendre le contenu d'un
            fichier en examinant l'entête
            <literal>Content-Type:</literal> qui fait partie de la
            réponse envoyée par Apache à la requête HTTP
            <literal>GET</literal>. La valeur de cet entête est en
            quelque sorte un type MIME. Par défaut, Apache va indiquer
            aux navigateurs web que tous les fichiers du dépôt sont du
            type MIME par défaut, en général
            <literal>text/plain</literal>. Cela peut s'avérer assez
            frustrant, si un utilisateur désire visualiser les fichiers
            du dépôt de manière plus appropriée &mdash; par exemple,
            un fichier <filename>truc.html</filename> du dépôt sera bien
            plus lisible s'il est rendu dans le navigateur en tant que
            fichier HTML.</para>

          <para>Pour rendre ceci possible, il suffit de vous assurer que
            vos fichiers portent bien la propriété
            <literal>svn:mime-type</literal>. Plus de détails sur ce
            sujet sont disponibles dans <xref
            linkend="svn.advanced.props.special.mime-type"/> et vous
            pouvez même configurer votre dépôt pour qu'il associe
            automatiquement la valeur de <literal>svn:mime-type</literal>
            appropriée aux fichiers qui arrivent dans le dépôt pour la
            première fois&nbsp;; reportez-vous à
            <xref linkend="svn.advanced.props.auto"/>.</para>

          <para>Donc, dans notre exemple, si quelqu'un attribuait la
            valeur <literal>text/html</literal> à la propriété
            <literal>svn:mime-type</literal> du fichier
            <filename>truc.html</filename>, Apache indiquerait avec
            justesse à votre navigateur web de rendre le fichier comme
            une page HTML. On pourrait aussi associer des propriétés
            ayant des valeurs <literal>image/*</literal> appropriées aux
            fichiers d'images et, en fin de compte, faire qu'un site web
            entier soit consultable directement à travers un dépôt&nbsp;!
            Ceci ne pose en général pas de problème, du moment que le
            site web ne possède pas de contenu généré
            dynamiquement.</para>

        </sect4>

        <sect4 id="svn.serverconfig.httpd.extra.browsing.xslt">
          <title>Personnalisation de l'aspect</title>

          <para>En général, vous utiliserez principalement des URL de
            fichiers suivis en versions&nbsp;; après tout c'est là que
            le contenu intéressant réside. Mais vous aurez peut-être
            l'occasion de naviguer dans le contenu d'un répertoire
            Subversion et vous remarquerez rapidement que le code HTML
            généré pour afficher la liste des éléments du répertoire
            est très rudimentaire, et certainement pas conçu pour être
            agréable d'un point de vue esthétique (ni même intéressant).
            Afin d'activer la personnalisation de l'affichage de ces
            répertoires, Subversion fournit une fonctionnalité d'index
            XML. La présence d'une directive
            <literal>SVNIndexXSLT</literal> dans le bloc
            <literal>Location</literal> du fichier
            <filename>httpd.conf</filename> de votre dépôt conduira
            <command>mod_dav_svn</command> à générer un résultat en XML
            quand il affiche la liste des éléments d'un répertoire et à
            faire référence à la feuille de style XSLT de votre
            choix&nbsp;:</para>

        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn
  SVNIndexXSLT "/index-svn.xsl"
  &hellip;
&lt;/Location&gt;
</screen>

         <para>A l'aide de la directive <literal>SVNIndexXSLT</literal>
           et d'une feuille de style XSLT faisant preuve de créativité,
           vous pouvez adapter les listes de contenus de répertoires aux
           schémas de couleur et d'imagerie utilisés dans d'autres
           parties de votre site web. Ou, si vous préférez, vous pouvez
           utiliser les exemples de feuilles de style fournis dans le
           répertoire <filename>tools/xslt/</filename> du code source de
           Subversion. Gardez à l'esprit que le chemin d'accès fourni au
           répertoire <literal>SVNIndexXSLT</literal> est en fait une
           URL &mdash; les navigateurs de chemins doivent être
           capables de lire vos feuilles de style pour les
           utiliser&nbsp;!</para>

         </sect4>

        <sect4 id="svn.serverconfig.httpd.extra.browsing.reposlisting">
          <title>Affichage de la liste des dépôts</title>

          <para>Si vous desservez un ensemble de dépôts à partir d'une
            URL unique via la directive <literal>SVNParentPath</literal>,
            il est possible de faire afficher par Apache tous les dépôts
            disponibles dans un navigateur web. Il suffit d'activer la
            directive <literal>SVNListParentPath</literal>&nbsp;:</para>

          <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn
  SVNListParentPath on
  &hellip;
&lt;/Location&gt;
</screen>

          <para>Si un utilisateur pointe son navigateur web à l'URL
            <literal>http://hote.exemple.com/svn/</literal>, il verra
            une liste de tous les dépôts Subversion situés dans
            <filename>/var/svn</filename>. Évidemment, ceci peut poser
            des problèmes de sécurité&nbsp;; cette fonctionnalité est
            donc désactivée par défaut.</para>

        </sect4>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.extra.logging">
        <title>Journalisation Apache</title>

        <para>Comme Apache est avant tout un serveur HTTP, il contient
          des fonctionnalités de journalisation d'une flexibilité
          fantastique. Détailler toutes les façons dont la
          journalisation peut être configurée sort du cadre de ce livre,
          mais nous voulons quand même vous faire remarquer que même le
          fichier <filename>httpd.conf</filename> le plus générique
          conduit Apache à créer deux fichiers de journalisation&nbsp;:
          <filename>error_log</filename>
          et <filename>access_log</filename>. Ces journaux peuvent
          apparaître à différents endroits, mais sont en général créés
          dans la zone de journalisation de votre installation Apache
          (sur Unix, ils résident souvent dans
          <filename>/usr/local/apache2/logs/</filename>).</para>

        <para>Le fichier <filename>error_log</filename> décrit toutes
          les erreurs internes qu'Apache rencontre au cours de son
          fonctionnement. Le fichier <filename>access_log</filename>
          enregistre toutes les requêtes HTTP reçues par Apache. Ceci
          permet de voir facilement, par exemple, de quelles adresses IP
          les clients Subversion se connectent, à quelle fréquence un
          client donné utilise le serveur, quels utilisateurs se sont
          authentifiés correctement et quelles requêtes ont échoué ou
          réussi.</para>

        <para>Malheureusement, parce qu'HTTP est un protocole sans
          notion d'état, même la plus simple opération du client
          Subversion génère plusieurs requêtes réseau. Il est donc très
          difficile d'examiner le fichier <filename>access_log</filename>
          et d'en déduire ce que le client faisait &mdash; la plupart
          des opérations se présentent sous la forme de séries de
          requêtes <literal>PROPPATCH</literal>, <literal>GET</literal>,
          <literal>PUT</literal> et <literal>REPORT</literal>
          énigmatiques. Pour couronner le tout, de nombreuses opérations
          du client envoient des séries de requêtes quasi-identiques, il
          est donc encore plus difficile de les distinguer.</para>

        <para>Cependant, <command>mod_dav_svn</command> peut venir à
          votre rescousse. En activant la fonctionnalité de
          <quote>journalisation opérationnelle</quote>, vous pouvez
          demander à <command>mod_dav_svn</command> de créer un fichier
          séparé décrivant quelles sortes d'opérations de haut niveau
          vos clients effectuent.</para>

        <para>Pour ce faire, vous devez utiliser la directive
          <literal>CustomLog</literal> d'Apache (qui est expliquée en
          détail dans la documentation Apache). Prenez soin de placer
          cette directive <emphasis>en dehors</emphasis> de votre bloc
          <literal>Location</literal> de Subversion&nbsp;:</para>

        <screen>
&lt;Location /svn&gt;
  DAV svn
  &hellip;
&lt;/Location&gt;

CustomLog logs/journal-svn "%t %u %{SVN-ACTION}e" env=SVN-ACTION
</screen>

        <para>Dans cet exemple, nous demandons à Apache de créer un
          fichier journal spécial, <filename>journal-svn</filename>,
          dans le répertoire habituel de journaux d'Apache
          (<filename>logs</filename>). Les variables
          <literal>%t</literal> et <literal>%u</literal> sont remplacées
          par l'horodatage et le nom d'utilisateur de la requête,
          respectivement. Les points importants sont les deux instances
          de <literal>SVN-ACTION</literal>. Quand Apache trouve cette
          variable, il lui substitue la valeur de la variable
          d'environnement <literal>SVN-ACTION</literal>, modifiée
          automatiquement par <command>mod_dav_svn</command>
          quand il détecte une action haut-niveau du client.</para>

        <para>Ainsi, au lieu d'avoir à interpréter un fichier
          <filename>access_log</filename> traditionnel qui ressemble
          à&nbsp;:</para>

        <screen>
[26/Jan/2007:22:25:29 -0600] "PROPFIND /svn/calc/!svn/vcc/default HTTP/1.1" 207 398
[26/Jan/2007:22:25:29 -0600] "PROPFIND /svn/calc/!svn/bln/59 HTTP/1.1" 207 449
[26/Jan/2007:22:25:29 -0600] "PROPFIND /svn/calc HTTP/1.1" 207 647
[26/Jan/2007:22:25:29 -0600] "REPORT /svn/calc/!svn/vcc/default HTTP/1.1" 200 607
[26/Jan/2007:22:25:31 -0600] "OPTIONS /svn/calc HTTP/1.1" 200 188
[26/Jan/2007:22:25:31 -0600] "MKACTIVITY /svn/calc/!svn/act/e6035ef7-5df0-4ac0-b811-4be7c823f998 HTTP/1.1" 201 227
&hellip;
</screen>

        <para>vous pouvez vous contenter de parcourir le fichier
          <filename>journal-svn</filename> qui est bien plus
          intelligible&nbsp;:</para>

        <screen>
[26/Jan/2007:22:24:20 -0600] - get-dir /tags r1729 props
[26/Jan/2007:22:24:27 -0600] - update /trunk r1729 depth=infinity send-copyfrom-args
[26/Jan/2007:22:25:29 -0600] - status /trunk/machin r1729 depth=infinity
[26/Jan/2007:22:25:31 -0600] sally commit r1730
</screen>

        <para>Pour une liste exhaustive de toutes les actions
          journalisées, reportez-vous à <xref
          linkend="svn.ref.mod_dav_svn.conf.logging"/>.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.extra.writethruproxy">
        <title>Mandataire en écriture</title>

        <para>Un des avantages notables d'Apache comme serveur
          Subversion est qu'il peut être configuré pour effectuer de la
          réplication. Par exemple, imaginez que votre équipe soit
          répartie sur quatre sites dans différents coins du globe. Le
          dépôt Subversion ne peut exister que sur un de ces sites, ce
          qui signifie que les trois autres sites n'auront pas un accès
          très satisfaisant &mdash; ils devront sans doute faire avec
          un trafic plus lent et des temps de réponse plus longs lors
          des mises à jour et des propagations. Une solution très
          puissante est de mettre en place un système constitué d'un
          serveur Apache&nbsp;<firstterm>maître</firstterm> et de plusieurs
          serveurs Apache&nbsp;<firstterm>esclaves</firstterm>. Si vous
          placez un serveur esclave sur chacun des sites, les
          utilisateurs peuvent extraire une copie de travail de
          l'esclave qui est le plus proche d'eux. Toutes les requêtes
          de lecture vont au serveur esclave local. Les requêtes
          d'écriture sont automatiquement routées vers l'unique
          serveur maître. Lorsque la propagation se termine, le maître
          <quote>pousse</quote> la nouvelle révision vers chaque serveur
          esclave en utilisant l'outil de réplication
          <command>svnsync</command>.</para>

        <para>Cette configuration permet une immense amélioration de la
          vitesse perçue par les utilisateurs, car le trafic d'un client
          Subversion est généralement constitué à 80&nbsp;-&nbsp;90&nbsp;%
          de requêtes de lecture. Et ces requêtes étant traitées par
          un serveur <emphasis>local</emphasis>, le gain est énorme.</para>

        <para>Dans ce paragraphe, nous vous accompagnons dans la mise en
          place standard de ce système comportant un maître unique et
          plusieurs esclaves. Cependant, gardez à l'esprit que vos
          serveurs doivent faire tourner au moins Apache&nbsp;2.2.0
          (avec le module <command>mod_proxy</command> chargé) et
          Subversion&nbsp;1.5 (<command>mod_dav_svn</command>).</para>

        <sect4 id="svn.serverconfig.httpd.extra.writethruproxy.configure">
          <title>Configuration des serveurs</title>

          <para>Pour commencer, configurez le fichier
            <filename>httpd.conf</filename> de votre serveur maître de
            la façon habituelle. Mettez le dépôt à disposition à un
            certain emplacement URI et configurez l'authentification
            ainsi que le contrôle d'accès comme vous le souhaitez. Une
            fois que c'est fait, configurez chacun de vos serveurs
            <quote>esclaves</quote> exactement de la même manière, mais
            ajoutez la directive <literal>SVNMasterURI</literal> au
            bloc&nbsp;:</para>

          <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNPath /var/svn/depot
  SVNMasterURI http://maitre.exemple.com/svn
  &hellip;
&lt;/Location&gt;
</screen>

          <para>Cette nouvelle directive indique à un serveur esclave de
            rediriger toutes les requêtes d'écriture vers le maître (ce
            qui est accompli automatiquement par le module
            <command>mod_proxy</command> d'Apache). Les requêtes
            ordinaires de lecture, cependant, sont toujours traitées par
            les esclaves. Assurez-vous que vos serveurs maître et
            esclaves ont tous des configurations identiques
            d'authentification et de contrôle d'accès&nbsp;; s'ils ne
            peuvent plus se synchroniser, cela peut engendrer
            beaucoup d'ennuis.</para>

          <para>Ensuite nous devons nous occuper du problème de la
            récursion infinie. Avec la configuration actuelle, imaginez
            ce qui se va se passer quand un client Subversion va
            effectuer une propagation vers le serveur maître. Une fois
            la propagation terminée, le serveur utilise
            <command>svnsync</command> pour répliquer la nouvelle
            révision vers chaque esclave. Mais comme
            <command>svnsync</command> ne se présente que comme un
            simple client en train d'effectuer une propagation,
            l'esclave va immédiatement tenter d'envoyer vers le maître
            la requête d'écriture qui vient d'arriver&nbsp;! Et là,
            patatras&nbsp;!</para>

          <para>La solution consiste à s'arranger pour que le maître
            pousse les révisions vers un emplacement
            <literal>&lt;Location&gt;</literal> distinct au sein des
            dépôts esclaves. Cet emplacement est configuré
            <emphasis>non pas pour servir de mandataire</emphasis> pour
            les requêtes d'écriture mais pour accepter les propagations
            normales en provenance de l'adresse IP du maître (et
            seulement de lui)&nbsp;:</para>

          <screen>
&lt;Location /svn-proxy-sync&gt;
  DAV svn
  SVNPath /var/svn/depot
  Order deny,allow
  Deny from all
  # Ne laisse que le serveur ayant l'adresse indiquée accéder à cet emplacement :
  Allow from 10.20.30.40
  &hellip;
&lt;/Location&gt;
</screen>

        </sect4>

        <sect4 id="svn.serverconfig.httpd.extra.writethruproxy.replicate">
          <title>Mise en place de la réplication</title>

          <para>Une fois que vous avez configuré les blocs
            <literal>Location</literal> du maître et des esclaves, vous
            devez configurer le maître pour que la réplication vers les
            esclaves fonctionne. Ceci se fait de la manière habituelle,
            en utilisant <command>svnsync</command>. Si vous n'êtes pas
            familier avec cet outil, reportez-vous à <xref
            linkend="svn.reposadmin.maint.replication"/> pour plus de
            détails.</para>

          <para>Tout d'abord, assurez-vous que chaque dépôt esclave a
            une procédure automatique
            <filename>pre-revprop-change</filename> qui autorise les
            modifications de propriétés de révisions à distance (cette
            étape fait partie de la procédure standard pour un serveur
            qui reçoit les révisions de <command>svnsync</command>).
            Ensuite, connectez-vous au serveur maître et configurez
            l'URI de chaque dépôt esclave pour qu'il reçoive les données
            en provenance du dépôt maître sur le disque local&nbsp;:</para>

          <screen>
$ svnsync init http://esclave1.exemple.com/svn-proxy-sync file://var/svn/depot
Propriétés copiées pour la révision 0.
$ svnsync init http://esclave2.exemple.com/svn-proxy-sync file://var/svn/depot
Propriétés copiées pour la révision 0.
$ svnsync init http://esclave3.exemple.com/svn-proxy-sync file://var/svn/depot
Propriétés copiées pour la révision 0.

# Effectue la réplication initiale

$ svnsync sync http://esclave1.exemple.com/svn-proxy-sync
Transmission des données ........................................
Révision 1 propagée.
Propriétés copiées pour la révision 1.
Transmission des données ..
Révision 2 propagée.
Propriétés copiées pour la révision 2.
&hellip;

$ svnsync sync http://esclave2.exemple.com/svn-proxy-sync
Transmission des données ........................................
Révision 1 propagée.
Propriétés copiées pour la révision 1.
Transmission des données ..
Révision 2 propagée.
Propriétés copiées pour la révision 2.
&hellip;

$ svnsync sync http://esclave3.exemple.com/svn-proxy-sync
Transmission des données ........................................
Révision 1 propagée.
Propriétés copiées pour la révision 1.
Transmission des données ..
Révision 2 propagée.
Propriétés copiées pour la révision 2.
&hellip;
</screen>

          <para>Une fois que c'est fait, nous configurons la procédure
            automatique post-propagation (<literal>post-commit</literal>)
            du serveur maître pour qu'elle lance
            <command>svnsync</command> sur chaque serveur esclave&nbsp;:</para>

          <programlisting>
#!/bin/sh
# Procédure post-propagation pour répliquer les révisions nouvellement propagées vers les esclaves

svnsync sync http://esclave1.exemple.com/svn-proxy-sync &gt; /dev/null 2&gt;&amp;1
svnsync sync http://esclave2.exemple.com/svn-proxy-sync &gt; /dev/null 2&gt;&amp;1
svnsync sync http://esclave3.exemple.com/svn-proxy-sync &gt; /dev/null 2&gt;&amp;1
</programlisting>

          <para>Les symboles en plus à la fin de chaque ligne ne sont
            pas nécessaires, mais constituent un moyen astucieux
            d'autoriser <command>svnsync</command> à lancer des
            commandes qui fonctionneront à l'arrière-plan, de telle
            sorte que le client Subversion ne se retrouvera pas à
            attendre indéfiniment que la propagation se termine. En
            plus de cette procédure post-propagation
            (<literal>post-commit</literal>), vous aurez également
            besoin d'une procédure <literal>post-revprop-change</literal>
            pour que, disons, quand un utilisateur modifie un message de
            propagation, les serveurs esclaves reçoivent aussi cette
            modification&nbsp;:</para>

          <programlisting>
#!/bin/sh
# Procédure post-revprop-change pour répliquer les modifications
# des propriétés de révisions vers les esclaves

REV=${2}
svnsync copy-revprops http://esclave1.exemple.com/svn-proxy-sync ${REV} &gt; /dev/null 2&gt;&amp;1
svnsync copy-revprops http://esclave2.exemple.com/svn-proxy-sync ${REV} &gt; /dev/null 2&gt;&amp;1
svnsync copy-revprops http://esclave3.exemple.com/svn-proxy-sync ${REV} &gt; /dev/null 2&gt;&amp;1
</programlisting>

          <para>La seule chose que nous n'avons pas détaillé concerne
            les verrous. Comme les verrous sont gérés strictement par le
            serveur maître (le seul endroit où des propagations ont
            lieu), nous n'avons en théorie pas besoin de faire quoi que
            ce soit. De nombreuses équipes n'utilisent pas du tout les
            fonctionnalités de verrouillage de Subversion, il s'agit
            donc peut-être pour vous d'un faux problème. Cependant, si
            les modifications de verrous ne sont pas répliquées du
            maître vers les esclaves, cela signifie que les clients ne
            seront pas capables d'interroger l'état des verrous (par
            exemple, <userinput>svn status -u</userinput> ne donne
            aucune information sur les verrous du dépôt). Si cela vous
            embête, vous pouvez écrire des procédures automatiques
            <literal>post-lock</literal> et
            <literal>post-unlock</literal> qui lancent
            <command>svn lock</command> et <command>svn
            unlock</command> sur les serveurs esclaves,
            vraisemblablement à l'aide d'une méthode de connexion à
            distance telle que SSH. Nous laissons ceci au lecteur
            en guise d'exercice&nbsp;!</para>

        </sect4>

        <sect4 id="svn.serverconfig.httpd.extra.writethruproxy.caveats">
          <title>Pièges à éviter</title>

          <para>Votre système de réplication maître/esclave doit à
            présent être prêt à l'emploi. Cependant, quelques consignes
            de prudence sont de mise. Souvenez-vous que la réplication
            n'est pas totalement robuste en ce qui concerne les
            plantages machine ou réseau. Par exemple, si l'une des
            commandes <command>svnsync</command> automatisées demeure
            inachevée, pour quelque raison que ce soit, les esclaves
            vont commencer à être décalés. Par exemple, vos utilisateurs
            distants verront qu'ils ont propagé la révision&nbsp;100,
            mais quand ils exécuteront <command>svn update</command>,
            leur serveur local leur indiquera que la révision&nbsp;100
            n'existe pas encore&nbsp;! Bien sûr, le problème se réglera
            automatiquement dès qu'une autre propagation aura lieu et
            que la commande <command>svnsync</command> qui s'ensuit aura
            fonctionné &mdash; cette synchronisation répliquera toutes
            les révisions en attente. Néanmoins, vous pouvez décider de
            mettre en place une surveillance des décalages, vérifiant le
            bon fonctionnement de la synchronisation et qui, en cas de
            problème, déclenche une nouvelle exécution de
            <command>svnsync</command>.</para>

          <sidebar>
            <title>Pouvons-nous mettre en place la réplication avec
              svnserve&nbsp;?</title>

            <para>Si vous utilisez <command>svnserve</command> au lieu
              d'Apache comme serveur, vous pouvez tout à fait configurer
              les procédures automatiques de votre dépôt pour qu'elles
              lancent <command>svnsync</command> comme nous l'avons
              expliqué ici, lançant ainsi la réplication automatique du
              maître vers les esclaves. Malheureusement, à l'heure où
              nous écrivons ces lignes, il n'y a pas moyen de s'assurer
              que des serveurs esclaves <command>svnserve</command>
              envoient automatiquement les requêtes d'écriture vers le
              serveur maître. Cela veut dire que vos utilisateurs ne
              pourraient pas extraire des copies de travail en lecture
              seule des serveurs esclaves. Il vous faudrait configurer
              vos serveurs esclaves pour qu'ils refusent complètement
              tout accès en écriture. Cela peut être utile pour créer
              des <quote>miroirs</quote> en lecture seule de projets
              open source populaires, mais il ne s'agit alors plus d'un
              système de mandataire d'écriture transparent.</para> </sidebar>

        </sect4>

        </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.extra.other">
        <title>Autres fonctionnalités d'Apache</title>

        <para>Il y a également plusieurs fonctionnalités fournies par
          Apache, en tant que serveur web robuste, dont on peut tirer
          profit pour améliorer les fonctionnalités ou la sécurité de
          Subversion. Le client Subversion est capable d'utiliser SSL
          (Secure Socket Layer, le protocole de sécurisation des
          échanges sur internet, présenté auparavant). Si votre client
          Subversion a été compilé en incluant le support de SSL, il
          peut accéder à votre serveur Apache en utilisant des URL
          <literal>https://</literal> et bénéficier d'une session réseau
          avec un chiffrement de grande qualité.</para>

        <para>D'autres fonctionnalités de la relation Apache/Subversion
          sont également tout aussi utiles, comme par exemple la
          possibilité de spécifier un port personnalisé (au lieu du port
          HTTP par défaut, 80) ou un nom de domaine virtuel par lequel
          accéder au dépôt Subversion ou la possibilité d'accéder au
          dépôt via un serveur mandataire HTTP.</para>

        <para>Enfin, comme <command>mod_dav_svn</command> se sert d'un
          sous-ensemble du protocole WebDAV/DeltaV pour communiquer, il
          est possible d'accéder au dépôt depuis des clients DAV tiers.
          La possibilité de monter un serveur DAV en tant que
          <quote>dossier partagé</quote> réseau standard est intégrée
          dans la plupart des systèmes d'exploitation modernes (Win32,
          OS X et Linux). C'est un sujet compliqué, mais merveilleux
          une fois mis en place. Pour plus de détails, consultez l'<xref
          linkend="svn.webdav"/>.</para>

        <para>Notez qu'il y a un certain nombre d'autres petits
          <quote>bricolages</quote> que l'on peut faire autour de
          <command>mod_dav_svn</command> qui sont trop obscurs pour être
          mentionnés dans ce chapitre. Pour voir la liste complète de
          toutes les directives <filename>httpd.conf</filename>
          auxquelles <command>mod_dav_svn</command> obéit, reportez-vous
          à <xref linkend="svn.ref.mod_dav_svn.conf.directives"/>.</para>

      </sect3>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.pathbasedauthz">

    <title>Contrôle d'accès basé sur les chemins</title>

    <para>Apache et <command>svnserve</command> sont tous deux capables
      d'accorder ou de refuser l'accès aux utilisateurs. Généralement
      c'est géré globalement au niveau du dépôt&nbsp;: un utilisateur
      peut accéder (ou pas) au dépôt en lecture et il peut accéder
      (ou pas) au dépôt en écriture. Il est pourtant aussi possible de
      définir des règles d'accès possédant une granularité plus fine.
      Un ensemble d'utilisateurs peut alors obtenir le droit d'écrire
      dans certains répertoires du dépôt mais pas dans d'autres&nbsp;;
      parallèlement, un autre répertoire peut très bien ne pas être
      accessible en lecture pour la majorité des utilisateurs.</para>

    <para>Les deux types de serveurs utilisent un format de fichier
      commun pour décrire les règles d'accès basées sur les chemins.
      Dans le cas d'Apache, il faut charger le module
      <command>mod_authz_svn</command> puis ajouter la directive
      <literal>AuthzSVNAccessFile</literal> (dans le fichier
      <filename>httpd.conf</filename>) pointant vers votre propre
      fichier de règles (pour l'explication complète, voir <xref
      linkend="svn.serverconfig.httpd.authz.perdir"/>). Si vous utilisez
      <command>svnserve</command>, vous devez faire pointer la variable
      <literal>authz-db</literal> (dans le fichier
      <filename>svnserve.conf</filename>) vers votre fichier de
      règles.</para>

    <sidebar>
      <title>Avez-vous vraiment besoin d'un contrôle d'accès basé sur
        les chemins&nbsp;?</title>

      <para>De nombreux administrateurs qui mettent en place Subversion
        pour la première fois ont tendance à se lancer dans le contrôle
        d'accès basé sur les chemins sans trop y réfléchir.
        L'administrateur sait en général quelles équipes travaillent sur
        quel projet, il est dès lors facile de démarrer en accordant
        l'accès pour certains répertoires à certaines équipes et pas à
        d'autres. Ceci peut sembler assez naturel, et assouvir le désir
        de l'administrateur de contrôler le dépôt de très près.</para>

      <para>Notez cependant qu'il y a souvent des coûts invisibles (et
        visibles&nbsp;!) associés à cette fonctionnalité. Dans la
        catégorie visible, le serveur doit faire beaucoup de travail
        pour s'assurer que l'utilisateur a le droit de lire ou d'écrire
        sur chaque chemin spécifié&nbsp;; dans certaines situations, il
        y a une chute très significative des performances. Dans la
        catégorie invisible, réfléchissez à la culture que vous créez.
        La plupart du temps, même si certains utilisateurs ne devraient
        pas propager de modifications dans certaines parties du dépôt,
        ce contrat social n'a pas besoin de solution technologique pour
        être respecté. Les équipes peuvent parfois collaborer
        spontanément entre elles&nbsp;; quelqu'un peut vouloir aider
        quelqu'un d'autre en effectuant une propagation dans une zone
        qui n'est pas celle où il travaille habituellement. En
        interdisant ce genre de choses au niveau du serveur, vous mettez
        en place une barrière à la collaboration. Vous créez aussi tout
        un tas de règles qui doivent être gérées au fur et à mesure que
        les projets se développent, que de nouveaux utilisateurs sont
        ajoutés,&nbsp;etc. C'est une quantité de travail supplémentaire à
        fournir.</para>

        <para>Souvenez-vous que c'est un système de gestion de
          versions&nbsp;! Même si quelqu'un propageait accidentellement
          une modification là où il n'aurait pas du, revenir en arrière
          reste très facile. Et si un utilisateur propage au mauvais
          endroit de façon intentionnelle, c'est un problème social qui
          doit être réglé, de toute manière, en dehors de
          Subversion.</para>

      <para>Bref, avant que vous ne commenciez à restreindre les droits
        d'accès des utilisateurs, demandez-vous si cela correspond à un
        véritable besoin ou si c'est juste quelque chose qui
        <quote>plaît</quote> à l'administrateur. Demandez-vous si ça
        vaut la peine de sacrifier de la vitesse côté serveur et
        souvenez-vous que les risques associés sont très minimes&nbsp;;
        ce n'est pas une bonne idée d'attendre de la technologie qu'elle
        résolve les problèmes sociaux<footnote>
          <para>Un thème récurrent dans ce livre&nbsp;!</para>
        </footnote>.
      </para>

      <para>En guise d'exemple à méditer, prenez le cas du projet
        Subversion lui-même, au sein duquel il a toujours été clairement
        défini quel utilisateur avait le droit d'effectuer des
        propagations à quel endroit, règles qui ont toujours été
        appliquées socialement. C'est un bon modèle de confiance dans
        la communauté, en particulier pour les projets open source.
        Bien sûr, il peut parfois y avoir de véritables besoins
        légitimant un contrôle d'accès basé sur les chemins&nbsp;; dans
        les grandes entreprises, par exemple, certaines données
        <emphasis>sont</emphasis> sensibles et l'accès à ces données
        doit vraiment être restreint à un petit groupe de personnes.</para>

    </sidebar>

    <para>Une fois que votre serveur sait où trouver votre fichier de
      règles, il est temps de définir ces règles.</para>

    <para>La syntaxe du fichier est la même syntaxe que celle utilisée
      dans <filename>svnserve.conf</filename> et dans les fichiers de
      configuration. Les lignes commençant par un dièse
      (<literal>#</literal>) sont ignorées. Dans la forme la plus
      simple, chaque section désigne un dépôt et un chemin
      à l'intérieur de celui-ci et les noms d'utilisateurs
      authentifiés sont les noms des options à
      l'intérieur de chaque section. La valeur de chaque option décrit
      le niveau d'accès de l'utilisateur au chemin du dépôt&nbsp;:
      soit <literal>r</literal> (lecture seule),
      soit <literal>rw</literal> (lecture/écriture).
      Si l'utilisateur ne figure pas dans la
      section, l'accès n'est pas autorisé.</para>

    <para>Plus précisément, la valeur des noms de section est soit de la
      forme <literal>[nom-du-depot:chemin]</literal>, soit de la forme
      <literal>[chemin]</literal>. Si vous utilisez la directive
      <literal>SVNParentPath</literal>, il est important de
      spécifier les noms des dépôts dans vos sections. Si vous les
      omettez, une section telle que
      <literal>[/un/repertoire]</literal> correspondra au chemin
      <filename>/un/repertoire</filename> de <emphasis>tous les
      dépôts</emphasis>. Cependant, si vous utilisez la directive
      <literal>SVNPath</literal>, ne définir que des chemins dans vos
      sections est acceptable &mdash; après tout, il n'y a qu'un seul
      dépôt.</para>

    <screen>
[calc:/branches/calc/bogue-142]
harry = rw
sally = r
</screen>

    <para>Dans ce premier exemple, l'utilisateur <literal>harry</literal>
      a les droits d'accès complets en lecture/écriture au répertoire
      <filename>/branches/calc/bogue-142</filename> du dépôt
      <literal>calc</literal>, alors que l'utilisateur
      <literal>sally</literal> n'a que l'accès en lecture. Tous les
      autres utilisateurs sont bloqués et ne peuvent pas accéder à ce
      répertoire.</para>

    <para>Bien évidemment, les droits d'accès sont hérités d'un
      répertoire parent à ses fils. Ce qui signifie que nous pouvons
      spécifier un sous-répertoire avec une politique d'accès différente
      pour Sally&nbsp;:</para>

    <screen>
[calc:/branches/calc/bogue-142]
harry = rw
sally = r

# donne à sally les droits d'écriture sur le sous-répertoire "test"
[calc:/branches/calc/bogue-142/test]
sally = rw
</screen>

    <para>Maintenant Sally peut écrire dans le sous-répertoire
      <filename>test</filename> de la branche, mais ne peut toujours que
      lire les autres parties. Harry, en attendant, continue à avoir les
      droits d'accès complets en lecture écriture sur toute la
      branche.</para>

    <para>Il est aussi possible d'interdire explicitement l'accès à
      quelqu'un grâce aux règles d'héritage, en attribuant la valeur
      vide à un nom d'utilisateur&nbsp;:</para>

    <screen>
[calc:/branches/calc/bogue-142]
harry = rw
sally = r

[calc:/branches/calc/bogue-142/secret]
harry =
</screen>

    <para>Dans cet exemple, Harry a les droits de lecture/écriture sur
      l'arborescence <filename>bogue-142</filename> toute entière, mais
      n'a absolument pas accès au répertoire <filename>secret</filename>
      contenu dans celle-ci.</para>

    <tip>
      <para>Ce qu'il faut retenir est que le chemin le plus spécifique
        est choisi en premier. Le serveur tente de trouver une
        correspondance avec le chemin lui-même, puis avec son chemin
        parent, puis avec le parent du parent,&nbsp;etc. Le résultat est que
        tout chemin spécifié dans le fichier des accès prendra le pas
        sur les droits hérités de ses répertoires parents.</para>
    </tip>

    <para>Par défaut, personne n'a accès au dépôt. Cela signifie que si
      vous démarrez avec un fichier vide, vous voudrez probablement au
      moins donner les droits de lecture sur la racine du dépôt à tous
      les utilisateurs. Vous pouvez accomplir ceci en utilisant la
      variable astérisque (<literal>*</literal>), qui désigne
      <quote>tous les utilisateurs</quote>&nbsp;:</para>

    <screen>
[/]
* = r
</screen>

    <para>C'est une configuration très répandue&nbsp;; notez qu'aucun
      nom de dépôt n'est mentionné dans le nom de la section. Ceci rend
      tous les dépôts accessibles en lecture à tous les utilisateurs.
      Une fois que tous les utilisateurs ont l'accès en lecture aux
      dépôts, vous pouvez accorder des droits d'écriture
      (<literal>rw</literal>) explicites à certains utilisateurs sur des
      sous-répertoires spécifiques à l'intérieur de dépôts spécifiques.</para>

    <para>La variable astérisque (<literal>*</literal>) a aussi ceci de
      spécial qu'elle est le <emphasis>seul</emphasis> symbole qui
      puisse correspondre à un utilisateur anonyme. Si vous avez
      configuré votre serveur pour qu'il autorise un mélange d'accès
      anonymes et authentifiés, tous les utilisateurs peuvent commencer
      à y accéder anonymement. Le serveur cherche une valeur
      <literal>*</literal> définie pour le chemin d'accès demandé&nbsp;;
      s'il n'en trouve pas, il demande au client de s'authentifier.</para>

    <para>Le fichier des accès vous permet aussi de définir des groupes
      entiers d'utilisateurs, à la façon du fichier Unix
      <filename>/etc/group</filename>&nbsp;:</para>

    <screen>
[groups]
developpeurs-calc = harry, sally, joe
developpeurs-paint = frank, sally, jane
tout-le-monde = harry, sally, joe, frank, sally, jane
</screen>

    <para>Les droits d'accès peuvent être accordés aux groupes de la
      même façon qu'à de simples utilisateurs. Il faut juste les mettre
      en évidence par le préfixe <quote>at</quote>
      (<literal>@</literal>)&nbsp;:</para>

    <screen>
[calc:/projets/calc]
@developpeurs-calc = rw

[paint:/projets/paint]
jane = r
@developpeurs-paint = rw
</screen>

    <para>Un autre fait notable est que la première règle vérifiée est
      celle qui sera appliquée à l'utilisateur. Dans l'exemple
      précédent, même si <literal>jane</literal> est membre du groupe
       <literal>développeurs-paint</literal> (qui a les droits de
       lecture/écriture), la règle <literal>jane = r</literal> sera lue
       et vérifiée avant la règle du groupe, refusant ainsi à Jane
       l'accès en écriture. </para>

    <para>Les groupes peuvent aussi contenir d'autres groupes&nbsp;:</para>

    <screen>
[groups]
developpeurs-calc = harry, sally, joe
developpeurs-paint = frank, sally, jane
tout-le-monde = @developpeurs-calc, @developpeurs-paint
</screen>

    <para>Subversion 1.5 introduit une autre fonctionnalité utile pour
      la syntaxe du fichier des accès&nbsp;: les alias. Certains systèmes
      d'authentification attendent et utilisent des noms d'utilisateurs
      relativement courts tels que ceux que nous avons décrits ici
      &mdash; <literal>harry</literal>,
      <literal>sally</literal>, <literal>joe</literal>,&nbsp;etc. Mais
      d'autres systèmes d'authentification, comme par exemple ceux qui
      utilisent des bases LDAP ou des certificats clients SSL, peuvent
      utiliser des noms d'utilisateurs beaucoup plus complexes. Par
      exemple, le nom d'utilisateur d'Harry dans un système protégé par
      LDAP pourrait très bien être&nbsp;: <literal>CN=Harold
      Hacker,OU=Engineers,DC=red-bean,DC=com</literal>. Avec des noms
      d'utilisateurs de ce type, le fichier des accès devient
      rapidement illisible, avec des noms d'utilisateurs longs ou
      obscurs qui peuvent facilement être mal orthographiés.
      Heureusement, les alias vous permettent de n'avoir à taper le nom
      d'utilisateur complexe entier qu'une seule fois, au sein d'un
      paragraphe qui lui attribue un alias bien plus digeste.</para>

    <screen>
[aliases]
harry = CN=Harold Hacker,OU=Engineers,DC=red-bean,DC=com
sally = CN=Sally Swatterbug,OU=Engineers,DC=red-bean,DC=com
joe = CN=Gerald I. Joseph,OU=Engineers,DC=red-bean,DC=com
&hellip;
</screen>

    <para>Une fois défini votre ensemble d'alias, vous pouvez faire
      référence à ces utilisateurs en d'autres endroits du fichier par
      leurs alias, partout là où vous auriez sinon entré leur
      véritables noms d'utilisateurs. Il faut juste ajouter une
      esperluette (<literal>&amp;</literal>) juste avant l'alias pour le
      distinguer des noms d'utilisateurs classiques&nbsp;:</para>

    <screen>
[groups]
developpeurs-calc = &amp;harry, &amp;sally, &amp;joe
developpeurs-paint = &amp;frank, &amp;sally, &amp;jane
tout-le-monde = @developpeurs-calc, @developpeurs-paint

</screen>

    <para>Vous pouvez aussi choisir d'utiliser des alias si les noms de
      vos utilisateurs changent souvent. Ainsi vous n'aurez que la table
      des alias à mettre à jour quand des modifications de noms
      d'utilisateurs auront lieu, au lieu d'avoir à effectuer des
      opérations de recherches-et-remplacements-globaux sur la totalité
      du fichier.</para>

  <!-- TODO(sussman): Once serf becomes officially support, this
       sidebar will need to be revisited. -->

  <sidebar>
    <title>Accès partiel en lecture et extractions</title>

    <para>Si vous utilisez Apache en tant que serveur Subversion et que
      vous avez rendu certains sous-répertoires de votre dépôt
      inaccessibles en lecture à certains utilisateurs, vous devez être
      au courant d'un comportement potentiellement non-optimal de la
      commande <command>svn checkout</command>.</para>

    <para>Quand le client lance une requête de mise à jour ou
      d'extraction via HTTP, il envoie une requête unique au serveur et
      reçoit du serveur une réponse unique (dont la taille peut être
      assez importante). Quand le serveur reçoit la requête, c'est la
      <emphasis>seule</emphasis> opportunité dont dispose Apache pour
      demander à l'utilisateur de s'authentifier. Ceci a des effets
      secondaires assez étonnants. Par exemple, si un certain sous-répertoire du
      dépôt n'est accessible en lecture qu'à l'utilisateur Sally et
      qu'Harry extrait un répertoire parent, son client répondra à la
      demande d'authentification initiale en tant que Harry. Au fur et
      à mesure que le serveur génère la réponse, il n'a aucun moyen de
      renvoyer un défi d'authentification quand il atteint le
      sous-répertoire spécial&nbsp;; ainsi le sous-répertoire tout
      entier est omis, plutôt que de demander à l'utilisateur de se
      ré-authentifier en tant que Sally le moment venu. De même, si la
      racine du dépôt est accessible en lecture anonymement,
      l'extraction se fera entièrement sans authentification,
      omettant, encore une fois, le répertoire non-lisible, plutôt que
      d'envoyer une demande d'authentification au cours de
      l'opération.</para>
  </sidebar>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.multimethod">

    <title>Accès au dépôt par plusieurs méthodes</title>

    <para>Vous venez de voir différentes méthodes d'accès à un dépôt.
      Est-il possible &mdash; et sans danger &mdash; d'accéder
      simultanément à un dépôt par différentes méthodes&nbsp;? La
      réponse est oui, à condition d'être un petit peu prévoyant.</para>

    <para>À un instant donné, les processus suivants peuvent avoir
      besoin de l'accès en lecture ou en écriture au dépôt&nbsp;:</para>

    <itemizedlist>
      <listitem>
        <para>des utilisateurs classiques du système se connectant à
          l'aide d'un client Subversion à des URL
          <literal>file://</literal>&nbsp;;</para>
      </listitem>
      <listitem>
        <para>des utilisateurs classiques du système se connectant à des
          processus <command>svnserve</command> privés générés par SSH
          (dont le propriétaire est l'utilisateur lui-même) et accédant
          au dépôt&nbsp;;</para>
      </listitem>
      <listitem>
        <para>un processus <command>svnserve</command> &mdash; soit un
          serveur autonome, soit un processus lancé par
          <command>inetd</command> &mdash; dont le propriétaire est un
          utilisateur dédié&nbsp;;</para>
      </listitem>
      <listitem>
        <para>un processus <command>httpd</command>&nbsp;Apache, dont le
          propriétaire est un utilisateur dédié.</para>
      </listitem>
    </itemizedlist>

    <para>Les problèmes les plus courants rencontrés par les
      administrateurs sont des problèmes de droits et de propriété pour
      le dépôt. Chaque processus de la liste précédente a-t-il les
      droits de lecture et d'écriture sur les fichiers sous-jacents du
      dépôt&nbsp;? En supposant que vous ayez un système d'exploitation
      de type Unix, une approche naïve de ce problème serait de placer
      chaque utilisateur potentiel du dépôt dans un groupe
      <literal>svn</literal> unique et de faire posséder le dépôt tout
      entier par ce groupe. Mais cela ne suffit même pas, car un
      processus risque de modifier les fichiers de la base de données en
      utilisant un umask inadapté qui va interdire l'accès aux autres
      utilisateurs.</para>

    <para>L'étape suivante consiste donc, après avoir mis en place un
      groupe commun pour les utilisateurs du dépôt, à forcer tout
      processus qui accède au dépôt à utiliser un umask correct. Pour
      les utilisateurs qui accèdent directement au dépôt, vous pouvez
      <quote>envelopper</quote> le programme svnserve dans un script
      (<foreignphrase>wrapper</foreignphrase> en anglais) qui commence
      par lancer la commande <userinput>umask 002</userinput>
      et qui, seulement ensuite, appelle
      le véritable programme client <command>svn</command>.
      Vous pouvez également écrire un script similaire pour le programme
      <command>svnserve</command> et ajouter la commande
      <userinput>umask 002</userinput> au script de démarrage d'Apache,
      <filename>apachectl</filename>. Par exemple&nbsp;:</para>

    <screen>
$ cat /usr/bin/svn

#!/bin/sh

umask 002
/usr/bin/le-vrai-svn "$@"

</screen>

    <para>Sur les systèmes de type Unix, on rencontre souvent un autre
      problème classique. Si vous avez un dépôt Berkeley DB, par
      exemple, il crée de temps en temps de nouveaux fichiers pour la
      journalisation. Même si le dépôt Berkeley DB est entièrement
      possédé par le groupe <literal>svn</literal>, ces nouveaux
      journaux ne seront pas nécessairement possédés par le même groupe,
      ce qui crée des problèmes de droits supplémentaires pour vos
      utilisateurs. Une bonne façon de contourner ce problème est
      d'activer le bit SUID du groupe sur le répertoire
      <filename>db</filename> du dépôt, ce qui a pour résultat que tous
      les nouveaux fichiers journaux créés ont le même propriétaire que
      le répertoire parent.</para>

    <para>Une fois ces manipulations effectuées, vos dépôts devraient
      être accessibles par tous les processus nécessaires. Tout ceci
      peut sembler un petit peu confus et compliqué, mais les problèmes
      d'accès en écriture par plusieurs utilisateurs à des fichiers
      partagés sont des problèmes très classiques, qui ne sont pas
      souvent résolus avec élégance.</para>

    <para>Heureusement, la plupart des administrateurs
      <emphasis>n'auront jamais besoin</emphasis> d'une configuration
      aussi complexe. Les utilisateurs qui désirent accéder aux dépôts
      résidant sur une même machine ne sont pas limités aux URL d'accès
      <literal>file://</literal> &mdash; ils peuvent généralement
      contacter le serveur http&nbsp;Apache ou le
      serveur <command>svnserve</command> en utilisant
      <literal>localhost</literal> comme nom de serveur dans leurs URL
      <literal>http://</literal> ou <literal>svn://</literal>. Et
      assurer la maintenance de plusieurs processus serveurs pour vos
      dépôts Subversion vous créera plus de soucis qu'autre chose. Nous
      vous recommandons de choisir un seul serveur (celui qui correspond
      le mieux à vos besoins) et de vous y tenir&nbsp;!</para>

    <sidebar>
      <title>Serveur <literal>svn+ssh://</literal>&nbsp;: les points à
        vérifier</title>

      <para>Partager un dépôt entre des utilisateurs qui ont des comptes
        SSH sans avoir de problème de droits d'accès peut être assez
        épineux. Si l'ensemble des tâches à mener par l'administrateur
        d'un système de type Unix est encore un peu confus pour vous,
        voici la liste des choses à vérifier qui récapitule les points
        abordés dans cette section&nbsp;:</para>

      <itemizedlist>
        <listitem>
          <para>Tous vos utilisateurs SSH doivent être capables de lire
            et d'écrire dans le dépôt, donc mettez tous les utilisateurs
            SSH dans un même groupe&nbsp;;</para>
        </listitem>
        <listitem>
          <para>
            Faites de ce dépôt l'entière propriété de ce groupe.
            </para>
        </listitem>
        <listitem>
          <para>Mettez les droits d'accès de ce groupe à
            lecture/écriture.</para>
        </listitem>
        <listitem>
          <para>Vos utilisateurs doivent utiliser un umask correct quand
            ils accèdent au dépôt, donc assurez-vous que
            <command>svnserve</command>
            (<filename>/usr/bin/svnserve</filename> ou le chemin vers
              lequel <literal>$PATH</literal> pointe) est en fait un
              script qui exécute <userinput>umask 002</userinput> avant
              de lancer le véritable exécutable
              <command>svnserve</command>.</para>
        </listitem>
        <listitem><para>Prenez des mesures similaires quand vous utilisez
            <command>svnlook</command> et
            <command>svnadmin</command>&nbsp;: soit vous les lancez avec
            un umask correct, soit vous les <quote>enveloppez</quote>
            dans un script comme nous venons de l'expliquer.</para>
        </listitem>
      </itemizedlist>

    </sidebar>

  </sect1>




</chapter>

<!--
local variables:
sgml-parent-document: ("book.xml" "chapter")
end:
-->
