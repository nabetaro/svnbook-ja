<chapter id="svn.basic">
  <title>Notions fondamentales</title>

  <para>Ce chapitre est une introduction rapide à Subversion. Si vous ne
    connaissez rien à la gestion de versions, ce chapitre est à coup sûr
    pour vous. Nous allons commencer par une présentation des notions
    générales de la gestion de versions, puis étudier plus précisément
    les idées particulières qui se cachent derrière Subversion et enfin
    donner quelques exemples simples d'utilisation de Subversion.</para>

  <para>Même si les exemples de ce chapitre mettent en scène des personnes
    partageant du code source, gardez à l'esprit que Subversion peut gérer
    n'importe quel type d'ensemble de fichiers, il n'est pas réservé aux
    programmeurs.</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.repository">
    <title>Le dépôt</title>

    <para>Subversion est un système centralisé fait pour partager
      l'information. Le dépôt constitue le cœur de ce système, en tant
      que lieu de stockage central des données. Les informations y sont
      organisées sous la forme d'une <firstterm>arborescence de
      fichiers</firstterm>, c'est-à-dire une hiérarchie classique de
      fichiers et de répertoires. Un certain nombre de
      <firstterm>clients</firstterm> se connectent au dépôt, et
      parcourent ou modifient ces fichiers. En modifiant des données,
      un client rend ces informations disponibles à d'autres
      personnes&nbsp;; en lisant des données, le client reçoit les
      informations des autres personnes. La <xref
      linkend="svn.basic.repository.dia-1"/> illustre cela.</para>

    <figure id="svn.basic.repository.dia-1">
      <title>Un authentique système client/serveur</title>
      <graphic fileref="images/ch02dia1.png"/>
    </figure>

    <para>Quel est l'intérêt&nbsp;? Jusque là, cela ressemble à la
      définition d'un serveur de fichiers classique. En fait, le dépôt
      <emphasis>est</emphasis> bien une sorte de serveur de fichiers,
      mais d'un type particulier. Ce qui rend le dépôt Subversion
      spécial, c'est qu'<emphasis>il se souvient de toutes les
      modifications</emphasis> qui ont été apportées&nbsp;: chaque
      modification de chaque fichier, ainsi que les modifications de
      l'arborescence-même des répertoires, comme l'ajout, la
      suppression ou la réorganisation de fichiers et de
      répertoires.</para>

    <para>Quand un client parcourt le dépôt, il consulte généralement
      la dernière version de l'arborescence du système de fichiers.
      Mais le client est également capable de visualiser
      des états <emphasis>antérieurs</emphasis> du système de fichiers.
      Par exemple, un client peut poser des questions concernant
      l'historique des données, comme <quote>Que contenait ce
      répertoire mercredi dernier&nbsp;?</quote> ou <quote>Quelle est
      la dernière personne qui a modifié ce fichier, et quels
      changements a-t-elle effectué&nbsp;?</quote>. C'est le genre de
      questions qui est au cœur de tout <firstterm>logiciel de gestion
      de versions</firstterm>, logiciel conçu pour conserver
      l'historique des modifications des données au cours
      du temps.</para>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.vsn-models">
    <title>Modèles de gestion de versions</title>

    <para>La mission essentielle d'un logiciel de gestion de versions
      est de permettre l'édition collaborative et le partage de données.
      Mais il existe différentes stratégies pour arriver à cette fin.
      Comprendre ces différentes stratégies est important pour
      plusieurs raisons. Tout d'abord, cela vous aidera à comparer
      et différencier les logiciels de gestion de versions existants,
      au cas où vous rencontriez d'autres logiciels similaires à
      Subversion. Ensuite, cela vous aidera également à utiliser plus
      efficacement Subversion, puisque Subversion lui-même autorise
      différentes façons de travailler.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.vsn-models.problem-sharing">
      <title>Problématique du partage de fichiers</title>

      <para>Tous les logiciels de gestion de versions doivent résoudre
        le même problème fondamental&nbsp;: comment le logiciel va-t-il
        permettre aux utilisateurs de partager l'information, tout en
        les empêchant de se marcher mutuellement sur les pieds par
        accident&nbsp;? Il est vraiment trop facile pour les utilisateurs
        d'écraser malencontreusement les changements effectués par
        d'autres dans le dépôt.</para>

      <para>Observons le scénario décrit à la <xref
        linkend="svn.basic.vsn-models.problem-sharing.dia-1"/>.
        Supposons que nous ayons deux collaborateurs, Harry et Sally.
        Ils décident tous les deux d'éditer au même moment le même
        fichier dans le dépôt. Si Harry sauvegarde ses modifications dans
        le dépôt en premier, il est possible que, quelques instants plus
        tard, Sally les écrase avec sa propre version du fichier.
        Bien que la version de Harry ne soit pas perdue pour toujours,
        car le système se souvient de tous les changements,
        <emphasis>aucune </emphasis> des modifications effectuées par
        Harry ne sera présente dans la nouvelle version du fichier de
        Sally, car elle n'aura jamais vu les changements réalisés par
        Harry. De fait, le travail de Harry est perdu ou, du moins, perdu
        dans la version finale du fichier, et ceci probablement par
        accident. Il s'agit précisément d'une situation que nous
        voulons à tout prix éviter&nbsp;!</para>

      <figure id="svn.basic.vsn-models.problem-sharing.dia-1">
        <title>La situation à éviter</title>
        <graphic fileref="images/ch02dia2.png"/>
      </figure>

      </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.vsn-models.lock-unlock">
      <title>Modèle verrouiller-modifier-libérer</title>

      <para>De nombreux logiciels de gestion de versions utilisent
        le modèle <firstterm>verrouiller-modifier-libérer</firstterm>
        pour résoudre le problème de plusieurs auteurs annihilant
        le travail des autres. Dans ce modèle, le dépôt ne permet
        qu'à une seule personne de modifier un fichier à un instant
        donné. Cette politique exclusive est gérée grâce à des verrous
        (<quote>lock</quote> en anglais). Harry doit
        <quote>verrouiller</quote> un fichier avant de commencer à le
        modifier. Si Harry a verrouillé un fichier, alors Sally ne
        pourra pas le verrouiller et ne pourra donc faire aucun
        changement dessus. Tout ce qu'elle pourra faire sera de lire le
        fichier et d'attendre que Harry ait fini ses changements puis
        libéré le verrou. Après que Harry ait libéré le fichier, Sally
        pourra à son tour le verrouiller et l'éditer. La <xref
        linkend="svn.basic.vsn-models.lock-unlock.dia-1"/> illustre
        cette solution très simple.</para>

      <figure id="svn.basic.vsn-models.lock-unlock.dia-1">
        <title>Modèle verrouiller-modifier-libérer</title>
        <graphic fileref="images/ch02dia3.png"/>
      </figure>

      <para>Le problème avec le modèle verrouiller-modifier-libérer
        est qu'il est relativement restrictif et devient souvent un
        barrage pour les utilisateurs&nbsp;:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Le verrouillage peut créer des problèmes
            d'administration.</emphasis>

            Parfois, Harry va verrouiller un fichier et oublier qu'il
            l'a fait. Pendant ce temps, Sally, qui est encore en train
            d'attendre pour éditer le fichier, est bloquée. Puis Harry
            part en vacances. Sally doit alors aller trouver un
            administrateur pour libérer le verrou de Harry. La situation
            finit par générer beaucoup de délais inutiles et de temps
            perdu.</para>
        </listitem>

        <listitem>
          <para><emphasis>Le verrouillage peut créer une
            sérialisation inutile.</emphasis>

            Que se passe-t-il lorsque Harry veut éditer le début d'un
            fichier texte et que Sally veut simplement éditer la fin
            de ce même fichier&nbsp;? Ces changements ne se chevauchent
            pas du tout. Ils pourraient aisément éditer le fichier
            simultanément et il n'y aurait pas beaucoup de dégâts,
            en supposant que les changements soient correctement
            fusionnés. Dans cette situation, il n'est pas nécessaire
            de les forcer à éditer le fichier chacun à leur tour.</para>
        </listitem>

        <listitem>
          <para><emphasis>Le verrouillage peut créer un faux sentiment
            de sécurité.</emphasis>

            Supposons que Harry verrouille et édite le fichier A,
            alors qu'au même moment Sally verrouille et édite le
            fichier B. Que se passe-t-il si A et B dépendent l'un de
            l'autre et que les changements faits à chacun sont
            incompatibles d'un point de vue sémantique&nbsp;? A et B ne
            fonctionnent soudainement plus ensemble. Le système de
            verrouillage a été incapable d'empêcher ce problème, bien
            qu'il ait d'une certaine manière instillé un faux sentiment
            de sécurité. Il est facile pour Harry et Sally d'imaginer
            qu'en verrouillant les fichiers, chacun commence une tâche
            isolée, sans danger et donc que ce n'est pas la peine de
            discuter à l'avance de leurs modifications incompatibles.
            Verrouiller devient souvent un substitut à une réelle
            communication.</para>
        </listitem>
      </itemizedlist>

      </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.vsn-models.copy-merge">
      <title>Modèle copier-modifier-fusionner</title>

      <para>Subversion, CVS et beaucoup d'autres logiciels de gestion
        de versions utilisent le modèle
        <firstterm>copier-modifier-fusionner</firstterm>
        comme alternative au verrouillage. Dans ce modèle, chaque
        utilisateur contacte le dépôt du projet via son client et
        crée une copie de travail personnelle, une sorte de version
        locale des fichiers et répertoires du dépôt. Les utilisateurs
        peuvent alors travailler, simultanément et indépendamment les
        uns des autres, et modifier leurs copies privées. Pour finir,
        les copies privées sont fusionnées au sein d'une nouvelle
        version finale. Le logiciel de gestion de versions fournit de
        l'aide afin de réaliser cette fusion, mais au final la
        responsabilité de s'assurer que tout se passe bien incombe à
        un être humain.</para>

      <para>Voici un exemple. Supposons que Harry et Sally aient créé
        chacun des copies de travail du même projet, copiées à partir
        du dépôt. Ils travaillent simultanément et effectuent sur leur
        copie des modifications du même fichier A. Sally sauvegarde
        ses changements dans le dépôt en premier. Lorsque Harry essaie
        par la suite de sauvegarder ses modifications, le dépôt
        l'informe que son fichier A est <firstterm>périmé</firstterm>.
        En d'autres termes, le fichier A du dépôt a changé, d'une façon
        ou d'une autre, depuis la dernière fois qu'il l'avait copié.
        Harry demande donc à son client de
        <firstterm>fusionner</firstterm> tous les changements en
        provenance du dépôt dans sa copie de travail du fichier A.
        Il y a des chances que les modifications de Sally n'empiètent
        pas sur les siennes&nbsp;; une fois qu'il a intégré les
        changements provenant des deux côtés, il sauvegarde sa copie
        de travail dans le dépôt. La <xref
        linkend="svn.basic.vsn-models.copy-merge.dia-1"/> et la <xref
        linkend="svn.basic.vsn-models.copy-merge.dia-2"/> illustrent
        ce processus.</para>

      <figure id="svn.basic.vsn-models.copy-merge.dia-1">
        <title>Modèle copier-modifier-fusionner</title>
        <graphic fileref="images/ch02dia4.png"/>
      </figure>

      <figure id="svn.basic.vsn-models.copy-merge.dia-2">
        <title>Modèle copier-modifier-fusionner (suite)</title>
        <graphic fileref="images/ch02dia5.png"/>
      </figure>

      <para>Mais que se passe-t-il quand les modifications de Sally
        empiètent sur celles de Harry&nbsp;? Que fait-on dans ce
        cas-là&nbsp;? Cette situation est appelée un
        <firstterm>conflit</firstterm>
        et ne constitue pas, en général, un gros problème. Lorsque Harry
        demande à son logiciel client de fusionner les changements
        les plus récents du dépôt dans sa copie de travail, sa copie
        du fichier est en quelque sorte marquée comme étant dans un
        état de conflit&nbsp;: il a la possibilité de voir les deux
        ensembles de changements entrant en conflit et de choisir
        manuellement entre les deux. Notez bien qu'un logiciel ne
        peut pas résoudre automatiquement les conflits&nbsp;; seuls les
        humains sont capables de comprendre et de faire les choix
        intelligents nécessaires. Une fois que Harry a manuellement
        résolu les modifications se chevauchant, par exemple après une
        discussion avec Sally, il peut sauvegarder le fichier fusionné
        en toute sécurité dans le dépôt.</para>

      <para>Le modèle copier-modifier-fusionner peut sembler un peu
        chaotique mais, en pratique, il fonctionne de façon très
        fluide. Les utilisateurs peuvent travailler en parallèle, sans
        jamais devoir s'attendre les uns les autres. Lorsqu'ils
        travaillent sur les mêmes fichiers, il s'avère que la plupart
        des changements réalisés en parallèle ne se chevauchent pas du
        tout&nbsp;; les conflits sont rares. Et le temps nécessaire à la
        résolution des conflits est en général bien inférieur au temps
        gaspillé par un système de verrouillage.</para>

      <para>Au final, tout revient à un facteur critique&nbsp;: la
        communication entre les utilisateurs. Lorsque les utilisateurs
        communiquent mal, les conflits syntaxiques et sémantiques
        augmentent. Aucun système ne peut forcer les utilisateurs à
        communiquer parfaitement et aucun système ne peut détecter
        les conflits sémantiques. Il n'y a donc aucun intérêt à se
        laisser endormir par un faux sentiment de sécurité selon
        lequel un système de verrouillage permettrait d'éviter les
        conflits&nbsp;; en pratique, le verrouillage semble limiter la
        productivité plus qu'aucun autre facteur.</para>

      <sidebar id="svn.basic.vsn-models.copy-merge.sb-1">
        <title>Le verrouillage est parfois nécessaire</title>

        <para>Même si le modèle verrouiller-modifier-libérer est en
          général considéré comme pénalisant pour la collaboration, il
          y a quand même des cas où le verrouillage est
          approprié.</para>

        <para>Le modèle copier-modifier-fusionner est basé sur
          l'hypothèse que les fichiers sont contextuellement
          fusionnables, c'est-à-dire que la majorité des fichiers d'un
          dépôt sont des fichiers textes (comme le code source d'un
          programme). Mais pour les fichiers binaires, tels que des
          images ou du son, il est souvent impossible de fusionner les
          modifications en conflit. Dans ces cas-là, il est réellement
          nécessaire que les utilisateurs ne modifient le fichier qu'à
          tour de rôle. Sans accès sérialisé, quelqu'un finirait par
          perdre du temps sur des modifications qui seraient finalement
          perdues.</para>

        <para>Bien que Subversion soit avant tout un système
          copier-modifier-fusionner, il reconnaît toutefois la
          nécessité du verrouillage pour certains fichiers et fournit
          donc un mécanisme pour cela. Cette fonctionnalité est
          traitée plus tard dans ce livre, dans <xref
          linkend="svn.advanced.locking"/>.</para>

      </sidebar>


    </sect2>

  </sect1>

  <!-- How svn implements the philosophy -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.in-action">
    <title>Subversion en action</title>

    <para>Il est temps de passer de l'abstrait au concret. Dans cette
      section, nous vous montrons des exemples réels
      d'utilisation de Subversion.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.reposurls">
      <title>URL des dépôts Subversion</title>

      <para>Tout au long de ce livre, Subversion utilise des URL
        pour identifier des fichiers et des répertoires suivis en
        version au sein de dépôts Subversion. Pour la plupart, ces URL
        utilisent la syntaxe standard, permettant de spécifier les
        noms des serveurs et les numéros de port à l'intérieur même
        de l'URL&nbsp;:</para>

      <screen>
$ svn checkout http://svn.exemple.com:9834/depot
&hellip;
</screen>

      <para>Mais il existe quelques nuances dans la gestion des URL
        par Subversion qui doivent être notées. Par exemple, les URL
        ayant pour méthode d'accès <literal>file:// </literal>
        (utilisée pour les dépôts locaux) doivent posséder, en accord
        avec les conventions, soit un nom de serveur
        <literal>localhost </literal>, soit pas de nom de serveur
        du tout&nbsp;:</para>

      <screen>
$ svn checkout file:///var/svn/depot
&hellip;
$ svn checkout file://localhost/var/svn/depot
&hellip;
</screen>

      <para>D'autre part, les utilisateurs du procédé
        <literal>file://</literal> sur les plateformes Windows doivent
        se servir d'une syntaxe qui est un <quote>standard</quote>
        officieux pour accéder à leurs dépôts se trouvant sur la même
        machine mais sur un disque différent du disque de travail
        habituel du client. Les deux syntaxes de chemin d'URL suivantes
        fonctionnent, <literal>X</literal> étant le disque sur lequel
        le dépôt se trouve&nbsp;:</para>

      <screen>
C:\&gt; svn checkout file:///X:/var/svn/depot
&hellip;
C:\&gt; svn checkout "file:///X|/var/svn/depot"
&hellip;
</screen>

      <para>Dans la seconde syntaxe, vous devez entourer
        l'URL de guillemets pour éviter que la barre verticale ne soit
        interprétée comme un symbole de redirection (un
        <quote>pipe</quote>). De plus, remarquez qu'une URL utilise
        des barres obliques (<literal>/</literal>) alors que la
        forme native (non-URL) d'un chemin sous Windows utilise des
        barres obliques inversées (<literal>\</literal>).</para>

      <note>
        <para>Les URL Subversion <literal>file://</literal> ne
          peuvent pas être utilisées dans un navigateur web classique
          de la même façon qu'une URL <literal>file:// </literal>
          habituelle. Lorsque vous essayez de visualiser une URL
          <literal>file:// </literal> dans un navigateur web
          classique, il lit et affiche le contenu du fichier situé à
          cet emplacement en interrogeant directement le système de
          fichiers. Cependant, les ressources de Subversion existent
          dans un système de fichier virtuel (cf. <xref
          linkend="svn.developer.layerlib.repos" />) et votre
          navigateur ne comprend pas comment interagir avec ce
          système de fichiers.</para>
      </note>

      <para>Enfin, il faut noter que le client Subversion encode
        automatiquement les URL en cas de besoin, exactement
        comme le fait un navigateur web. Par exemple, si une URL
        contient un espace ou un caractère ASCII spécial, comme dans
        ce qui suit&nbsp;:</para>

      <screen>
$ svn checkout "http://hote/chemin avec espace/projet/españa"
</screen>

      <para>alors Subversion banalise les caractères spéciaux et
        se comporte comme si vous aviez tapé&nbsp;:</para>

      <screen>
$ svn checkout http://hote/chemin%20avec%20espace/projet/espa%C3%B1a
</screen>

      <para>Si l'URL contient des espaces, prenez bien soin de la
        placer entre guillemets, pour que votre shell traite le tout
        comme un unique argument du programme
        <command>svn</command>.</para>

      <sidebar id="svn.basic.in-action.wc.sb-1">
        <title>URL du dépôt</title>

        <para>On peut accéder aux dépôts Subversion de nombreuses
          manières différentes, sur un disque local ou à travers
          différents protocoles réseau, en fonction de la façon dont
          votre administrateur a mis les choses en place pour vous.
          L'emplacement d'un dépôt, toutefois, est toujours une URL.
          Le <xref linkend="svn.basic.in-action.wc.tbl-1"/> décrit
          les différents procédés d'accès et les méthodes d'accès
          correspondantes.</para>

        <table id="svn.basic.in-action.wc.tbl-1">
          <title>URL d'accès au dépôt</title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Procédé</entry>
                <entry>Méthode d'accès</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><literal>file:///</literal></entry>
                <entry>Accès direct au dépôt (sur un disque local).
                  </entry>
              </row>
              <row>
                <entry><literal>http://</literal></entry>
                <entry>Accès via le protocole WebDAV à un serveur
                  Apache configuré pour Subversion.</entry>
              </row>
              <row>
                <entry><literal>https://</literal></entry>
                <entry>Identique à <literal>http://</literal>, mais
                  avec chiffrement SSL.</entry>
              </row>
              <row>
                <entry><literal>svn://</literal></entry>
                <entry>Accès via un protocole personnalisé à un
                  serveur <literal>svnserve</literal>.</entry>
              </row>
              <row>
                <entry><literal>svn+ssh://</literal></entry>
                <entry>Identique à <literal>svn://</literal>, mais à
                  travers un tunnel SSH.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Pour plus d'informations sur la façon dont Subversion
          analyse les URL, reportez-vous à <xref
          linkend="svn.advanced.reposurls"/>. Pour plus d'informations
          sur les différents types de serveurs réseau disponibles
          pour Subversion, reportez-vous au <xref
          linkend="svn.serverconfig"/>.</para>

      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.wc">
      <title>Copies de travail</title>

      <para>Vous avez déjà découvert ce que sont les copies de
        travail&nbsp;; nous allons maintenant vous expliquer comment le
        client Subversion les crée et les utilise.</para>

      <para>Une copie de travail Subversion est une arborescence
        classique de répertoires de votre système local, contenant un
        ensemble de fichiers. Vous pouvez éditer ces fichiers comme
        vous le voulez et, s'il s'agit de code source, vous pouvez
        compiler votre programme à partir de ceux-ci de la façon
        habituelle. Votre copie de travail est votre espace de travail
        personnel privé&nbsp;: Subversion n'y incorporera jamais les
        changements d'autres personnes ni ne rendra jamais disponibles
        vos propres changements à d'autres personnes tant que vous ne
        lui demanderez pas explicitement de le faire. Vous pouvez même
        avoir plusieurs copies de travail d'un même projet.</para>

      <para>Après que vous ayez apporté quelques modifications aux
        fichiers de votre copie de travail et vérifié qu'elles
        fonctionnent correctement, Subversion vous fournit des
        commandes pour <quote>publier</quote> vos changements vers
        les autres personnes qui travaillent avec vous sur votre
        projet (en les transmettant au dépôt). Si d'autres personnes
        publient leurs propres modifications, Subversion vous fournit
        des commandes pour fusionner ces changements dans votre copie
        de travail (en les obtenant du dépôt).</para>

      <para>Une copie de travail contient également quelques fichiers
        supplémentaires, créés et gérés par Subversion, pour l'aider
        à effectuer ces opérations. En particulier, chaque répertoire
        de votre copie de travail contient un sous-répertoire appelé
        <filename>.svn</filename>, aussi appelé <firstterm>répertoire
        administratif</firstterm> de votre copie de travail. Les
        fichiers de chacun de ces répertoires administratifs permettent
        à Subversion d'identifier quels fichiers contiennent des
        modifications non-publiées et quels fichiers sont périmés
        vis-à-vis du travail des autres personnes.</para>

      <para>Un dépôt Subversion contient bien souvent les fichiers
        (ou code source) de plusieurs projets&nbsp;; habituellement,
        chaque projet est un sous-répertoire de l'arborescence du
        système de fichiers du dépôt. Dans cette situation, la copie
        de travail d'un utilisateur correspond à une
        sous-arborescence particulière du dépôt.</para>

      <para>Par exemple, supposons que votre dépôt contienne deux
        projets logiciels, <literal>paint</literal> et
        <literal>calc</literal>. Chaque projet réside dans son propre
        sous-répertoire racine, comme indiqué dans la <xref
        linkend="svn.basic.in-action.wc.dia-1"/>.</para>

      <figure id="svn.basic.in-action.wc.dia-1">
        <title>Système de fichiers du dépôt</title>
        <graphic fileref="images/ch02dia6.png"/>
      </figure>

      <para>Pour obtenir une copie de travail, vous devez
        <firstterm>extraire</firstterm> une sous-arborescence du
        répertoire (le terme <quote>extraire</quote>,
        <quote>check out</quote> en anglais, peut vous faire penser
        que cela a quelque chose à voir avec verrouiller ou réserver
        des ressources, mais ce n'est pas le cas&nbsp;; cela crée
        simplement pour vous une copie privée du projet). Par exemple,
        si vous extrayez <filename>/calc</filename>, vous obtenez
        une copie de travail qui ressemble à ceci&nbsp;:</para>

      <screen>
$ svn checkout http://svn.exemple.com/depot/calc
A    calc/Makefile
A    calc/entier.c
A    calc/bouton.c
Révision 56 extraite.

$ ls -A calc
Makefile  entier.c  bouton.c  .svn/
</screen>

      <para>Les lettres <literal>A</literal> qui s'affichent dans la
        marge de gauche indiquent que Subversion est en train
        d'ajouter des éléments dans votre copie de travail. Vous avez
        désormais votre copie personnelle du répertoire
        <filename>/calc</filename> du dépôt, avec une entrée
        supplémentaire, <filename>.svn</filename>, qui contient des
        informations complémentaires nécessaires à Subversion, comme
        évoqué précédemment.</para>

      <para>Supposons que vous fassiez des modifications à
        <filename>bouton.c</filename>. Comme le répertoire
        <filename>.svn</filename> se souvient de la date de
        modification et du contenu du fichier original, Subversion
        peut en déduire que vous avez modifié le fichier. Néanmoins,
        Subversion ne rend pas vos modifications publiques tant que
        vous ne lui dites pas de le faire. L'action de publication de
        vos modifications est plus communément appelée
        <firstterm>propagation</firstterm> (<quote>commit</quote> ou
        <quote>check in</quote> en anglais et, parfois,
        <firstterm>archivage</firstterm>  ou
        <firstterm>livraison</firstterm> en français) des
        modifications au sein du dépôt.</para>

      <para>Pour rendre publiques vos modifications, vous pouvez
        utiliser la commande Subversion
        <command>svn commit</command>&nbsp;:</para>

      <screen>
$ svn commit bouton.c -m "Coquille corrigée dans bouton.c."
Ajout        bouton.c
Transmission des données .
Révision 57 propagée.
</screen>

      <para>À présent, vos modifications de
        <filename>bouton.c</filename> ont été propagées au sein du
        dépôt, avec un commentaire décrivant ces changements
        (<quote>vous avez corrigé une coquille</quote>). Si un
        autre utilisateur extrait une copie de travail de
        <filename>/calc/</filename>, il va voir vos modifications dans
        la dernière version du fichier.</para>

      <para>Supposons que vous ayez une collaboratrice, Sally, qui a
        extrait une copie de travail de <filename>/calc</filename> en
        même temps que vous. Lorsque vous propagez votre modification
        de <filename>bouton.c</filename>, la copie de travail de Sally
        reste inchangée&nbsp;; Subversion ne modifie les copies de travail
        qu'à la demande des utilisateurs.</para>

      <para>Pour mettre son projet à jour, Sally peut demander à
        Subversion de mettre à jour (<quote>update</quote> en anglais)
        sa copie de travail, en utilisant la commande
        <command>svn update</command>. Cela va intégrer vos
        modifications dans sa copie de travail, ainsi que celles qui
        ont été envoyées par d'autres personnes depuis qu'elle
        l'avait extraite.</para>

      <screen>
$ pwd
/home/sally/calc

$ ls -A 
Makefile bouton.c entier.c .svn/ 

$ svn update
U    bouton.c
Actualisé à la révision 57.
</screen>

      <para>En sortie, la commande <command>svn update</command>
        indique que Subversion a mis à jour le contenu de
        <filename>bouton.c</filename>. Remarquez que Sally n'a pas eu
        besoin de spécifier quels fichiers devaient être mis à
        jour&nbsp;; Subversion utilise les informations contenues dans
        le répertoire <filename>.svn</filename>, ainsi que d'autres
        informations en provenance du dépôt, pour décider quels
        fichiers doivent être mis à jour.</para>

    </sect2>


    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.revs">
      <title>Révisions</title>

      <para>Une opération <command>svn commit</command> publie les
        modifications d'un nombre quelconque de fichiers et de
        répertoires en une seule opération atomique. Dans votre copie
        de travail, vous pouvez modifier le contenu des fichiers&nbsp;:
        créer, supprimer, renommer et copier fichiers et
        répertoires&nbsp;; puis propager un ensemble de modifications en
        une seule transaction atomique.</para>

      <para>Par <quote>transaction atomique</quote>, on entend
        simplement ceci&nbsp;: soit toutes les modifications sont
        propagées dans le dépôt, soit aucune ne l'est. Subversion
        tente de conserver cette atomicité aussi bien face à des
        <quote>plantages</quote> de programmes, de systèmes
        d'exploitation ou de réseau, que face aux actions des autres
        utilisateurs.</para>

      <para>Chaque fois que le dépôt accepte une propagation, ceci
        crée un nouvel état de l'arborescence du système de fichiers,
        appelé <firstterm>révision</firstterm>. Un numéro unique est
        associé à chaque révision, correspondant au numéro de la
        révision précédente augmenté de 1. La révision initiale d'un
        dépôt fraîchement créé porte le numéro 0 et ne consiste en rien
        d'autre qu'un répertoire racine vide.</para>

      <para>La <xref linkend="svn.basic.in-action.revs.dia-1"/> offre
        une vue intéressante du dépôt. Imaginez un tableau de numéros
        de révisions, commençant à 0 et s'étirant de la gauche vers la
        droite. Chaque numéro de révision correspond à une arborescence
        de système de fichiers située en-dessous de lui et chaque
        arborescence est une photo, un <quote>instantané</quote>
        (<quote>snapshot</quote> en anglais) du dépôt prise après une
        propagation.</para>

      <figure id="svn.basic.in-action.revs.dia-1">
        <title>Le dépôt</title>
        <graphic fileref="images/ch02dia7.png"/>
      </figure>

      <sidebar>
        <title>Numéros de révision globaux</title>

        <para>Contrairement à la plupart des logiciels de gestion de
          versions, les numéros de révision de Subversion s'appliquent
          à <emphasis>l'arborescence toute entière</emphasis> et non
          à chaque fichier individuellement. À chaque numéro de révision
          correspond une arborescence toute entière, un état particulier
          du dépôt après une propagation. Une autre façon de voir cela
          est de considérer que la révision N représente l'état du
          système de fichiers du dépôt après la N-ième propagation.
          Quand des utilisateurs de Subversion parlent de la
          <quote>révision 5 de <filename>truc.c</filename></quote>,
          ils veulent en fait parler de
          <quote><filename>truc.c</filename> tel qu'il apparaît dans
          la révision 5</quote>. Remarquez bien qu'en règle générale,
          les révisions N et M d'un fichier ne sont <emphasis>pas
          forcément </emphasis> différentes&nbsp;! De nombreux autres
          logiciels de gestion de versions gèrent les numéros de
          révision fichier par fichier&nbsp;; ce concept peut donc
          sembler inhabituel à première vue (les anciens utilisateurs
          de CVS peuvent se référer à l'<xref linkend="svn.forcvs"/>
          pour plus de détails).</para>
      </sidebar>

      <para>Il est important de noter que les copies de travail ne
        correspondent pas toujours à une unique révision du
        dépôt&nbsp;; elles peuvent contenir des fichiers provenant de
        plusieurs révisions différentes. Par exemple, supposons que
        vous extrayiez une copie de travail d'un dépôt dont la
        révision la plus récente est la numéro 4&nbsp;:</para>

      <screen>
calc/Makefile:4
     integer.c:4
     button.c:4
</screen>

      <para>À cet instant, le répertoire de travail correspond
        exactement à la révision 4 du dépôt. Néanmoins, supposons que
        vous modifiiez <filename>bouton.c</filename> et que vous
        propagiez cette modification. En supposant qu'aucune autre
        propagation n'a eu lieu, votre propagation crée la
        révision 5 du dépôt et votre copie de travail ressemble 
        maintenant à ceci&nbsp;:</para>

      <screen>
calc/Makefile:4
    entier.c:4
    bouton.c:5
</screen>

      <para>Supposons maintenant qu'à ce moment précis, Sally propage
        une modification d'<filename>entier.c</filename>, créant la
        révision 6. Si vous utilisez <command>svn update</command>
        pour mettre à jour votre copie de travail, elle ressemble alors 
        à ceci&nbsp;:</para>

      <screen>
calc/Makefile:6
    entier.c:6
    bouton.c:6
</screen>

      <para>Les modifications apportées par Sally à
        <filename>entier.c</filename> apparaissent dans votre copie
        de travail et vos modifications sont toujours présentes dans
        <filename>bouton.c</filename>. Dans cet exemple, le texte de
        <filename>Makefile</filename> est identique dans les révisions
        4, 5 et 6 mais Subversion marque votre copie de travail
        de <filename>Makefile</filename> comme étant à la révision 6
        pour indiquer qu'elle est à jour. Ainsi, quand vous effectuez
        une mise à jour au niveau de la racine de votre copie de
        travail, celle-ci correspond en général à une révision
        donnée du dépôt.</para>

    </sect2>


    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.track-repos">
      <title>Les copies de travail suivent l'évolution du dépôt</title>

      <para>Pour chaque fichier d'un répertoire de travail, Subversion
        enregistre deux informations essentielles dans la zone
        administrative <filename>.svn/</filename>&nbsp;:</para>

      <itemizedlist>
        <listitem>
          <para>la révision sur laquelle votre fichier de travail est
          basé (qui est appelée la <firstterm>révision de
          travail</firstterm> du fichier) et</para>
        </listitem>

        <listitem>
          <para>la date et l'heure de la dernière mise à jour de la
          copie locale depuis le dépôt</para>
        </listitem>
      </itemizedlist>

      <para>À partir de ces informations, en dialoguant avec le dépôt,
        Subversion est capable de déterminer dans lequel des quatre
        états suivants se trouve un fichier de travail&nbsp;:</para>

      <variablelist>
        <varlistentry>
          <term>Inchangé et à jour</term>

          <listitem>
            <para>Le fichier est inchangé dans le répertoire de
              travail et aucune modification de ce fichier n'a été
              propagée vers le dépôt depuis sa révision de travail. Un
              appel à <command>svn commit</command> sur le fichier ne
              fera rien, un appel à <command>svn update</command> sur
              le fichier ne fera rien non plus.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Modifié localement et à jour</term>

          <listitem>
            <para>Le fichier a été modifié dans le répertoire de
              travail et aucune modification du fichier n'a été
              propagée dans le dépôt depuis la dernière mise à jour.
              Il existe des modifications locales qui n'ont pas été
              propagées vers le dépôt, donc un appel à
              <command>svn commit</command> sur le fichier permettra
              de publier vos modifications et un appel à
              <command>svn update</command> ne fera rien.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Inchangé et périmé</term>

          <listitem>
            <para>Le fichier n'a pas été modifié dans le répertoire
              de travail mais a changé dans le dépôt. Le fichier
              devra être mis à jour à un moment ou à un autre, pour
              l'amener au niveau de la dernière révision publique.
              Un appel à <command>svn commit</command> sur le
              fichier ne fera rien et un appel à
              <command>svn update</command> incorporera les dernières
              modifications dans votre copie de travail.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Modifié localement et périmé</term>

          <listitem>
            <para>Le fichier a été modifié à la fois dans le
              répertoire de travail et dans le dépôt. Un appel
              à <command>svn commit</command> sur le fichier va
              échouer, renvoyant comme erreur <quote>Périmé</quote>
              (<quote>out-of-date</quote> en anglais). Le fichier doit
              d'abord être mis à jour&nbsp;; un appel à
              <command>svn update</command> va tenter de fusionner
              les modifications publiques avec les modifications
              locales. Si Subversion ne parvient pas à réaliser
              automatiquement cette fusion de manière crédible, il va
              laisser à l'utilisateur la tâche de résoudre le
              conflit.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Tout ceci peut sembler compliqué à gérer mais la
        commande <command>svn status</command> vous indique dans
        quel état se trouve n'importe quel élément de votre copie de
        travail. Pour plus d'informations sur cette commande,
        référez-vous à <xref
        linkend="svn.tour.cycle.examine.status" />.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.mixedrevs">
      <title>Copies de travail mixtes, à révisions mélangées</title>

      <para>Un principe général de Subversion est d'être aussi
        flexible que possible. Un type particulier de flexibilité est
        la capacité d'avoir une copie de travail contenant des fichiers
        et des répertoires avec un mélange de différents numéros de
        révision. Malheureusement, cette flexibilité a tendance à
        embrouiller un certain nombre de nouveaux utilisateurs.
        Si l'exemple précédent contenant des révisions mixtes vous
        laisse perplexe, voici une amorce d'explication à la fois sur
        les raisons pour lesquelles cette fonctionnalité existe et sur
        la façon de l'utiliser.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.in-action.mixedrevs.update-commit">
        <title>Mises à jour et propagation sont deux choses
          distinctes</title>

        <para>Une des règles fondamentales de Subversion est que
          l'action de <quote>pousser</quote> ne déclenche pas une
          action de <quote>tirer</quote>, ni l'inverse. Le simple fait
          que vous soyez prêt à soumettre vos nouvelles modifications
          au dépôt ne veut pas dire que vous êtes prêts à recevoir
          les modifications d'autres personnes. Et si vous avez de
          nouvelles modifications encore en cours, alors
          <command>svn update</command> fusionne élégamment les
          changements du dépôt avec les vôtres, plutôt que de vous
          forcer à les publier.</para>

        <para>Le principal effet secondaire de cette règle est que la
          copie de travail a de la comptabilité supplémentaire à
          effectuer pour suivre les mélanges de révision et également
          être tolérante vis-à-vis de l'ensemble. Cela est rendu
          encore plus difficile par le fait que les répertoires
          eux-mêmes sont suivis en versions.</para>

        <para>Par exemple, supposons que vous ayez une copie de travail
          qui soit intégralement à la révision 10. Vous éditez le
          fichier <filename>truc.html</filename> et réalisez ensuite
          un <command>svn commit</command> qui crée la révision 15
          dans le dépôt. Après que la propagation ait réussi, nombreux
          sont ceux parmi les nouveaux utilisateurs qui s'attendraient
          à ce que toute la copie de travail soit à la révision 15,
          mais ce n'est pas le cas&nbsp;! Un certain nombre de
          modifications ont pu avoir lieu dans le dépôt entre les
          révisions 10 et 15. Le client ne sait rien de ces changements
          qui ont été apportés au dépôt, puisque vous n'avez pas encore
          exécuté la commande <command>svn update</command> et la
          commande <command>svn commit</command> ne récupère pas les
          nouvelles modifications. D'un autre côté, si la commande
          <command>svn commit</command> téléchargeait automatiquement
          les modifications les plus récentes, alors il serait
          possible d'avoir toute la copie de travail à la révision
          15 mais, dans ce cas, nous enfreindrions la règle
          fondamentale selon laquelle <quote>pousser</quote> et
          <quote>tirer</quote> doivent demeurer des actions
          distinctes. Ainsi, la seule chose que le client Subversion
          peut faire en toute sécurité est de marquer le fichier
          <filename>truc.html</filename>, et lui seulement, comme étant
          à la révision 15. Le reste de la copie de travail reste à la
          révision 10. Seule l'exécution de la commande
          <command>svn update</command> permet de récupérer les
          dernières modifications et de marquer la copie de travail
          comme étant à la révision 15.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.in-action.mixedrevs.normal">
        <title>Des révisions mélangées sont normales</title>

        <para>Le fait est qu' <emphasis>à chaque fois</emphasis> que
          vous exécutez la commande <command>svn commit</command>,
          votre copie de travail se retrouve composée d'un mélange de
          révisions. Les éléments que vous venez juste de propager
          sont marqués comme ayant un numéro de révision plus élevé
          que tous les autres. Après plusieurs propagations (sans
          mise à jour entre-temps), votre copie de travail va contenir
          tout un mélange de révisions. Même si vous êtes la seule
          personne à utiliser le dépôt, vous constaterez quand même
          ce phénomène. Pour étudier votre propre mélange de révisions
          de travail, utilisez la commande
          <command>svn status</command> avec l'option
          <option>--verbose</option> (voir <xref
          linkend="svn.tour.cycle.examine.status"/> pour plus
          d'informations).</para>

        <para>Souvent, les nouveaux utilisateurs n'ont pas du tout
          conscience que leur copie de travail contient des révisions
          mélangées. Cela peut être déroutant car beaucoup de
          commandes client sont sensibles à la révision de travail de
          l'élément qu'elles examinent. Par exemple, la commande
          <command>svn log</command> est utilisée pour afficher
          l'historique des modifications d'un fichier ou d'un
          répertoire (cf. <xref linkend="svn.tour.history.log"/>).
          Lorsque l'utilisateur appelle cette commande sur un objet
          de la copie de travail, il s'attend à obtenir l'historique
          complet de celui-ci. Mais si la révision de travail de
          l'objet est assez ancienne (souvent parce que
          <command>svn update</command> n'a pas été lancé depuis
          un certain temps), alors c'est l'historique de
          l'<emphasis>ancienne</emphasis> version de l'objet qui est
          affiché.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.in-action.mixedrevs.useful">
        <title>Un mélange de révisions est utile</title>

        <para>Si votre projet est suffisamment complexe, vous allez
          découvrir qu'il est parfois pratique d'effectuer un
          <firstterm>retour en arrière</firstterm> forcé
          (c'est-à-dire de faire une mise à jour vers une
          version plus ancienne que celle que vous avez déjà) sur
          certaines parties de votre copie de travail vers des
          révisions plus anciennes&nbsp;; vous apprendrez comme le faire
          dans le <xref linkend="svn.tour"/>. Vous avez peut-être envie
          de tester une version précédente d'un sous-module contenu
          dans un sous-répertoire ou bien de comprendre comment un
          bogue est apparu pour la première fois dans un fichier
          donné. C'est le côté
          <quote>machine à voyager dans le temps</quote> d'un
          logiciel de gestion de versions, la fonctionnalité qui vous
          permet de déplacer n'importe quelle partie de votre copie
          de travail en avant ou en arrière dans le temps.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.in-action.mixedrevs.limits">
        <title>Les mélanges de révisions ont des limites</title>

        <para>Quelle que soit la façon dont vous utilisez les
          mélanges de révision dans votre copie de travail, il existe
          des limites à cette flexibilité.</para>

        <para>Premièrement, vous ne pouvez pas propager la
          suppression d'un fichier ou d'un répertoire qui n'est pas
          complètement à jour. Si une version plus récente de
          l'élément existe dans le dépôt, votre tentative de
          suppression est rejetée, afin de vous empêcher de détruire
          accidentellement des modifications dont vous n'aviez pas
          encore connaissance.</para>

        <para>Deuxièmement, vous ne pouvez propager la modification
          des métadonnées d'un répertoire que si celui-ci est
          complètement à jour. Vous apprendrez comment associer des
          <quote>propriétés</quote> à des éléments dans le
          <xref linkend="svn.advanced"/>. La révision de travail d'un
          répertoire définit un ensemble précis d'entrées et de
          propriétés et propager la modification d'une propriété
          d'un répertoire périmé risquerait de détruire des
          propriétés dont vous n'aviez pas encore connaissance.</para>

      </sect3>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.summary">
    <title>Résumé</title>

    <para>Nous avons couvert un certain nombre de concepts
      fondamentaux de Subversion dans ce chapitre&nbsp;:</para>

    <itemizedlist>
      <listitem>
        <para>Nous avons introduit les notions de dépôt central, de
          copie de travail du client et d'ensemble des révisions de
          l'arborescence du dépôt.</para>
      </listitem>

      <listitem>
        <para>Nous avons vu quelques exemples simples de la façon
          dont deux collaborateurs peuvent utiliser Subversion pour
          publier et recevoir des modifications en provenance l'un de
          l'autre, en utilisant le modèle
          <quote>copier-modifier-fusionner</quote>.</para>
      </listitem>

      <listitem>
        <para>Nous avons évoqué la façon dont Subversion suit et gère
          les informations dans une copie de travail.</para>
      </listitem>

    </itemizedlist>

    <para>À présent, vous avez probablement une bonne idée générale
      de la façon dont Subversion fonctionne. Armé de cette
      connaissance, vous devez désormais être prêt à passer au
      chapitre suivant qui traite en détail des commandes et des
      fonctionnalités de Subversion.</para>

  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
