<chapter id="svn.advanced">
  <title>Sujets avancés</title>

  <para>Si vous lisez ce livre chapitre par chapitre, du début à la fin, 
    vous avez acquis maintenant suffisamment de connaissance du 
    fonctionnement de Subversion pour effectuer les opérations les plus 
    courantes de gestion de versions. Vous savez comment extraire une 
    copie de travail du dépôt Subversion. Vous n'avez aucune difficulté 
    à propager vos modifications et à recevoir des mises à jour en 
    utilisant les commandes <command>svn commit</command> et 
    <command>svn update</command> Vous avez probablement acquis le 
    réflexe, presque inconscient, de lancer la commande 
    <command>svn status</command>. Bref, vous êtes apte à utiliser 
    Subversion dans un environnement normal pour tout type de 
    projet.</para>

  <para>Mais les fonctionnalités de Subversion ne s'arrêtent pas aux 
    <quote>opérations courantes de gestion de versions</quote>. Il 
    possède d'autres atouts en plus de permettre le partage de fichiers 
    et de répertoires depuis un dépôt central.</para>
 
  <para>Ce chapitre dévoile certaines fonctionnalités de Subversion qui, 
    bien qu'importantes, ne sont pas d'une utilisation quotidienne pour 
    un utilisateur normal. Nous supposerons que vous êtes familier avec 
    les possibilités de base de gestion de versions sur les fichiers et 
    répertoires. Sinon, reportez-vous au <xref linkend="svn.basic" /> 
    et au <xref linkend="svn.tour" />. Une fois que vous maîtriserez ces 
    bases et que vous aurez assimilé ce chapitre, vous serez un 
    super-utilisateur de Subversion&nbsp;!</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.revs.specifiers">
    <title>Identifiants de révision</title>

    <para>Comme vous avez pu le constater dans 
      <xref linkend="svn.basic.in-action.revs"/>, les numéros de 
      révision dans Subversion sont d'une grande simplicité, formant une 
      suite d'entiers incrémentés au fur et à mesure des changements 
      propagés dans le dépôt. Néanmoins, il ne faudra pas longtemps 
      avant que vous ne puissiez plus vous rappeler exactement quel 
      changement correspond à quelle révision. Heureusement, le 
      fonctionnement normal de Subversion ne requiert pas souvent que 
      vous fournissiez explicitement un numéro de révision pour une 
      opération. Pour les opérations qui nécessitent 
      <emphasis>vraiment</emphasis> un numéro de révision, vous pouvez 
      fournir un numéro de révision que vous avez vu soit dans un mail 
      de propagation, soit dans la sortie d'une autre opération 
      Subversion, soit dans un autre contexte qui donnait du sens à ce 
      numéro particulier.</para>

    <para>Occasionnellement, vous aurez besoin d'identifier un moment 
      précis pour lequel vous n'avez pas de numéro de révision en tête 
      ou sous la main. C'est pourquoi, en plus des numéros de révision,
      <command>svn</command> accepte également en entrée d'autres 
      formats d'appellations pour les révisions&nbsp;: les 
      <firstterm>mots-clés de révision</firstterm> et les dates de
      révision.</para>

    <note>
      <para>Les différentes formes d'appellations pour les révisions 
        peuvent être mélangées et comparées pour définir des intervalles 
        de révisions. Par exemple, vous pouvez spécifier <option>-r
        <replaceable>REV1</replaceable>:<replaceable>REV2</replaceable></option>
        où <replaceable>REV1</replaceable> est un mot-clé de révision et
        <replaceable>REV2</replaceable> est un numéro de révision, ou
        alors <replaceable>REV1</replaceable> est une date et
        <replaceable>REV2</replaceable> est un numéro de révision. Comme 
        chaque appellation de révision est évaluée indépendamment, vous 
        pouvez placer n'importe quel type d'appellation de chaque côté 
        du symbole deux-points.</para>
    </note>
    
    <!-- =============================================================== -->
    <sect2 id="svn.tour.revs.keywords">
      <title>Mots-clés de révision</title>
      
      <indexterm>
        <primary>Révisions</primary>
        <secondary>Mots-clés de révision</secondary>
      </indexterm>
      <indexterm>
        <primary>HEAD</primary>
      </indexterm>
      <indexterm>
        <primary>BASE</primary>
      </indexterm>
      <indexterm>
        <primary>COMMITTED</primary>
      </indexterm>
      <indexterm>
        <primary>PREV</primary>
      </indexterm>

      <para>Le client Subversion accepte toute une variété de mots-clés 
        de révision. En tant qu'argument de l'option 
        <option>--revision</option>(<option>-r</option>) ces mots-clés 
        peuvent être utilisés en lieu et place des numéros et sont 
        remplacés par les numéros correspondants par 
        Subversion&nbsp;:</para>

      <variablelist>
        
        <varlistentry>
          <term><literal>HEAD</literal></term>
          <listitem>
            <para>La dernière (ou plus récente) révision présente dans 
              le dépot.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><literal>BASE</literal></term>
          <listitem>
            <para>Le numéro de révision d'un élément de la copie de 
              travail. Si l'élément a été modifié localement, la 
              <quote>version BASE</quote> fait référence à l'élément tel 
              qu'il était sans ces modifications locales.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><literal>COMMITTED</literal></term>
          <listitem>
            <para>La révision la plus récente avant (ou égale à) 
              <literal>BASE</literal>, dans laquelle un élément a changé.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><literal>PREV</literal></term>
          <listitem>
            <para>La révision <emphasis>précédant</emphasis> immédiatement 
              la dernière révision dans laquelle un élément a changé. 
              Techniquement, cela revient à 
              <literal>COMMITTED</literal>&minus;1.</para>
          </listitem>
        </varlistentry>
        
      </variablelist>

      <para>Comme vous pouvez le deviner d'après leur description, les 
        mots-clés de révision <literal>PREV</literal>, 
        <literal>BASE</literal>, et <literal>COMMITTED</literal> ne sont 
        utilisés que pour faire référence à un chemin dans la copie de 
        travail&nbsp;; ils ne s'appliquent pas à des URL du dépôt. En 
        revanche,<literal>HEAD</literal> peut être utilisé avec les deux 
        types de chemin (local ou URL du dépôt).</para>
      
      <para>Vous trouverez ci-dessous des exemples de l'utilisation de 
        ces mots-clés&nbsp;:</para>
      
      <screen>
$ svn diff -r PREV:COMMITTED machin.c
# affiche le dernier changement propagé concernant machin.c 

$ svn log -r HEAD
# affiche le message associé à la dernière propagation dans le dépôt.

$ svn diff -r HEAD
# compare votre copie de travail (avec tous ses changements locaux) 
# à la dernière version de l'arborescence correspondante du dépôt. 

$ svn diff -r BASE:HEAD machin.c
# compare la version non modifiée localement de machin.c avec la dernière 
# version de machin.c dans le dépôt.

$ svn log -r BASE:HEAD
# affiche, pour le répertoire versionné courant, les messages de propagation depuis 
# la dernière mise à jour (svn update)

$ svn update -r PREV machin.c
# revient une version en arrière pour le fichier machin.c 
# Ceci diminue de un la révision de la version de travail du fichier machin.c

$ svn diff -r BASE:14 machin.c
# compare la version non modifiée localement de machin.c avec 
# la version de ce fichier à la révision 14 

</screen>
      
    </sect2>
    
    <!-- =============================================================== -->
    <sect2 id="svn.tour.revs.dates">
      <title>Dates de révision</title>
      
      <indexterm>
        <primary>Révisions</primary>
        <secondary>dates de révisions</secondary>
      </indexterm>

      <para>Les numéros de révision n'ont aucune signification en dehors 
        du système de gestion de versions. Cependant, parfois, vous aurez 
        besoin d'associer une date réelle à un moment précis de 
        l'historique des versions. Pour ça, l'option 
        <option>--revision</option>(<option>-r</option>) accepte comme 
        argument une date placée entre accolades (<literal>{</literal> et
        <literal>}</literal>). Subversion accepte les dates et les heures 
        aux formats définis dans le standard ISO-8601, et quelques autres 
        formats. Voici quelques exemples (n'oubliez pas de mettre les 
        dates qui contiennent des espaces entre 
        guillemets)&nbsp;:</para>

      <screen>
$ svn checkout -r {2006-02-17}
$ svn checkout -r {15:30}
$ svn checkout -r {15:30:00.200000}
$ svn checkout -r {"2006-02-17 15:30"}
$ svn checkout -r {"2006-02-17 15:30 +0230"}
$ svn checkout -r {2006-02-17T15:30}
$ svn checkout -r {2006-02-17T15:30Z}
$ svn checkout -r {2006-02-17T15:30-04:00}
$ svn checkout -r {20060217T1530}
$ svn checkout -r {20060217T1530Z}
$ svn checkout -r {20060217T1530-0500}
&hellip;
</screen>
      
      <para>Quand vous spécifiez une date, Subversion convertit cette 
        date vers le numéro de révision le plus récent du dépôt à la 
        date spécifiée. Puis, il continue son travail avec ce numéro de 
        révision&nbsp;:</para>
        
      <screen>
$ svn log -r {2006-11-28}
------------------------------------------------------------------------
r12 | ira | 2006-11-27 12:31:51 -0600 (lun. 27 Nov. 2006) | 6 lignes
&hellip;
</screen>
        
      <sidebar>
        <title>Subversion retarde-t-il d'une journée&nbsp;?</title>
        
        <para>Si vous spécifiez une date de révision sans préciser 
          l'heure (par exemple <literal>2006-11-27</literal>), vous 
          pourriez penser que Subversion vous donnera la dernière 
          révision qui a eu lieu le 27 novembre. En fait, vous aurez une 
          révision datant du 26, voire même avant. Souvenez-vous que 
          Subversion renvoie <emphasis>la révision la plus récente du 
          dépôt</emphasis> à la date spécifiée. Si vous spécifiez une 
          date sans préciser l'heure, comme <literal>2006-11-27</literal>, 
          Subversion utilise alors 00h00 comme heure, et la recherche de 
          la plus récente révision ne renverra donc pas de résultat 
          correspondant au 27 novembre.</para>

        <para>Si vous voulez inclure le 27 dans votre recherche, vous 
          pouvez soit spécifier une heure (<literal>{"2006-11-27
          23:59"}</literal>), soit simplement spécifier le jour suivant
          (<literal>{2006-11-28}</literal>).</para>
        
      </sidebar>
      
      <para>Vous pouvez également utiliser des intervalles de dates. 
        Subversion trouvera alors les révisions incluses entre ces deux 
        dates&nbsp;:</para>
      
      <screen>
$ svn log -r {2006-11-20}:{2006-11-29}
&hellip;
</screen>
        
      <warning>
        <para>Puisque l'horodatage d'une révision est stocké comme une 
          propriété modifiable et non suivi en versions de la révision 
          (reportez-vous à <xref linkend="svn.advanced.props" />), les 
          horodatages peuvent être changés et ne pas refléter la 
          chronologie réelle. Ils peuvent même être tous supprimés. Or 
          la capacité de Subversion à convertir correctement les dates 
          en numéros de révision dépend des horodatages de révisions et 
          de leur ordonnancement correct dans le temps&nbsp;: à une 
          révision antérieure correspond un horodatage antérieur. Si cet 
          ordonnancement n'est pas maintenu, il y a de grandes chances 
          que l'utilisation des dates pour spécifier des intervalles de 
          révisions dans votre dépôt ne fournisse pas les résultats 
          attendus.</para>
      </warning>
        
    </sect2>
      
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.props">
    <title>Propriétés</title>
    <indexterm>
      <primary>propriétés</primary>
    </indexterm>

    <para>Nous avons vu en détail comment Subversion stocke et récupère 
      les différentes versions des fichiers et répertoires dans le dépôt. 
      Des chapitres entiers ont décrit cette fonctionnalité fondamentale 
      de l'outil. Et si la gestion de versions se limitait à ça, 
      Subversion couvrirait déjà complètement les besoins attendus.</para>

    <para>Mais ce n'est pas tout.</para>

    <para>En plus de gérer les versions de vos répertoires et de vos 
      fichiers, Subversion fournit une interface pour ajouter, modifier 
      et supprimer des méta-données suivies en versions pour chacun de 
      vos répertoires et de vos fichiers. On appelle ces méta-données 
      des <firstterm>propriétés</firstterm>. Elles peuvent être pensées 
      comme des tableaux à deux colonnes, qui associent des noms de 
      propriétés à des valeurs arbitraires, pour chaque élément de votre 
      copie de travail. En termes simples, vous pouvez assigner n'importe 
      quel nom et n'importe quelle valeur à vos propriétés, à la seule 
      condition que le nom doit être un texte lisible par un humain. Et 
      l'atout principal de ces propriétés réside dans le fait qu'elles 
      sont également suivies en versions, tout comme le contenu textuel 
      de vos fichiers. Vous pouvez modifier, propager et revenir en 
      arrière sur les propriétés aussi facilement que sur le contenu des 
      fichiers. L'envoi et la réception des changements concernant les 
      propriétés intervient lors de vos propagations et mises à 
      jour&nbsp;: vous n'avez pas à changer vos habitudes pour les 
      utiliser.</para>

    <note>
      <para>Subversion a réservé pour son propre usage les propriétés 
        dont le nom commence par <literal>svn:</literal>. Bien qu'il n'y 
        en ait seulement que quelques unes d'utilisées actuellement, 
        vous ne devriez pas créer vos propres propriétés avec un nom 
        commençant par ce préfixe. Sinon, vous courrez le risque qu'une 
        future version de Subversion définisse une propriété ayant le 
        même nom mais avec un usage tout autre.</para>
    </note>

    <para>Les propriétés sont aussi présentes ailleurs dans Subversion. 
      De la même manière que pour les fichiers et répertoires, chaque 
      révision en tant que telle peut avoir des propriétés arbitraires 
      associées. Les mêmes contraintes s'appliquent&nbsp;: nom lisible 
      par un humain et valeur arbitraire, éventuellement binaire. La 
      différence principale est que les propriétés des révisions ne sont 
      pas suivies en versions. Autrement dit, si vous changez la valeur 
      ou si vous supprimez une propriété d'une révision, il n'y a pas 
      moyen, en utilisant Subversion, de revenir à la valeur 
      précédente.</para>

    <para>Subversion ne fournit pas de recommandation précise quant à 
      l'utilisation des propriétés. Il demande seulement de ne pas 
      utiliser de nom de propriété qui commence par le préfixe 
       <literal>svn:</literal>. C'est l'espace de noms qu'il garde pour 
       son propre usage. Et Subversion utilise bien lui-même les 
       propriétés, suivies en versions ou pas. Certaines propriétés 
       suivies en versions ont une signification particulière ou des 
       effets particuliers quand elles font référence à un fichier ou à 
       un répertoire, ou stockent des informations relatives à la 
       révision à laquelle elles font référence. Certaines propriétés de 
       révision sont automatiquement rattachées à une révision par la 
       procédure de propagation et stockent des informations relatives à 
       cette révision. La plupart de ces propriétés sont mentionnées 
       ailleurs dans ce chapitre ou dans d'autres chapitres comme faisant 
       partie de sujets plus généraux. Pour une liste exhaustive des 
       propriétés pré-définies de Subversion, référez-vous à 
       <xref linkend="svn.ref.properties" />.</para>

    <para>Dans cette section, nous examinerons l'utilité des propriétés, 
      à la fois pour l'utilisateur et pour Subversion lui-même. Vous 
      apprendrez les sous-commandes <command>svn</command> relatives aux 
      propriétés et comment la modification des propriétés change votre 
      manière habituelle d'utiliser Subversion.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.why">
      <title>Pourquoi des propriétés&nbsp;?</title>

      <para>&Agrave; l'instar de Subversion, qui utilise les propriétés 
        pour stocker des méta-données sur les fichiers, les répertoires 
        et les révisions qu'il gère, vous pourriez faire une utilisation 
        similaire des propriétés. Vous pourriez trouver utile d'avoir un 
        endroit, près de vos données suivies en versions, pour stocker 
        des méta-données relatives à vos données.</para>

      <para>Imaginons que vous vouliez créer un site Web qui héberge 
        beaucoup de photos et qui les affiche avec une légende et une 
        date. D'accord, mais votre collection de photos change constamment, 
        donc vous voudriez automatiser le plus possible la gestion du 
        site. Ces photos peuvent être relativement volumineuses et vous 
        voulez pouvoir fournir des miniatures à vos visiteurs, comme 
        c'est généralement le cas sur ce genre de sites.</para>

      <para>Certes, vous pouvez le faire en utilisant des fichiers 
        traditionnels. C'est-à-dire que vous aurez votre 
        <filename>image123.jpg</filename> et une 
        <filename>image123-thumbnail.jpg</filename> côte à côte dans un 
        répertoire. Ou, si vous voulez garder les mêmes noms de fichier, 
        vous placerez vos miniatures dans un répertoire différent, comme 
        <filename>thumbnails/image123.jpg</filename>.  Vous pouvez 
        également stocker vos légendes et dates de la même façon, 
        séparées encore une fois du fichier image original. Mais le 
        problème est que votre collection de fichiers s'agrandit de 
        plusieurs fichiers à chaque nouvelle photo ajoutée au 
        site.</para>

      <para>Maintenant, considérons le même site Web conçu en utilisant 
        les propriétés des fichiers fournies par Subversion. Imaginez un 
        simple fichier image, <filename>image123.jpg</filename>, et un 
        ensemble de propriétés relatives à ce fichier nommées 
        <literal>légende</literal>,<literal>date</literal> et même 
        <literal>miniature</literal>. Maintenant, le répertoire de votre 
        copie de travail se gère beaucoup plus facilement&nbsp;; en fait, 
        vu du navigateur, il semble ne contenir que des images. Mais vos 
        scripts d'automatisation vont plus loin&nbsp;: ils savent qu'ils 
        peuvent utiliser les commandes <command>svn</command> (ou mieux, 
        ils peuvent utiliser les connecteurs spécifiques au langage 
        utilisé, voir <xref linkend="svn.developer.usingapi" />) pour 
        extraire les informations dont votre site a besoin sans avoir à 
        lire un fichier d'index ou à jouer avec des chemins de 
        fichiers.</para>

      <note>
        <para>Bien que Subversion n'impose que peu de restrictions sur 
          les noms et les valeurs des propriétés, il n'a pas été conçu 
          pour gérer de façon optimale des valeurs de propriétés de 
          grande taille ou un grand nombre de propriétés sur un fichier 
          ou un répertoire donné. Subversion garde souvent en mémoire en 
          même temps tous les noms et valeurs de propriétés associés à 
          un élément, ce qui peut engendrer des problèmes de performance 
          lors de l'utilisation de très gros ensembles de 
          propriétés.</para>
      </note>

      <para>On utilise également fréquemment des propriétés de révisions 
        personnalisées. Une utilisation classique est d'avoir une 
        propriété qui contient un identifiant en provenance d'un autre 
        outil de gestion et de l'associer à une révision. Par exemple, 
        l'outil de gestion est utilisé pour suivre les bogues et la 
        révision corrige le bogue associé à l'identifiant. Ce peut aussi 
        être l'utilisation de noms plus conviviaux pour les 
        révisions&nbsp;: il peut être difficile de se remémorer que la 
        révision 1935 correspond à une révision qui a subi la totalité 
        des tests, alors qu'une propriété 
        <literal>resultat-des-tests</literal> avec la valeur 
        <literal>tout ok</literal> est autrement plus utile.</para>

      <sidebar>
        <title>Retrouver ses petits (ou savoir <emphasis>ne pas 
          utiliser</emphasis> les propriétés)</title>

        <para>Bien que très utiles, les propriétés Subversion, ou plus 
          exactement les interfaces disponibles pour y accéder, ont une 
          lacune majeure&nbsp;: alors qu'il est très simple de
          <emphasis>définir</emphasis> une propriété personnalisée, la 
          <emphasis>retrouver</emphasis> plus tard est une toute autre 
          affaire.</para>

        <para>Trouver une propriété de révision personnalisée implique 
          généralement d'effectuer un parcours linéaire de toutes les 
          révisions du dépôt, en demandant à chacune&nbsp;:
          <quote>Avez-vous la propriété que je cherche&nbsp;?</quote>.
          Trouver une propriété personnalisée suivie en versions est 
          également difficile et implique souvent un appel récursif à 
          <command>svn propget</command> sur toute une copie de travail. 
          Dans votre situation, ce pourrait être moins pire que le 
          parcours linéaire de toutes les révisions. Mais cela laisse 
          certainement beaucoup à désirer en termes de performance et de 
          probabilité de réussite, surtout si, pour votre recherche, il 
          faut une copie de travail de la racine de votre dépôt.</para>

        <para>C'est pourquoi, vous pourriez choisir, en particulier pour 
          ce qui concerne les propriétés de révisions, de simplement 
          ajouter les méta-données au message de propagation. Par 
          exemple, utilisez une politique de formatage (idéalement 
          appliquée automatiquement par un script) conçue pour être 
          rapidement analysée à partir de la sortie de 
          <command>svn log</command>. Ainsi, il est assez fréquent de 
          voir dans Subversion des messages de propagation qui 
          ressemblent à&nbsp;:</para>

        <programlisting>
Problème(s): IZ2376, IZ1919
Corrigé par:  sally

Corrige un méchant plantage dans la fonction machin bidule
&hellip;
</programlisting>

        <para>Mais hélas, cela ne résout pas tout. Subversion ne fournit 
        pas encore de mécanisme pour gérer des modèles de messages 
        associés aux propagations, ce qui aiderait pourtant beaucoup les 
        utilisateurs à respecter le format des méta-données qu'ils 
        placent dans les messages de révision.</para>

      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.manip">
      <title>Manipuler les propriétés</title>

      <para>La commande <command>svn</command> offre différentes 
        possibilités pour ajouter ou modifier des propriétés sur les 
        fichiers et les répertoires. Pour les propriétés avec des 
        valeurs courtes, lisibles par un humain, la solution la plus 
        simple est sûrement de spécifier le nom de la propriété et sa 
        valeur en ligne de commande avec la 
        sous-commande <command>svn propset</command>&nbsp;:</para>

      <screen>
$ svn propset copyright '(c) 2006 Red-Bean Software' calc/bouton.c
Propriété 'copyright' définie sur 'calc/bouton.c'
$
</screen>
       
      <para>Mais nous avons vanté la souplesse de Subversion pour 
        spécifier les valeurs des propriétés. Ainsi, si vous envisagez 
        d'avoir des valeurs de plusieurs lignes de texte, ou même une 
        valeur binaire, la passer en ligne de commande ne vous convient 
        pas. La sous-commande <command>svn propset</command> accepte donc
        l'option <option>--file</option> (<option>-F</option>) pour 
        spécifier le nom d'un fichier qui contient la nouvelle valeur de 
        la propriété.</para>

      <screen>
$ svn propset license -F /chemin/vers/LICENCE calc/bouton.c
Propriété 'license' définie sur 'calc/bouton.c'
$
</screen>

      <para>Il y a quelques restrictions sur les noms de propriétés. Un 
        nom de propriété doit commencer par une lettre, le caractère 
        deux points (<literal>:</literal>), ou le caractère souligné
        (<literal>_</literal>)&nbsp;; ensuite, vous pouvez utiliser des 
        chiffres, des tirets (<literal>-</literal>), et des points
        (<literal>.</literal>)
          <footnote>
            <para>Pour ceux qui connaissent le XML, c'est à peu près le 
              sous-ensemble ASCII pour la syntaxe du champ "Name" en 
              XML.</para>
          </footnote>.
      </para>

      <para>En plus de la commande <command>propset</command>, 
        <command>svn</command> dispose de la commande
        <command>propedit</command>. Cette commande utilise l'éditeur de 
        texte pré-configuré (reportez-vous à <xref
        linkend="svn.advanced.confarea.opts.config" />) pour ajouter ou 
        modifier des propriétés. Quand vous exécutez la commande, 
        <command>svn</command> lance votre éditeur de texte avec un 
        fichier temporaire qui contient la valeur actuelle de la 
        propriété (ou un contenu vierge si vous ajoutez une nouvelle 
        propriété). Vous pouvez alors modifier la valeur dans l'éditeur 
        de texte pour y placer votre nouvelle valeur, sauvegarder le 
        fichier temporaire et quitter l'éditeur. Si Subversion détecte 
        que la valeur a effectivement changé, il la prend en compte. Si 
        vous quittez l'éditeur sans faire de changement, la propriété ne 
        sera pas modifiée&nbsp;:</para>

      <screen>
$ svn propedit copyright calc/bouton.c  ### sortez de l'éditeur sans faire de modification
Pas de modification de la propriété 'copyright' sur 'calc/bouton.c'
$
</screen>

      <para>Vous pouvez noter que, à l'instar des autres commandes 
        <command>svn</command>, celles relatives aux propriétés 
        fonctionnent aussi sur des chemins multiples. Vous pouvez ainsi 
        modifier les propriétés d'un ensemble de fichiers en une seule 
        commande. Par exemple, nous aurions pu taper&nbsp;:</para>

      <screen>
$ svn propset copyright '(c) 2006 Red-Bean Software' calc/*
Propriété 'copyright' définie sur 'calc/Makefile'
Propriété 'copyright' définie sur 'calc/bouton.c'
Propriété 'copyright' définie sur 'calc/entier.c'
&hellip;
$
</screen>

      <para>Toutes ces manipulations de propriétés ne seraient pas 
        vraiment utiles si vous ne pouviez pas récupérer facilement la 
        valeur d'une propriété. Subversion propose donc deux 
        sous-commandes pour afficher les noms et les valeurs des 
        propriétés stockées des fichiers et répertoires. La commande
        <command>svn proplist</command> fournit la liste des noms de 
        propriétés qui existent dans un chemin. Une fois que vous 
        connaissez les noms des propriétés d'un élément, vous pouvez 
        obtenir les valeurs correspondantes avec la commande 
        <command>svn propget</command>. Cette commande affiche sur la 
        sortie standard la valeur de la propriété dont le nom et le 
        chemin (ou l'ensemble des chemins) ont été passés en 
        paramètres.</para>

      <screen>
$ svn proplist calc/bouton.c
Propriétés sur 'calc/bouton.c':
  copyright
  license
$ svn propget copyright calc/bouton.c
(c) 2006 Red-Bean Software
$
</screen>

      <para>Il y a même une variante de la commande
        <command>proplist</command> qui liste à la fois le nom et la 
        valeur de toutes les propriétés. Ajoutez simplement l'option
        <option>--verbose</option> (<option>-v</option>) à la 
        commande&nbsp;:</para>

      <screen>
$ svn proplist -v calc/bouton.c
Propriétés sur 'calc/bouton.c':
  copyright : (c) 2006 Red-Bean Software
  license : ================================================================
Copyright (c) 2006 Red-Bean Software.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions 
are met:

1. Redistributions of source code must retain the above copyright
notice, this list of conditions, and the recipe for Fitz's famous
red-beans-and-rice.
&hellip;
</screen>

      <para>La dernière sous-commande relative aux propriétés est 
        <command>propdel</command>. Puisque Subversion vous autorise à 
        stocker des propriétés avec une valeur vide, vous ne pouvez pas 
        supprimer une propriété en utilisant <command>svn propedit</command> 
        ou <command>svn propset</command>.  Par exemple, la commande 
        suivante <emphasis>ne fournit pas</emphasis> le résultat 
        escompté&nbsp;:</para>

      <screen>
$ svn propset license  calc/bouton.c
Propriété 'license' définie sur 'calc/bouton.c'
$ svn proplist -v calc/bouton.c
Propriétés sur 'calc/bouton.c':
  copyright : (c) 2006 Red-Bean Software
  license : 
$
</screen>

      <para>Vous devez utiliser la sous-commande 
        <command>propdel</command> pour supprimer entièrement une 
        propriété. La syntaxe est similaire aux autres commandes sur les 
        propriétés&nbsp;:</para>

      <screen>
$ svn propdel license calc/bouton.c
Propriété 'license' supprimée de 'calc/bouton.c'.
$ svn proplist -v calc/bouton.c
Propriétés sur 'calc/bouton.c':
  copyright : (c) 2006 Red-Bean Software
$
</screen>

      <para>Vous souvenez-vous des propriétés de révision non suivies en 
        versions&nbsp;? Vous pouvez les modifier elles-aussi en 
        utilisant les mêmes sous-commandes <command>svn</command> que 
        nous venons de décrire. Il suffit juste d'ajouter l'option 
        <option>--revprop</option> à la ligne de commande et de spécifier 
        la révision à laquelle s'applique la modification. Puisque les 
        numéros de révisions s'appliquent à l'ensemble de l'arborescence, 
        vous n'avez pas besoin d'indiquer un chemin pour ces commandes, 
        du moment que vous êtes dans une copie de travail du dépôt 
        contenant la révision dont vous voulez modifier la propriété. 
        Autrement, vous pouvez simplement fournir n'importe quelle URL 
        du dépôt en question (y compris l'URL racine). Par exemple, 
        imaginons que vous vouliez remplacer le message associé à la 
        propagation d'une révision précédente 
        <footnote>
          <para>Corriger les fautes d'orthographe, les erreurs de 
            grammaire et les informations simplement erronnées au sein 
            des messages de propagation est peut-être le cas le plus 
            courant d'utilisation de l'option
            <option>--revprop</option>.</para>
        </footnote>.
        Si le répertoire actuel fait partie de votre copie de travail du 
        dépôt, vous pouvez simplement lancer la commande
        <command>svn propset</command> sans spécifier de 
        chemin&nbsp;:</para>

      <screen>
$ svn propset svn:log '* bouton.c: Corrige un avertissement du compilateur.' -r11 --revprop
Nouvelle valeur définie pour la propriété 'svn:log' à la révision du dépôt '11'
$
</screen>

      <para>Et même si vous n'avez pas extrait de copie de travail du 
        dépôt, vous pouvez toujours modifier la propriété en indiquant 
        l'URL racine du dépôt&nbsp;:</para>

      <screen>
$ svn propset svn:log '* bouton.c: Corrige un avertissement du compilateur.' -r11 --revprop \
              http://svn.exemple.com/depot/projet
Nouvelle valeur définie pour la propriété 'svn:log' à la révision du dépôt '11'
$
</screen>

      <para>Notez que le droit de modifier cette propriété non suivie en 
        versions doit être explicitement ajouté par l'administrateur du 
        dépôt (voir <xref linkend="svn.reposadmin.maint.setlog" />).
        En effet, la propriété n'étant pas suivie en versions, vous 
        risquez une perte d'informations si vous la modifiez à tort ou 
        à travers. L'administrateur du dépôt peut mettre en place des 
        protections contre ce type d'incident et, par défaut, la 
        modification de propriétés non suivies en versions est 
        désactivée.</para>

      <tip>
        <para>Dans la mesure du possible, il est recommandé d'utiliser 
          <command>svn propedit</command> au lieu de <command>svn
          propset</command>. Bien que le résultat soit identique, la 
          première permet de visualiser la valeur actuelle de la 
          propriété que l'on veut modifier, ce qui aide à vérifier que 
          l'on fait bien ce que l'on pense faire. C'est particulièrement 
          vrai dans le cas des propriétés non suivies en versions. Il est 
          aussi beaucoup plus facile de modifier un texte de plusieurs 
          lignes dans un éditeur de texte qu'en ligne de commande.</para>
      </tip>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.workflow">
      <title>Les propriétés et le cycle de travail Subversion</title>

      <para>Maintenant que vous êtes familier avec toutes les 
        sous-commandes <command>svn</command> relatives aux propriétés, 
        voyons comment la modification des propriétés change le cycle 
        habituel d'utilisation de Subversion. Comme mentionné 
        précédemment, les propriétés des fichiers et répertoires sont 
        suivies en versions, à l'instar du contenu des fichiers. En 
        conséquence, Subversion offre les mêmes possibilités pour 
        fusionner (proprement ou quand apparaissent des conflits) vos 
        modifications avec celles des autres collaborateurs.</para>

      <para>De même que pour le contenu des fichiers, les modifications 
        de propriétés sont locales. Elles ne deviennent permanentes que 
        quand vous les propagez dans le dépôt via 
        <command>svn commit</command>. Vos modifications sur les 
        propriétés peuvent aussi être annulées facilement&nbsp;: la 
        commande <command>svn revert</command> restaurera vos fichiers 
        et répertoires dans leur état d'avant les modifications, y 
        compris pour les propriétés. Vous pouvez également obtenir des 
        informations intéressantes sur l'état des propriétés de vos 
        fichiers et répertoires en utilisant les commandes
        <command>svn status</command> et <command>svn diff</command>.</para>

      <screen>
$ svn status calc/bouton.c
 M     calc/bouton.c
$ svn diff calc/bouton.c
Modification de propriétés sur calc/bouton.c
___________________________________________________________________
Ajouté: copyright
   + (c) 2006 Red-Bean Software

$

</screen>

      <para>Remarquez que la sous-commande <command>status</command> 
        place le <literal>M</literal> dans la deuxième colonne plutôt 
        que dans la première. C'est parce que nous avons modifié les 
        propriétés de <filename>calc/bouton.c</filename>, mais pas son 
        contenu. Si nous avions changé les deux, nous aurions vu le 
        <literal>M</literal> dans la première colonne également 
        (reportez-vous à  <xref
        linkend="svn.tour.cycle.examine.status" />).</para>

      <sidebar>
        <title>Conflits sur les propriétés</title>

        <para>De la même manière que pour les contenus des fichiers, les 
          modifications locales effectuées sur les propriétés peuvent 
          entrer en conflit avec les changements effectués par d'autres 
          collaborateurs. Si vous faites une mise à jour de votre copie 
          de travail et que vous recevez un changement incompatible avec 
          vos propres modifications d'une propriété d'un objet suivi en 
          versions, Subversion vous indiquera que l'objet est dans un 
          état de conflit.</para>
 
        <screen>
% svn update calc
M  calc/Makefile.in
 C calc/bouton.c
À la révision 143.
$ 
</screen>
         
        <para>Subversion créera également, dans le même répertoire que 
          l'objet en conflit, un fichier avec l'extension
          <filename>.prej</filename> qui contiendra les détails du 
          conflit. Vous devrez examiner le contenu de ce fichier pour 
          décider comment résoudre le conflit. Tant que le conflit ne 
          sera pas résolu, la sortie de <command>svn status</command>
          affichera un <literal>C</literal> dans la deuxième colonne pour 
          cet objet et vos tentatives de propagation échoueront.</para>

        <screen>
$ svn status calc
 C     calc/bouton.c
?      calc/bouton.c.prej
$ cat calc/bouton.c.prej 
prop 'nombre_lignes': user set to '1256', but update set to '1301'.
$
</screen>
 
        <para>Pour résoudre les conflits sur les propriétés, assurez-vous 
          simplement que les propriétés en question contiennent bien les 
          valeurs qu'elle doivent contenir, puis utilisez la commande 
          <command>svn resolved</command> pour indiquer à Subversion que 
          vous avez résolu le problème manuellement.</para>

      </sidebar>

      <para>Vous avez peut-être remarqué que Subversion affiche les 
        différences au niveau des propriétés d'une manière non standard. 
        Certes, vous pouvez toujours re-diriger la sortie de 
        <command>svn diff</command> pour créer un fichier patch 
        utilisable&nbsp;: le programme patch ignorera ce qui concerne les 
        propriétés (comme il ignore tout ce qu'il ne comprend pas). 
        Malheureusement, cela signifie aussi que pour appliquer 
        intégralement un patch généré par 
        <command>svn diff</command>, les modifications concernant les 
        propriétés doivent être faites à la main.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.auto">
      <title>Configurer des propriétés de façon automatique</title>

        <para>Les propriétés constituent une fonctionnalité très puissante 
        de Subversion, et sont un élément central de nombreuses 
        fonctionnalités de Subversion présentées ailleurs dans ce 
        chapitre et dans les autres chapitres&nbsp;: comparaisons et 
        fusions textuelles, substitution de mots-clés, transformation des 
        retours à la ligne, etc. Mais pour profiter pleinement des 
        propriétés, il faut les placer sur les répertoires et fichiers 
        adéquats. Malheureusement, cette étape peut passer à la trappe 
        dans le train-train quotidien, d'autant plus qu'oublier de 
        configurer une propriété n'engendre généralement pas une erreur 
        qui saute aux yeux (du moins comparativement à oublier d'ajouter 
        un fichier dans la gestion de versions). Pour vous aider à 
        placer vos propriétés au bon endroit, Subversion propose deux 
        fonctionnalités simples mais néanmoins utiles.</para>
      
      <para>Au moment d'introduire un fichier en suivi de versions à 
        l'aide de la commande <command>svn add</command> ou 
        <command>svn import</command>, Subversion essaie de vous aider 
        en configurant automatiquement certaines propriétés communes des 
        fichiers. D'abord, sur les systèmes d'exploitation dont le 
        système de fichiers utilise un bit <quote>exécutable</quote>, 
        Subversion ajoutera automatiquement la propriété 
        <literal>svn:executable</literal> aux nouveaux fichiers, ajoutés 
        ou importés, qui ont ce bit activé (voir <xref
        linkend="svn.advanced.props.special.executable" /> pour plus de 
        détails sur cette propriété). </para>
        
      <para>Ensuite, Subversion essaie de déterminer le type MIME du
        fichier. Si vous avez configuré le paramètre 
        <literal>mime-types-files</literal>, Subversion essaiera de 
        trouver un type MIME correspondant à l'extension du nom de 
        fichier. Si un tel type MIME existe, il définira 
        automatiquement la propriété <literal>svn:mime-type</literal> 
        avec la valeur du type trouvé. S'il ne trouve pas de type MIME
        correspondant ou s'il n'existe pas de fichier définissant les 
        correspondances, Subversion applique une heuristique très basique
        pour déterminer si le contenu du fichier est lisible par un 
        humain. Si le résultat est négatif, Subversion ajoute 
        automatiquement la propriété <literal>svn:mime-type</literal> à 
        ce fichier avec la valeur 
        <literal>application/octet-stream</literal> (type MIME générique 
        indiquant <quote>une suite d'octets</quote>). Bien sûr, si 
        Subversion se trompe, ou si vous voulez indiquer un type plus 
        précis (par exemple <literal>image/png</literal> ou 
        <literal>application/x-shockwave-flash</literal>), vous pouvez 
        toujours supprimer ou modifier cette propriété. (Pour d'avantage 
        d'informations sur la gestion des types MIME par Subversion, 
        reportez vous à  <xref
        linkend="svn.advanced.props.special.mime-type" /> plus loin dans
        ce chapitre).</para>

      <para>Subversion fournit également, via sa zone de configuration 
        (voir <xref linkend="svn.advanced.confarea" />), une fonction de 
        renseignement automatique des propriétés plus flexible, qui vous 
        permet de créer des associations entre d'une part des motifs de 
        noms de fichiers et d'autre part des noms de 
        propriétés&nbsp;/&nbsp;valeurs de propriétés. Là encore, ces 
        associations modifient le comportement des commandes 
        <command>add</command> et <command>import</command>, pouvant non 
        seulement passer outre la décision prise par défaut d'attribution 
        d'une propriété de type MIME, mais pouvant aussi définir d'autres 
        propriétés, qu'elles soient utilisées par Subversion ou 
        personnalisées. Par exemple, vous pouvez créer une association 
        qui, à chaque ajout d'un fichier JPEG (c'est-à-dire dont le nom 
        est du type <literal>*.jpg</literal>) fixe la propriété 
        <literal>svn:mime-type</literal> de ce fichier à la valeur 
        <literal>image/jpeg</literal>.  Ou alors, tout fichier de type
        <literal>*.cpp</literal> se verra affecter la propriété
        <literal>svn:eol-style</literal> avec la valeur
        <literal>native</literal>, et la propriété 
        <literal>svn:keywords</literal> la valeur
        <literal>Id</literal>. L'affectation automatique de propriétés 
        est sûrement l'outil de manipulation des propriétés le plus 
        commode de tout Subversion. Reportez-vous à <xref
        linkend="svn.advanced.confarea.opts.config"/> pour plus 
        d'informations sur la configuration de cette fonction.</para>

    </sect2>     
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.props.file-portability">
    <title>Portabilité des fichiers</title>

    <para>Heureusement pour les utilisateurs de Subversion qui 
      travaillent sur différents ordinateurs et systèmes d'exploitation, 
      le comportement du programme en ligne de commande est pratiquement 
      identique sur tous les systèmes. Si vous vous débrouillez avec 
      <command>svn</command> sur un système, vous devriez vous en sortir 
      sur n'importe quel système.</para>

    <para>Cependant, ce n'est pas toujours le cas pour d'autres types de 
      logiciels ou pour les fichiers que vous gérez dans Subversion. Par 
      exemple, sur un système Windows, la définition d'un 
      <quote>fichier texte</quote> est similaire à la définition de 
      Linux, mais avec une différence notable pour ce qui concerne les 
      retours à la ligne. Il y a aussi d'autres différences. Les 
      plateformes Unix (et Subversion) supportent la notion de lien 
      symbolique&nbsp;; Windows non. Les plateformes Unix utilisent les 
      permissions du fichier pour déterminer si un fichier est 
      exécutable&nbsp;; Windows utilise l'extension du fichier.</para>

    <para>Subversion n'a pas la possibilité d'unifier toutes ces 
      définitions et ces implémentations. Tout ce qu'il peut faire, c'est 
      aider au maximum l'utilisateur qui travaille sur plusieurs systèmes 
      et plusieurs ordinateurs. Cette section décrit comment Subversion 
      s'y prend.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.special.mime-type">
      <title>Type de contenu des fichiers</title>
      
      <para>Subversion fait partie des nombreuses applications qui 
        reconnaissent et utilisent les types MIME (Multipurpose Internet 
        Mail Extensions). Ainsi, la valeur de la propriété 
        <literal>svn:mime-type</literal> permet, en plus de stocker le 
        type de contenu d'un fichier, de changer le comportement de 
        Subversion lui-même.</para>

      <sidebar>
        <title>Identifier les types de fichiers</title>
    
        <para>Beaucoup de programmes sur les systèmes d'exploitation 
          modernes font des suppositions sur le type et le format du 
          contenu d'un fichier à partir de son nom, notamment son 
          extension. Par exemple, les fichiers qui se terminent par
          <filename>.txt</filename> sont généralement considérés comme 
          lisibles par un être humain, aptes à être compris pratiquement 
          tels quels, sans nécessiter un processus de décodage compliqué. 
          Les fichiers dont le nom se termine par 
          <filename>.png</filename>, en revanche, sont considérés comme 
          des fichiers du type "Portable Network Graphics", illisibles 
          pour un être humain, et utilisables uniquement au travers d'un 
          logiciel qui comprend le format PNG pour pouvoir l'afficher en 
          tant qu'image matricielle.</para>

        <para>Malheureusement, certaines de ces extensions ont changé de 
          sens au fil du temps. Au début des ordinateurs personnels, un 
          fichier <filename>LISEZMOI.DOC</filename> aurait 
          certainement été un simple fichier texte, comme aujourd'hui les 
          fichiers <filename>.txt</filename>. Mais, rendu au milieu des 
          années 1990, vous pouvez parier que ce fichier ne serait plus 
          un simple fichier texte, mais un document "Microsoft Word", 
          format propriétaire et illisible pour un être humain. Ce 
          changement n'a pas eu lieu du jour au lendemain et il y a eu 
          une période de confusion pour les utilisateurs qui, lorsqu'ils 
          tombaient sur un fichier <filename>.doc</filename>, ne savaient 
          pas trop de quel type était ce fichier
          <footnote>
            <para>Ca vous semble dur&nbsp;? Et bien, à la même période, 
              WordPerfect utilisait aussi <filename>.DOC</filename> 
              comme extension préférée de son format de fichier 
              propriétaire&nbsp;!</para>
          </footnote>.
        </para>

        <para>L'essor des réseaux informatiques n'a fait qu'ajouter à la 
          confusion sur la relation entre le nom d'un fichier et son 
          contenu. Avec l'information circulant à travers les réseaux, 
          souvent générée dynamiquement par des programmes sur les 
          serveurs, il n'y avait plus de fichier en tant que tel, et donc
          plus de nom de fichier. Les serveurs Web, par exemple, avaient 
          besoin d'un autre moyen pour indiquer au navigateur quel type 
          de contenu il télécharge afin qu'il puisse appliquer un 
          traitement cohérent à cette information : soit afficher les 
          données à l'aide d'un programme qui sait traiter ce type de 
          contenu, soit demander à l'utilisateur où stocker les données 
          téléchargées.</para>

        <para>Finalement, un standard est apparu pour, entre autres, 
          décrire le contenu d'un flux de données. En 1996, était publiée 
          la RFC2045, la première des cinq RFC à décrire le format MIME. 
          Elle décrit le concept de types de média et de sous-types, et 
          recommande une syntaxe pour représenter ces types. Aujourd'hui, 
          les types de média MIME (ou simplement types MIME) sont 
          utilisés de manière pratiquement universelle par les clients 
          de messagerie, les serveurs Web et autres logiciels, pour 
          déterminer de manière sûre le type de contenu d'un 
          fichier.</para>

      </sidebar>
    
      <para>Par exemple, un avantage fourni par cette reconnaissance de 
        type par Subversion est la possibilité de fusion contextuelle, 
        ligne par ligne, des changements reçus lors d'une mise à jour. 
        En revanche, pour les fichiers contenant autre chose que du 
        texte, il n'y a souvent pas de concept de <quote>ligne</quote>.
        En conséquence, pour les fichiers suivis en versions dont la 
        propriété <literal>svn:mime-type</literal> contient une valeur 
        de type MIME non textuel (généralement, un intitulé qui ne 
        commence pas par <literal>text/</literal>, bien qu'il y ait des 
        exceptions), Subversion ne tente pas de fusion contextuelle 
        pendant la mise à jour. A la place, chaque fois que vous avez 
        modifié localement un fichier binaire qui a été mis à jour sur 
        le dépôt, Subversion ne touche pas à votre fichier mais crée 
        deux nouveaux fichiers. Un fichier avec l'extension
        <filename>.oldrev</filename> qui contient la version du fichier 
        à la révision BASE. Un autre fichier avec l'extension
        <filename>.newrev</filename> qui contient la version à jour du 
        fichier. Ce comportement est dicté par la volonté d'éviter que 
        l'utilisateur ne tente d'effectuer une fusion qui échouerait 
        parce que les fichiers ne peuvent tout simplement pas être 
        fusionnés.</para>

      <warning>
        <para>La propriété <literal>svn:mime-type</literal>, si elle 
          n'est pas correctement définie à une valeur qui indique un 
          contenu non textuel, peut causer des comportements inattendus.
          Par exemple, comme la <quote>fin de ligne</quote> n'a pas de 
          sens  dans un fichier binaire, Subversion vous empêchera de 
          définir la propriété  <literal>svn:eol-style</literal> sur ces
          fichiers. Cela saute aux yeux quand vous travaillez sur un seul
          fichier et que <command>svn propset</command> génère une 
          erreur. &Ccedil;a l'est beaucoup moins si vous effectuez une 
          opération récursive, où Subversion omettra silencieusement les
          fichiers qu'il considère inappropriés pour une propriété 
          donnée.</para>
      </warning>

      <para>Beginning in Subversion 1.5, users can configure a new
        <literal>mime-types-file</literal> runtime configuration
        parameter, which identifies the location of a MIME types
        mapping file.  Subversion will consult this mapping file to
        determine the MIME type of newly added and imported
        files.</para>

      <para>Par ailleurs, si la propriété <literal>svn:mime-type</literal>
        est définie, alors le greffon Apache pour Subversion utilisera 
        cette valeur pour renseigner le champ 
        <literal>Content-type:</literal> de l'en-tête HTTP en réponse à 
        une requête GET. Cela fournit une indication très importante au 
        navigateur Web pour pouvoir afficher correctement le fichier 
        quand vous l'utilisez pour parcourir le contenu du dépôt 
        Subversion.</para>

    </sect2>
  
    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.special.executable">
      <title>Fichiers exécutables ou non</title>
 
      <para>Sur beaucoup de systèmes d'exploitation, la capacité de 
        rendre un fichier exécutable dépend d'un bit dit 
        <quote>exécutable</quote>. Habituellement, ce bit est désactivé 
        par défaut et doit être explicitement activé par l'utilisateur 
        pour chaque fichier concerné. Ce serait une perte de temps 
        énorme d'avoir à se rappeler exactement quel fichier, parmi ceux 
        que l'on vient d'extraire du dépôt, doit avoir le bit exécutable 
        positionné et ensuite de devoir le faire manuellement. C'est 
        pourquoi Subversion fournit la propriété 
        <literal>svn:executable</literal> pour spécifier que le bit 
        exécutable doit être activé pour le fichier concerné. Subversion 
        s'occupe lui-même de cette tâche quand il rapatrie de tels 
        fichiers dans la copie de travail locale.</para>

      <para>Cette propriété n'a aucun effet sur les systèmes de fichiers 
        qui ne possèdent pas le concept du bit exécutable, tels que 
        FAT32 et NTFS
        <footnote>
          <para>Les systèmes de fichiers Windows utilisent les extensions 
            des fichiers (telles que
            <filename>.EXE</filename>, <filename>.BAT</filename>, et
            <filename>.COM</filename>) pour indiquer que les fichiers 
            sont exécutables.</para>
        </footnote>.
        Par ailleurs, bien qu'elle n'ait pas de valeurs définies, 
        Subversion lui attribuera la valeur <literal>*</literal> 
        lorsqu'il activera cette propriété. Enfin, cette propriété n'est 
        valide que sur des fichiers, pas sur des répertoires.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.special.eol-style">
      <title>Caractères de fin de ligne</title>

      <para>Sur un fichier suivi en versions, Subversion considère que 
        le contenu est lisible par un humain, à moins que la propriété 
        <literal>svn:mime-type</literal> n'indique le contraire. En 
        règle générale, Subversion utilise cette information pour 
        déterminer s'il est possible d'effectuer une comparaison 
        contextuelle pour ce fichier. Sinon, pour Subversion, les octets 
        sont des octets.</para>
      
      <para>Cela veut dire que par défaut, Subversion ne s'intéresse pas 
        au type de caractère utilisé pour marquer les <firstterm>fins de
        lignes</firstterm> (EOL en anglais, pour End Of Line). 
        Malheureusement, des conventions différentes sont utilisées 
        suivant les systèmes d'exploitation pour indiquer une fin de 
        ligne de texte dans un fichier. Par exemple, les logiciels sous 
        Windows utilisent généralement une paire de caractères de 
        contrôle ASCII&nbsp;: un retour chariot (<literal>CR</literal>, 
        <quote>carriage return</quote>) suivi par un saut de ligne
        (<literal>LF</literal>, <quote>line feed</quote>). Les logiciels 
        Unix, cependant, utilisent uniquement le caractère 
        <literal>LF</literal> pour indiquer les fins de lignes.</para>

      <para>Tous les programmes ne savent pas gérer les fichiers 
        utilisant un marqueur de fin de ligne <quote>exogène</quote> au
        système d'exploitation sur lequel ils tournent. Ainsi, il n'est
        pas rare de voir les programmes Unix traiter le marqueur 
        <literal>CR</literal> des fichiers Windows comme un caractère 
        normal (en affichant à l'écran un <literal>^M</literal>) et les 
        programmes Windows combiner en une seule ligne immense un fichier
        Unix parce qu'ils n'y ont pas trouvé la combinaison retour 
        chariot-passage à la ligne (<literal>CR-LF</literal>). </para>

      <para>Cette incapacité de traiter correctement les marqueurs de 
        fin de ligne d'autres plates-formes peut être assez frustrante 
        pour ceux qui partagent des fichiers entre différents systèmes 
        d'exploitation. Prenons l'exemple d'un fichier de code source 
        qui est édité par des développeurs à la fois sous Windows et 
        sous Unix. Si tous les développeurs utilisent des outils qui se 
        plient à la convention utilisée par le fichier, pas de 
        problème.</para>
        
      <para>
        Mais, en pratique, de nombreux outils largement utilisés soit ne 
        parviennent pas à lire correctement un fichier utilisant une 
        convention différente pour les fins de ligne, soit ils 
        convertissent les fins de lignes dans le format local lors de la 
        sauvegarde. Dans le premier cas, le développeur doit utiliser 
        des outils externes (tels que <command>dos2unix</command> et son 
        compagnon <command>unix2dos</command>) pour préparer le fichier 
        avant l'édition. Dans le deuxième cas, pas besoin de 
        préparation. Mais dans les deux cas, le fichier résultant 
        diffère de l'original littéralement pour toutes les lignes&nbsp;! 
        Avant de propager ses changements, l'utilisateur a deux choix. 
        Soit il utilise un utilitaire de conversion pour revenir à la 
        même convention qu'avant l'édition. Soit il propage le fichier 
        avec la nouvelle convention de fin de ligne.</para>

      <para>Au final, les deux hypothèses conduisent à une perte de 
        temps et des modifications inutiles sur les fichiers propagés. 
        La perte de temps est déjà pénible. Mais si en plus la 
        propagation change chaque ligne du fichier, trouver quelle 
        ligne a effectivement changé devient non trivial. A quel endroit 
        ce bogue a-t-il réellement été corrigé&nbsp;? Dans quelle ligne 
        y avait-il cette erreur de syntaxe&nbsp;? </para>

      <para>La solution à ce problème est la propriété 
        <literal>svn:eol-style</literal> (eol pour "End Of Line"). Quand 
        cette propriété possède une valeur valide, Subversion l'utilise 
        pour déterminer quel traitement il doit appliquer pour que le 
        fichier ne change pas de convention à chaque propagation 
        provenant d'un système d'exploitation différent. Les valeurs 
        valides sont&nbsp;:</para>

      <variablelist>
        <varlistentry>
          <term><literal>native</literal></term>
          <listitem>
            <para>Ceci force le fichier à adopter la convention 
              utilisée par le système d'exploitation sur lequel 
              s'exécute Subversion. En d'autres termes, si un 
              utilisateur d'une machine Windows récupère une copie de 
              travail d'un fichier dont la propriété
              <literal>svn:eol-style</literal> vaut 
              <literal>native</literal>, ce fichier contiendra le marqueur 
              <literal>CRLF</literal> pour indiquer les fins de ligne. 
              Un utilisateur Unix qui récupère une copie de travail qui 
              contient le même fichier verra simplement 
              <literal>LF</literal> pour indiquer les fins de ligne sur 
              sa copie.</para>

            <para>Notez que Subversion stockera en fait le fichier dans 
              le dépôt en utilisant le marqueur standard 
              <literal>LF</literal> indépendamment du système 
              d'exploitation. Cela reste toutefois tout à fait 
              transparent pour l'utilisateur.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>CRLF</literal></term>
          <listitem>
            <para>Le fichier contiendra le marqueur 
              <literal>CRLF</literal> pour indiquer les fins de ligne, 
              quel que soit le système d'exploitation.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>LF</literal></term>
          <listitem>
            <para>Le fichier contiendra le marqueur 
              <literal>LF</literal> pour indiquer les fins de ligne, 
              quel que soit le système d'exploitation.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>CR</literal></term>
          <listitem>
            <para>Le fichier contiendra le marqueur
              <literal>CR</literal> pour indiquer les fins de ligne, 
              quel que soit le système d'exploitation. Ce marqueur de fin 
              de ligne n'est pas très courant. Il était utilisé sur les 
              vieux Macintosh (machines sur lesquelles Subversion ne 
              tourne même pas).</para>
          </listitem>
        </varlistentry>
      </variablelist>
      
    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.props.special.ignore">
    <title>Ignorer les éléments non suivis en versions </title>

    <para>Dans n'importe quelle copie de travail, il y a de grandes 
      chances que les fichiers et répertoires suivis en versions côtoient 
      d'autres fichiers et répertoires non suivis en versions ou qui 
      n'ont pas lieu de l'être. Les éditeurs de texte remplissent les 
      répertoires avec des fichiers de sauvegarde. Les compilateurs 
      créent des fichiers intermédiaires (ou même des fichiers finaux) 
      que vous ne voudrez pas suivre en versions. Et les utilisateurs 
      eux-mêmes déposent des fichiers et des répertoires où bon leur 
      semble, souvent dans des copies de travail locales.</para>

    <para>Il est ridicule de penser que les copies de travail Subversion 
      échappent à ce type de méli-mélo. En fait, Subversion prend en 
      compte (c'est une <emphasis>fonctionnalité</emphasis>) dès le début 
      que les copies de travail sont des répertoires comme les autres, 
      comme ceux qui ne sont pas suivis en versions. Mais ces fichiers 
      et répertoires qui-n-ont-pas-vocation-à-être-suivis-en-versions 
      peuvent perturber les utilisateurs de Subversion. Par exemple, 
      comme les commandes <command>svn add</command> et <command>svn
      import</command> sont récursives par défaut et ne savent pas 
      quels fichiers de l'arborescence vous voulez suivre ou non en 
      versions, il est relativement facile d'ajouter au suivi de 
      versions des éléments que vous ne vouliez pas suivre. Et comme la 
      commande <command>svn status</command> traite, par défaut, tous 
      les éléments intéressants dans la copie de travail, y compris les 
      fichiers et répertoires non suivis en versions, son affichage 
      devient rapidement confus avec de tels imbroglios.</para>

    <para>C'est pourquoi Subversion fournit deux façons de lui indiquer 
      quels fichiers vous souhaitez ignorer. La première implique 
      l'utilisation de la zone de configuration (voir <xref 
      linkend="svn.advanced.confarea" />) et, par conséquent, s'applique 
      à toutes les opérations Subversion qui utilisent cette zone de 
      configuration, généralement toutes celles de l'ordinateur ou d'un 
      utilisateur particulier de l'ordinateur. L'autre façon utilise les 
      propriétés Subversion des répertoires et est plus liée à 
      l'arborescence suivie en versions elle-même. Par conséquent, elle 
      affecte tous ceux qui possèdent une copie de travail de cette 
      arborescence. Les deux mécanismes utilisent des
      <firstterm>motifs de noms de fichiers</firstterm> (des chaines de
      caractères simples ou des jokers pour trouver des correspondances
      avec les noms de fichiers). </para>

    <para>La zone de configuration de Subversion propose une option, 
      <literal>global-ignores</literal>, dont la valeur est un ensemble 
      de motifs de noms de fichiers (appelés aussi globs) séparés par des 
      espaces. Le client Subversion compare ces motifs avec les noms de 
      fichiers que l'on tente d'ajouter au suivi de versions, ainsi 
      qu'aux fichiers non suivis en versions détectés par la commande 
      <command>svn status</command>. Si un nom de fichier correspond au 
      motif, Subversion ignore totalement ce fichier. C'est 
      particulièrement utile pour les fichiers que vous ne voulez jamais 
      suivre en versions, comme les fichiers de sauvegarde créés par les 
      éditeurs de texte (par exemple, les fichiers 
      <literal>*~</literal> et <literal>.*~</literal> créés par 
      Emacs).</para>

    <sidebar>
      <title>Les motifs de fichier dans Subversion</title>

      <para>Les motifs de noms de fichiers (également appelés 
        <firstterm>globs</firstterm> ou motifs de filtrages du shell) 
        sont des chaînes de caractères qui sont destinés à être comparés 
        à des noms de fichiers, en général dans le but de sélectionner 
        rapidement un sous-ensemble de fichiers similaires au sein d'un 
        ensemble plus large, sans avoir à nommer explicitement chaque 
        fichier. Les motifs contiennent deux types de caractères&nbsp;: 
        les caractères standard, qui sont comparés explicitement aux 
        noms de fichiers, et les caractères spéciaux (aussi nommés 
        quantificateurs), qui sont interprétés différemment. </para>

      <para>Il y a différents types de syntaxes de motifs, mais 
        Subversion utilise celle qui est la plus répandue sur les 
        systèmes Unix, implémentée dans la fonction 
        <function>fnmatch</function>. Elle reconnaît les caractères 
        spéciaux suivants, décrits ici à titre d'information&nbsp;:</para>

      <variablelist>
        <varlistentry>
          <term><literal>?</literal></term>
          <listitem>
            <para>Correspond à n'importe quel caractère unique </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>*</literal></term>
          <listitem>
            <para>Correspond à n'importe quelle chaîne de caractères, y 
              compris la chaîne vide</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>[</literal></term>
          <listitem>
            <para>Marque le début de la définition d'une classe de 
              caractères, se terminant par <literal>]</literal>, 
              utilisée pour décrire un sous-ensemble de 
              caractères.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Vous pouvez observer ce même filtrage de motifs à l'invite 
        de commandes d'un shell Unix. Voici ci-dessous des exemples de 
        motifs utilisés pour différentes choses&nbsp;:</para>

      <screen>
$ ls   ### les sources du livre
appa-quickstart.xml             ch06-server-configuration.xml
appb-svn-for-cvs-users.xml      ch07-customizing-svn.xml
appc-webdav.xml                 ch08-embedding-svn.xml
book.xml                        ch09-reference.xml
ch00-preface.xml                ch10-world-peace-thru-svn.xml
ch01-fundamental-concepts.xml   copyright.xml
ch02-basic-usage.xml            foreword.xml
ch03-advanced-topics.xml        images/
ch04-branching-and-merging.xml  index.xml
ch05-repository-admin.xml       styles.css
$ ls ch*   ###  les chapitres du livre
ch00-preface.xml                ch06-server-configuration.xml
ch01-fundamental-concepts.xml   ch07-customizing-svn.xml
ch02-basic-usage.xml            ch08-embedding-svn.xml
ch03-advanced-topics.xml        ch09-reference.xml
ch04-branching-and-merging.xml  ch10-world-peace-thru-svn.xml
ch05-repository-admin.xml
$ ls ch?0-*   ### les chapitres du livre dont le numéro se termine par 0
ch00-preface.xml  ch10-world-peace-thru-svn.xml
$ ls ch0[3578]-*   ### les chapitres du livre dont Mike est responsable
ch03-advanced-topics.xml   ch07-customizing-svn.xml
ch05-repository-admin.xml  ch08-embedding-svn.xml
$
</screen>

      <para>Le filtrage par motif de fichiers est un peu plus complexe 
        que ce que nous avons décrit ici, mais ce niveau d'utilisation 
        semble suffire à la majorité des utilisateurs de 
        Subversion.</para>

    </sidebar>

    <para>Pour un répertoire suivi en versions, la propriété
      <literal>svn:ignore</literal> est supposée contenir une liste de 
      motifs de noms de fichiers (un motif par ligne) que Subversion 
      utilise pour déterminer quels objets ignorer dans le présent 
      répertoire. Ces motifs ne remplacent pas les motifs inscrits dans 
      la directive <literal>global-ignores</literal> de la zone de 
      configuration, mais s'ajoutent à cette liste. Veuillez également 
      noter que, contrairement à la directive 
      <literal>global-ignores</literal>, les motifs de la propriété 
      <literal>svn:ignore</literal>
      s'appliquent uniquement au répertoire pour lequel la propriété est 
      définie, et pas à ses sous-répertoires. La propriété 
      <literal>svn:ignore</literal> est utile pour indiquer à Subversion 
      d'ignorer les fichiers susceptibles d'être présents dans la copie 
      de travail de ce répertoire chez chaque utilisateur comme par 
      exemple les fichiers produits par les compilateurs ou, pour citer 
      un exemple plus approprié à ce livre, les fichiers HTML, PDF ou 
      PostScript générés par la conversion des fichiers sources DocBook 
      XML vers un format de fichier plus lisible.</para>

    <note>
      <para>Le support des motifs de fichiers à ignorer dans Subversion 
        s'applique uniquement à la procédure d'ajout de fichiers et 
        répertoires non suivis en versions vers la gestion de versions. 
        Une fois que l'objet est géré en version par Subversion, les 
        mécanismes permettant d'ignorer certains fichiers selon des 
        motifs prédéfinis ne s'applique plus. Autrement dit, ne pensez 
        pas que Subversion ne propagera pas les changements que vous 
        avez faits à un fichier suivi en versions simplement parce que 
        son nom correspond à un motif à ignorer : Subversion prend 
        <emphasis>toujours</emphasis> en compte l'ensemble des objets 
        qu'il gère.</para>
    </note>

    <sidebar>
      <title>Motifs de fichier à ignorer pour les utilisateurs de CVS</title>
    
      <para>La syntaxe et le fonctionnement de la propriété 
        <literal>svn:ignore</literal> de Subversion sont très similaires 
        au fichier <filename>.cvsignore</filename> de CVS. Si vous 
        migrez une copie de travail CVS vers Subversion, vous pouvez 
        migrer directement les motifs à ignorer en utilisant le fichier
        <filename>.cvsignore</filename> comme entrée à la commande 
        <command>svn propset</command>&nbsp;:</para>
   
      <screen>
$ svn propset svn:ignore -F .cvsignore .
property 'svn:ignore' set on '.'
$
</screen>        
    
      <para>Il y a quand même quelques différences entre CVS et 
        Subversion concernant les motifs à ignorer. Les deux systèmes 
        n'utilisent pas les motifs au même moment, et il y a quelques 
        divergences légères sur ce sur quoi ils s'appliquent. 
        D'ailleurs, Subversion ne reconnaît pas le motif 
        <literal>!</literal> pour revenir à une situation où aucun motif 
        n'est ignoré.</para>

    </sidebar>

    <para>La liste globale des motifs à ignorer est une affaire de goût, 
      devant plus s'intégrer à la collection d'outils d'un utilisateur 
      particulier que répondre aux besoins d'une copie de travail 
      particulière. C'est pourquoi le reste de cette section s'attachera 
      à décrire l'utilisation de la propriété 
      <literal>svn:ignore</literal>.</para>

    <para>Prenons par exemple le résultat suivant de la commande 
      <command>svn status</command>&nbsp;:</para>

    <screen>
$ svn status calc
 M     calc/bouton.c
?      calc/calculatrice
?      calc/donnees.c
?      calc/debug_log
?      calc/debug_log.1
?      calc/debug_log.2.gz
?      calc/debug_log.3.gz
</screen>
    
    <para>Dans cet exemple, des modifications ont été faites sur les 
      propriétés de <filename>bouton.c</filename>, et il y a aussi des 
      fichiers non suivis en versions&nbsp;: le programme 
      <filename>calculatrice</filename> (résultat de votre dernière 
      compilation du code source), un fichier source 
      <filename>donnees.c</filename> et un ensemble de fichiers de 
      traces pour le débogage. Vous êtes conscient du fait que compiler 
      votre code engendre à chaque fois la création du programme
      <filename>calculatrice</filename>
      <footnote>
        <para>N'est-ce pas précisément la finalité d'un système de 
          compilation&nbsp;?</para>
      </footnote>.
      Vous savez également que vous aurez toujours des fichiers de 
      traces qui traîneront. On peut faire ce constat pour toutes les 
      copies de travail locales de ce projet, pas seulement la vôtre. Et 
      vous savez que cela ne vous intéresse pas, et que cela n'intéresse 
      très probablement aucun autre développeur, de voir ces fichiers 
      apparaître à chaque commande <command>svn status</command>. Vous 
      allez donc utiliser <userinput>svn propedit svn:ignore calc</userinput> 
      pour ajouter des motifs à ignorer pour le répertoire 
      <filename>calc</filename>. Par exemple, vous pourriez ajouter ce 
      qui suit comme nouvelle valeur de la propriété 
      <literal>svn:ignore</literal>&nbsp;:</para>

    <programlisting>
calculatrice
debug_log*
</programlisting>
    
    <para>Après avoir ajouté cette propriété, vous aurez une propriété 
      modifiée localement dans votre répertoire 
      <filename>calc</filename>. Mais notez les autres différences sur 
      le résultat de la commande
      <command>svn status</command>&nbsp;:</para>

    <screen>
$ svn status
 M     calc
 M     calc/bouton.c
?      calc/donnees.c
</screen>
    
    <para>Maintenant, tout le superflu a disparu&nbsp;! Bien sûr, votre 
      programme compilé et les fichiers de trace sont toujours présents 
      dans votre copie locale. Subversion ne vous présente pas ces 
      fichiers présents mais non suivis en versions, c'est tout. Et 
      maintenant que ces parasites sont supprimés de l'affichage, il ne 
      vous reste plus que les éléments intéressants, tels que le fichier 
      de code source <filename>donnees.c</filename> que vous avez 
      probablement oublié d'ajouter au suivi de versions.</para>

    <para>Bien évidemment, ce compte-rendu plus succinct de l'état de 
      votre copie de travail locale n'est pas le seul possible. Si vous 
      voulez voir les fichiers ignorés dans le compte-rendu, vous pouvez 
      ajouter l'option <option>--no-ignore</option> à la commande
      Subversion&nbsp;:</para>

    <screen>
$ svn status --no-ignore
 M     calc
 M     calc/bouton.c
I      calc/calculatrice
?      calc/donnees.c
I      calc/debug_log
I      calc/debug_log.1
I      calc/debug_log.2.gz
I      calc/debug_log.3.gz
</screen>
    
    <para>Comme mentionné auparavant, la liste des motifs de fichiers à 
      ignorer est aussi utilisée par <command>svn add</command> et 
      <command>svn import</command>. Ces deux opérations demandent à 
      Subversion de gérer un ensemble de fichiers et de répertoires. 
      Plutôt que de forcer l'utilisateur à choisir quels fichiers dans 
      l'arborescence il souhaite suivre en versions, Subversion utilise 
      les motifs de fichiers à ignorer, à la fois la liste globale et 
      ceux définis par répertoire, pour déterminer quels fichiers suivre 
      (ou ne pas suivre) en versions dans sa procédure récursive d'ajout 
      ou d'import. Là encore, vous pouvez utiliser l'option 
      <option>--no-ignore</option> pour indiquer à Subversion d'ignorer 
      ces listes et de d'agir effectivement sur tous les fichiers et 
      répertoires présents.</para>

    <tip>
      <para>Même si <literal>svn:ignore</literal> est défini, vous 
        risquez de rencontrer des problèmes si vous utilisez des 
        caractères spéciaux du shell dans une commande. Les caractères 
        spéciaux sont remplacés par une liste explicite de cibles avant 
        que Subversion n'agisse sur eux et donc lancer <userinput>svn
        <replaceable>SOUS-COMMANDE</replaceable> *</userinput> revient
        à lancer <userinput>svn <replaceable>SOUS-COMMANDE</replaceable>
        fichier1 fichier2 fichier3 &hellip;</userinput>.  Dans le cas de
        la commande <command>svn add</command>, ceci a un effet 
        similaire à l'option <option>--no-ignore</option>. Par conséquent, 
        au lieu d'utiliser un caractère spécial, utilisez plutôt 
        <userinput>svn add --force .</userinput> pour marquer d'un seul 
        coup les éléments non suivis en versions pour ajout. La cible 
        explicite permet de s'assurer que le répertoire en cours ne sera 
        pas négligé car déjà suivi en versions et l'option 
        <option>--force</option> forcera Subversion à parcourir ce 
        répertoire, ajoutant les fichiers non suivis en versions tout en 
        respectant la propriété <literal>svn:ignore</literal> et la 
        variable <literal>global-ignores</literal> de la zone de 
        configuration. Pensez à rajouter l'option <option>--depth
        files</option> à la commande <command>svn add</command>
        si vous ne voulez pas que la recherche de fichiers à ajouter au 
        suivi de versions ne parcoure le répertoire de façon 
        récursive.</para>

      </tip>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.props.special.keywords">
    <title>Substitution de mots-clés </title>

    <para>Subversion a la capacité de substituer des
      <firstterm>mots-clés</firstterm> dans les fichiers suivis en 
      versions par des informations dynamiques et utiles. Les mots-clés 
      fournissent généralement des indications sur les dernières 
      modifications faites au fichier. Comme ces informations changent à 
      chaque fois que le fichier change, et plus spécifiquement, juste 
      <emphasis>après</emphasis> que le fichier change, c'est compliqué 
      pour tout processus, excepté pour le système de gestion de 
      versions, de garder les données à jour. Sans outil automatique, 
      adieu la pertinence de ces informations&nbsp;!</para>

    <para>Par exemple, prenons un document dans lequel vous voudriez 
      afficher sa date de dernière modification. Vous pourriez charger 
      chaque contributeur du document de renseigner le champ 
      correspondant juste avant de propager ses changements. Mais un 
      jour ou l'autre, quelqu'un oubliera de le faire. Demandez plutôt 
      à Subversion de substituer le mot-clé
      <literal>LastChangedDate</literal>. Vous contrôlez où est inséré 
      le mot-clé dans votre document en plaçant un signet à l'endroit 
      voulu dans le fichier. Ce signet est juste une chaîne de 
      caractères formatée comme 
      <literal>$</literal><replaceable>NomDuMotCle</replaceable><literal>$</literal>.</para>

    <para>Tous les mots-clés sont sensibles à la casse des caractères 
      quand ils apparaissent en tant que signets&nbsp;: vous devez 
      placer les majuscules aux bons endroits pour que le mot-clé soit 
      effectivement remplacé. Vous devriez aussi considérer que la 
      valeur de la propriété <literal>svn:keywords</literal> est 
      sensible à la casse (<quote>case-sensitive</quote> en anglais)&nbsp;: 
      certains mots-clés seront reconnus indépendamment de la casse, mais 
      ce comportement est obsolète.</para>

    <para>Subversion définit la liste des mots-clés disponibles pour les 
      substitutions. Cette liste contient les cinq mots-clés suivants 
      (certains d'entre eux ont des alias que vous pouvez aussi 
      utiliser)&nbsp;:</para>

    <variablelist>
      <varlistentry>
        <term><literal>Date</literal></term>
        <listitem>
          <para>Ce mot-clé indique la date du dernier changement connu 
            dans le dépôt. Il est de la forme
            <literal>$Date: 2006-07-22 21:42:37 -0700 (Sat,
            22 Jul 2006) $</literal>.  Il peut également être spécifié 
            en tant que <literal>LastChangedDate</literal>.  
            Contrairement au mot-clé <literal>Id</literal>, qui utilise
            l'heure UTC, le mot-clé <literal>Date</literal> affiche la 
            date et l'heure locales.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>Revision</literal></term>
        <listitem>
          <para>Ce mot-clé indique la dernière révision connue pour 
            laquelle le fichier a changé dans le dépôt. Il fournit une 
            réponse du type <literal>$Revision: 144 $</literal>.  
            Il peut aussi être spécifié en tant que 
            <literal>LastChangedRevision</literal> ou
            <literal>Rev</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>Author</literal></term>
        <listitem>
          <para>Ce mot-clé indique le dernier utilisateur qui a changé 
            le fichier dans le dépôt et retourne une valeur du 
            type <literal>$Author: harry $</literal>.  
             Il peut aussi être spécifié en tant que 
            <literal>LastChangedBy</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>HeadURL</literal></term>
        <listitem>
          <para>Ce mot-clé décrit l'URL complète de la dernière version 
            du fichier dans le dépôt et ressemble à  <literal>$HeadURL:
            http://svn.collab.net/repos/trunk/README $</literal>.
            Il peut être abrégé en  
            <literal>URL</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>Id</literal></term>
        <listitem>
          <para>Ce mot-clé est une combinaison abrégée des autres 
            mots-clés. Sa substitution donne quelque chose comme 
            <literal>$Id: calc.c 148 2006-07-28 21:30:43Z sally
            $</literal>, que l'on interprète par <quote>le fichier 
            <filename>calc.c</filename> a été modifié en dernier par 
            l'utilisateur <literal>sally</literal>. lors de la révision 
            148 le 28 juillet 2006 au soir</quote>. La date et l'heure affichées
            sont en heure UTC, contrairement au mot-clé
            <literal>Date</literal> qui utilise l'heure locale.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Une bonne partie des définitions qui précèdent utilisent la 
      locution <quote>dernière &hellip; connue</quote> ou quelque chose 
      d'équivalent. Rappelez-vous que la substitution des mots-clés est 
      une opération effectuée côté client et que votre client ne connaît 
      pas les changements qui ont eu lieu dans le dépôt depuis votre 
      dernière mise à jour. Si vous ne mettez jamais à jour de votre 
      copie de travail locale, vos mots-clés resteront figés à la même 
      valeur même si des changements ont lieu régulièrement dans le 
      dépôt.</para>

    <para>Ajouter des signets dans votre fichier ne fait rien de spécial. 
      Subversion n'essaiera jamais d'effectuer la substitution dans votre 
      fichier tant que vous ne le lui demanderez pas explicitement. Après 
      tout, vous écrivez peut-être un document
      <footnote>
        <para>&hellip; ou même peut-être un paragraphe de ce 
          livre &hellip;</para>
      </footnote> 
      sur la manière d'utiliser les mots-clés et vous ne voulez pas que 
      Subversion substitue à vos beaux exemples de signets non substitués 
      leur valeur réelle&nbsp;!</para>

    <para>Pour indiquer à Subversion de substituer ou pas les mots-clés 
      d'un fichier particulier, nous utilisons une fois de plus les 
      commandes sur les propriétés. La propriété 
      <literal>svn:keywords</literal>, quand elle est activée pour un 
      fichier, contrôle quels mots-clés doivent être substitués dans ce 
      fichier. Elle doit contenir une liste de mots-clés ou d'alias 
      cités précédemment, séparés par des espaces.</para>

    <para>Par exemple, pour un fichier nommé
      <filename>meteo.txt</filename> qui ressemble à ça&nbsp;:</para>

    <programlisting>
Voici les dernières prévisions de nos spécialistes :
$LastChangedDate$
$Rev$
Les cumulus sont de plus en plus nombreux au fur et à mesure que l'été approche.
</programlisting>
        
    <para>Sans la propriété <literal>svn:keywords</literal> activée sur 
      ce fichier, Subversion ne fera rien de spécial. Maintenant, si 
      nous activons les substitutions pour le mot-clé
      <literal>LastChangedDate</literal>&nbsp;:</para>

    <screen>
$ svn propset svn:keywords "Date Author" meteo.txt
property 'svn:keywords' set on 'meteo.txt'
$
</screen>        
    
    <para>Vous venez d'effectuer une modification locale des propriétés 
      du fichier <filename>meteo.txt</filename>. Vous ne verrez aucun 
      changement dans le contenu du fichier (à moins d'avoir fait des 
      modifications avant d'activer la propriété). Notez que le fichier 
      contenait un signet pour le mot-clé <literal>Rev</literal> et que 
      nous n'avons pas inclus ce mot-clé dans la valeur de la propriété. 
      Subversion ignorera simplement les requêtes de substitutions de 
      mots-clés qui ne sont pas présents dans le fichier et ne 
      substituera pas de mot-clé qui ne soit pas présent dans la valeur 
      de la propriété <literal>svn:keywords</literal>.</para>

    <para>Immédiatement après avoir propagé ces modifications de 
      propriété, Subversion mettra à jour votre copie de travail avec le 
      nouveau texte substitué. Au lieu de voir votre signet
      <literal>$LastChangedDate$</literal>, vous verrez le résultat de la 
      substitution. Ce résultat contient aussi le nom du mot-clé et est 
      toujours entouré par des caractères dollar (<literal>$</literal>).
      Comme prévu, le mot-clé <literal>Rev</literal> n'a pas été 
      substitué parce que nous n'avons pas demandé qu'il le soit.</para>

    <para>Notez également que la substitution s'est bien passée alors 
      que nous avons indiqué <literal>Date Author</literal> comme valeur 
      de propriété <literal>svn:keywords</literal> et que le signet 
      utilisait l'alias <literal>$LastChangedDate$</literal>&nbsp;:</para>

    <screen>
Voici les dernières prévisions de nos spécialistes :
$LastChangedDate: 2006-07-22 21:42:37 -0700 (Sat, 22 Jul 2006) $
$Rev$
Les cumulus sont de plus en plus nombreux au fur et à mesure que l'été approche.
</screen>
        
    <para>Si quelqu'un d'autre propage une modification de
      <filename>meteo.txt</filename>, votre copie de ce fichier 
      continuera à afficher la même valeur substituée de mot-clé, 
      jusqu'à ce que vous mettiez à jour votre copie de travail. Aux 
      mots-clés de <filename>meteo.txt</filename> seront alors à nouveau 
      substitués les informations qui se rapportent à la plus récente 
      propagation du fichier.</para>

    <sidebar>
      <title>Où est passé $GlobalRev$&nbsp;?</title>

      <para>Les nouveaux utilisateurs sont parfois surpris par le 
        fonctionnement du mot-clé <literal>$Rev$</literal>. Puisque le 
        dépôt a un numéro de révision à la fois unique, global et 
        croissant, beaucoup de gens pensent que c'est par ce numéro que 
        sera remplacé le mot-clé <literal>$Rev$</literal>. Mais
        <literal>$Rev$</literal> indique la dernière révision dans 
        laquelle le fichier a <emphasis>changé</emphasis>, pas la 
        révision de la dernière mise à jour. Le malentendu est ainsi 
        dissipé, mais peut-être pas la frustration de ne pas avoir 
        automatiquement le numéro global de la dernière révision dans 
        vos fichiers, n'est-ce pas&nbsp;?</para>

      <para>Pour l'obtenir, vous avez besoin d'un outil externe. 
        Subversion est livré avec un outil appelé 
        <command>svnversion</command>, qui a été conçu spécifiquement 
        pour cela. svnversion parcourt votre copie de travail et affiche 
        toutes les révisions qu'il trouve. Vous pouvez utiliser ce 
        programme, avec d'autres outils de traitement, pour insérer 
        l'information de révision désirée dans vos fichiers. Pour 
        davantage d'information sur <command>svnversion</command>, voir
        <xref linkend="svn.ref.svnversion"/>.</para>

    </sidebar>

    <para>Subversion 1.2 introduisit une nouvelle variante pour la 
      syntaxe des mots-clés. Cette syntaxe offre des fonctionnalités 
      supplémentaires et utiles, bien que parfois atypiques. Vous pouvez 
      désormais demander à Subversion de maintenir une longueur 
      constante (en nombre d'octets consommés) pour les mots-clés 
      substitués, longueur que vous définissez en utilisant la séquence 
      double deux-points (<literal>::</literal>) après le nom du mot-clé, 
      suivie du nombre de caractères espace (<literal> </literal>) voulus. 
      Quand Subversion devra effectuer la substitution du mot-clé par le 
      mot-clé et sa valeur, il ne remplacera que ces espaces, laissant 
      la taille du champ inchangée. Si la valeur est plus courte que la 
      largeur du champ, il restera des espaces pour combler la fin&nbsp;; 
      si la valeur est trop longue, elle sera tronquée avec le caractère 
      dièse (<literal>#</literal>) juste avant le caractère dollar 
      (<literal>$</literal>) final.</para>

    <para>Par exemple, pour un document dans lequel vous avez une 
      section avec les mots-clés Subversion dans un tableau. 
      L'utilisation de la syntaxe originale de substitution de 
      Subversion donnera quelque chose comme&nbsp;:</para>

    <screen>
$Rev$:     Numéro de révision de la dernière propagation
$Author$:  Auteur de la dernière propagation
$Date$:    Date de la dernière propagation
</screen>
    
    <para>C'est joli et bien aligné au début. Mais quand vous allez 
      propager ce fichier (avec la substitution des mots-clés activée, 
      bien évidemment), vous obtiendrez&nbsp;:</para>

    <screen>
$Rev: 12 $:     Numéro de révision de la dernière propagation
$Author: harry $:  Auteur de la dernière propagation
$Date: 2006-03-15 02:33:03 -0500 (Wed, 15 Mar 2006) $:    Date de la dernière propagation
</screen>
    
    <para>Le résultat n'est pas très heureux. Vous seriez alors tenté de 
      modifier le fichier après la substitution pour que le contenu soit 
      mieux aligné. Mais cette modification ne serait valable que tant 
      que les valeurs des mots-clés gardent la même taille. Si le numéro 
      de dernière révision change de valeur (par exemple de 99 à 100), 
      ou si une autre personne avec un nom d'utilisateur plus long 
      modifie le fichier, tout le travail d'alignement est à refaire. 
      Cependant, si vous utilisez la version 1.2 (ou plus) de Subversion, 
      vous pouvez utiliser la nouvelle syntaxe et définir des largeurs 
      de champs adéquates et constantes. Votre fichier ressemblera alors 
      à ceci&nbsp;:</para>

    <screen>
$Rev::               $:  Numéro de révision de la dernière propagation
$Author::            $:  Auteur de la dernière propagation
$Date::              $:  Date de la dernière propagation
</screen>
    
    <para>Propagez ce fichier. Cette fois, Subversion prend en compte la 
      syntaxe d'un champ de mot-clé à largeur fixe et maintient la 
      largeur de ce champ comme indiqué entre le double deux-points et 
      le signe dollar final. Après substitution, la largeur des champs 
      n'a pas changé&nbsp;: les valeurs courtes comme
      <literal>Rev</literal> et <literal>Author</literal> sont comblées 
      avec des espaces et le champ <literal>Date</literal>, trop long, 
      est tronqué par un caractère dièse&nbsp;:</para>

    <screen>
$Rev:: 13            $:  Numéro de révision de la dernière propagation
$Author:: harry      $:  Auteur de la dernière propagation
$Date:: 2006-03-15 0#$:  Date de la dernière propagation
</screen>
       
    <para>L'utilisation des mots-clés à longueur fixe est 
      particulièrement efficace lors de substitutions dans des fichiers 
      aux formats complexes, qui utilisent eux-mêmes des champs de 
      données de longueur fixe ou qui stockent les données dans des 
      champs dont la taille est particulièrement difficile à changer en 
      dehors de l'application native elle-même (les documents Microsoft 
      Office en sont un bon exemple).</para>

    <warning>
      <para>Soyez conscient que, comme la taille d'un mot-clé est 
        mesurée en octets, les valeurs utilisant des données codées sur 
        plusieurs octets peuvent être corrompues. Par exemple, un nom 
        d'utilisateur qui contient des caractères au format UTF-8 codés 
        sur plusieurs octets risque d'être tronqué en plein milieu d'un 
        de ces caractères multi-octets. Cette troncature est valide au 
        niveau du traitement des octets mais résultera en une chaîne 
        UTF-8 incorrecte en raison du caractère final tronqué. Il est 
        ainsi possible que certaines applications, au moment de charger 
        le fichier, remarquent que le texte UTF-8 est invalide, 
        considèrent tout le fichier comme corrompu et refusent de 
        travailler dessus. En conséquence, lorsque vous utilisez les 
        mots-clés à longueur fixe, veillez à choisir une taille adaptée 
        à des valeurs pouvant contenir des caractères éventuellement 
        codés sur plusieurs octets.</para> 
    </warning>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.sparsedirs">
    <title>Répertoires clairsemés</title>

    <para>Par défaut, la plupart des opérations Subversion sur des 
      répertoires agissent de manière récursive. Par exemple,
      <command>svn checkout</command> crée une copie de travail avec 
      tous les fichiers et répertoires de la zone spécifiée du dépôt, en 
      descendant récursivement dans l'arborescence du dépôt pour en 
      copier la structure complète sur votre disque local. Subversion 1.5 
      introduit une nouvelle fonctionnalité appelée
      <firstterm>répertoires clairsemés</firstterm> (ou 
      <firstterm>extractions superficielles</firstterm>) qui permet 
      d'obtenir facilement une copie de travail (ou une simple portion 
      d'une copie de travail) moins profonde que via la récursion 
      complète, avec la possibilité de n'extraire que plus tard les 
      répertoires et les fichiers ignorés auparavant.</para>

    <para>Par exemple, imaginons un dépôt dont l'arborescence des 
      fichiers et répertoires est constituée des noms des membres d'une 
      famille et de leurs animaux de compagnie (c'est assurément un 
      exemple bizarre, mais soit). Un <command>svn checkout</command> 
      standard nous donnerait une copie de travail de l'ensemble de 
      l'arborescence&nbsp;:</para>

    <screen>
$ svn checkout file:///var/svn/depot maman
A    maman/fils
A    maman/fils/petit-fils
A    maman/fille
A    maman/fille/petite-fille1
A    maman/fille/petite-fille1/lapinou1.txt
A    maman/fille/petite-fille1/lapinou2.txt
A    maman/fille/petite-fille2
A    maman/fille/poissonou.txt
A    maman/minou1.txt
A    maman/toutou1.txt
Révision 1 extraite.
$
</screen>

    <para>Maintenant, extrayons la même arborescence, mais cette fois en 
      demandant à Subversion de nous donner uniquement le répertoire 
      racine sans les enfants&nbsp;:</para>

    <screen>
$ svn checkout file:///var/svn/depot maman-vide --depth empty
Révision 1 extraite.
$
</screen>
 
    <para>Remarquez que nous avons ajouté l'option <option>--depth</option>
      à la commande <command>svn checkout</command> originale. Cette 
      option existe pour de nombreuses sous-commandes Subversion et est 
      similaire aux options <option>--non-recursive</option> 
      (<option>-N</option>) et <option>--recursive</option> 
      (<option>-R</option>). En fait, elle combine, améliore, remplace 
      et à terme rend obsolète ces deux options plus anciennes. Déjà, 
      elle permet à l'utilisateur de spécifier le niveau de récursion de 
      façon plus précise, en ajoutant des niveaux auparavant non 
      supportés (ou de manière peu satisfaisante). Voici les valeurs de 
      niveau de récursion que vous pouvez ajouter à vos requêtes 
      Subversion&nbsp;:</para>

    <variablelist>

      <varlistentry>
        <term><literal>--depth empty</literal></term>
        <listitem>
          <para>Inclut uniquement la cible immédiate de l'opération, 
            sans aucun fichier ou répertoire fils.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>--depth files</literal></term>
        <listitem>
          <para>Inclut la cible immédiate de l'opération et tous les 
            fichiers fils immédiats.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>--depth immediates</literal></term>
        <listitem>
          <para>Inclut la cible immédiate de l'opération et tous ses 
            sous-répertoires et fils immédiats. Les répertoires fils 
            seront eux-mêmes vides.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry>
        <term><literal>--depth infinity</literal></term>
        <listitem>
          <para>Inclut la cible immédiate, les fichiers et répertoires 
            fils, les fils des fils, et ainsi de suite pour réaliser une 
            récursion complète.</para>
        </listitem>
      </varlistentry>

    </variablelist>

    <para>Bien sûr, la simple combinaison de deux options existantes en 
      une seule ne constitue pas une nouvelle fonctionnalité méritant 
      une section complète de ce livre. Heureusement, il y a plus à en 
      dire. Ce concept de profondeur ne s'applique pas uniquement aux 
      opérations réalisées avec le client Subversion mais il s'étend 
      aussi à la description de la copie de travail elle-même, en tant 
      que <firstterm>niveau associé</firstterm> de manière permanente 
      par la copie de travail à chaque élément. La force de ce concept 
      est cette permanence. La copie de travail se rappelle le niveau de 
      récursion que vous avez choisi pour chaque élément qui la compose, 
      jusqu'à ce que vous en changiez. Par défaut, les commandes 
      Subversion agissent sur les éléments présents dans la copie de 
      travail, indépendamment de leur niveau de récursion propre.</para>

    <tip>
      <para>Vous pouvez vérifier le niveau de récursion d'une copie de 
        travail en utilisant la commande <command>svn info</command>.
        Si le niveau de récursion n'est pas infini, <command>svn
        info</command> affichera une ligne indiquant le niveau de 
        récursion&nbsp;:</para>

      <screen>
$ svn info maman-immediats | grep '^Profondeur :' 
Profondeur : immédiates
$
</screen>
    </tip>

    <para>Ces premiers exemples comportaient des extractions avec un 
      niveau infini de récursion (la valeur par défaut de  
      <command>svn checkout</command>) ou avec un niveau nul. Voyons 
      maintenant des exemples avec d'autres valeurs de niveau de 
      récursion&nbsp;:</para>

    <screen>
$ svn checkout file:///var/svn/depot maman-fichiers --depth files
A    maman-fichiers/minou1.txt
A    maman-fichiers/toutou1.txt
Révision 1 extraite.
$ svn checkout file:///var/svn/depot maman-immediats --depth immediates
A    maman-immediats/fils
A    maman-immediats/fille
A    maman-immediats/minou1.txt
A    maman-immediats/toutou1.txt
Révision 1 extraite.
$
</screen>

    <para>Comme indiqué, chacun de ces deux niveaux se situe quelque 
      part entre la cible toute simple et la récursion complète.</para>

    <para>Nous avons utilisé la commande <command>svn checkout</command> 
      pour nos exemples, mais l'option <option>--depth</option> est 
      également accessible depuis beaucoup d'autres commandes Subversion. 
      Pour ces autres commandes, spécifier un niveau de récursion est 
      une manière de limiter le rayon d'action d'une opération à un 
      niveau, à l'instar des vieilles options
      <option>--non-recursive</option> (<option>-N</option>) et
      <option>--recursive</option> (<option>-R</option>). Cela veut dire 
      que lorsque vous travaillez sur une copie de travail d'un certain 
      niveau et que vous faites une opération sur un niveau plus faible, 
      l'opération est limitée à ce niveau faible. En fait, on peut 
      généraliser ce raisonnement : pour une copie de travail d'un 
      niveau de récursion arbitraire (éventuellement hétérogène) et pour 
      une commande Subversion comportant un niveau de récursion, la 
      commande conservera le niveau de récursion associé aux éléments de 
      la copie de travail tout en limitant le rayon d'action de 
      l'opération au niveau demandé (ou celui par défaut).</para>

    <para>En plus de l'option <option>--depth</option>, les 
      sous-commandes <command>svn update</command> et 
      <command>svn switch</command> acceptent une deuxième option 
      relative au niveau de récursion&nbsp;: <option>--set-depth</option>.  
      C'est cette option qui vous permet de changer le niveau de 
      récursion associé à un élément d'une copie de travail. Regardez ce 
      qui se passe après avoir extrait notre niveau zéro puis 
      graduellement augmenté le niveau de récursion en utilisant la 
      commande <userinput>svn update
      --set-depth <replaceable>NOUVELLE-PROFONDEUR</replaceable> <replaceable>CIBLE</replaceable></userinput>:</para>

    <screen>
$ svn update --set-depth files maman-vide
A    maman-vide/minou1.txt
A    maman-vide/toutou1.txt
Actualisé à la révision 1.
$ svn update --set-depth immediates maman-vide
A    maman-vide/fils
A    maman-vide/fille
Actualisé à la révision 1.
$ svn update --set-depth infinity maman-vide
A    maman-vide/fils/petit-fils
A    maman-vide/fille/petite-fille1
A    maman-vide/fille/petite-fille1/lapinou1.txt
A    maman-vide/fille/petite-fille1/lapinou2.txt
A    maman-vide/fille/petite-fille2
A    maman-vide/fille/poissonou1.txt
Actualisé à la révision 1.
$
</screen>

    <para>Au fur et à mesure que nous avons augmenté le niveau de 
      récursion, le dépôt a complété progressivement notre 
      arborescence.</para>

    <para>Dans notre exemple, nous n'avons agi que sur la racine de 
      notre copie de travail, en changeant la valeur du niveau de 
      récursion associé. Mais nous pouvons aussi changer de façon 
      indépendante le niveau de récursion associé à chaque 
      sous-répertoire de la copie de travail. Une utilisation minutieuse 
      de cette option nous permet de récupérer uniquement certaines 
      portions de la copie de travail, en laissant de côté toutes les 
      autres portions (d'où le nom <quote>clairsemé</quote> de la 
      fonctionnalité). Voici un exemple montrant comment construire une 
      portion d'une branche de notre arbre généalogique, activer la 
      récursion totale sur une autre branche et élaguer le reste (qui ne 
      sera donc pas sur notre disque dur).</para>

    <screen>
$ rm -rf maman-vide
$ svn checkout file:///var/svn/depot maman-vide --depth empty
Révision 1 extraite.
$ svn update --set-depth empty maman-vide/fils
A    maman-vide/fils
Actualisé à la révision 1.
$ svn update --set-depth empty maman-vide/fille
A    maman-vide/fille
Actualisé à la révision 1.
$ svn update --set-depth infinity maman-vide/fille/petite-fille1
A    maman-vide/fille/petite-fille1
A    maman-vide/fille/petite-fille1/lapinou1.txt
A    maman-vide/fille/petite-fille1/lapinou2.txt
Actualisé à la révision 1.
$
</screen>

    <para>Heureusement, même avec différents niveaux de récursion 
      définis au sein d'une même copie de travail, les actions sur la 
      copie de travail ne s'en trouvent pas plus compliquées. Vous 
      pouvez toujours effectuer des modifications et les propager, 
      revenir en arrière, ou afficher les modifications locales de 
      votre copie de travail sans spécifier d'option particulière (y 
      compris <option>--depth</option> et
      <option>--set-depth</option>) aux dites commandes. Même 
      <command>svn update</command> fonctionne normalement quand on ne 
      lui fournit pas de niveau de récursion spécifique&nbsp;: elle met 
      à jour les cibles de la copie de travail qui sont présentes en 
      tenant compte des niveaux de récursion qui leur sont 
      associés.</para>

    <para>Vous devez vous demander&nbsp;: <quote>Bien. Mais quand 
      aurais-je besoin d'utiliser ça&nbsp;?</quote>. Un cas classique est 
      lié à une architecture du dépôt particulière&nbsp;: lorsque de 
      nombreux projets et modules logiciels liés cohabitent au même 
      niveau dans un dépôt (<filename>trunk/projet1</filename>,
      <filename>trunk/projet2</filename>,
      <filename>trunk/projet3</filename>, etc.). Dans de tels scénarios, 
      il est probable que seuls quelques projets vous intéressent 
      personnellement, sans doute pas plus d'un projet principal et de 
      quelques autres modules dont il dépend. Vous pouvez extraire une 
      copie de travail pour chacune de ces arborescences, mais ces 
      copies de travail sont séparées et, par conséquent, il peut être 
      fastidieux d'effectuer des opérations sur plusieurs ou sur 
      l'ensemble des copies de travail en même temps. L'autre solution 
      est d'utiliser la fonctionnalité de répertoires clairsemés, en 
      construisant une seule copie de travail qui ne contient que les 
      modules qui vous intéressent. Vous partez d'une extraction du 
      répertoire parent commun aux différents projets avec un niveau 
      zéro de récursion (empty-depth), puis vous mettez à jour avec un 
      niveau infini de récursion les éléments que vous voulez récupérer, 
      comme nous l'avons fait dans l'exemple précédent. Voyez ça comme 
      un système d'inclusion optionnelle des éléments qui peuplent la 
      copie de travail.</para>

    <para>L'implémentation des extractions superficielles de Subversion 
      1.5 est relativement bonne, mais il y a deux choses intéressantes 
      qu'elle ne permet pas de faire. Premièrement, vous ne pouvez pas 
      diminuer le niveau de récursion d'un élément de la copie de 
      travail. Si vous lancez
      <userinput>svn update --set-depth empty</userinput> sur une copie 
      de travail de niveau de récursion infini, vous n'aurez pas l'effet 
      attendu, qui serait de supprimer tout sauf le répertoire racine 
      &mdash; cela renverra simplement une erreur. Deuxièmement, il n'y 
      a pas de valeur de récursion pour indiquer que vous voulez exclure 
      explicitement un élément. Vous devez effectuer une exclusion 
      implicite de l'élément en incluant tous les éléments sauf 
      celui-là.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.locking">
    <title>Verrouillage</title>

    <para>Le modèle copier-modifier-fusionner de gestion de versions de 
      Subversion repose sur ses algorithmes de fusion, notamment sur la 
      manière dont ils gèrent les conflits quand de multiples 
      collaborateurs modifient le même fichier simultanément. Subversion 
      lui-même ne propose qu'un seul algorithme de ce type, un 
      algorithme qui détecte les modifications par trois méthodes et qui 
      est suffisamment intelligent pour gérer les données à la ligne 
      près. Subversion vous permet également d'utiliser en plus des 
      outils externes lors du processus de fusion (comme indiqué dans
      <xref linkend="svn.advanced.externaldifftools.diff3" />), parfois 
      encore meilleurs que ceux inclus dans Subversion, proposant par 
      exemple une granularité plus fine allant jusqu'au mot, voire au 
      caractère, au lieu de s'arrêter à la ligne. Mais, en règle 
      générale, ces algorithmes ne fonctionnent que sur des fichiers 
      texte. Le paysage est beaucoup plus sombre lorsque l'on recherche 
      des outils de fusion pour des formats de fichiers non-texte. Et 
      quand vous ne trouvez pas d'outil capable de fusionner de tels 
      fichiers, les limites du modèle copier-modifier-fusionner se font 
      vite sentir.</para>

   <para>Prenons un exemple de la vie réelle où ce type de problème 
     apparaît. Harry et Sally sont deux graphistes travaillant sur le 
     même projet (du marketing pour le patron d'un garage). Au coeur 
     d'une affiche de ce projet se trouve l'image d'une voiture dont la 
     carrosserie a besoin d'être réparée, stockée dans un fichier image 
     au format PNG. L'agencement de l'affiche est pratiquement terminé, 
     et Harry et Sally sont contents de la photo qu'ils ont choisie pour 
     leur voiture endommagée&nbsp;: une Ford Mustang bleue de 1967, avec 
     un gnon sur l'aile avant gauche.</para>

    <para>C'est alors, comme c'est souvent le cas dans le domaine du 
      graphisme, que des contraintes extérieures imposent de changer la 
      couleur de la voiture. Sally met donc à jour sa copie de travail à 
      la révision <literal>HEAD</literal>, lance son outil d'édition de 
      photos et commence à modifier la photo de manière à obtenir une 
      voiture rouge cerise. Pendant ce temps, Harry, particulièrement 
      inspiré ce jour-là, décide que l'image serait plus percutante si 
      la voiture était davantage endommagée. Lui aussi met à jour sa 
      copie de travail à la révision <literal>HEAD</literal>, puis 
      dessine des fissures sur le pare-brise. Il termine son travail 
      avant que Sally ne termine le sien, admire son chef-d'oeuvre et 
      propage les changements. Peu après, Sally en termine avec la 
      nouvelle couleur de la voiture et essaie de propager ses 
      modifications. Mais, comme prévu, Subversion ne parvient pas à 
      valider la propagation et informe Sally que sa version de l'image 
      n'est pas à jour.</para>

    <para>Voilà où résident les difficultés&nbsp;: si Harry et Sally 
      avaient effectué leurs changements sur un fichier texte, Sally 
      aurait simplement mis à jour sa copie de travail, recevant au 
      passage les modifications de Harry. Dans le pire des cas, ils 
      auraient modifié la même portion du fichier et Sally aurait eu à 
      résoudre les conflits manuellement. Mais, ici, nous avons affaire 
      à des images binaires, pas des fichiers texte. Et s'il est 
      relativement facile de décrire ce que devrait être l'image finale, 
      il y a très peu de chance qu'un logiciel soit suffisamment 
      intelligent pour détecter les parties communes de l'image sur 
      laquelle les artistes ont travaillé, les changements effectués par 
      Harry et les changements effectués par Sally, et pour en tirer une 
      image d'une Mustang Rouge avec un pare-brise fissuré&nbsp;!</para>

    <para>Clairement, les choses se seraient mieux passées si Harry et 
      Sally avaient sérialisé leurs modifications&nbsp;: par exemple, si 
      Harry avait attendu et dessiné ses fissures sur la voiture 
      nouvellement rouge de Sally, ou si Sally avait changé la couleur 
      d'une voiture avec un pare-brise déjà fissuré. Comme indiqué dans 
      <xref linkend="svn.basic.vsn-models.copy-merge" />, la plupart 
      de ces problèmes disparaissent complètement quand une 
      communication parfaite existe entre Harry et Sally
      <footnote>
        <para>A ce propos, un peu de communication n'aurait pas non plus 
          été un mauvais remède pour leurs homonymes hollywoodiens.</para>
      </footnote>.
      Mais comme un système de gestion de versions est en fait un mode 
      de communication, il s'ensuit que si ce type de logiciel facilite 
      la sérialisation de tâches d'édition non parallélisables, c'est 
      plutôt une bonne chose. C'est ici que l'implémentation du concept 
      verrouiller-modifier-libérer dans Subversion prend tout son sens. 
      Il est temps de parler de la fonctionnalité de 
      <firstterm>verrouillage</firstterm> de Subversion, qui est 
      similaire aux mécanismes permettant de <quote>réserver
      pour modifications</quote> des fichiers dans d'autres systèmes de 
      gestion de versions.</para>

    <para>En fin de compte, la fonctionnalité de verrouillage existe afin 
      de minimiser les pertes de temps et les efforts. En autorisant un 
      utilisateur à s'arroger logiciellement le droit exclusif de 
      modifier un fichier dans le dépôt, cet utilisateur peut être 
      suffisamment confiant dans le fait que son travail ne sera pas 
      vain &mdash; la propagation de ses changements réussira. Aussi,
      en signifiant aux autres utilisateurs qu'une sérialisation a lieu
      pour un objet suivi en versions, ces utilisateurs peut 
      raisonnablement s'attendre à ce que cet objet soit modifié par 
      quelqu'un d'autre. Eux aussi peuvent alors éviter de perdre leur
      temps et leur énergie sur des modifications qui ne pourront pas
      être fusionnées en raison d'un problème de mise à jour du fichier
      correspondant.</para>

    <para>La fonctionnalité de verrouillage de Subversion comporte en 
      fait plusieurs facettes, qui permettent entre autres de 
      verrouiller un fichier suivi en versions
      <footnote>
        <para>Pour l'instant, Subversion ne permet pas de poser de 
          verrou sur un répertoire.</para>
      </footnote>
      (demander le droit exclusif de modification sur le fichier), de le 
      déverrouiller (abandonner le droit exclusif de modification), de 
      voir la liste des fichiers qui sont verrouillés et par qui, 
      d'annoter des fichiers pour lesquels le verrouillage est fortement 
      recommandé avant édition, etc. Dans cette section, nous aborderons 
      toutes les facettes de cette fonctionnalité de verrouillage.</para>

    <sidebar id="svn.advanced.locking.meanings">
      <title>Les trois types de <quote>verrous</quote></title>

      <para>Dans cette section, et pratiquement partout dans ce livre, 
        les mots <quote>verrou</quote> et <quote>verrouillage</quote>
        décrivent un mécanisme d'exclusion mutuelle entre utilisateurs 
        pour éviter des propagations incompatibles. Malheureusement, il 
        existe deux autres sortes de <quote>verrous</quote> auxquels 
        Subversion, et donc ce livre, sont confrontés.</para>

      <para>Les premiers sont des <firstterm>verrous des copies de 
        travail</firstterm>, utilisés en interne par Subversion pour 
        éviter des collisions entre de multiples instances du client 
        Subversion travaillant sur la même copie de travail. Ce type de 
        verrou est repérable au <computeroutput>L</computeroutput> situé 
        dans la troisième colonne de la sortie de <command>svn 
        status</command>, et peut être supprimé par la commande 
        <command>svn cleanup</command>, comme indiqué à <xref
        linkend="svn.tour.cleanup"/>.</para>

      <para>Ensuite, il y a les <firstterm>verrous des bases de 
        données</firstterm>, utilisés en interne par les bases de données 
        Berkeley DB pour éviter les collisions entre de multiples 
        programmes accédant à la base de données. C'est le type de 
        verrou qui, s'il persiste sans qu'on le veuille après une 
        erreur, peut provoquer un <quote>plantage</quote> du dépôt, comme 
        indiqué dans <xref linkend="svn.reposadmin.maint.recovery"
        />.</para>

      <para>En général, vous pouvez faire abstraction de ces autres 
        types de verrous, du moins tant que tout va bien. Si les choses 
        se gâtent, vous aurez peut-être à vous y intéresser. Dans ce 
        livre, le terme <quote>verrou</quote> désigne la fonctionnalité 
        Subversion, sauf si le contexte indique le contraire ou si c'est 
        mentionné explicitement.</para>

    </sidebar>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.locking.creation">
      <title>Créer des verrous</title>
      
      <para>Dans un dépôt Subversion, un <firstterm>verrou</firstterm> 
        est une méta-donnée qui alloue à un utilisateur un accès 
        exclusif en écriture sur un fichier. Cet utilisateur est 
        appelé <firstterm>détenteur du verrou</firstterm>. Chaque verrou 
        possède également un identifiant unique, en général une longue 
        chaîne de caractères, appelé <firstterm>jeton de 
        verrouillage</firstterm>. Le dépôt gère les verrous en assurant 
        in fine leur création, leur application et leur suppression. Si 
        une propagation tente de modifier ou effacer un fichier 
        verrouillé (ou effacer un répertoire parent dudit fichier), le 
        dépôt demande deux informations&nbsp;: que le client effectuant 
        la propagation s'authentifie en tant que détenteur du verrou et 
        que le jeton de verrouillage soit fourni lors de la procédure de 
        propagation afin de signifier que le client sait bien quel 
        verrou il utilise.</para>
      
      <para>Pour illustrer la création d'un verrou, reprenons notre 
        exemple de graphistes travaillant sur les même fichiers image 
        binaires. Harry a décidé de changer cette image JPEG. Pour 
        interdire aux autres collaborateurs d'effectuer des changements 
        sur le fichier pendant qu'il le modifie (et pour les avertir 
        qu'il va modifier ce fichier), il verrouille le fichier dans le 
        dépôt en utilisant la commande
        <command>svn lock</command>&nbsp;:</para>

      <screen>
$ svn lock banane.jpg -m "Édition du fichier pour la livraison de demain."
'banane.jpg' locked by user 'harry'.
$ 
</screen>

      <para>Il y a plusieurs points intéressants dans l'exemple 
        ci-dessus&nbsp;: d'abord, notez que Harry utilise l'option
        <option>--message</option> (<option>-m</option>) de
        <command>svn lock</command>.  Comme <command>svn
        commit</command>, la commande <command>svn lock</command> 
        accepte des commentaires (soit via <option>--message</option>
        (<option>-m</option>), soit via <option>--file</option>
        (<option>-F</option>)) pour indiquer la raison du verrouillage du 
        fichier. En revanche, contrairement à <command>svn 
        commit</command>, <command>svn lock</command> n'exigera pas 
        automatiquement un message en lançant votre éditeur de texte 
        préféré. Les commentaires de verrouillage sont optionnels, mais 
        néanmoins recommandés pour faciliter la communication entre 
        collaborateurs.</para>

      <para>Ensuite, la tentative de verrouillage a réussi. Cela 
        signifie que le fichier n'était pas préalablement verrouillé et 
        que Harry disposait de la dernière version du fichier. Si la 
        copie de travail de Harry avait été obsolète, le dépôt aurait 
        refusé la demande, forçant Harry à effectuer une mise à jour 
        (<command>svn update</command>) et à relancer ensuite la 
        commande de verrouillage. La commande de verrouillage aurait 
        également échoué si le fichier avait été déjà verrouillé par 
        quelqu'un d'autre.</para>

      <para>Comme vous pouvez le constater, la commande <command>svn 
        lock</command> affiche la confirmation que le verrouillage a 
        réussi. Dès lors, le verrouillage du fichier apparaît dans le 
        résultat des commandes <command>svn status</command> et 
        <command>svn info</command>&nbsp;:</para>

      <screen>
$ svn status
     K banane.jpg

$ svn info banane.jpg
Chemin : banane.jpg
Nom : banane.jpg
URL : http://svn.exemple.com/depot/projet/banane.jpg
Racine du dépôt : http://svn.exemple.com/depot
UUID du dépôt : edb2f264-5ef2-0310-a47a-87b0ce17a8ec
Revision: 2198
Type de nœud : file
Tâche programmée : normale
Auteur de la dernière modification : frank
Révision de la dernière modification : 1950
Date de la dernière modification : 2006-03-15 12:43:04 -0600 (mer. 15 mars 2006)
Texte mis à jour : 2006-06-08 19:23:07 -0500 (jeu. 08 juin 2006)
Propriétés mis à jour : 2006-06-08 19:23:07 -0500 (jeu. 08 juin 2006)
Somme de contrôle: 3b110d3b10638f5d1f4fe0f436a5a2a5
Nom de verrou : opaquelocktoken:0c0f600b-88f9-0310-9e48-355b44d4a58e
Propriétaire du verrou : harry
Verrou créé : 2006-06-14 17:20:31 -0500 (mer. 14 juin 2006)
Commentaire du verrou (1 ligne):
Édition du fichier pour la livraison de demain.

$

</screen>

      <para>Le fait que la commande <command>svn info</command>, qui ne 
        contacte pas le dépôt quand elle porte sur un chemin d'une copie 
        de travail, affiche bien le jeton de verrouillage, révèle une 
        caractéristique importante des jetons de verrouillage&nbsp;: ils 
        sont intégrés dans la copie de travail. La présence du jeton de 
        verrouillage est primordiale. Cela permet à la copie de travail 
        de pouvoir utiliser le verrou ultérieurement. Par ailleurs, la 
        commande <command>svn status</command> affiche un 
        <literal>K</literal> (raccourci pour locKed &mdash; verrouillé 
        en anglais) avant le nom du fichier, indiquant que le jeton de 
        verrouillage est présent.</para>

      <sidebar>
        <title>À propos des jetons de verrouillage</title>

        <para>Un jeton de verrouillage n'est pas un jeton 
          d'authentification mais plutôt un jeton 
          d'<emphasis>autorisation</emphasis>. Le jeton n'est pas 
          protégé comme un secret. En fait, le jeton de verrouillage 
          peut être vu par n'importe quel utilisateur qui lance la 
          commande <userinput>svn info <replaceable>URL</replaceable></userinput>.  
          Un jeton de verrouillage n'a de propriété spéciale que quand 
          il est placé dans une copie de travail. C'est la preuve que 
          le verrou a été créé dans cette copie de travail et non 
          ailleurs par quelqu'un d'autre. Seulement s'authentifier en 
          tant que propriétaire du verrou n'est pas suffisant pour 
          éviter les accidents.</para>

        <para>Par exemple, supposons que vous verrouilliez un fichier 
          avec votre ordinateur au bureau, puis que vous quittiez le 
          travail avant d'avoir fini vos changements sur ce fichier. Il 
          ne doit pas être possible de propager accidentellement des 
          modifications de ce même fichier depuis votre ordinateur à la 
          maison plus tard dans la soirée simplement parce que vous vous 
          êtes authentifié en tant que détenteur du verrou. En d'autres 
          termes, le verrou interdit à une instance d'un quelconque 
          client Subversion de saboter le travail d'une autre instance. 
          (Dans notre exemple, si vous avez réellement besoin de 
          modifier le fichier depuis votre copie de travail à la maison, 
          vous devrez <firstterm>casser</firstterm> le verrou puis 
          re-verrouiller le fichier).</para>

      </sidebar>

      <para>Maintenant que Harry a verrouillé <filename>banane.jpg</filename>,
        Sally ne peut ni modifier ni effacer ce fichier&nbsp;:</para>

      <screen>
$ svn delete banane.jpg
D         banane.jpg
$ svn commit -m "Suppression des fichiers inutiles."
Suppression    banane.jpg
svn: Échec de la propagation (commit), (détails):
svn: Suppression de
'/depot/projet/!svn/wrk/64bad3a9-96f9-0310-818a-df4224ddc35d/banane.jpg':
423 Verrouillé (http://svn.exemple.com)
$
</screen>

      <para>Mais Harry, après avoir fait ses retouches sur sa belle 
        banane jaune, peut propager ses changements sur le fichier. 
        C'est parce qu'il s'authentifie en tant que détenteur du verrou 
        et aussi parce que sa copie de travail possède le bon jeton de 
        verrouillage&nbsp;:</para>

      <screen>
$ svn status
M    K banane.jpg
$ svn commit -m "Rendu la banane plus jaune."
Envoi        banane.jpg
Transmission des données .
Révision 2201 propagée.
$ svn status
$
</screen>

      <para>Notez qu'après que la propagation est terminée, <command>svn
        status</command> permet de voir que le jeton de verrouillage 
        n'est plus présent dans la copie de travail. C'est le 
        comportement normal de <command>svn commit</command>&nbsp;: elle 
        recherche dans la copie de travail (ou dans une liste de cibles, 
        si vous fournissez une telle liste) les modifications effectuées 
        localement et elle envoie les jetons de verrouillage qu'elle 
        trouve durant sa recherche au serveur, en tant que partie 
        intégrante du processus de propagation. Après que la propagation 
        a réussi, tous les verrous du dépôt qui ont été mentionnés sont 
        libérés, <emphasis>même ceux pour lesquels les fichiers n'ont 
        pas été propagés</emphasis>. Ce comportement a pour but de 
        dissuader les utilisateurs d'être négligents avec leurs verrous 
        ou de garder des verrous trop longtemps. Si Harry verrouille au 
        hasard trente fichiers dans un répertoire nommé 
        <filename>Images</filename> parce qu'il n'est pas sûr de savoir 
        quels fichiers il doit modifier et qu'il ne modifie finalement 
        que quatre fichiers, alors quand il lancera la commande 
        <userinput>svn commit Images</userinput>, la procédure libérera 
        les trente verrous.</para>

      <para>Ce mode de fonctionnement (libérer automatiquement les 
        verrous) peut être modifié avec l'option 
        <option>--no-unlock</option> de <command>svn commit</command>.  
        C'est utile quand vous voulez propager des changements mais que 
        vous prévoyez d'effectuer des changements supplémentaires et 
        que donc vous avez toujours besoin des verrous. Vous pouvez 
        également en faire le fonctionnement par défaut en réglant 
        l'option <literal>no-unlock</literal> dans la zone de 
        configuration (voir 
        <xref linkend="svn.advanced.confarea" />).</para>

      <para>Bien sûr, verrouiller un fichier n'oblige pas l'utilisateur 
        à le modifier. Le verrou peut être libéré n'importe quand avec 
        la commande <command>svn unlock</command>&nbsp;:</para>

      <screen>
$ svn unlock banane.c
'banane.c' déverrouillé.
</screen>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.locking.discovery">
      <title>Identifier un verrou</title>

      <para>Quand une propagation échoue parce que quelqu'un d'autre a 
        posé un verrou, il est facile de savoir pourquoi. La commande la 
        plus simple est
        <userinput>svn status --show-updates</userinput>:</para>

      <screen>
$ svn status -u
M              23   truc.c
M    O         32   raisin.jpg
       *       72   machin.h
État par rapport à la révision      105
$
</screen>

      <para>Dans cet exemple, Sally peut voir que non seulement sa copie 
        de travail de <filename>machin.h</filename> n'est plus à jour, 
        mais aussi qu'un des deux fichiers qu'elle prévoie de propager 
        est verrouillé dans le dépôt. La lettre  <literal>O</literal> 
        (Others &mdash; <quote>autres</quote> en anglais) indique qu'un verrou 
        existe sur ce fichier et qu'il a été créé par quelqu'un d'autre. 
        Si elle essayait de lancer <command>svn commit</command>, le 
        verrou sur <filename>raisin.jpg</filename> l'en empêcherait. 
        Sally est laissée dans l'expectative de savoir qui a posé le 
        verrou, quand et pourquoi. Là encore, 
        <command>svn info</command> trouve la réponse&nbsp;:</para>

      <screen>
$ svn info http://svn.exemple.com/depot/projet/raisin.jpg
Chemin : raisin.jpg
Nom : raisin.jpg
URL: http://svn.exemple.com/depot/projet/raisin.jpg
UUID du dépôt : edb2f264-5ef2-0310-a47a-87b0ce17a8ec
Révision: 105
Type de nœud : file
Auteur de la dernière modification : sally
Révision de la dernière modification : 32
Texte mis à jour : 2006-01-25 12:43:04 -0600 (Sun, 25 Jan 2006)
Nom de verrou : opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Propriétaire du verrou : harry
Verrou créé : 2006-02-16 13:29:18 -0500 (jeu. 16 févr. 2006)
Commentaire du verrou (1 ligne):
Besoin de faire une retouche rapide sur cette image.
$
</screen>

      <para>De la même manière que <command>svn info</command> peut être 
        utilisée pour examiner les objets de la copie de travail, elle 
        peut être utilisée pour examiner les objets du dépôt. Si 
        l'argument principal de <command>svn info</command> est un 
        chemin de la copie de travail, alors toutes les informations 
        stockées localement sont affichées&nbsp;; toute mention d'un 
        verrou signifie que la copie de travail détient un jeton de 
        verrouillage (si le fichier est verrouillé par un autre 
        utilisateur ou depuis une autre copie de travail, alors lancer
        <command>svn info</command> sur la copie de travail ne renverra 
        aucune information relative au verrou). Si l'argument principal 
        de <command>svn info</command> est une URL, alors les 
        informations affichées se rapportent à la dernière version de 
        l'objet dans le dépôt et toute mention d'un verrou concerne le 
        verrou en cours sur l'objet.</para>

      <para>Ainsi, dans notre exemple, Sally peut voir que Harry a 
        verrouillé le fichier le 16 février pour effectuer une 
        <quote>retouche rapide</quote>. Comme nous sommes en juin, elle 
        suspecte qu'il a probablement oublié le verrou. Elle pourrait 
        téléphoner à Harry pour le lui signaler et lui demander de 
        libérer le verrou. S'il n'est pas joignable, elle pourrait 
        essayer de forcer le verrou elle-même, ou demander à un 
        administrateur de le faire.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.locking.break-steal">
      <title>Casser et voler des verrous</title>

      <para>Un verrou n'est pas quelque chose de sacré&nbsp;: dans la 
        configuration par défaut de Subversion, les verrous peuvent être 
        libérés non seulement par leur détenteur, mais aussi par 
        n'importe qui d'autre. Quand quelqu'un d'autre que le détenteur 
        d'un verrou le libère, nous appelons ça 
        <firstterm>casser le verrou</firstterm>.</para>

      <para>Avec un statut d'administrateur, il est facile de casser un 
        verrou. Les programmes <command>svnlook</command>
        et <command>svnadmin</command> peuvent afficher et casser les 
        verrous directement dans le dépôt (pour plus d'informations sur 
        ces outils, reportez-vous à
        <xref linkend="svn.reposadmin.maint.tk"/>.)</para>

      <screen>
$ svnadmin lslocks /usr/local/svn/depot
Chemin : /projet2/images/banane.jpg
Chaîne UUID : opaquelocktoken:c32b4d88-e8fb-2310-abb3-153ff1236923
Propriétaire : frank
Créé : 2006-06-15 13:29:18 -0500 (Thu, 15 Jun 2006)
Expire : 
Commentaire (1 ligne):
J'améliore encore la couleur jaune.

Chemin : /projet/raisin.jpg
Chaîne UUID : opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Propriétaire : harry
Créé : 2006-02-16 13:29:18 -0500 (Thu, 16 Feb 2006)
Expire : 
Commentaire (1 ligne):
Besoin de faire une retouche rapide sur cette image.

$ svnadmin rmlocks /usr/local/svn/depot/projet/raisin.jpg
'/projet/raisin.jpg' déverrouillé
$
</screen>

      <para>L'option la plus intéressante est celle qui permet aux 
        utilisateurs de casser les verrous détenus par d'autres 
        personnes à travers le réseau. Pour ce faire, Sally doit 
        simplement ajouter l'option <option>--force</option> à la
        commande <command>svn unlock</command>&nbsp;:</para>

      <screen>
$ svn status -u
M              23   truc.c
M    O         32   raisin.jpg
       *       72   machin.h
État par rapport à la révision     105
$ svn unlock raisin.jpg
svn: 'raisin.jpg' n'est pas verrouillé dans cette copie de travail
$ svn info raisin.jpg | grep URL
URL: http://svn.exemple.com/depot/projet/raisin.jpg
$ svn unlock http://svn.exemple.com/depot/projet/raisin.jpg
svn: Unlock request failed: 403 Forbidden (http://svn.exemple.com)
$ svn unlock --force http://svn.exemple.com/depot/projet/raisin.jpg
'raisin.jpg' déverrouillé.
$
</screen>

      <para>Ainsi, la tentative initiale de Sally pour libérer le verrou 
        a échoué parce qu'elle a lancé <command>svn unlock</command> 
        directement sur le fichier de sa copie de travail, où aucun 
        jeton de verrouillage n'était présent. Pour casser le verrou 
        directement dans le dépôt, elle doit passer une URL à
        <command>svn unlock</command>. Son premier essai pour casser le 
        verrou avec l'URL échoue car elle ne peut pas s'authentifier 
        comme détentrice du verrou (et elle n'a pas non plus le jeton de 
        verrouillage). Mais quand elle passe l'option
        <option>--force</option>, les pré-requis d'authentification et 
        d'autorisation sont ignorés et le verrou est cassé.</para>
        
      <para>Simplement casser le verrou peut ne pas être suffisant. Dans 
        l'exemple, Sally ne veut pas seulement casser le verrou oublié 
        par Harry, mais également re-verrouiller le fichier pour son 
        propre usage. Elle peut le faire en lançant 
        <command>svn unlock</command> avec l'option 
        <option>--force</option> puis <command>svn lock</command>
        à la suite, mais il existe une petite chance que quelqu'un 
        d'autre verrouille le fichier entre les deux commandes. La 
        meilleure solution est donc de <firstterm>voler le 
        verrou</firstterm>, ce qui implique de casser et re-verrouiller 
        le fichier en une seule opération atomique. Pour ce faire, Sally 
        passe l'option <option>--force</option> à la commande 
        <command>svn lock</command>&nbsp;:</para>

      <screen>
$ svn lock raisin.jpg
svn: avertissement : Échec de la demande de verrou : 423 verrouillé (http://svn.exemple.com)
$ svn lock --force raisin.jpg
'raisin.jpg' verrouillé par l'utilisateur 'sally'.
$
</screen>

      <para>Dans tous les cas, que le verrou soit cassé ou volé, Harry 
        est bon pour une bonne surprise. La copie de travail de Harry 
        contient toujours le jeton de verrouillage original, mais le 
        verrou n'existe plus. Le jeton de verrouillage est dit 
        <firstterm>défunt</firstterm>. Le verrou associé au jeton de 
        verrouillage a été soit cassé (il n'existe plus dans le dépôt) 
        soit volé (remplacé par un autre verrou). Quoi qu'il en soit, 
        Harry peut voir ce qu'il en est en demandant à
        <command>svn status</command> de contacter le dépôt&nbsp;:</para>

      <screen>
$ svn status
     K raisin.jpg
$ svn status -u
     B         32   raisin.jpg
$ svn update
  B  raisin.jpg
$ svn status
$
</screen>

      <para>Si le verrou dans le dépôt a été cassé, alors 
        <userinput>svn status --show-updates</userinput> affiche un 
        <literal>B</literal> (Broken &mdash; <quote>cassé</quote> en anglais) 
        à côté du fichier. Si un nouveau verrou existe en lieu et place 
        de l'ancien, alors un <literal>T</literal> (sTolen &mdash; 
        <quote>volé</quote> en anglais) est affiché. Finalement, 
        <command>svn update</command> détecte les jetons de verrouillage 
        défunts et les supprime de la copie de travail.</para>

      <sidebar>
        <title>Politiques de verrouillage</title>
        
        <para>Il existe des visions différentes de la résistance que 
          doit avoir un verrou. Certains considèrent que les verrous 
          doivent être respectés à tout prix, et donc libérables 
          uniquement par leur détenteur ou par un administrateur. Ils 
          affirment que si n'importe qui peut casser un verrou c'est la 
          pagaille et tout le concept de verrouillage est mis par terre. 
          D'autres pensent que les verrous sont d'abord et avant tout un 
          outil de communication. Si les utilisateurs cassent les 
          verrous des autres en permanence, c'est un problème culturel 
          de l'équipe qui ne peut pas être résolu par un outil 
          logiciel.</para>

        <para>Subversion souscrit à la version <quote>douce</quote>, 
          mais autorise cependant les administrateurs à mettre en place 
          une politique plus stricte via l'utilisation de procédures 
          automatiques. En particulier, les procédures automatiques de
          pré-verrouillage (fichier <filename>pre-lock</filename>) et de 
          pré-déverrouillage (fichier <filename>pre-unlock</filename>) 
          permettent aux administrateurs de décider dans quelles 
          situations la création ou la libération d'un verrou est 
          autorisée. En fonction de l'existence préalable ou non d'un 
          verrou, ces deux procédures automatiques décident s'il 
          convient ou non d'autoriser tel utilisateur à casser ou voler 
          tel verrou. Des procédures automatiques de post-verrouillage 
          (fichier <filename>post-lock</filename>) et de 
          post-déverrouillage (fichier <filename>post-unlock</filename>)
          sont également disponibles et peuvent être utilisées pour 
          envoyer des emails suite aux actions de verrouillage. Pour en 
          savoir plus sur les procédures automatiques, voir  <xref
          linkend="svn.reposadmin.create.hooks" />.</para>

      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.locking.lock-communication">
      <title>Communication par l'intermédiaire des verrous</title>

      <para>Nous avons vu comment <command>svn lock</command>
        et <command>svn unlock</command> peuvent être utilisés pour 
        poser, libérer, casser ou voler des verrous. Cela résout le 
        problème de la sérialisation des accès à un fichier. Mais qu'en 
        est-il du problème plus vaste d'éviter les pertes de 
        temps&nbsp;?</para>

      <para>Par exemple, supposons que Harry verrouille un fichier image 
        et commence à l'éditer. Pendant ce temps, loin de là, Sally veut 
        faire la même chose. Elle ne pense pas à faire un <userinput>svn 
        status --show-updates</userinput> et n'a donc pas la moindre 
        idée que Harry a déjà verrouillé le fichier. Elle passe des 
        heures à modifier le fichier et quand elle tente de propager ses 
        changements, elle découvre soit que le fichier est verrouillé, 
        soit que son propre fichier n'était pas à jour. Quoi qu'il en 
        soit, ses modifications ne peuvent pas être fusionnées avec 
        celles de Harry. L'un des deux doit passer ses modifications par 
        pertes et profits, un temps conséquent a été gaspillé.</para>
      
      <para>La solution proposée par Subversion à ce problème est de 
        fournir un mécanisme pour rappeler aux utilisateurs qu'un fichier 
        devrait être verrouillé <emphasis>avant</emphasis> de faire des 
        modifications. Ce mécanisme est mis en œuvre par une propriété 
        spéciale&nbsp;: <literal>svn:needs-lock</literal>. Si cette 
        propriété est associée à un fichier (quelle que soit sa valeur, 
        qui n'est pas prise en compte), alors Subversion essaiera 
        d'utiliser les permissions du système de fichiers pour le placer 
        en lecture seule &mdash; à moins, bien sûr, que l'utilisateur 
        ait explicitement verrouillé le fichier. Quand un jeton de 
        verrouillage est présent (indiquant que
        <command>svn lock</command> a été lancée), le fichier sera placé 
        en lecture-écriture. Quand le verrou sera libéré, le fichier 
        passera de nouveau en lecture seule.</para>

      <para>La théorie est donc que si le fichier image a cette 
        propriété définie, alors Sally remarquera tout de suite quelque 
        chose d'étrange à l'ouverture du fichier&nbsp;: beaucoup 
        d'applications avertissent l'utilisateur immédiatement quand un 
        fichier en lecture seule est ouvert pour édition et pratiquement 
        tous l'empêcheront de sauvegarder ses modifications dans le 
        fichier. Cela lui rappellera de verrouiller le fichier avant de 
        l'éditer, découvrant ainsi le verrou pré-existant&nbsp;:</para>

      <screen>
$ /usr/local/bin/gimp raisin.jpg
gimp: erreur: le fichier est en lecture seule !
$ ls -l raisin.jpg
-r--r--r--   1 sally   sally   215589 juin  8 19:23 raisin.jpg
$ svn lock raisin.jpg
svn: avertissement : Échec de la demande de verrou : 423 verrouillé (http://svn.exemple.com)
$ svn info http://svn.exemple.com/depot/projet/raisin.jpg | grep errou 
Nom de verrou : opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Propriétaire du verrou : harry
Verrou créé : 2006-06-08 07:29:18 -0500 (Thu, 08 June 2006)
Commentaire de verrouillage (1 ligne):
J'effectue quelques retouches.  Je le verrouille pour deux heures.
$</screen>

      <tip>
        <para>Les utilisateurs et les administrateurs sont tous 
          encouragés à positionner la propriété 
          <literal>svn:needs-lock</literal> sur les fichiers qui 
          ne peuvent pas être contextuellement fusionnés. C'est la 
          technique de base pour favoriser les bonnes habitudes de 
          verrouillage et éviter les pertes de temps.</para>
      </tip>

      <para>Notez que cette propriété est un outil de communication qui 
        fonctionne indépendamment de la politique de verrouillage. 
        Autrement dit, n'importe quel fichier peut être verrouillé, que 
        cette propriété existe ou pas. Et réciproquement, l'existence de 
        cette propriété ne rend pas obligatoire le verrouillage pour 
        pouvoir propager des modifications.</para>

      <para>Malheureusement, le système n'est pas parfait. Il est 
        possible que même si le fichier possède la propriété, 
        l'avertissement de lecture seule ne marche pas. Quelquefois, les 
        applications ne suivent pas les normes et
        <quote>piratent</quote> le fichier en lecture seule, autorisant 
        sans rien dire l'utilisateur à modifier et sauvegarder le 
        fichier. Subversion ne peut pas faire grand chose dans ce genre 
        de cas&nbsp;: au final, rien ne remplace une bonne communication 
        entre les membres d'une équipe
        <footnote>
          <para>A part, peut-être, la fusion mentale vulcaine.</para>
        </footnote>.
      </para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.externals">
    <title>Définition de références externes</title>
    
    <para>Parfois il peut être utile de construire une copie de travail 
      issue de différentes extractions. Par exemple, vous pouvez avoir 
      envie d'avoir différents sous-répertoires provenant de différents 
      endroits du dépôt, ou même carrément de différents dépôts. Vous 
      pourriez arriver un tel enchevêtrement manuellement, en utilisant 
      <command>svn checkout</command> pour créer le genre de structure 
      voulu pour votre copie de travail . Mais si cette configuration 
      est importante pour tous les utilisateurs de votre dépôt, chacun 
      devra effectuer les mêmes opérations d'extraction que vous.</para>

    <para>Heureusement, Subversion supporte les <firstterm>définitions
      de références externes</firstterm>. Une définition de références 
      externes est une association entre un répertoire local et une URL 
      (et idéalement un numéro de révision particulier) pour un 
      répertoire suivi en versions. Dans Subversion, vous déclarez les 
      définitions de références externes dans des groupes en utilisant 
      la propriété <literal>svn:externals</literal>.
      Vous pouvez créer et modifier cette propriété en utilisant 
      <command>svn propset</command> ou <command>svn propedit</command> 
      (voir <xref linkend="svn.advanced.props.manip" />). Elle peut être 
      définie sur tous les répertoires suivis en versions et sa valeur 
      décrit à la fois l'URL du dépôt externe et le répertoire côté 
      client dans lequel sera extrait cette URL.</para>

    <para>L'un des attraits de la propriété <literal>svn:externals</literal>
      est qu'une fois qu'elle est définie pour un répertoire suivi en 
      versions, chaque utilisateur qui extraie une copie de travail de 
      ce répertoire bénéficie des définitions de références externes. En 
      d'autres termes, une fois qu'un utilisateur a fait l'effort de 
      définir la structure de la copie de travail imbriquée, tout le 
      monde en bénéficie automatiquement&nbsp;: Subversion, lors de 
      l'extraction de la copie de travail originale, extraira également 
      les copies de travail externes.</para>

    <warning>
      <para>Les sous-répertoires cibles des définitions de références 
        externes <emphasis>ne doivent pas</emphasis> déjà exister sur 
        votre système ou sur le systèmes des autres utilisateurs&nbsp;: 
        Subversion les créera lors de l'extraction des copies de travail 
        externes.</para>
    </warning>

    <para>Vous bénéficiez avec les définitions de références externes de 
      tous les avantages liés aux propriétés Subversion. Les définitions 
      sont suivies en versions. Si vous avez besoin de changer une 
      définition de références externes, vous pouvez le faire à l'aide 
      des sous-commandes classiques sur les propriétés. Quand vous 
      propagez des modifications relatives à la propriété 
      <literal>svn:externals</literal>, Subversion synchronisera les 
      éléments extraits par rapport à la définition de références 
      externes modifiée dès que vous lancerez 
      <userinput>svn update</userinput>. Tous ceux qui 
      mettront à jour leur copie de travail recevront vos modifications 
      concernant les définitions de références externes.</para>

    <tip>
      <para>Comme la valeur de la propriété 
        <literal>svn:externals</literal> est constituée de plusieurs 
        lignes, nous vous recommandons fortement d'utiliser 
        <command>svn propedit</command> plutôt que <command>svn
        propset</command>.</para>
    </tip>

    <para>Les versions de Subversion antérieure à 1.5 utilisent un format
      de définitions externes qui est un tableau sur plusieurs lignes 
      composées de sous-répertoires (relativement au répertoire suivi
      en versions sur lequel est définie la propriété), d'indicateurs de 
      révision optionnels et l'URL, absolue et complètement qualifiée,
      du dépôt Subversion. Un exemple pourrait ressembler à 
      ceci&nbsp;:</para>

    <screen>
$ svn propget svn:externals calc
tierce-partie/sons                 http://svn.exemple.com/depot/sons
tierce-partie/themes -r148         http://svn.exemple.com/projet-themes
tierce-partie/themes/outils -r21   http://svn.exemple.com/outils-themes
</screen>

    <para>Quand quelqu'un extrait une copie de travail du répertoire
      <filename>calc</filename> décrit dans l'exemple ci-dessus, 
      Subversion extrait également les éléments trouvés dans les
      définitions de références externes.</para>

    <screen>
$ svn checkout http://svn.exemple.com/depot/calc
A  calc
A  calc/Makefile
A  calc/entier.c
A  calc/bouton.c
Révision 148 extraite.

Récupération de la référence externe dans 'calc/tierce-partie/sons'
A  calc/tierce-partie/sons/ding.ogg
A  calc/tierce-partie/sons/dong.ogg
A  calc/tierce-partie/sons/clang.ogg
&hellip;
A  calc/tierce-partie/sons/bang.ogg
A  calc/tierce-partie/sons/twang.ogg
Révision 14 extraite.

Récupération de la référence externe dans 'calc/tierce-partie/themes'
&hellip;
</screen>

    <para>A partir de la version 1.5 de Subversion, un nouveau format
      de la propriété <literal>svn:externals</literal> est supporté.
      Les références externes sont toujours multi-lignes mais l'ordre et
      le format des différentes informations ont changé. La nouvelle
      syntaxe ressemble plus à l'ordre des arguments que vous passeriez
      à la commande <command>svn checkout</command>&nbsp;: l'indicateur
      optionnel de révision est placé en premier, puis l'URL du dépôt
      Subversion externe et, enfin, le sous-répertoire local relatif.
      Notez cependant que cette fois-ci nous n'avons pas indiqué 
      <quote>URL absolue et complètement qualifiée</quote> pour le dépôt
      externe. En effet, le nouveau format accepte les URL relatives et
      les URL avec des piquets de révision. L'exemple précédent sur les 
      références externes pourrait, dans Subversion 1.5, ressembler à 
      ceci&nbsp;:</para>

    <screen>
$ svn propget svn:externals calc
      http://svn.exemple.com/depot/sons     tierce-partie/sons
-r148 http://svn.exemple.com/projet-themes  tierce-partie/themes
-r21  http://svn.exemple.com/outils-themes  tierce-partie/themes/outils
</screen>

    <para>Ou, en utilisant la syntaxe avec les piquets de révision 
      (décrite en détail dans <xref linkend="svn.advanced.pegrevs" />), 
      il pourrait être écrit comme ceci&nbsp;:</para>

    <screen>
$ svn propget svn:externals calc
http://svn.exemple.com/depot/sons         tierce-partie/sons
http://svn.exemple.com/projet-themes@148  tierce-partie/themes
http://svn.exemple.com/outils-themes@21   tierce-partie/themes/outils
</screen>

    <tip>
      <para>Il est particulièrement conseillé d'utiliser des numéros de 
        révision explicites dans toutes vos références externes. Ainsi, 
        vous conservez la possibilité de décider quand rapatrier une 
        nouvelle version de vos informations externes et quelle version 
        exacte rapatrier. En plus de vous éviter la surprise de recevoir 
        des changements effectués sur des dépôts tiers dont vous n'avez 
        pas la maîtrise, l'utilisation de numéros de révisions 
        explicites signifie aussi que, si vous revenez à une version de 
        travail antérieure, vos références externes reviendront elles 
        aussi dans l'état où elles étaient au moment de cette version 
        antérieure. Cela signifie aussi que les copies de travail 
        externes seront actualisées pour refléter 
        <emphasis>leur</emphasis> état au moment de la révision 
        antérieure. Pour des projets logiciels, cela peut faire la 
        différence entre une compilation réussie et un échec de 
        compilation d'une version antérieure d'un code source 
        complexe.</para> 
    </tip>

    <para> Pour la plupart des dépôts, les trois formats de références
      externes ont le même effet au final. Ils apportent tous les mêmes
      avantages. Malheureusement, ils possèdent aussi les mêmes 
      inconvénients. Puisque les références indiquées utilisent des URL
      absolues, déplacer ou copier un répertoire auquel elles sont 
      rattachées n'affectera pas ce qui est extrait en externe (alors 
      qu'une référence relative sera, bien évidemment, déplacée avec le
      répertoire). Cela peut vous induire en erreur, voire vous 
      frustrer, dans certaines situations. Par exemple, imaginons un
      répertoire racine appelé <filename>mon-projet</filename> pour 
      lequel nous avons défini des références externes dans un 
      sous-répertoire (<filename>mon-projet/un-rep</filename>) 
      vers la dernière révision d'un autre sous-répertoire
      (<filename>mon-projet/rep-externe</filename>).</para>

    <screen>
$ svn checkout http://svn.exemple.com/projets .
A    mon-projet
A    mon-projet/un-rep
A    mon-projet/rep-externe
&hellip;
Récupération de la référence externe dans 'mon-projet/un-rep/sous-rep'
Référence externe actualisée à la révision 11.

Actualisé à la révision 11.
$ svn propget svn:externals mon-projet/un-rep
sous-rep http://svn.exemple.com/projets/mon-projet/rep-externe

$
</screen>

    <para>Maintenant utilisez la commande 
      <command>svn move</command> pour renommer le répertoire
      <filename>mon-projet</filename>. &Agrave; ce moment là, vos 
      définitions de références externes  pointeront toujours vers un
      chemin sous le répertoire <filename>mon-projet</filename>, même si
      ce répertoire n'existe plus.</para>

    <screen>
$ svn move -q mon-projet nouveau-projet
$ svn commit -m "Renommé mon-projet en nouveau-projet."
Suppression    mon-projet
Ajout          nouveau-projet

Révision 12 propagée.
$ svn update

Récupération de la référence externe dans 'nouveau-projet/un-rep/sous-rep'
svn: Le dépôt http://svn.exemple.com/projets/mon-projet/rep-externe n'existe pas 

$
</screen>

    <para>De plus, les URL absolues utilisées par les références 
      externes peuvent causer des problèmes pour les dépôts accessibles 
      via plusieurs types d'URL. Par exemple, si votre serveur 
      Subversion est configuré pour autoriser tout le monde à consulter 
      le dépôt via <literal>http://</literal> ou <literal>https://</literal>, 
      mais que les opérations de propagation doivent être effectuées 
      uniquement via <literal>https://</literal>, vous vous retrouvez 
      bien embêté. Si vos références externes pointent vers une URL de  
      type <literal>http://</literal>, vous ne pourrez pas effectuer de 
      propagation depuis les copies de travail créées via ces 
      références externes. D'un autre côté, si vous utilisez la forme 
      <literal>https://</literal> pour les URL, ceux qui voudront 
      effectuer des consultations via <literal>http://</literal>, parce 
      que leur client ne sait pas traiter le <literal>https://</literal>, 
      seront incapables de récupérer les éléments externes. Soyez 
      conscient également que si vous avez besoin de déplacer toute 
      votre copie de travail (avec <command>svn switch</command> et  
      l'option <option>--relocate</option>), les références externes ne 
      seront pas mises à jour en conséquence.</para>

   <para>Subversion 1.5 franchit un grand pas dans la résolution de ces
     soucis. Comme indiqué précédemment, les URL utilisées dans le 
     nouveau format des définitions des références externes peuvent être
     relatives. Par ailleurs, Subversion autorise une syntaxe magique
     pour spécifier plusieurs types d'URL relatives.</para>

    <variablelist>
      <varlistentry>
        <term><literal>../</literal></term> 
        <listitem><para>Relative à l'URL du répertoire sur lequel la 
          propriété <literal>svn:externals</literal> est 
          définie.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>^/</literal></term> 
        <listitem><para>Relative à la racine du dépôt pour lequel la 
          propriété <literal>svn:externals</literal> est suivie en 
          versions.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>//</literal></term> 
        <listitem><para>Relative au type d'URL du répertoire sur lequel 
          la propriété <literal>svn:externals</literal> est
          définie.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>/</literal></term>
        <listitem><para>Relative à l'URL du serveur sur lequel la 
          propriété <literal>svn:externals</literal> est suivie en
          versions.</para></listitem>
      </varlistentry>
    </variablelist>

    <para>Donc, considérons pour la quatrième fois la définition de 
      nos références externes de l'exemple précédent et utilisons la 
      nouvelle syntaxe de différentes manière. Nous 
      obtenons&nbsp;:</para>

    <screen>
$ svn propget svn:externals calc
^/sons                             tierce-partie/sons
/themes@148                        tierce-partie/themes
//svn.exemple.com/outils-themes@21 tierce-partie/themes/outils
</screen>

    <para>Le support pour les références externes dans Subversion reste 
      imparfait. Une définition de références externes ne peut pointer
      que vers des répertoires et non vers des fichiers. Par ailleurs,
      le sous-répertoire local dans la définition ne peut pas contenir
      d'indicateur de répertoire père (<literal>..</literal>)&nbsp;; 
      Ainsi, <filename>../../themes/mon-theme</filename> est interdit.
      Et peut-être encore plus dommage, les copies de travail créées par 
      la définition de références externes sont toujours déconnectées de 
      la copie de travail primaire (celle dans laquelle la propriété
      <literal>svn:externals</literal> est définie sur le répertoire 
      suivi en versions). Et Subversion ne peut fonctionner pleinement
      que sur des copies de travail d'un seul tenant. Ainsi, par 
      exemple, si vous voulez propager des changements que vous avez
      effectués sur une ou plusieurs de ces copies de travail externes,
      vous devez lancez <command>svn commit</command> explicitement sur
      ces copies de travail &mdash; effectuer une propagation sur la 
      copie de travail primaire ne traitera pas récursivement les copies
      de travail externes.</para>

    <para>Nous avons déjà mentionné certains défauts de l'ancien
      format de <literal>svn:externals</literal> et comment la version
      1.5 de Subversion les corrige. Mais faites attention, en utilisant
      les nouveaux formats, à ne pas pénaliser accidentellement des 
      utilisateurs qui accèderaient à votre dépôt avec de vieux clients
      Subversion. Alors que les clients Subversion 1.5 supportent 
      toujours le format original des définitions de références 
      externes, les vieux clients <emphasis>ne seront pas 
      capables</emphasis> d'analyser le nouveau format.</para>

    <para>En plus des commandes <command>svn checkout</command>, 
      <command>svn update</command>, <command>svn switch</command> et
      <command>svn export</command> qui gèrent effectivement les 
      sous-répertoires <firstterm>disjoints</firstterm> (ou déconnectés)
      où sont extraites les références externes, la commande 
      <command>svn status</command> reconnaît également les définitions
      de références externes. Elle affiche un code de statut 
      <literal>X</literal> pour les sous-répertoires externes disjoints
      et parcourt ces sous-répertoires pour afficher le statut des 
      éléments externes eux-mêmes. Vous pouvez passer l'option 
      <option>--ignore-externals</option> à n'importe laquelle de ces
      commandes pour désactiver le traitement des définitions de 
      références externes.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.pegrevs">
    <title>Piquets de révisions et révisions opérationnelles</title>

    <para>Continuellement, nous copions, déplaçons, renommons et 
      remplaçons des fichiers et des répertoires sur nos ordinateurs. 
      Et votre système de gestion de versions ne doit pas être un 
      obstacle à ces opérations sur les fichiers et répertoires suivis 
      en versions. La gestion des fichiers par Subversion se fait 
      pratiquement oublier, étant presque aussi flexible pour les 
      fichiers suivis en versions que pour les autres. Mais cette 
      flexibilité signifie qu'au cours de la vie de votre dépôt un objet 
      suivi en versions aura un certain nombre de chemins et qu'un 
      chemin donné pourra représenter plusieurs objets suivis en 
      versions tout à fait différents. Cela ajoute un niveau de 
      complexité supplémentaire dans les actions sur les chemins et les 
      objets.</para>

    <para>Subversion est plutôt adroit pour détecter les 
      <quote>changements d'adresses</quote> dans l'historique du suivi 
      de versions d'un objet. Par exemple, si vous demandez l'historique 
      d'un fichier qui a été renommé la semaine dernière, Subversion 
      fournit ce journal (la révision dans laquelle s'est produit le 
      changement de nom) et les journaux pertinents avant et après ce 
      renommage. Ainsi, la plupart du temps, vous n'avez pas à vous 
      préoccuper de ces opérations. Mais il arrive que Subversion ait 
      besoin de votre aide pour lever des ambiguïtés.</para>

    <para>L'exemple correspondant le plus simple est quand un fichier ou 
      un répertoire est supprimé du suivi de versions, puis qu'un nouveau 
      répertoire ou fichier est créé avec le même nom et ajouté au suivi 
      de versions. L'objet qui a été effacé et celui qui a été ajouté 
      plus tard ne sont pas les mêmes. Ils se trouve qu'ils ont juste le 
      même chemin (<filename>/trunk/objet</filename> par exemple).
      Que signifie alors de demander à Subversion l'historique de 
      <filename>/trunk/object</filename>&nbsp;? La question 
      concerne-t-elle l'objet actuellement à cet emplacement ou l'objet 
      précédent qui a été supprimé&nbsp;? Ou encore les opérations sur
      <emphasis>tous</emphasis> les objets qui ont résidé à cet 
      emplacement&nbsp;? Subversion a besoin de savoir ce que vous 
      demandez réellement.</para>

    <para>Et, en raison des déplacements, l'historique des objets suivis 
      en versions peut être beaucoup plus tordu que cela. Par exemple, 
      vous pourriez avoir un répertoire appelé 
      <filename>concept</filename>, contenant une ébauche de projet 
      logiciel sur lequel vous vous êtes essayé. Il se peut que ce 
      projet mûrisse et que l'idée soit pertinente au point que, chose 
      inimaginable, vous décidiez de donner un nom au projet
      <footnote>
        <para><quote>Vous n'êtes pas supposés lui donner un nom. Une 
          fois que vous l'avez nommé, vous allez forcément vous y 
          attacher</quote>, Bob Razowski (le cyclope de Monstres et 
          Cie).</para>
      </footnote>
      Imaginons que vous nommiez ce logiciel 
      <filename>frabnaggilywort</filename>. Il semble alors logique de 
      renommer le répertoire <filename>concept</filename> en
      <filename>frabnaggilywort</filename> pour refléter le nom du 
      projet. L'eau coule sous les ponts et Frabnaggilywort sort en 
      version 1.0, est téléchargé et utilisé quotidiennement par des 
      tonnes de gens qui veulent se faciliter la vie.</para>
    
    <para>Quelle belle histoire&nbsp;! Mais elle ne s'arrête pas là. 
      Comme vous avez une âme d'entrepreneur, vous avez déjà une autre 
      idée derrière la tête&nbsp;: vous créez donc un nouveau répertoire
      <filename>concept</filename> et la boucle est bouclée. En fait, 
      ce cycle recommence plusieurs fois au fil du temps, à chaque fois 
      à partir de ce vieux répertoire<filename>concept</filename>
      qui, quelquefois, est renommé quand l'idée plaît, et, d'autres 
      fois, est effacé quand l'idée ne convient pas. En plus, pour être 
      réellement tordu, vous donnez parfois à 
      <filename>concept</filename> un autre nom temporaire, puis 
      renommez ce même répertoire <filename>concept</filename> pour une 
      raison quelconque.</para>

    <para>Avec de tels scénarios, demander à Subversion d'apprendre à 
      travailler avec ces renommages multiples est un peu comme dire à 
      un automobiliste de la banlieue de prendre la direction de Paris 
      et de prendre à gauche sur <quote>l'avenue du Général 
      Leclerc</quote>&nbsp;: il croisera l'avenue du Général Leclerc à 
      Colombes, La Garenne-Colombes, Nanterre, Neuilly &hellip; et, non, 
      ce n'est pas la même rue à chaque fois. De la même manière, 
      Subversion a besoin d'un peu plus de précisions pour travailler 
      correctement.</para>

    <para>Dans sa version 1.1, Subversion a introduit une façon de 
      spécifier de quelle avenue du Général Leclerc on parle. Cela 
      s'appelle le <firstterm>piquet de révision</firstterm> et c'est 
      uniquement destiné à identifier de manière unique une branche de 
      l'historique. Comme il y a au plus un objet suivi en versions à 
      un endroit et à un moment donnés (ou plus précisément à une 
      révision donnée), la combinaison d'un chemin et d'un piquet de 
      révision est tout ce dont vous avez besoin pour désigner une 
      branche spécifique de l'historique. Les piquets de révision sont 
      indiqués au client Subversion en utilisant la notation
      <firstterm>at</firstterm>(on l'appelle ainsi parce que la syntaxe 
      de la commande utilise le <quote>signe arobase</quote>
      (<literal>@</literal>) suivi du piquet de révision demandé, en 
      fin de chemin.</para>

    <para>Mais alors qu'en est-il de l'option <option>--revision</option>
      (<option>-r</option>) dont nous avons tant parlé dans ce 
      livre&nbsp;? Cette révision (ou ensemble de révisions) est appelée 
      la <firstterm>révision opérationnelle</firstterm> (ou
      <firstterm>ensemble de révisions opérationnelles</firstterm>). 
      Une fois qu'une branche particulière de l'historique a été 
      identifiée en utilisant un chemin et un piquet de révision, 
      Subversion effectue la requête en utilisant la révision 
      opérationnelle (ou l'ensemble de révisions opérationnelles). 
      Pour reprendre notre analogie avec les rues françaises, si on vous 
      dit d'aller au 137 de l'avenue du Général Leclerc à Nanterre
      <footnote>
        <para>606 N. Main Street, Wheaton, Illinois, is the home of
          the Wheaton <emphasis>History</emphasis> Center.  It seemed
          appropriate&hellip;.</para>
      </footnote>,
      vous pouvez penser que <quote>l'avenue du Général Leclerc</quote> 
      est le chemin dans le système de fichiers et 
      <quote>Nanterre</quote> le piquet de révision. Ces deux 
      informations identifient de manière unique une route donnée et 
      vous évitent de parcourir une autre avenue du Général Leclerc à 
      la recherche de votre destination finale. Maintenant, vous pouvez 
      rechercher le <quote>137</quote> comme numéro de révision 
      opérationnelle puisque nous savons exactement où aller.</para>

    <sidebar>
      <title>Algorithme des piquets de révision</title>
      
      <para>Subversion utilise l'algorithme des piquets de révision 
        chaque fois qu'il doit résoudre une ambiguïté dans les chemins 
        et numéros de versions fournis en ligne de commande. Voici un 
        exemple d'une telle ligne de commande&nbsp;:</para>

      <screen>
$ svn <replaceable>command</replaceable> -r <replaceable>REVISION-OPERATIONNELLE</replaceable> element@<replaceable>PIQUET-DE-REVISION</replaceable>
</screen>
      
      <para>Si <replaceable>REVISION-OPERATIONNELLE</replaceable> est 
        plus vieille que <replaceable>PIQUET-DE-REVISION</replaceable>, 
        alors l'algorithme est le suivant&nbsp;:</para>

      <orderedlist>
        <listitem>
          <para>Trouver <replaceable>element</replaceable> dans la 
            révision identifiée par 
            <replaceable>PIQUET-DE-REVISION</replaceable>. Il ne peut y 
            avoir qu'un seul objet.</para>
        </listitem>
        <listitem>
          <para>Parcourir l'historique de l'objet à l'envers (y compris 
            en tenant compte d'éventuels renommages) jusqu'à son ancêtre 
            dans la révision
            <replaceable>REVISION-OPERATIONNELLE</replaceable>.</para>
        </listitem>
        <listitem>
          <para>Effectuer la requête sur cet ancêtre, où qu'il soit et 
            quel que soit son nom (actuel et à ce moment là).</para>
        </listitem>
      </orderedlist>

      <para>Mais que se passe-t-il si 
        <replaceable>REVISION-OPERATIONNELLE</replaceable> est
        <emphasis>plus récente</emphasis> que
        <replaceable>PIQUET-DE-REVISION</replaceable>&nbsp;? Et bien, 
        cela ajoute un peu de complexité à la recherche du chemin dans 
        <replaceable>REVISION-OPERATIONNELLE</replaceable>, parce que 
        l'historique du chemin peut avoir bifurqué à plusieurs reprises 
        (en rainson d'opérations de copie) entre
	  <replaceable>PIQUET-DE-REVISION</replaceable> et
        <replaceable>REVISION-OPERATIONNELLE</replaceable>. Et ce n'est 
        pas tout car, de toute façon, Subversion ne stocke pas 
        suffisamment d'informations pour retracer de façon performante 
        l'historique d'un élément dans le sens chronologique. Donc, dans 
        ce cas, l'algorithme est un peu différent&nbsp;:</para>

      <orderedlist>
        <listitem>
          <para>Trouver <replaceable>element</replaceable> dans la 
            révision identifiée par <replaceable>REVISION-OPERATIONNELLE</replaceable>.  
		    Il ne peut y avoir qu'un seul objet.</para>
        </listitem>
        <listitem>
          <para>Parcourir l'historique de l'objet à l'envers (y compris 
            en tenant compte d'éventuels renommages) jusqu'à son ancêtre 
            dans la révision
            <replaceable>PIQUET-DE-REVISION</replaceable>.</para>
        </listitem>
        <listitem>
          <para>Vérifier que la position de l'objet (son chemin) dans 
            <replaceable>PIQUET-DE-REVISION</replaceable> est la même 
            que dans <replaceable>REVISION-OPERATIONNELLE</replaceable>. 
            Si c'est le cas, puisque les deux positions sont directement 
            liées, effectuer la requête sur la position dans 
            <replaceable>REVISION-OPERATIONNELLE</replaceable>.
            Sinon, la relation entre les deux n'étant pas établie, 
            renvoyer une erreur expliquant qu'aucune position viable n'a 
            été trouvée. On peut espérer qu'un jour Subversion sera plus 
            flexible et saura mieux gérer ce type de cas.</para>
        </listitem>
      </orderedlist>

      <para>Notez que même quand vous ne spécifiez pas explicitement de 
        piquet de révision ni de numéro de révision opérationnelle, ils 
        sont néanmoins présents. Par défaut, la valeur du piquet de 
        révision est <literal>BASE</literal> pour les éléments de la 
        copie de travail et <literal>HEAD</literal> pour les URL du 
        dépôt. Et quand aucune révision opérationnelle n'est fournie, 
        la valeur par défaut est celle du piquet de révision.</para>
        
    </sidebar>

    <para>Supposons que nous ayons créé notre dépôt il y a longtemps et 
      quand dans la révision 1 nous ayons ajouté notre premier 
      répertoire <filename>concept</filename> ainsi qu'un fichier 
      <filename>IDEE</filename>, situé dans ce répertoire, contenant la 
      description du concept. Nous avons ensuite ajouté et modifié de 
      véritables lignes de code. A la révision 20, nous avons renommé ce 
      répertoire en <filename>frabnaggilywort</filename>. Lors de la 
      révision 27, nous développons un nouveau concept et un nouveau 
      répertoire <filename>concept</filename> est créé pour l'héberger, 
      avec un nouveau fichier <filename>IDEE</filename> pour le décrire. 
      Cinq ans et vingt mille révisions passent, comme dans tout bon 
      roman d'amour.</para>

    <para>A présent, plusieurs années plus tard, nous nous demandons à 
      quoi ressemblait le fichier <filename>IDEE</filename> en révision 1. 
      Mais Subversion a besoin de savoir si nous demandons à quoi 
      ressemble le fichier <emphasis>actuel</emphasis> tel qu'il était 
      lors de la révision 1 ou si nous demandons le contenu du fichier
      <filename>concept/IDEE</filename> (quel qu'il soit) de la révision 
      1. Ces questions ont certainement des réponses différentes et grâce 
      aux piquets de révisions, nous pouvons poser ces deux questions. 
      Pour obtenir le contenu du fichier <filename>IDEE</filename> actuel 
      tel qu'il était dans l'ancienne révision, tapez&nbsp;:</para>

    <screen>
$ svn cat -r 1 concept/IDEE
svn: Unable to find repository location for 'concept/IDEE' in revision 1
</screen>

    <para>Bien sûr, dans cet exemple, le fichier
      <filename>IDEE</filename> actuel n'existait pas lors de la 
      révision 1, c'est pourquoi Subversion renvoie une erreur. La 
      commande ci-dessus est un raccourci pour la notation plus longue 
      qui explicite le piquet de révision. La notation complète est 
      donc&nbsp;:</para>

    <screen>
$ svn cat -r 1 concept/IDEE@BASE
svn: Unable to find repository location for 'concept/IDEE' in revision 1
</screen>

    <para>On obtient le résultat attendu.</para>

    <para>Le lecteur perspicace est certainement en train de se demander 
      si la syntaxe des piquets de révision ne pose pas de problèmes 
      pour les chemins ou les URL qui comportent déjà le signe arobase. 
      Après tout, comment <command>svn</command> peut-il savoir si 
      <literal>nouveau@11</literal> est le nom d'un répertoire dans mon 
      arborescence ou juste la syntaxe pour <quote>révision 11 de
      <filename>nouveau</filename></quote>&nbsp;?  Dieu merci, alors que
      <command>svn</command> opte par défaut pour cette dernière 
      hypothèse, il existe une solution de contournement triviale&nbsp;: 
      il suffit juste d'ajouter un signe arobase à la fin du 
      chemin, comme ceci&nbsp;: <literal>nouveau@11@</literal>.
      <command>svn</command> ne s'intéresse qu'au dernier arobase de 
      l'argument et il n'est pas considéré comme illégal d'omettre le 
      spécificateur de piquet de révision après ce arobase. Cette 
      solution de contournement s'applique même aux chemins qui se 
      terminent par arobase (utilisez <literal>nomfichier@@</literal> 
      pour désigner le fichier <filename>nomfichier@</filename>.</para>

    <para>Posons maintenant l'autre question&nbsp;: dans la révision 1, 
      quel était le contenu du fichier qui occupait l'adresse 
      <filename>concept/IDEE</filename> à ce moment là&nbsp;? Nous 
      allons utiliser explicitement un piquet de révision pour nous 
      aider&nbsp;:</para>

    <screen>
$ svn cat concept/IDEE@1
L'idée de ce projet est de fournir un logiciel qui peut frabber un 
naggily wort. Frabber les naggilys worts est particulièrement difficile
et ne pas le faire correctement aurait des conséquences inimaginables.
Nous devons donc utiliser des mécanismes de vérification des
entrées et des données du dernier cri.
</screen>

    <para>Remarquez que cette fois nous n'avons pas fourni de révision 
      opérationnelle. C'est parce que, quand aucune révision 
      opérationnelle n'est spécifiée, Subversion considère que le 
      numéro de révision opérationnelle est égal au piquet de 
      révision.</para>

    <para>Comme vous pouvez le constater, la résultat de la commande 
      semble être correct. Le texte parle même de "frabber les naggilys 
      worts", ce qui laisse supposer que c'est certainement le fichier 
      décrivant le logiciel maintenant connu sous le nom de 
      Frabnaggilywort. En fait, on peut le vérifier en combinant un 
      piquet de révision explicite et un numéro de révision 
      opérationnelle explicite. Nous savons que dans
      <literal>HEAD</literal>, the
      Frabnaggilywort project is located in the
      <filename>frabnaggilywort</filename> directory.  So we specify
      that we want to see how the line of history identified in
      <literal>HEAD</literal> as the path
      <filename>frabnaggilywort/IDEA</filename> looked in revision
      1.</para>

    <screen>
$ svn cat -r 1 frabnaggilywort/IDEE@HEAD
L'idée de ce projet est de fournir un logiciel qui peut frabber un 
naggily wort. Frabber les naggilys worts est particulièrement difficile
et ne pas le faire correctement aurait des conséquences inimaginables.
Nous devons donc utiliser des mécanismes de vérification des
entrées et des données du dernier cri.
</screen>

    <para>Vous pouvez aussi spécifier des piquets de révision et des 
      révisions opérationnelles moins triviales. Par exemple, disons 
      que<filename>frabnaggilywort</filename> a été effacé de 
      <literal>HEAD</literal>, mais nous savons qu'il existait en 
      révision 20 et nous voulons voir les différences entre la 
      révision 4 et la révision 10 pour son fichier
      <filename>IDEE</filename>. Nous pouvons utiliser le piquet de 
      révision 20 en conjonction avec l'URL qu'avait le fichier 
      <filename>frabnaggilywort/IDEE</filename> dans la révision 20 
      et utiliser 4 et 10 pour spécifier l'intervalle de révisions 
      opérationnelles.</para>

    <screen>
$ svn diff -r 4:10 http://svn.red-bean.com/projets/frabnaggilywort/IDEE@20
Index: frabnaggilywort/IDEE
===================================================================
--- frabnaggilywort/IDEE	(revision 4)
+++ frabnaggilywort/IDEE	(revision 10)
@@ -1,5 +1,5 @@
-L'idée de ce projet est de fournir un logiciel qui peut frabber un 
-naggily wort. Frabber les naggilys worts est particulièrement difficile
-et ne pas le faire correctement aurait des conséquences inimaginables.
-Nous devons donc utiliser des mécanismes de vérification des
-entrées et des données du dernier cri.
+L'idée de ce projet est de fournir un logiciel client-serveur qui peut
+frabber un naggily wort de manière distante. Frabber les naggilys worts
+est particulièrement difficile et ne pas le faire correctement aurait
+des conséquences inimaginables. Nous devons donc utiliser des mécanismes
+de vérification des entrées et des données du dernier cri.
</screen>

    <para>Heureusement, la plupart d'entre vous n'aura pas à faire 
      face à des situations aussi complexes. Mais si jamais c'est le 
      cas, rappelez-vous que les piquets de révisions sont les 
      informations complémentaires dont a besoin Subversion pour lever 
      toute ambiguïté.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.changelists">
    <title>Listes de modifications</title>

    <para>Il est très courant pour un développeur d'avoir à effectuer, 
      en même temps, des modifications multiples n'ayant rien à voir 
      entre elles sur une portion de code donnée. Ce n'est pas 
      nécessairement la preuve d'une mauvaise gestion de son temps, 
      ni d'une forme de masochisme numérique. Un ingénieur de 
      développement repère souvent des bogues annexes lorsqu'il 
      travaille sur un morceau de code particulier. Ou alors c'est une 
      fois rendu à mi-chemin d'un changement important qu'il prend 
      conscience que la solution qu'il a choisie serait mieux propagée 
      sous la forme de plusieurs unités logiques plus petites, ces 
      unités pouvant se recouper, affecter des fichiers différents du 
      même module, ou même toucher à des lignes différentes du même 
      fichier.</para>

    <para>Plusieurs méthodologies sont à disposition des développeurs 
      pour gérer ces ensembles de modifications. Certains développeurs 
      utilisent des copies de travail séparées, du même dépôt, pour y 
      conserver les progrès faits pour chaque changement. D'autres 
      développeurs choisissent de créer au sein du dépôt des branches 
      fonctionnelles à durée de vie très courte et utiliser une unique 
      copie de travail qu'ils feront pointer selon les besoins du moment 
      vers une branche de ce type ou vers une autre. Enfin, d'autres 
      développeurs utilisent les outils <command>diff</command> et
      <command>patch</command> pour sauvegarder et restaurer des 
      changements non propagés sur les fichiers touchés par les 
      modifications. Chacune de ces méthodes a des avantages et des 
      inconvénients et, en général, le détail des changements à 
      effectuer influence fortement le choix de la méthodologie 
      utilisée pour les distinguer.</para>

    <para>Subversion 1.5 a introduit une nouvelle fonctionnalité, les
      <firstterm>listes de modifications</firstterm>, qui vient 
      s'ajouter aux méthodes mentionnées ci-dessus. Les listes de 
      modifications sont en gros des étiquettes arbitraires (une au 
      plus par fichier pour l'instant) attachées à des fichiers de la 
      copie de travail dans le seul but de regrouper plusieurs fichiers 
      ensemble. Les utilisateurs de bon nombre de logiciels fournis par 
      Google sont déjà habitués à ce concept. Dans 
      <ulink url="http://mail.google.com/">Gmail</ulink>, vous associez 
      des étiquettes arbitraires à des e-mails, et plusieurs e-mails 
      peuvent être considérés comme faisant partie du même groupe s'ils 
      partagent une étiquette donnée. Dès lors, ne voir qu'un groupe 
      d'e-mails portant la même étiquette n'est plus qu'un simple jeu 
      d'affichage. De nombreux autres sites web 2.0 possèdent des 
      mécanismes similaires. Prenez par exemple les <quote>tags</quote>
      (étiquette en anglais) utilisés sur des sites comme 
      <ulink url="http://www.youtube.com/">YouTube</ulink> ou
      <ulink url="http://www.flickr.com/">Flickr</ulink>, les
      <quote>catégories</quote> utilisées pour regrouper les articles 
      de blogs, etc. Aujourd'hui les gens ont compris que l'organisation 
      des données est essentielle et la façon dont ces données sont 
      organisées doit être flexible. Le vieux paradigme des répertoires 
      et des fichiers est bien trop rigide pour certaines 
      applications.</para>

    <para>Cette fonctionnalité de Subversion vous permet de créer des 
      listes de modifications en étiquetant les fichiers que vous voulez 
      inclure, de supprimer ces étiquettes, et de limiter le rayon 
      d'action des sous-commandes aux seuls fichiers qui portent 
      l'étiquette donnée. Dans ce paragraphe, nous allons voir en 
      détails comment accomplir ces actions.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.changelists.creating">
      <title>Créer et modifier des listes de modifications</title>

      <para>Vous pouvez créer, modifier et supprimer des listes de 
        modifications en utilisant la commande <command>svn 
        changelist</command>. Plus précisément, vous pouvez utiliser 
        cette commande pour activer ou désactiver l'association d'une 
        liste de modifications avec un fichier donné de la copie de 
        travail. La création d'une liste de modifications a lieu la 
        première fois que vous étiquetez un fichier avec ce nom de 
        liste&nbsp;; elle n'est supprimée que quand vous effacez 
        l'étiquette du dernier fichier qui la portait. Examinons un cas 
        concret pour illustrer ces notions.

        You can create, modify, and delete changelists using the
        <command>svn changelist</command> command.  More accurately,
        you use this command to set or unset the changelist
        association of a particular working copy file.  A changelist
        is effectively created the first time you label a file with
        that changelist; it is deleted when you remove that label from
        the last file that had it.  Let's examine a usage scenario
        that demonstrates these concepts.</para>

      <para>Harry est en train de corriger des bogues dans le module de 
        logique mathématique de l'application 'calculatrice'. Son 
        travail l'amène à modifier deux fichiers&nbsp;:</para>

      <screen>
$ svn status
M      entier.c
M      ops-math.c
$
</screen>

      <para>En testant son correctif, Harry s'aperçoit que ses 
        modifications lui indiquent qu'un bogue collatéral existe au 
        sein de la logique de l'interface utilisateur, située dans le 
        fichier <filename>bouton.c</filename>. Harry décide alors qu'il 
        va aussi corriger ce bogue, dans une propagation séparée de ses 
        propres correctifs mathématiques. Dans une copie de travail de 
        petite taille, ne contenant qu'une poignée de fichiers, et pour 
        juste quelques modifications logiques, Harry pourrait 
        probablement gérer mentalement ces deux ensembles logiques de 
        modifications sans le moindre problème. Mais aujourd'hui il a 
        décidé qu'il allait utiliser les listes de modifications de 
        Subversion, pour faire une faveur aux auteurs de ce livre.</para>

      <para>Harry commence par créer une première liste de 
        modifications et y associe les deux premiers fichiers qu'il a 
        déjà modifié. Pour ce faire, il utilise la commande
        <command>svn changelist</command> afin d'associer le même nom 
        arbitraire de liste de modifications aux deux 
        fichiers&nbsp;:</para>

      <screen>
$ svn changelist correctifs-maths entier.c ops-math.c
Le chemin 'entier.c' fait maintenant partie de la liste de changement 'correctifs-maths'.
Le chemin 'ops-math.c' fait maintenant partie de la liste de changement 'correctifs-maths'.
$ svn status

--- Liste de changements 'correctifs-maths' :
M      entier.c
M      ops-math.c
$
</screen>

      <para>Comme vous pouvez le constater, le résultat de <command>svn
        status</command> reflète bien ce nouvel ensemble.</para>

      <para>Harry se lance alors dans la correction du problème 
        d'interface graphique collatéral. Puisqu'il sait quel fichier il 
        va modifier, il associe également ce chemin à une liste de 
        modifications. Mais malencontreusement Harry associe ce 
        troisième fichier à la même liste de modifications que les deux 
        premiers&nbsp;:</para>

      <screen>
$ svn changelist correctifs-maths bouton.c
Le chemin 'bouton.c' fait maintenant partie de la liste de changement 'correctifs-maths'.
$ svn status

--- Liste de changements 'correctifs-maths' :
       bouton.c
M      entier.c
M      ops-math.c
$
</screen>

      <para>Par chance, Harry prend conscience de son erreur. Deux 
        options se présentent alors à lui. Il peut supprimer 
        l'association de <filename>bouton.c</filename>avec la liste de 
        modifications, puis lui associer un nouveau nom de liste de 
        modifications&nbsp;:</para>

      <screen>
$ svn changelist --remove bouton.c
Le chemin 'bouton.c' n'est plus associé à une liste de changements.
$ svn changelist correctifs-graphiques bouton.c
Le chemin 'bouton.c' fait maintenant partie de la liste de changement 'correctifs-graphiques'.
$
</screen>

      <para>Ou alors il peut sauter l'étape de suppression et juste 
        associer un nouveau nom de liste de modifications à 
        <filename>bouton.c</filename>. Dans ce cas, Subversion signale à 
        Harry que <filename>bouton.c</filename> va être supprimé de la 
        première liste de modifications&nbsp;:</para>

      <screen>
$ svn changelist correctifs-graphiques bouton.c
svn:  avertissement : Retrait de 'bouton.c' de la liste de changements (changelist) 'correctifs-maths'.
Le chemin 'bouton.c' fait maintenant partie de la liste de changement 'correctifs-graphiques'.
$ svn status

--- Liste de changements 'correctifs-graphiques' :
       bouton.c

--- Liste de changements 'correctifs-maths' :
M      entier.c
M      ops-maths.c
$
</screen>

      <para>Harry dispose donc à présent de deux listes de modifications 
        distinctes dans sa copie de travail et <command>svn 
        status</command> présentera ses résultats en les regroupant par 
        liste de modifications. Notez que bien qu'Harry n'ait pas encore 
        modifié <filename>bouton.c</filename>, celui-ci est quand même 
        mentionné par <command>svn status</command> car une liste de 
        modifications lui est associée. Les listes de modifications 
        peuvent être associées, ou enlevées, aux fichiers à tout moment, 
        indépendamment du fait que ces fichiers contiennent des 
        modifications locales ou pas.</para>

      <para>Harry règle maintenant le problème de l'interface graphique 
        dans <filename>bouton.c</filename>.</para>

      <screen>
$ svn status

--- Liste de changements 'correctifs-graphiques':
M      bouton.c

--- Liste de changements 'correctifs-maths':
M      entier.c
M      ops-math.c
$
</screen>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.changelists.asfilters">
      <title>Listes de modifications&nbsp;: des filtres pour vos opérations</title>

      <para>Le regroupement visuel qu'Harry constate en sortie de
        <command>svn status</command>, comme indiqué précédemment, est 
        intéressant d'un point de vue esthétique, mais pas vraiment 
        utile. La commande <command>status</command> n'est qu'une des 
        commandes qu'il est susceptible de lancer sur sa copie de 
        travail. Heureusement, bon nombre des autres opérations de 
        Subversion sont capables d'agir sur les listes de modifications 
        grâce à l'option <option>--changelist</option>.</para>

      <para>Quand l'option <option>--changelist</option> est présente, 
        les commandes Subversion limiteront leur champ d'action aux 
        fichiers auxquels est associé le nom de liste de modifications 
        donné. Si Harry veut voir quels changements il a effectué sur 
        les fichiers de sa liste <literal>correctifs-maths</literal>, il
        <emphasis>pourrait</emphasis> lister explicitement les fichiers 
        faisant partie de cette liste de modifications avec la 
        commande <command>svn diff</command>.</para>

      <screen>
$ svn diff entier.c ops-math.c
Index: entier.c
===================================================================
--- entier.c	(révision 1157)
+++ entier.c	(copie de travail)
&hellip;
Index: ops-math.c
===================================================================
--- ops-math.c	(révision 1157)
+++ ops-math.c	(copie de travail)
&hellip;
$
</screen>

      <para>Cette méthode fonctionne correctement pour un petit nombre 
        de fichiers, mais qu'en est-il si Harry a modifié une vingtaine 
        ou une trentaine de fichiers&nbsp;? Fournir la liste de tous ces 
        fichiers serait assez pénible. Mais puisqu'il utilise les listes 
        de modifications, Harry peut désormais éviter de lister 
        explicitement tous les fichiers et ne donner à la place que le 
        nom de la liste de modifications&nbsp;:</para>

      <screen>
$ svn diff --changelist correctifs-maths

Index: entier.c
===================================================================
--- entier.c	(révision 1157)
+++ entier.c	(copie de travail)
&hellip;
Index: ops-math.c
===================================================================
--- ops-math.c	(révision 1157)
+++ ops-math.c	(copie de travail)
&hellip;
$
</screen>

      <para>Et au moment de lancer la propagation, Harry peut à nouveau 
        se servir de l'option <option>--changelist</option> pour limiter 
        le rayon d'action de la propagation aux fichiers de sa liste de 
        modifications. Par exemple, il pourra propager ses changements 
        concernant l'interface graphique en lançant&nbsp;:</para>

      <screen>
$ svn ci -m "Corrigé un bug de l'interface graphique découvert en travaillant sur la logique mathématique." \
      --changelist correctifs-graphiques
Envoi        bouton.c
Transmission des données .
Révision 1158 propagée.
$
</screen>

      <para>En fait, la commande <command>svn commit</command> accepte 
        une deuxième option liée aux listes de modifications&nbsp;: 
        <option>--keep-changelists</option>. Normalement, l'association 
        des listes de modifications avec les fichiers est supprimée dès 
        que ceux-ci ont été propagés. Mais si l'option 
        <option>--keep-changelists</option> est ajoutée sur la ligne de 
        commande, les fichiers propagés (qui ne sont donc plus dans 
        l'état modifié) resteront associés aux listes de modifications 
        en question. De toute façon, propager des fichiers faisant 
        partie d'une liste de modification laisse les autres listes de 
        modifications intactes.</para>

      <screen>
$ svn status

--- Liste de changements 'correctifs-maths':
M      entier.c
M      ops-math.c
$
</screen>

      <note>
        <para>L'option <option>--changelist</option> agit comme un 
          filtre sur les cibles des commandes Subversion et n'ajoutera 
          jamais de cible à une opération. Par exemple, lors d'une 
          opération de propagation lancée via <userinput>svn commit 
          /chemin/vers/rep</userinput>, la cible est le répertoire
          <filename>/chemin/vers/rep</filename> et ses fils (avec une 
          profondeur infinie). Si ensuite vous ajoutez une option 
          spécifiant une liste de modifications à cette commande, seuls 
          les fichiers se trouvant sous le chemin 
          <filename>/chemin/vers/rep</filename> et associés à cette 
          liste de modifications seront pris en compte en tant que 
          cibles de la propagation&nbsp;; ne seront pas inclus les 
          fichiers situés ailleurs (tels ceux sous
          <filename>/chemin/vers/autre-rep</filename>), quelle que soit 
          la liste de modifications à laquelle ils appartiennent, même 
          s'il font partie de la même copie de travail que la ou les 
          cibles de l'opération.</para>
      </note>

      <para>Même la commande <command>svn changelist</command> accepte 
        l'option <option>--changelist</option>. Ceci vous permet de 
        renommer ou supprimer facilement une liste de 
        modifications&nbsp;:</para>

      <screen>
$ svn changelist bogues-maths --changelist correctifs-maths --depth infinity .
svn: avertissement : Retrait de 'entier.c' de la liste de changements (changelist) 'correctifs-maths'.
Le chemin 'entier.c' fait maintenant partie de la liste de changement 'bogues-maths'.
svn: avertissement : Retrait de 'ops-math.c' de la liste de changements (changelist) 'correctifs-maths'.
Le chemin 'ops-math.c' fait maintenant partie de la liste de changement 'bogues-maths'.
$ svn changelist --remove --changelist bogues-maths --depth infinity .
Le chemin 'entier.c' n'est plus associé à une liste de changements.
Le chemin 'ops-math.c' n'est plus associé à une liste de changements.
$
</screen>

      <para>Enfin, vous pouvez spécifier plusieurs instances de l'option 
        <option>--changelist</option> dans une même ligne de commande. 
        Ceci limite le champ d'action de votre opération aux fichiers 
        faisant partie de toutes les listes de modifications 
        spécifiées.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.changelists.limitations">
      <title>Limitations des listes de modifications</title>

      <para>La fonctionnalité de listes de modifications de Subversion 
        est un outil très pratique pour créer des groupes de fichiers au 
        sein de la copie de travail, mais elle a cependant quelques 
        limitations. Les listes de modifications sont des objets 
        contenus à l'intérieur d'une copie de travail, ce qui signifie 
        que les associations entre fichiers et listes de modifications 
        ne peuvent pas être propagées vers le dépôt, ni partagées avec 
        d'autres utilisateurs. Les listes de modifications ne peuvent 
        être associées qu'à des fichiers, Subversion n'offre pas cette 
        possibilité pour les répertoires. Enfin, vous ne pouvez avoir 
        qu'au plus un nom de liste de modifications associé à un fichier 
        donné. C'est ici que l'analogie avec les articles de blogs et 
        les services d'étiquetage de photos en ligne part en fumée. S'il 
        vous faut associer un fichier à plusieurs listes de 
        modifications, vous êtes coincé.</para>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.netmodel">
    <title>Modèle de communication réseau</title>

    <para>&Agrave; un moment ou à un autre, vous aurez besoin de 
      comprendre comment le client Subversion communique avec le 
      serveur. La couche réseau de Subversion est abstraite, 
      c'est-à-dire que les clients Subversion ont le même comportement 
      quel que soit le type de serveur auquel ils ont affaire. Qu'ils 
      communiquent via le protocole HTTP (<literal>http://</literal>) 
      avec un serveur HTTP Apache ou via le protocole Subversion 
      (<literal>svn://</literal>) avec <command>svnserve</command>,
      le modèle de communication réseau est le même. Dans cette section, 
      nous expliquerons les fondamentaux de ce modèle de communication 
      réseau, y compris la façon dont Subversion gère les 
      authentifications et les autorisations.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.netmodel.reqresp">
      <title>Requêtes et réponses</title>

      <para>Le client Subversion passe la plupart de son temps à gérer 
        des copies de travail. Cependant, quand il a besoin 
        d'informations disponibles dans un dépôt distant, il envoie une 
        requête sur le réseau et le serveur lui répond. Les détails du 
        protocole réseau sont cachés à l'utilisateur&nbsp;: le client 
        essaie d'accéder à une URL et, suivant le format de cette URL, 
        utilise un protocole particulier pour contacter le serveur 
        (voir <xref linkend="svn.basic.in-action.wc.sb-1"/>).</para>

      <tip><para>Tapez <userinput>svn --version</userinput> pour voir 
        quels types d'URL et de protocoles sont utilisables par votre 
        client.</para>
      </tip>

      <para>Quand le serveur reçoit une requête d'un client, il demande 
        souvent au client de s'identifier. Il envoie un défi 
        d'authentification vers le client et le client répond en 
        fournissant les <firstterm>éléments 
        d'authentification</firstterm> au serveur. Une fois cette 
        authentification terminée, le serveur répond à la requête 
        originale du client. Remarquez que ce fonctionnement est 
        différent de celui de CVS où le client envoie systématiquement 
        au préalable ses identifiants de connexion (procédure de 
        <quote>log in</quote>), avant même de formuler la moindre 
        requête. Dans Subversion, le serveur requiert explicitement 
        l'authentification du client (par un défi d'authentification) 
        au moment approprié, au lieu que ce soit le client qui 
        s'authentifie a priori. Certaines opérations sont donc 
        effectuées plus élégamment. Par exemple, si un serveur est 
        configuré pour laisser tout le monde lire un dépôt, alors le 
        serveur n'enverra jamais de défi d'authentification quand un 
        client tente un <command>svn checkout</command>.</para>

      <para>Si une requête d'un client conduit à la création d'une 
        nouvelle révision du dépôt (par exemple un <command>svn 
        commit</command>), alors Subversion utilise le nom d'utilisateur 
        fourni lors de la phase d'authentification comme auteur de la 
        révision. C'est-à-dire que le nom d'utilisateur est stocké dans 
        la propriété <literal>svn:author</literal> de la nouvelle 
        révision (voir <xref linkend="svn.ref.properties"/>). Si le 
        client n'a pas été authentifié (en d'autres termes, si le 
        serveur n'a jamais envoyé de défi d'authentification), alors la 
        propriété <literal>svn:author</literal> de la révision est 
        vide.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.netmodel.credcache">
      <title>Mise en cache des éléments d'authentification du client</title>

      <para>Beaucoup de serveurs sont configurés pour demander une 
        authentification à chaque requête. Ce serait particulièrement 
        pénible pour les utilisateurs s'ils devaient taper leur mot de 
        passe à chaque fois. Heureusement, le client Subversion a une 
        solution&nbsp;: la mise en cache sur le disque des éléments 
        d'authentification. Par défaut, si le client en ligne de 
        commande s'authentifie avec succès auprès d'un serveur, le 
        client sauvegarde les éléments d'authentification dans une zone 
        privée propre à l'utilisateur
        (<filename>~/.subversion/auth/</filename> sur les systèmes de 
        type Unix ou <filename>%APPDATA%/Subversion/auth/</filename> sur 
        Windows)&nbsp;; voir <xref linkend="svn.advanced.confarea" /> 
        pour plus de détails). Les éléments d'authentification sont mis 
        en cache sur le disque, classés suivant une combinaison du nom, 
        du port et du domaine d'authentification du serveur.</para>

      <para>Quand le client reçoit un défi d'authentification, il 
        regarde d'abord s'il dispose des éléments appropriés dans le 
        cache disque de l'utilisateur. Si ce n'est pas le cas, ou si les 
        éléments conduisent à un échec lors de la tentative 
        d'authentification, le client demande alors (c'est son 
        comportement par défaut) à l'utilisateur les informations 
        nécessaires.</para>

      <para>Ici, le lecteur soucieux de sécurité va immédiatement 
        commencer à s'inquiéter&nbsp;: <quote>Mettre en cache des mots 
        de passe sur le disque&nbsp;? Quelle horreur&nbsp;! 
        Jamais&nbsp;!</quote></para>

      <para>Les développeurs de Subversion reconnaissent le bien fondé 
        du problème et c'est pourquoi Subversion est capable de 
        fonctionner avec les différents mécanismes offerts par le 
        système d'exploitation et l'environnement de travail pour 
        minimiser le risque d'une fuite de ces informations. Voici ce 
        que cela veut dire sur les plates-formes les plus 
        courantes&nbsp;:</para>

      <itemizedlist>

        <listitem>
          <para>Sur Windows 2000 et ses successeurs, le client 
            Subversion utilise les services cryptographiques standards 
            de Windows pour chiffrer le mot de passe sur le disque. 
            Comme la clé de chiffrement est gérée par Windows et qu'elle
            est associée à l'identifiant de connexion de l'utilisateur, 
            lui seul peut déchiffrer le mot de passe en cache. Notez que 
            si le mot de passe de l'utilisateur est ré-initialisé par un 
            administrateur, tous les mots de passe en cache deviennent 
            indéchiffrables. Le client Subversion agira comme s'ils 
            n'existaient pas, en redemandant le mot de passe quand c'est 
            nécessaire. </para>
        </listitem>

        <listitem>
          <para>De manière similaire, sur Mac OS X, le client Subversion 
            stocke tous les mots de passe dans le jeton de connexion 
            (géré par le service Keychain), qui est protégé par le mot 
            de passe du compte utilisateur. La configuration des 
            <quote>préférences utilisateur</quote> peuvent imposer une 
            politique plus stricte, comme par exemple demander le mot de 
            passe du compte utilisateur à chaque fois qu'un mot de passe 
            Subversion est utilisé.</para>
        </listitem>

        <listitem>
          <para>Pour les systèmes de type Unix, il n'existe pas de 
            standard de service de type <quote>keychain</quote>. 
            Cependant, la zone de cache <filename>auth/</filename> est 
            toujours protégée par les droits système et seul 
            l'utilisateur (le propriétaire) des données peut les lire. 
            Les droits sur les fichiers fournis par le système 
            d'exploitation protègent les mots de passe.</para>
        </listitem>

      </itemizedlist>

      <para>Bien sûr, si vous êtes complètement paranoïaque, aucun de 
        ces mécanismes n'est parfait. Ainsi, pour ceux qui sont prêt à 
        sacrifier le confort d'utilisation au profit de la sécurité 
        absolue, Subversion fournit de nombreuses façons de désactiver 
        le système de cache d'authentification.</para>

      <para>Pour désactiver le système de cache pour une seule commande, 
        utilisez l'option <option>--no-auth-cache</option>&nbsp;:</para>

      <screen>
$ svn commit -F log_msg.txt --no-auth-cache
Domaine d'authentification : &lt;svn://hote.exemple.com:3690&gt; exemple de domaine
Nom d'utilisateur :  paul
Mot de passe pour 'paul' :

Ajout         nouveau_fichier
Transmission des données .
Révision 2324 propagée.

# le mot de passe n'a pas été mis dans le cache, donc la deuxième propagation 
# nous redemandera le mot de passe

$ svn delete nouveau_fichier
$ svn commit -F nouveau_msg.txt
Domaine d'authentification : &lt;svn://hote.exemple.com:3690&gt; exemple de domaine
Nom d'utilisateur :  paul
&hellip;
</screen>

      <para>Autrement, si vous voulez désactiver la mise en cache des 
        éléments d'authentification de manière permanente, vous pouvez 
        éditer le fichier <filename>config</filename> de votre zone de 
        configuration en mettant l'option 
        <option>store-auth-creds</option> à <literal>no</literal>. La 
        mise en cache des éléments d'authentification sera désactivée 
        pour toutes les commandes Subversion que vous effectuerez sur 
        cet ordinateur. Ceci peut être étendu à l'ensemble des 
        utilisateurs de l'ordinateur en modifiant la configuration 
        globale de Subversion (voir <xref
        linkend="svn.advanced.confarea.layout" />).</para>

      <screen>
[auth]
store-auth-creds = no
</screen>

      <para>Il arrive que les utilisateurs veuillent effacer certains 
        mots de passe du cache disque. Pour ce faire, vous devez vous 
        rendre dans la zone <filename>auth/</filename> et effacer 
        manuellement le fichier de cache approprié. Les éléments 
        d'authentification sont mis en cache dans des fichiers 
        individuels&nbsp;; si vous affichez chaque fichier, vous verrez 
        des clés et des valeurs. La clé 
        <literal>svn:realmstring</literal> décrit le domaine du serveur 
        auquel est associé le fichier&nbsp;:</para>

      <screen>
$ ls ~/.subversion/auth/svn.simple/
5671adf2865e267db74f09ba6f872c28
3893ed123b39500bca8a0b382839198e
5c3c22968347b390f349ff340196ed39

$ cat ~/.subversion/auth/svn.simple/5671adf2865e267db74f09ba6f872c28

K 8
username
V 3
paul
K 8
password
V 4
blah
K 15
svn:realmstring
V 45
&lt;https://svn.domaine.com:443&gt; Dépôt de Paul
END
</screen>

      <para>Une fois le bon fichier trouvé, effacez-le.</para>

      <para>Un dernier mot sur la façon dont <command>svn</command> gère 
        l'authentification, avec un zoom sur les options
        <option>--username</option> et <option>--password</option>. 
        Beaucoup de sous-commandes du client acceptent ces options, mais 
        il est important de comprendre que l'utilisation de ces options 
        <emphasis>n'envoie pas</emphasis> automatiquement les éléments 
        d'authentification au serveur. Comme vu précédemment, le serveur 
        <emphasis>demande</emphasis> explicitement l'authentification au 
        client quand il estime que c'est nécessaire&nbsp;; le client ne 
        les envoie pas à sa convenance. Même si un nom d'utilisateur 
        et/ou un mot de passe sont passés en option, ils ne seront 
        envoyés au serveur que si celui-ci les demande. Ces options sont 
        couramment utilisées pour s'authentifier sous un nom 
        d'utilisateur différent de celui que Subversion aurait choisi 
        par défaut (comme votre nom de compte système), ou quand on ne 
        veut pas de commande interactive (par exemple, utilisation de la
        commande <command>svn</command> dans un script).</para>

      <note>
        <para>Une erreur classique consiste à mal configurer un serveur 
          de telle sorte qu'il n'envoie jamais de défi 
          d'authentification. Quand les utilisateurs passent les options
          <option>--username</option> et <option>--password</option>, 
          ils sont surpris de voir qu'elles ne sont jamais utilisées, 
          c'est-à-dire que les nouvelles révisions semblent toujours 
          avoir été propagées de façon anonyme&nbsp;!</para>
      </note>

      <para>En résumé, voici comment un client Subversion se comporte 
        quand il reçoit un défi d'authentification&nbsp;:</para>

      <orderedlist>
        <listitem>
          <para>D'abord, le client vérifie si l'utilisateur a spécifié 
            explicitement des éléments d'authentification dans la ligne 
            de commande (options <option>--username</option> et/ou
            <option>--password</option>). Si c'est le cas, le client 
            essaiera ces éléménts pour s'authentifier auprès du 
            serveur.</para>
        </listitem>
        <listitem>
          <para>Si les éléments d'authentification ne sont pas passés en
            ligne de commande, ou si ceux qui on été fournis ne sont pas
            valides, Le client regarde dans la zone 
            <filename>auth/</filename>  s'il trouve le nom, le port et 
            le domaine du serveur pour voir si l'utilisateur a déjà les 
            éléments d'authentification en cache. Si c'est le cas, il 
            essaie d'utiliser ces éléments pour s'authentifier.</para>
        </listitem>
        <listitem>
          <para>Finalement, si les mécanismes précédents ont abouti à 
            des échecs d'authentification sur le serveur, le client se 
            résout à demander les éléments à l'utilisateur (à moins 
            qu'il ne lui ait été indiqué de ne pas le faire via 
            l'option <option>--non-interactive</option> ou son 
            équivalent spécifique au client).</para>
        </listitem>
      </orderedlist>

      <para>Si le client réussit à s'authentifier par l'une ou l'autre 
        de ces méthodes, il essaiera de mettre en cache les éléments 
        d'authentification sur le disque (à moins que cette 
        fonctionnalité ne soit désactivée, comme indiqué 
        auparavant).</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.summary">
    <title>Résumé</title>

    <para>Après avoir lu ce chapitre, vous devriez désormais avoir une 
      bonne compréhension de certaines fonctionnalités de Subversion 
      qui, bien qu'elles ne servent pas systématiquement à chaque 
      utilisation du système de gestion de versions, peuvent rendre de 
      grands services. Ne vous arrêtez pas là&nbsp;! Lisez le chapitre 
      suivant, où vous découvrirez les branches, les étiquettes et les 
      fusions. Vous aurez alors la maîtrise quasi-complète du client 
      Subversion. Bien que nos avocats ne nous autorisent pas à vous 
      promettre quoi que ce soit, ces connaissances supplémentaires 
      feront déjà de vous quelqu'un de bien plus branché.
      <footnote>
        <para>Aucun achat nécessaire. Certaines conditions s'appliquent. 
          Aucune garantie, ni explicite ni implicite, n'est fournie. 
          Le kilométrage peut varier.</para>
      </footnote>
    </para>

  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
