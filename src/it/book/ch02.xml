<chapter id="svn.basic">
  <!-- <title>Basic Concepts</title> -->
  <title>Concetti base</title>

  <simplesect>
    <para lang="en">This chapter is a short, casual introduction to Subversion.
      If you're new to version control, this chapter is definitely for
      you.  We begin with a discussion of general version control
      concepts, work our way into the specific ideas behind
      Subversion, and show some simple examples of Subversion in
      use.</para>

    <para>Questo paragrafo è una introduzione corta ed informale a Subversion.
      Se si è nuovi rispetto al controllo di versione, questo è sicuramente il
      capitolo più adatto da cui partire. Inizieremo con una introduzione ai
      concetti generali del controllo di versione, approfondiremo le idee
      specifiche che sono dietro Subversion ed illustreremo qualche semplice
      esempio di Subversion in uso.</para>

    <para lang="en">Even though the examples in this chapter show people sharing
      collections of program source code, keep in mind that Subversion
      can manage any sort of file collection&mdash;it's not limited to
      helping computer programmers.</para>

    <para>Anche se gli esempi in questo capitolo mostrano persone che
      condividono collezioni di codice sorgente di programmi, è bene tenere
      presente che Subversion può gestire qualsiasi tipo di collezione di file
      &mdash; non è limitato ad aiutare programmatori.</para>
  </simplesect>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.repository">
    <!-- <title>The Repository</title> -->
    <title>Il repository</title>

    <para lang="en">Subversion is a centralized system for sharing information.
      At its core is a repository, which is a central store of data.
      The repository stores information in the form of a
      <firstterm>filesystem tree</firstterm>&mdash;a typical hierarchy
      of files and directories.  Any number of
      <firstterm>clients</firstterm> connect to the repository, and
      then read or write to these files.  By writing data, a client
      makes the information available to others; by reading data, the
      client receives information from others.  <xref
      linkend="svn.basic.repository.dia-1"/> illustrates this.</para>

    <para>Subversion è un sistema centralizzato per la condivisione
      delle informazioni. Al suo centro c'è il repository, che è l'archivio
      principale di dati. Il repository memorizza informazioni nella forma di un
      <firstterm>filesystem ad albero</firstterm>&mdash; la tipica gerarchia di
      file e directory. Un numero arbitrario di <firstterm>client</firstterm>
      può connettersi al repository e leggere o scrivere questi file. Scrivendo
      i dati, un client rende le informazioni disponibili agli altri; leggendo i
      dati, il client riceve le informazioni dagli altri. <xref
      linkend="svn.basic.repository.dia-1"/> illustra il meccanismo.</para>

    <figure id="svn.basic.repository.dia-1">
      <!-- <title>A typical client/server system</title> -->
      <title>Un tipico sistema client/server</title>
      <graphic fileref="images/ch02dia1.png"/>
    </figure>

    <para lang="en">So why is this interesting?  So far, this sounds like the
      definition of a typical file server.  And indeed, the repository
      <emphasis>is</emphasis> a kind of file server, but it's not your
      usual breed.  What makes the Subversion repository special is
      that <emphasis>it remembers every change</emphasis> ever written
      to it: every change to every file, and even changes to the
      directory tree itself, such as the addition, deletion, and
      rearrangement of files and directories.</para>

    <para>Perché quindi questo aspetto dovrebbe sembrare interessante?
      Inizialmente potrebbe sembrare la tipica definizione di un file server. In
      effetti il repository <emphasis>è</emphasis> una sorta di file server, ma
      non nell'accezione comune. Quello che rende Subversion un repository
      speciale è che <emphasis>ricorda qualsiasi cambiamento</emphasis> scritto
      in esso: ogni cambiamento ad ogni file, e perfino modifiche allo stesso
      albero delle directory, come l'aggiunta, la cancellazione ed il
      riarrangiamento di file e directory.</para>

    <para lang="en">When a client reads data from the repository, it normally
      sees only the latest version of the filesystem tree.  But the
      client also has the ability to view
      <emphasis>previous</emphasis> states of the filesystem.  For
      example, a client can ask historical questions like, <quote>What
      did this directory contain last Wednesday?</quote> or <quote>Who
      was the last person to change this file, and what changes did
      he make?</quote> These are the sorts of questions that are at
      the heart of any <firstterm>version control system</firstterm>:
      systems that are designed to record and track changes to data
      over time.</para>

    <para>Quando un client legge i dati dal repository, normalmente vede solo
      l'ultima versione dell'albero del filesystem. Il client in realtà ha anche
      la possibilità di vedere uno stato <emphasis>precedente</emphasis> del
      filesystem. Ad esempio, un client può chiedere domande storiche come
      <quote>Cosa conteneva questa directory l'ultimo Mercoledì?</quote> oppure
      <quote>Chi è stata l'ultima persona a cambiare questo file, e che
      modifiche ha apportato?</quote>. Queste sono le tipologie di domande che
      sono alla base di qualsiasi <firstterm>sistema di controllo di
      versione</firstterm>: sistemi che sono progettati per registrare e tenere
      traccia delle modifiche ai dati nel tempo.</para>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.vsn-models">
    <!-- <title>Versioning Models</title> -->
    <title>I modelli di versionamento</title>

    <para lang="en">The core mission of a version control system is to enable
      collaborative editing and sharing of data.  But different
      systems use different strategies to achieve this.</para>

    <para>La missione principale di un sistema di controllo di versione è
      abilitare la modifica collaborativa e la condivisione dei dati. In realtà
      sistemi differenti usano strategie differenti per ottenerlo.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.vsn-models.problem-sharing">
      <!-- <title>The Problem of File-Sharing</title> -->
      <title>Il problema della condivisione dei file</title>

      <para lang="en">All version control systems have to solve the same
        fundamental problem: how will the system allow users to share
        information, but prevent them from accidentally stepping on
        each other's feet?  It's all too easy for users to
        accidentally overwrite each other's changes in the
        repository.</para>

      <para>Tutti i sistemi per il controllo di versione devono risolvere lo
        stesso problema fondamentale: come farà il sistema a permettere agli
        utenti di condividere le informazioni, evitando al contempo che questi possano
        accidentalmente interferire fra loro? È troppo semplice infatti per gli
        utenti sovrascrivere accidentalmente le modifiche degli altri nel
        repository.</para>

      <para lang="en">Consider the scenario shown in <xref
        linkend="svn.basic.vsn-models.problem-sharing.dia-1"/>.
        Suppose we have two co-workers, Harry and Sally.  They each
        decide to edit the same repository file at the same time.  If
        Harry saves his changes to the repository first, then it's
        possible that (a few moments later) Sally could accidentally
        overwrite them with her own new version of the file.  While
        Harry's version of the file won't be lost forever (because the
        system remembers every change), any changes Harry made
        <emphasis>won't</emphasis> be present in Sally's newer version
        of the file, because she never saw Harry's changes to begin
        with.  Harry's work is still effectively lost&mdash;or at
        least missing from the latest version of the file&mdash;and
        probably by accident.  This is definitely a situation we want
        to avoid!</para>

      <para>Si consideri lo scenario illustrato in <xref
        linkend="svn.basic.vsn-models.problem-sharing.dia-1"/>. Supponiamo di
        avere 2 collaboratori, che chiameremo Hally e Sally. Entrambi decidono
        di modificare lo stesso file del repository nello stesso momento. Se
        Harry salva le sue modifiche nel repository per primo, è possibile che
        (qualche istante dopo) Sally possa accidentalmente sovrascriverle con
        la propria versione aggiornata del file. Mentre la versione di Harry del
        file non verrà persa per sempre (perché il sistema ricorda ogni
        cambiamento), qualsiasi cambiamento apportato da Harry
        <emphasis>non</emphasis> sarà presente nella nuova versione del file di
        Sally, perché lei non ha mai ricevuto le modifiche di Harry da cui poter
        continuare. Il lavoro di Harry è effettivamente perso&mdash;o
        quantomeno mancante dall'ultima versione del file&mdash;e probabilmente
        accidentalmente. Questa è sicuramente la situazione che si vuole
        evitare.</para>

      <figure id="svn.basic.vsn-models.problem-sharing.dia-1">
        <!-- <title>The problem to avoid</title> -->
        <title>Il problema da evitare</title>
        <graphic fileref="images/ch02dia2.png"/>
      </figure>

      </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.vsn-models.lock-unlock">
      <!-- <title>The Lock-Modify-Unlock Solution</title> -->
      <title>La soluzione blocca-modifica-sblocca (Lock-Modify-Unlock)</title>

      <para lang="en">Many version control systems use a
        <firstterm>lock-modify-unlock</firstterm> model to address the
        problem of many authors clobbering each other's work.  In this
        model, the repository allows only one person to change a file
        at a time.  This exclusivity policy is managed using locks.
        Harry must <quote>lock</quote> a file before he can begin
        making changes to it.  If Harry has locked a file, then Sally
        cannot also lock it, and therefore cannot make any changes to
        that file.  All she can do is read the file, and wait for
        Harry to finish his changes and release his lock.  After Harry
        unlocks the file, Sally can take her turn by locking and
        editing the file.  <xref
        linkend="svn.basic.vsn-models.lock-unlock.dia-1"/>
        demonstrates this simple solution.</para>

      <para>Molti sistemi per il controllo di versione usano un modello
        <firstterm>blocca-modifica-sblocca</firstterm> per trattare il
        potenziale problema di più autori che compromettono il proprio lavoro.
        In questo modello, il repository permette solo ad una persona alla volta
        di modificare un file. Questa politica di esclusione è gestita
        attraverso dei blocchi (lock). Harry deve <quote>bloccare</quote> un
        file prima di apportare modifiche allo stesso. Se Harry ha bloccato il
        file, Sally non potrà a sua volta bloccarlo, e quindi non potrà
        apportare modifiche allo stesso. Tutto quello che può fare è leggere il
        file ed aspettare che Harry abbia finito le sue modifiche e rilasci il
        suo blocco. Dopo che Harry avrà sbloccato il file, Sally potrà prendere
        il suo turno bloccando e modificando il file.
        <xref linkend="svn.basic.vsn-models.lock-unlock.dia-1"/> dimostra questa
        semplice soluzione.</para>

      <figure id="svn.basic.vsn-models.lock-unlock.dia-1">
      <!-- <title>The lock-modify-unlock solution</title> -->
      <title>La soluzione blocca-modifica-sblocca</title>
        <graphic fileref="images/ch02dia3.png"/>
      </figure>

      <para lang="en">The problem with the lock-modify-unlock model is that it's
        a bit restrictive, and often becomes a roadblock for
        users:</para>

      <para>Il problema con il modello blocca-modifica-sblocca è che risulta un
        po' restrittivo, e spesso diventa come un ostacolo per gli utenti:
        </para>

      <itemizedlist>
        <listitem>
          <para lang="en"><emphasis>Locking may cause administrative
            problems.</emphasis>

            Sometimes Harry will lock a file and then forget about it.
            Meanwhile, because Sally is still waiting to edit the file,
            her hands are tied.  And then Harry goes on vacation.  Now
            Sally has to get an administrator to release Harry's lock.
            The situation ends up causing a lot of unnecessary delay
            and wasted time.</para>

          <para><emphasis>Il blocco potrebbe creare problemi di natura
            amministrativa.</emphasis>

            A volte Harry si scorda di aver bloccato un file. Nel frattempo
            Sally, poiché sta aspettando di modificare il file, avrà le mani
            legate. Se in seguito Harry andrà in ferie, Sally si troverà
            costretta a contattare un amministratore per far rilasciare il
            blocco di Harry. La situazione si conclude con un notevole ritardo e
            tempo sprecato.</para>
        </listitem>

        <listitem>
          <para lang="en"><emphasis>Locking may cause unnecessary
            serialization.</emphasis>

            What if Harry is editing the beginning of a text file,
            and Sally simply wants to edit the end of the same file?
            These changes don't overlap at all.  They could easily
            edit the file simultaneously, and no great harm would
            come, assuming the changes were properly merged together.
            There's no need for them to take turns in this
            situation.</para>

          <para><emphasis>Il blocco potrebbe creare inutili
            serializzazioni.</emphasis>

            Cosa accade se Harry sta modificando l'inizio di un file di testo,
            mentre Sally vuole semplicemente modificare la parte finale dello
            stesso file? Questi cambiamenti non si sovrappongono in nessun modo.
            Loro potrebbero modificare il file simultaneamente, senza creare
            nessun danno, assumendo che i cambiamenti vengano propriamente
            fusi. Non c'è necessità per loro di prendere un turno in questa
            situazione.
          </para>
        </listitem>

        <listitem>
          <para lang="en"><emphasis>Locking may create a false sense of
            security.</emphasis>

            Pretend that Harry locks and edits file A, while
            Sally simultaneously locks and edits file B.  But suppose
            that A and B depend on one another, and the changes made
            to each are semantically incompatible.  Suddenly A and B
            don't work together anymore.  The locking system was
            powerless to prevent the problem&mdash;yet it somehow
            provided a false sense of security.  It's easy for Harry and
            Sally to imagine that by locking files, each is beginning a
            safe, insulated task, and thus not bother
            discussing their incompatible changes early
            on.</para>

          <para><emphasis>Il blocco potrebbe creare un falso senso di
            sicurezza.</emphasis>

            Supponiamo che Harry blocchi e modifichi un file A, e
            simultaneamente Sally blocchi e modifichi un file B. Ma supponiamo
            che A e B dipendano l'uno dall'altro, e che le modifiche apportate
            ad entrambi siano semanticamente incompatibili. Improvvisamente A e
            B non funzionano più correttamente insieme. La soluzione del blocco
            non è stata in grado di prevenire il problema&mdash;pertanto si
            riceve in qualche modo un falso senso di sicurezza. È facile per
            Harry e Sally immaginare che bloccando i file, ognuno stia
            iniziando una operazione sicura ed isolata, e di conseguenza non si
            preoccupano di discutere i propri cambiamenti incompatibili in
            anticipo.
          </para>
        </listitem>
      </itemizedlist>

      </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.vsn-models.copy-merge">
      <!-- <title>The Copy-Modify-Merge Solution</title> -->
      <title>La soluzione copia-modifica-fondi (Copy-Modify-Merge)</title>

      <para lang="en">Subversion, CVS, and other version control systems use a
        <firstterm>copy-modify-merge</firstterm> model as an
        alternative to locking.  In this model, each user's client
        contacts the project repository and creates a personal
        <firstterm>working copy</firstterm>&mdash;a local reflection
        of the repository's files and directories.  Users then work in
        parallel, modifying their private copies.  Finally, the
        private copies are merged together into a new, final version.
        The version control system often assists with the merging, but
        ultimately a human being is responsible for making it happen
        correctly.</para>

      <para>Subversion, CVS, ed altri sistemi per il controllo di versione usano
        il modello <firstterm>copia-modifica-fondi</firstterm> come alternativa
        al blocco. In questo modello, il client di ogni utente comunica con il
        repository e crea la propria
        <firstterm>copia di lavoro</firstterm>&mdash;una riproduzione dei
        file e delle directory del repository. Gli utenti possono poi lavorare
        in parallelo, modificando le proprie copie private. Infine, le copie
        private vengono fuse in una nuova versione finale. Spesso il sistema per
        il controllo di versione assiste nella fase di integrazione, ma alla
        fine è un essere umano il responsabile di fare in modo che questa si
        compia correttamente.</para>

      <para lang="en">Here's an example.  Say that Harry and Sally each create
        working copies of the same project, copied from the
        repository.  They work concurrently, and make changes to the
        same file A within their copies.  Sally saves her changes to
        the repository first.  When Harry attempts to save his changes
        later, the repository informs him that his file A is
        <firstterm>out-of-date</firstterm>.  In other words, that file
        A in the repository has somehow changed since he last copied
        it.  So Harry asks his client to <firstterm>merge</firstterm>
        any new changes from the repository into his working copy of
        file A.  Chances are that Sally's changes don't overlap with
        his own; so once he has both sets of changes integrated, he
        saves his working copy back to the repository.  <xref
        linkend="svn.basic.vsn-models.copy-merge.dia-1"/> and <xref
        linkend="svn.basic.vsn-models.copy-merge.dia-2"/> show this process.
      </para>

      <para>Ecco un esempio. Supponiamo che Harry e Sally creino una copia
        locale dello stesso progetto, copiata dallo stesso repository. Loro
        lavorano concorrentemente, ed apportano modifiche allo stesso file A
        all'interno delle loro copie. Sally salva le proprie modifiche per prima
        sul repository. Quando Harry prova successivamente a salvare i propri
        cambiamenti, il repository lo informa che il suo file A è
        <firstterm>obsoleto</firstterm>. In altre parole, questo file A è
        cambiato nel repository rispetto all'ultima volta che lui lo ha copiato.
        Quindi Harry chiede al repository di <firstterm>fondere</firstterm>
        ogni nuovo cambiamento dal repository alla sua copia locale del file A.
        Con buona probabilità i cambiamenti di Sally non si sovrappongono con i
        suoi; quindi una volta che ha integrato entrambi gli insiemi di
        cambiamenti, salva la sua copia di lavoro nel repository.
        <xref linkend="svn.basic.vsn-models.copy-merge.dia-1"/> e <xref
        linkend="svn.basic.vsn-models.copy-merge.dia-2"/> mostrano questo
        processo.</para>

      <figure id="svn.basic.vsn-models.copy-merge.dia-1">
      <!-- <title>The copy-modify-merge solution</title> -->
      <title>La soluzione copia-modifica-fondi</title>
        <graphic fileref="images/ch02dia4.png"/>
      </figure>

      <figure id="svn.basic.vsn-models.copy-merge.dia-2">
      <!-- <title>The copy-modify-merge solution (continued)</title> -->
      <title>La soluzione copia-modifica-fondi (continua)</title>
        <graphic fileref="images/ch02dia5.png"/>
      </figure>

      <para lang="en">But what if Sally's changes <emphasis>do</emphasis> overlap
        with Harry's changes?  What then?  This situation is called a
        <firstterm>conflict</firstterm>, and it's usually not much of
        a problem.  When Harry asks his client to merge the latest
        repository changes into his working copy, his copy of file A
        is somehow flagged as being in a state of conflict: he'll be
        able to see both sets of conflicting changes, and manually
        choose between them.  Note that software can't automatically
        resolve conflicts; only humans are capable of understanding
        and making the necessary intelligent choices.  Once Harry has
        manually resolved the overlapping changes&mdash;perhaps after
        a discussion with Sally&mdash;he can safely save the
        merged file back to the repository.</para>

      <para>Cosa accade se le modifiche di Sally <emphasis>di fatto</emphasis>
        si sovrappongono a quelle di Harry? Che comporta? Questa situazione è
        chiamata<firstterm>conflitto</firstterm>, ed in generale non è un grande
        problema. Quando Harry chiede al proprio client di fondere le ultime
        modifiche del repository nella sua copia di lavoro, la propria copia del
        file A è in qualche modo etichettata come in uno stato di conflitto:
        lui sarà in grado di vedere entrambi gli insiemi di cambiamenti e
        scegliere manualmente tra questi. Da notare che il software non può
        risolvere il conflitto automaticamente; solo gli uomini sono capaci di
        capire e fare le necessarie scelte intelligenti. Una volta che Harry ha
        risolto manualmente i cambiamenti sovrapposti&mdash; probabilmente dopo
        una discussione con Sally&mdash; può salvare in maniera sicura il file
        integrato nel repository.</para>

      <para lang="en">The copy-modify-merge model may sound a bit chaotic, but
        in practice, it runs extremely smoothly.  Users can work in
        parallel, never waiting for one another.  When they work on
        the same files, it turns out that most of their concurrent
        changes don't overlap at all; conflicts are infrequent.  And
        the amount of time it takes to resolve conflicts is far less
        than the time lost by a locking system.</para>

      <para>Il modello copia-modifica-fondi può sembrare un po' caotico, ma
        nella pratica funziona senza difficoltà. L'utente può lavorare in
        parallelo, senza mai dover aspettare gli altri. Quando gli utenti
        lavorano sullo stesso file, accade frequentemente che la maggior parte
        delle modifiche concorrenti non si sovrappongano; i conflitti sono
        infatti rari. La quantità di tempo necessario per risolvere i conflitti
        è decisamente inferiore a quella persa nell'uso di un sistema di
        blocchi.</para>

      <para lang="en">In the end, it all comes down to one critical factor: user
        communication.  When users communicate poorly, both syntactic
        and semantic conflicts increase.  No system can force users to
        communicate perfectly, and no system can detect semantic
        conflicts.  So there's no point in being lulled into a false
        promise that a locking system will somehow prevent conflicts;
        in practice, locking seems to inhibit productivity more than
        anything else.</para>

      <para>Alla fine, tutto si riconduce ad un fattore critico: la
        comunicazione degli utenti. Quando la comunicazione è povera, sia i
        conflitti sintattici che semantici aumentano. Nessun sistema può forzare
        l'utente a comunicare perfettamente, e nessun sistema può scovare
        conflitti semantici. Non c'è quindi nessuna ragione per rimanere illusi
        dalla falsa promessa che il sistema a blocchi prevenga in qualche modo
        i conflitti; nella pratica, il blocco sembra più che altro limitare la
        produttività.</para>

      <sidebar id="svn.basic.vsn-models.copy-merge.sb-1">
        <!-- <title>When Locking is Necessary</title> -->
        <title>Quando i blocchi sono necessari</title>

        <para lang="en">While the lock-modify-unlock model is considered
          generally harmful to collaboration, there are still times
          when locking is appropriate.</para>

        <para>Mentre il modello blocca-modifica-sblocca è considerato
          generalmente un ostacolo alla collaborazione, ci sono comunque casi in
          cui il sistema di blocchi risulta appropriato.</para>

        <para lang="en">The copy-modify-merge model is based on the assumption
          that files are contextually mergeable: that is, that the
          majority of the files in the repository are line-based text
          files (such as program source code).  But for files with
          binary formats, such as artwork or sound, it's often
          impossible to merge conflicting changes.  In these
          situations, it really is necessary to users to take strict
          turns when changing the file.  Without serialized access,
          somebody ends up wasting time on changes that are ultimately
          discarded.</para>

        <para>Il modello copia-modifica-fondi è basato sull'assunzione che i
          file siano contestualmente integrabili: di fatto la maggior parte dei
          file nel repository è in formato testo suddiviso in linee (come il
          codice sorgente dei programmi). Ma per i file con formato binario,
          come immagini o suoni, è spesso impossibile fondere modifiche
          conflittuali. In queste situazioni, è realmente necessario per
          l'utente prendere turni rigorosi nella modifica del file. Senza un
          accesso serializzato, qualcuno potrebbe perdere tempo ad effettuare
          modifiche che potrebbero andare scartate.</para>

        <para lang="en">While CVS and Subversion are still primarily
          copy-modify-merge systems, they both recognize the need to
          lock an occasional file and provide mechanisms for this.
          See <xref linkend="svn.advanced.locking"/>.</para>

        <para>Mentre CVS e Subversion sono comunque principalmente sistemi
          copia-modifica-fondi, entrambi riconoscono la necessità occasionale di
          bloccare un file e forniscono un meccanismo per questo.
          Si veda <xref linkend="svn.advanced.locking"/>.</para>

      </sidebar>

    </sect2>

  </sect1>

  <!-- How svn implements the philosophy -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.in-action">
    <!-- <title>Subversion in Action</title> -->
    <title>Subversion in Azione</title>

    <para lang="en">It's time to move from the abstract to the concrete.  In
      this section, we'll show real examples of Subversion being
      used.</para>

    <para>È il momento di passare dall'astratto al concreto. In questa sezione,
      saranno mostrati esempi di uso reale di Subversion.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.wc">
      <!-- <title>Working Copies</title> -->
      <title>Copie di lavoro</title>

      <para lang="en">You've already read about working copies; now we'll
        demonstrate how the Subversion client creates and uses
        them.</para>

      <para>Si è già letto a proposito delle copie di lavoro; adesso verrà
        mostrato come queste vengano create ed utilizzate dal client
        Subversion.</para>

      <para lang="en">A Subversion working copy is an ordinary directory tree on
        your local system, containing a collection of files. You can
        edit these files however you wish, and if they're source code
        files, you can compile your program from them in the usual
        way. Your working copy is your own private work area:
        Subversion will never incorporate other people's changes, nor
        make your own changes available to others, until you
        explicitly tell it to do so.  You can even have multiple
        working copies of the same project.</para>

      <para>Una copia di lavoro di Subversion è un normale albero di directory
        sul proprio sistema locale, contenente un certo insieme di file. È
        possibile modificare questi file come si preferisce, e, se si tratta di
        file di codice sorgente, si può compilare il proprio programma
        esattamente nella maniera usuale. La copia di lavoro è la propria area
        personale di lavoro: Subversion non incorporerà mai le modifiche
        introdotte da altri, né renderà le proprie modifiche disponibili ad
        altri, fino a quando non verrà esplicitamente chiesto di farlo. È
        possibile perfino avere più di una copia di lavoro dello stesso
        progetto.</para>

      <para lang="en">After you've made some changes to the files in your
        working copy and verified that they work properly, Subversion
        provides you with commands to <quote>publish</quote> your
        changes to the other people working with you on your project
        (by writing to the repository).  If other people publish their
        own changes, Subversion provides you with commands to merge
        those changes into your working directory (by reading from the
        repository).</para>

      <para>Dopo aver apportato le modifiche desiderate ai file nella propria
        copia di lavoro ed aver verificato che funzionino correttamente,
        Subversion mette a disposizione dei comandi per <quote>pubblicare</quote>
        le proprie modifiche verso le altre persone che lavorano sullo stesso
        progetto (scrivendo nel repository). Quando altre persone pubblicano le
        loro modifiche, Subversion permette di importarle nella propria
        directory di lavoro (leggendole dal repository).</para>

      <para lang="en">A working copy also contains some extra files, created and
        maintained by Subversion, to help it carry out these commands.
        In particular, each directory in your working copy contains a
        subdirectory named <filename>.svn</filename>, also known as
        the working copy <firstterm>administrative
        directory</firstterm>. The files in each administrative
        directory help Subversion recognize which files contain
        unpublished changes, and which files are out-of-date with
        respect to others' work.</para>

      <para>Una copia di lavoro contiene anche dei file aggiuntivi, creati ed
        aggiornati da Subversion, come supporto all'esecuzione dei comandi
        di cui sopra. In particolare, ogni directory nella propria copia di
        lavoro contiene una sottodirectory chiamata <filename>.svn</filename>,
        altrimenti nota come <firstterm>directory amministrativa</firstterm>
        della copia di lavoro. I file presenti in ciascuna delle directory
        amministrative aiutano Subversion a tenere traccia di quali file
        contengono modifiche non pubblicate e quali file non sono aggiornati
        rispetto al lavoro svolto da altri.</para>

      <para lang="en">A typical Subversion repository often holds the files (or
        source code) for several projects; usually, each project is a
        subdirectory in the repository's filesystem tree.  In this
        arrangement, a user's working copy will usually correspond to
        a particular subtree of the repository.</para>

      <para>Un tipico repository di Subversion spesso contiene i file (o codice
        sorgente) di diversi progetti; di solito, ogni progetto è contenuto in
        una sottodirectory nell'albero del filesystem del repository. Seguendo
        questa disposizione, la copia di lavoro di un utente corrisponderà ad
        uno specifico sottoalbero del repository.</para>

      <para lang="en">For example, suppose you have a repository that contains
        two software projects, <literal>paint</literal> and
        <literal>calc</literal>.  Each project lives in its own
        top-level subdirectory, as shown in <xref
        linkend="svn.basic.in-action.wc.dia-1"/>.</para>

      <para>Ad esempio, supponiamo di avere un repository che contenga due
        progetti software, <literal>paint</literal> e <literal>calc</literal>.
        Ciascun progetto vive nella sua personale sottodirectory al livello
        più alto dell'albero del filesystem, come mostrato in <xref
        linkend="svn.basic.in-action.wc.dia-1"/>.</para>

      <figure id="svn.basic.in-action.wc.dia-1">
        <!-- <title>The repository's filesystem</title> -->
        <title>Il filesystem del repository</title>
        <graphic fileref="images/ch02dia6.png"/>
      </figure>

      <para lang="en">To get a working copy, you must <firstterm>check
        out</firstterm> some subtree of the repository.  (The term
        <quote>check out</quote> may sound like it has something to do
        with locking or reserving resources, but it doesn't; it simply
        creates a private copy of the project for you.) For example,
        if you check out <filename>/calc</filename>, you will get a
        working copy like this:</para>

      <para>Per ottenere una copia di lavoro, si deve anzitutto eseguire il
        <firstterm>check out</firstterm> di un qualche sottoalbero del
        repository. (Il termine <quote>check out</quote> potrebbe erroneamente
        far pensare ad una azione di blocco o riserva delle risorse ma, in
        realtà, crea semplicemente all'utente una copia di lavoro del progetto.)
        Per esempio, se si effettua il check out di <filename>/calc</filename>,
        si otterrà una copia di lavoro con questa struttura:</para>

      <screen>
$ svn checkout http://svn.example.com/repos/calc
A    calc/Makefile
A    calc/integer.c
A    calc/button.c
Checked out revision 56.

$ ls -A calc
Makefile  integer.c  button.c  .svn/
</screen>

      <para lang="en">The list of letter A's indicates that Subversion is adding
        a number of items to your working copy.  You now have a
        personal copy of the repository's <filename>/calc</filename>
        directory, with one additional
        entry&mdash;<filename>.svn</filename>&mdash;which holds the
        extra information needed by Subversion, as mentioned
        earlier.</para>

      <para>La lista di A indica che Subversion stia aggiungendo un certo
        numero di elementi alla propria copia locale. Adesso quindi si ha una
        copia personale della directory<filename>/calc</filename> del
        repository, con un elemento aggiuntivo
        &mdash;<filename>.svn</filename>&mdash;che contiene tutte quelle
        extra informazioni menzionate in precedenza.</para>

      <sidebar id="svn.basic.in-action.wc.sb-1">
        <!-- <title>Repository URLs</title> -->
        <title>URL del repository</title>

        <para lang="en">Subversion repositories can be accessed through many
          different methods&mdash;on local disk, or through various
          network protocols.  A repository location, however, is
          always a URL.  <xref linkend="svn.basic.in-action.wc.tbl-1"/> describes how
          different URL schemas map to the available access methods.</para>

        <para>I repository di Subversion possono essere accessi con diversi
          metodi: nel disco locale o attraverso vari protocolli di rete.
          La localizzazione di un repository ad ogni modo avviene sempre
          attraverso una URL. <xref linkend="svn.basic.in-action.wc.tbl-1"/>
          descrive come differenti schemi di URL corrispondano ai metodi di
          accesso disponibili.</para>

        <table id="svn.basic.in-action.wc.tbl-1">
          <!-- <title>Repository Access URLs</title> -->
          <title>URL di accesso al repository</title>
          <!-- <tgroup cols="2">
            <thead>
              <row>
                <entry>Schema</entry>
                <entry>Access Method</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><literal>file:///</literal></entry>
                <entry>direct repository access (on local disk)</entry>
              </row>
              <row>
                <entry><literal>http://</literal></entry>
                <entry>access via WebDAV protocol to Subversion-aware
                  Apache server</entry>
              </row>
              <row>
                <entry><literal>https://</literal></entry>
                <entry>same as <literal>http://</literal>, but with
                  SSL encryption.</entry>
              </row>
              <row>
                <entry><literal>svn://</literal></entry>
                <entry>access via custom protocol to an
                  <literal>svnserve</literal> server</entry>
              </row>
              <row>
                <entry><literal>svn+ssh://</literal></entry>
                <entry>same as <literal>svn://</literal>, but through
                  an SSH tunnel.</entry>
              </row>
            </tbody>
          </tgroup> -->
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Schema</entry>
                <entry>Metodo di accesso</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><literal>file:///</literal></entry>
                <entry>accesso diretto al repository (nel disco locale)</entry>
              </row>
              <row>
                <entry><literal>http://</literal></entry>
                <entry>accesso tramite il protocollo WebDAV ad un server Apache
                con supporto Subversion</entry>
              </row>
              <row>
                <entry><literal>https://</literal></entry>
                <entry>come <literal>http://</literal>, ma con crittografia
                  SSL.</entry>
              </row>
              <row>
                <entry><literal>svn://</literal></entry>
                <entry>accesso tramite un protocollo specifico ad un server
                  <literal>svnserve</literal></entry>
              </row>
              <row>
                <entry><literal>svn+ssh://</literal></entry>
                <entry>come <literal>svn://</literal>, ma attraverso un tunnel
                  SSH.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para lang="en">For more information on how Subversion parses URLs, see
          <xref linkend="svn.advanced.reposurls"/>.</para>

        <para>Per avere informazioni più dettagliate su come Subversion effettui
          il parsing delle URL, si veda
          <xref linkend="svn.advanced.reposurls"/>.</para>

      </sidebar>

      <para lang="en">Suppose you make changes to <filename>button.c</filename>.
        Since the <filename>.svn</filename> directory remembers the
        file's modification date and original contents, Subversion can
        tell that you've changed the file.  However, Subversion does
        not make your changes public until you explicitly tell it to.
        The act of publishing your changes is more commonly known as
        <firstterm>committing</firstterm> (or <firstterm>checking
        in</firstterm>) changes to the repository.</para>

      <para>Supponiamo di aver apportato modiche a <filename>button.c</filename>.
        Dato che la directory <filename>.svn</filename> ricorda le date delle
        modifiche ai file ed i contenuti originali, Subversion può notificare
        che i file siano stati cambiati. Ad ogni modo, Subversion non rende
        pubblici i propri cambiamenti fino a quando non verrà esplicitamente
        richiesto. L'atto di pubblicazione dei propri cambiamenti è comunemente
        conosciuta come<firstterm>commit</firstterm> (o <firstterm>check
        in</firstterm>) delle modifiche al repository.</para>

      <para lang="en">To publish your changes to others, you can use
        Subversion's <command>commit</command> command:</para>

      <para>Per pubblicare le proprie modifiche agli altri è possibile usare il
        comando di Subversion <command>commit</command>:</para>

      <screen>
$ svn commit button.c
Sending        button.c
Transmitting file data .
Committed revision 57.
</screen>

      <para lang="en">Now your changes to <filename>button.c</filename> have
        been committed to the repository; if another user checks out a
        working copy of <filename>/calc</filename>, they will see
        your changes in the latest version of the file.</para>

      <para>Adesso le modifiche a <filename>button.c</filename> sono state
        sottomesse al repository; se un altro utente effettua il check out di
        una copia di lavoro di <filename>/calc</filename>, vedrà i propri
        cambiamenti nell'ultima versione del file.</para>

      <para lang="en">Suppose you have a collaborator, Sally, who checked out a
        working copy of <filename>/calc</filename> at the same time
        you did.  When you commit your change to
        <filename>button.c</filename>, Sally's working copy is left
        unchanged; Subversion only modifies working copies at the
        user's request.</para>

      <para>Supponiamo di avere un altro collaboratore, Sally, che ha effettuato
        il check out della copia di lavoro di <filename>/calc</filename> nello
        stesso momento in cui è stata effettuata la nostra. Quando verranno
        sottomesse le modifiche al file<filename>button.c</filename>, la copia
        di lavoro di Sally rimarrà inalterata; Subversion infatti modifica le
        copie solamente alla richiesta dell'utente.</para>

      <para lang="en">To bring her project up to date, Sally can ask
        Subversion to <firstterm>update</firstterm> her working copy,
        by using the Subversion <command>update</command> command.
        This will incorporate your changes into her working copy, as
        well as any others that have been committed since she checked
        it out.</para>

      <para>Per attualizzare il proprio progetto, Sally può chiedere a
        Subversion di <firstterm>aggiornare</firstterm> la sua copia di lavoro,
        usando il comando di Subversion <command>update</command>. Questo
        incorporerà le nostre modifiche nella sua copia di lavoro, così come
        ogni altro cambiamento che è stato sottomesso da quando lei ha
        effettuato il check out.</para>

      <screen>
$ pwd
/home/sally/calc

$ ls -A
.svn/ Makefile integer.c button.c

$ svn update
U    button.c
Updated to revision 57.
</screen>

      <para lang="en">The output from the <command>svn update</command> command
        indicates that Subversion updated the contents of
        <filename>button.c</filename>.  Note that Sally didn't need to
        specify which files to update; Subversion uses the information
        in the <filename>.svn</filename> directory, and further
        information in the repository, to decide which files need to
        be brought up to date.</para>

      <para>I risultati del comando <command>svn update</command> indicano che
        Subversion ha aggiornato i contenuti di <filename>button.c</filename>.
        Si noti che Sally non ha dovuto specificare quali file aggiornare;
        Subversion usa le informazioni nella directory <filename>.svn</filename>,
        ed informazioni aggiuntive nel repository, per decidere quali file hanno
        bisogno di essere attualizzati.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.revs">
      <!--  <title>Revisions</title>  -->
      <title>Revisioni</title>

      <para lang="en">An <command>svn commit</command> operation can publish
        changes to any number of files and directories as a single
        atomic transaction.  In your working copy, you can change
        files' contents, create, delete, rename and copy files and
        directories, and then commit the complete set of changes as a
        unit.</para>

      <para>Un comando <command>svn commit</command> può pubblicare i
        cambiamenti.</para>

      <para lang="en">In the repository, each commit is treated as an atomic
        transaction: either all the commit's changes take place, or
        none of them take place.  Subversion tries to retain this
        atomicity in the face of program crashes, system crashes,
        network problems, and other users' actions.</para>

      <para>Nel repository, ogni commit viene trattata come una transazione
        atomica: vengono effettuate o tutte o nessuna delle modifiche.
        Subversion cerca di mantenere questa atomicità come precauzione verso
        i crash dei programmi, i crash dei sistemi, i problemi di rete ed altre
        azioni dell'utente.</para>

      <para lang="en">Each time the repository accepts a commit, this creates a
        new state of the filesystem tree, called a
        <firstterm>revision</firstterm>.  Each revision is assigned a
        unique natural number, one greater than the number of the
        previous revision.  The initial revision of a freshly created
        repository is numbered zero, and consists of nothing but an
        empty root directory.</para>

      <para>Ogni volta che il repository accetta una commit, questo crea un
        nuovo stato nell'albero del filesystem, che viene chiamato
        <firstterm>revisione</firstterm>. Ogni revisione è assegnata ad un unico
        numero naturale, di una unità maggiore rispetto alla revisione
        precedente. La revisione iniziale di un repository appena creato è
        numerata come zero, e consiste in nient'altro che una directory radice
        vuota.</para>

      <para lang="en"><xref linkend="svn.basic.in-action.revs.dia-1"/> illustrates a nice way to
        visualize the repository.  Imagine an array of revision
        numbers, starting at 0, stretching from left to right.  Each
        revision number has a filesystem tree hanging below it, and
        each tree is a <quote>snapshot</quote> of the way the
        repository looked after a commit.</para>

      <para><xref linkend="svn.basic.in-action.revs.dia-1"/> illustra una
        tipo intuitivo di visualizzazione del repository. Si immagini un array
        di numeri di revisioni, che inizia da 0 ed incrementa da destra a
        sinistra. Ogni numero di revisione ha un albero di filesystem appeso al
        di sotto, e ogni albero è una <quote>istantanea</quote> di come appariva
        il repository dopo la commit.</para>

      <figure id="svn.basic.in-action.revs.dia-1">
        <!-- <title>The repository</title> -->
        <title>Il repository</title>
        <graphic fileref="images/ch02dia7.png"/>
      </figure>

      <sidebar>
        <!-- <title>Global Revision Numbers</title> -->
        <title>Numeri di revisione globali</title>

        <para lang="en">Unlike those of many other version control systems,
          Subversion's revision numbers apply to <emphasis>entire
          trees</emphasis>, not individual files.  Each revision
          number selects an entire tree, a particular state of the
          repository after some committed change.  Another way to
          think about it is that revision N represents the state of
          the repository filesystem after the Nth commit.  When
          Subversion users talk about <quote>revision 5 of
          <filename>foo.c</filename></quote>, they really mean
          <quote><filename>foo.c</filename> as it appears in revision
          5.</quote> Notice that in general, revisions N and M of a
          file do <emphasis>not</emphasis> necessarily differ!  Because
          CVS uses per-file revision numbers, CVS users might want to
          see <xref linkend="svn.forcvs"/> for more details.</para>

        <para>Al contrario di quelli di molti altri sistemi per il controllo di
          versione, i numeri di revisione di Subversion si applicano
          all'<emphasis>intero albero</emphasis>, non a file individuali.
          Ogni numero di revisione seleziona un intero albero, un particolare
          stato del repository seguente qualche sottomissione di modifiche.
          Un'altra maniera per comprenderlo è che la revisione N rappresenti lo
          stato del filesystem del repository seguente l'N-esima commit. Quando
          gli utenti parlano di
          <quote>revisione 5 di <filename>foo.c</filename></quote>, intendono
          in verità <quote><filename>foo.c</filename> come appare nella
          revisione 5.</quote> Si noti che in generale, le revisioni N ed M di
          un file <emphasis>non</emphasis> siano necessariamente differenti!
          Poiché CVS usa un numero di revisione per file, gli utenti CVS
          potrebbero essere interessati a leggere <xref linkend="svn.forcvs"/>
          per maggiori dettagli.</para>
      </sidebar>

      <para lang="en">It's important to note that working copies do not always
        correspond to any single revision in the repository; they may
        contain files from several different revisions.  For example,
        suppose you check out a working copy from a repository whose
        most recent revision is 4:</para>

      <para>È importante notare che le copie di lavoro non sempre corrispondano
        ad una singola revisione del repository; potrebbero contenere file di
        varie revisioni differenti. Ad esempio, supponiamo di effettuare
        check out di una copia di lavoro da un repository la cui revisione più
        recente è 4:</para>

      <screen>
calc/Makefile:4
     integer.c:4
     button.c:4
</screen>

      <para lang="en">At the moment, this working directory corresponds exactly
        to revision 4 in the repository.  However, suppose you make a
        change to <filename>button.c</filename>, and commit that
        change.  Assuming no other commits have taken place, your
        commit will create revision 5 of the repository, and your
        working copy will now look like this:</para>

      <para>Al momento, questa directory di lavoro corrisponde esattamente alla
        revisione 4 del repository. Tuttavia, supponiamo di aver modificato
        <filename>button.c</filename>, ed aver sottomesso questo cambiamento.
        Assumendo che nessun'altra commit abbia avuto luogo, la propria commit
        creerà la revisione 5 del repository, e la propria copia di lavoro
        apparirà come segue:</para>

      <screen>
calc/Makefile:4
     integer.c:4
     button.c:5
</screen>

      <para lang="en">Suppose that, at this point, Sally commits a change to
        <filename>integer.c</filename>, creating revision 6.  If you
        use <command>svn update</command> to bring your working copy
        up to date, then it will look like this:</para>

      <para>Supponiamo che, a questo punto, Sally effettui la commit di una
        modifica a <filename>integer.c</filename>, creando la revisione 6. Se si
        usa <command>svn update</command> per attualizzare la propria copia
        di lavoro, questa apparirà come segue:</para>

      <screen>
calc/Makefile:6
     integer.c:6
     button.c:6
</screen>

      <para lang="en">Sally's change to <filename>integer.c</filename> will
        appear in your working copy, and your change will still be
        present in <filename>button.c</filename>.  In this example,
        the text of <filename>Makefile</filename> is identical in
        revisions 4, 5, and 6, but Subversion will mark your working
        copy of <filename>Makefile</filename> with revision 6 to
        indicate that it is still current.  So, after you do a clean
        update at the top of your working copy, it will generally
        correspond to exactly one revision in the repository.</para>

      <para>La modifica di Sally a <filename>integer.c</filename> apparirà
        nella propria copia di lavoro, ed i propri cambiamenti saranno ancora
        presenti in <filename>button.c</filename>. In questo esempio il testo di
        <filename>Makefile</filename> è identico nelle revisioni 4, 5 e 6, ma
        Subversion marcherà la propria copia di lavoro di
        <filename>Makefile</filename> con la revisione 6 per indicare che è la
        corrente. Quindi, dopo aver fatto un aggiornamento al livello più
        alto della propria copia di lavoro, questa corrisponderà esattamente ad
        una revisione del repository.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.track-repos">
      <title>Come le copie di lavoro sono in relazione con il repository</title>

      <para lang="en">For each file in a working directory, Subversion records
        two essential pieces of information in the
        <filename>.svn/</filename> administrative area:</para>

      <para>Per ogni file nella directory di lavoro, Subversion registra due
        porzioni di informazione essenziali nell'area di amministrazione
        <filename>.svn/</filename>:</para>

      <itemizedlist>
        <listitem>
          <para lang="en">what revision your working file is based on (this is
            called the file's <firstterm>working revision</firstterm>),
            and</para>

          <para>il numero di revisione su cui è basata la copia di lavoro
            (detta <firstterm>revisione di lavoro</firstterm> del file), e</para>
        </listitem>

        <listitem>
          <para lang="en">a timestamp recording when the local copy was last
            updated by the repository.</para>

          <para>una marca temporale relativa a quando la copia locale è stata
            aggiornata con il repository</para>
        </listitem>
      </itemizedlist>

      <para lang="en">Given this information, by talking to the repository,
        Subversion can tell which of the following four states a
        working file is in:</para>

      <para>Date queste informazioni, comunicando con il repository, Subversion
        può decidere in quale dei seguenti quattro stati si trovi un file nella
        copia di lavoro:</para>

      <variablelist>
        <varlistentry>
          <term lang="en">Unchanged, and current</term> 
          <term>Non modificato ed aggiornato</term>

          <listitem>
            <para lang="en">The file is unchanged in the working directory, and
              no changes to that file have been committed to the
              repository since its working revision.  An <command>svn
              commit</command> of the file will do nothing, and an
              <command>svn update</command> of the file will do
              nothing.</para>

            <para>Il file non è stato modificato nella directory di lavoro e
              nessuna modifica alla sua revisione di lavoro è stata sottomessa
              al repository. Un comando <command>svn commit</command> del file
              non farà nulla, e un comando <command>svn update</command> del
              file non farà nulla.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term lang="en">Locally changed, and current</term>
          <term>Localmente modificato ed aggiornato</term>

          <listitem>
            <para lang="en">The file has been changed in the working directory,
              and no changes to that file have been committed to the
              repository since its base revision.  There are local
              changes that have not been committed to the repository,
              thus an <command>svn commit</command> of the file will
              succeed in publishing your changes, and an <command>svn
              update</command> of the file will do nothing.</para>

            <para>Il file è stato modificato nella directory di lavoro e nessuna
              modifica alla sua revisione di lavoro è stata sottomessa al
              repository. Ci sono delle modifiche locali che devono essere
              salvate sul repository, quindi un <command>svn commit</command>
              del file pubblicherà con successo le modifiche, ed un <command>svn
              update</command> del file non farà nulla.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term lang="en">Unchanged, and out-of-date</term> 
          <term>Non modificato e scaduto</term>

          <listitem>
            <para lang="en">The file has not been changed in the working
              directory, but it has been changed in the repository.
              The file should eventually be updated, to make it
              current with the public revision.  An <command>svn
              commit</command> of the file will do nothing, and an
              <command>svn update</command> of the file will fold the
              latest changes into your working copy.</para>

            <para>Il file non è stato modificato nella directory di lavoro, ma
              ha subito dei cambiamenti nel repository. Il file dovrebbe essere
              aggiornato per renderlo sincronizzato con l'attuale revisione
              pubblica. Un <command>svn commit</command> del file non farà
              nulla, ed un <command>svn update</command> del file caricherà gli
              ultimi cambiamenti nella copia di lavoro.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term lang="en">Locally changed, and out-of-date</term>
          <term>Localmente modificato e scaduto</term>
          <listitem>
            <para lang="en">The file has been changed both in the working
              directory, and in the repository.  An <command>svn
              commit</command> of the file will fail with an
              <quote>out-of-date</quote> error.  The file should be
              updated first; an <command>svn update</command> command
              will attempt to merge the public changes with the local
              changes.  If Subversion can't complete the merge in a
              plausible way automatically, it leaves it to the user to
              resolve the conflict.</para>

            <para>Il file è stato cambiato sia nella directory di lavoro, sia
              nel repository. Un comando <command>svn commit</command> del file
              fallirà con un errore di <quote>out-of-date</quote>. Il file
              dovrebbe prima essere aggiornato; un comando
              <command>svn update</command> tenterà di incorporare le modifiche
              pubbliche con le modifiche locali. Se Subversion non può
              completare la fusione automatica in un modo coerente, lascerà
              all'utente il compito di risolvere il conflitto.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para lang="en">This may sound like a lot to keep track of, but the
        <command>svn status</command> command will show you the state
        of any item in your working copy.  For more information on
        that command, see <xref linkend="svn.tour.cycle.examine.status" />.</para>

      <para>Potrebbe sembrare eccessivo tener traccia di tutto questo, ma il
        comando <command>svn status</command> mostrerà la stato di ogni elemento
        nella copia di lavoro. Per altre informazioni su questo comando, si veda
        <xref linkend="svn.tour.cycle.examine.status" />.
      </para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.mixedrevs">
      <!-- <title>Mixed Revision Working Copies</title> -->
      <title>Copie di lavoro con revisioni miste</title>

      <para lang="en">As a general principle, Subversion tries to be as flexible
        as possible.  One special kind of flexibility is the ability
        to have a working copy containing files and directories with a
        mix of different working revision numbers.  Unfortunately,
        this flexibility tends to confuse a number of new users.  If
        the earlier example showing mixed revisions perplexed you,
        here's a primer on both why the feature exists and how to make
        use of it.</para>

      <para>Come principio generale, Subversion vuole essere il più flessibile
        possibile. Una particolare flessibilità deriva dalla possibilità di
        avere una copia di lavoro contenente file e directory con un insieme di
        differenti numeri di revisione. Sfortunatamente questa flessibilità
        tende a confondere alcuni utenti. Segue quindi un'introduzione sul
        perché esiste questa caratteristica e su come utilizzarla.</para>

      <sect3 id="svn.basic.in-action.mixedrevs.update-commit">
        <!-- <title>Updates and Commits are Separate</title> -->
        <title>Update e commit sono azioni separate</title>

        <para lang="en">One of the fundamental rules of Subversion is that
          a <quote>push</quote> action does not cause
          a <quote>pull</quote>, nor the other way around.  Just
          because you're ready to submit new changes to the repository
          doesn't mean you're ready to receive changes from other
          people.  And if you have new changes still in progress,
          then <command>svn update</command> should gracefully merge
          repository changes into your own, rather than forcing you to
          publish them.</para>

        <para>Una delle regole fondamentali di Subversion è che un'azione di
          <quote>invio</quote> non causa una <quote>ricezione</quote>, né
          viceversa. Il fatto che ci siano le condizioni per inviare nuove
          modifiche al repository non significa che si sia pronti per ricevere
          quelle apportate dagli altri utenti. Se si sta lavorando a delle
          modifiche, il comando <command>svn update</command> deve integrare gli
          eventuali cambiamenti avvenuti sul repository in quelle su cui si sta
          lavorando, piuttosto che forzare la pubblicazione.</para>

        <para lang="en">The main side-effect of this rule is that it means a
          working copy has to do extra bookkeeping to track mixed
          revisions, and be tolerant of the mixture as well.  It's
          made more complicated by the fact that directories
          themselves are versioned.</para>

        <para>La conseguenza principale di questa regola è che implica che una
          copia di lavoro debba compiere attività supplementari per tener
          traccia delle diverse revisioni, oltre a tollerare le diversità
          stesse. Ciò inoltre è reso più complicato dal fatto che anche le
          directory stesse siano sotto controllo di versione.</para>

        <para lang="en">For example, suppose you have a working copy entirely at
          revision 10.  You edit the
          file <filename>foo.html</filename> and then perform
          an <command>svn commit</command>, which creates revision 15
          in the repository.  After the commit succeeds, many new
          users would expect the working copy to be entirely at
          revision 15, but that's not the case!  Any number of changes
          might have happened in the repository between revisions 10
          and 15.  The client knows nothing of those changes in the
          repository, since you haven't yet run <command>svn
          update</command>, and <command>svn commit</command> doesn't
          pull down new changes.  If, on the other hand,
          <command>svn commit</command> <emphasis>were</emphasis> to
          automatically download the newest changes, then it would be
          possible to set the entire working copy to revision
          15&mdash;but then we'd be breaking the fundamental rule
          of <quote>push</quote> and <quote>pull</quote> remaining
          separate actions.  Therefore the only safe thing the
          Subversion client can do is mark the one
          file&mdash;<filename>foo.html</filename>&mdash;as being at
          revision 15.  The rest of the working copy remains at
          revision 10.  Only by running <command>svn update</command>
          can the latest changes be downloaded, and the whole working
          copy be marked as revision 15.</para>

        <para>Ad esempio, si suppone di avere una copia di lavoro completamente
          allineata alla revisione 10. Il file <filename>foo.html</filename>
          viene modificato e successivamente viene eseguito un
          <command>svn commit</command> il quale crea la revisione numero 15 nel
          repository. Visto l'esito positivo del comando di commit, molti utenti
          potrebbero pensare che la copia di lavoro sia interamente allineata
          con la revisione 15, ma non è così! Molti cambiamenti potrebbero
          essersi verificati nel repository tra la revisione 10 e la 15. Il
          client non sa nulla di questi cambiamenti in quanto non si è ancora
          eseguito il comando <command>svn update</command>, ed il comando
          <command>svn commit</command> non riceve nessun cambiamento.
          D'altronde, se il comando <command>svn commit</command> scaricasse
          automaticamente le nuove modifiche dal repository, allora sarebbe
          possibile allineare tutta la copia di lavoro alla revisione 15 &mdash;
          ma si verrebbe così ad infrangere la regola fondamentale che impone a
          invio e ricezione di essere azioni separate. Quindi l'unica cosa
          sicura che il client di Subversion possa fare è ricordare che il file
          &mdash;<filename>foo.html</filename>&mdash; sia aggiornato alla
          revisione 15. Il resto della copia di lavoro rimane alla revisione 10.
          Solo eseguendo un <command>svn update</command> si possono scaricare
          gli ultimissimi cambiamenti, e tutta la copia di lavoro sarà
          contrassegnata alla revisione 15.</para>

        </sect3>

        <sect3 id="svn.basic.in-action.mixedrevs.normal">
          <!-- title>Mixed revisions are normal</title -->
          <title>È normale avere revisioni miste</title>

          <para lang="en">The fact is, <emphasis>every time</emphasis> you
            run <command>svn commit</command>, your working copy ends
            up with some mixture of revisions.  The things you just
            committed are marked as having larger working revisions
            than everything else.  After several commits (with no
            updates in-between) your working copy will contain a whole
            mixture of revisions.  Even if you're the only person
            using the repository, you will still see this phenomenon.
            To examine your mixture of working revisions, use
            the <command>svn status --verbose</command> command (see
            <xref linkend="svn.tour.cycle.examine.status"/> for more
            information.)</para>

          <para>Di fatto <emphasis>ogni volta</emphasis> che si esegue il
            comando <command>svn commit</command> la copia di lavoro si viene a
            trovare in un insieme misto di revisioni. Gli elementi che sono
            appena stati inviati al repository avranno la revisione di lavoro
            più alta di ogni altro. Dopo diversi commit (senza operazioni di
            aggiornamento intermedie) la copia di lavoro conterrà una vasta
            combinazione di revisioni. Anche se una sola persona stesse usando
            il repository, si continuerebbe a verificare questo fenomeno. Per
            esaminare la miscela delle revisioni di lavoro, si può usare il
            comando <command>svn status --verbose</command> (per maggiori
            informazioni vedere <xref
            linkend="svn.tour.cycle.examine.status"/>).</para>

          <para lang="en">Often, new users are completely unaware that their
            working copy contains mixed revisions.  This can be
            confusing, because many client commands are sensitive to
            the working revision of the item they're examining.  For
            example, the <command>svn log</command> command is used to
            display the history of changes to a file or directory (see
            <xref linkend="svn.tour.history.log"/>).  When the user
            invokes this command on a working copy object, they expect
            to see the entire history of the object.  But if the
            object's working revision is quite old (often
            because <command>svn update</command> hasn't been run in a
            long time), then the history of
            the <emphasis>older</emphasis> version of the object is
            shown.</para>

          <para>Spesso i nuovi utenti ignorano completamente che la loro copia di
            lavoro contenga diverse revisioni. Ciò può generare confusione,
            perché molti comandi sono sensibili alla revisione di lavoro degli
            oggetti che devono esaminare. Per esempio, il comando
            <command>svn log</command> viene utilizzato per mostrare la storia
            dei cambiamenti di un file o una directory (vedere
            <xref linkend="svn.tour.history.log"/>). Quando un utente invoca
            questo comando sulla copia di lavoro di un oggetto, si aspetta di
            vedere l'intera storia dell'oggetto stesso. In realtà se la
            revisione di lavoro è piuttosto vecchia (solitamente perché non si è
            usato il comando <command>svn update</command> da molto tempo),
            allora viene mostrata la storia della
            <emphasis>precedente</emphasis> versione dell'oggetto.</para>
        </sect3>

        <sect3 id="svn.basic.in-action.mixedrevs.useful">
          <!-- title>Mixed revisions are useful</title -->
          <title>Le revisioni miste sono utili</title>

          <para lang="en">If your project is sufficiently complex, you'll
            discover that it's sometimes nice to forcibly
            <quote>backdate</quote> portions of your working copy to
            an earlier revision; you'll learn how to do that in
            Chapter 3.  Perhaps you'd like to test an earlier version
            of a sub-module contained in a subdirectory, or perhaps
            you'd like to figure out when a bug first came into
            existence in a specific file.  This is the <quote>time
            machine</quote> aspect of a version control system &mdash;
            the feature which allows you to move any portion of your
            working copy forward and backward in history.</para>

          <para>Se il progetto è piuttosto complesso, a volte è meglio forzare
            alcune porzioni della copia di lavoro a <quote>retrocedere</quote> a
            versioni precedenti; nel Capitolo 3 si potrà vedere come fare. Si
            potrebbe voler testare una versione precedente di qualche componente
            contenuta in una sotto directory; oppure si vorrebbe capire quando
            un difetto è comparso per la prima volta in un certo file. Questo è
            l'aspetto di un sistema di controllo delle versioni che lo
            caratterizza come una <quote>macchina del tempo</quote> &mdash; la
            caratteristica che permette di muovere ogni porzione della copia di
            lavoro avanti e indietro nella storia.</para>

        </sect3>

        <sect3 id="svn.basic.in-action.mixedrevs.limits">
          <!-- <title>Mixed revisions have limitations</title> -->
          <title>Le revisioni miste hanno dei limiti</title>

          <para lang="en">However you make use of mixed revisions in your
            working copy, there are limitations to this
            flexibility.</para>

          <para>Qualunque uso si faccia delle revisioni miste nella copia di
            lavoro, ci sono sempre delle limitazioni a questa
            flessibilità.</para>

          <para lang="en">First, you cannot commit the deletion of a file or
            directory which isn't fully up-to-date.  If a newer
            version of the item exists in the repository, your attempt
            to delete will be rejected, to prevent you from
            accidentally destroying changes you've not yet
            seen.</para>

          <para>Primo, non si può effettuare la commit della cancellazione di un
            file o directory che non sia completamente aggiornato. Se nel
            repository esiste una versione più recente, il tentativo di
            eliminazione verrà rifiutato, per evitare la distruzione accidentale
            di modifiche che non si siano ancora viste.</para>

          <para lang="en">Second, you cannot commit a metadata change to a
            directory unless it's fully up-to-date.  You'll learn
            about attaching <quote>properties</quote> to items in Chapter 6.  A
            directory's working revision defines a specific set of
            entries and properties, and thus committing a property
            change to an out-of-date directory may destroy properties
            you've not yet seen.</para>

          <para>Secondo, non è possibile effettuare la commit della modifica di
            un metadato su una directory senza che questa sia completamente
            aggiornata. Nel capitolo 6 si imparerà ad assegnare
            <quote>proprietà</quote> agli oggetti. La revisione di lavoro di
            una directory definisce un insieme specifico di voci e proprietà,
            quindi effettuare la commit della modifica di una proprietà a una
            directory non aggiornata potrebbe distruggere qualche proprietà che
            non sia ancora stata esaminata.</para>

        </sect3>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.summary">
    <!-- <title>Summary</title> -->
    <title>Sommario</title>

    <para lang="en">We've covered a number of fundamental Subversion concepts in
      this chapter:</para>

    <para>In questo capitolo sono stati affrontati alcuni concetti fondamentali
      di Subversion:</para>

    <itemizedlist>
      <listitem>
        <para lang="en">We've introduced the notions of the central repository,
          the client working copy, and the array of repository
          revision trees.</para>

        <para>Sono state introdotte le nozioni di repository centrale, copia di
          lavoro e serie di alberi di revisione.</para>
      </listitem>

      <listitem>
        <para lang="en">We've seen some simple examples of how two collaborators
          can use Subversion to publish and receive changes from one
          another, using the <quote>copy-modify-merge</quote>
          model.</para>

        <para>Si è visto qualche semplice esempio di come due collaboratori
        possano usare Subversion per pubblicare e ricevere le modifiche l'uno
        dall'altro secono il modello <quote>copia-modifica-fondi</quote>.</para>
      </listitem>

      <listitem>
        <para lang="en">We've talked a bit about the way Subversion tracks and
          manages information in a working copy.</para>

        <para>Si è parlato di come Subversion traccia e gestisce le informazioni
          in una copia di lavoro</para>
      </listitem>

    </itemizedlist>

    <para lang="en">At this point, you should have a good idea of how Subversion
      works in the most general sense.  Armed with this knowledge, you
      should now be ready to jump into the next chapter, which is a
      detailed tour of Subversion's commands and features.</para>

    <para>A questo punto, si dovrebbe avere una buona idea di come lavora
      Subversion nel senso più generale. Armati di questa conoscenza si dovrebbe
      essere ora pronti a passare al prossimo capitolo, che rappresenta
      un'analisi dettagliata dei comandi e delle caratteristiche di Subversion.
    </para>

  </sect1>

</chapter>

<!--
local variables:
sgml-parent-document: ("book.xml" "chapter")
end:
-->
