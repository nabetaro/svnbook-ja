<chapter id="svn.branchmerge">
  <title>Ramificazioni e fusioni</title>

  <simplesect>

    <para lang="en">Branching, tagging, and merging are concepts common to
      almost all version control systems.  If you're not familiar with
      these ideas, we provide a good introduction in this chapter.  If
      you are familiar, then hopefully you'll find it interesting to
      see how Subversion implements these ideas.</para>

    <para>Ramificazioni, targhe(etichette) e fusioni sono concetti comuni a
      quasi tutti sistemi di controllo delle versioni.  Se non si conoscono
      abbastanza queste idee, forniamo noi la buona introduzione in
      questo capitolo. Se le conoscete già, si spera che troverete interesante
      di vedere come Subversion implementa queste idee.</para>

    <para lang="en">Branching is a fundamental part of version control.  If
      you're going to allow Subversion to manage your data, then this
      is a feature you'll eventually come to depend on.  This chapter
      assumes that you're already familiar with Subversion's basic
      concepts (<xref linkend="svn.basic"/>).</para>

    <para>Ramificazioni sono la parte fondamentale di controlo delle versioni.
      Se state per permettere a Subversion di maneggiare i vostri dati,
      dipenderete da questa caratteristica. In questo capitolo si assume
      che siete già al corrente di concetti base di Subversion
      (<xref linkend="svn.basic"/>).</para>

  </simplesect>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.whatis">
    <title>Che cos'è un ramo?</title>

    <para lang="en">Suppose it's your job to maintain a document for a division
      in your company, a handbook of some sort.  One day a different
      division asks you for the same handbook, but with a few parts
      <quote>tweaked</quote> for them, since they do things slightly
      differently.</para>

    <para>Supponiamo che vostro compito è mantenere un certo documento per
      un dipartimento della vostra società. Un giorno un altro dipartimento
      chiede lo stesso documento, ma con alcune parti
      <quote>modificate</quote> per loro, perché in quel dipartimento le
      cose fanno in modo legermente diverso.</para>

    <para lang="en">What do you do in this situation?  You do the obvious thing:
      you make a second copy of your document, and begin maintaining
      the two copies separately.  As each department asks you to make
      small changes, you incorporate them into one copy or the
      other.</para>

    <para>Che cosa fatte in questa situazione?  Una cosa ovvia:
      fatte la seconda copia del vostro documento e cominciate mantenere
      le due copie separatamente. Quando uno o altro dipartimento
      chede di fare modifiche, voi le fatte nell'una o l'altra copia.</para>

    <para lang="en">You often want to make the same change to both copies.  For
      example, if you discover a typo in the first copy, it's very
      likely that the same typo exists in the second copy.  The two
      documents are almost the same, after all; they only differ in
      small, specific ways.</para>

    <para>Spesso vi capita di dover fare lo stesso cambiamento in tutte e due
      copie. Per es. avete scoperto errore di battitura nella prima copia,
      molto probabilmente lo stesso errore è anche nell'altra. Dopo tutto,
      le due copie sono quasi identiche, differiscono solo nelle piccole,
      specifiche parti.</para>

    <para lang="en">This is the basic concept of a
      <firstterm>branch</firstterm>&mdash;namely, a line of
      development that exists independently of another line, yet still
      shares a common history if you look far enough back in time.  A
      branch always begins life as a copy of something, and moves on
      from there, generating its own history (see <xref
      linkend="svn.branchmerge.whatis.dia-1"/>).</para>

    <para>Questo è il concetto base di
      <firstterm>ramo</firstterm>&mdash;leteralmente una linea di
      sviluppo che esiste independemente dall'altra, anche se sempre
      condividono la storia comune se si guarda abbastanza indietro in tempo.
      Un ramo sempre comincia la sua vita come copia di qualcosa e
      prosegue da questo punto generando la sua propria storia
      (vedi <xref linkend="svn.branchmerge.whatis.dia-1"/>).</para>

      <figure id="svn.branchmerge.whatis.dia-1">
        <title>Rami di sviluppo</title>
        <graphic fileref="images/ch04dia1.png"/>
      </figure>

    <para lang="en">Subversion has commands to help you maintain parallel
      branches of your files and directories.  It allows you to create
      branches by copying your data, and remembers that the copies are
      related to one another.  It also helps you duplicate changes
      from one branch to another.  Finally, it can make portions of
      your working copy reflect different branches, so that you can
      <quote>mix and match</quote> different lines of development in
      your daily work.</para>

    <para>Subversion ha i comandi per aiutarvi mantenere rami paralleli
      di vostri file e cartelle. Vi permette di creare rami copiando i vostri dati
      e si ricorda che le copie sono in relazione con altre. Vi aiuta anche
      di dupplicare cambiamenti da un ramo ad altro. Infine, può
      creare parti della vostra copia di lavoro che riflettono rami
      diversi così che potete <quote>mescolare e abbinare</quote>
      le linee diverse dello sviluppo nel vostro lavoro giornaliero.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.using">
    <title>Usare i rami</title>

    <para lang="en">At this point, you should understand how each commit creates
      an entire new filesystem tree (called a <quote>revision</quote>)
      in the repository.  If not, go back and read about revisions in
      <xref linkend="svn.basic.in-action.revs"/>.</para>

    <para>A questo punto dovete già capire come ogni commit crea
      in deposito un albero di filesystem completamente nuovo (chiamato una
      <quote>revisione</quote>).  Se no, tornate a leggere riguardo le
      revisioni la <xref linkend="svn.basic.in-action.revs"/>.</para>

    <para lang="en">For this chapter, we'll go back to the same example from
      Chapter 2.  Remember that you and your collaborator, Sally, are
      sharing a repository that contains two projects,
      <filename>paint</filename> and <filename>calc</filename>.
      Notice that in <xref linkend="svn.branchmerge.using.dia-1"/>, however, each
      project directory now contains subdirectories named
      <filename>trunk</filename> and <filename>branches</filename>.
      The reason for this will soon become clear.</para>

    <para>Per questo capitolo torniamo allo stesso esempio del Capitolo 2.
      Ricordate che voi e vostra collaboratrice, Sally, state condividere
      un deposito che contiene due progetti,
      <filename>paint</filename> e <filename>calc</filename>.
      Da notare che nella <xref linkend="svn.branchmerge.using.dia-1"/>, comunque,
      ogni cartella di progetto adesso contiene sottocartelle denominate
      <filename>trunk</filename> e <filename>branches</filename>.
      La ragione di ciò diventa presto chiara.</para>

      <!-- <figure id="svn.branchmerge.using.dia-1">
        <title>Starting repository layout</title>
        <graphic fileref="images/ch04dia2.png"/>
      </figure> -->

      <figure id="svn.branchmerge.using.dia-1">
        <title>Forma iniziale del deposito</title>
        <graphic fileref="images/ch04dia2.png"/>
      </figure>

    <para lang="en">As before, assume that Sally and you both have working
      copies of the <quote>calc</quote> project.  Specifically, you
      each have a working copy of <filename>/calc/trunk</filename>.
      All the files for the project are in this subdirectory rather
      than in <filename>/calc</filename> itself, because your team has
      decided that <filename>/calc/trunk</filename> is where the
      <quote>main line</quote> of development is going to take
      place.</para>

    <para>Come prima, assumiamo che tutti e due, Sally e voi, avete
      copia di lavoro del progetto <quote>calc</quote>. Specificamente,
      entrambi avete una copia di lavoro di <filename>/calc/trunk</filename>.
      Tutti i file del progetto sono in questa sottocartella invece nella
      cartella <filename>/calc</filename> stessa, perché vostro gruppo ha deciso
      che <filename>/calc/trunk</filename> è il posto dove va posizionata la
      <quote>linea principale</quote> dello sviluppo.</para>

    <para lang="en">Let's say that you've been given the task of performing a
      radical reorganization of the project.  It will take a long time
      to write, and will affect all the files in the project.  The
      problem here is that you don't want to interfere with Sally, who
      is in the process of fixing small bugs here and there.  She's
      depending on the fact that the latest version of the project (in
      <filename>/calc/trunk</filename>) is always usable.  If you
      start committing your changes bit-by-bit, you'll surely break
      things for Sally.</para>

    <para>Diciamo che vi hanno dato lavoro di radicale riorganizazione del
      progetto. Questo prende lungo tempo per scriverlo e toccherà tutti i file
      nell progetto. Il problema è che voi non volete interferire con lavoro di
      Sally, che sta correggendo piccoli errori qua e là. Ella dipende dall fatto
      che l'ultima versione del progetto (in <filename>/calc/trunk</filename>)
      è sempre usabile. Se voi cominciate pubblicare i vostri cambiamenti
      pezzo per pezzo, sicuramente rompete le cose a Sally.</para>

    <para lang="en">One strategy is to crawl into a hole: you and Sally can stop
      sharing information for a week or two.  That is, start gutting
      and reorganizing all the files in your working copy, but don't
      commit or update until you're completely finished with the task.
      There are a number of problems with this, though.  First, it's
      not very safe.  Most people like to save their work to the
      repository frequently, should something bad accidentally happen
      to their working copy.  Second, it's not very flexible.  If you
      do your work on different computers (perhaps you have a working
      copy of <filename>/calc/trunk</filename> on two different
      machines), you'll need to manually copy your changes back and
      forth, or just do all the work on a single computer.  By that
      same token, it's difficult to share your changes-in-progress
      with anyone else.  A common software development <quote>best
      practice</quote> is to allow your peers to review your work as you
      go.  If nobody sees your intermediate commits, you lose
      potential feedback.  Finally, when you're finished with all your
      changes, you might find it very difficult to re-merge your final
      work with the rest of the company's main body of code.  Sally
      (or others) may have made many other changes in the repository
      that are difficult to incorporate into your working
      copy&mdash;especially if you run <command>svn update</command>
      after weeks of isolation.</para>

    <para>Una strategia è nascondersi in una buca: voi e Sally smettete
      di condividere le informazioni per una settimana o due.
      Proprio così, cominciate sventrare e riorganizzare tutti i file
      nella vostra copia di lavoro ma senza commit oppure update finché
      non avrete complettamente finito il vostro lavoro.
      C'è un numero di problemi con questo, comunque. Prima, non è
      molto sicuro. A molte persone piace conservare suo lavoro
      nel deposito frequentemente, nel caso che accidentalmente succede
      qualcosa brutto alla loro copia di lavoro. Seconda, non è molto
      flessibile. Se state svolgendo vostro lavoro su diversi computer
      (magari avete le copie di lavoro del <filename>/calc/trunk</filename>
      su due macchine diverse), avete bisogno di copiare manualmente
      i vostri cambiamenti avanti e dietro o fare il lavoro solo su un computer.
      E per la stessa ragione, è difficile condividere i vostri cambiamenti in corso
      con qualcun altro. <quote>La regola d'arte</quote> comune
      nel sviluppo del software è permettere ai vostri compagni di vedere
      il vostro lavoro man mano come procede. Se nessuno vede i vostri
      commit intermediari, avete perso le potenziali reazioni.
      Alla fine, quando avete finito con tutti i vostri cambiamenti,
      potete magari trovare molto difficile di ri-fondere vostro lavoro finale
      con il resto del corpo principale del codice della vostra società.
      Sally (o altri) poteva fare molti altri cambiamenti nel deposito
      che sono difficili da incorporare nella vostra copia di
      lavoro&mdash;specialmente se fatte <command>svn update</command>
      dopo settimane di isolamento.</para>

    <para lang="en">The better solution is to create your own branch, or line of
      development, in the repository.  This allows you to save your
      half-broken work frequently without interfering with others, yet
      you can still selectively share information with your
      collaborators.  You'll see exactly how this works later
      on.</para>

    <para>La soluzione migliore è creare vostro ramo, o linea di
      sviluppo, nel deposito.  Questo vi permette di salvare frequentemente
      vostro lavoro incompiuto senza interferire con altri,
      ma nello stesso tempo selettivamente condividere le informazioni
      con i vostri collaboratori. Vediamo in seguito esattamente come questo
      approcio funziona.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.using.create">
      <title>Creare un ramo</title>

      <para lang="en">Creating a branch is very simple&mdash;you make a copy of
        the project in the repository using the <command>svn
        copy</command> command.  Subversion is not only able to copy
        single files, but whole directories as well.  In this case,
        you want to make a copy of the
        <filename>/calc/trunk</filename> directory.  Where should the
        new copy live?  Wherever you wish&mdash;it's a matter of
        project policy.  Let's say that your team has a policy of
        creating branches in the <filename>/calc/branches</filename>
        area of the repository, and you want to name your branch
        <literal>my-calc-branch</literal>.  You'll want to create a
        new directory,
        <filename>/calc/branches/my-calc-branch</filename>, which
        begins its life as a copy of
        <filename>/calc/trunk</filename>.</para>

      <para>Creare un ramo è molto semplice&mdash;fatte una copia di progetto
        in deposito usando il comando <command>svn copy</command>.
        Subversion è capace non solo di copiare i singoli file,
        ma anche intere cartelle. Nel nostro caso, volete fare una copia
        della cartella <filename>/calc/trunk</filename>. Dove la mettiamo?
        Dovunque desideriate&mdash;è un aspetto di regole del progetto.
        Diciamo che il vostro gruppo ha stabilito la regola di creare rami
        nella area del deposito <filename>/calc/branches</filename>,
        e voi volete chiamare vostro ramo <literal>my-calc-branch</literal>.
        State per creare nuova cartella,
        <filename>/calc/branches/my-calc-branch</filename>, che nasce come
        copia di <filename>/calc/trunk</filename>.</para>

      <para lang="en">There are two different ways to make a copy.  We'll
        demonstrate the messy way first, just to make the concept
        clear.  To begin, check out a working copy of the project's
        root directory, <filename>/calc</filename>:</para>

      <para>Ci sono due modi diversi di fare una copia. Vi dimostriamo
        prima quello ingarbugliato, solo per fare chiaro il concetto.
        Per cominciare, tiriamo fuori una copia di lavoro della cartella
        principale del progetto, <filename>/calc</filename>:</para>

      <screen>
$ svn checkout http://svn.example.com/repos/calc bigwc
A  bigwc/trunk/
A  bigwc/trunk/Makefile
A  bigwc/trunk/integer.c
A  bigwc/trunk/button.c
A  bigwc/branches/
Checked out revision 340.
</screen>

      <para lang="en">Making a copy is now simply a matter of passing two
        working-copy paths to the <command>svn copy</command>
        command:</para>

      <para>Creare una copia è adesso semplice questione di passare due
        percorsi di copia di lavoro al comando <command>svn copy</command>:</para>

      <screen>
$ cd bigwc
$ svn copy trunk branches/my-calc-branch
$ svn status
A  +   branches/my-calc-branch
</screen>

      <para lang="en">In this case, the <command>svn copy</command> command
        recursively copies the <filename>trunk</filename> working
        directory to a new working directory,
        <filename>branches/my-calc-branch</filename>.  As you can see
        from the <command>svn status</command> command, the new
        directory is now scheduled for addition to the repository.
        But also notice the <quote>+</quote> sign next to the letter
        A.  This indicates that the scheduled addition is a
        <emphasis>copy</emphasis> of something, not something new.
        When you commit your changes, Subversion will create
        <filename>/calc/branches/my-calc-branch</filename> in the
        repository by copying <filename>/calc/trunk</filename>, rather
        than resending all of the working copy data over the
        network:</para>

      <para>In questo caso, il comando <command>svn copy</command>
        copia ricorsivamente cartella di lavoro <filename>trunk</filename>
        nella nuova cartella di lavoro, <filename>branches/my-calc-branch</filename>.
        Come si può vedere dal comando <command>svn status</command>,
        la nuova cartella è adesso pianificata per essere aggiunta
        al deposito. Notare anche il segno <quote>+</quote> vicino la lettera
        A.  Questo indica che la aggiunta pianificata è una <emphasis>copia</emphasis>
        di qualcosa, non qualcosa di nuovo. Quando pubblicate i vostri
        cambiamenti, Subversion creerà
        <filename>/calc/branches/my-calc-branch</filename> nel deposito
        copiando <filename>/calc/trunk</filename>, invece di re-inviare tramite
        la rete tutti i dati dalla cartella di lavoro:</para>

      <screen lang="en">
$ svn commit -m "Creating a private branch of /calc/trunk."
Adding         branches/my-calc-branch
Committed revision 341.
</screen>
<screen>
$ svn commit -m "Creato un ramo privato da /calc/trunk."
Adding         branches/my-calc-branch
Committed revision 341.
</screen>

      <para lang="en">And now the easier method of creating a branch, which we
        should have told you about in the first place: <command>svn
        copy</command> is able to operate directly on two URLs.</para>

      <para>E adesso il metodo più semplice di creare un ramo, di cui
        si doveva parlare per primo: <command>svn
        copy</command> può operare direttamente su due URL.</para>

      <screen lang="en">
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/branches/my-calc-branch \
      -m "Creating a private branch of /calc/trunk."

Committed revision 341.
</screen>
<screen>
  $ svn copy http://svn.example.com/repos/calc/trunk \
  http://svn.example.com/repos/calc/branches/my-calc-branch \
  -m "Creato un ramo privato da /calc/trunk."

  Committed revision 341.
</screen>

      <para lang="en">There's really no difference between these two methods.
        Both procedures create a new directory in revision 341, and
        the new directory is a copy of
        <filename>/calc/trunk</filename>.  This is shown in <xref
        linkend="svn.branchmerge.using.create.dia-1"/>.  Notice that the second method,
        however, performs an <emphasis>immediate</emphasis> commit.
        <footnote>
          <para>Subversion does not support
            cross-repository copying.  When using URLs with <command>svn
            copy</command> or <command>svn move</command>, you can only
            copy items within the same repository.</para>
        </footnote>
        It's an easier procedure, because it doesn't require you to
        check out a large mirror of the repository.  In fact, this
        technique doesn't even require you to have a working copy at
        all.</para>

      <para>Realmente non c'è differenza tra questi due metodi.
        Entrambe le procedure creano una nuova cartella nella revisione 341 e
        la nuova cartella è una copia di <filename>/calc/trunk</filename>.
        Come mostrato nella <xref
        linkend="svn.branchmerge.using.create.dia-1"/>.  Notare che il secondo
        metodo, tuttavia, fa anche commit <emphasis>immediato</emphasis>.
        <footnote>
          <para>Subversion non supporta la copia tra due depositi
            (cross-repository). Usando gli URL con <command>svn
            copy</command> o <command>svn move</command>, si possono
            copiare elementi solo dentro lo stesso deposito.</para>
        </footnote>
        Questa è una procedura più semplice, perché non richiede di fare
        checkout di grande parte del deposito.  Infatti, questa tecnica addirittura
        non richiede neanche di avere una copia di lavoro.</para>

      <figure id="svn.branchmerge.using.create.dia-1">
        <title>Deposito con la nuova copia</title>
        <graphic fileref="images/ch04dia3.png"/>
      </figure>

      <sidebar>
        <title>Le copie economiche</title>

        <para lang="en">Subversion's repository has a special design.  When you
          copy a directory, you don't need to worry about the
          repository growing huge&mdash;Subversion doesn't actually
          duplicate any data.  Instead, it creates a new directory
          entry that points to an <emphasis>existing</emphasis> tree.
          If you're a Unix user, this is the same concept as a
          hard-link.  From there, the copy is said to be
          <quote>lazy</quote>.  That is, if you commit a change to one
          file within the copied directory, then only that file
          changes&mdash;the rest of the files continue to exist as
          links to the original files in the original
          directory.</para>

        <para>Il deposito di Subversion ha un design speciale.
          Quando si fa la copia della cartella, non dovete preoccuparvi
          della massice crescita del deposito&mdash;Subversion in verità
          non dupplica nessun dato. Al posto di copia crea solo nuova voce
          nella cartella, che punta su albero <emphasis>esistente</emphasis>.
          Se siete utenti di Unix, questo è lo stesso concetto di
          hard-link. Da qui in poi, la copia è, diciamo, <quote>pigra</quote>.
          Proprio così, facendo commit di qualche cambiamento di un file
          della cartella copiata, solo quel file cambia&mdash;il resto
          dei file continua esistere come i link ai file originali nella
          cartella originale.</para>

        <para lang="en">This is why you'll often hear Subversion users talk
          about <quote>cheap copies</quote>.  It doesn't matter how
          large the directory is&mdash;it takes a very tiny, constant
          amount of time to make a copy of it.  In fact, this feature
          is the basis of how commits work in Subversion: each
          revision is a <quote>cheap copy</quote> of the previous
          revision, with a few items lazily changed within.  (To read
          more about this, visit Subversion's website and read about
          the <quote>bubble up</quote> method in Subversion's design
          documents.)</para>

        <para>E per questo spesso sentirette utenti di Subversion parlare
          delle <quote>copie a basso costo</quote>. Non importa quanto è
          grande la cartella&mdash;fare la sua copia prende sempre
          molto piccola, costante quantità di tempo. Infatti, questa
          caratteristica è la base del funzionamento di commit in Subversion:
          ogni revisione è <quote>copia economica</quote> della
          revisione precedente, con dentro poche voci pigramente cambiate.
          (Per leggere di più, visitate il sito web di Subversion e leggete
          di metodo <quote>bubble up</quote> negli documenti riguardo design
          di Subversion.)</para>

        <para lang="en">Of course, these internal mechanics of copying and
          sharing data are hidden from the user, who simply sees
          copies of trees.  The main point here is that copies are
          cheap, both in time and space.  Make branches as often as
          you want.</para>

        <para>Ovviamente, questo mecanismo interno di copiatura e
          condivisione dei dati è per utenti nascosto, loro semplicemente vedono
          le copie delle strutture. Qui il punto cardinale è che le copie
          sono economiche, parlando di tempo e spazio. Fatte i rami ogni volta
          che volete.</para>
      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.using.work">
      <title>Lavorare con il vostro ramo</title>

      <para lang="en">Now that you've created a branch of the project, you can
        check out a new working copy to start using it:</para>

      <para>Adesso che avete creato un ramo del progetto, potete tirare fuori
        (check out) una nuova copia di lavoro per cominciar ad usarla:</para>

      <screen>
$ svn checkout http://svn.example.com/repos/calc/branches/my-calc-branch
A  my-calc-branch/Makefile
A  my-calc-branch/integer.c
A  my-calc-branch/button.c
Checked out revision 341.
</screen>

      <para lang="en">There's nothing special about this working copy; it simply
        mirrors a different directory in the repository.  When you
        commit changes, however, Sally won't ever see them when she
        updates.  Her working copy is of
        <filename>/calc/trunk</filename>.  (Be sure to read <xref
        linkend="svn.branchmerge.switchwc"/> later in this chapter: the
        <command>svn switch</command> command is an alternate way of
        creating a working copy of a branch.)</para>

      <para>Non c'è niente speciale di questa copia di lavoro; semplicemente
        rispecchia una cartella diversa del deposito.
        Quando pubblicate le vostre modifiche (commit), tuttavia, Sally
        non può nenche vederle quando fa aggiornamento (update). La sua
        copia di lavoro è di <filename>/calc/trunk</filename>.
        (Assicuratevi di leggere la <xref
        linkend="svn.branchmerge.switchwc"/> più avanti in questo capitolo:
        il comando <command>svn switch</command> è un modo alternativo di creare
        copia di lavoro di un ramo.)</para>

      <para>Let's pretend that a week goes by, and the following
        commits happen:</para>

      <para>Facciamo finta che le settimane passano e succedono sequenti pubblicazioni
        (commit):</para>

      <itemizedlist lang="en">
        <listitem><para>
          You make a change to
          <filename>/calc/branches/my-calc-branch/button.c</filename>,
          which creates revision 342.</para>
        </listitem>

        <listitem><para>
          You make a change to
          <filename>/calc/branches/my-calc-branch/integer.c</filename>,
          which creates revision 343.</para>
        </listitem>

        <listitem><para>
          Sally makes a change to
          <filename>/calc/trunk/integer.c</filename>, which creates
          revision 344.</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem><para>
            Fatta la modifica di
            <filename>/calc/branches/my-calc-branch/button.c</filename>,
            che crea revisione 342.</para>
        </listitem>

        <listitem><para>
            Fatta la modifica di
            <filename>/calc/branches/my-calc-branch/integer.c</filename>,
            che crea revisione 343.</para>
        </listitem>

        <listitem><para>
            Sally modifica
            <filename>/calc/trunk/integer.c</filename>, che crea
            revisione 344.</para>
        </listitem>
      </itemizedlist>

      <para lang="en">There are now two independent lines of development, shown
        in <xref linkend="svn.branchmerge.using.work.dia-1"/>, happening on
        <filename>integer.c</filename>.</para>

      <para>Ci sono adesso due linee di sviluppo independenti, mostrate
        nella <xref linkend="svn.branchmerge.using.work.dia-1"/>, che toccano
        <filename>integer.c</filename>.</para>

      <!-- <figure id="svn.branchmerge.using.work.dia-1">
        <title>The branching of one file's history</title>
        <graphic fileref="images/ch04dia4.png"/>
      </figure> -->

      <figure id="svn.branchmerge.using.work.dia-1">
        <title>Ramificazione della storia d'un file</title>
        <graphic fileref="images/ch04dia4.png"/>
      </figure>

      <para lang="en">Things get interesting when you look at the history of
        changes made to your copy of
        <filename>integer.c</filename>:</para>

      <para>Le cose diventano interessanti quando guardate la storia delle
        modifiche della vostra copia di
        <filename>integer.c</filename>:</para>

      <screen lang="en">
$ pwd
/home/user/my-calc-branch

$ svn log --verbose integer.c
------------------------------------------------------------------------
r343 | user | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   M /calc/branches/my-calc-branch/integer.c

* integer.c:  frozzled the wazjub.

------------------------------------------------------------------------
r341 | user | 2002-11-03 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)

Creating a private branch of /calc/trunk.

------------------------------------------------------------------------
r303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  changed a docstring.

------------------------------------------------------------------------
r98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  adding this file to the project.

------------------------------------------------------------------------
</screen>
<screen>
  $ pwd
  /home/user/my-calc-branch

  $ svn log --verbose integer.c
  ------------------------------------------------------------------------
  r343 | user | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
  Changed paths:
  M /calc/branches/my-calc-branch/integer.c

  * integer.c:  frozzled the wazjub.

  ------------------------------------------------------------------------
  r341 | user | 2002-11-03 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
  Changed paths:
  A /calc/branches/my-calc-branch (from /calc/trunk:340)

  Creato un ramo privato da /calc/trunk

  ------------------------------------------------------------------------
  r303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines
  Changed paths:
  M /calc/trunk/integer.c

  * integer.c:  cambiato un docstring.

  ------------------------------------------------------------------------
  r98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines
  Changed paths:
  M /calc/trunk/integer.c

  * integer.c:  aggiunto questo file al progetto.

  ------------------------------------------------------------------------
</screen>

      <para lang="en">Notice that Subversion is tracing the history of your
        branch's <filename>integer.c</filename> all the way back
        through time, even traversing the point where it was copied.
        It shows the creation of the branch as an event in the
        history, because <filename>integer.c</filename> was implicitly
        copied when all of <filename>/calc/trunk/</filename> was
        copied.  Now look what happens when Sally runs the same
        command on her copy of the file:</para>

      <para>Notare che Subversion tiene traccia della storia di
        <filename>integer.c</filename> del vostro ramo dietro tutto il tempo,
        attraversando anche il punto dov'è stato copiato.
        Mostra la creazione del ramo come evento nella storia,
        perché <filename>integer.c</filename> era stato implicitamente copiato
        quando tutto il <filename>/calc/trunk/</filename> era stato copiato.
        Adesso guardate che sucede quando Sally avvia lo stesso comando
        sulla sua copia del file:</para>

<screen lang="en">
  $ pwd
  /home/sally/calc

  $ svn log --verbose integer.c
  ------------------------------------------------------------------------
  r344 | sally | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
  Changed paths:
  M /calc/trunk/integer.c

  * integer.c:  fix a bunch of spelling errors.

  ------------------------------------------------------------------------
  r303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines
  Changed paths:
  M /calc/trunk/integer.c

  * integer.c:  changed a docstring.

  ------------------------------------------------------------------------
  r98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines
  Changed paths:
  M /calc/trunk/integer.c

  * integer.c:  adding this file to the project.

  ------------------------------------------------------------------------
</screen>
<screen>
  $ pwd
  /home/sally/calc

  $ svn log --verbose integer.c
  ------------------------------------------------------------------------
  r344 | sally | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
  Changed paths:
  M /calc/trunk/integer.c

  * integer.c:  riparata una manciata di errori ortografici.

  ------------------------------------------------------------------------
  r303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines
  Changed paths:
  M /calc/trunk/integer.c

  * integer.c:  cambiato un docstring.

  ------------------------------------------------------------------------
  r98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines
  Changed paths:
  M /calc/trunk/integer.c

  * integer.c:  aggiunto questo file al progetto.

  ------------------------------------------------------------------------
</screen>

      <para lang="en">Sally sees her own revision 344 change, but not the change
        you made in revision 343.  As far as Subversion is concerned,
        these two commits affected different files in different
        repository locations.  However, Subversion
        <emphasis>does</emphasis> show that the two files share a
        common history.  Before the branch-copy was made in revision
        341, they used to be the same file.  That's why you and Sally
        both see the changes made in revisions 303 and 98.</para>

      <para>Sally vede la sua modifica nella versione 344, ma non la modifica
        che voi avete fatto nella versione 343. Per quel che riguarda Subversion,
        questi due commit riguardano i file diversi nelle diverse locazioni
        del deposito.  Tuttavia, Subversion <emphasis>mostra</emphasis> che questi
        due file condividono una storia comune. Prima che era fatta copia del ramo
        nella versione 341, essi erano l'unico file. E per questo entrambi, voi e Sally,
        vedete le modifiche fatte nelle versioni 303 e 98.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.using.concepts">
    <!-- <title>The Key Concepts Behind Branches</title> -->
      <title>Concetti chiave dietro i rami</title>

      <para lang="en">There are two important lessons that you should remember
        from this section.</para>

      <para>Ci sono due lezioni importanti che dovete ricordare
        da questa sezione.</para>

      <orderedlist>
        <listitem>
          <para lang="en">Unlike many other version control systems,
            Subversion's branches exist as <emphasis>normal filesystem
            directories</emphasis> in the repository, not in an extra
            dimension.  These directories just happen to carry some
            extra historical information.</para>
          <para>Diversamente da molti altri sistemi di controllo delle versioni,
            rami di Subversion esistono  come <emphasis>normali cartelle
            del filesystem</emphasis> in deposito, non in una dimensione extra.
            Succede solo che queste cartelle portano qualche
            storica informazione extra.</para>
        </listitem>
        <listitem>
          <para lang="en">Subversion has no internal concept of a
            branch&mdash;only copies.  When you copy a directory, the
            resulting directory is only a <quote>branch</quote>
            because <emphasis>you</emphasis> attach that meaning to
            it.  You may think of the directory differently, or treat
            it differently, but to Subversion it's just an ordinary
            directory that happens to have been created by
            copying.</para>
          <para>Subversion non ha un concetto interno dei rami&mdash;solo copie.
            Quando copiate una cartella, la cartella risultante
            è un <quote>ramo</quote> solo perché <emphasis>voi</emphasis> le date
            questo significato. Potete pensare alla cartella diversamente o
            trattarla diversamente, ma per Subversion essa è solo normale
            cartella, a quall'è successo di esser creata tramite copiatura.</para>
        </listitem>
      </orderedlist>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.copychanges">
    <!-- <title>Copying Changes Between Branches</title> -->
    <title>Copiare modifiche tra i rami</title>

    <para lang="en">Now you and Sally are working on parallel branches of the
      project: you're working on a private branch, and Sally is
      working on the <firstterm>trunk</firstterm>, or main line of
      development.</para>

    <para>Adesso voi e Sally state lavorando sui rami paralleli del progetto:
      voi lavorate su un ramo privato e Sally lavora su <firstterm>tronco</firstterm>
      (<firstterm>trunk</firstterm>), o linea principale dello sviluppo.</para>

    <para lang="en">For projects that have a large number of contributors, it's
      common for most people to have working copies of the trunk.
      Whenever someone needs to make a long-running change that is
      likely to disrupt the trunk, a standard procedure is to create a
      private branch and commit changes there until all the work is
      complete.</para>

    <para>Per progetti che hanno grande numero di contribuenti, è comune
      per molta gente di avere copie di lavoro del tronco.
      Ogni volta che qualcuno ha bisogno di fare durature modifiche,
      che potrebbero disturbare il tronco, procedura standard è di creare
      un ramo privato e pubblicare le modifiche là finché tutto
      il lavoro no è completo.</para>

    <para lang="en">So, the good news is that you and Sally aren't interfering
      with each other.  The bad news is that it's very easy to drift
      <emphasis>too</emphasis> far apart.  Remember that one of the
      problems with the <quote>crawl in a hole</quote> strategy is
      that by the time you're finished with your branch, it may be
      near-impossible to merge your changes back into the trunk
      without a huge number of conflicts.</para>

    <para>Allora, la notizia buona è che voi e Sally non vi disturbate
      a vicenda. La cativa è che è molto facile slittare
      <emphasis>tropo</emphasis> lontano.  Ricordate che uno dei problemi
      della strategia <quote>nascondersi in una buca</quote> è
      che quando avrete finito con il vostro ramo, potrebbe essere
      quasi impossibile fondere vostre modifiche nel tronco principale senza
      largo numero di conflitti.</para>

    <para lang="en">Instead, you and Sally might continue to share changes as
      you work.  It's up to you to decide which changes are worth
      sharing; Subversion gives you the ability to selectively
      <quote>copy</quote> changes between branches.  And when you're
      completely finished with your branch, your entire set of branch
      changes can be copied back into the trunk.</para>

    <para>Invece, voi e Sally potette continuare di scambiarsi modifiche
      mentre lavorate.  Spetta a voi decidere qualle modifiche vale la pena
      condividere; Subversion vi dà l'abilità di <quote>copiare</quote>
      modifiche tra i rami selettivamente.  E quando avrete completamente
      finito con il vostro ramo, vostro completto insieme di modifiche del ramo
      può essere copiato dietro nel tronco.</para>


    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.copychanges.specific">
      <!-- <title>Copying Specific Changes</title> -->
      <title>Copiare modifiche specifiche</title>

      <para lang="en">In the previous section, we mentioned that both you and
        Sally made changes to <filename>integer.c</filename> on
        different branches.  If you look at Sally's log message for
        revision 344, you can see that she fixed some spelling errors.
        No doubt, your copy of the same file still has the same spelling
        errors.  It's likely that your future changes to this file will
        be affecting the same areas that have the spelling errors, so
        you're in for some potential conflicts when you merge your
        branch someday.  It's better, then, to receive Sally's change
        now, <emphasis>before</emphasis> you start working too heavily
        in the same places.</para>

      <para>Nella precedente sezione, abbiamo menzionato che
        entrambi, voi e Sally avete fatto modifiche su
        <filename>integer.c</filename> nei rami diversi.
        Se date un sguardo al messaggio di log di Sally (versione
        344), potete vedere che ella ha corretto qualche errore di battitura.
        Senza dubbio, vostra copia dello stesso file ancora ha gli stessi
        errori.  È probabile che le vostre future modifiche al file toccheranno
        gli stessi posti che hanno errori di battitura, così sorgeranno alcuni
        potenziali conflitti, quando un giorno andrete a fondere il vostro ramo.
        Meglio incorporare le modifiche di Sally adesso,
        <emphasis>prima</emphasis> che cominciate lavoro troppo pesante
        sugli stessi posti.</para>

      <para lang="en">It's time to use the <command>svn merge</command> command.
        This command, it turns out, is a very close cousin to the
        <command>svn diff</command> command (which you read about in
        Chapter 3).  Both commands are able to compare any two objects
        in the repository and describe the differences.  For example,
        you can ask <command>svn diff</command> to show you the exact
        change made by Sally in revision 344:</para>

      <para>È ora di usare comando <command>svn merge</command>.
        Questo comando, come si vedrà, è cugino molto stretto del
        comando <command>svn diff</command> (di quale avete letto nel
        Capitolo 3).  Entrambi comandi sono capaci di comparare qualsiasi
        due oggetti in deposito e descrivere le differenze. Per esempio,
        potete chiedere a <command>svn diff</command> di mostrare
        esatta modifica fatta da Sally nella versione 344:</para>

      <screen lang="en">
$ svn diff -r 343:344 http://svn.example.com/repos/calc/trunk

Index: integer.c
===================================================================
--- integer.c   (revision 343)
+++ integer.c   (revision 344)
@@ -147,7 +147,7 @@
     case 6:  sprintf(info-&gt;operating_system, "HPFS (OS/2 or NT)"); break;
     case 7:  sprintf(info-&gt;operating_system, "Macintosh"); break;
     case 8:  sprintf(info-&gt;operating_system, "Z-System"); break;
-    case 9:  sprintf(info-&gt;operating_system, "CPM"); break;
+    case 9:  sprintf(info-&gt;operating_system, "CP/M"); break;
     case 10:  sprintf(info-&gt;operating_system, "TOPS-20"); break;
     case 11:  sprintf(info-&gt;operating_system, "NTFS (Windows NT)"); break;
     case 12:  sprintf(info-&gt;operating_system, "QDOS"); break;
@@ -164,7 +164,7 @@
     low = (unsigned short) read_byte(gzfile);  /* read LSB */
     high = (unsigned short) read_byte(gzfile); /* read MSB */
     high = high &lt;&lt; 8;  /* interpret MSB correctly */
-    total = low + high; /* add them togethe for correct total */
+    total = low + high; /* add them together for correct total */

     info-&gt;extra_header = (unsigned char *) my_malloc(total);
     fread(info-&gt;extra_header, total, 1, gzfile);
@@ -241,7 +241,7 @@
      Store the offset with ftell() ! */

   if ((info-&gt;data_offset = ftell(gzfile))== -1) {
-    printf("error: ftell() retturned -1.\n");
+    printf("error: ftell() returned -1.\n");
     exit(1);
   }

@@ -249,7 +249,7 @@
   printf("I believe start of compressed data is %u\n", info-&gt;data_offset);
   #endif

-  /* Set postion eight bytes from the end of the file. */
+  /* Set position eight bytes from the end of the file. */

   if (fseek(gzfile, -8, SEEK_END)) {
     printf("error: fseek() returned non-zero\n");
</screen>
<screen>
  $ svn diff -r 343:344 http://svn.example.com/repos/calc/trunk

  Index: integer.c
  ===================================================================
  --- integer.c   (revision 343)
  +++ integer.c   (revision 344)
  @@ -147,7 +147,7 @@
  case 6:  sprintf(info-&gt;operating_system, "HPFS (OS/2 or NT)"); break;
  case 7:  sprintf(info-&gt;operating_system, "Macintosh"); break;
  case 8:  sprintf(info-&gt;operating_system, "Z-System"); break;
  -    case 9:  sprintf(info-&gt;operating_system, "CPM"); break;
  +    case 9:  sprintf(info-&gt;operating_system, "CP/M"); break;
  case 10:  sprintf(info-&gt;operating_system, "TOPS-20"); break;
  case 11:  sprintf(info-&gt;operating_system, "NTFS (Windows NT)"); break;
  case 12:  sprintf(info-&gt;operating_system, "QDOS"); break;
  @@ -164,7 +164,7 @@
  low = (unsigned short) read_byte(gzfile);  /* read LSB */
  high = (unsigned short) read_byte(gzfile); /* read MSB */
  high = high &lt;&lt; 8;  /* interpreta MSB correttamente */
  -    total = low + high; /* sommali inseme per un totale corretto */
  +    total = low + high; /* sommali insieme per un totale corretto */

  info-&gt;extra_header = (unsigned char *) my_malloc(total);
  fread(info-&gt;extra_header, total, 1, gzfile);
  @@ -241,7 +241,7 @@
  Memorizza offset con ftell() ! */

  if ((info-&gt;data_offset = ftell(gzfile))== -1) {
  -    printf("errore: ftell() ha resttituito -1.\n");
  +    printf("errore: ftell() ha restituito -1.\n");
  exit(1);
  }

  @@ -249,7 +249,7 @@
  printf("Credo che inizio dei dati compressi è %u\n", info-&gt;data_offset);
  #endif

  -  /* Imposta poszione otto byte dalla fine del file. */
  +  /* Imposta posizione otto byte dalla fine del file. */

  if (fseek(gzfile, -8, SEEK_END)) {
  printf("errore: fseek() ha restituito non-zero\n");
</screen>

      <para lang="en">The <command>svn merge</command> command is almost exactly
        the same.  Instead of printing the differences to your
        terminal, however, it applies them directly to your working
        copy as <emphasis>local modifications</emphasis>:</para>

      <para>Il comando <command>svn merge</command> è quasi esattamente
        uguale.  Invece di mostrare le differenze sullo schermo,
        tuttavia, le applica direttamente nella vostra
        copia di lavoro come <emphasis>modifiche locali</emphasis>:</para>

      <screen>
$ svn merge -r 343:344 http://svn.example.com/repos/calc/trunk
U  integer.c

$ svn status
M  integer.c
</screen>

      <para lang="en">The output of <command>svn merge</command> shows that your
        copy of <filename>integer.c</filename> was patched.  It now
        contains Sally's change&mdash;the change has been
        <quote>copied</quote> from the trunk to your working copy of
        your private branch, and now exists as a local modification.
        At this point, it's up to you to review the local modification
        and make sure it works correctly.</para>

      <para>L'output di <command>svn merge</command> mostra che vostra
        copia di <filename>integer.c</filename> era stata modificata. Adesso
        contiene le modifiche di Sally&mdash;le modifiche erano state
        <quote>copiate</quote> dal tronco nella copia di lavoro
        del vostro ramo privato e adesso esistono come modifiche locali.
        A questo punto, tocca a voi rivedere le modifiche locali ed assicurare
        che funzionano correttamente.</para>

      <para lang="en">In another scenario, it's possible that things may not have
        gone so well, and that <filename>integer.c</filename> may have
        entered a conflicted state.  You might need to resolve the
        conflict using standard procedures (see Chapter 3), or if you
        decide that the merge was a bad idea altogether, simply give up
        and <command>svn revert</command> the local change.</para>

      <para>In un altro scenario, è possibile che le cose possono non andare
        così bene e perciò <filename>integer.c</filename> può entrare
        nello stato di conflitto.  Potette avere bisogno di risolvere
        il conflitto usando procedure standard (vedi Capitolo 3), oppure
        se decidete che fusione era del tutto una cativa idea,
        semplicemente passare sopra e scartare con <command>svn revert</command>
        le modifiche locali.</para>

      <para lang="en">But assuming that you've reviewed the merged change, you can
        <command>svn commit</command> the change as usual.  At that
        point, the change has been merged into your repository branch.
        In version control terminology, this act of copying changes
        between branches is commonly called
        <firstterm>porting</firstterm> changes.</para>

      <para>Ma assumendo che avete ispezionato le modifiche incorporate,
        potete pubblicarle con <command>svn commit</command>
        come al solito. A questo punto, la modifica sarà fusa dentro
        il vostro ramo del deposito. Nella terminologia di controlo delle
        versioni, questo atto di copiatura delle modifiche tra i rami
        è comunemnte chaimato <firstterm>porting</firstterm> dele modifiche.</para>

      <para lang="en">When you commit the local modification, make sure your log
        message mentions that you're porting a specific change from
        one branch to another.  For example:</para>

      <para>Facendo commit delle modifiche locali, assicuratevi che
        vostro messaggio menziona che state portando una modifica specifica
        da un ramo ad altro. Per esempio:</para>

      <screen lang="en">
$ svn commit -m "integer.c: ported r344 (spelling fixes) from trunk."
Sending        integer.c
Transmitting file data .
Committed revision 360.
</screen>
<screen>
  $ svn commit -m "integer.c: portata r344 (fix di ortografia) dal tronco."
  Sending        integer.c
  Transmitting file data .
  Committed revision 360.
</screen>

      <para lang="en">As you'll see in the next sections, this is a very
        important <quote>best practice</quote> to follow.</para>

      <para>Come vedrete nella prossima sezione, questa è molto importante
        <quote>regola d'arte</quote> da seguire.</para>

      <sidebar>
        <!-- <title>Why Not Use Patches Instead?</title> -->
        <title>Perché non usare invece Patch?</title>

        <para lang="en">A question may be on your mind, especially if you're a
          Unix user: why bother to use <command>svn merge</command> at
          all?  Why not simply use the operating system's
          <command>patch</command> command to accomplish the same job?
          For example:</para>

        <para>Potete pensare a una domanda, specialmente se siete utenti
          Unix: perchè disturbarsi con <command>svn merge</command>?
          Perché semplicemente non usare comando di sistema operativo
          <command>patch</command> per svolgere lo stesso lavoro?
          Per esempio:</para>

        <screen>
$ svn diff -r 343:344 http://svn.example.com/repos/calc/trunk &gt; patchfile
$ patch -p0  &lt; patchfile
Patching file integer.c using Plan A...
Hunk #1 succeeded at 147.
Hunk #2 succeeded at 164.
Hunk #3 succeeded at 241.
Hunk #4 succeeded at 249.
done
</screen>

        <para lang="en">In this particular case, yes, there really is no
          difference.  But <command>svn merge</command> has special
          abilities that surpass the <command>patch</command> program.
          The file format used by <command>patch</command> is quite
          limited; it's only able to tweak file contents.  There's no
          way to represent changes to <emphasis>trees</emphasis>, such
          as the addition, removal, or renaming of files and
          directories.  If Sally's change had, say, added a new
          directory, the output of <command>svn diff</command>
          wouldn't have mentioned it at all.  <command>svn
          diff</command> only outputs the limited patch-format, so
          there are some ideas it simply can't express.
          <footnote>
            <para>In the future, the Subversion project plans to use
              (or invent) an expanded patch format that describes
              changes in tree structure and properties.</para>
          </footnote>
          The <command>svn merge</command> command, however, can express
          changes in tree structure and properties by directly applying
          them to your working copy.</para>

        <para>In questo caso particolare, sì, veramente non c'è
          differenza.  Ma <command>svn merge</command> ha le
          abilità speciali che sorpassano il programma <command>patch</command>.
          Formato di file usato da <command>patch</command> è un po'
          limitato; è capace di maneggare contenuto del file.  Non c'è
          modo di rappresentare modifiche delle <emphasis>strutture</emphasis>,
          come aggiunta, rimozione o cambio del nome dei file e delle
          cartelle.  Se la modifica di Sally ha, diciamo, aggiunto una
          nuova cartella, output di <command>svn diff</command>
          non la menziona neanche.  <command>svn
          diff</command> mostra solo patch in un format0 limitato, così ci sono
          alcune idee che semplicemente non può esprimere.
          <footnote>
            <para>In futuro, progetto Subversion pianifica du usare
              (o inventare) patch format estesso che descrive modifiche
              delle struture e properietà.</para>
          </footnote>
          Il comando <command>svn merge</command>, tuttavia, può esprimere
          modifiche della struttura e properietà applicandole direttamente
          sulla vostra copia di lavoro.</para>
      </sidebar>

      <para lang="en">A word of warning: while <command>svn diff</command> and
        <command>svn merge</command> are very similar in concept, they
        do have different syntax in many cases.  Be sure to read about
        them in Chapter 9 for details, or ask <command>svn
        help</command>.  For example, <command>svn merge</command>
        requires a working-copy path as a target, i.e. a place where
        it should apply the tree-changes.  If the target isn't
        specified, it assumes you are trying to perform one of the
        following common operations:</para>

      <para>Una parola di avvertimento: anche se <command>svn diff</command> e
        <command>svn merge</command> sono nel concetto molto simili, hanno
        in molti casi la sintassi diversa.  Assicuratevi di leggere dettagli
        nel Capitolo 9 o chiedete lumi a <command>svn help</command>.
        Per esempio, <command>svn merge</command> richiede percorso
        di copia di lavoro come destinazione, i.e. un posto dove può applicare
        le modifiche della struttura. Se la destinazione non è specificata,
        assume che state provando di fare una delle seguenti comuni
        operazioni:</para>

      <orderedlist>
        <listitem>
          <para lang="en">You want to merge directory changes into your current
            working directory.</para>
          <para>Volete fondere modifiche delle cartelle nella vostra
            cartella di lavoro.</para>
        </listitem>
        <listitem>
          <para lang="en">You want to merge the changes in a specific file into
            a file by the same name which exists in your current working
            directory.</para>
          <para>Volete fondere le modifiche d'un file specifico
            dentro un file con lo stesso nome che esiste nella vostra
            cartella di lavoro.</para>
        </listitem>
      </orderedlist>

      <para lang="en">If you are merging a directory and haven't specified a
        target path, <command>svn merge</command> assumes the first case
        above and tries to apply the changes into your current
        directory.  If you are merging a file, and that file (or a file
        by the same name) exists in your current working directory,
        <command>svn merge</command> assumes the second case and tries
        to apply the changes to a local file with the same name.</para>

      <para>Se state fondendo una cartella e non avete specificato percorso
        di destinazione, <command>svn merge</command> assume il primo caso
        sopra e prova applicare le modifiche dentro vostra cartella attuale.
        Se state fondendo un file e questo file (o un file con lo stesso nome)
        esiste dentro vostra cartella attuale,
        <command>svn merge</command> assume il secondo caso e prova
        applicare le modifiche dentro file locale con lo stesso nome.</para>

      <para lang="en">If you want changes applied somewhere else, you'll
        need to say so.  For example, if you're sitting in the parent
        directory of your working copy, you'll have to specify the
        target directory to receive the changes:</para>

      <para>Se volete applicare le modifiche in un altro posto, dovete dirlo.
        Per esempio, se siete nella cartella parente della vostra copia di
        lavoro, dovete specificare cartella destinazione per ricevere
        le modifiche:</para>

      <screen>
$ svn merge -r 343:344 http://svn.example.com/repos/calc/trunk my-calc-branch
U   my-calc-branch/integer.c
</screen>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.copychanges.keyconcept">
<!--       <title>The Key Concept Behind Merging</title> -->
      <title>Concetto chiave dietro la fusione</title>

      <para lang="en">You've now seen an example of the <command>svn
          merge</command> command, and you're about to see several
          more.  If you're feeling confused about exactly how merging
          works, you're not alone.  Many users (especially those new
          to version control) are initially perplexed about the proper
          syntax of the command, and about how and when the feature
          should be used.  But fear not, this command is actually much
          simpler than you think!  There's a very easy technique for
          understanding exactly how <command>svn merge</command>
          behaves.</para>

        <para>Abbiamo visto un esempio di comando <command>svn
            merge</command>, e stiamo per vedere di più.
          Se vi sentite confusi riguardo come funziona esattamente
          la fusione, non siete soli. Molti utenti (specialmente
          quelli nuovi a cotrollo delle versioni) rimangono inizialmente
          perplessi riguardo la giusta sintassi del comando e come
          e quando usare questa caratteristica.
          Non avere paura, questo comando è in verità molto più
          semplice che si pensa. C'è una tecnica molto semplice
          per capire esattamente come <command>svn merge</command>
          agisce.</para>

      <para lang="en">The main source of confusion is the
        <emphasis>name</emphasis> of the command.  The term
        <quote>merge</quote> somehow denotes that branches are
        combined together, or that there's some sort of mysterious
        blending of data going on.  That's not the case.  A better
        name for the command might have been <command>svn
        diff-and-apply</command>, because that's all that happens:
        two repository trees are compared, and the differences are
        applied to a working copy.</para>

      <para>La fonte primaria della confusione è il
        <emphasis>nome</emphasis> del comando.  Il termine
        <quote>merge</quote>(fondere) qualche volta denota che i rami sono
        combinati tra loro, oppure che ci sta qualche sorta di misterioso
        mescolamento dei dati.  Non è il caso.  Più appropriato
        nome per questo comando forse sarebbe
        <command>svn diff-and-apply</command>(trova-differenze-e-applicale),
        perché questo è tutto che accade: due strutture del deposito sono comparate
        e le differenze sono applicate alla copia di lavoro.</para>

      <para lang="en">The command takes three arguments:</para>
      <para>Il comando prende tre argomenti:</para>

      <orderedlist>

        <listitem><para lang="en">An initial repository tree (often called the
        <firstterm>left side</firstterm> of the
        comparison),</para><para>Una struttura del deposito iniziale (spesso chiamata il
        <firstterm>lato sinistro</firstterm> della comparazione),</para></listitem>

        <listitem><para lang="en">A final repository tree (often called the
        <firstterm>right side</firstterm> of the
        comparison),</para><para>Una struttura del deposito finale (spesso chiamata il
        <firstterm>lato destro</firstterm>  della comparazione),</para></listitem>

        <listitem><para lang="en">A working copy to accept the differences as
        local changes (often called the <firstterm>target</firstterm>
        of the merge).</para><para>Una copia di lavoro per ricevere le differenze
        come modifiche locali (spesso chiamata la <firstterm>destinazione</firstterm>
        della fusione).</para></listitem>

      </orderedlist>

    <para lang="en">Once these three arguments are specified, the two trees
        are compared, and the resulting differences are applied to the
        target working copy as local modifications.  When the command
        is done, the results are no different than if you had
        hand-edited the files, or run various <command>svn
        add</command> or <command>svn delete</command> commands
        yourself.  If you like the results, you can commit them.  If
        you don't like the results, you can simply <command>svn
        revert</command> all of the changes.</para>

    <para>Una volta specificati questi tre argomenti, le due strutture
      sono comparate e le differenze risultanti sono applicate
      alla copia di lavoro destinataria come modifiche locali.
      Quando il comando finisce il suo lavoro, il risultato non è diverso
      da come aveste editato i file manualmente o aveste da soli avviato
      svariati comandi <command>svn add</command> o <command>svn delete</command>.
      Se il risultato vi piace, potete fare commit. Se non vi piace,
      con semplice comando <command>svn revert</command> scartate tutte le
      modifiche.</para>

      <para lang="en">The syntax of <command>svn merge</command> allows you to
        specify the three necessary arguments rather flexibly.  Here
        are some examples:</para>

      <para>La sintassi di comando <command>svn merge</command> vi permete
        di specificare i tre argomenti necessari in modo molto flessibile
        Qui ci sono alcuni esempi:</para>

      <screen>
$ svn merge http://svn.example.com/repos/branch1@150 \
            http://svn.example.com/repos/branch2@212 \
            my-working-copy

$ svn merge -r 100:200 http://svn.example.com/repos/trunk my-working-copy

$ svn merge -r 100:200 http://svn.example.com/repos/trunk
</screen>

      <para lang="en">The first syntax lays out all three arguments explicitly,
        naming each tree in the form <emphasis>URL@REV</emphasis> and
        naming the working copy target.  The second syntax can be used
        as a shorthand for situations when you're comparing two
        different revisions of the same URL.  The last syntax shows
        how the working-copy argument is optional; if omitted, it
        defaults to the current directory.</para>

      <para>La prima sintassi elenca tutti e tre argomenti
        esplicitamente, nominando ogni struttura in forma <emphasis>URL@REV</emphasis>
        e nominando la copia di lavoro ricevente. La seconda sintassi
        può essere usata, quando state comparando due versioni diverse
        dello stesso URL. L'ultima sintassi mostra che argomento 'copia di lavoro'
        è facoltativo; se omesso, il suo valore predefinito è la cartella
        attuale.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.copychanges.bestprac">
      <!--  <title>Best Practices for Merging</title> -->
      <title>Regole d'arte per la fusione</title>

      <sect3 id="svn.branchmerge.copychanges.bestprac.track">
        <!--  <title>Tracking Merges Manually</title> -->
        <title>Tenere a mano traccia delle fusioni</title>

        <para lang="en">Merging changes sounds simple enough, but in practice it
          can become a headache.  The problem is that if you
          repeatedly merge changes from one branch to another, you
          might accidentally merge the same change
          <emphasis>twice</emphasis>.  When this happens, sometimes
          things will work fine.  When patching a file, Subversion
          typically notices if the file already has the change, and
          does nothing.  But if the already-existing change has been
          modified in any way, you'll get a conflict.</para>

        <para>Fondere modifiche suona abbastanza semplice, ma in prattica
          può diventare mal di testa.  Il problema è che se ripetutamente
          fondete modifiche da un ramo ad altro, potete accidentalmente
          fondere la stessa modifica <emphasis>due volte</emphasis>.
          Se succede questo, a volte tutto va bene. Quando Subversion applica
          le modifiche su un file, tipicamente si accorge che il file queste
          modifiche ha già e non fa niente.  Ma se la già esistente modifica
          era ulteriormente modificata, otente un conflitto.</para>

        <para lang="en">Ideally, your version control system should prevent the
          double-application of changes to a branch.  It should
          automatically remember which changes a branch has already
          received, and be able to list them for you.  It should use
          this information to help automate merges as much as
          possible.</para>

        <para>Idealmente, vostro sistema di controlo delle versioni
          dovrebbe prevenire la doppia applicazione delle modifiche su un ramo.
          Dovrebbe automaticamente ricordare quale modifiche il ramo ha già
          ricevuto ed essere capace di elencarle per voi. Dovrebbe
          usare queste informazioni per automatizzare le fusioni
          quanto più possibile.</para>

        <para lang="en">Unfortunately, Subversion is not such a system.  Like
          CVS, Subversion does not yet record any information about
          merge operations.  When you commit local modifications, the
          repository has no idea whether those changes came from
          running <command>svn merge</command>, or from just
          hand-editing the files.</para>

        <para>Sfortunatamente, un sistema così non è Subversion.  Come il
          CVS, Subversion non memorizza ancora nessuna informazione riguardo
          operazioni di fusioni.  Quando fatte commit delle modifiche locali,
          il deposito non ha idea se queste modifiche arrivano da
          <command>svn merge</command> eseguito o da editazione a mano dei file.</para>

        <para lang="en">What does this mean to you, the user?  It means that
          until the day Subversion grows this feature, you'll have to
          track merge information yourself.  The best place to do this
          is in the commit log-message.  As demonstrated in the
          earlier example, it's recommended that your log-message
          mention a specific revision number (or range of revisions)
          that are being merged into your branch.  Later on, you can
          run <command>svn log</command> to review which changes your
          branch already contains.  This will allow you to carefully
          construct a subsequent <command>svn merge</command> command
          that won't be redundant with previously ported
          changes.</para>

        <para>Che cosa significa questo per voi, utente?  Significa che
          fino al giorno in cui Subversion avrà questa capacità,
          dovete tracciare informazioni riguardo le fusioni da soli.
          Il posto migliore dove farlo è messaggio di commit.
          Come era dimostrato nel esempio precedente, è raccomandato
          che vostro messaggio menziona specifico numero della revisione
          (o rango delle revisioni) che state fondendo nel vostro ramo.
          In futuro potete avviare comando <command>svn log</command>
          per vedere quale modifiche contiene già il vostro ramo.
          Questo vi permete di costruire con cura prossimi comandi
          <command>svn merge</command> che non saranno redundanti
          con le modifiche già riportate in precedenza.</para>

        <para lang="en">In the next section, we'll show some examples of this
          technique in action.</para>

        <para>Nella prossima sezione mostreremo in azione alcuni esempi
          di questa tecnica.</para>

      </sect3>

      <sect3 id="svn.branchmerge.copychanges.bestprac.preview">
        <!-- <title>Previewing Merges</title> -->
        <title>Anteprima delle fusioni</title>

        <para lang="en">Because merging only results in local modifications,
          it's not usually a high-risk operation.  If you get the
          merge wrong the first time, simply <command>svn
            revert</command> the changes and try again.</para>

        <para>Perché risultato delle fusioni sono soltanto
          le modifiche locali, questa non è normalmente una operazione
          ad alto rischio.  Se vi capita di fondere male prima volta,
          semplicemente buttate via le modifiche (<command>svn
          revert</command>) e provate di nuovo.</para>

        <para lang="en">It's possible, however, that your working copy might
          already have local modifications.  The changes applied by a
          merge will be mixed with your pre-existing ones, and running
          <command>svn revert</command> is no longer an option.  The
          two sets of changes may be impossible to separate.</para>

        <para>È possibile, comunque, che vostra copia di lavoro contiene anche
          le modifiche locali. Le modifiche applicate da merge saranno mischiate
          tra le vostre e avviare comando <command>svn revert</command> non è
          più una scelta pratticabile.  Potrebbe essere impossibile separare
          i due insiemi delle modifiche.</para>

        <para lang="en">In cases like this, people take comfort in being able to
          predict or examine merges before they happen.  One simple
          way to do that is to run <command>svn diff</command> with
          the same arguments you plan to pass to <command>svn
          merge</command>, as we already showed in our first example
          of merging.  Another method of previewing is to pass the
          <option>--dry-run</option> option to the merge
          command:</para>

        <para>In casi come questo, le persone si confortano con la possibilità
          di prevedere o esaminare fusione prima che accade. Un semplice
          modo per farlo è avviare <command>svn diff</command>
          con gli stessi argomenti che avete in mente di passare a
          <command>svn merge</command>, come abbiamo già mostrato nel nostro
          primo esempio. Altro metodo di anteprima è aggiungere la opzione
          <option>--dry-run</option>(a secco) al comando merge:</para>

<screen lang="en">
$ svn merge \-\-dry-run -r 343:344 http://svn.example.com/repos/calc/trunk
U  integer.c

$ svn status
#  nothing printed, working copy is still unchanged.
</screen>
<screen>
  $ svn merge --dry-run -r 343:344 http://svn.example.com/repos/calc/trunk
  U  integer.c

  $ svn status
  # non stampa niente, copia di lavoro è ancora intatta.
</screen>

        <para lang="en">The <option>--dry-run</option> option doesn't actually
          apply any local changes to the working copy.  It only shows
          status codes that <emphasis>would</emphasis> be printed in a
          real merge.  It's useful for getting a <quote>high
          level</quote> preview of the potential merge, for those
          times when running <command>svn diff</command> gives too
          much detail.</para>

        <para>La opzione <option>--dry-run</option> in verità non applica
          nessuna modifica locale alla copia di lavoro.  Mostra solo output
          che <emphasis>sarebbe</emphasis> mostrato con la fusione vera.
          Questo è utile per avere una previsione ad <quote>alto
          livello</quote> della potenziale fusione, per quelle volte dove
          comando <command>svn diff</command> dà troppi dettagli.</para>

      </sect3>

      <sidebar>
        <!-- <title>Subversion and Changesets</title> -->
        <title>Subversion e gli changeset</title>

        <para lang="en">Everyone seems to have a slightly different definition
          of <quote>changeset</quote>, or at least a different
          expectation of what it means for a version control system to
          have <quote>changeset features</quote>.  For our purpose,
          let's say that a changeset is just a collection of changes
          with a unique name.  The changes might include textual edits
          to file contents, modifications to tree structure, or tweaks
          to metadata.  In more common speak, a changeset is just a
          patch with a name you can refer to.</para>

        <para>Sembra che ciascuno ha la definizione degli
           <quote>changeset</quote> legermente diversa, o almeno
          diverse aspettative di che cosa significa per sistema
          di controlo delle versioni avere <quote>capacità di changeset</quote>
          (insieme delle modifiche). Per nostro scopo, diciamo che un
          changeset è solo una collezione delle modifiche
          con un nome unico.  Le modifiche possono includere editazioni testuali
          del contenuto dei file, modificazioni della struttura o cambiamenti
          dei metadati. In parole povere, un changeset è solo un
          ??patch? con nome con quale portremo riferirsi ad esso.</para>

        <para lang="en">In Subversion, a global revision number N names a tree
          in the repository: it's the way the repository looked after
          the Nth commit.  It's also the name of an implicit
          changeset: if you compare tree N with tree N-1, you can
          derive the exact patch that was committed.  For this reason,
          it's easy to think of <quote>revision N</quote> as not just
          a tree, but a changeset as well.  If you use an issue
          tracker to manage bugs, you can use the revision numbers to
          refer to particular patches that fix bugs&mdash;for example,
          <quote>this issue was fixed by revision 9238.</quote>.
          Somebody can then run <command>svn log -r9238</command> to
          read about the exact changeset which fixed the bug, and run
          <command>svn diff -r9237:9238</command> to see the patch
          itself.  And Subversion's <literal>merge</literal> command
          also uses revision numbers.  You can merge specific changesets
          from one branch to another by naming them in the merge
          arguments: <command>svn merge -r9237:9238</command> would
          merge changeset #9238 into your working copy.</para>

        <para>In Subversion, numero globale di versione N nomina una struttura
          in deposito: modo in quale il deposito appare dopo N-essimo commit.
          Ed è anche il nome di un implicito changeset: comparando struttura
          N con struttura N-1, potete ricavare esatto ??patch? che era applicato.
          Per questa ragione è semplice pensare <quote>revisione N</quote> non
          solo come struttura ma nello stesso modo changeset. ##### If you use an issue
          tracker to manage bugs, you can use the revision numbers to
          refer to particular patches that fix bugs&mdash;for example,
          <quote>this issue was fixed by revision 9238.</quote>.
          Somebody can then run <command>svn log -r9238</command> to
          read about the exact changeset which fixed the bug, and run
          <command>svn diff -r9237:9238</command> to see the patch
          itself.  And Subversion's <literal>merge</literal> command
          also uses revision numbers.  You can merge specific changesets
          from one branch to another by naming them in the merge
          arguments: <command>svn merge -r9237:9238</command> would
          merge changeset #9238 into your working copy.</para>
      </sidebar>

      <sect3 id="svn.branchmerge.copychanges.bestprac.merge">
        <!-- <title>Merge Conflicts</title> -->
        <title>Conflitti delle fusioni</title>

        <para lang="en">Just like the <command>svn update</command> command,
          <command>svn merge</command> applies changes to your working
          copy.  And therefore it's also capable of creating
          conflicts.  The conflicts produced by <command>svn
            merge</command>, however, are sometimes different, and this
          section explains those differences.</para>

        <para>Così come comando <command>svn update</command>,
          anche <command>svn merge</command> applica modifiche alla vostra
          copia di lavoro. E perciò è capace generare conflitti. I conflitti
          prodotti da <command>svn merge</command>, tuttavia, sono a volte
          diversi e questa sezione spiega queste differenze.</para>

        <para lang="en">To begin with, assume that your working copy has no
          local edits.  When you <command>svn update</command> to a
          particular revision, the changes sent by the server will
          always apply <quote>cleanly</quote> to your working copy.
          The server produces the delta by comparing two trees: a
          virtual snapshot of your working copy, and the revision tree
          you're interested in.  Because the left-hand side of the
          comparison is exactly equal to what you already have, the
          delta is guaranteed to correctly convert your working copy
          into the right-hand tree.</para>

        <para>Per cominciare, si assume che vostra copia di lavoro
          non ha editazioni locali. Quando la aggiornate (<command>svn update</command>)
          ad una particolare versione, le modifiche mandate dal server
          si applicano sempre alla vostra copia di lavoro in modo
          <quote>pulito</quote>.
          Il server produce un ??delta? comparando due strutture: un'instantanea
          virtuale della vostra copia di lavoro e struttura della revisione a quale
          siete interessati. Perché lato sinistra della comparazione è uguale
          a quel che già avete il delta garantisce di correttamente convertire
          vostra copia di lavoro nella struttura di lato destra.</para>

        <para lang="en">But <command>svn merge</command> has no such guarantees
          and can be much more chaotic: the user can ask the server to
          compare <emphasis>any</emphasis> two trees at all, even ones
          that are unrelated to the working copy!  This means there's
          large potential for human error.  Users will sometimes
          compare the wrong two trees, creating a delta that doesn't
          apply cleanly.  <command>svn merge</command> will do its
          best to apply as much of the delta as possible, but some
          parts may be impossible.  Just like the Unix
          <command>patch</command> command sometimes complains about
          <quote>failed hunks</quote>, <command>svn merge</command>
          will complain about <quote>skipped targets</quote>:</para>

        <para>Ma <command>svn merge</command> non ha tali garanzie
          e può essere più caotico: utente può chidere al server di
          comparare <emphasis>qualsiasi</emphasis> due strutture, anche
          tali che non hanno nessun legame con la copia di lavoro.
          Questo significa che qui c'è largo potenziale per errori umani.
          Utenti possono a volte comparare due strutture sbagliate,
          creando delta che non si applica pulitamente.
          <command>svn merge</command> farà il meglio per applicare più
          possibile il delta, ma su alcune parti questo potrà essere
          impossibile. Nello stesso modo come comando Unix
          <command>patch</command> a volte si lamenta di ??<quote>failed hunks</quote>?,
          <command>svn merge</command> può accusare <quote>skipped targets</quote>
          (destinazioni saltate):</para>

        <screen>
$ svn merge -r 1288:1351 http://svn.example.com/repos/branch
U  foo.c
U  bar.c
Skipped missing target: 'baz.c'
U  glub.c
C  glorb.h

$
</screen>

        <para lang="en">In the previous example it might be the case that
          <filename>baz.c</filename> exists in both snapshots of the
          branch being compared, and the resulting delta wants to
          change the file's contents, but the file doesn't exist in
          the working copy.  Whatever the case, the
          <quote>skipped</quote> message means that the user is most
          likely comparing the wrong two trees; they're the classic
          sign of driver error.  When this happens, it's easy to
          recursively revert all the changes created by the merge
          (<command>svn revert --recursive</command>), delete any
          unversioned files or directories left behind after the
          revert, and re-run <command>svn merge</command> with
          different arguments.</para>

        <para>Nel esempio precedente può essere caso che
          <filename>baz.c</filename> esiste in entrambe instantanee del
          ramo comparato e delta risultante vuole cambiare il contenuto del
          file, ma il file non esiste nella copia di lavoro.
          Qualunque sia causa, il messaggio
          <quote>skipped</quote>(saltato) significa che
          con alta probabilità utente sta comparando le strutture sbagliate;
          questo è un segno classico del 'errore del conducente'.
          Quando accade ciò, è semplice invertire ricorsivamente tutte le
          modifiche create dalla fusione (<command>svn revert --recursive</command>),
          cancellare ogni file o cartella rimasta senza controllo delle versioni
          dopo revert e rifare <command>svn merge</command> con argomenti
          diversi.</para>

        <para lang="en">Also notice that the previous example shows a conflict
          happening on <filename>glorb.h</filename>.  We already
          stated that the working copy has no local edits: how can a
          conflict possibly happen?  Again, because the user can use
          <command>svn merge</command> to define and apply any old
          delta to the working copy, that delta may contain textual
          changes that don't cleanly apply to a working file, even if
          the file has no local modifications.</para>

        <para>Notare ancora che precedente esempio mostra un conflitto
          accaduto su <filename>glorb.h</filename>.  Abbiamo già stabilito
          che copia di lavoro non ha editazioni locali: come può allora
          accadere un conflitto?  Di nuovo, perché l'utente può usare
          <command>svn merge</command> per definire ed applicare qualsiasi
          delta vecchio a copia di lavoro, tale delta può contenere modifiche
          testuali che non si applicano in modo pulito al file di lavoro,
          anche se il file non ha le modifiche locali.</para>

        <para lang="en">Another small difference between <command>svn
          update</command> and <command>svn merge</command> are the
          names of the full-text files created when a conflict
          happens.  In <xref linkend="svn.tour.cycle.resolve"/>, we saw
          that an update produces files named
          <filename>filename.mine</filename>,
          <filename>filename.rOLDREV</filename>, and
          <filename>filename.rNEWREV</filename>.  When <command>svn
          merge</command> produces a conflict, though, it creates
          three files named <filename>filename.working</filename>,
          <filename>filename.left</filename>, and
          <filename>filename.right</filename>.  In this case, the
          terms <quote>left</quote> and <quote>right</quote> are
          describing which side of the double-tree comparison the file
          came from.  In any case, these differing names will help you
          distinguish between conflicts that happened as a result of an
          update versus ones that happened as a result of a
          merge.</para>

        <para>Altra piccola differenza tra <command>svn update</command> e
          <command>svn merge</command> sono i nomi
          dei file testuali creati quando accade un conflitto.
          Nella <xref linkend="svn.tour.cycle.resolve"/>, abbiamo visto che
          un aggiornamento (update) produce file nominati
          <filename>filename.mine</filename>,
          <filename>filename.rOLDREV</filename> e
          <filename>filename.rNEWREV</filename>.  Quando comando <command>svn
            merge</command> produce un conflitto, ??though?, crea
          tre file nominati <filename>filename.working</filename>,
          <filename>filename.left</filename> e
          <filename>filename.right</filename>.  Qui i
          termini <quote>left</quote> e <quote>right</quote> descrivono
          da quale lato della comparazione delle strutture proviene il file.
          In qualsiasi caso, questi nomi diversi vi aiuteranno
          distinguere tra conflitti che accadono come risultato d'un
          aggiornamento (update) e tali che accadono come risultato d'una
          fusione (merge).</para>

      </sect3>

      <sect3 id="svn.branchmerge.copychanges.bestprac.ancestry">
        <!-- <title>Noticing or Ignoring Ancestry</title> -->
        <title>Notare o ignorare ascendenza</title>

        <para lang="en">When conversing with a Subversion developer, you might
          very likely hear reference to the term
          <firstterm>ancestry</firstterm>.  This word is used to
          describe the relationship between two objects in a
          repository: if they're related to each other, then one
          object is said to be an ancestor of the other.</para>

        <para>Parlando con sviluppatori di Subversion, uno può
          molto probabilmente sentire riferimento al termine
          <firstterm>ascendenza</firstterm>(ancestry).  Questa parola è usata per
          descrivere la relazione tra due oggetti nel deposito:
          se sono in relazione si dice che uno è antenato dell'altro.</para>

        <para lang="en">For example, suppose you commit revision 100, which
          includes a change to a file <filename>foo.c</filename>.
          Then <filename>foo.c@99</filename> is an
          <quote>ancestor</quote> of <filename>foo.c@100</filename>.
          On the other hand, suppose you commit the deletion of
          <filename>foo.c</filename> in revision 101, and then add a
          new file by the same name in revision 102.  In this case,
          <filename>foo.c@99</filename> and
          <filename>foo.c@102</filename> may appear to be related
          (they have the same path), but in fact are completely
          different objects in the repository.  They share no history
          or <quote>ancestry</quote>.</para>

        <para>Per esempio, supponiamo che voi depositate la versione 100,
          che include una modifica a file <filename>foo.c</filename>.
          Dopo questo il file <filename>foo.c@99</filename> è un
          <quote>antenato</quote> di <filename>foo.c@100</filename>.
          Caso oposto, supponiamo che depositate la cancellazione del
          <filename>foo.c</filename> nella versione 101 e dopo aggiugete
          nuovo file con lo stesso nome nella versione 102.  In questo caso,
          <filename>foo.c@99</filename> e
          <filename>foo.c@102</filename> possono apparire in relazione
          (hanno lo stesso percorso e nome), ma in verità sono oggetti
          del deposito completamente diversi. Non condividono nessuna storia
          o <quote>ascendenza</quote>.</para>

        <para lang="en">The reason for bringing this up is to point out an
          important difference between <command>svn diff</command> and
          <command>svn merge</command>.  The former command ignores
          ancestry, while the latter command is quite sensitive to it.
          For example, if you asked <command>svn diff</command> to
          compare revisions 99 and 102 of <filename>foo.c</filename>,
          you would see line-based diffs; the <literal>diff</literal>
          command is blindly comparing two paths.  But if you asked
          <command>svn merge</command> to compare the same two objects,
          it would notice that they're unrelated and first attempt to
          delete the old file, then add the new file;  the output would
          indicate a deletion followed by an add:</para>

        <para>La ragione per spiegare questo è di puntare il dito
          sulla differenza importante tra <command>svn diff</command> e
          <command>svn merge</command>.  Il primo comando ignora
          ascendenza, invece il secondo è assai sensibile ad essa.
          Per esempio, chiedendo a <command>svn diff</command> di
          comparare revisioni 99 e 102 di <filename>foo.c</filename>,
          potete vedere differenze basate sulle linee; il comando
          <literal>diff</literal> ciecamente compara i due file.
          Ma se chiedete a <command>svn merge</command> di comparare
          gli stessi oggetti, lui si accorge che non sono in relazione
          e prima provede a cancellare quello vecchio e poi aggiunge
          nuovo; output indicherà una cancellazione seguita da una aggiunta:</para>

        <screen>
D  foo.c
A  foo.c
</screen>

        <para lang="en">Most merges involve comparing trees that are ancestrally
          related to one another, and therefore <command>svn
          merge</command> defaults to this behavior.  Occasionally,
          however, you may want the <literal>merge</literal> command to
          compare two unrelated trees.  For example, you may have
          imported two source-code trees representing different vendor
          releases of a software project (see <xref
          linkend="svn.advanced.vendorbr"/>).
          If you asked <command>svn merge</command> to compare the two
          trees, you'd see the entire first tree being deleted,
          followed by an add of the entire second tree!</para>

        <para>Molte fusioni coinvolgono comparazioni delle strutture che sono
          genealogicamente relazionate tra loro, e perciò <command>svn
            merge</command> ha come predefinito questo comportamento.  Occasionalmente,
          tuttavia, si può volere che comando <literal>merge</literal> compara
          due strutture che non sono in relazione.  Per esempio, si può importare
          due strutture del codice sorgente che rappresentano due rilasci pubblici
          d'un progetto software (vedi la <xref linkend="svn.advanced.vendorbr"/>).
          Chiedendo a <command>svn merge</command> di comparare queste due strutture,
          si vede prima la cancellazione completta della prima struttura,
          seguita da aggiunta di tutta la seconda struttura!</para>

        <para lang="en">In these situations, you'll want <command>svn
          merge</command> to do a path-based comparison only, ignoring
          any relations between files and directories.  Add the
          <option>--ignore-ancestry</option> option to your merge
          command, and it will behave just like <command>svn
          diff</command>.  (And conversely, the
          <option>--notice-ancestry</option> option will cause
          <command>svn diff</command> to behave like the
          <literal>merge</literal> command.)</para>

        <para>In tali situazioni, si chiede a <command>svn
            merge</command> di fare comparazione basata solo sui nomi, ignorando
          qualsiasi relazione tra i file e cartelle.  Si aggiunge opzione
          <option>--ignore-ancestry</option> al vostro comando di fusione,
          e quello si comporterà esattamente come <command>svn
            diff</command>.  (E al contrario, la opzione
          <option>--notice-ancestry</option> causerà che
          <command>svn diff</command> aggirà come comando
          <literal>merge</literal>.)</para>

      </sect3>

    </sect2>


  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.commonuses">
    <!-- <title>Common Use-Cases</title> -->
    <title>Casi di uso comuni</title>

    <para lang="en">There are many different uses for branching and <command>svn
      merge</command>, and this section describes the most common ones
      you're likely to run into.</para>

    <para>Ci sono molti usi diversi per ramificazione e fusione(<command>svn
        merge</command>) e questa sezione descrive i più comuni tra essi, che
      probabilmente potete incontrare.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.commonuses.wholebr">
      <!-- <title>Merging a Whole Branch to Another</title> -->
      <title>Fondere ramo intero nel altro</title>

      <para lang="en">To complete our running example, we'll move forward in
        time.  Suppose several days have passed, and many changes have
        happened on both the trunk and your private branch.  Suppose
        that you've finished working on your private branch; the
        feature or bug fix is finally complete, and now you want to
        merge all of your branch changes back into the trunk for
        others to enjoy.</para>

      <para>Per complettare nostro esempio in corso, ci moviamo avanti
        nel tempo. Supponiamo che sono passati diversi giorni, e sono
        accadute molte modifiche su tutte e due strutture, il tronco
        e vostro ramo privato.  Supponiamo che avete finito il lavoro
        su vostro ramo privato; nuova caratteristica o riparazione del bug
        è finalmente completta e adesso volete fondere tutte le modifiche
        del vostro ramo dietro tronco, così che gl'altri possono
        assaporarle.</para>

      <para lang="en">So how do we use <command>svn merge</command> in this
        scenario?  Remember that this command compares two trees, and
        applies the differences to a working copy.  So to receive the
        changes, you need to have a working copy of the trunk.  We'll
        assume that either you still have your original one lying
        around (fully updated), or that you recently checked out a
        fresh working copy of <filename>/calc/trunk</filename>.</para>

      <para>Allora, come usiamo <command>svn merge</command> in questo
        scenario?  Ricordate che questo comando compara due strutture ed
        applica le differenze alla copia di lavoro.  Perciò per scoprire
        le modifiche, avete bisogno della copia di lavoro del tronco.
        Assumiamo che o avete ancora quella originale da qualche parte
        (complettamente aggiornata) o che di recente avete tirato fuori
        (checkout) una fresca copia di <filename>/calc/trunk</filename>.</para>

      <para lang="en">But which two trees should be compared?  At first glance,
        the answer may seem obvious: just compare the latest trunk
        tree with your latest branch tree.  But beware&mdash;this
        assumption is <emphasis>wrong</emphasis>, and has burned many
        a new user!  Since <command>svn merge</command> operates like
        <command>svn diff</command>, comparing the latest trunk and
        branch trees will <emphasis>not</emphasis> merely describe
        the set of changes you made to your branch.  Such a comparison
        shows too many changes: it would not only show the addition of
        your branch changes, but also the <emphasis>removal</emphasis>
        of trunk changes that never happened on your branch.</para>

      <para>Ma quale due strutture devono essere comparate?  A primo sguardo,
        la risposta sembra ovvia: comparare l'ultima struttura di tronco
        con l'ultima del ramo.  Ferma!&mdash;questa
        ??assunzione? è <emphasis>sbagliata</emphasis>, e ha bruciato molti
        principianti! Perché <command>svn merge</command> opera come
        <command>svn diff</command>, comparare le ultime strutture
        di tronco e ramo <emphasis>non</emphasis> descriverà soltanto
        l'insieme delle modifiche fatte sul ramo.  Comparazione come questa
        mostra trope modifiche: mostrerebbe non solo le agguinte delle
        vostre modifiche del ramo, ma anche le <emphasis>rimozioni</emphasis>
        delle modifiche del tronco che non sono mai accadute su vostro ramo.</para>

      <para lang="en">To express only the changes that happened on your branch,
        you need to compare the initial state of your branch to its
        final state.  Using <command>svn log</command> on your branch,
        you can see that your branch was created in revision 341.  And
        the final state of your branch is simply a matter of using the
        <literal>HEAD</literal> revision.  That means you want to
        compare revisions 341 and <literal>HEAD</literal> of your
        branch directory, and apply those differences to a working
        copy of the trunk.</para>

      <para>Per scoprire solo le modifiche che son accadute nel vostro ramo,
        dovete comparare lo stato iniziale del ramo con il suo stato finale.
        Usando <command>svn log</command> sul vostro ramo,
        potete vedere che vostro ramo era stato creato nella versione 341.
        E lo stato finale è semplicemente questione di usare la versione
        <literal>HEAD</literal>.  Questo significa che dovete comparare versione
        341 e <literal>HEAD</literal> della cartella del vostro ramo
        e applicare quelle differenze all copia di lavoro del tronco.</para>

      <tip>
        <para lang="en">A nice way of finding the revision in which a branch was
          created (the <quote>base</quote> of the branch) is to use the
          <option>--stop-on-copy</option> option to <command>svn
          log</command>.  The log subcommand will normally show every
          change ever made to the branch, including tracing back
          through the copy which created the branch.  So normally,
          you'll see history from the trunk as well.  The
          <option>--stop-on-copy</option> will halt log output as soon
          as <command>svn log</command> detects that its target was
          copied or renamed.</para>

        <para>Un bel modo per trovare la versione nella quale era stato
          creato un ramo (la <quote>base</quote> del ramo) è usare opzione
          <option>--stop-on-copy</option> nel <command>svn
            log</command>.  Sottocomando log normalmente mostrerà ogni cambiamento
          fatto sul ramo, andando dietro anche prima della copiatura che
          ha creato il ramo. Così normalmente, vedremmo anche la parte della
          storia dal tronco. Lo <option>--stop-on-copy</option> fermerà
          output di log appena <command>svn log</command> scopre che il suo
          bersaglio era copiato o rinominato.</para>

        <para lang="en">So in our continuing example,</para>

        <para>Così nel nostro esempi continuo,</para>

        <screen>
$ svn log --verbose --stop-on-copy \
          http://svn.example.com/repos/calc/branches/my-calc-branch
&hellip;
------------------------------------------------------------------------
r341 | user | 2002-11-03 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)

$
</screen>

        <para lang="en">As expected, the final revision printed by this command
          is the revision in which <filename>my-calc-branch</filename>
          was created by copying.</para>
        <para>Come aspettato, l'ultima versione stampata da questo comando
          è la versione in cui <filename>my-calc-branch</filename>
          era stato creato copiandolo.</para>
      </tip>


      <para lang="en">Here's the final merging procedure, then:</para>
      <para>Qui c'è la procedura di fusione finale, allora:</para>

      <screen lang="en">
$ cd calc/trunk
$ svn update
At revision 405.

$ svn merge -r 341:405 http://svn.example.com/repos/calc/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile

$ svn status
M   integer.c
M   button.c
M   Makefile

# ...examine the diffs, compile, test, etc...

$ svn commit -m "Merged my-calc-branch changes r341:405 into the trunk."
Sending        integer.c
Sending        button.c
Sending        Makefile
Transmitting file data ...
Committed revision 406.
</screen>
<screen>
  $ cd calc/trunk
  $ svn update
  At revision 405.

  $ svn merge -r 341:405 http://svn.example.com/repos/calc/branches/my-calc-branch
  U   integer.c
  U   button.c
  U   Makefile

  $ svn status
  M   integer.c
  M   button.c
  M   Makefile

  # ...esaminare le diff, compilare, testare, ecc...

  $ svn commit -m "Fuso modifiche my-calc-branch r341:405 dentro tronco."
  Sending        integer.c
  Sending        button.c
  Sending        Makefile
  Transmitting file data ...
  Committed revision 406.
</screen>

      <para lang="en">Again, notice that the commit log message very
        specifically mentions the range of changes that was merged
        into the trunk.  Always remember to do this, because it's
        critical information you'll need later on.</para>

      <para>Di nuovo, notare che messaggio di commit menziona molto
        specificamente intervallo delle modifiche che sono state
        fuse nel tronco.  Ricordate sempre di farlo, perché più tardi avrete bisogno
        di questa critica informazione.</para>

      <para lang="en">For example, suppose you decide to keep working on your
        branch for another week, in order to complete an enhancement
        to your original feature or bug fix.  The repository's
        <literal>HEAD</literal> revision is now 480, and you're ready
        to do another merge from your private branch to the trunk.
        But as discussed in <xref linkend="svn.branchmerge.copychanges.bestprac"/>, you
        don't want to merge the changes you've already merged before;
        you only want to merge everything <quote>new</quote> on your
        branch since the last time you merged.  The trick is to figure
        out what's new.</para>

      <para>Per esempio, supponiamo che decidete di proseguire lavoro
        sul vostro ramo per altra settimana, onde complettare un miglioramento
        alla vostra caratteristica o bugfix.  La versione
        <literal>HEAD</literal> del deposito è adesso 480, e voi siete pronti
        a fare altra fusione dal vostro ramo privato al tronco.
        Ma come era discusso nella <xref linkend="svn.branchmerge.copychanges.bestprac"/>,
        non volete fondere le modifiche che avevate già fuso prima; volete solo
        fondere tutto il <quote>nuovo</quote> dal vostro ramo
        a partire dalla ultima fusione.  Il trucco sta nel scoprire che cosa è 'il nuovo'.</para>

      <para lang="en">The first step is to run <command>svn log</command> on the
        trunk, and look for a log message about the last time you
        merged from the branch:</para>

      <para>Il primo passo è avviare <command>svn log</command> su tronco
        e cercare messaggio riguardo l'ultima fusione dal ramo:</para>

      <screen lang="en">
$ cd calc/trunk
$ svn log
&hellip;
------------------------------------------------------------------------
r406 | user | 2004-02-08 11:17:26 -0600 (Sun, 08 Feb 2004) | 1 line

Merged my-calc-branch changes r341:405 into the trunk.
------------------------------------------------------------------------
&hellip;
</screen>
<screen>
  $ cd calc/trunk
  $ svn log
  &hellip;
  ------------------------------------------------------------------------
  r406 | user | 2004-02-08 11:17:26 -0600 (Sun, 08 Feb 2004) | 1 line

  Fuso modifiche my-calc-branch r341:405 dentro tronco.
  ------------------------------------------------------------------------
  &hellip;
</screen>

      <para lang="en">Aha!  Since all branch-changes that happened between
        revisions 341 and 405 were previously merged to the trunk as
        revision 406, you now know that you want to merge only the
        branch changes after that&mdash;by comparing revisions 406 and
        <literal>HEAD</literal>.</para>

      <para>Aha!  Poiché tutte modifiche del ramo che sono state fatte
        tra le versioni 341 e 405 erano già precedentemente fuse nel tronco
        come versione 406, sapete adesso che volete fondere solo cambiamenti
        del ramo fatte dopo&mdash;comparando versioni 406 e <literal>HEAD</literal>.</para>

      <screen lang="en">
$ cd calc/trunk
$ svn update
At revision 480.

# We notice that HEAD is currently 480, so we use it to do the merge:

$ svn merge -r 406:480 http://svn.example.com/repos/calc/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile

$ svn commit -m "Merged my-calc-branch changes r406:480 into the trunk."
Sending        integer.c
Sending        button.c
Sending        Makefile
Transmitting file data ...
Committed revision 481.
</screen>
<screen>
  $ cd calc/trunk
  $ svn update
  At revision 480.

  # Vediamo che HEAD è al momento 480, usiamo questa info per la fusione:

  $ svn merge -r 406:480 http://svn.example.com/repos/calc/branches/my-calc-branch
  U   integer.c
  U   button.c
  U   Makefile

  $ svn commit -m "Fuso modifiche my-calc-branch r406:480 dentro tronco."
  Sending        integer.c
  Sending        button.c
  Sending        Makefile
  Transmitting file data ...
  Committed revision 481.
</screen>

      <para lang="en">Now the trunk contains the complete second wave of changes
        made to the branch.  At this point, you can either delete your
        branch (we'll discuss this later on), or continue working on
        your branch and repeat this procedure for subsequent
        merges.</para>

      <para>Adesso il tronco contiene la completta seconda ondata delle
        modifiche fatte sul ramo. A questo punto, potete o cancellare
        vostro ramo (discutteremmo questo più avanti), o continuare lavoro
        su vostro ramo e ripetere questa procedura con le fusioni
        venture.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.commonuses.undo">
      <!-- <title>Undoing Changes</title> -->
      <title>Disfare i cambiamenti</title>

      <para lang="en">Another common use for <command>svn merge</command> is to
        roll back a change that has already been committed.  Suppose
        you're working away happily on a working copy of
        <filename>/calc/trunk</filename>, and you discover that the
        change made way back in revision 303, which changed
        <filename>integer.c</filename>, is completely wrong.  It never
        should have been committed.  You can use <command>svn
        merge</command> to <quote>undo</quote> the change in your
        working copy, and then commit the local modification to the
        repository.  All you need to do is to specify a
        <emphasis>reverse</emphasis> difference:</para>

      <para>Altro uso comune per <command>svn merge</command> è di
        riavvolgere dietro (disfare) le modifiche che sono state
        già depositate. Supponiamo che state proseguendo beatamente lavori
        sulla copia di lavoro del <filename>/calc/trunk</filename>,
        e avete scoperto che la modifica fatta nella versione 303,
        che ha cambiato <filename>integer.c</filename>, è complettamente
        sbagliata.  Non doveva essere mai depositata. Potete usare
        <command>svn merge</command> per <quote>disfare</quote> la
        modifica nella vostra copia e dopo depositare la modifica locale.
        Tutto di cui avete bisogno è specificare la diffrenza
        <emphasis>rovesciata</emphasis>:</para>


      <screen lang="en">
$ svn merge -r 303:302 http://svn.example.com/repos/calc/trunk
U  integer.c

$ svn status
M  integer.c

$ svn diff
&hellip;
# verify that the change is removed
&hellip;

$ svn commit -m "Undoing change committed in r303."
Sending        integer.c
Transmitting file data .
Committed revision 350.
</screen>
<screen>
  $ svn merge -r 303:302 http://svn.example.com/repos/calc/trunk
  U  integer.c

  $ svn status
  M  integer.c

  $ svn diff
  &hellip;
  # verificare che le modifiche sono state rimosse
  &hellip;

  $ svn commit -m "Disfatte le modifiche pubblicate nella r303."
  Sending        integer.c
  Transmitting file data .
  Committed revision 350.
</screen>

      <para lang="en">One way to think about a repository revision is as a
        specific group of changes (some version control systems call
        these <firstterm>changesets</firstterm>).  By using the
        <option>-r</option> switch, you can ask <command>svn
        merge</command> to apply a changeset, or whole range of
        changesets, to your working copy.  In our case of undoing a
        change, we're asking <command>svn merge</command> to apply
        changeset #303 to our working copy
        <emphasis>backwards</emphasis>.</para>

      <para>Un modo di pensare alle versioni del deposito è
        come allo specifico gruppo delle modifiche (alcuni sistemi di controllo
        delle versioni lo chiamano <firstterm>changeset</firstterm>).
        Usando opzione <option>-r</option> potete chiedere a
        <command>svn merge</command> di applicare un changeset, o tutto intervallo di
        changeset, alla vostra copia di lavoro.  Nel nostro caso di disfare
        cambiamenti, stiamo chiedendo a <command>svn merge</command>
        di applicare changeset nr.303 sulla nostra copia di lavoro
        <emphasis>al rovescio</emphasis>.</para>

      <para lang="en">Keep in mind that rolling back a change like this is just
        like any other <command>svn merge</command> operation, so you
        should use <command>svn status</command> and <command>svn
        diff</command> to confirm that your work is in the state you
        want it to be in, and then use <command>svn commit</command>
        to send the final version to the repository.  After
        committing, this particular changeset is no longer reflected
        in the <literal>HEAD</literal> revision.</para>

      <para>Tenete in mente che disfare (riavvolgere dietro) una modifica
        è come ogni altra operazione <command>svn merge</command>, così
        dovete usare <command>svn status</command> e <command>svn
          diff</command> per confermare che vostro lavoro è nello stato voluto,
        e poi usare <command>svn commit</command> per spedire la versione finale
        al deposito. Dopo deposizione quello particolare changeset non è più
        presente nella versione <literal>HEAD</literal>.</para>

      <para lang="en">Again, you may be thinking: well, that really didn't undo
        the commit, did it?  The change still exists in revision 303.
        If somebody checks out a version of the
        <filename>calc</filename> project between revisions 303 and
        349, they'll still see the bad change, right?</para>

      <para>Di nuovo, potete pensare: Insomma, questo in verità non disfa
        una deposizione, dico bene? La modifica ancora esiste nella versione 303.
        Se qualcuno tira fuori una versione di progetto <filename>calc</filename>
        tra versioni 303 e 349, può ancora vedere la modifica errata, vero?</para>

      <para lang="en">Yes, that's true.  When we talk about
        <quote>removing</quote> a change, we're really talking about
        removing it from <literal>HEAD</literal>.  The original change
        still exists in the repository's history.  For most
        situations, this is good enough.  Most people are only
        interested in tracking the <literal>HEAD</literal> of a
        project anyway.  There are special cases, however, where you
        really might want to destroy all evidence of the commit.
        (Perhaps somebody accidentally committed a confidential
        document.)  This isn't so easy, it turns out, because
        Subversion was deliberately designed to never lose
        information.  Revisions are immutable trees which build upon
        one another.  Removing a revision from history would cause a
        domino effect, creating chaos in all subsequent revisions and
        possibly invalidating all working copies.
        <footnote>
          <para>The Subversion project has plans, however, to someday
            implement an <command>svnadmin obliterate</command>
            command that would accomplish the task of permanently
            deleting information.  In the meantime, see <xref
            linkend="svn.reposadmin.maint.tk.svndumpfilter"/> for a possible
            workaround.</para>
        </footnote>
      </para>

      <para>Sì, questo è vero.  Quando abbiamo parlato di
        <quote>rimuovere</quote> una modifica, in verità abbiamo parlato
        di rimuoverla dalla versione <literal>HEAD</literal>.
        Il cambiamento originale ancora esiste nella storia del deposito.
        Per la maggioranza delle situazioni questo basta. Tanto, molte persone
        sono interessate solo di usare <literal>HEAD</literal> del progetto.
        Ci sono, comunque, casi speciali, in cui veramente volete distruggere
        ogni traccia della deposizione avvenuta. (Magari qualcuno ha
        accidentalmente pubblicato un documento riservato.)
        Si scopre che non è così facile, perché Subversion era stato
        volutamente disegnato per non perdere mai le informazioni.
        Versioni sono strutture ad albero immutabili basati una sull'altra.
        Togliendo una revisione dalla storia può causare un effetto domino,
        creando chaos in tutte le subsequenti versioni e possibilmente
        invalidare tutte le copie di lavoro.
        <footnote>
          <para>Progetto Subversion pianifica tuttavia di implementare
            un giorno il comando <command>svnadmin obliterate</command>
            che può accontentare una richiesta della cancellazione
            permanente. Ma prima ciò accada, vedi la
            <xref linkend="svn.reposadmin.maint.tk.svndumpfilter"/>
            per possibile raggiro.</para>
        </footnote>
      </para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.commonuses.resurrect">
      <!-- <title>Resurrecting Deleted Items</title> -->
      <title>Risuscitare elementi cancellati</title>

      <para lang="en">The great thing about version control systems is that
        information is never lost.  Even when you delete a file or
        directory, it may be gone from the <literal>HEAD</literal>
        revision, but the object still exists in earlier revisions.
        One of the most common questions new users ask is, <quote>How
        do I get my old file or directory back?</quote>.</para>

     <para>La cosa grande nei sistemi di controllo delle versioni è
       che la informazione non si perde mai.  Addirittura quando cancellate
       un file o cartella, può sparire dalla versione <literal>HEAD</literal>,
       ma l'elemento sempre esiste nelle versioni precedenti.
       Una delle più comuni domande degli nuovi utenti è <quote>Come posso
       riavere mio vecchio file o cartella?</quote>.</para>

      <para lang="en">The first step is to define exactly <emphasis
        role="bold">which</emphasis> item you're trying to resurrect.
        Here's a useful metaphor: you can think of every object in the
        repository as existing in a sort of two-dimensional coordinate
        system.  The first coordinate is a particular revision tree,
        and the second coordinate is a path within that tree.  So
        every version of your file or directory can be defined by a
        specific coordinate pair.</para>

      <para>Il primo passo è di definire precisamente <emphasis
        role="bold">quale</emphasis> elemento state provando di
        risuscitare. Qui c'è una utile metafora: potete pensare
        ad ogni oggetto del deposito come essistesse in una sorta
        di spazio bidimensionale. La prima coordinata è la particolare
        versione e la seconda è il percorso e nome dentro questa versione.
        Così ogni versione del vostro file o cartella può essere
        definita da una copia di coordinate specifica.</para>

      <para lang="en">Subversion has no <filename>Attic</filename> directory
        like CVS does,
        <footnote>
          <para>Because CVS doesn't version trees, it creates an
            <filename>Attic</filename> area within each repository
            directory as a way of remembering deleted files.</para>
        </footnote>
        so you need to use <command>svn
        log</command> to discover the exact coordinate pair you wish
        to resurrect.  A good strategy is to run <command>svn log
        --verbose</command> in a directory which used to contain your
        deleted item.  The <option>--verbose</option> option shows a
        list of all changed items in each revision; all you need to do
        is find the revision in which you deleted the file or
        directory.  You can do this visually, or by using another tool
        to examine the log output (via <command>grep</command>, or
        perhaps via an incremental search in an editor).</para>

      <para>Subversion no ha cartella <filename>Attic</filename>
        come la tiene CVS,
        <footnote>
          <para>Perché CVS non fa le versioni delle strutture, crea una
            area <filename>Attic</filename> in ogni cartella del deposito
            come modo di ricordare i file cancellati.</para>
        </footnote>
        e perciò dovete usare <command>svn log</command> per scoprire
        la copia esatta di coordinate del elemento da risuscitare.
        Una strategia buona è di avviare <command>svn log --verbose</command>
        nella cartella che abitulamente conteneva vostro elemento cancellato.
        La opzione <option>--verbose</option> mostra la lista di tutte le
        modifiche in ogni versione; tutto di cui avete bisogno è trovare
        versione in cui l'elemento era stato cancellato. Potete farlo a vista
        o usando qualche strumento per essaminare output di log
        (tramite <command>grep</command>, o forse con una ricerca incrementale
        in un editore).</para>

      <screen lang="en">
$ cd parent-dir
$ svn log --verbose
&hellip;
------------------------------------------------------------------------
r808 | joe | 2003-12-26 14:29:40 -0600 (Fri, 26 Dec 2003) | 3 lines
Changed paths:
   D /calc/trunk/real.c
   M /calc/trunk/integer.c

Added fast fourier transform functions to integer.c.
Removed real.c because code now in double.c.
&hellip;
</screen>
<screen>
  $ cd parent-dir
  $ svn log --verbose
  &hellip;
  ------------------------------------------------------------------------
  r808 | joe | 2003-12-26 14:29:40 -0600 (Fri, 26 Dec 2003) | 3 lines
  Changed paths:
  D /calc/trunk/real.c
  M /calc/trunk/integer.c

  Aggiunta la funzione di trasformazione Fourier veloce a integer.c.
  Rimosso real.c perché il codice è adesso in double.c.
  &hellip;
</screen>

      <para lang="en">In the example, we're assuming that you're looking for a
        deleted file <filename>real.c</filename>.  By looking through
        the logs of a parent directory, you've spotted that this file
        was deleted in revision 808.  Therefore, the last version of
        the file to exist was in the revision right before that.
        Conclusion: you want to resurrect the path
        <filename>/calc/trunk/real.c</filename> from revision
        807.</para>

      <para>Nel esempio abbiamo assunto che state cercando file cancellato
        <filename>real.c</filename>.  Scorrendo tra log della sua
        cartella parente, avete scoperto che questo file era stato cancellato
        nella versione 808. In consequenza, l'ultima versione che lo
        contiene è quella subito prima. Conclusione: dovete risuscitare
        <filename>/calc/trunk/real.c</filename> della versione
        807.</para>

      <para lang="en">That was the hard part&mdash;the research.  Now that you
        know what you want to restore, you have two different
        choices.</para>

      <para>Quella era la parte dura&mdash;la ricerca.  Adesso che sappiamo
        che cosa riprendere, abbiamo due diverse scelte.</para>

      <para lang="en">One option is to use <command>svn merge</command> to apply
        revision 808 <quote>in reverse</quote>.  (We've already
        discussed how to undo changes, see <xref
        linkend="svn.branchmerge.commonuses.undo"/>.)  This would have the effect of
        re-adding <filename>real.c</filename> as a local modification.
        The file would be scheduled for addition, and after a commit,
        the file would again exist in <literal>HEAD</literal>.</para>

      <para>Una opzione è usare <command>svn merge</command> per applicare
        versione 808 <quote>al rovescio</quote>.  (Abbiamo già discusso
        come disfare le modifiche, vedi <xref
        linkend="svn.branchmerge.commonuses.undo"/>.)  Questo potrebbe
        avere effetto di ri-aggiungere <filename>real.c</filename>
        come una modifica locale. Il file sarà pianificato per aggiunta
        e dopo deposizione essisterà di nuovo nel <literal>HEAD</literal>.</para>

      <para lang="en">In this particular example, however, this is probably not
        the best strategy.  Reverse-applying revision 808 would not
        only schedule <filename>real.c</filename> for addition, but
        the log message indicates that it would also undo certain
        changes to <filename>integer.c</filename>, which you don't
        want.  Certainly, you could reverse-merge revision 808 and
        then <command>svn revert</command> the local modifications to
        <filename>integer.c</filename>, but this technique doesn't
        scale well.  What if there were 90 files changed in revision
        808?</para>

      <para>In questo esempio particolare, ??however?, questa probabilmente
        non è la strategia migliore.  Applicazione al rovescio
        della versione 808 non solo pianificherà <filename>real.c</filename>
        per aggiunta, ma il messagio di log indica che disfarà anche
        certe modifiche del file <filename>integer.c</filename>, ciò che
        non vogliamo.  Naturalmente, potete fare fusione al rovescio
        di versione 808 e dopo disfare modifiche locali del file
        <filename>integer.c</filename> con <command>svn revert</command>,
        ma questa tecnica non si adatta bene al aumento del lavoro.
        Cosa fare se ci fossero 90 file modificati nella versione 808?</para>

      <para lang="en">A second, more targeted strategy is not to use
        <command>svn merge</command> at all, but rather the
        <command>svn copy</command> command.  Simply copy the exact
        revision and path <quote>coordinate pair</quote> from the
        repository to your working copy:</para>

      <para>Una seconda strategia, più mirata, è di non usare del tutto
        <command>svn merge</command>, ma invece il comando
        <command>svn copy</command>.  Semplicemete copiate esatte
        <quote>coordinate</quote> (revisone e percorso-nome)
        dal deposito alla vostra copia di lavoro:</para>

      <screen lang="en">
$ svn copy --revision 807 \
           http://svn.example.com/repos/calc/trunk/real.c ./real.c

$ svn status
A  +   real.c

$ svn commit -m "Resurrected real.c from revision 807, /calc/trunk/real.c."
Adding         real.c
Transmitting file data .
Committed revision 1390.
</screen>
<screen>
$ svn copy --revision 807 \
           http://svn.example.com/repos/calc/trunk/real.c ./real.c

$ svn status
A  +   real.c

$ svn commit -m "Risuscitato real.c dalla versione 807, /calc/trunk/real.c."
Adding         real.c
Transmitting file data .
Committed revision 1390.
</screen>

      <para lang="en">The plus sign in the status output indicates that the item
        isn't merely scheduled for addition, but scheduled for
        addition <quote>with history</quote>.  Subversion remembers
        where it was copied from.  In the future, running <command>svn
        log</command> on this file will traverse back through the
        file's resurrection and through all the history it had prior
        to revision 807.  In other words, this new
        <filename>real.c</filename> isn't really new; it's a direct
        descendant of the original, deleted file.</para>

      <para>Il segno più nel output di status indica che l'elemento
        non è solo pianificato per aggiunta, ma per aggiunta
        <quote>con storico</quote>.  Subversion si ricorda
        da dove era stato copiato.  In futuro, usando <command>svn
          log</command> su di questo file attraversiammo dietro la sua
        resurrezione e vedremmo tutta la sua storia che aveva prima della versione
        807.  In altre parole, questo nuovo
        <filename>real.c</filename> non è veramente nuovo; è un discendente
        diretto del file originale cancellato.</para>

      <para lang="en">Although our example shows us resurrecting a file, note
        that these same techniques work just as well for resurrecting
        deleted directories.</para>

      <para>Nonostante nostro esempio ci mostra resurrezione di un file, notare
        che la stessa tecnica serve anche per resurrezione delle cartelle
        cancellate.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.commonuses.patterns">
      <!-- <title>Common Branching Patterns</title> -->
      <title>Tipi comuni di ramificazione</title>

      <para lang="en">Version control is most often used for software
        development, so here's a quick peek at two of the most common
        branching/merging patterns used by teams of programmers.  If
        you're not using Subversion for software development, feel
        free to skip this section.  If you're a software developer
        using version control for the first time, pay close attention,
        as these patterns are often considered best practices by
        experienced folk.  These processes aren't specific to
        Subversion; they're applicable to any version control system.
        Still, it may help to see them described in Subversion
        terms.</para>

      <para>Controllo delle versioni è molto spesso usato per sviluppo
        del software, così abbiamo qui una veloce sbirciatina di due più comuni
        archetipi di ramificazione usati dai team di programmatori.
        Se non usate Subversion per sviluppo di software, sentitevi liberi
        di saltare questa sezione.[alternativa: Se non
        è il vostro caso, potete tranquilmente saltare questa sezione.]
        Se siete sviluppatore di software alle prime armi con l'uso di
        controllo delle versioni, prestate molta attenzione,
        perché questi archetipi sono spesso considerati regola d'arte
        dalla gente esperta.
        Queste procedure non sono specifiche di Subversion; sono applicabili
        a qualsiasi sistema di controllo delle versioni. Tuttavia,
        può essere d'aiuto vederle descritte in termini di Subversion.</para>

      <sect3 id="svn.branchmerge.commonuses.patterns.release">
        <!-- <title>Release Branches</title> -->
        <title>Rami di rilascio</title>

        <para lang="en">Most software has a typical lifecycle: code, test,
          release, repeat.  There are two problems with this process.
          First, developers need to keep writing new features while
          quality-assurance teams take time to test supposedly-stable
          versions of the software.  New work cannot halt while the
          software is tested.  Second, the team almost always needs to
          support older, released versions of software; if a bug is
          discovered in the latest code, it most likely exists in
          released versions as well, and customers will want to get
          that bugfix without having to wait for a major new
          release.</para>

        <para>Molti software hanno un tipico ciclo di vita: scrittura, test,
          rilascio; ripetere.  Ci sono due problemi con questo processo.
          Prima, sviluppatori devono continuare a scrivere nuove funzioni
          mentre i team di controllo di qualità prendono tempo per testare
          presunte stabili versioni del software.  Nuovo lavoro non si può
          fermare mentre si fanno i test. Secondo, il team quasi sempre
          deve fornire supporto per vecchie, già rilasciate versioni del
          software; quando si scopre un errore nel codice nuovo, con
          molta probabilità esiste anche nelle versioni rilasciate
          e i clienti vogliono avere questi bug risolti senza aspettare
          rilascio della nuova versione.</para>

        <para lang="en">Here's where version control can help.  The typical
          procedure looks like this:</para>

        <para>Ed è qui che controllo delle versioni può aiutare. La tipica procedura
          assomiglia a questo:</para>

      <itemizedlist>

        <listitem>
          <para lang="en"><emphasis>Developers commit all new work to the
                trunk.</emphasis>

              Day-to-day changes are committed to
              <filename>/trunk</filename>: new features, bugfixes, and
              so on.</para>
            <para><emphasis>Sviluppatori fanno commit di tutto lavoro nuovo
                nel tronco.</emphasis>

              Giorno dopo giorno modifiche sono pubblicate nel
              <filename>/trunk</filename>: nuove capacità, fix dei bug e così
              via.</para>
        </listitem>

        <listitem>
          <para lang="en"><emphasis>The trunk is copied to a
                <quote>release</quote> branch.</emphasis>

              When the team thinks the software is ready for release
              (say, a 1.0 release), then <filename>/trunk</filename>
              might be copied to
              <filename>/branches/1.0</filename>.</para>
          <para><emphasis>Il tronco è copiato nel ramo
              <quote>rilascio</quote>.</emphasis>

            Quando il team pensa che il software è pronto per rilascio
            (diciamo, una vers. 1.0), il <filename>/trunk</filename>
            può essere copiato su <filename>/branches/1.0</filename>.</para>
        </listitem>

        <listitem>
          <para lang="en"><emphasis>Teams continue to work in parallel.</emphasis>

              One team begins rigorous testing of the release branch,
              while another team continues new work (say, for version
              2.0) on <filename>/trunk</filename>.  If bugs are
              discovered in either location, fixes are ported back and
              forth as necessary.  At some point, however, even that
              process stops.  The branch is <quote>frozen</quote> for
              final testing right before a release.</para>
         <para><emphasis>I team continuarono lavorare in parallelo.</emphasis>

              Un team comincia rigorosi test del ramo rilascio,
              mentre altro team continua nuovo lavoro (diciamo per la versione
              2.0) su <filename>/trunk</filename>.  Quando si scoprono i bug
              in entrambi locazioni, correzioni sono portate avanti e dietro
              secondo la necessità.  Ad un certo punto, comunque, anche questo
              processo si ferma.  Il ramo è <quote>congelato</quote> per
              test finale subito prima del rilascio.</para>
        </listitem>

        <listitem>
          <para lang="en"><emphasis>The branch is tagged and released.</emphasis>

              When testing is complete,
              <filename>/branches/1.0</filename> is copied to
              <filename>/tags/1.0.0</filename> as a reference
              snapshot.  The tag is packaged and released to
              customers.</para>
         <para><emphasis>Il ramo è targato e rilasciato.</emphasis>

              Quando i test sono completati,
              <filename>/branches/1.0</filename> è copiato su
              <filename>/tags/1.0.0</filename> come instantanea di riferimento.
              Ramo targato è impachettato e rilasciato ai clienti.</para>
        </listitem>

        <listitem>
          <para lang="en"><emphasis>The branch is maintained over time.</emphasis>

              While work continues on <filename>/trunk</filename> for
              version 2.0, bugfixes continue to be ported from
              <filename>/trunk</filename> to
              <filename>/branches/1.0</filename>.  When enough
              bugfixes have accumulated, management may decide to do a
              1.0.1 release: <filename>/branches/1.0</filename> is
              copied to <filename>/tags/1.0.1</filename>, and the tag
              is packaged and released.</para>
            <para><emphasis>Il ramo è mantenuto durante il tempo.</emphasis>

              Mentre lavoro continua su <filename>/trunk</filename> per
              la versione 2.0, i bugfix continuano ad essere portati da
              <filename>/trunk</filename> a
              <filename>/branches/1.0</filename>.  Quando si accumulano abbastanza
              correzioni, i capi possono decidere di rilasciare
              vers. 1.0.1: <filename>/branches/1.0</filename> è
              copiato su <filename>/tags/1.0.1</filename>, la targa
              è impachettata e rilasciata.</para>
        </listitem>

        </itemizedlist>

        <para lang="en">This entire process repeats as the software matures:
          when the 2.0 work is complete, a new 2.0 release branch is
          created, tested, tagged, and eventually released.  After
          some years, the repository ends up with a number of release
          branches in <quote>maintenance</quote> mode, and a number
          of tags representing final shipped versions.</para>

        <para>L'intero processo si ripete quando il software matura:
          quando lavoro 2.0 è completo, è creato nuovo ramo di rilascio 2.0,
          testato, targato e alla fine rilasciato. Dopo alcuni anni il
          deposito finisce con certo numero di rami di rilascio in stato di
          <quote>mantenimento</quote> e certo numero di targhe che rappresentano
          le versioni finali spedite.</para>

      </sect3>

      <sect3 id="svn.branchmerge.commonuses.patterns.feature">
        <!-- <title>Feature Branches</title> -->
        <title>Rami di 'caratteristica'</title>

        <para lang="en">A <firstterm>feature branch</firstterm> is the sort of
          branch that's been the dominant example in this chapter, the
          one you've been working on while Sally continues to work on
          <filename>/trunk</filename>.  It's a temporary branch
          created to work on a complex change without interfering with
          the stability of <filename>/trunk</filename>.  Unlike
          release branches (which may need to be supported forever),
          feature branches are born, used for a while, merged back to
          the trunk, then ultimately deleted.  They have a finite span
          of usefulness.</para>

        <para>Un <firstterm>ramo di caratteristica</firstterm> è il tipo di ramo
          che era esempio dominante in questo capitolo, quello su quale
          voi avete lavorato mentre Sally continuava lavorare su
          <filename>/trunk</filename>.  È un ramo temporaneo
          creato per lavorare su una modifica complessa senza interferire con
          la stabilità di <filename>/trunk</filename>.  A differenza di
          rami di rilascio (che possono avere bisogno di supporto
          per sempre<footnote>
            <para>Ndt. 'per sempre' mi sempre parola tropo grossa, il team
              può anche decidere e rendere noto
              diciamo dopo rilascio di versione 8.0 che a partire
              da 1 genaio del anno venturo cesserà il supporto per
              la versione 3.0 e precedenti. Già successo su molti software
              di grandi nomi. Poi le targhe 1.0, 2.0 e 3.0 possono essere
              cancellate dal deposito.)
            </para>
          </footnote>),
          rami di caratteristica nascono, sono ussati per un po', fusi dietro il
          tronco e infine cancellati.  Hanno un arco di vita utile limitato.</para>

        <para lang="en">Again, project policies vary widely concerning exactly
          when it's appropriate to create a feature branch.  Some
          projects never use feature branches at all: commits to
          <filename>/trunk</filename> are a free-for-all.  The
          advantage to this system is that it's simple&mdash;nobody
          needs to learn about branching or merging.  The disadvantage
          is that the trunk code is often unstable or unusable.  Other
          projects use branches to an extreme: no change is
          <emphasis>ever</emphasis> committed to the trunk directly.
          Even the most trivial changes are created on a short-lived
          branch, carefully reviewed and merged to the trunk.  Then
          the branch is deleted.  This system guarantees an
          exceptionally stable and usable trunk at all times, but at
          the cost of tremendous process overhead.</para>

        <para>Di nuovo, le regole del progetto variano largamente
          riguardo esattamente quando è appropriato create un ramo di
          caratteristica. Alcuni progetti non usano questi rami per niente:
          depositare (commit) su <filename>/trunk</filename> è libero
          per tutti. Vantaggio di questo sistema è la
          semplicità&mdash;nessuno deve imparare ramificazione e fusione.
          Svantaggio è che contenuto fresco del tronco (HEAD) è spesso
          instabile o non usabile. Altri progetti ramificano ad estremo:
          nessuna modifica è <emphasis>mai</emphasis> pubblicata su tronco
          direttamente. Anche la modifica più triviale è creata su ramo
          a vita breve, revisionata con cura e solo dopo fusa al tronco.
          Dopo quel ramo 'monouso' è cancellato. Questo sistema garantisce
          tronco eccezionalmente stabile e usabile in ogni momento, ma al costo di
          tremendo sovracarico del processo di sviluppo.</para>

        <para lang="en">Most projects take a middle-of-the-road approach.  They
          commonly insist that <filename>/trunk</filename> compile and
          pass regression tests at all times.  A feature branch is
          only required when a change requires a large number of
          destabilizing commits.  A good rule of thumb is to ask this
          question: if the developer worked for days in isolation and
          then committed the large change all at once (so that
          <filename>/trunk</filename> were never destabilized), would
          it be too large a change to review?  If the answer to that
          question is <quote>yes</quote>, then the change should be
          developed on a feature branch.  As the developer commits
          incremental changes to the branch, they can be easily
          reviewed by peers.</para>

        <para>Molti progetti addottano approccio 'via di mezzo'.  Comunemente
          insistono che <filename>/trunk</filename> si può compilare e
          passa tutti i test in ogni momento. Un ramo di caratteristica
          è richiesto solo quando modifica porta grande numero di commit
          destabilizzanti. Buona regola ferrea è di rispondere
          a questa domanda: se il sviluppatore lavora per giorni in isolamento
          e dopo pubblica larga modifica tutta in un colpo
          (così che <filename>/trunk</filename> non sarà mai destabilizzato),
          la modifica non sarebbe tropo grande per revisionare?  Se la risposta
          a questa domanda è di <quote>sì</quote>, allora le modifiche
          devono essere sviluppate in un ramo di caratteristica.
          Man mano che il sviluppatore pubblica modifiche incrementali
          sul ramo, queste possono essere facilmente revisionate dai
          collaboratori.</para>

        <para lang="en">Finally, there's the issue of how to best keep a feature
          branch in <quote>sync</quote> with the trunk as work
          progresses.  As we mentioned earlier, there's a great risk
          to working on a branch for weeks or months; trunk changes
          may continue to pour in, to the point where the two lines of
          development differ so greatly that it may become a nightmare
          trying to merge the branch back to the trunk.</para>

        <para>All fine, c'è anche la questione come meglio tenere un ramo
          di caratteristica in <quote>sincronia</quote> col tronco man mano
          che lavoro procede.  Abbiamo menzionato prima, c'è un grande rischio
          di lavorare su un ramo per settimane o mesi; modifiche continuano
          confluire anche al tronco, al punto che le due linee di sviluppo
          differiscono così tanto che può essere un incubo provare di fondere
          ramo dentro il tronco.</para>

        <para lang="en">This situation is best avoided by regularly merging
          trunk changes to the branch.  Make up a policy: once a week,
          merge the last week's worth of trunk changes to the branch.
          Take care when doing this; the merging needs to be
          hand-tracked to avoid the problem of repeated merges (as
          described in <xref linkend="svn.branchmerge.copychanges.bestprac.track"/>).  You'll
          need to write careful log messages detailing exactly which
          revision ranges have been merged already (as
          demonstrated in <xref linkend="svn.branchmerge.commonuses.wholebr"/>).  It
          may sound intimidating, but it's actually pretty easy to
          do.</para>

        <para>Questa situazione si può evitare meglio con regolare
          fusione delle modifiche del tronco dentro il ramo. Stabilite una regola:
          una volta alla settimana fondere ultime modifiche del tronco dentro il ramo.
          Prestate attenzione facendo questo; la fusione deve essere documentata
          a mano per evitare il problema delle fusioni ripetute (come descritto
          nella <xref linkend="svn.branchmerge.copychanges.bestprac.track"/>).
          Dovete scrivere con cura messaggi di merge con esatti dettagli di
          quale intervallo di versioni era stato già fuso (come dimostrato nella
          <xref linkend="svn.branchmerge.commonuses.wholebr"/>).  Può sembrare
          spaventoso, ma in verità è abbastanza semplice da fare.</para>

        <para lang="en">At some point, you'll be ready to merge the
          <quote>synchronized</quote> feature branch back to the
          trunk.  To do this, begin by doing a final merge of the
          latest trunk changes to the branch.  When that's done, the
          latest versions of branch and trunk will be absolutely
          identical except for your branch changes.  So in this
          special case, you would merge by comparing the branch with
          the trunk:</para>

        <para>Ad un certo punto, sarete pronti per fondere il vostro
          ramo di caratteristica <quote>sincronizato</quote> dietro nel
          tronco.  Per fare questo, cominciate facendo fusione finale
          delle ultime modifiche del tronco dentro vostro ramo.
          Qundo sarà fatto, le ultime versioni del ramo e del tronco
          saranno identiche, eccezion fatta per le vostre modifiche
          del ramo. Così in questo caso speciale, potete fondere
          comparando il ramo con il tronco:</para>

        <screen>
$ cd trunk-working-copy

$ svn update
At revision 1910.

$ svn merge http://svn.example.com/repos/calc/trunk@1910 \
            http://svn.example.com/repos/calc/branches/mybranch@1910
U  real.c
U  integer.c
A  newdirectory
A  newdirectory/newfile
&hellip;
</screen>

        <para lang="en">By comparing the <literal>HEAD</literal> revision of the
          trunk with the <literal>HEAD</literal> revision of the
          branch, you're defining a delta that describes only the
          changes you made to the branch; both lines of development
          already have all of the trunk changes.</para>

        <para>Comparando versione <literal>HEAD</literal> del tronco
          con la versione <literal>HEAD</literal> del ramo, avete definito
          un delta che descrive solo le modifiche che avete fatto sul ramo;
          tutte e due linee dello sviluppo già hanno le modifiche del tronco.</para>

        <para lang="en">Another way of thinking about this pattern is that your
          weekly sync of trunk to branch is analogous to running
          <command>svn update</command> in a working copy, while the
          final merge step is analogous to running <command>svn
          commit</command> from a working copy.  After all, what else
          <emphasis>is</emphasis> a working copy but a very shallow
          private branch?  It's a branch that's only capable of
          storing one change at a time.</para>

        <para>Altro modo di pensare di questo archetipo è che la sincronizzazione
          settimanale del tronco sul ramo è analoga a
          <command>svn update</command> sulla copia di lavoro, mentre
          il passo di fusione finale è analogo a <command>svn commit</command>
          dalla copia di lavoro. Doppo tutto, che altro <emphasis>è</emphasis>
          una copia di lavoro se non un ramo privato pocco capiente.
          Un ramo capace di contenere solo una modifica alla volta.</para>
<!-- proofread stopflag, need to be visible -->
<para>Proofread stopflag #$#$#$#$#$#</para>
      </sect3>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.switchwc">
    <!-- <title>Switching a Working Copy</title> -->
    <title>Cambiare una copia di lavoro</title>

    <para lang="en">The <command>svn switch</command> command transforms an
      existing working copy into a different branch.  While this
      command isn't strictly necessary for working with branches, it
      provides a nice shortcut to users.  In our earlier example,
      after creating your private branch, you checked out a fresh
      working copy of the new repository directory.  Instead, you can
      simply ask Subversion to change your working copy of
      <filename>/calc/trunk</filename> to mirror the new branch
      location:</para>

    <para>Il comando <command>svn switch</command> trasforma una
      copia di lavoro esistente in modo da riflettere diverso ramo.  Anche se
      questo comando non è strettamente necessario per lavorare con
      i rami, fornisce ai utenti una bella scorciatoia. In uno dei primi esempi
      dopo aver creato vostro privato ramo, avete tirato fuori (check out)
      una fresca copia della nuova cartella del deposito. Invece,
      potete semplicemente chiedere a Subversion di cambiare vostra
      copia di lavoro del <filename>/calc/trunk</filename> per riflettere
      nuovo ramo:</para>

    <screen>
$ cd calc

$ svn info | grep URL
URL: http://svn.example.com/repos/calc/trunk

$ svn switch http://svn.example.com/repos/calc/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile
Updated to revision 341.

$ svn info | grep URL
URL: http://svn.example.com/repos/calc/branches/my-calc-branch
</screen>

    <para lang="en">After <quote>switching</quote> to the branch, your working
      copy is no different than what you would get from doing a fresh
      checkout of the directory.  And it's usually more efficient to
      use this command, because often branches only differ by a small
      degree.  The server sends only the minimal set of changes
      necessary to make your working copy reflect the branch
      directory.</para>

    <para>Dopo <quote>switching</quote> [cerco una traduzione calzante]
      al ramo, vostra copia di lavoro
      non è diversa da tale che potevate ottenere facendo checkout fresco fresco
      della cartella. E molte volte è anche più efficace di usare questo comando,
      perche spesso rami differiscono di piccolo grado. Il server manda
      solo un insieme minimo delle modifiche necessari per allineare
      vostra copia di lavoro con la cartella del ramo.</para>

    <para lang="en">The <command>svn switch</command> command also takes a
      <option>--revision</option> (<option>-r</option>) option, so you
      need not always move your working copy to the <quote>tip</quote>
      of the branch.</para>

    <para>Il comando <command>svn switch</command> prende anche una opzione
      <option>--revision</option> (<option>-r</option>), so you
      need not always move your working copy to the <quote>tip</quote>
      of the branch.</para>

    <para lang="en">Of course, most projects are more complicated than our
      <filename>calc</filename> example, containing multiple
      subdirectories.  Subversion users often follow a specific
      algorithm when using branches:</para>

    <para>Certo, molti progetti sono più complicati di nostro esempio
      <filename>calc</filename>, contendo sottocartelle multiple.
      Utenti di Subversion spesso seguono un algoritmo specifico
      quando usano i rami:</para>

      <orderedlist>
        <listitem>
          <para lang="en">Copy the project's entire <quote>trunk</quote> to a
            new branch directory.</para>
          <para>Copiare tutto il <quote>trunk</quote> del progetto
            nella cartella del nuovo ramo.</para>
        </listitem>
        <listitem>
          <para lang="en">Switch only <emphasis>part</emphasis> of the trunk
            working copy to mirror the branch.</para>
          <para>Cambiare(switch) solo <emphasis>una parte</emphasis> della
            copia di lavoro del tronco per rispechiare il ramo.</para>
        </listitem>
      </orderedlist>

    <para lang="en">In other words, if a user knows that the branch-work only
      needs to happen on a specific subdirectory, they use
      <command>svn switch</command> to move only that subdirectory to
      the branch.  (Or sometimes users will switch just a single
      working file to the branch!)  That way, they can continue to
      receive normal <quote>trunk</quote> updates to most of their
      working copy, but the switched portions will remain immune
      (unless someone commits a change to their branch).  This feature
      adds a whole new dimension to the concept of a <quote>mixed
      working copy</quote>&mdash;not only can working copies contain a
      mixture of working revisions, but a mixture of repository
      locations as well.</para>

    <para>In altre parole, se un utente sa che lavoro sul ramo
      è neccessario solo in una specifica sottocartella, usa
      <command>svn switch</command> per spostare solo quella
      sottocartella sul ramo.  (O qualche volta utenti cambiano(switch)
      solo un file di lavoro sul ramo!)  In quel modo, continuano a
      ricevere normali aggiornamenti del <quote>trunk</quote>
      per maggior parte della loro copia di lavoro, ma la parte
      ??switchata? :) rimarrà imune (finché qualcuno non deposita
      cambiamenti su loro raomo).  Questa caratteristica aggiunge completamente
      nuova dimensione al concetto di <quote>copia di lavoro
      mista</quote>&mdash;mom solo la copia di lavoro può contenere
      una miscella delle revisioni, ma con la stessa facilità anche
      miscella delle locazioni del deposito.</para>

    <para lang="en">If your working copy contains a number of switched subtrees
      from different repository locations, it continues to function as
      normal.  When you update, you'll receive patches to each subtree
      as appropriate.  When you commit, your local changes will still
      be applied as a single, atomic change to the repository.</para>

    <para>Nonostante vostra copia di lavoro contiene una quantità delle
      sottostrutture alternate da diversi posti del deposito, continua
      funzionare normalmente.  Durante aggiornamenti riceve modifiche
      per ogni sottostruttura dal posto giusto. Quando depositate, vostre
      modifiche locali sono ancora applicate come una singola, atomica
      modifica del deposito.</para>

    <para lang="en">Note that while it's okay for your working copy to reflect a
      mixture of repository locations, these locations must all be
      within the <emphasis>same</emphasis> repository.  Subversion
      repositories aren't yet able to communicate with one another;
      that's a feature planned beyond Subversion
      1.0.<footnote><para>You <emphasis>can</emphasis>, however, use
      <command>svn switch</command> with the
      <option>--relocate</option> switch if the URL of your server
      changes and you don't want to abandon an existing working copy.
      See the <command>svn switch</command> section in <xref
      linkend="svn.ref"/> for more information and an example.</para>
      </footnote></para>

    <para>Da notare: anche se è consentito alla vostra copia di lavoro
      di riflettere miscella dei posti del deposito, questi posti
      devono tutti provenire dal <emphasis>unico</emphasis> deposito.
      I depositi di Subversion non sono ancora capaci di communicare
      tra loro; questa caratteristica è pianificata oltre
      Subversion 1.0.<footnote><para><emphasis>Potete</emphasis>, comunque,
      usare <command>svn switch</command> con la opzione
      <option>--relocate</option> se URL del vostro server cambia e
      voi non volete abbandonare una copia di lavoro esistente.
      Vedi sezione <command>svn switch</command> in <xref
      linkend="svn.ref"/> per avere più informazioni e un esempio.</para>
      </footnote></para>

    <sidebar>
      <!-- <title>Switches and Updates</title> -->
      <title>Switches and Updates</title>

      <para lang="en">Have you noticed that the output of <command>svn
        switch</command> and <command>svn update</command> look the
        same?  The <literal>switch</literal> command is actually a
        superset of the update command.</para>

      <para>Avete notato che output di <command>svn
          switch</command> e <command>svn update</command> sembrano
        uguali?  Il comando <literal>switch</literal> è in verità
        un soprainsieme del comando update.</para>

      <para lang="en">When you run <command>svn update</command>, you're asking
        the repository to compare two trees.  The repository does so,
        and then sends a description of the differences back to the
        client.  The only difference between <command>svn
        switch</command> and <command>svn update</command> is that the
        <literal>update</literal> command always compares two identical
        paths.</para>

      <para>Quando lanciate <command>svn update</command>, state chiedendo
        al deposito di comparare due strutture. Il deposito lo fa e spedisce
        descrizione delle differenze dietro al client . L'unica
        differenza tra <command>svn switch</command> e <command>svn update</command>
        è che il comando <literal>update</literal> compara sempre
        due indirizz identici.</para>

      <para lang="en">That is, if your working copy is a mirror of
        <filename>/calc/trunk</filename>, then <command>svn
        update</command> will automatically compare your working copy
        of <filename>/calc/trunk</filename> to
        <filename>/calc/trunk</filename> in the
        <literal>HEAD</literal> revision.  If you're switching your
        working copy to a branch, then <command>svn switch</command>
        will compare your working copy of
        <filename>/calc/trunk</filename> to some
        <emphasis>other</emphasis> branch-directory in the
        <literal>HEAD</literal> revision.</para>

      <para>Proprio così, se la vostra copia di lavoro rispecchia
        <filename>/calc/trunk</filename>, <command>svn
          update</command> automaticamente comparerà vostra
        copia di <filename>/calc/trunk</filename> con
        <filename>/calc/trunk</filename> della revisione
        <literal>HEAD</literal>.  Se state alternando vostra
        copia di lavoro ad un ramo, <command>svn switch</command>
        comparerà vostra copia di lavoro di
        <filename>/calc/trunk</filename> con qualche
        <emphasis>altra</emphasis> cartella (quella del ramo) della
        revisione <literal>HEAD</literal>.</para>

      <para lang="en">In other words, an update moves your working copy through
        time.  A switch moves your working copy through time
        <emphasis>and</emphasis> space.</para>
      <para>In altre parole, un aggiornamento sposta vostra copia
        di lavoro in tempo.  Un switch spota vostra copia di lavoro
        in tempo <emphasis>e</emphasis> spazio.</para>
    </sidebar>

    <para lang="en">Because <command>svn switch</command> is essentially a
      variant of <command>svn update</command>, it shares the same
      behaviors; any local modifications in your working copy are
      preserved when new data arrives from the repository.  This
      allows you to perform all sorts of clever tricks.</para>

    <para>Perché <command>svn switch</command> è esenzialmente
      una variante di <command>svn update</command>, condivide lo
      stesso comportamento; qualsiasi modifica locale nella vostra copia
      di lavoro è conservata quando arrivano nuovi dati dal deposito.
      Questo vi permette di fare ogni sorta di truchetti intelligenti.</para>

    <para lang="en">For example, suppose you have a working copy of
      <filename>/calc/trunk</filename> and make a number of changes to
      it.  Then you suddenly realize that you meant to make the
      changes to a branch instead.  No problem!  When you <command>svn
      switch</command> your working copy to the branch, the local
      changes will remain.  You can then test and commit them to the
      branch.</para>

    <para>Per esempio, supponiamo che avete copia di lavoro di
      <filename>/calc/trunk</filename> e fatte una quantità di cambiamenti.
      Solo dopo scoprite che avete pensavate di fare modifiche
      sulla copia del ramo.  No problem!  Dopo <command>svn
        switch</command> della vostra copia su ramo, i cambiamenti locali
      restano.  Potete testarli e poi depositarli sul ramo.</para>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.tags">
    <!-- <title>Tags</title> -->
    <title>Targhe</title>

    <para lang="en">Another common version control concept is a
      <firstterm>tag</firstterm>.  A tag is just a
      <quote>snapshot</quote> of a project in time.  In Subversion,
      this idea already seems to be everywhere.  Each repository
      revision is exactly that&mdash;a snapshot of the filesystem
      after each commit.</para>

    <para>Altro concetto comune del controllo delle versioni è
      <firstterm>tag</firstterm>(targa).  Una targa è solo
      un'<quote>instantanea</quote>  del progetto nel tempo.  In Subversion,
      questa idea sembra di essere già presente ovunque. Ogni versione
      nel deposito è proprio questo&mdash;un'instantanea del filesystem
      dopo ogni commit.</para>

    <para lang="en">However, people often want to give more human-friendly names
      to tags, like <literal>release-1.0</literal>.  And they want to
      make snapshots of smaller subdirectories of the filesystem.
      After all, it's not so easy to remember that release-1.0 of a
      piece of software is a particular subdirectory of revision
      4822.</para>

    <para>Tuttavia, gente spesso vuole dare alle targe nomi più
      comprensibili, come <literal>release-1.0</literal>.  E vogliono
      fare instantanee di sottocartelle più piccole. Dopo tutto,
      non è così facile ricordarsi che rilascio-1.0 d'un pezzo
      di software è una particolare sottocartella della versione
      4822.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.tags.mksimple">
      <!-- <title>Creating a Simple Tag</title> -->
      <title>Creare una targa semplice</title>

      <para lang="en">Once again, <command>svn copy</command> comes to the
        rescue.  If you want to create a snapshot of
        <filename>/calc/trunk</filename> exactly as it looks in the
        <literal>HEAD</literal> revision, then make a copy of it:</para>

      <para>Ancora una volta, <command>svn copy</command>
        vi dà una mano.  Se volete creare un'instantanea di
        <filename>/calc/trunk</filename> esattamente come compare nella
        versione <literal>HEAD</literal>, fate una copia di esso:</para>

      <screen lang="en">
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/tags/release-1.0 \
      -m "Tagging the 1.0 release of the 'calc' project."

Committed revision 351.
</screen>
<screen>
  $ svn copy http://svn.example.com/repos/calc/trunk \
  http://svn.example.com/repos/calc/tags/release-1.0 \
  -m "Targato il rilascio 1.0 del progetto 'calc'."

  Committed revision 351.
</screen>

      <para lang="en">This example assumes that a
        <filename>/calc/tags</filename> directory already exists.  (If it
        doesn't, vedi <xref linkend="svn.ref.svn.c.mkdir"/>).
        After the copy completes, the new
        <filename>release-1.0</filename> directory is forever a
        snapshot of how the project looked in the
        <literal>HEAD</literal> revision at the time you made the
        copy.  Of course you might want to be more precise about
        exactly which revision you copy, in case somebody else may
        have committed changes to the project when you weren't
        looking.  So if you know that revision 350 of
        <filename>/calc/trunk</filename> is exactly the snapshot you
        want, you can specify it by passing <option>-r 350</option> to
        the <command>svn copy</command> command.</para>

      <para>Questo esempio presume che cartella
        <filename>/calc/tags</filename> già esiste.  (Se no,
        vedi <xref linkend="svn.ref.svn.c.mkdir"/>).
        Dopo che la copia è completata, la nuova cartella
        <filename>release-1.0</filename> è per sempre
        un'instantanea come il progetto appariva nella versione
        <literal>HEAD</literal> in momento della copiatura.
        Certo, potete forse volere di essere più precisi nello
        stabilire quale versione copiare, in caso che qualcun altro
        aveva depositato cambiamenti quando non avete guardato.
        Sapendo che la versione 350 di
        <filename>/calc/trunk</filename> è proprio quella voluta,
        potete specificarlo passando opzione <option>-r 350</option> al
        comando <command>svn copy</command>.</para>

      <para lang="en">But wait a moment: isn't this tag-creation procedure the
        same procedure we used to create a branch?  Yes, in fact, it
        is.  In Subversion, there's no difference between a tag and a
        branch.  Both are just ordinary directories that are created
        by copying.  Just as with branches, the only reason a copied
        directory is a <quote>tag</quote> is because
        <emphasis>humans</emphasis> have decided to treat it that way:
        as long as nobody ever commits to the directory, it forever
        remains a snapshot.  If people start committing to it, it
        becomes a branch.</para>

      <para>Ma aspettate un po': la procedura di creare una targa non è la
        stessa come creare un ramo? Sì, infatti, lo è.  In Subversion
        non c'è differenza tra targa e ramo. Entrambi sono ordinarie cartelle
        e sono creati tramite copiatura.
        Uguale come per i rami, l'unica ragione che una cartella
        copiata è una <quote>targa</quote> è perché
        <emphasis>esseri umani</emphasis> hanno deciso di trattarla
        in quel modo: finché nessuno fa commit su questa cartella, rimane
        per sempre un'instantanea.  Se la gente comincia a depositare dentro
        (commit), diventa un ramo.</para>

      <para lang="en">If you are administering a repository, there are two
        approaches you can take to managing tags.  The first approach
        is <quote>hands off</quote>: as a matter of project policy,
        decide where your tags will live, and make sure all users know
        how to treat the directories they copy in there.  (That is,
        make sure they know not to commit to them.)  The second
        approach is more paranoid: you can use one of the
        access-control scripts provided with Subversion to prevent
        anyone from doing anything but creating new copies in the
        tags-area (See <xref linkend="svn.serverconfig"/>.)  The paranoid
        approach, however, isn't usually necessary.  If a user
        accidentally commits a change to a tag-directory, you can
        simply undo the change as discussed in the previous section.
        This is version control, after all.</para>

      <para>Se state amministrando un deposito, ci sono due approci da prendere
        per maneggiare targhe.  Il primo approcio è
        <quote>alzare le mani</quote>: nelle regole del progetto decidete
        dove vivranno le targhe e assicurate che tutti utenti capiscono
        come trattare le cartelle che copiano lì. (Proprio così,
        assicuratevi che sanno di non fare commit su di essi.<footnote><para>Ndt.
        E se qualcosa va storto, alzate le mani e gridate: <quote>ve lo avevo detto</quote>.
        </para></footnote>)  Il secondo
        approcio è più paranoico. Potete usare uno dei script di controllo
        d'accesso forniti con Subversion per prevenire che nell'area delle targhe
        nessuno può fare altro che creare nuove copie.
        (Vedi <xref linkend="svn.serverconfig"/>.)  L'approcio paranoico,
        comunque, non è tanto necessario.  Se un utente accidentalmente
        fa un commit nella cartella delle targhe, potete semplicemente disfare
        la modifica come abbiamo discuso nella sezione precedente.
        Oltrettuto, stiamo usando controllo delle versioni, no?</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.tags.mkcomplex">
      <!-- <title>Creating a Complex Tag</title> -->
      <title>Creare una targa complessa</title>

      <para lang="en">Sometimes you may want your <quote>snapshot</quote> to be
        more complicated than a single directory at a single
        revision.</para>

      <para>Qualche volta potete desiderare che vostra
        <quote>instantanea</quote> sarà più complicata di una singola
        cartella della singola revisione.</para>

      <para lang="en">For example, pretend your project is much larger than our
        <filename>calc</filename> example: suppose it contains a
        number of subdirectories and many more files.  In the course
        of your work, you may decide that you need to create a working
        copy that is designed to have specific features and bug fixes.
        You can accomplish this by selectively backdating files or
        directories to particular revisions (using <command>svn update
        -r</command> liberally), or by switching files and directories
        to particular branches (making use of <command>svn
        switch</command>).  When you're done, your working copy is a
        hodgepodge of repository locations from different revisions.
        But after testing, you know it's the precise combination of
        data you need.</para>

      <para>For example, pretend your project is much larger than our
        <filename>calc</filename> example: supponiamo che contiene
        gran numero di sottocartelle e molto di più file. Nel corso
        del vostro lavoro potete decidere che avete bisogno di creare
        una copia di lavoro progettata per avere specifiche caratteristiche
        e bug fix.
        You can accomplish this by selectively backdating files or
        directories to particular revisions (using <command>svn update
          -r</command> liberally), or by switching files and directories
        to particular branches (making use of <command>svn
          switch</command>).  Dopo aver finito, vostra copia di lavoro
        è un groviglio delle locazioni del deposito dalle diverse versioni.
        Ma dopo i test, sapete che questa è la precisa combinazione dei dati
        che vi serve.</para>

      <para lang="en">Time to make a snapshot.  Copying one URL to another won't
        work here.  In this case, you want to make a snapshot of your
        exact working copy arrangement and store it in the repository.
        Luckily, <command>svn copy</command> actually has four
        different uses (which you can read about in Chapter 9),
        including the ability to copy a working-copy tree to the
        repository:</para>

      <para>Ora di scattare un'instantanea.  Copying one URL to another won't
        work here.  In this case, you want to make a snapshot of your
        exact working copy arrangement and store it in the repository.
        Luckily, <command>svn copy</command> actually has four
        different uses (which you can read about in <xref linkend="svn.ref"/>),
        incluso la capacità di copiare una copia di lavoro nel deposito:</para>

      <screen>
$ ls
my-working-copy/

$ svn copy my-working-copy http://svn.example.com/repos/calc/tags/mytag

Committed revision 352.
</screen>

      <para lang="en">Now there is a new directory in the repository,
        <filename>/calc/tags/mytag</filename>, which is an exact
        snapshot of your working copy&mdash;mixed revisions, URLs,
        and all.</para>

      <para>Adesso nel deposito c'è una nuova cartella,
        <filename>/calc/tags/mytag</filename>, che è un'instantanea
        esatta della vostra copia di lavoro&mdash;revisioni miste, URL,
        e tutto il resto.</para>

      <para lang="en">Other users have found interesting uses for this feature.
        Sometimes there are situations where you have a bunch of local
        changes made to your working copy, and you'd like a
        collaborator to see them.  Instead of running <command>svn
        diff</command> and sending a patch file (which won't capture
        tree changes, symlink changes or changes in properties), you can
        instead use <command>svn copy</command> to <quote>upload</quote>
        your working copy to a private area of the repository.  Your
        collaborator can then either checkout a verbatim copy of your
        working copy, or use <command>svn merge</command> to receive
        your exact changes.</para>

      <para>Altri utenti hanno trovato usi interessanti per questa caratteristica.
        Di tanto in tanto sono le situazioni avete una manciata delle
        modifiche locali fatte sulla vostra copia di lavoro e volete
        farle vedere ai vostri collaboratori. Invece di usare
        <command>svn diff</command> e mandarli file patch (che non può
        catturare cambiamenti di cartelle, link simbolici oppure
        cambiamenti delle proprietà) potete usare <command>svn copy</command>
        per <quote>caricare</quote> la vostra copia di lavoro nella
        area privata del deposito. Vostro collaboratore può poi
        o tirarsi fuori una copia identica (checkout) o usare
        <command>svn merge</command> per ricevere le vostre modifiche.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.maint">
    <!-- <title>Branch Maintenance</title> -->
    <title>Mantenimento dei rami</title>

    <para lang="en">You may have noticed by now that Subversion is extremely
      flexible.  Because it implements branches and tags with the same
      underlying mechanism (directory copies), and because branches
      and tags appear in normal filesystem space, many people find
      Subversion intimidating.  It's almost <emphasis>too</emphasis>
      flexible.  In this section, we'll offer some suggestions for
      arranging and managing your data over time.</para>

    <para>Forse avete già notato che Subversion è estremamente
      flessibile.  Perché implementa rami e targhe con lo stesso mecanismo
      sottostante (copiatura delle cartelle) e perché rami e targhe
      appaiono nello spazio ordinario del filesistem, molte persone
      trovano Subversion spaventoso.  È quasi <emphasis>troooopo</emphasis>
      flessibile.  In questa sezione vi offriamo alcune suggestioni di come
      arrangiare e mantenere i vostri dati nel corso del tempo.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.maint.layout">
      <!-- <title>Repository Layout</title> -->
      <title>Forma del deposito</title>

      <para lang="en">There are some standard, recommended ways to organize a
        repository.  Most people create a <filename>trunk</filename>
        directory to hold the <quote>main line</quote> of development,
        a <filename>branches</filename> directory to contain branch
        copies, and a <filename>tags</filename> directory to contain
        tag copies.  If a repository holds only one project, then
        often people create these top-level directories:</para>

      <para>Ci sono alcuni standard, modi raccommandati per organizzare
        un deposito.  Molti creano una cartella <filename>trunk</filename>
        per contenere <quote>linea principale</quote> dello sviluppo,
        una cartella <filename>branches</filename> per contenere i rami
        e una cartella <filename>tags</filename> per contenere le targhe.
        Quando il deposito contiene solo un progetto, allora si creano
        queste cartelle di alto livello:</para>

      <screen>
/trunk
/branches
/tags
</screen>

      <para lang="en">If a repository contains multiple projects, admins
        typically index their layout by project (see <xref
        linkend="svn.reposadmin.projects.chooselayout"/> to read more about
        <quote>project roots</quote>):</para>

      <para>Quando il deposito contiene più progetti, amministratori tipicamente
        dividono la disposizione secondo i progetti (vedi <xref
        linkend="svn.reposadmin.projects.chooselayout"/> per leggere di più
        riguardo <quote>radici dei progetti</quote>):</para>

      <screen>
/paint/trunk
/paint/branches
/paint/tags
/calc/trunk
/calc/branches
/calc/tags
</screen>

      <para lang="en">Of course, you're free to ignore these common layouts.
        You can create any sort of variation, whatever works best for
        you or your team.  Remember that whatever you choose, it's not
        a permanent commitment.  You can reorganize your repository at
        any time.  Because branches and tags are ordinary directories,
        the <command>svn move</command> command can move or rename
        them however you wish.  Switching from one layout to another
        is just a matter of issuing a series of server-side moves; if
        you don't like the way things are organized in the repository,
        just juggle the directories around.</para>

      <para>Of course, you're free to ignore these common layouts.
        You can create any sort of variation, whatever works best for
        you or your team.  Remember that whatever you choose, it's not
        a permanent commitment.  You can reorganize your repository at
        any time.  Because branches and tags are ordinary directories,
        the <command>svn move</command> command can move or rename
        them however you wish.  Switching from one layout to another
        is just a matter of issuing a series of server-side moves; if
        you don't like the way things are organized in the repository,
        just juggle the directories around.</para>

      <para lang="en">Remember, though, that while moving directories may be
        easy to do, you need to be considerate of your users as well.
        Your juggling can be disorienting to users with existing
        working copies.  If a user has a working copy of a particular
        repository directory, your <command>svn move</command>
        operation might remove the path from the latest revision.
        When the user next runs <command>svn update</command>, she will
        be told that her working copy represents a path that no
        longer exists, and the user will be forced to <command>svn
        switch</command> to the new location.
        </para>

      <para>Ricordatevi, though, that while moving directories may be
        easy to do, you need to be considerate of your users as well.
        Your juggling can be disorienting to users with existing
        working copies.  If a user has a working copy of a particular
        repository directory, your <command>svn move</command>
        operation might remove the path from the latest revision.
        When the user next runs <command>svn update</command>, she will
        be told that her working copy represents a path that no
        longer exists, and the user will be forced to <command>svn
        switch</command> to the new location.
        </para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.maint.lifetime">
      <!-- <title>Data Lifetimes</title> -->
      <title>Arco di vita dei dati</title>

      <para lang="en">Another nice feature of Subversion's model is that
        branches and tags can have finite lifetimes, just like any
        other versioned item.  For example, suppose you eventually
        finish all your work on your personal branch of the
        <filename>calc</filename> project.  After merging all of your
        changes back into <filename>/calc/trunk</filename>, there's
        no need for your private branch directory to stick around
        anymore:</para>

      <para>Altra bella caratteristica del modello Subversionè che
        i rami e targhe hanno la vita limitata, come qualsiasi altro
        articolo[pezzo] versionato. Per esempio, supponiamo che
        avete finito lavoro su vostro ramo personale di progetto
        <filename>calc</filename>.  Dopo fusione delle tutte vostre
        modifiche indietro nel <filename>/calc/trunk</filename>,
        non c'è più ragione per la essistenza del ramo privato:</para>

      <screen lang="en">
$ svn delete http://svn.example.com/repos/calc/branches/my-calc-branch \
             -m "Removing obsolete branch of calc project."

Committed revision 375.
</screen>
<screen>
  $ svn delete http://svn.example.com/repos/calc/branches/my-calc-branch \
             -m "Rimosso ramo obsoletto del progetto calc."

  Committed revision 375.
</screen>

      <para lang="en">And now your branch is gone.  Of course it's not really
        gone: the directory is simply missing from the
        <literal>HEAD</literal> revision, no longer distracting
        anyone.  If you use <command>svn checkout</command>,
        <command>svn switch</command>, or <command>svn list</command>
        to examine an earlier revision, you'll still be able to see
        your old branch.</para>

      <para>E adesso vostro ramo è andato.  Certo, in verità non è
        sparito: la cartella semplicemente manca nella versione
        <literal>HEAD</literal>, non distraendo più nessuno.
        Usando <command>svn checkout</command>,
        <command>svn switch</command>, o <command>svn list</command>
        per essaminare le versioni precedenti, potete ancora vedere
        vostro vecchio ramo.</para>

      <para lang="en">If browsing your deleted directory isn't enough, you can
        always bring it back.  Resurrecting data is very easy in
        Subversion.  If there's a deleted directory (or file) that
        you'd like to bring back into <literal>HEAD</literal>, simply
        use <command>svn copy -r</command> to copy it from the old
        revision:</para>

      <para>Se non vi basta navigare nella cartella cancellata,
        potete sempre richiamarla dietro.  Risurrezione dei dati
        è in Subversion molto semplice.  If there's a deleted directory (or file) that
        you'd like to bring back into <literal>HEAD</literal>, simply
        use <command>svn copy -r</command> to copy it from the old
        revision:</para>

      <screen>
$ svn copy -r 374 http://svn.example.com/repos/calc/branches/my-calc-branch \
                  http://svn.example.com/repos/calc/branches/my-calc-branch

Committed revision 376.
</screen>

      <para lang="en">In our example, your personal branch had a relatively
        short lifetime: you may have created it to fix a bug or
        implement a new feature.  When your task is done, so is the
        branch.  In software development, though, it's also common to
        have two <quote>main</quote> branches running side-by-side for
        very long periods.  For example, suppose it's time to release
        a stable version of the <filename>calc</filename> project to the
        public, and you know it's going to take a couple of months to
        shake bugs out of the software.  You don't want people to add
        new features to the project, but you don't want to tell all
        developers to stop programming either.  So instead, you create
        a <quote>stable</quote> branch of the software that won't
        change much:</para>

      <para>Nel nostro esempio, vostro ramo personale aveva la vita
        relativamente breve: lo avete creato per bug fix o sviluppo
        d'una nuova caratteristica. Quando vostro lavoro era fatto,
        era finito anche il ramo. Nello sviluppo di software, invece,
        è comune di avere due <quote>principali</quote> rami
        affiancati per lungo periodo di tempo. Per esempio, supponiamo
        che è giunta ora di rilasciare la versione stabile di progetto
        <filename>calc</filename> al pubblico, e voi sapete che ci vorrà
        qualche mese per cacciare via dal software gli errori.
        Non volete che la gente aggiunga nuove caratteristiche al progetto,
        ma non volete neanche fermare gli sviluppatori.
        Allora, create un ramo<quote>stable</quote> del software
        che non cambierà molto:</para>

      <screen lang="en">
$ svn copy http://svn.example.com/repos/calc/trunk \
         http://svn.example.com/repos/calc/branches/stable-1.0 \
         -m "Creating stable branch of calc project."

Committed revision 377.
</screen>
<screen>
  $ svn copy http://svn.example.com/repos/calc/trunk \
  http://svn.example.com/repos/calc/branches/stable-1.0 \
  -m "Creato ramo stabile del progetto calc."

  Committed revision 377.
</screen>

      <para lang="en">And now developers are free to continue adding
        cutting-edge (or experimental) features to
        <filename>/calc/trunk</filename>, and you can declare a
        project policy that only bug fixes are to be committed to
        <filename>/calc/branches/stable-1.0</filename>.  That is, as
        people continue to work on the trunk, a human selectively
        ports bug fixes over to the stable branch.  Even after the
        stable branch has shipped, you'll probably continue to
        maintain the branch for a long time&mdash;that is, as long
        as you continue to support that release for customers.</para>

      <para>Adesso gli sviluppatori sono liberi di continuare ad
        aggiungere caratteristiche all'avanguardia (o sperimentali)
        al <filename>/calc/trunk</filename>, e voi potete stabilire
        la regola del progetto che solo i bug fix possono essere
        pubblicati nel <filename>/calc/branches/stable-1.0</filename>.
        Proprio così, mentre continua il lavoro sul tronco,
        qualcuno a mano porta selettivamente i bug fix sul ramo
        stabile. Anche dopo la uscita del ramo stabile al pubblico,
        probabilmente continuerete mantenere il ramo per lungo
        tempo&mdash;finché continuerà il supporto di questa versione
        per i clienti.</para>

    </sect2>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.summary">
  <!--  <title>Summary</title>  -->
    <title>Sommario</title>

    <para lang="en">We've covered a lot of ground in this chapter.  We've
      discussed the concepts of tags and branches, and demonstrated
      how Subversion implements these concepts by copying directories
      with the <command>svn copy</command> command.  We've shown how
      to use <command>svn merge</command> to copy changes from one
      branch to another, or roll back bad changes.  We've gone over
      the use of <command>svn switch</command> to create
      mixed-location working copies.  And we've talked about how one
      might manage the organization and lifetimes of branches in a
      repository.</para>

    <para>Abbiamo coperto molto delle basi in questo capitolo. Abbiamo
      discusso i concetti delle targe e dei rami e dimostrato come
      Subversion implementa questi concetti tramite copie delle cartelle
      con comando <command>svn copy</command>.  Abbiamo mostrato come
      usare <command>svn merge</command> per copiare modifiche da
      un ramo ad altro o disfare (riavvolgere dietro) modifiche errate.
      Abbiamo passato uso di <command>svn switch</command> per creare
      copie di lavoro miste, provenienti da diverse locazioni.
      E abbiamo parlato di come uno può maneggare la organizzazione e
      ciclo di vita dei rami nel deposito.</para>

    <para lang="en">Remember the Subversion mantra: branches and tags are cheap.
      So use them liberally!</para>

    <para>Ricordate il mantra di Subversion: rami e targhe sono a basso costo.
      Allora usateli liberalmente!</para>

  </sect1>

</chapter>

<!--
local variables:
sgml-parent-document: ("book.xml" "chapter")
end:
-->
