<chapter id="svn.developer">
  <title>Informazioni per lo sviluppatore</title>
  
  <simplesect>
    <para lang="en">Subversion is an open-source software project developed
      under an Apache-style software license.  The project is
      financially backed by CollabNet, Inc., a California-based
      software development company.  The community that has formed
      around the development of Subversion always welcomes new members
      who can donate their time and attention to the project.
      Volunteers are encouraged to assist in any way they can, whether
      that means finding and diagnosing bugs, refining existing source
      code, or fleshing out whole new features.</para>
    
    <para>Subversion è un progetto software open source sviluppato
      sotto una licenza software nello stile di quella di Apache.  Il progetto è
      sostenuto finanziariamente dalla CollabNet, Inc., una compagnia di
      sviluppo software con sede in California.  La comunità che si è formata
      attorno allo sviluppo di Subversion dà sempre il bevenuto a nuovi membri
      che possono donare il loro tempo e attenzione al progetto.
      I volontari sono incoraggiati a assistere in ogni modo loro possibile, dove
      questo significa trovare e diagnosticare errori, raffinare il codice
      sorgente esistente, o sviluppare intere nuove caratteristiche.</para>

    <para lang="en">This chapter is for those who wish to assist in the
      continued evolution of Subversion by actually getting their
      hands dirty with the source code.  We will cover some of the
      software's more intimate details, the kind of technical
      nitty-gritty that those developing Subversion itself&mdash;or
      writing entirely new tools based on the Subversion
      libraries&mdash;should be aware of.  If you don't foresee
      yourself participating with the software at such a level, feel
      free to skip this chapter with confidence that your experience
      as a Subversion user will not be affected.</para>

    <para>Questo capitolo è per coloro desiderano assistere nella continua
      evoluzione di Subversion mettendo realmente le loro mani
      nel codice sorgente.  Verranno coperti alcuni dei dettagli più intrinsechi
      del software, il tipo di essenza tecnica
      di quelli che sviluppano Subversion in se&mdash;o
      scrivendo interamente nuovi strumenti basati sulle librerie di Subversion
      &mdash;di cui si dovrebbe essere informati.  Se non si prevede di
      partecipare al software a questo livello, si può
      saltare questo capitolo con la sicurezza che la propria esperienza come
      utente di Subversion non ne sarà influenzata.</para>

  </simplesect>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.developer.layerlib">
    <title>Il disegno a strati delle librerie</title>

    <para lang="en">Subversion has a modular design, implemented as a collection
      of C libraries.  Each library has a well-defined purpose and
      interface, and most modules are said to exist in one of three
      main layers&mdash;the Repository Layer, the Repository Access
      (RA) Layer, or the Client Layer.  We will examine these layers
      shortly, but first, see our brief inventory of Subversion's
      libraries in <xref linkend="svn.developer.layerlib.tbl-1"/>.  For the sake
      of consistency, we will refer to the libraries by their
      extensionless Unix library names (e.g.: libsvn_fs, libsvn_wc,
      mod_dav_svn).</para>

    <para>Subversion ha un disegno modulare, implementato come una collezione
      di librerie C.  Ogni libreria ha uno scopo e un'interfaccia ben definiti,
      e la maggior parte dei moduli sono dichiarati di esistere in uno dei tre
      strati principali&mdash;lo strato repository, lo strator accesso al repository
      (RA), o lo strato clien.  Verranno esaminati questi strati
      brevemente, ma prima, vedere il breve inventario delle librerie
      di Subversion in <xref linkend="svn.developer.layerlib.tbl-1"/>.  Nell'interesse
      della consistenza, verrà fatto riferimento alla librerie con i loro nomi Unix
      senza estensione (es.: libsvn_fs, libsvn_wc,
      mod_dav_svn).</para>

    <table id="svn.developer.layerlib.tbl-1-en" lang="en">
      <title>A Brief Inventory of the Subversion Libraries</title>
      <tgroup cols="2">
        <thead>
          <row>
            <entry>Library</entry>
            <entry>Description</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>libsvn_client</entry> 
            <entry>Primary interface for client programs</entry>
          </row>
          <row>
            <entry>libsvn_delta</entry>
            <entry>Tree and byte-stream differencing routines</entry>
          </row>
          <row>
            <entry>libsvn_diff</entry>
            <entry>Contextual differencing and merging routines</entry>
          </row>
          <row>
            <entry>libsvn_fs</entry>
            <entry>Filesystem commons and module loader</entry>
          </row>
          <row>
            <entry>libsvn_fs_base</entry>
            <entry>The Berkeley DB filesystem back-end</entry>
          </row>
          <row>
            <entry>libsvn_fs_fs</entry>
            <entry>The native filesystem (FSFS) back-end</entry>
          </row>
          <row>
            <entry>libsvn_ra</entry>
            <entry>Repository Access commons and module loader</entry>
          </row>
          <row>
            <entry>libsvn_ra_dav</entry>
            <entry>The WebDAV Repository Access module</entry>
          </row>
          <row>
            <entry>libsvn_ra_local</entry>
            <entry>The local Repository Access module</entry>
          </row>
          <row>
            <entry>libsvn_ra_svn</entry>
            <entry>The custom protocol Repository Access module</entry>
          </row>
          <row>
            <entry>libsvn_repos</entry>
            <entry>Repository interface</entry>
          </row>
          <row>
            <entry>libsvn_subr</entry>
            <entry>Miscellaneous helpful subroutines</entry>
          </row>
          <row>
            <entry>libsvn_wc</entry>
            <entry>The working copy management library</entry>
          </row>
          <row>
            <entry>mod_authz_svn</entry>
            <entry>Apache authorization module for Subversion
            repositories access via WebDAV</entry>
          </row>
          <row>
            <entry>mod_dav_svn</entry>
            <entry>Apache module for mapping WebDAV operations to
            Subversion ones</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <table id="svn.developer.layerlib.tbl-1">
      <title>Un breve inventario delle librerie di Subversion</title>
      <tgroup cols="2">
        <thead>
          <row>
            <entry>Libreria</entry>
            <entry>Descrizione</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>libsvn_client</entry> 
            <entry>Interfaccia primaria per programmi client</entry>
          </row>
          <row>
            <entry>libsvn_delta</entry>
            <entry>Procedure di differenza per alberi e byte-stream</entry>
          </row>
          <row>
            <entry>libsvn_diff</entry>
            <entry>Procedure di differenza e fusione</entry>
          </row>
          <row>
            <entry>libsvn_fs</entry>
            <entry>Caricatore di filesystem comuni e moduli</entry>
          </row>
          <row>
            <entry>libsvn_fs_base</entry>
            <entry>L'interfaccia per il filesystem al database Berkeley DB</entry>
          </row>
          <row>
            <entry>libsvn_fs_fs</entry>
            <entry>L'interfaccia per il filesystem nativo (FSFS)</entry>
          </row>
          <row>
            <entry>libsvn_ra</entry>
            <entry>Caricatore di accesso a repository comuni e moduli</entry>
          </row>
          <row>
            <entry>libsvn_ra_dav</entry>
            <entry>Il modulo per l'accesso a repository WebDAV</entry>
          </row>
          <row>
            <entry>libsvn_ra_local</entry>
            <entry>Il modulo per l'accesso a repository locali</entry>
          </row>
          <row>
            <entry>libsvn_ra_svn</entry>
            <entry>Il modulo per l'accesso a repository con protocolli personalizzati</entry>
          </row>
          <row>
            <entry>libsvn_repos</entry>
            <entry>Interfaccia a repository</entry>
          </row>
          <row>
            <entry>libsvn_subr</entry>
            <entry>Varie sottoprocedure di aiuto</entry>
          </row>
          <row>
            <entry>libsvn_wc</entry>
            <entry>La libreria di gestione della copia di lavoro</entry>
          </row>
          <row>
            <entry>mod_authz_svn</entry>
            <entry>Il modulo di autorizzazione Apache per l'accesso a repository
            Subversion via WebDAV</entry>
          </row>
          <row>
            <entry>mod_dav_svn</entry>
            <entry>Modulo Apache per mappare operazioni WebDAV sulle corrispondenti
            Subversion</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para lang="en">The fact that the word <quote>miscellaneous</quote> only
      appears once in <xref linkend="svn.developer.layerlib.tbl-1"/> is a good
      sign.  The Subversion development team is serious about making
      sure that functionality lives in the right layer and libraries.
      Perhaps the greatest advantage of the modular design is its lack
      of complexity from a developer's point of view.  As a developer,
      you can quickly formulate that kind of <quote>big
      picture</quote> that allows you to pinpoint the location of
      certain pieces of functionality with relative ease.</para>

    <para>Il fatto che la parola <quote>varie</quote> compare una sola volta
      in <xref linkend="svn.developer.layerlib.tbl-1"/> è un buon
      segno.  La squadra di sviluppo di Subversion è preoccupata riguardo il fatto di
      assicurarsi che le funzionalità esistano nello strato e nelle librerie giuste.
      Forse il più grande vantaggio del disegno modulare è la sua mancanza
      di complessità da un punto di vista dello sviluppatore.  Come sviluppatore,
      si può formulare velocemente questo tipo di <quote>grande
      immagine</quote> che permette di individuare la posizione di certe parti
      di funzionalità con relativa semplicità.</para>

    <para lang="en">Another benefit of modularity is the ability to replace a
      given module with a whole new library that implements the same
      API without affecting the rest of the code base.  In some sense,
      this happens within Subversion already.  The libsvn_ra_dav,
      libsvn_ra_local, and libsvn_ra_svn all implement the same
      interface.  And all three communicate with the Repository
      Layer&mdash;libsvn_ra_dav and libsvn_ra_svn do so across a
      network, and libsvn_ra_local connects to it directly.  The
      libsvn_fs_base and libsvn_fs_fs libraries are another example of
      this.</para>

    <para>Un altro beneficio della modularità è l'abilità di sostituire un dato
      modulo con un'intera nuova libreria che implementa la stessa
      API senza interessare il resto del codice di base.  In un certo senso,
      questo accade già allinterno di Subversion.  libsvn_ra_dav,
      libsvn_ra_local, e libsvn_ra_svn implmentato tutte la stessa
      interfaccia.  E tutte e tre comunicano con lo strato repository
      &mdash;libsvn_ra_dav e libsvn_ra_svn lo fanno attraverso una rete,
      e libsvn_ra_local ci si connette direttamente.  Le librerie
      libsvn_fs_base e libsvn_fs_fs sono un altro esempio di ciò.</para>

    <para lang="en">The client itself also highlights modularity in the
      Subversion design.  While Subversion itself comes with only a
      command-line client program, there are several third party
      programs which provide various forms of client GUI.  These GUIs
      use the same APIs that the stock command-line client does.
      Subversion's libsvn_client library is the one-stop shop for most
      of the functionality necessary for designing a working
      Subversion client (see <xref
      linkend="svn.developer.layerlib.client"/>).</para>

    <para>Il client stesso evidenzia anche la madularità nel disegno di
      Subversion.  Mentre Subversion stesso viene fornito solamente con un programma
      client a linea di comando, ci sono vari programmi di terze parti
      che forniscono varie forme di client a interfaccia grafica.  Queste interfacce
      grafiche utilizzano le stesse API che usa il client a linea di comando predefinito.
      La libreria di Subversion libsvn_client è il negozio a fermata unica per la
      maggior parte delle funzionalità necessarie per progettare un client
      funzionante per Subversion (vedere <xref
      linkend="svn.developer.layerlib.client"/>).</para>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.layerlib.repos">
      <title>Strato repository</title>

      <para lang="en">When referring to Subversion's Repository Layer, we're
        generally talking about two libraries&mdash;the repository
        library, and the filesystem library.  These libraries provide
        the storage and reporting mechanisms for the various revisions
        of your version-controlled data.  This layer is connected to
        the Client Layer via the Repository Access Layer, and is, from
        the perspective of the Subversion user, the stuff at the
        <quote>other end of the line.</quote></para>

      <para>Nel riferirsi allo strato repository di Subversion, si sta
        generalmente parlando di due librerie&mdash;la libreria per i repository,
        e la libreria per i filesystem.  Queste librerie forniscono
        i meccanismi per l'immagazzinaggio e la segnalazione per le varie revisioni
        dei propri dati sotto controllo di versione.  Questo strato è connesso allo
        strato client attraverso lo strato di accesso al repository, ed è, dalla
        prospettiva dell'utente di Subversion, la cosa all'
        <quote>altro lato della linea.</quote></para>

      <para lang="en">The Subversion Filesystem is accessed via the libsvn_fs
        API, and is not a kernel-level filesystem that one would
        install in an operating system (like the Linux ext2 or NTFS),
        but a virtual filesystem.  Rather than storing
        <quote>files</quote> and <quote>directories</quote> as real
        files and directories (as in, the kind you can navigate
        through using your favorite shell program), it uses one of two
        available abstract storage backends&mdash;either a Berkeley DB
        database environment, or a flat-file representation.  (To
        learn more about the two repository back-ends, see <xref
        linkend="svn.reposadmin.basics.backends"/>.)  However, there has been
        considerable interest by the development community in giving
        future releases of Subversion the ability to use other
        back-end database systems, perhaps through a mechanism such as
        Open Database Connectivity (ODBC).</para>

      <para>Il filesystem di Subversion è acceduto attraverso l'API libsvn_fs,
        e non è un filesystem a livello di kernel che si installerebbe
        in un sistema operativo (come ext2 o NTFS di Linux),
        ma un filesystem virtuale.  Piuttosto che immagazzinare
        <quote>file</quote> e <quote>directory</quote> come file e
        directory reali (il tipo in cui si può navigare
        utilizzando il proprio programma di shell favorito), utilizza una delle due
        interfacce astratte per immagazzinamento disponibili&mdash;o un ambientedatabase
        Berkeley DB, o una rappresentazione di file piatta.  (Per
        imparare maggiormente circa le due interfacce per il repository, vedere <xref
        linkend="svn.reposadmin.basics.backends"/>.)  Comunque, c'è stato un
        considerevole interesse della comunità di sviluppo nel dare ai
        rilasci futuri di Subversion l'abilità di utilizzare altre
        interfacce a sistemi database, forse attraverso un meccanismo come
        Open Database Connectivity (ODBC).</para>

      <para lang="en">The filesystem API exported by libsvn_fs contains the
        kinds of functionality you would expect from any other
        filesystem API: you can create and remove files and
        directories, copy and move them around, modify file contents,
        and so on.  It also has features that are not quite as common,
        such as the ability to add, modify, and remove metadata
        (<quote>properties</quote>) on each file or directory.
        Furthermore, the Subversion Filesystem is a versioning
        filesystem, which means that as you make changes to your
        directory tree, Subversion remembers what your tree looked
        like before those changes.  And before the previous changes.
        And the previous ones.  And so on, all the way back through
        versioning time to (and just beyond) the moment you first
        started adding things to the filesystem.</para>

      <para>L'API per il filesystem esportata da libsvn_fs contiene il
        tipo di funzionalità ci si aspetterebbe da ogni altra API per
        filesystem: si può creare e rimuovere file e
        directory, copiarli e spostarli, modificare il contenuto dei file,
        e così via.  Ha anche caratteristiche che non sono comuni,
        come l'abilità di aggiungere, modificare, e rimuovere metadati
        (<quote>proprietà</quote>) su ogni file o directory.
        Ancora, il filesystem di Subversion è un filesystem di
        versionamento, che significa che come vengono fatti dei cambiamenti
        all'albero delle directory, Subversion ricorda come era fatto l'albero
        prima di questi cambiamenti.  E prima dei cambiamenti precedenti.
        E i precedenti ancora.  E così via, tutti i modi indietro attraverso il
        tempo di versionamento fino al (e ancora oltre) momento in cui si è iniziato
        ad aggiungere cose al filesystem.</para>

      <para lang="en">All the modifications you make to your tree are done
        within the context of a Subversion transaction.  The following
        is a simplified general routine for modifying your
        filesystem:</para>

      <para>Tutte le modifiche fatte all'albero sono fatte
        all'interno del contesto di una transazione Subversion.  Il seguente
        è una procedure semplificata generale per modificare il proprio
        filesystem:</para>

      <orderedlist>
        <listitem>
          <para lang="en">Begin a Subversion transaction.</para>
          <para>Iniziare una transazione Subversion.</para>
        </listitem>
        <listitem>
          <para lang="en">Make your changes (adds, deletes, property
            modifications, etc.).</para>
          <para>Fare i propri cambiamenti (aggiunte, eliminazioni, modifiche alle
            proprietà, ecc.).</para>
        </listitem>
        <listitem>
          <para lang="en">Commit your transaction.</para>
          <para>Fare il commit della transazione.</para>
        </listitem>
      </orderedlist>

      <para lang="en">Once you have committed your transaction, your filesystem
        modifications are permanently stored as historical artifacts.
        Each of these cycles generates a single new revision of your
        tree, and each revision is forever accessible as an immutable
        snapshot of <quote>the way things were.</quote></para>

      <para>Una volta fatto il commit della transazione, le modifiche
        al filesystem sono immagazzinate permanentemente come artefatti storici.
        Ognuno di questi cicli genera un singola nuova revisione dell'albero,
        e ogni revisione è accessibile per sempre come un'istantanea immutabile
        di <quote>come erano le cose.</quote></para>

      <sidebar>
        <title>La distrazione di transazione</title>

        <para lang="en">The notion of a Subversion transaction, especially given
          its close proximity to the database code in libsvn_fs, can
          become easily confused with the transaction support provided
          by the underlying database itself.  Both types of
          transaction exist to provide atomicity and isolation.  In
          other words, transactions give you the ability to perform a
          set of actions in an <quote>all or nothing</quote>
          fashion&mdash;either all the actions in the set complete
          with success, or they all get treated as if
          <emphasis>none</emphasis> of them ever happened&mdash;and in
          a way that does not interfere with other processes acting on
          the data.</para>

        <para>La nozione di una transazione di Subversion, in particolare data la
          sua prossimità al codice per il database in libsvn_fs, può
          facilmente essere confusa con il supporto alla transazione fornito
          dal database sottostante stesso.  Entrambi i tipi di
          transazioni esistono per fornire atomicità e isolamento.  In
          altre parole, le transazioni danno l'abilità di eseguire un insieme
          di azioni in un modo <quote>tutte o nessuna</quote>
          &mdash;o tutte le azioni nell'insieme completano con
          successo, o vengono trattate come se
          <emphasis>nessuna</emphasis> di loro sono accadute&mdash;e in un
          modo che non interferisce con altri processi che agiscono sui
          dati.</para>

        <para lang="en">Database transactions generally encompass small
          operations related specifically to the modification of data
          in the database itself (such as changing the contents of a
          table row).  Subversion transactions are larger in scope,
          encompassing higher-level operations like making
          modifications to a set of files and directories which are
          intended to be stored as the next revision of the filesystem
          tree.  If that isn't confusing enough, consider this:
          Subversion uses a database transaction during the creation
          of a Subversion transaction (so that if the creation of
          Subversion transaction fails, the database will look as if
          we had never attempted that creation in the first
          place)!</para>

        <para>Le transazioni del database generalmente comprendono piccole
          operazioni relative specificamente alla modifica dei dati
          nel database stesso (come cambiare i contenuti di una riga di
          tabella).  Le transazioni di Subversion hanno una portata più ampia,
          comprendendo operazioni ad alto livello come fare
          modifiche a un insieme di file e directory che sono
          intese di essere immagazzinate come la prossima revisione dell'albero
          del filesystem.  Se questo non è abbastanza confuso, considerare questo:
          Subversion utilizza una transazione di database durante la creazione
          di una transazioni di Subversion (così che se la creazione di una
          transazione di Subversion fallisce, il database sarà come se
          non sia stato tentata questa prima creazione)!</para>

        <para lang="en">Fortunately for users of the filesystem API, the
          transaction support provided by the database system itself
          is hidden almost entirely from view (as should be expected
          from a properly modularized library scheme).  It is only
          when you start digging into the implementation of the
          filesystem itself that such things become visible (or
          interesting).</para>

        <para>Fortunatamente per gli utenti delle API per il filesystem API, il
          supporto alle transazioni fornito del sistema di database stesso
          è nascosto quasi interamente alla vista (come ci si può aspettare
          da uno schema di libreria propriamente modulare).  È solamente
          quando si inizia a scavare nell'implementazione del
          filesystem stesso che queste cose diventano visibili (o
          interessanti).</para>

      </sidebar>

      <para lang="en">Most of the functionality provided by the filesystem
        interface comes as an action that occurs on a filesystem path.
        That is, from outside of the filesystem, the primary mechanism
        for describing and accessing the individual revisions of files
        and directories comes through the use of path strings like
        <filename>/foo/bar</filename>, just as if you were addressing
        files and directories through your favorite shell program.
        You add new files and directories by passing their paths-to-be
        to the right API functions.  You query for information about
        them by the same mechanism.</para>

      <para>La maggior parte delle funzionalità fornite dalla interfaccia del
        filesystem avvengono come un'azione che occorre su un percorso del filesystem.
        Quello è, da fuori il filesystem, il meccanismo primario
        per descrivere e accedere le revisioni individuali di file
        e directory attraverso l'utilizzo di stringhe percorso come
        <filename>/foo/bar</filename>, come se si stessero indirizzando
        file e directory attraverso il proprio programma shell favorito.
        Si aggiungono nuovi file e directory passando il loro percorso 
        alle funzioni giuste dell'API.  Si interroga per informazioni su di loro
        con lo stesso meccanismo.</para>

      <para lang="en">Unlike most filesystems, though, a path alone is not
        enough information to identify a file or directory in
        Subversion.  Think of a directory tree as a two-dimensional
        system, where a node's siblings represent a sort of
        left-and-right motion, and descending into subdirectories a
        downward motion.  <xref linkend="svn.developer.layerlib.repos.dia-1"/> shows
        a typical representation of a tree as exactly that.</para>

      <para>A differenza della maggior parte dei filesystem un percorso da solo non è
        un'informazione sufficiente per identificare un file o una directory in
        Subversion.  Si pensi all'albero delle directory come un sistema a due dimensioni,
        dove i fratelli dei nodi rappresentano una sorta di
        movimento sinistra destra, e discendendo all'interno delle sottodirectory un
        movimento verso il basso.  <xref linkend="svn.developer.layerlib.repos.dia-1"/> mostra
        una tipica rappresentazione di un albero esattamente come è.</para>

      <figure id="svn.developer.layerlib.repos.dia-1">
        <title>File e directory in due dimensioni</title>
        <graphic fileref="images/ch08dia1.png"/>
      </figure>

      <para lang="en">Of course, the Subversion filesystem has a nifty third
        dimension that most filesystems do not have&mdash;Time!
        <footnote>
          <para>We understand that this may come as a shock to sci-fi
            fans who have long been under the impression that Time was
            actually the <emphasis>fourth</emphasis> dimension, and we
            apologize for any emotional trauma induced by our
            assertion of a different theory.</para>
        </footnote>
        In the filesystem interface, nearly every function that has a
        <parameter>path</parameter> argument also expects a
        <parameter>root</parameter> argument.  This
        <structname>svn_fs_root_t</structname> argument describes
        either a revision or a Subversion transaction (which is
        usually just a revision-to-be), and provides that
        third-dimensional context needed to understand the difference
        between <filename>/foo/bar</filename> in revision 32, and the
        same path as it exists in revision 98.  <xref
        linkend="svn.developer.layerlib.repos.dia-2"/> shows revision history as an
        added dimension to the Subversion filesystem universe.</para>

      <para>Naturalmente, il filesystem di Subversion ha un'eccezionale terza
        dimensione che la maggior parte dei filesystem non hanno&mdash;il tempo!
        <footnote>
          <para>Capiamo che questo può essere come uno shock per un fan di
            fantascienza che è stato lungamente con l'impressione che il tempo fosse
            realmente la <emphasis>quarta</emphasis> dimensione, e ci
            scusiamo per ogni trauma emozionale indotto da questa
            asserzione di una differente teoria.</para>
        </footnote>
        Nell'interfaccia del filesystem, quasi ogni funzione che ha un argomento
        <parameter>percorso</parameter> prevede anche un argomento
        <parameter>root</parameter>.  Questo argomento
        <structname>svn_fs_root_t</structname> descrive
        sia una revisione sia una transazione di Subversion (che è
        usualmente una revisione a essere), e fornisce questo contesto
        tridimensionale necessario per capire la differenza
        tra <filename>/foo/bar</filename> nella revisione 32, e lo stesso
        percorso come esiste nella revisione 98.  <xref
        linkend="svn.developer.layerlib.repos.dia-2"/> mostra lo storico di revisione
        come una dimensione aggiunta all'universo del filesystem di Subversion.</para>

      <figure id="svn.developer.layerlib.repos.dia-2">
        <title>Tempo di versionamento&mdash;la terza dimensione!</title>
        <graphic fileref="images/ch08dia2.png"/>
      </figure>

      <!-- Perhaps dig into the DAG/tree layers a bit here, talking
           about the hard-link design and how that affords such
           pleasures as cheap copies.  If "bubble-up" isn't covered
           twelve other times in the book, maybe give it a go here. -->

      <para lang="en">As we mentioned earlier, the libsvn_fs API looks and feels
        like any other filesystem, except that it has this wonderful
        versioning capability.  It was designed to be usable by any
        program interested in a versioning filesystem.  Not
        coincidentally, Subversion itself is interested in that
        functionality.  But while the filesystem API should be
        sufficient for basic file and directory versioning support,
        Subversion wants more&mdash;and that is where libsvn_repos
        comes in.</para>

      <para>Come menzionato prima, l'API di libsvn_fs sembra
        come ogni altro filesystem, eccetto che ha questa meravigliosa
        capacità di versionamento.  È stata disegnata per essere usabile da ogni
        programma interessato a un filesystem di versionamento.  Non
        per coincidenza, Subversion stesso è interessato a questa
        funzionalità.  Ma mentre l'API del filesystem API dovrebbe essere
        sufficiente per il supporto di versionamento base a file e directory,
        Subversion vuole di più&mdash;e questo è dove entra libsvn_repos.</para>

      <para lang="en">The Subversion repository library (libsvn_repos) is
        basically a wrapper library around the filesystem
        functionality.  This library is responsible for creating the
        repository layout, making sure that the underlying filesystem
        is initialized, and so on.  Libsvn_repos also implements a set
        of hooks&mdash;scripts that are executed by the repository
        code when certain actions take place.  These scripts are
        useful for notification, authorization, or whatever purposes
        the repository administrator desires.  This type of
        functionality, and other utilities provided by the repository
        library, are not strictly related to implementing a versioning
        filesystem, which is why it was placed into its own
        library.</para>
      
      <para>La libreria per il repository di Subversion  (libsvn_repos) è
        essenzialmente una libreria involucro attorno alle funzionalità del filesystem.
        Questa libreria è responsabile della creazione della disposizione del
        repository, assicurandosi che il filesystem sottostante
        sia inizializzato, e così via.  Libsvn_repos implementa anche un insieme
        di ganci&mdash;script che sono eseguiti dal codice del repository
        quando certe avvengono azioni.  Questi script sono
        utili per notificare, autorizzare, o a qualunque scopo
        l'amministratore del repository desideri.  Questo tipo di
        funzionalità, e altre utilità fornite dalla libreria per il repository,
        non sono rigorosamente relative a implementare un filesystem di versionamento,
        che è il perché è stato messo all'interno della sua libreria.</para>

      <para lang="en">Developers who wish to use the libsvn_repos API will find
        that it is not a complete wrapper around the filesystem
        interface.  That is, only certain major events in the general
        cycle of filesystem activity are wrapped by the repository
        interface.  Some of these include the creation and commit of
        Subversion transactions, and the modification of revision
        properties.  These particular events are wrapped by the
        repository layer because they have hooks associated with them.
        In the future, other events may be wrapped by the repository
        API.  All of the remaining filesystem interaction will
        continue to occur directly via the libsvn_fs API, though.</para>

      <para>Gli sviluppatori che desiderano utilizzare l'API di libsvn_repos troveranno
        che non è un involucro completo attorno all'interfaccia del
        filesystem.  Questo è, solamente certi eventi maggiori nel generale ciclo
        dell'attività del filesystem sono avvolte dall'interfaccia del
        repository.  Alcuni di questi includono la creazione e il commit delle
        transazioni di Subversion, e la modifica delle proprietà di
        revisione.  Questi particolari eventi sono avvolti dallo strato del
        repository perché hanno ganci associati a loro.
        In futuro, altri eventi posso essere inglobati dall'API del repository.
        Tutti le rimanenti interazioni del filesystem
        continueranno ad occorrere direttamente attraverso l'API di libsvn_fs.</para>

      <para lang="en">For example, here is a code segment that illustrates the
        use of both the repository and filesystem interfaces to create
        a new revision of the filesystem in which a directory is
        added.  Note that in this example (and all others throughout
        this book), the <function>SVN_ERR()</function> macro simply
        checks for a non-successful error return from the function it
        wraps, and returns that error if it exists.</para>

      <para>Per esempio, questo è un segmento di codice che illustra
        l'utilizzo di entrambe le interfacce per il repository e il filesystem per creare
        una nuova revisione del filesystem nella quale una directory è
        aggiunta.  Notare che in questo esempio (e tutti gli altri all'interno di
        questo libro), la macro <function>SVN_ERR()</function> controlla semplicemente
        per un errore di non successo che ritorna dalla funzione di cui è
        l'involucro, e ritorna questo errore se esiste.</para>

      <example id="svn.developer.layerlib.repos.ex-1">
        <title>Utilizzare lo strato repository</title>

        <programlisting>
/* Create a new directory at the path NEW_DIRECTORY in the Subversion
   repository located at REPOS_PATH.  Perform all memory allocation in
   POOL.  This function will create a new revision for the addition of
   NEW_DIRECTORY.  */
static svn_error_t *
make_new_directory (const char *repos_path,
                    const char *new_directory,
                    apr_pool_t *pool)
{
  svn_error_t *err;
  svn_repos_t *repos;
  svn_fs_t *fs;
  svn_revnum_t youngest_rev;
  svn_fs_txn_t *txn;
  svn_fs_root_t *txn_root;
  const char *conflict_str;

  /* Open the repository located at REPOS_PATH.  */
  SVN_ERR (svn_repos_open (&amp;repos, repos_path, pool));

  /* Get a pointer to the filesystem object that is stored in
     REPOS.  */
  fs = svn_repos_fs (repos);

  /* Ask the filesystem to tell us the youngest revision that
     currently exists.  */
  SVN_ERR (svn_fs_youngest_rev (&amp;youngest_rev, fs, pool));

  /* Begin a new transaction that is based on YOUNGEST_REV.  We are
     less likely to have our later commit rejected as conflicting if we
     always try to make our changes against a copy of the latest snapshot
     of the filesystem tree.  */
  SVN_ERR (svn_fs_begin_txn (&amp;txn, fs, youngest_rev, pool));

  /* Now that we have started a new Subversion transaction, get a root
     object that represents that transaction.  */
  SVN_ERR (svn_fs_txn_root (&amp;txn_root, txn, pool));
  
  /* Create our new directory under the transaction root, at the path
     NEW_DIRECTORY.  */
  SVN_ERR (svn_fs_make_dir (txn_root, new_directory, pool));

  /* Commit the transaction, creating a new revision of the filesystem
     which includes our added directory path.  */
  err = svn_repos_fs_commit_txn (&amp;conflict_str, repos, 
                                 &amp;youngest_rev, txn, pool);
  if (! err)
    {
      /* No error?  Excellent!  Print a brief report of our success.  */
      printf ("Directory '%s' was successfully added as new revision "
              "'%ld'.\n", new_directory, youngest_rev);
    }
  else if (err-&gt;apr_err == SVN_ERR_FS_CONFLICT)
    {
      /* Uh-oh.  Our commit failed as the result of a conflict
         (someone else seems to have made changes to the same area 
         of the filesystem that we tried to modify).  Print an error
         message.  */
      printf ("A conflict occurred at path '%s' while attempting "
              "to add directory '%s' to the repository at '%s'.\n", 
              conflict_str, new_directory, repos_path);
    }
  else
    {
      /* Some other error has occurred.  Print an error message.  */
      printf ("An error occurred while attempting to add directory '%s' "
              "to the repository at '%s'.\n", 
              new_directory, repos_path);
    }

  /* Return the result of the attempted commit to our caller.  */
  return err;
} 
</programlisting>
      </example>

      <para lang="en">In the previous code segment, calls were made to both the
        repository and filesystem interfaces.  We could just as easily
        have committed the transaction using
        <function>svn_fs_commit_txn()</function>.  But the filesystem
        API knows nothing about the repository library's hook
        mechanism.  If you want your Subversion repository to
        automatically perform some set of non-Subversion tasks every
        time you commit a transaction (like, for example, sending an
        email that describes all the changes made in that transaction
        to your developer mailing list), you need to use the
        libsvn_repos-wrapped version of that
        function&mdash;<function>svn_repos_fs_commit_txn()</function>.
        This function will actually first run the
        <literal>pre-commit</literal> hook script if one exists, then
        commit the transaction, and finally will run a
        <literal>post-commit</literal> hook script.  The hooks provide
        a special kind of reporting mechanism that does not really
        belong in the core filesystem library itself.  (For more
        information regarding Subversion's repository hooks, see <xref
        linkend="svn.reposadmin.create.hooks" />.)</para>
      
      <para>Nel precedente segmento di codice, le chiamate vengono fatte a entrambe
        le interfacce repository e filesystem.  Si potrebbe facilmente
        aver fatto il commit della transazione utilizzando
        <function>svn_fs_commit_txn()</function>.  Ma le API del filesystem
        non conoscono niente del meccanismo dei ganci della libreria del
        repository.  Se si vuole che il proprio repository di Subversion
        effettui automaticamente qualche insieme di compiti non di Subversion ogni
        volta che si fa il commit di una transazione (come, per esempio, inviare una
        email che descrive tutti i cambiamenti fatti in quella transazione
        alla lista di posta del proprio sviluppatore), occorre utilizzare
        libsvn_repos-versione avvolta di quella funzione
        &mdash;<function>svn_repos_fs_commit_txn()</function>.
        Questa funzione eseguirà realmente prima uno script gancio
        <literal>pre-commit</literal> se ne esiste uno, poi farà
        il commit della transazione, e finalmente eseguirà uno script gancio
        <literal>post-commit</literal>.  I ganci forniscono un tipo speciale
        di meccanismo di reportistica che non appartiene veramente al nucleo
        della libreria stessa per il filesystem.  (Per maggiori
        informazioni riguardanti i gangi a repository di Subversion, vedere <xref
        linkend="svn.reposadmin.create.hooks" />.)</para>

      <para lang="en">The hook mechanism requirement is but one of the reasons
        for the abstraction of a separate repository library from the
        rest of the filesystem code.  The libsvn_repos API provides
        several other important utilities to Subversion.  These
        include the abilities to:</para>

      <para>Il requisito per il meccanismo del gancio è una delle ragioni
        per l'astrazione di una libreria separata per il repository dal
        resto del codice del filesystem.  Le API libsvn_repos forniscono
        varie altre importanti utilità a Subversion.  Queste includono
        le abilità di:</para>

      <orderedlist>
        <listitem>
          <para lang="en">create, open, destroy, and perform recovery steps on a
            Subversion repository and the filesystem included in that
            repository.</para>

          <para>creare, aprire, distruggere, ed effettuare i passi per il ripristino
            su un repository di Subversion e il filesystem incluso in questo
            repository.</para>
        </listitem>
        <listitem>
          <para lang="en">describe the differences between two filesystem
            trees.</para>

          <para>descrivere le differenze tra due alberi di
            filesystem.</para>
        </listitem>
        <listitem>
          <para lang="en">query for the commit log messages
            associated with all (or some) of the revisions in which a
            set of files was modified in the filesystem.</para>

          <para>interrogare per i messaggi commit di registro associati
            con tutte (o alcune) delle revisioni nelle quali un insieme
            di file fosse modificato nel filesystem.</para>
        </listitem>
        <listitem>
          <para lang="en">generate a human-readable <quote>dump</quote> of the
            filesystem, a complete representation of the revisions in
            the filesystem.</para>

          <para>generare un <quote>dump</quote> del filesystem leggibile dalle
            persone, una rappresentazione completa delle revisioni nel
            filesystem.</para>
        </listitem>
        <listitem>
          <para lang="en">parse that dump format, loading the dumped revisions
            into a different Subversion repository.</para>

          <para>interpretare il formato di questo dump, caricando la revisione di cui
            è stato fatto il dump in un repository di Subversion diverso.</para>
        </listitem>
      </orderedlist>

      <para lang="en">As Subversion continues to evolve, the repository library
        will grow with the filesystem library to offer increased
        functionality and configurable option support.</para>

      <para>Dato che Subversion continua ad evolversi, la libreria per il repository
        crescerà con la libreria per il filesystem per offrire funzionalità
        incrementate e il supporto a opzioni configurabili.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.layerlib.ra">
      <title>Strato di accesso al repository</title>

      <para lang="en">If the Subversion Repository Layer is at <quote>the other
        end of the line</quote>, the Repository Access Layer is the
        line itself.  Charged with marshalling data between the client
        libraries and the repository, this layer includes the
        libsvn_ra module loader library, the RA modules themselves
        (which currently includes libsvn_ra_dav, libsvn_ra_local, and
        libsvn_ra_svn), and any additional libraries needed by one or
        more of those RA modules, such as the mod_dav_svn Apache
        module with which libsvn_ra_dav communicates or
        libsvn_ra_svn's server, <command>svnserve</command>.</para>

      <para>Se lo strato per il repository Subversion è <quote>all'altro
        capo della linea</quote>, lo strato per l'accesso al repository è
        la linea stessa.  Caricato dei dati di ordinamento tra le librerie client
        e il repository, questo strato include la libreria per il caricamento
        del modulo libsvn_ra, i moduli RA stessi
        (che correntemente includono libsvn_ra_dav, libsvn_ra_local, e
        libsvn_ra_svn), e ogni libreria addizionale necessaria da uno o
        più di quei moduli RA, come il modulo Apache
        mod_dav_svn con cui libsvn_ra_dav comunica o il server di
        libsvn_ra_svn, <command>svnserve</command>.</para>

      <para lang="en">Since Subversion uses URLs to identify its repository
        resources, the protocol portion of the URL schema (usually
        <literal>file:</literal>, <literal>http:</literal>,
        <literal>https:</literal>, or <literal>svn:</literal>) is used
        to determine which RA module will handle the communications.
        Each module registers a list of the protocols it knows how to
        <quote>speak</quote> so that the RA loader can, at runtime,
        determine which module to use for the task at hand.  You can
        determine which RA modules are available to the Subversion
        command-line client, and what protocols they claim to support,
        by running <command>svn --version</command>:</para>
     
      <para>Da allora Subversion utilizza gli URL per identificare le risorse
        dei suoi repository, la porzione del protocollo dello schema URL (usualmente
        <literal>file:</literal>, <literal>http:</literal>,
        <literal>https:</literal>, o <literal>svn:</literal>) è utilizzato
        per determinare quale modulo RA si occuperà della comunicazione.
        Ogni modulo registra una lista di protocolli che riesce a
        <quote>parlare</quote> così che il caricatore RA può, in esecuzione,
        determinare quale modulo utilizzare per il compito attuale.  Si può
        determinare quali moduli RA sono disponibili al client a riga di comando
        di Subversion, e quali protocolli sostengono di supportare,
        eseguendo <command>svn --version</command>:</para>

      <screen>
$ svn --version
svn, version 1.2.3 (r15833)
   compiled Sep 13 2005, 22:45:22

Copyright (C) 2000-2005 CollabNet.
Subversion is open source software, see http://subversion.tigris.org/
This product includes software developed by CollabNet (http://www.Collab.Net/).

The following repository access (RA) modules are available:

* ra_dav : Module for accessing a repository via WebDAV (DeltaV) protocol.
  - handles 'http' scheme
  - handles 'https' scheme
* ra_svn : Module for accessing a repository using the svn network protocol.
  - handles 'svn' scheme
* ra_local : Module for accessing a repository on local disk.
  - handles 'file' scheme

</screen>
    
      <sect3 id="svn.developer.layerlib.ra.dav">
        <title>RA-DAV (Accesso al repository utilizzando HTTP/DAV)</title>

        <para lang="en">The libsvn_ra_dav library is designed for use by clients
          that are being run on different machines than the servers
          with which they communicating, specifically servers reached
          using URLs that contain the <literal>http:</literal> or
          <literal>https:</literal> protocol portions.  To understand
          how this module works, we should first mention a couple of
          other key components in this particular configuration of the
          Repository Access Layer&mdash;the powerful Apache HTTP
          Server, and the Neon HTTP/WebDAV client library.</para>
  
        <para>La libreria libsvn_ra_dav è disegnata per essere utilizzata dai
          client che vengono eseguiti su macchine diverse dai server
          con cui loro comunicano, specificamente server raggiunti
          utilizzando URL che contengono le porzioni protocollo <literal>http:</literal>
          oppure <literal>https:</literal>.  Per capire come questo modulo
          funziona, dobbiamo prima menzionare un paio di altri
          componenti chiave in questa particolare configurazione dello strato
          di accesso al repository&mdash;il potente server HTTP Apache,
          e la libreria client HTTP/WebDAV Neon.</para>

        <para lang="en">Subversion's primary network server is the Apache HTTP
          Server.  Apache is a time-tested, extensible open-source
          server process that is ready for serious use.  It can
          sustain a high network load and runs on many platforms.  The
          Apache server supports a number of different standard
          authentication protocols, and can be extended through the
          use of modules to support many others.  It also supports
          optimizations like network pipelining and caching.  By using
          Apache as a server, Subversion gets all of these features
          for free.  And since most firewalls already allow HTTP
          traffic to pass through, system administrators typically
          don't even have to change their firewall configurations to
          allow Subversion to work.</para>
  
        <para>Il server di rete primario di Subversion è il server HTTP Apache.
          Apache è un processo server testato da tempo, estendibile e open-source
          che è pronto per un utilizzo serio.  Può sostenere
          un alto carico di rete e essere eseguito su molte piattaforme.  Il
          server Apache supporta un numero di differenti protocolli di
          autenticazione standard, e può essere esteso attraverso l'utilizzo
          di moduli per supportarne molti altri.  Supporta anche
          ottimizzazioni come il pipelining e il caching di rete.  Utilizzando
          Apache come server, Subversion ottiene tutte queste caratteristiche
          gratuitamente.  E dato che la maggior parte dei firewall permettono già
          al traffico HTTP di attraversarli, tipicamente gli amministratori di sistema
          non hanno neppure da cambiare la configurazione dei propri firewall
          per permettere a Subversion di funzionare.</para>

        <para lang="en">Subversion uses HTTP and WebDAV (with DeltaV) to
          communicate with an Apache server.  You can read more about
          this in the WebDAV section of this chapter, but in short,
          WebDAV and DeltaV are extensions to the standard HTTP 1.1
          protocol that enable sharing and versioning of files over
          the web.  Apache 2.0 and later versions come with mod_dav,
          an Apache module that understands the DAV extensions to
          HTTP.  Subversion itself supplies mod_dav_svn, though, which
          is another Apache module that works in conjunction with
          (really, as a back-end to) mod_dav to provide Subversion's
          specific implementations of WebDAV and DeltaV.</para>

        <para>Subversion utilizza HTTP e WebDAV (con DeltaV) per
          comunicare con un server Apache.  Si può leggere altro a proposito
          di questo nella sezione di WebDAV in questo capitolo, ma in breve,
          WebDAV e DeltaV sono estensioni al protocollo standard HTTP 1.1
          che abilita la condivisione e il versionamento di file sul
          web.  Apache 2.0 e versioni più recenti hanno mod_dav,
          un modulo Apache che comprende le estensioni DAV a
          HTTP.  Subversion stesso fornisce mod_dav_svn, che è
          un altro modulo Apache che funziona in congiunzione con
          (veramente, come un sottostrato di) mod_dav per fornire implementazioni
          specifiche di Subversion a WebDAV e DeltaV.</para>

        <para lang="en">When communicating with a repository over HTTP, the RA
          loader library chooses libsvn_ra_dav as the proper access
          module.  The Subversion client makes calls into the generic
          RA interface, and libsvn_ra_dav maps those calls (which
          embody rather large-scale Subversion actions) to a set of
          HTTP/WebDAV requests.  Using the Neon library, libsvn_ra_dav
          transmits those requests to the Apache server.  Apache
          receives these requests (exactly as it does generic HTTP
          requests that your web browser might make), notices that the
          requests are directed at a URL that is configured as a DAV
          location (using the <literal>&lt;Location&gt;</literal>
          directive in <filename>httpd.conf</filename>), and hands the
          request off to its own mod_dav module.  When properly
          configured, mod_dav knows to use Subversion's mod_dav_svn for
          any filesystem-related needs, as opposed to the generic
          mod_dav_fs that comes with Apache.  So ultimately, the client
          is communicating with mod_dav_svn, which binds directly to the
          Subversion Repository Layer.</para>
  
        <para>Quando comunica con un repository sopra HTTP, il caricatore
          di libreria RA sceglie libsvn_ra_dav come modulo di accesso
          adeguato.  Il client Subversion effettua chiamate nella interfaccia
          generica RA, e libsvn_ra_dav mappa queste chiamate (che
          comprendono una scala piuttosto ambia di azioni di Subversion)
          ad un insieme di richieste HTTP/WebDAV.  Utilizzando la libreria Neon,
          libsvn_ra_dav trasmette queste richieste al server Apache.  Apache
          riceve queste richieste (esattamente come come richieste HTTP
          generiche che potrebbe fare il proprio navigatore web), avvisando che
          le richieste sono dirette a una URL che è configurata come una posizione
          DAV (utilizzando la direttiva <literal>&lt;Location&gt;</literal>
          in <filename>httpd.conf</filename>), e passa la richiesta
          al proprio modulo mod_dav.  Quando adeguatamente
          configurato, mod_dav sa utilizzare mod_dav_svn di Subversion per
          ogni necessità relativa al filesystem, come opposto al generico
          mod_dav_fs che viene fornito con Apache.  Così infine, il client
          sta comunicando con mod_dav_svn, che si lega direttamente allo
          strato repository di Subversion.</para>

        <para lang="en">That was a simplified description of the actual
          exchanges taking place, though.  For example, the Subversion
          repository might be protected by Apache's authorization
          directives.  This could result in initial attempts to
          communicate with the repository being rejected by Apache on
          authorization grounds.  At this point, libsvn_ra_dav gets
          back the notice from Apache that insufficient identification
          was supplied, and calls back into the Client Layer to get
          some updated authentication data.  If the data is supplied
          correctly, and the user has the permissions that Apache
          seeks, libsvn_ra_dav's next automatic attempt at performing
          the original operation will be granted, and all will be
          well.  If sufficient authentication information cannot be
          supplied, the request will ultimately fail, and the client
          will report the failure to the user.</para>
  
        <para>Questa era una descrizione semplificata degli scambi
          attuali che avvengono.  Per esempio, il repository Subversion
          potrebbe essere protetto delle direttive di autorizzazione di
          Apache.  Questo può risultare in tentativi iniziali di comunicazione
          con il repository che vengono respinti da Apache
          per motivi di autorizzazione.  A questo punto, libsvn_ra_dav ottiene
          come risposta l'avviso da Apache che è stata fornita un'identificazione
          insufficiente, e ritorna indietro nello strato client per ottenere
          qualche dato di autenticazione aggiornato.  Se il dato viene fornito
          correttamente, e l'utente ha i permessi che Apache
          cerca, il tentativo automatico successivo di libsvn_ra_dav di effettuare
          l'operazione originale verrà assegnato, e tutto andrà
          bene.  Se informazioni di autenticazione sufficienti non possono essere
          fornite, la richiesta finalmente fallirà, e il client
          riporterà il fallimento all'utente.</para>

        <!-- A diagram here? -->
  
        <para lang="en">By using Neon and Apache, Subversion gets free
          functionality in several other complex areas, too.  For
          example, if Neon finds the OpenSSL libraries, it allows the
          Subversion client to attempt to use SSL-encrypted
          communications with the Apache server (whose own mod_ssl can
          <quote>speak the language</quote>).  Also, both Neon itself
          and Apache's mod_deflate can understand the
          <quote>deflate</quote> algorithm (the same one used by the
          PKZIP and gzip programs), so requests can be sent in smaller,
          compressed chunks across the wire.  Other complex features
          that Subversion hopes to support in the future include the
          ability to automatically handle server-specified redirects
          (for example, when a repository has been moved to a new
          canonical URL) and taking advantage of HTTP
          pipelining.</para>
  
        <para>Utilizzando Neon e Apache, Subversion ottiene funzionalità
          gratuite anche in varie altre complesse aree.  Per
          esempio, se Neon trova le librerie di OpenSSL, permette al client
          Subversion di tentare di utilizzare comunicazioni cifrate SSL
          con il server Apache (che possiede mod_ssl che può
          <quote>parlare la lingua</quote>).  Inoltre, sia Neon stesso
          che mod_deflate di Apache possono capire l'algoritmo
          <quote>deflate</quote> (lo stesso utilizzato dai programmi
          PKZIP e gzip), così che le richieste possono essere inviate in pezzi
          più piccoli e compressi attraverso il collegamento.  Altre caratteristiche
          complesse che Subversion spera di supportare in futuro includono
          l'abilità di maneggiare automaticamente redirezioni specificate dal server
          (per esempio, quando un repository è stato spostato a un nuovo
          URL canonico) e prendere del vantaggio dal pipelining HTTP.</para>

        <!-- Talk about another difference between CVS and Subversion.
             CVS users had to specify which auth mechanism to use
             (with :ext: vs. :pserver:) and whether or not to use
             compressed communications (with the -z option).  In
             Subversion, Apache takes some of that responsibility.
             The server will tell the client whether it can understand
             compression, and ... hmm.  Is this really true? -->

      </sect3>

      <sect3 id="svn.developer.layerlib.ra.svn">
        <title>RA-SVN (Accesso con protocollo personalizzato al repository)</title>

        <para lang="en">In addition to the standard HTTP/WebDAV protocol,
          Subversion also provides an RA implementation that uses a
          custom protocol.  The libsvn_ra_svn module implements
          its own network socket connectivity, and communicates with a
          stand-alone server&mdash;the <filename>svnserve</filename>
          program&mdash;on the machine that hosts the
          repository.  Clients access the repository using the
          <literal>svn://</literal> schema.</para>

        <para>In aggiunta al protocollo standard HTTP/WebDAV,
          Subversion fornisce anche una implementazione RA che utilizza
          un protocollo personalizzato.  Il modulo libsvn_ra_svn implementa
          il proprio socket di connettività di rete, e comunica con un server
          autonomo&mdash;il programma <filename>svnserve</filename>
          &mdash; sulla macchina che ospita il
          repository.  I client accedono al repository utilizzando lo schema
          <literal>svn://</literal>.</para>

        <para lang="en">This RA implementation lacks most of the advantages of
          Apache mentioned in the previous section; however, it may be
          appealing to some system administrators nonetheless.  It is
          dramatically easier to configure and run; setting up an
          <filename>svnserve</filename> process is nearly
          instantaneous.  It is also much smaller (in terms of lines
          of code) than Apache, making it much easier to audit, for
          security reasons or otherwise.  Furthermore, some system
          administrators may already have an SSH security
          infrastructure in place, and want Subversion to use it.
          Clients using ra_svn can easily tunnel the protocol over
          SSH.</para>

        <para>Questa implementazione di RA difetta di molti dei vantaggi di
          Apache menzionati nella precedente sezione; tuttavia, può fare
          appello a qualche amministratore di sistema ciò nonostante.  È
          drammaticamente facile da configurare ed eseguire; mettere in opera
          il processo <filename>svnserve</filename> è quasi
          istantaneo.  È anche molto più piccolo (in termini di linee di
          codice) di Apache, rendendolo molto più facile da verificare, per
          ragioni di sicurezza o altrimenti.  Ancora, qualche amministratore
          di sistema può già avere una infrastruttura di sicurezza SSH
          sul posto, e volere che Subversion la utilizzi.
          I client utilizzando ra_svn possono facilmente fare il tunnel del
          protocollo sopra SSH.</para>

      </sect3>

      <sect3 id="svn.developer.layerlib.ra.local">
        <title>RA-Local (Accesso diretto al repository)</title>

        <para lang="en">Not all communications with a Subversion repository
          require a powerhouse server process and a network layer.
          For users who simply wish to access the repositories on
          their local disk, they may do so using
          <literal>file:</literal> URLs and the functionality provided
          by libsvn_ra_local.  This RA module binds directly with the
          repository and filesystem libraries, so no network
          communication is required at all.</para>

        <para>Non tutte le comunicazioni con un repository Subversion
          richiedono un processo server e uno strato di rete.
          Per utenti che semplicemente desiderano accedere ai repository nel
          loro disco locale, lo possono fare utilizzando l'URL
          <literal>file:</literal> e la funzionalità fornita da
          libsvn_ra_local.  Questo modulo RA si lega direttamente con il
          repository e le librerie del filesystem, così nessuna comunicazione di
          rete è affatto richiesta.</para>

        <para lang="en">Subversion requires that the server name included as part
          of the <literal>file:</literal> URL be either
          <literal>localhost</literal> or empty, and that there be no
          port specification.  In other words, your URLs should look
          like either
          <literal>file://localhost/path/to/repos</literal> or
          <literal>file:///path/to/repos</literal>.</para>

        <para>Subversion richiede che il nome del server incluso come parte
          dell'URL <literal>file:</literal> sia
          <literal>localhost</literal> o vuoto, e che possa non essere
          specificata la porta.  In altre parole, l'URL dovrebbe
          assomigliare o a
          <literal>file://localhost/path/to/repos</literal> o a
          <literal>file:///path/to/repos</literal>.</para>

        <para lang="en">Also, be aware that Subversion's
          <literal>file:</literal> URLs cannot be used in a regular
          web browser the way typical <literal>file:</literal> URLs
          can.  When you attempt to view a <literal>file:</literal>
          URL in a regular web browser, it reads and displays the
          contents of the file at that location by examining the
          filesystem directly.  However, Subversion's resources exist
          in a virtual filesystem (see <xref
          linkend="svn.developer.layerlib.repos" />), and your browser will not
          understand how to read that filesystem.</para>

        <para>Inoltre, occorre essere informati che l'URL di Subversion
          <literal>file:</literal> non può essere utilizzato in un regolare
          esploratore web nel tipico modo che l'URL <literal>file:</literal> può.
          Quando si tenta di visualizzare un URL <literal>file:</literal>
          in un regolare esploratore web, questo legge e visualizza i contenuti
          dei file a questa posizione esaminando direttamente il
          filesystem.  Tuttavia, le risorse di Subversion esistono
          in un filesystem virtuale (vedere <xref
          linkend="svn.developer.layerlib.repos" />), e il proprio esploratore
          non capirà come leggere questo filesystem.</para>

      </sect3>

      <sect3 id="svn.developer.layerlib.ra.yours">
        <title>La vostra libreria RA qui</title>

        <para lang="en">For those who wish to access a Subversion repository
          using still another protocol, that is precisely why the
          Repository Access Layer is modularized!  Developers can
          simply write a new library that implements the RA interface
          on one side and communicates with the repository on the
          other.  Your new library can use existing network protocols,
          or you can invent your own.  You could use inter-process
          communication (IPC) calls, or&mdash;let's get crazy, shall
          we?&mdash;you could even implement an email-based protocol.
          Subversion supplies the APIs; you supply the creativity.</para>

        <para>Per chi desiderasse accedere al repository di Subversion
          utilizzando ancora un altro protocollo, questo è esattamente il
          perché lo strato di accesso al repository è modularizzato!  Gli
          sviluppatori possono semplicemente scrivere una nuova libreria che
          implementa l'interfaccia di RA
          da una parte e comunicare con il repository dall'altra.
          La propria nuova libreria può utilizzare protocolli di rete esistenti,
          o se ne può inventare dei propri.  Si possono utilizzare chiamate a
          comunicazioni tra processi (IPC), o&mdash;let's get crazy, shall
          we?&mdash;si può anche implementare un protocollo basato sulla posta
          elettronica. Subversion fornisce le API; voi fornite la creatività.</para>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.layerlib.client">
      <title>Strato client</title>
      
      <para lang="en">On the client side, the Subversion working copy is where
        all the action takes place.  The bulk of functionality
        implemented by the client-side libraries exists for the sole
        purpose of managing working copies&mdash;directories full of
        files and other subdirectories which serve as a sort of local,
        editable <quote>reflection</quote> of one or more repository
        locations&mdash;and propagating changes to and from the
        Repository Access layer.</para>

      <para>Dalla parte del client, la copia di lavoro di Subversion è dove
        tutte le azioni hanno luogo.  La massa delle funzionalità
        implementate delle librerie lato client esiste per il solo
        scopo di gestire le copie di lavoro&mdash;directory piene di
        file e altre sottodirectory che servono come una sorta di locale,
        modificabile <quote>riflessione</quote> di uno o più posizioni di
        repository&mdash;e propagare cambiamenti allo e dallo strato di
        accesso al repository.</para>

      <para lang="en">Subversion's working copy library, libsvn_wc, is directly
        responsible for managing the data in the working copies.  To
        accomplish this, the library stores administrative information
        about each working copy directory within a special
        subdirectory.  This subdirectory, named
        <filename>.svn</filename>, is present in each working copy
        directory and contains various other files and directories
        which record state and provide a private workspace for
        administrative action.  For those familiar with CVS, this
        <filename>.svn</filename> subdirectory is similar in purpose
        to the <filename>CVS</filename> administrative directories
        found in CVS working copies.  For more information about the
        <filename>.svn</filename> administrative area, see <xref
        linkend="svn.developer.insidewc"/>in this chapter.</para>

      <para>La libreria per copie di lavoro di Subversion, libsvn_wc, è direttamente
        responsabile della gestione dei dati nelle copie di lavoro.  Per
        compiere questo, la libreria immagazzina informazioni amministrative
        circa ogni directory della copia di lavoro all'interno di una
        sottodirectory speciale.  Questa sottodirectory, di nome
        <filename>.svn</filename>, è presente in ogni directory della copia di
        lavoro e contiene vari altri file e directory
        che registrano lo stato e forniscono uno spazio di lavoro privato per
        azioni amministrative.  Per chi ha familiarità con CVS, questa
        sottodirectory <filename>.svn</filename> è simile nello scopo
        alle directory amministrative <filename>CVS</filename>
        che si trovano nelle copie di lavoro di CVS.  Per maggiori informazioni
        circa l'area amminstrativa <filename>.svn</filename>, vedere <xref
        linkend="svn.developer.insidewc"/>in questo capitolo.</para>

      <para lang="en">The Subversion client library, libsvn_client, has the
        broadest responsibility; its job is to mingle the
        functionality of the working copy library with that of the
        Repository Access Layer, and then to provide the highest-level
        API to any application that wishes to perform general revision
        control actions.  For example, the function
        <function>svn_client_checkout()</function> takes a URL as an
        argument.  It passes this URL to the RA layer and opens an
        authenticated session with a particular repository.  It then
        asks the repository for a certain tree, and sends this tree
        into the working copy library, which then writes a full
        working copy to disk (<filename>.svn</filename> directories
        and all).</para>

      <para>La libreria del client di Subversion, libsvn_client, ha la più
        vasta responsabilità; il suo lavoro è di mescolare le
        funzionalità della libreria della copia di lavoro con quella dello
        strato di accesso al repository, e poi di fornire il più alto livello
        delle API a qualunque applicazione che desidera eseguire azioni di controllo
        di revisione.  Per esempio, la funzione
        <function>svn_client_checkout()</function> prende un URL come
        argomento.  Passa questo URL allo strato RA e apre una sessione
        autenticata con un particolare repository.  Poi chiede
        al repository un certo albero, e invia questo albero
        alla libreria per la copia di lavoro, che poi scrive una copia di
        lavoro completa su disco (le directory <filename>.svn</filename>
        e tutti).</para>

      <para lang="en">The client library is designed to be used by any
        application.  While the Subversion source code includes a
        standard command-line client, it should be very easy to write
        any number of GUI clients on top of the client library.  New
        GUIs (or any new client, really) for Subversion need not be
        clunky wrappers around the included command-line
        client&mdash;they have full access via the libsvn_client API
        to same functionality, data, and callback mechanisms that the
        command-line client uses.</para>

      <para>La libreria del client è disegnata per essere utilizzata da qualunque
        applicazione.  Mentre il codice sorgente di Subversion include un
        client standard a linea di comando, dovrebbe essere molto facile scrivere
        qualunque numero di client con GUI sopra la libreria del client.  Nuove
        GUI (o qualunque nuovo client, veramente) per Subversion need not be
        clunky wrappers attorno al client a linea di comando
        incluso&mdash;hanno pieno accesso attraverso le API di libsvn_client
        alle stesse funzionalità, dati, e ai meccanismi di callback che utilizza
        il client a linea di comando.</para>

      <sidebar>
        <title>Legarsi direttamente&mdash;una parola circa la precisione</title>

        <para lang="en">Why should your GUI program bind directly with a
          libsvn_client instead of acting as a wrapper around a
          command-line program?  Besides simply being more efficient,
          this can address potential correctness issues as well.  A
          command-line program (like the one supplied with Subversion)
          that binds to the client library needs to effectively
          translate feedback and requested data bits from C types to
          some form of human-readable output.  This type of
          translation can be lossy.  That is, the program may not
          display all of the information harvested from the API, or
          may combine bits of information for compact representation.</para>

        <para>Perché il proprio programma GUI dovrebbe legarsi direttamente con
          un libsvn_client invece di agire come un involucro attorno a un
          programma a linea di comando?  Oltre a diventare semplicemente più
          efficiente, questo può anche indirizzare potenziali problemi di 
          precisione.  Un programma a linea di comando (come quello fornito con
          Subversion) che si lega alla libreria del client necessita di tradurre
          effettivamente il feedback e i bit di dati richiesti da tipi C a
          qualche forma di output leggibile dalle persone.  Questo tipo di
          traduzione può essere con perdita.  Questo è, il programma non può
          mostrare tutte le informazioni raccolte dalle API, oppure
          può combinare i bit di informazione per una rappresentazione compatta.</para>

        <para lang="en">If you wrap such a command-line program with yet another
          program, the second program has access only to
          already-interpreted (and as we mentioned, likely incomplete)
          information, which it must <emphasis>again</emphasis>
          translate into <emphasis>its</emphasis> representation
          format.  With each layer of wrapping, the integrity of the
          original data is potentially tainted more and more, much
          like the result of making a copy of a copy (of a copy &hellip;)
          of a favorite audio or video cassette.</para>

        <para>Se si avvolge tale programma a linea di comando con un altro programma
          ancora, il secondo programma ha accesso solamente a
          informazioni già interpretate (e come menzionato, probabilmente
          incomplete), che può tradurre <emphasis>ancora</emphasis>
          nel <emphasis>proprio</emphasis> formato di rappresentazione.
          Con ogni strato dell'involucro, l'integrità del dato originale
          è potenzialmente alterata sempre più, tanto come
          il risultato di fare una copia di una copia (di una copia &hellip;)
          di una casetta audio o video favorita.</para>

      </sidebar>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.developer.usingapi">
    <title>Utilizzare le API</title>

    <para lang="en">Developing applications against the Subversion library APIs
      is fairly straightforward.  All of the public header files live
      in the <filename>subversion/include</filename> directory of the
      source tree.  These headers are copied into your system
      locations when you build and install Subversion itself from
      source.  These headers represent the entirety of the functions
      and types meant to be accessible by users of the Subversion
      libraries.</para>

    <para>Sviluppare applicazioni sopra le API della libreria di Subversion
      è ragionevolmente diretto.  Tutti i file header pubblici sono
      nella directory <filename>subversion/include</filename> dell'albero
      dei sorgenti.  Questi header sono copiati nelle posizioni di
      sistema quando si compila e si installa Subversion stesso dai
      sorgenti.  Questi header rappresentano l'interezza delle funzioni
      e dei tipi fatti per essere accessibili dagli utenti delle
      librerie di Subversion.</para>

    <para lang="en">The first thing you might notice is that Subversion's
      datatypes and functions are namespace protected.  Every public
      Subversion symbol name begins with <literal>svn_</literal>,
      followed by a short code for the library in which the symbol is
      defined (such as <literal>wc</literal>,
      <literal>client</literal>, <literal>fs</literal>, etc.),
      followed by a single underscore (<literal>_</literal>) and
      then the rest of the symbol name.  Semi-public functions (used
      among source files of a given library but not by code outside
      that library, and found inside the library directories
      themselves) differ from this naming scheme in that instead of a
      single underscore after the library code, they use a double
      underscore (<literal>__</literal>).  Functions that are private
      to a given source file have no special prefixing, and are declared
      <literal>static</literal>.  Of course, a compiler isn't
      interested in these naming conventions, but they help to clarify
      the scope of a given function or datatype.</para>

    <para>La prima cosa che si può notare è che i tipi dati di Subversion
      e le funzioni sono spazi di nomi protetti.  Ogni nome di simbolo pubblico
      di Subversion inizia con <literal>svn_</literal>,
      seguito da un codice corto per la libreria nella quale il simbolo è
      definito (come <literal>wc</literal>,
      <literal>client</literal>, <literal>fs</literal>, etc.),
      seguito da un singolo trattino basso (<literal>_</literal>) e poi
      dal resto del nome del simbolo.  Funzioni parzialmente pubbliche (utilizzate
      fra file sorgenti di una data libreria ma non dal codice esterno
      a questa libreria, e si trova all'interno delle directory stesse della
      libreria) differiscono da questa schema di nomi in quanto anziché di un
      singolo trattino basso dopo il codice libreria, utilizzano un doppio
      trattino basso (<literal>__</literal>).  Le funzioni che sono private
      a un dato file sorgente non hanno prefissi particolari, e sono dichiarate
      <literal>static</literal>.  Naturalmente, un compilatore non è
      interessato a queste convenzioni di nomi, ma aiutano a chiarire
      lo scopo di una data funzione o tipo di dato.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.usingapi.apr">
      <title>La libreria runtime portatile di Apache</title>

      <para lang="en">Along with Subversion's own datatypes, you will see many
        references to datatypes that begin with
        <literal>apr_</literal>&mdash;symbols from the Apache
        Portable Runtime (APR) library.  APR is Apache's portability
        library, originally carved out of its server code as an
        attempt to separate the OS-specific bits from the
        OS-independent portions of the code.  The result was a library
        that provides a generic API for performing operations that
        differ mildly&mdash;or wildly&mdash;from OS to OS.  While the
        Apache HTTP Server was obviously the first user of the APR
        library, the Subversion developers immediately recognized the
        value of using APR as well.  This means that there are
        practically no OS-specific code portions in Subversion itself.
        Also, it means that the Subversion client compiles and runs
        anywhere that the server does.  Currently this list includes
        all flavors of Unix, Win32, BeOS, OS/2, and Mac OS X.</para>

      <para>Oltre ai tipi di dato di Subversion, si vedranno molte
        referenze a tipi di dato che iniziano con
        <literal>apr_</literal>&mdash;simboli dalla libreria
        runtime portabile di Apache (APR).  APR è la libreria della
        portabilità di Apache, originariamente fuoriuscita dal codice del server
        come un tentativo di separare i bit specifici del sistema operativo dalle
        porzioni di codice indipendenti dal sistema operativo.  Il risultato è
        stata una libreria che fornisce un'API generica per eseguire operazioni che
        differiscono leggermente&mdash;o molto&mdash;da sistema operativo a
        sistema operativo.  Mentre il server HTTP
        Apache era ovviamente il primo utente della libreria APR,
        gli sviluppatori di Subversion immediatamente hanno riconosciuto il
        valore dell'utilizzare APR pure loro.  Questo significa che ci sono
        praticamente porzioni di codice non specifiche di un sistema operativo
        in Subversion stesso.
        Inoltre, significa che il client di Subversion compila e si esegue
        ovunque lo fa il server.  Correntemente questa lista include
        tutti i tipi di Unix, Win32, BeOS, OS/2, e Mac OS X.</para>

      <para lang="en">In addition to providing consistent implementations of
        system calls that differ across operating systems,
        <footnote>
          <para>Subversion uses ANSI system calls and datatypes as much
            as possible.</para>
        </footnote>
        APR gives Subversion immediate access to many custom
        datatypes, such as dynamic arrays and hash tables.  Subversion
        uses these types extensively throughout the codebase.  But
        perhaps the most pervasive APR datatype, found in nearly every
        Subversion API prototype, is the
        <structname>apr_pool_t</structname>&mdash;the APR memory pool.
        Subversion uses pools internally for all its memory allocation
        needs (unless an external library requires a different memory
        management schema for data passed through its API),
        <footnote>
          <para>Neon and Berkeley DB are examples of such libraries.</para>
        </footnote>
        and while a person coding against the Subversion APIs is
        not required to do the same, they are required to provide
        pools to the API functions that need them.  This means that
        users of the Subversion API must also link against APR, must
        call <function>apr_initialize()</function> to initialize the
        APR subsystem, and then must acquire a pool for use with
        Subversion API calls.  See <xref linkend="svn.developer.pools"/>
        for more information.</para>

      <para>Oltre a fornire implementazioni consistenti delle chiamate
        di sistema che differiscono tra i sistemi operativi,
        <footnote>
          <para>Subversion utilizza chiamate di sistema ANSI e tipi di dato il
            più possibile.</para>
        </footnote>
        APR da a Subversion l'accesso immediato a molti tipi di dato
        personalizzati, come array dinamici a tabelle hash.  Subversion
        utilizza questi tipi estensivamente attraverso il codice base.  Ma
        forse il più pervasivo tipo di dato di APR, che si trova in quasi ogni
        prototipo delle API di Subversion, è
        <structname>apr_pool_t</structname>&mdash;il pool di memoria di APR.
        Subversion utilizza i pool internamente per tutte le proprie necessità di
        allocazione di memoria (a meno che una libreria esterna richieda uno
        schema di gestione della memoria differente per i dati passati attraverso
        le proprie API),
        <footnote>
          <para>Neon e Berkeley DB sono esempi di questo tipo librerie.</para>
        </footnote>
        e mentre a una persona che scrive codice con le API di Subversion non è
        richiesto di fare lo stesso, sono richiesti per fornire
        i pool alle funzioni delle API che li necessitano.  Questo significa che
        gli utenti delle API di Subversion devono anche collegare l'APR, devono
        chiamare <function>apr_initialize()</function> per inizializzare il
        sottosistema APR, e poi devono acquisire un pool per utilizzarlo con
        le chiamate alle API di Subversion.  Vedere <xref linkend="svn.developer.pools"/>
        per maggiori informazioni.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.usingapi.urlpath">
      <title>Requisiti di URL e percorsi</title>

      <para lang="en">With remote version control operation as the whole point
        of Subversion's existence, it makes sense that some attention
        has been paid to internationalization (i18n) support.  After
        all, while <quote>remote</quote> might mean <quote>across the
        office</quote>, it could just as well mean <quote>across the
        globe.</quote> To facilitate this, all of Subversion's public
        interfaces that accept path arguments expect those paths to be
        canonicalized, and encoded in UTF-8.  This means, for example,
        that any new client binary that drives the libsvn_client
        interface needs to first convert paths from the
        locale-specific encoding to UTF-8 before passing those paths
        to the Subversion libraries, and then re-convert any resultant
        output paths from Subversion back into the locale's encoding
        before using those paths for non-Subversion purposes.
        Fortunately, Subversion provides a suite of functions (see
        <filename>subversion/include/svn_utf.h</filename>) that can be
        used by any program to do these conversions.</para>

      <para>Con operazioni remote di controllo di versione come punto centrale
        dell'esistenza di Subversion, ha senso che qualche attenzione
        sia stata data al supporto all'internazionalizzazione (i18n).  Dopo
        tutto, mentre <quote>remoto</quote> può significare <quote>attraverso
        l'ufficio</quote>, it could just as well mean <quote>across the
        globe.</quote> Per facilitare questo, tutte le interfacce
        pubbliche di Subversion che accettano percorsi come argomenti si aspettano
        che quei percorsi siano
        canonizzati, e codificati in UTF-8.  Questo significa, per esempio,
        che ogni nuovo client binario che utilizza l'interfaccia di libsvn_client
        necessita prima di convertire i percorsi dalla codifica specifica
        locale a UTF-8 prima passando questi percorsi
        alle librerie di Subversion, e poi convertendo di nuovo ogni percorso
        risultante da Subversion indietro alla codifica locale
        prima di utilizzare questi percorsi per scopi diversi da Subversion.
        Fortunatamente, Subversion fornisce un insieme di funzioni (vederer
        <filename>subversion/include/svn_utf.h</filename>) che possono essere
        utilizzate da ogni programma per effettuare queste conversioni.</para>

      <para lang="en">Also, Subversion APIs require all URL parameters to be
        properly URI-encoded.  So, instead of passing <systemitem
        class="url">file:///home/username/My File.txt</systemitem> as
        the URL of a file named <literal>My File.txt</literal>, you
        need to pass <systemitem
        class="url">file:///home/username/My%20File.txt</systemitem>.
        Again, Subversion supplies helper functions that your
        application can
        use&mdash;<function>svn_path_uri_encode()</function> and
        <function>svn_path_uri_decode()</function>, for URI encoding and
        decoding, respectively.</para>

      <para>Inoltre, le API di Subversion richiedono tutti i prametri URL di
        essere propriamente codificati come URI.  Così, invece di passare <systemitem
        class="url">file:///home/username/My File.txt</systemitem> come
        l'URL di un file di nome <literal>My File.txt</literal>, occorre
        passare <systemitem
        class="url">file:///home/username/My%20File.txt</systemitem>.
        Ancora, Subversion fornisce funzioni di aiuto che la propria
        applicazione può
        utilizzare&mdash;<function>svn_path_uri_encode()</function> e
        <function>svn_path_uri_decode()</function>, per la codifica e la decodifica
        URI, rispettivamente.</para>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.usingapi.otherlangs">
      <title>Utilizzare altri linguaggi oltre C e C++</title> 

      <para lang="en">If you are interested in using the Subversion libraries in
        conjunction with something other than a C program&mdash;say a
        Python or Perl script&mdash;Subversion has some support for this
        via the Simplified Wrapper and Interface Generator (SWIG).  The
        SWIG bindings for Subversion are located in
        <filename>subversion/bindings/swig</filename> and whilst still
        maturing, they are in a usable state.  These bindings allow you
        to call Subversion API functions indirectly, using wrappers that
        translate the datatypes native to your scripting language into
        the datatypes needed by Subversion's C libraries.</para>

      <para>Se si è interessati ad utilizzare le librerie di Subversion in
        congiunzione con qualche altro programma non scritto con il C&mdash;uno
        script Python o Perl&mdash;Subversion ha qualche supporto per questi
        attraverso il Simplified Wrapper and Interface Generator (SWIG).  I legami
        di SWIG per Subversion sono posizionati in
        <filename>subversion/bindings/swig</filename> e mentre stanno ancora
        maturando, sono in uno stato usabile.  Questi legami permettono
        di chiamare indirettamente le funzioni delle API di Subversion, utilizzando
        involucri che traducono i tipi di dato nativi nel linguaggio di script nei
        tipi di dato necessari alle librerie C di Subversion.</para>

      <para lang="en">There is an obvious benefit to accessing the Subversion
        APIs via a language binding&mdash;simplicity.  Generally
        speaking, languages such as Python and Perl are much more
        flexible and easy to use than C or C++.  The sort of
        high-level datatypes and context-driven type checking provided
        by these languages are often better at handling information
        that comes from users.  As you know, humans are proficient at
        botching up input to a program, and scripting languages tend
        to handle that misinformation more gracefully.  Of course,
        often that flexibility comes at the cost of performance.  That
        is why using a tightly-optimized, C-based interface and
        library suite, combined with a powerful, flexible binding
        language, is so appealing.</para>

      <para>C'è un ovvio beneficio ad accedere alle API di Subversion
        attraverso un legame di linguaggio&mdash;semplicità.  Generalmente
        parlando, i linguaggi come Python e Perl sono molto più
        flessibili e facili da utilizzare che C o C++.  La specie di tipi di
        dato ad alto livello e il controllo di tipo guidato dal contesto forniti
        da questi linguaggi sono spesso migliori per la gestione delle informazioni
        che arrivano dagli utenti.  Come si sa, gli esseri umani riescono
        botching up input a un programma, e i linguaggi script tendono
        a gestire queste informazioni sbagliate con più garbo.  Naturalmente,
        spesso questa flessibilità viene al costo delle prestazioni.  Questo
        è perché utilizzando una strettamente ottimizzata interfaccia basata sul
        C e un insieme di librerie, combinate con un potente, flessibile linguaggio
        di legame, è così interessante.</para>

      <para lang="en">Let's look at a sample program that uses Subversion's
        Python SWIG bindings to recursively crawl the youngest
        repository revision, and print the various paths reached
        during the crawl.</para>

      <para>Vediamo un esempio di programma che utilizza il legame SWIG per
        Python di Subversion per esplorare ricorsivamente le più recenti
        revisioni del repository, e stampare i vari percorsi raggiunti
        durante l'esplorazione.</para>

      <example id="svn.developer.usingapi.otherlangs.ex-1">
        <title>Utilizzare lo strato repository con Python</title>

        <programlisting>
#!/usr/bin/python

"""Crawl a repository, printing versioned object path names."""

import sys
import os.path
import svn.fs, svn.core, svn.repos

def crawl_filesystem_dir(root, directory, pool):
    """Recursively crawl DIRECTORY under ROOT in the filesystem, and return
    a list of all the paths at or below DIRECTORY.  Use POOL for all 
    allocations."""

    # Print the name of this path.
    print directory + "/"
    
    # Get the directory entries for DIRECTORY.
    entries = svn.fs.svn_fs_dir_entries(root, directory, pool)

    # Use an iteration subpool.
    subpool = svn.core.svn_pool_create(pool)

    # Loop over the entries.
    names = entries.keys()
    for name in names:
        # Clear the iteration subpool.
        svn.core.svn_pool_clear(subpool)

        # Calculate the entry's full path.
        full_path = directory + '/' + name

        # If the entry is a directory, recurse.  The recursion will return
        # a list with the entry and all its children, which we will add to
        # our running list of paths.
        if svn.fs.svn_fs_is_dir(root, full_path, subpool):
            crawl_filesystem_dir(root, full_path, subpool)
        else:
            # Else it's a file, so print its path here.
            print full_path

    # Destroy the iteration subpool.
    svn.core.svn_pool_destroy(subpool)

def crawl_youngest(pool, repos_path):
    """Open the repository at REPOS_PATH, and recursively crawl its
    youngest revision."""
    
    # Open the repository at REPOS_PATH, and get a reference to its
    # versioning filesystem.
    repos_obj = svn.repos.svn_repos_open(repos_path, pool)
    fs_obj = svn.repos.svn_repos_fs(repos_obj)

    # Query the current youngest revision.
    youngest_rev = svn.fs.svn_fs_youngest_rev(fs_obj, pool)
    
    # Open a root object representing the youngest (HEAD) revision.
    root_obj = svn.fs.svn_fs_revision_root(fs_obj, youngest_rev, pool)

    # Do the recursive crawl.
    crawl_filesystem_dir(root_obj, "", pool)
    
if __name__ == "__main__":
    # Check for sane usage.
    if len(sys.argv) != 2:
        sys.stderr.write("Usage: %s REPOS_PATH\n"
                         % (os.path.basename(sys.argv[0])))
        sys.exit(1)

    # Canonicalize (enough for Subversion, at least) the repository path.
    repos_path = os.path.normpath(sys.argv[1])
    if repos_path == '.': 
        repos_path = ''

    # Call the app-wrapper, which takes care of APR initialization/shutdown
    # and the creation and cleanup of our top-level memory pool.
    svn.core.run_app(crawl_youngest, repos_path)
</programlisting>
      </example>

      <para lang="en">This same program in C would need to deal with custom
        datatypes (such as those provided by the APR library) for
        representing the hash of entries and the list of paths, but
        Python has hashes (called <quote>dictionaries</quote>) and
        lists as built-in datatypes, and provides a rich collection of
        functions for operating on those types.  So SWIG (with the
        help of some customizations in Subversion's language bindings
        layer) takes care of mapping those custom datatypes into the
        native datatypes of the target language.  This provides a more
        intuitive interface for users of that language.</para>

      <para>Questo stesso programma in C avrebbe bisogno di trattare con tipi di
        dato personalizzati (come quelli forniti dalla libreria APR) per
        rappresentare l'hash delle entrate e la lista dei percorsi, ma
        Python ha gli hash (chiamati <quote>dizionari</quote>) e le liste
        come tipi di dato interni, e fornisce una ricca collezione di
        funzioni per operare su questi tipi.  Così SWIG (con l'aiuto
        di qualche personalizzazione nello strato del linguaggio di legame di
        Subversion) si prende cura di mappare questi tipi di dato personalizzati
        nei tipi di dato nativi del linguaggio bersaglio.  Questo fornisce una
        più intuitiva interfaccia per gli utenti di questo linguaggio.</para>

      <para lang="en">The Subversion Python bindings can be used for working
        copy operations, too.  In the previous section of this
        chapter, we mentioned the <filename>libsvn_client</filename>
        interface, and how it exists for the sole purpose of
        simplifying the process of writing a Subversion client.  The
        following is a brief example of how that library can be
        accessed via the SWIG bindings to recreate a scaled-down
        version of the <command>svn status</command> command.</para>

      <para>I legami Python di Subversion possono essere anche utilizzati per 
        operazioni sulle copie di lavoro.  Nella sezione precedente di questo
        capitolo, abbiamo menzionato l'interfaccia <filename>libsvn_client</filename>,
        e come questa esiste per il solo scopo di semplificare il
        processo di scrittura di un client di Subversion.  Il seguente è
        un breve esempio di come questa libreria può essere acceduta
        attraverso i legami SWIG per ricreare una versione ridotta
        del comando <command>svn status</command>.</para>

      <example id="svn.developer.usingapi.otherlangs.ex-2">
        <title>Un ricercatore di stato in Python</title>

        <programlisting>
#!/usr/bin/env python

"""Crawl a working copy directory, printing status information."""

import sys
import os.path
import getopt
import svn.core, svn.client, svn.wc

def generate_status_code(status):
    """Translate a status value into a single-character status code,
    using the same logic as the Subversion command-line client."""

    if status == svn.wc.svn_wc_status_none:
        return ' '
    if status == svn.wc.svn_wc_status_normal:
        return ' '
    if status == svn.wc.svn_wc_status_added:
        return 'A'
    if status == svn.wc.svn_wc_status_missing:
        return '!'
    if status == svn.wc.svn_wc_status_incomplete:
        return '!'
    if status == svn.wc.svn_wc_status_deleted:
        return 'D'
    if status == svn.wc.svn_wc_status_replaced:
        return 'R'
    if status == svn.wc.svn_wc_status_modified:
        return 'M'
    if status == svn.wc.svn_wc_status_merged:
        return 'G'
    if status == svn.wc.svn_wc_status_conflicted:
        return 'C'
    if status == svn.wc.svn_wc_status_obstructed:
        return '~'
    if status == svn.wc.svn_wc_status_ignored:
        return 'I'
    if status == svn.wc.svn_wc_status_external:
        return 'X'
    if status == svn.wc.svn_wc_status_unversioned:
        return '?'
    return '?'

def do_status(pool, wc_path, verbose):
    # Calculate the length of the input working copy path.
    wc_path_len = len(wc_path)

    # Build a client context baton.
    ctx = svn.client.svn_client_ctx_t()

    def _status_callback(path, status, root_path_len=wc_path_len):
        """A callback function for svn_client_status."""

        # Print the path, minus the bit that overlaps with the root of
        # the status crawl
        text_status = generate_status_code(status.text_status)
        prop_status = generate_status_code(status.prop_status)
        print '%s%s  %s' % (text_status, prop_status, path[wc_path_len + 1:])
        
    # Do the status crawl, using _status_callback() as our callback function.
    svn.client.svn_client_status(wc_path, None, _status_callback,
                                 1, verbose, 0, 0, ctx, pool)

def usage_and_exit(errorcode):
    """Print usage message, and exit with ERRORCODE."""
    stream = errorcode and sys.stderr or sys.stdout
    stream.write("""Usage: %s OPTIONS WC-PATH
Options:
  --help, -h    : Show this usage message
  --verbose, -v : Show all statuses, even uninteresting ones
""" % (os.path.basename(sys.argv[0])))
    sys.exit(errorcode)
    
if __name__ == '__main__':
    # Parse command-line options.
    try:
        opts, args = getopt.getopt(sys.argv[1:], "hv", ["help", "verbose"])
    except getopt.GetoptError:
        usage_and_exit(1)
    verbose = 0
    for opt, arg in opts:
        if opt in ("-h", "--help"):
            usage_and_exit(0)
        if opt in ("-v", "--verbose"):
            verbose = 1
    if len(args) != 1:
        usage_and_exit(2)
            
    # Canonicalize (enough for Subversion, at least) the working copy path.
    wc_path = os.path.normpath(args[0])
    if wc_path == '.': 
        wc_path = ''

    # Call the app-wrapper, which takes care of APR initialization/shutdown
    # and the creation and cleanup of our top-level memory pool.
    svn.core.run_app(do_status, wc_path, verbose)
</programlisting>
      </example>

      <para lang="en">Subversion's language bindings unfortunately tend to lack
        the level of attention given to the core Subversion modules.
        However, there have been significant efforts towards creating
        functional bindings for Python, Perl, and Ruby.  To some extent,
        the work done preparing the SWIG interface files for these
        languages is reusable in efforts to generate bindings for other
        languages supported by SWIG (which includes versions of C#,
        Guile, Java, MzScheme, OCaml, PHP, Tcl, and others).
        However, some extra programming is required to compensate for
        complex APIs that SWIG needs some help interfacing with.  For
        more information on SWIG itself, see the project's website at
        <ulink url="http://www.swig.org/"/>.</para>

      <para>I legami ai linguaggi di Subversion sfortunatamente tendono a
        a difettare nel livello di attenzione dato ai moduli del cuore di Subversion.
        Comunque, ci sono stati sforzi significati verso la creazione di legami
        funzionali per Python, Perl, e Ruby.  In parte,
        il lavoro fatto preparando i file dell'interfaccia di SWIG per questi
        linguaggi è riusabile nello sforzo di generare legami per altri
        linguaggi supportati da SWIG (che includono versioni di C#,
        Guile, Java, MzScheme, OCaml, PHP, Tcl, e altri).
        Tuttavia, qualche programmazione in più è richiesta per compensare
        le API complesse così che SWIG necessita di qualche aiuto per interfacciarsi.
        Per maggiori informazioni su SWIG stesso, vedere il sito web del progetto
        a <ulink url="http://www.swig.org/"/>.</para>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.developer.insidewc">
    <title>All'interno dell'area di amminstrazione della copia di lavoro</title>
    
    <para lang="en">As we mentioned earlier, each directory of a Subversion
      working copy contains a special subdirectory called
      <filename>.svn</filename> which houses administrative data about
      that working copy directory.  Subversion uses the information in
      <filename>.svn</filename> to keep track of things like:</para>

    <para>Come menzionato prima, ogni directory di una copia di lavoro
      di Subversione contiene una sottodirectory speciale chiamata
      <filename>.svn</filename> che ospita dati amministrativi circa
      quella directory della copia di lavoro.  Subversion utilizza le informazioni
      in <filename>.svn</filename> per tenere traccia di cose come:</para>

    <itemizedlist>
      <listitem>
        <para lang="en">Which repository location(s) are represented by the
          files and subdirectories in the working copy
          directory.</para>

        <para>Quali posizioni del repository sono rappresentate dai file e
          sottodirecotyr nella directory della copia di lavoro.</para>
      </listitem>
      <listitem>
        <para lang="en">What revision of each of those files and directories are
          currently present in the working copy.</para>

        <para>Quale revisione di ognuno di questi file e directory sono
          correntemente presenti nella copia di lavoro.</para>
      </listitem>
      <listitem>
        <para lang="en">Any user-defined properties that might be attached
          to those files and directories.</para>

        <para>Qualsiasi proprietà definite dall'utente che possono essere allegate
          a questi file e directory.</para>
      </listitem>
      <listitem>
        <para lang="en">Pristine (un-edited) copies of the working copy
          files.</para>

        <para>Copie originarie (non modificate) dei file della copia di
          lavoro.</para>
      </listitem>
    </itemizedlist>

    <para lang="en">While there are several other bits of data stored in the
      <filename>.svn</filename> directory, we will examine only a
      couple of the most important items.</para>

    <para>Mentre ci sono vari altri bit di dati immagazzinati nella directory
      <filename>.svn</filename>, esamineremo solamente un paio degli elementi
      più importanti.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.insidewc.entries">
      <title>Il file entries</title>

      <para lang="en">Perhaps the single most important file in the
        <filename>.svn</filename> directory is the
        <filename>entries</filename> file.  The entries file is an XML
        document which contains the bulk of the administrative
        information about a versioned resource in a working copy
        directory.  It is this one file which tracks the repository
        URLs, pristine revision, file checksums, pristine text and
        property timestamps, scheduling and conflict state
        information, last-known commit information (author, revision,
        timestamp), local copy history&mdash;practically everything
        that a Subversion client is interested in knowing about a
        versioned (or to-be-versioned) resource!</para>

      <para>Forse il più importante singolo file nella directory
        <filename>.svn</filename> è il file
        <filename>entries</filename>.  Il file entries è un documento XML
        che contiene la massa delle informazioni amministrative
        circa le risorse versionate in una directory della copia di lavoro.
        È questo il file che traccia gli URL del repository,
        revisioni originarie, il checksum dei file, testo originario e la proprietà
        timestamp, le informazioni di pianificazione e di stato di
        conflitto, informazioni sull'ultimo commit fatto (autore, revisione,
        timestamp), lo storico della copia locale&mdash;praticamente ogni cosa
        che un client di Subversion è interessato a sapere circa le risorse
        versionate (o da versionare)!</para>


      <sidebar>
        <title>Confrontare le aree amministrative di Subversion e
          CVS</title>

        <para lang="en">A glance inside the typical <filename>.svn</filename>
          directory turns up a bit more than what CVS maintains in its
          <filename>CVS</filename> administrative directories.  The
          <filename>entries</filename> file contains XML which
          describes the current state of the working copy directory,
          and basically serves the purposes of CVS's
          <filename>Entries</filename>, <filename>Root</filename>, and
          <filename>Repository</filename> files combined.</para>

        <para>Un'occhiata all'interno della tipica directory <filename>.svn</filename>
          rivela più di quello che mantiene CVS nelle sue directory
          amministrative <filename>CVS</filename>.  Il file
          <filename>entries</filename> contiene XML che descrive
          lo stato corrente della directory della copia di lavoro,
          e essenzialmente serve allo scopo dei file di CVS
          <filename>Entries</filename>, <filename>Root</filename>, e
          <filename>Repository</filename> insieme.</para>

      </sidebar>

      <para lang="en">The following is an example of an actual entries
        file:</para>

      <para>Il seguente è un esempio degli elementi file reali:</para>

      <example id="svn.developer.insidewc.entries.ex-1">
        <title>Contenuti di un tipico file <filename>.svn/entries</filename></title>
        <programlisting>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;wc-entries
   xmlns="svn:"&gt;
&lt;entry
   committed-rev="1"
   name=""
   committed-date="2005-04-04T13:32:28.526873Z"
   url="http://svn.red-bean.com/repos/greek-tree/A/D"
   last-author="jrandom"
   kind="dir"
   uuid="4e820d15-a807-0410-81d5-aa59edf69161"
   revision="1"/&gt;
&lt;entry
   name="lambda"
   copied="true"
   kind="file"
   copyfrom-rev="1"
   schedule="add"
   copyfrom-url="http://svn.red-bean.com/repos/greek-tree/A/B/lambda"/&gt;
&lt;entry
   committed-rev="1"
   name="gamma"
   text-time="2005-12-11T16:32:46.000000Z"
   committed-date="2005-04-04T13:32:28.526873Z"
   checksum="ada10d942b1964d359e048dbacff3460"
   last-author="jrandom"
   kind="file"
   prop-time="2005-12-11T16:32:45.000000Z"/&gt;
&lt;entry
   name="zeta"
   kind="file"
   schedule="add"
   revision="0"/&gt;
&lt;entry
   name="G"
   kind="dir"/&gt;
&lt;entry
   name="H"
   kind="dir"
   schedule="delete"/&gt;
&lt;/wc-entries&gt;
</programlisting>
      </example>

      <para lang="en">As you can see, the entries file is essentially a list of
        entries.  Each <sgmltag>entry</sgmltag> tag represents one of
        three things: the working copy directory itself (called the
        <quote>this directory</quote> entry, and noted as having an
        empty value for its <structfield>name</structfield>
        attribute), a file in that working copy directory (noted by
        having its <structfield>kind</structfield> attribute set to
        <literal>"file"</literal>), or a subdirectory in that working
        copy (<structfield>kind</structfield> here is set to
        <literal>"dir"</literal>).  The files and subdirectories whose
        entries are stored in this file are either already under
        version control, or (as in the case of the file named
        <filename>zeta</filename> above) are scheduled to be added to
        version control when the user next commits this working copy
        directory's changes.  Each entry has a unique name, and each
        entry has a node kind.</para>

      <para>Come si può vedere, il file entries è essenzialmente una lista di
        entrate.  Ogni etichetta <sgmltag>entry</sgmltag> rappresenta una di tre
        cose: la directory della copia di lavoro stessa (chiamata l'entrata
        <quote>questa directory</quote>, e famosa per avere valore
        vuoto per il suo attributo <structfield>name</structfield>),
        un file in questa directory della copia di lavoro (famosa per avere
        il suo attributo <structfield>kind</structfield> impostato a
        <literal>"file"</literal>), o una sottodirectory in questa copia di
        lavoro (qui <structfield>kind</structfield> è impostato a
        <literal>"dir"</literal>).  I file e lo sottodirectory per i quali
        le entrate sono immagazzinate in questo file sono o già sotto
        controllo di versione, o (come nel caso del file sopra di nome
        <filename>zeta</filename>) sono pianificato per essere aggiunte al
        controllo di versione quando l'utente farà il prossimo commit dei
        cambiamente a questa directory della copia di lavoro.  Ogni entrata
        ha un nome univoco, e ogni entrata ha un nodo kind.</para>

      <para lang="en">Developers should be aware of some special rules that
        Subversion uses when reading and writing its
        <filename>entries</filename> files.  While each entry has a
        revision and URL associated with it, note that not every
        <sgmltag>entry</sgmltag> tag in the sample file has explicit
        <structfield>revision</structfield> or
        <structfield>url</structfield> attributes attached to it.
        Subversion allows entries to not explicitly store those two
        attributes when their values are the same as (in the
        <structfield>revision</structfield> case) or trivially
        calculable from
        <footnote>
          <para>That is, the URL for the entry is the same as the
            concatenation of the parent directory's URL and the
            entry's name.</para>
        </footnote>
        (in the <structfield>url</structfield> case) the data stored
        in the <quote>this directory</quote> entry.  Note also that
        for subdirectory entries, Subversion stores only the crucial
        attributes&mdash;name, kind, url, revision, and schedule.  In
        an effort to reduce duplicated information, Subversion
        dictates that the method for determining the full set of
        information about a subdirectory is to traverse down into that
        subdirectory, and read the <quote>this directory</quote> entry
        from its own <filename>.svn/entries</filename> file.  However,
        a reference to the subdirectory is kept in its parent's
        <filename>entries</filename> file, with enough information to
        permit basic versioning operations in the event that the
        subdirectory itself is actually missing from disk.</para>

      <para>Gli sviluppatori dovrebbero fare attenzione ad alcune regole speciali
        che Subversion utilizza quando legge e scrive i propri file
        <filename>entries</filename>.  Mentre ogni entrata ha una revisione
        e un URL associati ad essi, notare che non ogni etichetta 
        <sgmltag>entry</sgmltag> nel file di esempio ha specifici attributi
        <structfield>revision</structfield> o
        <structfield>url</structfield> allegati a esso.
        Subversion permette alle entrate di non immagazzinare esplicitamente
        questi due attributi quando il loro valoro è lo stesso (nel caso
        <structfield>revision</structfield>) o banalmente
        calcolabile da
        <footnote>
          <para>Quello è, l'URL per l'entrata è lo stesso della
            concatenazione dell'URL della directory superiore e il nome
            dell'entrata.</para>
        </footnote>
        (nel caso <structfield>url</structfield>) i dati immagazzinati
        nell'entrata <quote>questa directory</quote>.  Notare anche che
        per entrate sottodirectory, Subversion immagazzina solamente gli attributi
        cruciali&mdash;name, kind, url, revision, e schedule.  In uno
        sforzo di ridurre informazioni duplicate, Subversion
        impone il metodo per determinare l'insieme completo delle
        informazioni circa una sottodirectory è di traversare verso il basso
        all'interno di questa sottodirectory, e leggere l'entrata <quote>questa directory</quote>
        dal suo file <filename>.svn/entries</filename>.  Tuttavia,
        un riferimento alla sottodirectory è tenuto nel file
        <filename>entries</filename> della directory superiore, con abbastanza
        informazioni da permettere operazioni di versionamento di base nel caso
        in cui la sottodirectory stessa attualmente manchi dal disco.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.insidewc.base-and-props">
      <title>Copie originarie e file di proprietà</title>

      <para lang="en">As mentioned before, the <filename>.svn</filename>
        directory also holds the pristine <quote>text-base</quote>
        versions of files.  Those can be found in
        <filename>.svn/text-base</filename>.  The benefits of these
        pristine copies are multiple&mdash;network-free checks for
        local modifications and difference reporting, network-free
        reversion of modified or missing files, smaller transmission
        of changes to the server&mdash;but comes at the cost of having
        each versioned file stored at least twice on disk.  These
        days, this seems to be a negligible penalty for most files.
        However, the situation gets uglier as the size of your
        versioned files grows.  Some attention is being given to
        making the presence of the <quote>text-base</quote> an option.
        Ironically though, it is as your versioned files' sizes get
        larger that the existence of the <quote>text-base</quote>
        becomes more crucial&mdash;who wants to transmit a huge file
        across a network just because they want to commit a tiny
        change to it?</para>

      <para>Come menzionato prima, la directory <filename>.svn</filename>
        contiene anche le versioni <quote>testuali</quote>
        originarie dei file.  Questi possono essere trovati in
        <filename>.svn/text-base</filename>.  I benefici di queste copie
        originarie sono multiple&mdash;controlli liberi dalla rete per
        modifiche locali e differenze, revisione libera dalla rete
        di file modificati o mancanti, trasmissioni più piccole di
        cambiamenti al server&mdash;ma vengono al costodi avere ogni
        file versionato immagazzinato almeno due volte sul disco.  Ai giorni
        nostri, questo sembra essere una penalità trascurabile per la maggior
        parte dei file.
        Tuttavia, la situazione diventa più sgradevole se la dimensione dei
        propri file versionati aumenta.  Qualche attenzione deve essere fatta
        sul fare della presenza di <quote>text-base</quote> un'opzione.
        Benché ironicamente, come le dimensioni dei propri file versionati
        diventa più grande l'esistenza di <quote>text-base</quote>
        diventa maggiormente cruciale&mdash;che vuole trasmettere un file enorme
        sulla la rete solo perché vuole fare un commit di un piccolo
        cambiamento a questo?</para>

      <para lang="en">Similar in purpose to the <quote>text-base</quote> files
        are the property files and their pristine
        <quote>prop-base</quote> copies, located in
        <filename>.svn/props</filename> and
        <filename>.svn/prop-base</filename> respectively.  Since
        directories can have properties, too, there are also
        <filename>.svn/dir-props</filename> and
        <filename>.svn/dir-prop-base</filename> files.  Each of these
        property files (<quote>working</quote> and <quote>base</quote>
        versions) uses a simple <quote>hash-on-disk</quote> file
        format for storing the property names and values.</para>

      <para>Simile nello scopo dei file in <quote>text-base</quote> 
        sono i file proprietà e le loro copie originarie
        <quote>prop-base</quote>, posizionati rispettivamente in
        <filename>.svn/props</filename> e
        <filename>.svn/prop-base</filename>.  Dato che
        le directory possono avere anche le proprietà, ci sono anche i file
        <filename>.svn/dir-props</filename> e
        <filename>.svn/dir-prop-base</filename>.  Ognuno di questi
        file di proprietà (versioni <quote>working</quote> e <quote>base</quote>)
        utilizza un semplice formato di file <quote>hash-on-disk</quote>
        per immagazzinare i nomi delle proprietà e i valori.</para>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.developer.webdav">
    <title>WebDAV</title>

    <para lang="en">WebDAV (shorthand for <quote>Web-based Distributed Authoring
      and Versioning</quote>) is an extension of the standard HTTP
      protocol designed to make the web into a read/write medium,
      instead of the basically read-only medium that exists today.
      The theory is that directories and files can be shared&mdash;as
      both readable and writable objects&mdash;over the web.  RFCs
      2518 and 3253 describe the WebDAV/DeltaV extensions to HTTP, and
      are available (along with a lot of other useful information) at
      <ulink url="http://www.webdav.org/"/>.</para>

    <para>WebDAV (abbreviazione di <quote>Creazione e versionamento distribuiti
      basati sul web</quote>) è un'estensione del protocollo standard HTTP
      progettato per fare del web un mezzo di lettura/scrittura,
      invece del mezzo di sola lettura che esiste oggi.
      La teoria è che le directory e i file possono essere condivisi&mdash;
      entrambi come oggetti leggibili e scrivibili&mdash;sul web.  RFC
      2518 e 3253 descrivono le estenzioni WebDAV/DeltaV a HTTP, e
      sono disponibili (con molte altre utili informazioni) a
      <ulink url="http://www.webdav.org/"/>.</para>

    <para lang="en">A number of operating system file browsers are already able
      to mount networked directories using WebDAV.  On Win32, the
      Windows Explorer can browse what it calls Web Folders (which are
      just WebDAV-ready network locations) as if they were regular
      shared folders.  Mac OS X also has this capability, as do the
      Nautilus and Konqueror browsers (under GNOME and KDE,
      respectively).</para>

    <para>Un numero di navigatori di file di sistemi operativi sono già capaci
      di montare directory sulla rete utilizzando WebDAV.  In Win32,
      Windows Explorer può navigare quelle che chiama Cartelle Web (che sono
      posizioni di rete pronte per WebDAV) come se fossero regolari cartelle
      condivise.  Anche Mac OS X ha questa capacità, così come i navigatori
      Nautilus e Konqueror (in GNOME e KDE,
      rispettivamente).</para>

    <para lang="en">How does all of this apply to Subversion?  The mod_dav_svn
      Apache module uses HTTP, extended by WebDAV and DeltaV, as one
      of its network protocols.  Subversion uses mod_dav_svn to map
      between Subversion's versioning concepts and those of RFCs 2518
      and 3253.
    </para>

    <para>Come si applicato tutto questo a Subversion?  Il modulo mod_dav_svn
      di Apache utilizza HTTP, esteso da WebDAV e DeltaV, come uno dei
      propri protocolli di rete.  Subversion utilizza mod_dav_svn per mappare
      i concetti di versionamento di Subversion con quelli degli RFC 2518
      e 3253.
    </para>

    <para lang="en">For a more thorough discussion of WebDAV, how it works, and
      how Subversion uses it, see <xref linkend="svn.webdav"/>.  Among
      other things, that appendix discusses the degree to which
      Subversion adheres to the generic WebDAV specification, and how
      that affects interoperability with generic WebDAV
      clients.</para>

    <para>Per una discussione più completa di WebDAV, come funziona, e
      come Subversion lo utilizza, vedere <xref linkend="svn.webdav"/>.  Fra le
      altre cose, l'appendice discute il grado al quale aderisce
      Subversion delle specifiche generiche di WebDAV, e come
      questo influenzi l'interoperabilità tra client WebDAV
      generici.</para>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.developer.pools">
    <title>Programmare con i pool di memoria</title>

    <para lang="en">Almost every developer who has used the C programming
      language has at some point sighed at the daunting task of
      managing memory usage.  Allocating enough memory to use, keeping
      track of those allocations, freeing the memory when you no
      longer need it&mdash;these tasks can be quite complex.  And of
      course, failure to do those things properly can result in a
      program that crashes itself, or worse, crashes the computer.
      Fortunately, the APR library that Subversion depends on for
      portability provides the <structname>apr_pool_t</structname>
      type, which represents a pool from which the application may
      allocate memory.</para>

    <para>Quasi ogni sviluppatore che ha utilizzato il linguaggio di
      programmazione C a qualche punto ha sospirato allo scoraggiante compito di
      gestire l'uso della memoria.  Allocare abbastanza memoria da utilizzare,
      mantenere traccia di quelle allocazioni, liberare la memoria quando non è
      più necessaria&mdash;questi compiti possono essere abbastanza complessi.
      E naturalmente, fallire a fare queste cose correttamente può risultare in un
      programma che va in crash, o peggio, fa andare in crash il computer.
      Fortunatamente, la libreria APR da cui Subversion dipende per
      portabilità fornisce il tipo <structname>apr_pool_t</structname>,
      che rappresenta un pool dal quale l'applicazione può
      allocare memoria.</para>

    <para lang="en">A memory pool is an abstract representation of a chunk of
      memory allocated for use by a program.  Rather than requesting
      memory directly from the OS using the standard
      <function>malloc()</function> and friends, programs that link
      against APR can simply request that a pool of memory be created
      (using the <function>apr_pool_create()</function> function).
      APR will allocate a moderately sized chunk of memory from the
      OS, and that memory will be instantly available for use by the
      program.  Any time the program needs some of the pool memory, it
      uses one of the APR pool API functions, like
      <function>apr_palloc()</function>, which returns a generic
      memory location from the pool.  The program can keep requesting
      bits and pieces of memory from the pool, and APR will keep
      granting the requests.  Pools will automatically grow in size to
      accommodate programs that request more memory than the original
      pool contained, until of course there is no more memory
      available on the system.</para>

    <para>Un pool di memoria è una rappresentazione astratta di un pezzo di
      memoria allocata per l'uso da parte di un programma.  Piuttosto che richiedere
      la memoria direttamente al sistema operativo utilizzando la funzione
      standard <function>malloc()</function> e simili, i porgrammi che si 
      collegano a APR possono semplicemente richiedere che venga creato un pool
      di memoria (utilizzando la funzione <function>apr_pool_create()</function>).
      APR allocherà un pezzo di memoria di moderata grandezza dal sistema operativo,
      e questa memoria diverrà istantaneamente disponibile per l'uso da parte del
      programma.  Ogni volta che il programma necessita di qualche pool di memoria,
      utilizza una delle funzioni dell'API per i pool di APR, come
      <function>apr_palloc()</function>, che ritorna una posizione di memoria
      generica dal pool.  Il programma può continuare a chiedere bit e pezzi di
      memoria dal pool, e APR continuerà a
      esaudire le richieste.  I pool cresceranno automaticamente in grandezza
      per accogliere i programmi che richiedono più memoria di quella che il pool
      originale conteneva, naturalmente fino a quando non ci sia più memoria
      disponibile nel sistema.</para>

    <para lang="en">Now, if this were the end of the pool story, it would hardly
      have merited special attention.  Fortunately, that's not the
      case.  Pools can not only be created; they can also be cleared
      and destroyed, using <function>apr_pool_clear()</function> and
      <function>apr_pool_destroy()</function> respectively.  This
      gives developers the flexibility to allocate several&mdash;or
      several thousand&mdash;things from the pool, and then clean up
      all of that memory with a single function call!  Further, pools
      have hierarchy.  You can make <quote>subpools</quote> of any
      previously created pool.  When you clear a pool, all of its
      subpools are destroyed; if you destroy a pool, it and its
      subpools are destroyed.</para>

    <para>Ora, se questa fosse stata la fine della storia dei pool, a stento
      avrebbe meritato speciale attenzione.  Fortunatamente, questo non è il
      caso.  I pool possono non solo essere creati; possono anche essere puliti
      e distrutti, utilizzando rispettivamente <function>apr_pool_clear()</function> e
      <function>apr_pool_destroy()</function>.  Questo
      da agli sviluppatori la flessibilità di allocare varie&mdash;o varie
      migliaia&mdash;cose dal pool, e poi pulire tutta
      questa memoria con una singola chiamata a funzione!  Inoltre, i pool
      hanno una gerarchia.  Si possono fare dei <quote>sotto pool</quote> di ogni
      pool creato precedentemente.  Quando si pulisce un pool, tutti i suoi
      sotto pool vengono distrutti; se si distrugge un pool, questo e i suoi
      sotto pool vengono distrutti.</para>

    <para lang="en">Before we go further, developers should be aware that they
      probably will not find many calls to the APR pool functions we
      just mentioned in the Subversion source code.  APR pools offer
      some extensibility mechanisms, like the ability to have custom
      <quote>user data</quote> attached to the pool, and mechanisms
      for registering cleanup functions that get called when the pool
      is destroyed.  Subversion makes use of these extensions in a
      somewhat non-trivial way.  So, Subversion supplies (and most of
      its code uses) the wrapper functions
      <function>svn_pool_create()</function>,
      <function>svn_pool_clear()</function>, and
      <function>svn_pool_destroy()</function>.</para>

    <para>Prima di andare oltre, gli sviluppatori dovrebbero essere informati che
      probabilmente non troveranno nel codice sorgente di Subversion molte delle 
      chiamate alle funzioni di APR per i pool che abbiamo appena menzionato.
      I pool di APR offrono qualche meccanismo di estendibilità, come l'abilità
      di avere <quote>dati utente</quote> personalizzati attaccati al pool, e
      meccanismi per registrare funzioni di pulizia che possono essere chiamate
      quando il pool viene distrutto.  Subversion fa uso di queste estensioni in
      un modo piuttosto non banale.  Così, Subversion fornisce (e la maggior parte
      del proprio codice utilizza) le funzioni di avvolgimento
      <function>svn_pool_create()</function>,
      <function>svn_pool_clear()</function>, e
      <function>svn_pool_destroy()</function>.</para>

    <para lang="en">While pools are helpful for basic memory management, the
      pool construct really shines in looping and recursive scenarios.
      Since loops are often unbounded in their iterations, and
      recursions in their depth, memory consumption in these areas of
      the code can become unpredictable.  Fortunately, using nested
      memory pools can be a great way to easily manage these
      potentially hairy situations.  The following example
      demonstrates the basic use of nested pools in a situation that
      is fairly common&mdash;recursively crawling a directory tree,
      doing some task to each thing in the tree.</para>

    <para>Mentre i pool sono utili per una gestione di base della memoria, la
      costruzione dei pool brilla realmente negli scenari di ciclo e ricorsione.
      Poiché i cicli sono spesso illimitati nelle loro iterazioni, e le
      ricorsioni nella loro profondità, il consumo di memoria in queste aree del
      codice può diventare non predicibile.  Fortunatamente, utilizzando pool di
      memoria annidati può essere un buon modo per gestire facilmente queste
      situazioni potenzialmente pericolose.  L'esempio seguente
      dimostra l'uso di base dei pool annidati in una situazione che è
      ragionevolmente comune&mdash;l'esplorazione ricorsiva di un albero di directory,
      eseguendo qualche compito per ogni cosa nell'albero.</para>

    <example id="svn.developer.pools.ex-1">
      <title>Effective Pool Usage</title>
      <programlisting>
/* Recursively crawl over DIRECTORY, adding the paths of all its file
   children to the FILES array, and doing some task to each path
   encountered.  Use POOL for the all temporary allocations, and store
   the hash paths in the same pool as the hash itself is allocated in.  */
static apr_status_t 
crawl_dir (apr_array_header_t *files,
           const char *directory,
           apr_pool_t *pool)
{
  apr_pool_t *hash_pool = files-&gt;pool;  /* array pool */
  apr_pool_t *subpool = svn_pool_create (pool);  /* iteration pool */
  apr_dir_t *dir;
  apr_finfo_t finfo;
  apr_status_t apr_err;
  apr_int32_t flags = APR_FINFO_TYPE | APR_FINFO_NAME;

  apr_err = apr_dir_open (&amp;dir, directory, pool);
  if (apr_err)
    return apr_err;

  /* Loop over the directory entries, clearing the subpool at the top of
     each iteration.  */
  for (apr_err = apr_dir_read (&amp;finfo, flags, dir);
       apr_err == APR_SUCCESS;
       apr_err = apr_dir_read (&amp;finfo, flags, dir))
    {
      const char *child_path;

      /* Clear the per-iteration SUBPOOL.  */
      svn_pool_clear (subpool);

      /* Skip entries for "this dir" ('.') and its parent ('..').  */
      if (finfo.filetype == APR_DIR)
        {
          if (finfo.name[0] == '.'
              &amp;&amp; (finfo.name[1] == '\0'
                  || (finfo.name[1] == '.' &amp;&amp; finfo.name[2] == '\0')))
            continue;
        }

      /* Build CHILD_PATH from DIRECTORY and FINFO.name.  */
      child_path = svn_path_join (directory, finfo.name, subpool);

      /* Do some task to this encountered path. */
      do_some_task (child_path, subpool);

      /* Handle subdirectories by recursing into them, passing SUBPOOL
         as the pool for temporary allocations.  */
      if (finfo.filetype == APR_DIR)
        {
          apr_err = crawl_dir (files, child_path, subpool);
          if (apr_err)
            return apr_err;
        }

      /* Handle files by adding their paths to the FILES array.  */
      else if (finfo.filetype == APR_REG)
        {
          /* Copy the file's path into the FILES array's pool.  */
          child_path = apr_pstrdup (hash_pool, child_path);

          /* Add the path to the array.  */
          (*((const char **) apr_array_push (files))) = child_path;
        }
    }

  /* Destroy SUBPOOL.  */
  svn_pool_destroy (subpool);

  /* Check that the loop exited cleanly. */
  if (apr_err)
    return apr_err;

  /* Yes, it exited cleanly, so close the dir. */
  apr_err = apr_dir_close (dir);
  if (apr_err)
    return apr_err;

  return APR_SUCCESS;
}
</programlisting>
    </example>

    <para lang="en">The previous example demonstrates effective pool usage in
      <emphasis>both</emphasis> looping and recursive situations.
      Each recursion begins by making a subpool of the pool passed to
      the function.  This subpool is used for the looping region, and
      cleared with each iteration.  The result is memory usage is
      roughly proportional to the depth of the recursion, not to total
      number of file and directories present as children of the
      top-level directory.  When the first call to this recursive
      function finally finishes, there is actually very little data
      stored in the pool that was passed to it.  Now imagine the extra
      complexity that would be present if this function had to
      <function>alloc()</function> and <function>free()</function>
      every single piece of data used!</para>
    
    <para>L'esempio precedente dimostra l'effettivo utilizzo del pool in
      <emphasis>entrambe</emphasis> le situazioni di ciclo e ricorsione.
      Ogni ricorsione inizia creando un sotto pool del pool passato alla
      funzione.  Questo sotto pool è utilizzato per la regione di ciclo, e
      pulito con ogni iterazione.  Il risultato di utilizzo della memoria è
      approssimativamente proporzionale alla profondità della ricorsione, non il
      numero totale di file e directory presenti come figli della directory
      di più alto livello.  Quando la prima chiamata a questa funzione ricorsiva
      finalmente finisce, attualmente c'è un dato molto piccolo immagazzinato
      nel pool che le è stato passato.  Ora immaginate la complessità ulteriore
      che sarebbe presente se questa funzione dovesse usare
      <function>alloc()</function> e <function>free()</function>
      ogni singolo pezzo di dati utilizzati!</para>
    
    <para lang="en">Pools might not be ideal for every application, but they are
      extremely useful in Subversion.  As a Subversion developer,
      you'll need to grow comfortable with pools and how to wield them
      correctly.  Memory usage bugs and bloating can be difficult to
      diagnose and fix regardless of the API, but the pool construct
      provided by APR has proven a tremendously convenient,
      time-saving bit of functionality.</para>

    <para>I pool possono non essere l'ideale per ogni applicazione, ma sono
      estremamente utili in Subversion.  Come sviluppatore di Subversion,
      occorre prendere confidenza con i pool e come maneggiarli correttamente.
      Gli errori di utilizzo della memoria e la sua crescita possono essere
      difficili da diagnosticare e correggere malgrado l'API, ma la
      costruzione del pool fornita da APR è risultata tremendamente conveniente,
      facendo risparmiare tempo in bit di funzionalità.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.developer.contrib">
    <title>Contribuire a Subversion</title>
    
    <para lang="en">The official source of information about the Subversion
      project is, of course, the project's website at
      <ulink url="http://subversion.tigris.org/"/>.  There you can
      find information about getting access to the source code and
      participating on the discussion lists.  The Subversion community
      always welcomes new members.  If you are interested in
      participating in this community by contributing changes to the
      source code, here are some hints on how to get started.</para>

    <para>La fonte ufficiale di informazioni sul progetto Subversion
      è, naturalmente, il sito web del progetto all'indirizzo
      <ulink url="http://subversion.tigris.org/"/>.  Qui si possono trovare
      informazioni su come ottenere accesso al codice sorgente e partecipare
      alle liste di discussione.  La comunità di Subversion da sempre il
      benvenuto a nuovi membri.  Se si è interessati a partecipare
      a questa comunità contribuendo con cambiamenti al codice
      sorgente, qui ci sono alcuni suggerimenti su come iniziare.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.contrib.join">
      <title>Unirsi alla comunità</title>
      
      <para lang="en">The first step in community participation is to find a way
        to stay on top of the latest happenings.  To do this most
        effectively, you will want to subscribe to the main developer
        discussion list (<email>dev@subversion.tigris.org</email>) and
        commit mail list (<email>svn@subversion.tigris.org</email>).
        By following these lists even loosely, you will have access
        to important design discussions, be able to see actual changes
        to Subversion source code as they occur, and be able to
        witness peer reviews of those changes and proposed changes.
        These email based discussion lists are the primary
        communication media for Subversion development.  See the
        Mailing Lists section of the website for other
        Subversion-related lists you might be interested in.</para>

      <para>Il primo passo nella partecipazione alla comunità è trovare un modo
        per rimanere aggiornati sugli ultimi eventi.  Per fare questo più
        efficacemente, occorrerà iscriversi alla lista di discussione principale
        di sviluppo (<email>dev@subversion.tigris.org</email>) e
        alla lista dei commit (<email>svn@subversion.tigris.org</email>).
        Seguendo queste liste anche approssimativamente, si ha accesso
        a importanti discussioni sul disegno, si possono vedere i cambiamenti
        effettivi al codice sorgente di Subversion quando occorrono, e si può
        assistere alle rassegne di questi cambiamenti e proposte di cambiamento.
        Queste liste di discussione basate sulle email sono il mezzo primario di
        comunicazione per lo sviluppo di Subversion.  Vedere la sezione
        delle liste mail del sito web per altre liste su
        Subversion a cui si può essere interessati.</para>

      <para lang="en">But how do you know what needs to be done?  It is quite
        common for a programmer to have the greatest intentions of
        helping out with the development, yet be unable to find a good
        starting point.  After all, not many folks come to the
        community having already decided on a particular itch they
        would like to scratch.  But by watching the developer
        discussion lists, you might see mentions of existing bugs or
        feature requests fly by that particularly interest you.  Also,
        a great place to look for outstanding, unclaimed tasks is the
        Issue Tracking database on the Subversion website.  There you
        will find the current list of known bugs and feature requests.
        If you want to start with something small, look for issues
        marked as <quote>bite-sized</quote>.</para>
      
      <para>Ma come si può conoscere ciò che deve essere fatto?  È abbastanza
        comune per un programmatore avere le più grandi intenzioni di aiutare
        con lo sviluppo, ma non trovare un buon punto di inizio.
        Dopo tutto, non molta gente arriva alla comunità
        avendo già deciso su quale particolare rogna
        vorrebbero impegnarsi.  Ma osservando le liste di discussione,
        si possono vedere menzioni di errori esistenti o
        richieste di caratteristiche che interessano particolarmente.  Inoltre,
        un ottimo posto per cercare compiti eccezionali, non reclamati è il
        database Issue Tracking sul sito web di Subversion.  Qui si troveranno
        la lista corrente degli errori conosciuti e delle richieste di caratteristiche.
        Se si vuole iniziare con qualche cosa di piccolo, cercare problemi
        marcati come <quote>bite-sized</quote>.</para>
      
    </sect2>
    
    <!-- =============================================================== -->
    <sect2 id="svn.developer.contrib.get-code">
      <title>Prendere il codice sorgente</title>
      
      <para>To edit the code, you need to have the code.  This means
        you need to check out a working copy from the public
        Subversion source repository.  As straightforward as that
        might sound, the task can be slightly tricky.  Because
        Subversion's source code is versioned using Subversion itself,
        you actually need to <quote>bootstrap</quote> by getting a
        working Subversion client via some other method.  The most
        common methods include downloading the latest binary
        distribution (if such is available for your platform), or
        downloading the latest source tarball and building your own
        Subversion client.  If you build from source, make sure to
        read the <filename>INSTALL</filename> file in the top level of
        the source tree for instructions.</para>

      <para>After you have a working Subversion client, you are now
        poised to checkout a working copy of the Subversion source
        repository from <ulink
         url="http://svn.collab.net/repos/svn/trunk/"/>:
        <footnote>
          <para>Note that the URL checked out in the example above
            ends not with <literal>svn</literal>, but with a
            subdirectory thereof called <literal>trunk</literal>.  See
            our discussion of Subversion's branching and tagging model
            for the reasoning behind this.</para>
        </footnote></para>

      <screen>
$ svn checkout http://svn.collab.net/repos/svn/trunk subversion
A    subversion/HACKING
A    subversion/INSTALL
A    subversion/README
A    subversion/autogen.sh
A    subversion/build.conf
&hellip;
</screen>

      <para>The above command will checkout the bleeding-edge, latest
        version of the Subversion source code into a subdirectory
        named <filename>subversion</filename> in your current working
        directory.  Obviously, you can adjust that last argument as
        you see fit.  Regardless of what you call the new working copy
        directory, though, after this operation completes, you will
        now have the Subversion source code.  Of course, you will
        still need to fetch a few helper libraries (apr, apr-util,
        etc.)&mdash;see the <filename>INSTALL</filename> file in the
        top level of the working copy for details.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.contrib.hacking">
      <title>Become Familiar with Community Policies</title>
      
      <para>Now that you have a working copy containing the latest
        Subversion source code, you will most certainly want to take a
        cruise through the <quote>Hacker's Guide to Subversion</quote>,
        which is available either as the
        <filename>www/hacking.html</filename> file in the working copy,
        or on the Subversion website at <ulink
          url="http://subversion.tigris.org/hacking.html"/>.  This guide
        contains general instructions for contributing to Subversion,
        including how to properly format your source code for
        consistency with the rest of the codebase, how to describe your
        proposed changes with an effective change log message, how to
        test your changes, and so on.  Commit privileges on the
        Subversion source repository are earned&mdash;a government by
        meritocracy.
        <footnote>
          <para>While this may superficially appear as some sort of
            elitism, this <quote>earn your commit privileges</quote>
            notion is about efficiency&mdash;whether it costs more in
            time and effort to review and apply someone else's changes
            that are likely to be safe and useful, versus the
            potential costs of undoing changes that are
            dangerous.</para>
        </footnote>
        The <quote>Hacker's Guide</quote> is an invaluable resource when
        it comes to making sure that your proposed changes earn the
        praises they deserve without being rejected on
        technicalities.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.contrib.code-and-test">
      <title>Make and Test Your Changes</title>
      
      <para>With the code and community policy understanding in hand,
        you are ready to make your changes.  It is best to try to make
        smaller but related sets of changes, even tackling larger
        tasks in stages, instead of making huge, sweeping
        modifications.  Your proposed changes will be easier to
        understand (and therefore easier to review) if you disturb
        the fewest lines of code possible to accomplish your task
        properly.  After making each set of proposed changes, your
        Subversion tree should be in a state in which the software
        compiles with no warnings.</para>

      <para>Subversion has a fairly thorough
        <footnote>
          <para>You might want to grab some popcorn.
            <quote>Thorough</quote>, in this instance, translates to
            somewhere in the neighborhood of thirty minutes of
            non-interactive machine churn.</para>
        </footnote>
        regression test suite, and your proposed changes are expected
        to not cause any of those tests to fail.  By running
        <command>make check</command> (in Unix) from the top of the
        source tree, you can sanity-check your changes.  The fastest
        way to get your code contributions rejected (other than
        failing to supply a good log message) is to submit changes
        that cause failure in the test suite.</para>

      <!-- ### TODO: Describe building and testing on Windows. -->

      <para>In the best-case scenario, you will have actually added
        appropriate tests to that test suite which verify that your
        proposed changes work as expected.  In fact,
        sometimes the best contribution a person can make is solely
        the addition of new tests.  You can write regression tests for
        functionality that currently works in Subversion as a way to
        protect against future changes that might trigger failure in
        those areas.  Also, you can write new tests that demonstrate
        known failures.  For this purpose, the Subversion test suite
        allows you to specify that a given test is expected to fail
        (called an <literal>XFAIL</literal>), and so long as
        Subversion fails in the way that was expected, a test result
        of <literal>XFAIL</literal> itself is considered a success.
        Ultimately, the better the test suite, the less time wasted on
        diagnosing potentially obscure regression bugs.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.contrib.submit">
      <title>Donate Your Changes</title>
      
      <para>After making your modifications to the source code,
        compose a clear and concise log message to describe those
        changes and the reasons for them.  Then, send an email to the
        developers list containing your log message and the output of
        <command>svn diff</command> (from the top of your Subversion
        working copy).  If the community members consider your changes
        acceptable, someone who has commit privileges (permission to
        make new revisions in the Subversion source repository) will
        add your changes to the public source code tree.  Recall that
        permission to directly commit changes to the repository is
        granted on merit&mdash;if you demonstrate comprehension of
        Subversion, programming competency, and a <quote>team
        spirit</quote>, you will likely be awarded that
        permission.</para>

    </sect2>
  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
