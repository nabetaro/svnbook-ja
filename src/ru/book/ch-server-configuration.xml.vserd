<?xml version="1.0" encoding="UTF-8"?>

<chapter id="svn.serverconfig">
   <chapterinfo>
    <othername id="svn.serverconfig.accusative-case" role="title-variant">
 главе Настройка сервера</othername>
  </chapterinfo> 
  
  <!-- @ENGLISH {{{
     
  <title>Server Configuration</title>

  <para>A Subversion repository can be accessed simultaneously by
    clients running on the same machine on which the repository
    resides using the <literal>file://</literal> method.  But the
    typical Subversion setup involves a single server machine being
    accessed from clients on computers all over the office&mdash;or,
    perhaps, all over the world.</para>

  <para>This chapter describes how to get your Subversion repository
    exposed outside its host machine for use by remote clients.  We
    will cover Subversion's currently available server mechanisms,
    discussing the configuration and use of each.  After reading
    this section, you should be able to decide which networking
    setup is right for your needs, and understand how to enable such
    a setup on your host computer.</para>
  @ENGLISH }}} -->
  <title>Настройка сервера</title>
  <para>Одновременный доступ к хранилищу Subversion клиентами,
    запущенными на том же компьютере, где расположено и хранилище,
    возможен при использовании метода <literal>file://</literal>.
    Но, обычно, сервер Subversion устанавливается на отдельный
    компьютер, к которому имеют доступ клиенты с компьютеров всего
    офиса &mdash; или, возможно, всего мира.</para>
  <para>Эта глава расскажет, как предоставить доступ к хранилищу
    Subversion удаленным клиентам. Мы опишем доступные на сегодняшний
    день механизмы серверов Subversion, а так же обсудим вопросы
    конфигурации и использования каждого из них. После прочтения этого
    раздела вы сможете решить, какой тип сервера подходит вам, как его
    установить и настроить на вашем компьютере.</para>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.overview">
    <!-- @ENGLISH {{{
    <title>Overview</title>

    <para>Subversion was designed with an abstract network layer.
      This means that a repository can be programmatically accessed by
      any sort of server process, and the client <quote>repository
      access</quote> API allows programmers to write plugins that
      speak relevant network protocols.  In theory, Subversion can use
      an infinite number of network implementations.  In practice,
      there are only two servers at the time of this writing.</para>
    @ENGLISH }}} -->
    <title>Обзор</title>    

    <para>Subversion был разработан с использованием абстрактного
      сетевого уровня. Это означает, что на программном уровне для
      доступа к хранилищу может быть использован любой тип сервера,
      а <quote>клиентский API для доступа к хранилищу</quote> дает
      программистам возможность создавать плагины, которые будут
      взаимодействовать с соответствующим сетевым протоколом.
      Теоретически, Subversion может использовать неограниченное
      количество сетевых реализаций. Практически же, на данный момент
      написаны только два сервера.</para>
    
    <!-- @ENGLISH {{{
    <para>Apache is an extremely popular webserver; using the
      <command>mod_dav_svn</command> module, Apache can access a
      repository and make it available to clients via the
      WebDAV/DeltaV protocol, which is an extension of HTTP.  Because
      Apache is an extremely extensible web server, it provides a
      number of features <quote>for free</quote>, such as encrypted
      SSL communication, logging, integration with a number of
      third-party authentication systems, and limited built-in web
      browsing of repositories.</para>
    @ENGLISH }}} -->
    <para>Apache &mdash; наиболее популярный web-сервер; при использовании
      модуля <command>mod_dav_svn</command> Apache получает возможность
      доступа к хранилищу, а так же делает его доступным для клиентов,
      используя протокол WebDAV/DeltaV, который является расширением
      HTTP. Так как Apache черезвычайно расширяемый web-сервер, он 
      <quote>бесплатно</quote> предоставляет множество возможностей, 
      таких как: коммуникации по 
      SSL с шифрированием, логгирование, интеграцию с несколькими 
      сторонними системами идентификации и ограниченный встороенный 
      просмотр хранилищ через web.</para>



    <!-- @ENGLISH {{{
    <para>In the other corner is <command>svnserve</command>: a small,
      lightweight server program that speaks a custom protocol with
      clients.  Because its protocol is explicitly designed for
      Subversion and is stateful (unlike HTTP), it provides
      significantly faster network operations&mdash;but at the cost of
      some features as well.  It only understands CRAM-MD5
      authentication, has no logging, no web-browsing, and no option
      to encrypt network traffic.  It is, however, extremely easy to
      set up and is often the best option for small teams just
      starting out with Subversion.</para>


    <para>A third option is to use <command>svnserve</command>
      tunneled over an SSH connection.  Even though this scenario
      still uses <command>svnserve</command>, it differs quite a bit
      in features from a traditional <command>svnserve</command>
      deployment.  SSH is used to encrypt all communication.  SSH is
      also used exclusively to authenticate, so real system accounts
      are required on the server host (unlike
      vanilla <command>svnserve</command>, which has its own private
      user accounts.)  Finally, because this setup requires that each
      user spawn a private, temporary <command>svnserve</command>
      process, it's equivalent (from a permissions point of view) to
      allowing a group of local users to all access the repository
      via <literal>file://</literal> URLs. Path-based access control
      has no meaning, since each user is accessing the repository
      database files directly.</para>
    @ENGLISH }}} -->
    <para> В другом углу ринга &mdash; <command>svnserve</command>
      &mdash; небольшой, самостоятельный сервер, использующий для связи
      с клиентами собственный протокол. Так как этот протокол специально 
      разработан для Subversion и полный (в отличии от HTTP), он 
      предоставляет значительно быстрые сетевые операции &mdash; но 
      за счет некоторых возможностей. Он понимает идентификацию только 
      по CRAM-MD5, не имеет логгирования, нет просмотра через web, и нет 
      возможности шифрировать сетевой трафик. Одноко он черезвычайно 
      простой в установке и часто лучший выбор для небольших команд, 
      которые начинают с Subversion.</para>

    <para>Третьей возможностью является использование 
      <command>svnserve</command> с тунелированием черзе SSH соединение. 
      Не смотря на то что этот сценарий продолжает использовать 
      <command>svnserve</command>, он значительно отличается в некоторых 
      возможностях от традиционного <command>svnserve</command>. SHH 
      использует шифрацию всех коммуникаций. SSH также использует 
      исключительно для идентификации, такии образом на хосте сервера 
      требуются реальные системные учетные записи (в отличии от 
      стандартного <command>svnserve</command>, который имеет 
      собственные учетные записи пользователей). В заключение, так как 
      его установка требует чтобы каждый пользователь порождал 
      собственный, временный процесс <command>svnserve</command>, это 
      эквивалентно (с точки зрения прав разрешения) разрешению группе 
      локальных пользователей получать доступ ко всему хранилищу через 
      <literal>file://</literal> URL. Управление доступом к хранилищу на 
      основе пути не имеет значения, так как каждый пользователь 
      получает доступ к файлу базы данных напрямую.</para>

    <!-- @ENGLISH {{{
    <para>Here's a quick summary of the three typical server
      deployments.</para>
    @ENGLISH }}} -->
    <para>Вот краткое резюме трех типичных возможностей развертывания 
      сервера.</para>
    
    <table id="svn.serverconfig.overview.tbl-1">
      <!-- @ENGLISH {{{      
      <title>Comparison of Subversion Server Options</title>
      <tgroup cols="4">
        <thead>
          <row>
            <entry>Feature</entry>
            <entry>Apache + mod_dav_svn</entry>
            <entry>svnserve</entry>
            <entry>svnserve over SSH</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>Authentication options</entry>
            <entry>HTTP(S) basic auth, X.509 certificates, LDAP, NTLM, or
              any other mechanism available to Apache httpd</entry>
            <entry>CRAM-MD5</entry>
            <entry>SSH</entry>
          </row>

          <row>
            <entry>User account options</entry>
            <entry>private 'users' file</entry>
            <entry>private 'users' file</entry>
            <entry>system accounts</entry>
          </row>

          <row>
            <entry>Authorization options</entry>
            <entry>read/write access can be granted over whole
              repository, or specified per-path.</entry>
            <entry>read/write access can be granted over whole
              repository, or specified per-path.</entry>
            <entry>read/write access only grantable over whole
              repository</entry>
          </row>

          <row>
            <entry>Encryption</entry>
            <entry>via optional SSL</entry>
            <entry>none</entry>
            <entry>SSH tunneled</entry>
          </row>

          <row>
            <entry>Logging</entry>
            <entry>full Apache logs of each HTTP request, with
            optional <quote>high-level</quote> logging of general
            client operations</entry>
            <entry>no logging</entry>
            <entry>no logging</entry>
          </row>

          <row>
            <entry>Interoperability</entry>
            <entry>partially usable by other WebDAV clients</entry>
            <entry>only talks to svn clients</entry>
            <entry>only talks to svn clients</entry>
          </row>

          <row>
            <entry>Web viewing</entry>
            <entry>limited built-in support, or via 3rd-party tools
              such as ViewVC</entry>
            <entry>only via 3rd-party tools such as ViewVC</entry>
            <entry>only via 3rd-party tools such as ViewVC</entry>
          </row>

          <row>
            <entry>Speed</entry>
            <entry>somewhat slower</entry>
            <entry>somewhat faster</entry>
            <entry>somewhat faster</entry>
          </row>

          <row>
            <entry>Initial setup</entry>
            <entry>somewhat complex</entry>
            <entry>extremely simple</entry>
            <entry>moderately simple </entry>
          </row>

        </tbody>
      </tgroup>
    </table>
    @ENGLISH }}} -->
    <title>Сравнение возможностей серверов Subversion</title>
      <tgroup cols="4">
        <thead>
          <row>
            <entry>Возможность</entry>
            <entry>Apache + mod_dav_svn</entry>
            <entry>svnserve</entry>
            <entry>svnserve через SSH</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>Настройки установления личности</entry>
            <entry>стандартное установление личности средствами HTTP(S),
              сертификаты X.509, LDAP, NTLM, а также другие механизмы,
              доступные для использования в Apache</entry>
            <entry>CRAM-MD5</entry>
            <entry>SSH</entry>
          </row>

          <row>
            <entry>Настройки пользовательских учетных записей</entry>
            <entry>внутренний файл 'users'</entry>
            <entry>внутренний файл 'users'</entry>
            <entry>системные учетные записи</entry>
          </row>

          <row>
            <entry>Настройки прав доступа</entry>

             <entry>доступ для чтения/записи может быть предоставлен на 
               все хранилище, или к конкретному пути.</entry>

             <entry>доступ для чтения/записи может быть предоставлен на 
               все хранилище, или к конкретному пути.</entry>

             <entry>доступ для чтения/записи может быть предоставлен 
               только на все хранилище.</entry>

          </row>

          <row>
            <entry>Шифрование</entry>
            <entry>через опциональный SSL </entry>
            <entry>нет</entry>
            <entry>SSH тунель</entry>
          </row>

          <row>
            <entry>Логгирование</entry>
            <entry>полные логи Apache каждого запроса HTTP, с 
              дополнительным <quote>высоко-уровневым</quote> 
              логгированием основных операций клиента</entry>
            <entry>нет логгрования</entry>
            <entry>нет логгрования</entry>
          </row>

          <row>
            <entry>Возможность к взаимодействию</entry>
            <entry>частично, используя другие WevDAV-клиенты</entry>
            <entry>общение только с клиентами svn</entry>
            <entry>общение только с клиентами svn</entry>
          </row>

          <row>
            <entry>Просмотр через web</entry>
            <entry>встроенная ограниченная поддержка, или используя
              программы сторонних разработчиков, такие, как ViewVS</entry>
            
            <entry>только используя программы сторонних разработчиков, такие,
              как ViewVS </entry>
            <entry>только используя программы сторонних разработчиков, такие,
              как ViewVS </entry>

          </row>

          <row>
            <entry>Скорость</entry>
            <entry>более низкая</entry>
            <entry>более высокая</entry>
            <entry>более высокая</entry>
          </row>

          <row>
            <entry>Начальная установка</entry>
            <entry>несколько сложная</entry>
            <entry>черезвычайно простая</entry>
            <entry>умеренно простая</entry>
          </row>

        </tbody>
      </tgroup>
    </table>


  </sect1>

  <sect1 id="svn.serverconfig.choosing">
    <!-- @ENGLISH {{{
    <title>Choosing a Server Configuration</title>

    <para>So, which server should you use?  Which is best?</para>

    <para>Obviously, there's no right answer to that question.  Every
      team has different needs, and the different servers all
      represent different sets of tradeoffs.  The Subversion project
      itself doesn't endorse one server or another, or consider either
      server more <quote>official</quote> than another.</para>

    <para>Here are some reasons why you might choose one deployment
      over another, as well as reasons you
      might <emphasis>not</emphasis> choose one.</para>
    @ENGLISH }}} -->
    <title>Выбор конфигурации сервера</title>

    <para>И так, какой сервер вы должны использовать? Какой из них 
      лучший?</para>

    <para>Очевидно, нет правильного ответа на этот вопрос. Каждая 
      комадна имеет различные нужды и различные сервера предоставляют 
      различные наборы альтернатив. Сам проект Subversion не выделяет 
      один сервер по сравнению с другими, другими словами, нет более 
      <quote>официального</quote> сервера по сравнению с другими.</para>

    <para>Вот некоторые причины почему вы можете выбрать один тип 
      сервера вместо другого, или почему вы можете 
      <emphasis>не</emphasis> выбрать его.</para>


    <sect2 id="svn.serverconfig.choosing.svnserve">

      <!-- @ENGLISH {{{
      <title>The <command>svnserve</command> Server</title>

      <variablelist>
        <varlistentry>
          <term>Why you might want to use it:</term>
          <listitem>
            <itemizedlist>

            <listitem><para>Quick and easy to set
                up.</para></listitem>

            <listitem><para>Network protocol is stateful and
                noticeably faster than WebDAV.</para></listitem>

            <listitem><para>No need to create system accounts on
                server.</para></listitem>

            <listitem><para>Password is not passed over the
                network.</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Why you might want to avoid it:</term>
          <listitem>
            <itemizedlist>

            <listitem><para>Network protocol is not
                encrypted.</para></listitem>

            <listitem><para>Only one choice of authentication
                method.</para></listitem>

            <listitem><para>Password is stored in the clear on the
                server.</para></listitem>

            <listitem><para>No logging of any kind, not even
                errors.</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

      </variablelist>
      @ENGLISH }}} -->
      <title>Сервер svnserve</title>

      <variablelist>
        <varlistentry>
          <term>Почему вы можете захотеть использовать его:</term>
          <listitem>
            <itemizedlist>

            <listitem><para>Быстро и просто устанавливается.</para></listitem>

            <listitem><para>Сетевой протокол полон и значительно быстрее 
                чем WebDAV.</para></listitem>

            <listitem><para>Не нужно создавать системные учетные записи 
                на сервере.</para></listitem>

            <listitem><para>Пароль не передается через сеть.</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Почему вы можете захотеть избегать его:</term>
          <listitem>
            <itemizedlist>
              <listitem><para>Сетевой протокол не 
                  шифрируется.</para></listitem>

            <listitem><para>Только один метод 
                идентификации.</para></listitem>

            <listitem><para>Пароль хранится в открытом виде на 
                сервере.</para></listitem>

            <listitem><para>Нет никакого логгирования, даже 
                ошибок.</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

      </variablelist>

    </sect2>

    <sect2 id="svn.serverconfig.choosing.svn-ssh">

    <!-- @ENGLISH {{{
      <title><command>svnserve</command> over SSH</title>

      <variablelist>
        <varlistentry>
          <term>Why you might want to use it:</term>
          <listitem>
            <itemizedlist>

            <listitem><para>Network protocol is stateful and
                noticeably faster than WebDAV.</para></listitem>

            <listitem><para>You can take advantage of existing ssh
                accounts and user infrastructure.</para></listitem>

            <listitem><para>All network traffic is
                encrypted.</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Why you might want to avoid it:</term>
          <listitem>
            <itemizedlist>

            <listitem><para>Only one choice of authentication
                method.</para></listitem>

            <listitem><para>No logging of any kind, not even
                errors.</para></listitem>

            <listitem><para>Requires users to be in same system group, or
                use a shared ssh key.</para></listitem>

            <listitem><para>Can lead to file permissions
                problems.</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

      </variablelist>
      @ENGLISH }}} -->
      <title>svnserve через SSH</title>

      <variablelist>
        <varlistentry>
          <term>Почему вы можете захотеть использовать его:</term>
          <listitem>
            <itemizedlist>

              <listitem><para>Сетевой протокол полон и значительно 
                  быстрее чем WebDAV.</para></listitem>

              <listitem><para> Вы можете взять преймущества существующих 
                  ssh учетных записей и пользовательской 
                  инфраструктуры.</para></listitem>

            <listitem><para>Сетевой трафик зашифрован.</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Почему вы можете захотеть избегать его:</term>
          <listitem>
            <itemizedlist>

            <listitem><para>Только один метод 
                идентификации.</para></listitem>

            <listitem><para>Нет никакого логгирования, даже 
                ошибок.</para></listitem>

            <listitem><para>Требует чтобы пользователи были в одной 
                системной группе, или использовать общий ключ 
                ssh.</para></listitem>

            <listitem><para>Может приводить к проблемам с правами 
                доступа.</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

      </variablelist>


    </sect2>

    <sect2 id="svn.serverconfig.choosing.apache">

      <!-- @ENGLISH {{{
      <title>The Apache HTTP Server</title>

      <variablelist>
        <varlistentry>
          <term>Why you might want to use it:</term>
          <listitem>
            <itemizedlist>

              <listitem><para>Allows Subversion to use any of the
                  numerous authentication systems already integrated
                  with Apache.</para></listitem>

              <listitem><para>No need to create system accounts on
                  server.</para></listitem>

              <listitem><para>Full Apache logging.</para></listitem>

              <listitem><para>Network traffic can be encrypted via
                  SSL.</para></listitem>

              <listitem><para>HTTP(S) can usually go through corporate
                  firewalls.</para></listitem>

              <listitem><para>Built-in repository browsing via web
                  browser.</para></listitem>

              <listitem><para>Repository can be mounted as a network
                  drive for transparent version control. (See
                  <xref
                  linkend="svn.webdav.autoversioning"/>.)</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Why you might want to avoid it:</term>
          <listitem>
            <itemizedlist>

            <listitem><para>Noticeably slower than svnserve, because
                HTTP is a stateless protocol and requires more
                turnarounds.</para></listitem>

            <listitem><para>Initial setup can be complex.</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

      </variablelist>
      @ENGLISH }}} -->
      <title>Apache HTTP-сервер</title>

      <variablelist>
        <varlistentry>
          <term>Почему вы можете захотеть использовать его:</term>
          <listitem>
            <itemizedlist>

              <listitem><para>Позволяет Subversion использовать любую из 
                  многочисленных систем идентификации которые уже 
                  Apache.</para></listitem>

              <listitem><para>Не нужно создавать системные учетные 
                  записи на сервере.</para></listitem>

              <listitem><para>Полное Apache логирование.</para></listitem>

              <listitem><para>Сетевой трафик может быть зашифрован через 
                  SSL.</para></listitem>

              <listitem><para>HTTP(S) может передаваться через 
                  корпоративный фаейрвол.</para></listitem>

              <listitem><para>Встроенный просомортр хранилиша через 
                  web-браузер.</para></listitem>

              <listitem><para>Хранилище может быть смонтировано как 
                  серевой диск для прозрачным управлением версиями. 
                  (Смотрите <xref
                  linkend="svn.webdav.autoversioning"/>.)</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Почему вы можете захотеть избегать его:</term>
          <listitem>
            <itemizedlist>

            <listitem><para>Заметно медленнее чем svnserve, так как HTTP 
                протокол без состояния и требует больше 
                поворотов.</para></listitem>

            <listitem><para>Начальная установка может быть сложной.</para></listitem>

            </itemizedlist>
          </listitem>
        </varlistentry>

      </variablelist>
    </sect2>

    <sect2 id="svn.serverconfig.choosing.recommendations">

      <!-- @ENGLISH {{{
      <title>Recommendations</title>

      <para>In general, the authors of this book recommend a vanilla
        <command>svnserve</command> installation for small teams just
        trying to get started with a Subversion server; it's the
        simplest to set up, and has the fewest maintenance issues.
        Remember, you can always switch to a more complex server
        deployment as your needs change.</para>

      <para>Here are some general recommendations and tips, based on
        years of supporting users:</para>
      @ENGLISH }}} -->
      <title>Рекомендации</title>

      <para>В общем, авторы этой книги рекомендуют установку 
        <command>svnserve</command> для маленьких команд которые только 
        начинают с Subversion, он проще в установке и меет наименьшее 
        проблем с поддержкой. Помните, вы можете всегда переключится на 
        более сложный вариант как только вам это понадобится.</para>

      <para>Вот некоторые общие рекомендации и советы, основанные на 
        многолетней поддержке пользователей:</para>

      <!-- @ENGLISH {{{
      <itemizedlist>
        <listitem>
          <para>If you're trying to set up the simplest possible
            server for your group, then a
            vanilla <command>svnserve</command> installation is the
            easiest, fastest route.  Note, however, that your
            repository data will be transmitted in the clear over the
            network.  If your deployment is entirely within your
            company's LAN or VPN, this isn't an issue.  If the
            repository is exposed to the wide-open internet, then you
            might want to make sure the repository's contents aren't
            sensitive (e.g. it contains only open-source code.)</para>
        </listitem>

        <listitem>
          <para>If you need to integrate with existing identity
            systems (LDAP, Active Directory, NTLM, X.509, etc.), then
            an Apache-based server is your only real option.
            Similarly, if you absolutely need server-side logs of
            either server errors or client activities, then an
            Apache-based server is required.</para>
        </listitem>

        <listitem>
           <para>If you've decided to use either Apache or stock
             <command>svnserve</command>, create a
             single <literal>svn</literal> user on your system and run
             the server process as that user.  Be sure to make the
             repository directory wholly owned by
             the <literal>svn</literal> user as well.  From a security
             point of view, this keeps the repository data nicely
             siloed and protected by operating system filesystem
             permissions, changeable by only the Subversion server
             process itself.</para>
        </listitem>

        <listitem>
          <para>If you have an existing infrastructure heavily based
            on SSH accounts, and if your users already have system
            accounts on your server machine, then it makes sense to
            deploy an svnserve-over-ssh solution.  Otherwise, we don't
            widely recommend this option to the public.  It's
            generally considered safer to have your users access the
            repository via (imaginary) accounts managed
            by <command>svnserve</command> or Apache, rather than by
            full-blown system accounts.  If your deep desire for
            encrypted communication still draws you to this option, we
            recommend using Apache with SSL instead.</para>
        </listitem>

        <listitem>
          <para>Do <emphasis>not</emphasis> be seduced by the simple
            idea of having all of your users access a repository
            directly via <literal>file://</literal> URLs.  Even if
            the repository is readily available to everyone via
            network share, this is a bad idea.  It removes any layers
            of protection between the users and the repository: users
            can accidentally (or intentionally) corrupt the repository
            database, it becomes hard to take the repository offline
            for inspection or upgrade, and it can lead to a mess of
            file-permissions problems (see
            <xref linkend="svn.serverconfig.multimethod"/>.)  Note
            that this is also one of the reasons we warn against
            accessing repositories via <literal>svn+ssh://</literal>
            URLs &mdash; from a security standpoint, it's effectively
            the same as local users accessing
            via <literal>file://</literal>, and can entail all the
            same problems if the administrator isn't careful.</para>
        </listitem>
      </itemizedlist>
      @ENGLISH }}} -->
      <itemizedlist>
        <listitem>
          <para>Если вы пытаетесь установить наиболее простой сервер для 
            вашей группы, тогда <command>svnserve</command> простейший, 
            быстрейший путь. Однако обратите внимание,  что ваше 
            хранилище данных может быть передано в открытом виде через 
            сеть. Если ваше развертывание внутри сети вашей компании или 
            VPN, это не вопрос. Если хранилище засвечивается в интернет, 
            тогда вы можете захотеть чтобы содержимое этого хранилища 
            не было чувствительным к содержимому (например содержать 
            только код с открытым кодом).</para>
        </listitem>

        <listitem>
          <para>Если вы нуждаетесь в интеграции с существующими 
            системами идентификации (LDAP, Active Directory, NTLM, 
            X.509, и т.д.), тогда единственный реальный выбор это сервер 
            на основе Apache. Так же, если вы абсолютно нуждаетесь в 
            логах на стороне сервера как об ошибках сервера так и об 
            активности клиентов, требуется сервер на основе Apache.</para>
        </listitem>

        <listitem>
          <para>Если вы решились использовать Apache или 
            <command>svnserve</command>, создайте в сисистеме одного 
            пользователя <literal>svn</literal> и запускайте серверный 
            процесс от имени этого пользователя. Убедитесь что сделали 
            владельцем папки хранилища пользователя 
            <literal>svn</literal>. С точки зрения безопасности, это 
            сохраняет данные хранилища изолированными и защищенными 
            правами файловой системы операционной системы, изменяемые 
            только самим процессом сервера Subversion.</para>
        </listitem>

        <listitem>
          <para>Если вы имеете существующую инфраструктуру сильно 
            основанной на SSH учетных записях, и ваши пользователи уже 
            имеют системные учтеные записи на вашей сервеной машине, 
            тогда имеет смысл развернуть решение svnserve через ssh. В 
            противном случае, мы не сильно рекомендуем этот выбор для 
            всех. Обычно считается что безопаснее иметь доступ 
            пользователей к хранилищу через учтеные записи пользователей 
            (возможно воображаемые), управляемые 
            <command>svnserve</command> или Apache, чем разросшимся 
            системными учетными записями. Если вы сильно желаете 
            зашифрованных коммуникаций через эту возможность, мы 
            рекомендуем использвать в место нее Apache с SSL.</para>
        </listitem>

        <listitem>
          <para><emphasis>Не</emphasis> соблазняйтесь простой идеей 
            иметь доступ всех ваших пользователей к хранилищу напрямую 
            через URL види <literal>file://</literal>. Даже если 
            хранилище легко доступно для всех через сетевую шару, это 
            плохая идея. Такой вариант удаляет любые уровни защиты между 
            пользователями и хранилищем: пользователи могут случайно 
            (или специально) повреждать базу данных хранилища, вызывает 
            трудности для того чтобы выключить хранлище для проверок или 
            обновления, и может вызывать неприятности с файловыми 
            правами доступа (см. <xref 
              linkend="svn.serverconfig.multimethod"/>.) Обратите 
            внимание что этот вариант таже одна из причин почему мы 
            снова предостерегаем от доступап к хранилищу через 
            <literal>svn+ssh://</literal> &mdash; с точки зрения 
            безопасноси, это также эффективно как доступ локальных 
            пользователей через <literal>file://</literal>, и может 
            вызывать все теже проблемы, если администратор не будет 
            аккуратным.</para>
        </listitem>
      </itemizedlist>


    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.svnserve">
    <!-- @ENGLISH {{{

    <title>svnserve, a custom server</title>

    <para>The <command>svnserve</command> program is a lightweight
      server, capable of speaking to clients over TCP/IP using a
      custom, stateful protocol.  Clients contact an
      <command>svnserve</command> server by using URLs that begin with
      the <literal>svn://</literal> or <literal>svn+ssh://</literal>
      schema.  This section will explain the different ways of running
      <command>svnserve</command>, how clients authenticate themselves
      to the server, and how to configure appropriate access control
      to your repositories.</para>
    @ENGLISH }}} -->
    <title>svnserve - Заказной сервер</title>
    <para> Программа <command>svnserve</command> легкий сервер, 
      способный общаться с клиентами через TCP/IP, используя собственный 
      простой протокол. Клиенты обращаются к серверу, 
      <command>svnserve</command> используя URL, который начинается с 
      <literal>svn://</literal> или <literal>svn+ssh://</literal>.  
      В этом разделе рсказывается о различных путях запуска 
      <command>svnserve</command>, о том как клиенты удостоверяются
      (authenticate) на сервере и настройке соответствующих правил 
      доступа к вашему хранилищу.</para>



    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.invoking">

      <!-- @ENGLISH {{{
      <title>Invoking the Server</title>

      <para>There are a few different ways to run the
        <command>svnserve</command> program:</para>

      <itemizedlist>
        <listitem><para>Run <command>svnserve</command> as a
            standalone daemon, listening for
            requests.</para></listitem>
        <listitem><para>Have the Unix <command>inetd</command> daemon
            temporarily spawn <command>svnserve</command> whenever a
            request comes in on a certain port.</para></listitem>
        <listitem><para>Have SSH invoke a
            temporary <command>svnserve</command> over an encrypted
            tunnel.</para></listitem>
        <listitem><para>Run <command>svnserve</command> as a Windows
            service.</para></listitem>
      </itemizedlist>
      @ENGLISH }}} -->
      <title>Запуск Сервера</title>
      <para>Существует несколько различных способов запустить программу 
         <command>svnserve</command>:</para>

      <itemizedlist>
        <listitem><para>Запуск <command>svnserve</command> как одиночный 
            демон, слушающий запросы.</para></listitem>

        <listitem><para>Использовать демон <command>inetd</command> в 
            Unix, для временного запуска  <command>svnserve</command> 
            когда запрос приходит на некоторый порт.</para></listitem>
        <listitem><para>SSH запускает временый
            <command>svnserve</command> через зашифрованный 
            тунель.</para></listitem>
        <listitem><para>Запускать <command>svnserve</command> как сервис
            Windows.</para></listitem>
      </itemizedlist>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.invoking.daemon">

        <!-- @ENGLISH {{{
        <title><command>svnserve</command> as Daemon</title>

        <para>The easiest option is to run <command>svnserve</command>
          as a standalone <quote>daemon</quote> process.  Use the
          <option>-d</option> option for this:</para>
        @ENGLISH }}} -->
        <title>Svnserve как демон</title>

        <para>Простейший вариант запускать <command>svnserve</command> 
          как самостоятельный процесс <quote>демона</quote>. Для этого 
          используйте параметр <option>-d</option>:</para>


        <screen>
$ svnserve -d
$               # svnserve is now running, listening on port 3690
</screen>

      <!-- @ENGLISH {{{      
      <para>When running <command>svnserve</command> in daemon mode,
        you can use the <option>--><!--listen-port=</option> and
        <option>--><!--listen-host=</option> options to customize the exact
        port and hostname to <quote>bind</quote> to.</para>
      @ENGLISH }}} -->
      <para> Когда <command>svnserve</command> запускается в режиме 
        демона, то Вы можете использовать опции <option>--listen-port=</option> и
        <option>--listen-host=</option>, чтобы назначить нужное значение порта и 
        имени хоста, к которому <quote>привязан</quote> 
        <command>svnserve</command>.</para>

      <!-- @ENGLISH {{{      
      <para>Once the <command>svnserve</command> program is running,
        it makes every repository on your system available to the
        network.  A client needs to specify an
        <emphasis>absolute</emphasis> path in the repository URL.  For
        example, if a repository is located at
        <filename>/usr/local/repositories/project1</filename>, then a
        client would reach it via
        <uri>svn://host.example.com/usr/local/repositories/project1</uri>.
        To increase security, you can pass the <option>-r</option>
        option to <command>svnserve</command>, which restricts it to
        exporting only repositories below that path.  For example:</para>
      @ENGLISH }}} -->
      <para> Как только <command>svnserve</command> запущена каждое хранилище
        на Вашей системе доступно по сети. Клиенту необходимо указать 
        <emphasis>абсолютный</emphasis> путь в URL хранилища. Например, если
        хранилище расположено в
        <filename>/usr/local/repositories/project1</filename>, тогда клиент
        должен получит доступ к нему через
        <uri>svn://host.example.com/usr/local/repositories/project1</uri>. Чтобы
        увеличить безопасность, Вы можете указать у <command>svnserve</command>
        опцию -r, которая разрешает экспортировать хранилища расположенные
        только ниже указанного пути. Например: </para>
    

      
      <screen>
$ svnserve -d -r /usr/local/repositories
&hellip;
</screen>


      <!-- @ENGLISH {{{
      <para>Using the <option>-r</option> option effectively
        modifies the location that the program treats as the root of
        the remote filesystem space.  Clients then use URLs that
        have that path portion removed from them, leaving much
        shorter (and much less revealing) URLs:</para>
      @ENGLISH }}} -->
      <para> Использование параметра -r эффективно изменяет расположение, 
        которое программа рассматривает как корень раздела удаленной 
        файловой системы. Тогда клиенты используют URL, из которых удален этот 
        путь, в итоге получается URL значительно короче (и более 
        наглядным):</para>



      <screen>
$ svn checkout svn://host.example.com/project1
&hellip;
</screen>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.invoking.inetd">

      <!-- @ENGLISH {{{
      <title><command>svnserve</command> via <command>inetd</command></title>

        <para>If you want <command>inetd</command> launch the process,
          then you can pass the <option>-i</option>
          (<option>--><!--inetd</option>) option:</para>
      @ENGLISH }}} -->
      <title>Svnserve через inetd</title>

      <para>Если вы хотите чтобы <command>inetd</command> запускать 
        процесс, тогда вы можете передать параметр 
          <option>-i</option> (<option>--inetd</option>):</para>


      <screen>
$ svnserve -i
( success ( 1 2 ( ANONYMOUS ) ( edit-pipeline ) ) )
</screen>

      <!-- @ENGLISH {{{
      <para>When invoked with the <option>--><!--inetd</option> option,
        <command>svnserve</command> attempts to speak with a
        Subversion client via <emphasis>stdin</emphasis> and
        <emphasis>stdout</emphasis> using a custom protocol.  This is
        the standard behavior for a program being run via
        <command>inetd</command>.  The IANA has reserved port 3690
        for the Subversion protocol, so on a Unix-like system you can
        add lines to <filename>/etc/services</filename> like these (if
        they don't already exist):</para>
      @ENGLISH }}} -->
      <para>Когда произведен запуск с параметром <option>--inetd</option>,
        <command>svnserve</command> пытается общаться с клиентом
        Subversion через <emphasis>stdin</emphasis> и <emphasis>stdout</emphasis> 
        используя собственный протокол.
        Это стандартное поведение для программ, запускаемых через 
        <command>inetd</command>.  IANA зарезервировал порт  3690
      	для протокола Subversion, поэтому на unix-подобных системах Вы можете добавить в 
        <filename>/etc/services</filename> строки подобные этим (возможно, они 
        уже существуют):</para>




      <screen>
svn           3690/tcp   # Subversion
svn           3690/udp   # Subversion
</screen>


      <!-- @ENGLISH {{{
      <para>And if your system is using a classic Unix-like
        <command>inetd</command> daemon, you can add this line to
        <filename>/etc/inetd.conf</filename>:</para>
      @ENGLISH }}} -->
      <para> И если Ваша система использует классический Unix-подобный 
         демон <command>inetd</command>, Вы можете добавить эти строки в 
         <filename>/etc/inetd.conf</filename>:</para>


      <screen>
svn stream tcp nowait svnowner /usr/bin/svnserve svnserve -i
</screen>

      <!-- @ENGLISH {{{
      <para>Make sure <quote>svnowner</quote> is a user which has
        appropriate permissions to access your repositories.  Now, when
        a client connection comes into your server on port 3690,
        <command>inetd</command> will spawn an
        <command>svnserve</command> process to service it.  Of course,
        you may also want to add <option>-r</option> to the
        configuration line as well, to restrict which repositories are
        exported.</para>
      @ENGLISH }}} -->
      <para> Убедитесь, что <quote>svnowner</quote> это пользователь, который 
        имеет достаточно прав на доступ к хранилищу. Теперь, когда от клиента 
        к серверу на порт 3690 приходит запрос на соединение, 
        <command>inetd</command> запустит процесс <command>svnserve</command> 
        для обслуживания этого запроса. Конечно, вы можете также 
        захотеть добавить  <option>-r</option> строку в настройку, для 
        ограничения какие хранлища экспортируются.</para>


      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.invoking.tunnel">
        <!-- @ENGLISH {{{
        <title><command>svnserve</command> over a Tunnel</title>

        <para>A third way to invoke <command>svnserve</command> is in
          <quote>tunnel mode</quote>, with the <option>-t</option>
          option.  This mode assumes that a remote-service program
          such as <command>RSH</command> or <command>SSH</command> has
          successfully authenticated a user and is now invoking a
          private <command>svnserve</command> process <emphasis>as
          that user</emphasis>.  The <command>svnserve</command>
          program behaves normally (communicating via
          <emphasis>stdin</emphasis> and <emphasis>stdout</emphasis>),
          and assumes that the traffic is being automatically
          redirected over some sort of tunnel back to the client.
          When <command>svnserve</command> is invoked by a tunnel
          agent like this, be sure that the authenticated user has
          full read and write access to the repository database files.
          It's essentially the same as a local user accessing the
          repository via <literal>file://</literal> URLs.</para>

        <para>This option is described in much more detail in
          <xref linkend="svn.serverconfig.svnserve.sshauth"/>.</para>
      @ENGLISH }}} -->
        <title>Svnserve через тунель</title>

        <para>Третий способ запустить <command>svnserve</command> это 
          запуск в <quote>режиме тунеля</quote>, с помощью параметра 
          <option>-t</option>.  Этот режим предполагает что удаленная 
          сервисная программа, такая как <command>RSH</command> или 
          <command>SSH</command> уже успешно идентифицировала 
          пользователя и запускает частный процесс 
          <command>svnserve</command> <emphasis>от имени этого 
          пользователя</emphasis>. Программа <command>svnserve</command> 
          обычно работает (взаимодействует через 
          <emphasis>stdin</emphasis> и <emphasis>stdout</emphasis>), и 
          предполагает что трафик будет автоматически перенаправлен 
          через некоторый вид тунеля назад к клиенту. Когда 
          <command>svnserve</command> запускается через такого тунельного 
          агента, убедитесь что идентифицированный пользователь имеет 
          полные права на чтение и запись в файлы базы данных хранилища. 
          Это по существу тоже самое как локальный пользователь получает 
          доступ к хранилищу через URL вида <literal>file://</literal>.</para>

        <para>Эта возможность более детально описана в           
          <xref linkend="svn.serverconfig.svnserve.sshauth"/>.</para>


      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.invoking.winservice">

        <!-- @ENGLISH {{{
        <title><command>svnserve</command> as Windows Service</title>

        <para>If your Windows system is a descendant of Windows NT
          (2000, 2003, XP, Vista), then you can
          run <command>svnserve</command> as a standard Windows
          service.  This is typically a much nicer experience than
          running it as a standalone daemon with the <option>--><!--daemon
          (-d)</option> option.  Using daemon-mode requires launching
          a console, typing a command, and then leaving the console
          window running indefinitely.  A Windows service, however,
          runs in the background, can start at boot time
          automatically, and can be started and stopped using the same
          consistent administration interface as other
          Windows services. </para>

        <para>You'll need to define the new service using the
          command-line tool <command>SC.EXE</command>.  Much like
          the <command>inetd</command> configuration line, you must
          specify an exact invocation of <command>svnserve</command>
          for Windows to run at start-up time:</para>
        @ENGLISH }}} -->
        <title>Svnserve как сервис Windows</title>

        <para>Если ваша Windows система является наследником Windows NT
          (2000, 2003, XP, Vista), тогда вы можете запустить 
          <command>svnserve</command> как стандартный сервис Windows. 
          Обычно это более лучший выбор чем запуск его как отдельное 
          приложение с параметром <option>--daemon (-d)</option>.  
          Использование режим демона требует запуска консоли, ввода 
          команд, а затем поддержания этой консоли постоянно запущенной. 
          С другой стороны, сервис Windows запускается в фоне, может 
          автоматически запускаться во время загрузки, и может быть 
          запушен и остановлен через тот же интерфейс администрирования 
          что и другие сервисы Windows. 
          <footnote>
            <para>Примечание переводчика. Самое главное преимущество 
              запуска программ в виде сервиса, заключается в том, что не 
              требуется вход пользователя в систему. Если сервис 
              настроен чтобы запускаться автоматически, он предоставляет 
              доступ к своим возможностям еще до того как появится 
              диалог с требованием ввода пароля.
            </para>
          </footnote>
        </para>
        

        <para>Вы нуждаетесь в определении нового сервиса используя 
          утилиту командной строки <command>SC.EXE</command>. Подобно 
          строке настройки <command>inetd</command>, вы должны указать 
          точный вызов <command>svnserve</command> для того чтобы 
          запустить его во время загрузки Windows:</para>


        <screen>
C:\&gt; sc create svn
        binpath= "C:\svn\bin\svnserve.exe --service -r C:\repos"
        displayname= "Subversion Server"
        depend= Tcpip
        start= auto
</screen>


        <!-- @ENGLISH {{{
        <para>This defines a new Windows service
          named <quote>svn</quote>, and which executes a
          particular <command>svnserve.exe</command> command when
          started (in this case, rooted
          at <filename>C:\repos</filename>.)  There are a number of
          caveats in the prior example, however.</para>

        <para>First, notice that the <command>svnserve.exe</command>
          program must always be invoked with
          the <option>--><!--service</option> option.  Any other options to
          <command>svnserve</command> must then be specified on the
          same line, but you cannot add conflicting options such
          as <option>--><!--daemon
          (-d)</option>, <option>--><!--tunnel</option>, or <option>--><!--inetd
          (-i)</option>.  Options such as <option>-r</option>
          or <option>--><!--listen-port</option> are fine, though.  Second, be
          careful about spaces when invoking
          the <command>SC.EXE</command> command: the
          <literal>key= value</literal> patterns must have no
          spaces between <literal>key=</literal> and exactly one
          space before the <literal>value</literal>.  Lastly, be
          careful about spaces in your command-line to be invoked.  If
          a directory name contains spaces (or other characters that
          need escaping), place the entire inner value
          of <literal>binpath</literal> in double-quotes, by escaping
          them:</para>
        @ENGLISH }}} -->
        <para>Эта настройка определяет новый сервис Windows с именем
          <quote>svn</quote>, который выполняет программу 
          <command>svnserve.exe</command> которая начинает хранилища с 
          адреса (в данном случае) <filename>C:\repos</filename>.
          Однако есть несколько предостережений к предыдущему примеру.</para>

        <para>Первое, помните что программа 
          <command>svnserve.exe</command> должна всегда запускаться с 
          параметром <option>--service</option>. Любые другие параметры 
          <command>svnserve.exe</command> должны быть указаны в той же 
          строке, но вы не можете добавлять конфликтующие параметры 
          такие как <option>--daemon (-d)</option>, 
          <option>--tunnel</option>, или <option>--inetd (-i)</option>.  
          Параметры такие как <option>-r</option> или
          <option>--listen-port</option> приветствуются. Вовторых, 
          будьте внимательны к пробелам когда запускаете команду
          <command>SC.EXE</command>: шаблон <literal>key= 
            value</literal> не должен иметь пробелов между 
          <literal>key=</literal> и точно один пробел перед <literal>value</literal>.  
          Наконец, будьте внимательны с пробелами в командной строке 
          которая будет выполняться. Если имя папки содержит пробелы 
          (или другие символы которые должны быть 
          <quote>замаскированы</quote>) заключайте все внутренне 
          содержимое в двойные кавычки, чтобы замаскировать их:</para>



        <screen>
C:\&gt; sc create svn
        binpath= "\"C:\program files\svn\bin\svnserve.exe\" --service -r C:\repos"
        displayname= "Subversion Server"
        depend= Tcpip
        start= auto
</screen>


        <!-- @ENGLISH {{{
        <para>Once the service is defined, it can stopped, started, or
          queried using standard GUI tools (The Services
          administrative control panel), or at the command line as
          well:</para>
        @ENGLISH }}} -->
        <para>Как только сервис определен, он может быть остановлен, 
          запущен или опрошен с использованием стандартных графических 
          инструментов (Панель управления - Администрирование - 
          Сервисы) или командную строку:</para>


        <screen>
C:\&gt; net stop svn
C:\&gt; net start svn
</screen>


        <!-- @ENGLISH {{{
        <para>The service can also be uninstalled (i.e. undefined) by
          deleting its definition:  <literal>sc delete svn</literal>.
          Just be sure to stop the service first!
          The <command>SC.EXE</command> program has many other
          subcommands and options, run <literal>sc /?</literal> to
          learn more about it.</para>
        @ENGLISH }}} -->
        <para>Сервис также может быть удален путем удаления его 
          определения: <literal>sc delete svn</literal>.
          Но перед этим убедитесь что сервис остановлен!
          Программа <command>SC.EXE</command> имеет множетство других 
          подкоманд и опций, для получения более полной информации 
          запустите <literal>sc /?</literal>.</para>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.auth">

      <!-- @ENGLISH {{{
      <title>Built-in authentication and authorization</title>

      <para>When a client connects to an <command>svnserve</command>
        process, the following things happen:</para>
      @ENGLISH }}} -->
      <title>Встроенная идентификация и авторизация</title>
      <para>Когда клиент соединяется с процессом <command>svnserve</command>,
        то происходит следующее:</para>
      
      <!-- @ENGLISH {{{
      <itemizedlist>
        <listitem><para>The client selects a specific
        repository.</para></listitem>

        <listitem><para>The server processes the repository's
        <filename>conf/svnserve.conf</filename> file, and begins to
        enforce any authentication and authorization policies defined
        therein.</para></listitem>

        <listitem><para>Depending on the situation and authorization
        policies,</para>

          <itemizedlist>
            <listitem><para>the client may be allowed to make requests
              anonymously, without ever receiving an authentication
              challenge, OR</para></listitem>

            <listitem><para>the client may be challenged for
              authentication at any time, OR</para></listitem>

            <listitem><para>if operating in <quote>tunnel
              mode</quote>, the client will declare itself to be
              already externally authenticated.</para></listitem>
          </itemizedlist>
        </listitem>

      </itemizedlist>
      @ENGLISH }}} -->
      <itemizedlist>
        <listitem><para>Клиент указывает конкретное хранилище </para></listitem>

        <listitem><para>Сервер обрабатывает файл хранилища
           <filename>conf/svnserve.conf</filename>, и начинает осуществлять 
           правила идентификации и авторизации, указанные там. 
        </para></listitem>

       <listitem><para>В зависимости от ситуации и правил авторизации,</para>

          <itemizedlist>
             <listitem><para>клиенту может быть разрешено делать анонимные
                запросы, без получения вызова на идентификацию, ИЛИ </para></listitem>

             <listitem><para>клиент может быть вызван на идентификацию в любой момент, 
                 ИЛИ </para></listitem>
      	     <listitem><para>при обслуживании в <quote>туннельном режиме</quote>, клиент 
                сам объявит, что уже был идентифицирован.</para></listitem>
          </itemizedlist>
        </listitem>

      </itemizedlist>


    <!-- @ENGLISH {{{

      <para>At the time of writing, the server only knows how to send
        a CRAM-MD5 <footnote><para>See RFC 2195.</para></footnote>
        authentication challenge.  In essence, the server sends a
        small amount of data to the client.  The client uses the MD5
        hash algorithm to create a fingerprint of the data and
        password combined, then sends the fingerprint as a response.
        The server performs the same computation with the stored
        password to verify that the result is identical.  <emphasis>At
        no point does the actual password travel over the
        network.</emphasis></para>

      <para>It's also possible, of course, for the client to be
        externally authenticated via a tunnel agent, such as
        <command>SSH</command>.  In that case, the server simply
        examines the user it's running as, and uses it as the
        authenticated username.  For more on this, see <xref
        linkend="svn.serverconfig.svnserve.sshauth"/>.</para>

      <para>As you've already guessed, a repository's
        <filename>svnserve.conf</filename> file is the central
        mechanism for controlling authentication and authorization
        policies.  The file has the same format as other configuration
        files (see <xref linkend="svn.advanced.confarea"/>): section names
        are marked by square brackets (<literal>[</literal> and
        <literal>]</literal>), comments begin with hashes
        (<literal>#</literal>), and each section contains
        specific variables that can be set (<literal>variable =
        value</literal>).  Let's walk through this file and learn how
        to use them.</para>
      @ENGLISH }}} -->
      <para>Во время написания данного материала сервер знал только об вызове
        авторизации через CRAM-MD5 <footnote><para>Смотри RFC 
            2195.</para></footnote>. В сущности, сервер отправляет 
        некоторые данные клиенту. Клиент, используя хэш алгоритма MD5, 
        создает отпечаток (fingerprint) из совмещенных вместе этих 
        данных и своего пароля, после чего отправляет этот отпечаток 
        серверу как ответ. Сервер производит подобные вычисления со 
        своей версией пользовательского пароля и проверяет идентичность 
        результатов. <emphasis>Таким образом пароль никогда не 
        передается в открытую по сети.</emphasis></para>

     <para> Также возможно, что клиент уже был идентифицирован через внешнего
        туннельного агента, такого как <command>SSH</command>. В таком
        случае, сервер просто проверяет запустившего его пользователя и
        в дальнейшем использует идентифицированное имя пользователя.
        Более подробно об этом смотри в <xref 
         linkend="svn.serverconfig.svnserve.sshauth"/>.</para>

     <para>Как Вы уже догадались, файл хранилища 
       <filename>svnserve.conf</filename> - центральный механизм 
        контроля правил идентификации и авторизации. Этот файл имеет такой же 
        формат, как и другие конфигурационные файлы (см.  <xref 
          linkend="svn.advanced.confarea"/>): имена 
        секций помечены	квадратными скобками ((<literal>[</literal> и 
        <literal>]</literal>), комментарии начинаются с 
        <literal>#</literal>, а каждая секция содержит определенные 
        переменные, которые могут быть использованы для конфигурирования 
        (<literal>переменная = значение</literal>). Давайте 
        посмотрим на этот файл и изучим как им пользоваться. </para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.auth.users">
        <!-- @ENGLISH {{{
        <title>Create a 'users' file and realm</title>

        <para>For now, the <literal>[general]</literal> section of the
          <filename>svnserve.conf</filename> has all the variables you
          need.  Begin by defining a file which contains usernames and
          passwords, and an authentication realm:</para>
        @ENGLISH }}} -->
        <title>Создание файла пользователей и область хранилища </title>
        <para>Сейчас, секция <literal>[general]</literal>
           в <filename>svnserve.conf</filename> имеет все необходимые Вам
           переменные. Начнем с определения файла, содержащего имена
           пользователей и пароли, а также с области хранилища: </para>

        <screen>
[general]
password-db = userfile
realm = example realm
</screen>

        <!-- @ENGLISH {{{
        <para>The <literal>realm</literal> is a name that you define.
          It tells clients which sort of <quote>authentication
          namespace</quote> they're connecting to; the Subversion
          client displays it in the authentication prompt, and uses it
          as a key (along with the server's hostname and port) for
          caching credentials on disk (see <xref
          linkend="svn.serverconfig.netmodel.credcache"/>).  The
          <literal>password-db</literal> variable points to a separate
          file that contains a list of usernames and passwords, using
          the same familiar format.  For example:</para>
        @ENGLISH }}} -->
        <para><literal>realm</literal> - это определяемое Вами имя. Она сообщает 
          клиентам, к какой <quote>области идентификации</quote> они 
          подсоединяются; клиенту Subversion она выводится в приглашении к 
          аутентификации, и используется как ключ (вместе с именем сервера и 
          портом) для кэширования клиентской идентификационной 
         	информации на диск (см. <xref 
            linkend="svn.serverconfig.netmodel.credcache"/>). 
          Переменная 	<literal>password-db</literal> указывает на 
          отдельный файл, который содержит список пользователей и пароли 
          в таком же простом формате. Например: </para>


        <screen>
[users]
harry = foopassword
sally = barpassword
</screen>

        <!-- @ENGLISH {{{
        <para>The value of <literal>password-db</literal> can be an
          absolute or relative path to the users file.  For many
          admins, it's easy to keep the file right in the
          <filename>conf/</filename> area of the repository, alongside
          <filename>svnserve.conf</filename>.  On the other hand, it's
          possible you may want to have two or more repositories share
          the same users file; in that case, the file should probably
          live in a more public place.  The repositories sharing the
          users file should also be configured to have the same realm,
          since the list of users essentially defines an
          authentication realm.  Wherever the file lives, be sure to
          set the file's read and write permissions appropriately.  If
          you know which user(s) <command>svnserve</command> will run
          as, restrict read access to the user file as necessary.</para>
        @ENGLISH }}} -->
        <para>Значение <literal>password-db</literal> может быть 
          абсолютным или относительным путем к файлу пользователей. Для 
          большинства администраторов, его легче держать в 
          <filename>conf/</filename> области хранилища, рядом с 
          <filename>svnserve.conf</filename>. С другой стороны, 
          возможно, Вы захотите использовать (разделять) один и тот же 
          файл пользователей для двух или более хранилищ, в этом случае 
          этот файл стоит поместить в более доступное место. Хранилища 
          разделяющие файл пользователей, должны быть также 
          сконфигурированы с одинаковыми областями, так как список 
          пользователей по существу определяет область аутентификации. 
          Где бы в итоге файл не находился, убедитесь, что у него 
          выставлены соответствующие права на чтение/запись. Если Вы 
          знаете от имени какого пользователя(-ей) будет запускаться 	 
          <command>svnserve</command>, то ограничьте доступ на чтение 
          только тем пользователем, которым это нужно.</para>


      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.auth.general">

        <!-- @ENGLISH {{{
        <title>Set access controls</title>

        <para>There are two more variables to set in the
          <filename>svnserve.conf</filename> file: they determine what
          unauthenticated (anonymous) and authenticated users are
          allowed to do.  The variables <literal>anon-access</literal>
          and <literal>auth-access</literal> can be set to the values
          <literal>none</literal>, <literal>read</literal>, or
          <literal>write</literal>.  Setting the value to
          <literal>none</literal> restricts all access of any kind;
          <literal>read</literal> allows read-only access to the
          repository, and <literal>write</literal> allows complete
          read/write access to the repository.  For example:</para>
        @ENGLISH }}} -->
        <title>Установка контроля доступа</title>	
      	<para>Есть еще две дополнительных переменные в 
          <filename>svnserve.conf</filename>: они определяют, 
          что будут допущены делать не идентифицированные (анонимные) и 
          идентифицированные пользователи. Переменные 
          <literal>anon-access</literal> и <literal>auth-access</literal> 
          могут иметь значения:	<literal>none</literal>, 
          <literal>read</literal>, или <literal>write</literal>. 
          Установка значения в <literal>none</literal> запрещает доступ 
          любого рода; <literal>read</literal> - доступ к хранилищу 
          только на чтение, а <literal>write</literal> -	  позволяет 
          полный доступ к хранилищу на чтение/запись. Например:</para>


        <screen>
[general]
password-db = userfile
realm = example realm

# anonymous users can only read the repository
anon-access = read

# authenticated users can both read and write
auth-access = write
</screen>

        <!-- @ENGLISH {{{
        <para>The example settings are, in fact, the default values of
          the variables, should you forget to define them.  If you
          want to be even more conservative, you can block anonymous
          access completely:</para>
        @ENGLISH }}} -->
      	<para>Значения установленные в примере - фактически значения 
          по умолчанию, они будут установлены если Вы не захотите 
          определить их. Если Вы хотите быть более консервативным, 
          то можете заблокировать полностью анонимный доступ:</para>



        <screen>
[general]
password-db = userfile
realm = example realm

# anonymous users aren't allowed
anon-access = none

# authenticated users can both read and write
auth-access = write
</screen>

      <!-- @ENGLISH {{{
      <para>The server process not only understands
        these <quote>blanket</quote> access controls to the
        repository, but also finer-grained access restrictions placed
        on specific files and directories within the repository.  To
        make use of this feature, you need to define a file containing
        more detailed rules, and then set
        the <literal>authz-db</literal> variable to point to it:</para>
      @ENGLISH }}} -->
      <para>Процесс сервера не только понимает такой 
        <quote>всеохватывающее</quote> управление доступом к хранилищу, 
        но таже детальные ограничения наложенные на конкретные файлы и 
        папки внутри хранилища. Для использования этой функциональности, 
        вы должны определить файл содержащий более детальные правила, и 
        затем установить переменную <literal>authz-db</literal> для 
        указания на этот файл:</para>



        <screen>
[general]
password-db = userfile
realm = example realm

# Specific access rules for specific locations
authz-db = authzfile
</screen>

        <!-- @ENGLISH {{{
        <para>The syntax of the <filename>authzfile</filename> file is
          discussed in detail in
          <xref linkend="svn.serverconfig.pathbasedauthz"/>.  Note
          that the <literal>authz-db</literal> variable isn't mutually
          exclusive with the <literal>anon-access</literal>
          and <literal>auth-access</literal> variables;  if all the
          variables are defined at once, then <emphasis>all</emphasis>
          of the rules must be satisfied before access is allowed.</para>
        @ENGLISH }}} -->
        <para>Синтаксис файла <filename>authzfile</filename> детально 
          обсуждается в <xref linkend="svn.serverconfig.pathbasedauthz"/>.  
          Обратите внимание что переменная <literal>authz-db</literal> 
          не взаимно исключающая с переменными 
          <literal>anon-access</literal> и 
          <literal>auth-access</literal>; если все переменные 
          одновременно определены, тогда <emphasis>все</emphasis> 
          правила должны быть удовлетворены для предоставления доступа.</para>



      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.sshauth">

      <!-- @ENGLISH {{{
      <title>Tunneling over SSH</title>

      <para><command>svnserve</command>'s built-in authentication can
        be very handy, because it avoids the need to create real
        system accounts.  On the other hand, some administrators
        already have well-established SSH authentication frameworks in
        place.  In these situations, all of the project's users
        already have system accounts and the ability to <quote>SSH
        into</quote> the server machine.</para>

      <para>It's easy to use SSH in conjunction with
        <command>svnserve</command>.  The client simply uses the
        <literal>svn+ssh://</literal> URL schema to connect:</para>
      @ENGLISH }}} -->
      <title>Тунелирование через SSH</title>
    	<para>Встроенная в <command>svnserve</command> идентификация может
        быть более удобной, так как избегает необходимости создавать 
        реальные системные учетные записи. Другими словами, некоторые 
   	    администраторы уже имеют хорошо настроенные SSH оболочки в своих
	      системах. В этой ситуации все пользователи проектов уже имеют
        системные учетные записи и способность к <quote>SSH
        into</quote> на серверную машину. </para>

      <para>Проще всего использовать SSH в связке с 
        <command>svnserve</command>. Клиенты просто используют для 
        коннекта схему <literal>svn+ssh://</literal>:</para>

      <screen>
$ whoami
harry

$ svn list svn+ssh://host.example.com/repos/project
harry@host.example.com's password:  *****

foo
bar
baz
&hellip;
</screen>


      <!-- @ENGLISH {{{
      <para>In this example, the Subversion client is invoking a local
        <command>ssh</command> process, connecting to
        <literal>host.example.com</literal>, authenticating as the
        user <literal>harry</literal>, then spawning a private
        <command>svnserve</command> process on the remote machine
        running as the user <literal>harry</literal>.  The
        <command>svnserve</command> command is being invoked in tunnel
        mode (<option>-t</option>) and its network protocol is being
        <quote>tunneled</quote> over the encrypted connection by
        <command>ssh</command>, the tunnel-agent.
        <command>svnserve</command> is aware that it's running as the
        user <literal>harry</literal>, and if the client performs a
        commit, the authenticated username will be attributed as the
        author of the new revision.</para>

      <para>The important thing to understand here is that the
        Subversion client is <emphasis>not</emphasis> connecting to a
        running <command>svnserve</command> daemon.  This method of
        access doesn't require a daemon, nor does it notice one if
        present.  It relies wholly on the ability of
        <command>ssh</command> to spawn a temporary
        <command>svnserve</command> process, which then terminates
        when the network connection is closed.</para>
      @ENGLISH }}} -->
      <para>В этом примере клиент Subversion вовлекает локальный процесс 
        <command>ssh</command>, соединяется с 
        <literal>host.example.com</literal>, идентифицируется как 
        пользователь <literal>harry</literal>, затем порождает личный 
        процесс <command>svnserve</command> на удаленной машине 
        запускаемый от имени пользователя <literal>harry</literal>.  
        Команда	<command>svnserve</command> была вовлечена в режим 
        тунелирования (<option>-t</option>) и ее	сетевой протокол был 
        <quote>тунелирован</quote> через зашифрованное соединение через 
        тунельного-агента <command>ssh</command>.        
        <command>svnserve</command> знает что он запущен пользователем 
        <literal>harry</literal>, и если клиент выполняет фиксацию,	
        идентификационное имя пользователя будет использовано как имя 
        автора новой ревизии.</para>

      <para>Важная вещь для понимания здесь, это то что клиент 
        Subversion <emphasis>не</emphasis> соединяется с запущенным демоном
        <command>svnserve</command>.  Этот метод доступа не требует демона, ни 
      	делает уведомления даже если он присутствует. Он использует в целом
      	способность <command>ssh</command> запускать временный процесс 
        <command>svnserve</command>, которые завершается когда сетевое
       	соединение закроется.</para>

      <!-- @ENGLISH {{{
      <para>When using <literal>svn+ssh://</literal> URLs to access a
        repository, remember that it's the <command>ssh</command>
        program prompting for authentication, and
        <emphasis>not</emphasis> the <command>svn</command> client
        program.  That means there's no automatic password caching
        going on (see <xref linkend="svn.serverconfig.netmodel.credcache"/>).  The
        Subversion client often makes multiple connections to the
        repository, though users don't normally notice this due to the
        password caching feature.  When using
        <literal>svn+ssh://</literal> URLs, however, users may be
        annoyed by <command>ssh</command> repeatedly asking for a
        password for every outbound connection.  The solution is to
        use a separate SSH password-caching tool like
        <command>ssh-agent</command> on a Unix-like system, or
        <command>pageant</command> on Windows.</para>
      @ENGLISH }}} -->
      <para>Когда для доступа к хранилищу используется URL вида
        <literal>svn+ssh://</literal>, помните что это программа 
        <command>ssh</command> запрашивает идентификацию, а 
        <emphasis>не</emphasis> клиентская программа 
        <command>svn</command>.  Это означает что нет автоматического 
        кеширования паролей (см. <xref 
          linkend="svn.serverconfig.netmodel.credcache"/>). Клиенты 
      	Subversion часто делают несколько соединений к хранилищу, хотя
       	пользователи обычно не знают об этом из-за возможности кеширования
      	паролей. Однако когда используют URL вида
      	<literal>svn+ssh://</literal> URLs, пользователи могут быть 
        раздражены <command>ssh</command> из-за повторяющихся запросов 
        пароля для каждого исходящего соединения. Решение этой проблемы 
        заключается в использовании отдельного инструмента для 
        кеширования паролей SSH, подобных 
        <command>ssh-agent</command> на Unix-подобных системах, или
        <command>pageant</command> в Windows.</para>

      <!-- @ENGLISH {{{
      <para>When running over a tunnel, authorization is primarily
        controlled by operating system permissions to the repository's
        database files; it's very much the same as if Harry were
        accessing the repository directly via a
        <literal>file://</literal> URL.  If multiple system users are
        going to be accessing the repository directly, you may want to
        place them into a common group, and you'll need to be careful
        about umasks.  (Be sure to read <xref
        linkend="svn.serverconfig.multimethod"/>.)  But even in the case of
        tunneling, the <filename>svnserve.conf</filename> file can
        still be used to block access, by simply setting
        <literal>auth-access = read</literal> or <literal>auth-access
        = none</literal>.
        <footnote>
          <para>Note that using any sort
            of <command>svnserve</command>-enforced access control at
            all is a bit pointless;  the user already has direct access to
            the repository database.</para>
        </footnote>
      </para>

      <para>You'd think that the story of SSH tunneling would end
        here, but it doesn't.  Subversion allows you to create custom
        tunnel behaviors in your run-time <filename>config</filename>
        file (see <xref linkend="svn.advanced.confarea"/>).  For example,
        suppose you want to use RSH instead of SSH.  In the
        <literal>[tunnels]</literal> section of your
        <filename>config</filename> file, simply define it like
        this:</para>
      @ENGLISH }}} -->

      <para>Когда выполняется через тунелирование, идентификация 
        первоначально управляется правами операционной системы на файлы 
        базы данных хранилища; это очень похоже на то как если бы Harry 
        получала доступ к хранилищу напрямую через URL 
        <literal>file:///</literal>.  Если несколько пользователей 
        системы получают доступ к хранилищу напрямую, вы можете захотеть 
        поместить их в общую группу, и вы должны будете быть очень 
        осторожным при разрешении (umasks). (Прочитайте <xref 
       	linkend="svn.serverconfig.multimethod"/>.)  Но в каждом случае
        тунелирования файл <filename>svnserve.conf</filename> может 
        продолжать использоваться для блокирования доступа, простой 
        установкой <literal>auth-access = read</literal> или 
        <literal>auth-access = none</literal>.
        <footnote>
          <para>Примечание, использование любой вида 
            <command>svnserve</command>-управления доступом вообщето 
            бесполезно, пользователь все равно уже имеет прямой доступ к 
            базе данных хранилища.</para>
        </footnote>
      </para>

      <para>Вы не должны думать что рассказ о SSH тунелирование будет 
        закончен здесь. Subversion позволяет вам создавать заказное 
        поведение тунеля в файле <filename>config</filename>
        (смотри <xref linkend="svn.advanced.confarea"/>).  Например, 
        предположим что вы хотите использовать RSH вместо SSH. В разделе 
        <literal>[tunnels]</literal> файла <literal>[tunnels]</literal> 
        просто укажите подобно этому:</para>


      <screen>
[tunnels]
rsh = rsh
</screen>


      <!-- @ENGLISH {{{
      <para>And now, you can use this new tunnel definition by using a
        URL schema that matches the name of your new variable:
        <literal>svn+rsh://host/path</literal>.  When using the new
        URL schema, the Subversion client will actually be running the
        command <command>rsh host svnserve -t</command> behind the
        scenes.  If you include a username in the URL (for example,
        <literal>svn+rsh://username@host/path</literal>) the client
        will also include that in its command (<command>rsh
        username@host svnserve -t</command>).  But you can define new
        tunneling schemes to be much more clever than that:</para>
       @ENGLISH }}} -->
      <para>И сейчас вы можете использовать новое определение туннеля используя схему 
        URL которая соответствует имени вашей новой переменной:  
        <literal>svn+rsh://host/path</literal>. Затем используя новую схему URL, клиент 
        Subversion будет выполнять команду <command>rsh host 
        svnserve -t</command> 
        за кулисами. Если вы включите имя пользователя в URL (на пример,
        <literal>svn+rsh://username@host/path</literal>) клиент также будет 
        включать его в эту команду (<command>rsh
        username@host svnserve -t</command>). Но вы может определить новую 
        схему 
        туннелирования которая будет более умная чем эта:</para>



      <screen>
[tunnels]
joessh = $JOESSH /opt/alternate/ssh -p 29934
</screen>


    <!-- @ENGLISH {{{

      <para>This example demonstrates a couple of things.  First, it
        shows how to make the Subversion client launch a very specific
        tunneling binary (the one located at
        <filename>/opt/alternate/ssh</filename>) with specific
        options.  In this case, accessing a
        <literal>svn+joessh://</literal> URL would invoke the
        particular SSH binary with <option>-p 29934</option> as
        arguments&mdash;useful if you want the tunnel program to
        connect to a non-standard port.</para>

      <para>Second, it shows how to define a custom environment
        variable that can override the name of the tunneling program.
        Setting the <literal>SVN_SSH</literal> environment variable is
        a convenient way to override the default SSH tunnel agent.
        But if you need to have several different overrides for
        different servers, each perhaps contacting a different port or
        passing a different set of options to SSH, you can use the
        mechanism demonstrated in this example.  Now if we were to set
        the <literal>JOESSH</literal> environment variable, its value
        would override the entire value of the tunnel
        variable&mdash;<command>$JOESSH</command> would be executed
        instead of <command>/opt/alternate/ssh -p
        29934</command>.</para>
      @ENGLISH }}} -->
      <para>Этот пример демонстрирует связанные вещи. С начала он 
       показывает как можно сделать чтобы клиент Subversion запускал очень 
       специфическую
       программу тунелирования (она расположена в 
       <filename>/opt/alternate/ssh</filename>) 
       с некоторым параметром. В данном случае, доступ к 
       <literal>svn+joessh://</literal> будет
       вовлекать особую программу SSH с аргументами <option>-p 29934</option>
       &mdash; полезно если вы хотите соединить программу тунелирования на 
       нестандартный порт.</para>

      <para>Затем он показывает как определить пользовательскую переменную
        окружения, которая может перекрыть имя программы тунелирования. 
        Установка переменной окружения <literal>SVN_SSH</literal> это 
        удобный путь для перекрытия агента тунелирования SSH по умолчанию.
        Но если вы нуждаетесь в нескольких различных перекрытиях, для разных 
        серверов, каждый возможно взаимодействует с разными портами или 
        передача различных наборов параметров в SSH, вы можете использовать 
        механизм показанный в этом примере. 
        Сейчас, если вы установите переменную окружения <literal>JOESSH</literal>, ее 
        значение будет перекрывать содержимое переменной тунелирования
        &mdash;<command>$JOESSH</command> будет выполняться вместо 
        <command>/opt/alternate/ssh -p 29934</command>.</para>


    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.sshtricks">

    <!-- @ENGLISH {{{
	    
      <title>SSH configuration tricks</title>

      <para>It's not only possible to control the way in which the
        client invokes <command>ssh</command>, but also to control
        the behavior of <command>sshd</command> on your server
        machine.  In this section, we'll show how to control the
        exact <command>svnserve</command> command executed
        by <command>sshd</command>, as well as how to have multiple
        users share a single system account.</para>
      @ENGLISH }}} -->
      <title>Трюки конфигурирования SSH</title>
      <para>Возможно не только управлять как клиент выполняет <command>ssh</command>,
        но также управлять поведением <command>sshd</command> на машине вашего сервера.
        В этом разделе, мы покажем как управлять точным исполнением команды  
        <command>svnserve</command>, так же хорошо как иметь несколько
        совместных 
        ресурсов (share) пользователей под одной учетной записью.</para>


      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.sshtricks.setup">

        <!-- @ENGLISH {{{
	      <title>Initial setup</title>

        <para>To begin, locate the home directory of the account
          you'll be using to launch <command>svnserve</command>.  Make
          sure the account has an SSH public/private keypair
          installed, and that the user can log in via public-key
          authentication.  Password authentication will not work,
          since all of the following SSH tricks revolve around using
          the SSH <filename>authorized_keys</filename> file.</para>

        <para>If it doesn't already exist, create the
          <filename>authorized_keys</filename> file (on Unix,
          typically <filename>~/.ssh/authorized_keys</filename>).
          Each line in this file describes a public key that is
          allowed to connect.  The lines are typically of the
          form:</para>
        @ENGLISH }}} -->
        <title>Начальная настройка</title>
        <para>Для начала, перейдите в домашнюю папку учетной записи которую вы 
          используете
          для запуска <command>svnserve</command>. Убедитесь что учетная запись 
          имеет 
          установленную пару ключей SSH (публичную/приватную), и что 
          пользователь может 
          зайти через идентификацию с использованием публичного ключа. Парольная 
          идентификация
          не работает, так как все следующие SSH трюки  вращаются вокруг 
          использования файла SSH <filename>authorized_keys</filename>.</para>

        <para>Если он не существует, создайте файл <filename>authorized_keys</filename>
          (на Unix, обычно <filename>~/.ssh/authorized_keys</filename>). Каждая 
          строка этого
          файла описывает публичный ключ, который разрешен для соединения. 
          Строки обычно в следующей форме:</para>

        <screen>
  ssh-dsa AAAABtce9euch&hellip; user@example.com
</screen>

    <!-- @ENGLISH {{{

        <para>The first field describes the type of key, the second
          field is the uuencoded key itself, and the third field is a
          comment.  However, it's a lesser known fact that the entire
          line can be preceded by a <literal>command</literal>
          field:</para>
        @ENGLISH }}} -->
        <para>Первое поле описывает тип ключа, второе поле uu-кодированный (uuencoded)
          ключ и третье поле это комментарий. Однако, менее известный факт 
          что всей строке
          может предшествовать поле <literal>command</literal>:</para>



        <screen>
  command="program" ssh-dsa AAAABtce9euch&hellip; user@example.com
</screen>


    <!-- @ENGLISH {{{

        <para>When the <literal>command</literal> field is set, the
          SSH daemon will run the named program instead of the
          typical <command>svnserve -t</command> invocation that the
          Subversion client asks for.  This opens the door to a number
          of server-side tricks.  In the following examples, we
          abbreviate the lines of the file as:</para>
        @ENGLISH }}} -->
        <para>Когда поле <literal>command</literal> установлено, демон 
          SSH будет выполнять указанную программу, вместо обычной 
          <command>svnserve -t</command> моля что клиент знает об этом.  
          Это открывает двери для многих трюков на стороне сервера.  В следующем
          примерах мы сокращаем строки в файле так :</para>



        <screen>
  command="program" TYPE KEY COMMENT
</screen>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.sshtricks.fixedcmd">
        <!-- @ENGLISH {{{
	      
        <title>Controlling the invoked command</title>

        <para>Because we can specify the executed server-side command,
          it's easy to name a specific <command>svnserve</command>
          binary to run and to pass it extra arguments:</para>
        @ENGLISH }}} -->
        <title>Управление вовлекаемой команды</title>
        <para>Так как мы можем указать выполняемую на сервере команду, проще назвать 
          специфическую программу <command>svnserve</command> и передать дополнительные 
          параметры:</para>

        <screen>
  command="/path/to/svnserve -t -r /virtual/root" TYPE KEY COMMENT
</screen>

        <!-- @ENGLISH {{{
        <para>In this example, <filename>/path/to/svnserve</filename>
          might be a custom wrapper script
          around <command>svnserve</command> which sets the umask (see
          <xref linkend="svn.serverconfig.multimethod"/>).  It also shows how to
          anchor <command>svnserve</command> in a virtual root
          directory, just as one often does when
          running <command>svnserve</command> as a daemon process.
          This might be done either to restrict access to parts of the
          system, or simply to relieve the user of having to type an
          absolute path in the <literal>svn+ssh://</literal>
          URL.</para>

        <para>It's also possible to have multiple users share a single
          account.  Instead of creating a separate system account for
          each user, generate a public/private keypair for each
          person.  Then place each public key into
          the <filename>authorized_users</filename> file, one per
          line, and use the <option>--><!--tunnel-user</option>
          option:</para>
        @ENGLISH }}} -->
        <para>В этом примере, <filename>/path/to/svnserve</filename> может быть
          пользовательским скриптом, оберткой вокруг 
          <command>svnserve</command> которая устанавливает umask (маску????)
          (смотри <xref linkend="svn.serverconfig.multimethod"/>).  Также 
          показано как привязать <command>svnserve</command> к 
          виртуальному корневому каталогу, который часто делается когда 
          запускается <command>svnserve</command> 
          как процесс-демон. Это может быть сделано либо ограничением доступа к 
          части системы, или просто заставляя пользователя указывать 
          абсолютный путь в <literal>svn+ssh://</literal> URL.</para>

        <para>Так же возможно иметь нескольких пользовательских разделяемых 
          ресурсов под одной учетной записью. Вместо создания различных учетных 
          записей для каждого пользователя, сгенерируйте пару публичный/частный 
          ключ 
          для каждого человека. Затем поместите каждый публичный ключ в файл
          <filename>authorized_users</filename>, по одному ключу в строке, и 
          используйте параметр <option>--tunnel-user</option>:</para>


        <screen>
  command="svnserve -t --tunnel-user=harry" TYPE1 KEY1 harry@example.com
  command="svnserve -t --tunnel-user=sally" TYPE2 KEY2 sally@example.com
</screen>

        <!-- @ENGLISH {{{
        <para>This example allows both Harry and Sally to connect to
          the same account via public-key authentication.  Each of
          them has a custom command that will be executed;
          the <option>--><!--tunnel-user</option> option 
          tells <command>svnserve -t</command> to assume that the named
          argument is the authenticated user.  Without
          <option>--><!--tunnel-user</option>, it would appear as though
          all commits were coming from the one shared system
          account.</para>

        <para>A final word of caution: giving a user access to the
          server via public-key in a shared account might still allow
          other forms of SSH access, even if you've set
          the <literal>command</literal> value
          in <filename>authorized_keys</filename>.  For example, the
          user may still get shell access through SSH, or be able to
          perform X11 or general port-forwarding through your server.
          To give the user as little permission as possible, you may
          want to specify a number of restrictive options immediately
          after the <literal>command</literal>:</para>
        @ENGLISH }}} -->
        <para>Этот пример позволяет обоим, Гарии (Harry) и Салли (Sally) 
          соединяться к одной учетной записи через идентификацию через публичный
          ключ. Каждый из них имеет собственную команду, которая будет выполняться,
          параметр <option>--tunnel-user</option> говорит 
          <command>svnserve -t</command>
          какой из названных аргументов идентифицирует пользователя. Без 
          <option>--tunnel-user</option> они будут появляться не смотря на все
          фиксации которые сделаны из одной разделяемой учетной записи.</para>

        <para>В заключение предостережение: предоставление доступа пользователям
          к серверу через публичные ключи в разделяемой учетной записи
          может оставлять доступным другие формы доступа через SSH, даже если
          вы установили значение <literal>command</literal> в
          <filename>authorized_keys</filename>.  Например, пользователи могут 
          получить доступ через SSH, или быть способны выполнять X11 или общий форвардинг 
          портов (general port-forwarding) через ваш сервер. Для предоставления 
          пользователям как можно меньших привилегий, вы можете захотеть указать несколько 
          ограничивающих опций сразу же после <literal>command</literal>:</para>
        

        <screen>
  command="svnserve -t --tunnel-user=harry",no-port-forwarding,\
           no-agent-forwarding,no-X11-forwarding,no-pty \
           TYPE1 KEY1 harry@example.com
</screen>

      </sect3>

    </sect2>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.httpd">
    <!-- @ENGLISH {{{
    <title>httpd, the Apache HTTP server</title>

    <para>The Apache HTTP Server is a <quote>heavy duty</quote>
      network server that Subversion can leverage.  Via a custom
      module, <command>httpd</command> makes Subversion repositories
      available to clients via the WebDAV/DeltaV protocol, which is an
      extension to HTTP 1.1 (see <ulink url="http://www.webdav.org/"/>
      for more information).  This protocol takes the ubiquitous HTTP
      protocol that is the core of the World Wide Web, and adds
      writing&mdash;specifically, versioned
      writing&mdash;capabilities.  The result is a standardized,
      robust system that is conveniently packaged as part of the
      Apache 2.0 software, is supported by numerous operating systems
      and third-party products, and doesn't require network
      administrators to open up yet another custom port.
      <footnote>
        <para>They really hate doing that.</para>
      </footnote>
      While an Apache-Subversion server has more features than
      <command>svnserve</command>, it's also a bit more difficult
      to set up.  With flexibility often comes more complexity.</para>

    <para>Much of the following discussion includes references to
      Apache configuration directives.  While some examples are given
      of the use of these directives, describing them in full is
      outside the scope of this chapter.  The Apache team maintains
      excellent documentation, publicly available on their website at
      <ulink url="http://httpd.apache.org"/>.  For example, a general
      reference for the configuration directives is located at <ulink url="
      http://httpd.apache.org/docs-2.0/mod/directives.html"/>.</para>
    @ENGLISH }}} -->
    <title>httpd, Сервер HTTP  Apache </title>
    <para>Сервер HTTP Apache  - сетевой сервер, подходящий для работы 
       в <quote>тяжелых условиях</quote>, который Subversion использует в 
       качестве средства доставки. Используя специальный модуль 
       <command>httpd</command> делает доступными для клиентов Subversion 
       хранилища через протокол WebDAV/DeltaV, который является расширением
       HTTP 1.1        
       (для получения дополнительной информации см. <ulink url="http://www.webdav.org/"/>.

       Этот протокол берет повсеместно используемый протокол HTTP, 
       который является ядром World Wide Web, и добавляет возможность записи 
       &mdash;
       особую, версионированную запись. Результат - стандартизированная, мощная 
       система,
       которая удобно упакована как часть ПО Apache 2, поддерживаемая 
       многочисленными 
       операционными системами и сторонними продуктами, и не требующая от 
       сетевого
       администратора открытия еще одного специального порта  
       <footnote>
	      <para>Они действительно ненавидят этого делать.</para>
      </footnote>
      В общем связка Apache-Subversion имеет больше возможностей перед 
      <command>svnserve</command>, он также 
      немного сложнее в установке. С гибкостью часто приходит и 
      сложность.</para>
    <para>Очень часто в дальнейшем разговоре будут включаться ссылки
      на конфигурационные директивы Apache. Тогда как некоторые примеры 
      даны с использованием этих директив, описание их в целом выходит 
      далеко за рамки данной главы. Команда Apache предоставляет превосходную 
      документацию, к которой возможен доступ на их сайте 
      <ulink url="http://httpd.apache.org"/>. Для примера, основное 
      описание конфигурационных директив расположено в <ulink url="
      http://httpd.apache.org/docs-2.0/mod/directives.html"/>.</para>

    <!-- @ENGLISH {{{
    <para>Also, as you make changes to your Apache setup, it is likely
      that somewhere along the way a mistake will be made.  If you are
      not already familiar with Apache's logging subsystem, you should
      become aware of it.  In your <filename>httpd.conf</filename>
      file are directives that specify the on-disk locations of the
      access and error logs generated by Apache (the
      <literal>CustomLog</literal> and <literal>ErrorLog</literal>
      directives, respectively).  Subversion's mod_dav_svn uses
      Apache's error logging interface as well.  You can always browse
      the contents of those files for information that might reveal
      the source of a problem that is not clearly noticeable
      otherwise.</para>
    @ENGLISH }}} -->
    <para>Также во время внесения изменений в настройки вашего Apache, 
       возможно, будут сделаны ошибки. Если Вы не знакомы с подсистемой 
       журналирования Apache, то должны знать о ней. В файле 
       <filename>httpd.conf</filename> существуют директивы, которые определяют 
       расположение 
       на диске журналов доступа и ошибок, создаваемых Apache (директивы 
       <literal>CustomLog</literal> и <literal>ErrorLog</literal> 
       соответственно). 
       Модуль Subversion mod_dav_svn, также использует систему журналирования 
       ошибок Apache. 
       Вы всегда можете просмотреть содержимое этих файлов для получения 
       информации, с помощью которой 
       выяснить источник проблем, явно не выявляемых другим способом.</para>



    <sidebar>
      <!-- @ENGLISH {{{
      <title>Why Apache 2?</title>

      <para>If you're a system administrator, it's very likely that
        you're already running the Apache web server and have some
        prior experience with it.  At the time of writing, Apache 1.3
        is by far the most popular version of Apache.  The world has
        been somewhat slow to upgrade to the Apache 2.X series for
        various reasons: some people fear change, especially changing
        something as critical as a web server.  Other people depend on
        plug-in modules that only work against the Apache 1.3 API, and
        are waiting for a 2.X port.  Whatever the reason, many people
        begin to worry when they first discover that Subversion's
        Apache module is written specifically for the Apache 2 API.</para>

      <para>The proper response to this problem is: don't worry about
        it.  It's easy to run Apache 1.3 and Apache 2 side-by-side;
        simply install them to separate places, and use Apache 2 as a
        dedicated Subversion server that runs on a port other than 80.
        Clients can access the repository by placing the port number
        into the URL:</para>
      @ENGLISH }}} -->
      <para>Если Вы - системный администратор, то очень может быть, что
        у Вас уже работает веб-сервер Apache, и Вы уже имеете некоторый опыт 
        работы с ним. Во время написания книги, Apache 1.3 был самой 
        популярной версией Apache. Мир по разным причинам откладывал переход на 
        Apache 2.x: одни боялись изменений, особенно изменений в чем-то настолько 
        критическом как веб-сервер. Другие зависели от встраиваемых модулей,
        которые работали только с Apache 1.3 API, и ждали пока их не перенесут 
        для 2.x. Какими бы не были причины, но многие люди начинали беспокоиться, 
        когда впервые узнавали, что Subversion модуль к Apache написан специально 
        под Apache 2 API. </para>

      <para>Соответствующее решение этой проблемы: не волноваться о ней. 
        Легко можно запустить рядом и Apache 1.3, и Apache 2; просто 
        установите их в разные места на диске, и используйте Apache 2 
	      только как Subversion сервер, запущенный на другом порту 
  	    отличном от 80. Клиент может получить доступ к хранилищу, 
	      поместив номер порта в URL: </para>


      <screen>
$ svn checkout http://host.example.com:7382/repos/project
&hellip;
</screen>
    </sidebar>


    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.prereqs">

      <!-- @ENGLISH {{{
      <title>Prerequisites</title>

      <para>To network your repository over HTTP, you basically need
        four components, available in two packages.  You'll need
        Apache <command>httpd</command> 2.0, the
        <command>mod_dav</command> DAV module that comes with it,
        Subversion, and the <command>mod_dav_svn</command>
        filesystem provider module distributed with Subversion.
        Once you have all of those components, the process of
        networking your repository is as simple as:</para>

      <itemizedlist>
        <listitem>
          <para>getting httpd 2.0 up and running with the mod_dav
            module,</para>
        </listitem>
        <listitem>
          <para>installing the mod_dav_svn plugin to mod_dav, which
            uses Subversion's libraries to access the repository,
            and</para>
        </listitem>
        <listitem>
          <para>configuring your <filename>httpd.conf</filename>
            file to export (or expose) the repository.</para>
        </listitem>
      </itemizedlist>
    @ENGLISH }}} -->
    <title>Необходимые условия</title>

    <para>Чтобы рботать с Вашим хранилишем через HTTP, Вам по существу 
     	необходимо четыре компонента, доступные в двух пакетах. 
    	Вам будет нужен Apache httpd 2.0, mod_dav - DAV модуль, идущий с 
    	ним, Subversion и mod_dav_svn - провайдер файловой системы, 
    	идущий в дистрибутиве Subversion. Как только у Вас будет доступ 
    	ко всем этим компонентам, процесс работы с вашим хранилищем по 
      сети будет простым:</para>

     <itemizedlist>
        <listitem>
      	  <para>получить и запустить httpd 2.0 с модулем mod_dav,</para>          
        </listitem>
        <listitem>
          <para>установить плугин mod_dav_svn к mod_dav, который
            использует библиотеки Subversion для доступа к хранилищу, и</para>
          
        </listitem>
        <listitem>
      	  <para> настроить файл <filename>httpd.conf</filename>, чтобы 
            экспортировать (выставить) хранилище.</para>
          
        </listitem>
      </itemizedlist>

    <!-- @ENGLISH {{{

      <para>You can accomplish the first two items either by
        compiling <command>httpd</command> and Subversion from
        source code, or by installing pre-built binary packages of
        them on your system.  For the most up-to-date information on
        how to compile Subversion for use with the Apache HTTP Server,
        as well as how to compile and configure Apache itself for
        this purpose, see the <filename>INSTALL</filename> file in
        the top level of the Subversion source code tree.</para>
    @ENGLISH }}} -->
      <para>Вы можете выполнить первые два пункта Вы можете скомпилировав 
        <command>httpd</command> и Subversion из исходных кодов, или установить уже 
        собранные бинарные пакеты на Вашу систему. Для самой новой информации о том 
        как собирать Subversion для использования с сервером Apache HTTP, а также 
        как собрать и настроить сам Apache для этих целей, смотрите файл 
       <filename>INSTALL</filename>, в самом начале дерева исходных кодов Subversion. 
       </para>


    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.basic">

    <!-- @ENGLISH {{{

      <title>Basic Apache Configuration</title>

      <para>Once you have all the necessary components installed on
        your system, all that remains is the configuration of Apache
        via its <filename>httpd.conf</filename> file.  Instruct Apache
        to load the mod_dav_svn module using the
        <literal>LoadModule</literal> directive.  This directive must
        precede any other Subversion-related configuration items.  If
        your Apache was installed using the default layout, your
        <command>mod_dav_svn</command> module should have been
        installed in the <filename>modules</filename> subdirectory of
        the Apache install location (often
        <filename>/usr/local/apache2</filename>).  The
        <literal>LoadModule</literal> directive has a simple syntax,
        mapping a named module to the location of a shared library on
        disk:</para>
      @ENGLISH }}} -->
      <title>Основная настройка Apache</title>
      <para>Как только Вы установили все необходимые компоненты на Вашу 
        систему, вся оставшаяся настройка Apache будет происходить в файле 
      	<filename>httpd.conf</filename>. Укажите Apache загружать модуль 
	      mod_dav_svn, используя директиву <literal>LoadModule</literal>. Эта 
	      директива должна предшествовать любым другим касающихся Subversion настроек. 
	      Если Ваш Apache был установлен с настройками по умолчанию, то Ваш модуль 
      	<command>mod_dav_svn</command> должен быть установлен в подкаталог 
      	<filename>modules</filename> каталога, в который установлен Apache 
      	(часто <filename>/usr/local/apache2</filename>). Директива 
      	<literal>LoadModule</literal> имеет простой синтаксис, отображающий
       	поименованный модуль на местоположение разделяемой библиотеки на диске: </para>

        <screen>
LoadModule dav_svn_module     modules/mod_dav_svn.so
</screen>

      <!-- @ENGLISH {{{
      <para>Note that if <command>mod_dav</command> was compiled as a
        shared object (instead of statically linked directly to the
        <command>httpd</command> binary), you'll need a similar
        <literal>LoadModule</literal> statement for it, too.  Be sure
        that it comes before the <command>mod_dav_svn</command> line:</para>
      @ENGLISH }}} -->
      <para>Обратите внимание, что если <command>mod_dav</command> был скомпилирован 
        как разделяемая библиотека (вместо статически прилинкованного напрямую к 
        <command>httpd</command> бинарнику), то Вам необходимо указать и для 
        него подобный  <literal>LoadModule</literal>. Убедитесь, что он идет
        перед строкой с <command>mod_dav_svn</command>: </para>


        <screen>
LoadModule dav_module         modules/mod_dav.so
LoadModule dav_svn_module     modules/mod_dav_svn.so
</screen>

      <!-- @ENGLISH {{{
      <para>At a later location in your configuration file, you now
        need to tell Apache where you keep your Subversion repository
        (or repositories).  The <literal>Location</literal> directive
        has an XML-like notation, starting with an opening tag, and
        ending with a closing tag, with various other configuration
        directives in the middle.  The purpose of the
        <literal>Location</literal> directive is to instruct Apache to
        do something special when handling requests that are directed
        at a given URL or one of its children.  In the case of
        Subversion, you want Apache to simply hand off support for
        URLs that point at versioned resources to the DAV layer.  You
        can instruct Apache to delegate the handling of all URLs whose
        path portions (the part of the URL that follows the server's
        name and the optional port number) begin with
        <filename>/repos/</filename> to a DAV provider whose
        repository is located at
        <filename>/absolute/path/to/repository</filename> using the
        following <filename>httpd.conf</filename> syntax:</para>
      @ENGLISH }}} -->
      <para>Дальше в Вашем конфигурационном файле Вам необходимо сказать Apache,
         где находится Ваш Subverison хранилище (или хранилища). Директива 
         <literal>Location</literal> имеет XML-подобную запись, начинающуюся с тега 
         открытия, и заканчивающуюся тегом закрытия, с различными конфигурационными 
         директивами внутри. Цель директивы <literal>Location</literal>, сообщить 
         Apache, как обрабатывать запрос, направленный на данный URL или к его "детям". 
         В случае Subversion, Вам нужно, чтобы просто передавал обработку URL, 
         указывающего на версионированные ресурсы на уровень DAV. Вы можете сообщить 
         Apache поручать обработку всех URL, чья path-часть (часть URL, которая следует 
         за именем сервера и возможным номером порта) начинается с <filename>/repos/</filename> 
         провайдеру DAV, чье хранилище находится в 
         <filename>/absolute/path/to/repository</filename>, используя следующий
         синтаксис <filename>httpd.conf</filename>:</para>


        <screen>
&lt;Location /repos&gt;
  DAV svn
  SVNPath /absolute/path/to/repository
&lt;/Location&gt;
</screen>

      <!-- @ENGLISH {{{
      <para>If you plan to support multiple Subversion repositories
        that will reside in the same parent directory on your local
        disk, you can use an alternative directive, the
        <literal>SVNParentPath</literal> directive, to indicate that
        common parent directory.  For example, if you know you will be
        creating multiple Subversion repositories in a directory
        <filename>/usr/local/svn</filename> that would be accessed via
        URLs like <uri>http://my.server.com/svn/repos1</uri>,
        <uri>http://my.server.com/svn/repos2</uri>, and
        so on, you could use the <filename>httpd.conf</filename>
        configuration syntax in the following example:</para>
      @ENGLISH }}} -->
      <para>Если Вы планируете поддерживать несколько хранилищ Subversion, 
        которые будут расположены в одном родительском каталоге на Вашем локальном 
        диске, то Вы можете использовать альтернативную директиву 
        <literal>SVNParentPath</literal>, которая указывает общий родительский
        каталог. Для примера, если Вы знаете, что будете создавать несколько
        хранилищ Subversion в каталоге <filename>/usr/local/svn</filename>, к 
        которым будет доступ через URL типа <uri>http://my.server.com/svn/repos1</uri>, 
        <uri>http://my.server.com/svn/repos2</uri> и т.д., то вы можете использовать 
        следующий конфигурационный синтаксис <filename>httpd.conf</filename>:</para>


        <screen>
&lt;Location /svn&gt;
  DAV svn

  # any "/svn/foo" URL will map to a repository /usr/local/svn/foo
  SVNParentPath /usr/local/svn
&lt;/Location&gt;
</screen>

      <!-- @ENGLISH {{{
      <para>Using the previous syntax, Apache will delegate the
        handling of all URLs whose path portions begin with
        <filename>/svn/</filename> to the Subversion DAV provider,
        which will then assume that any items in the directory
        specified by the <literal>SVNParentPath</literal> directive
        are actually Subversion repositories.  This is a particularly
        convenient syntax in that, unlike the use of the
        <literal>SVNPath</literal> directive, you don't have to
        restart Apache in order to create and network new
        repositories.</para>

      <para>Be sure that when you define your new
        <literal>Location</literal>, it doesn't overlap with other
        exported Locations.  For example, if your main
        <literal>DocumentRoot</literal> is exported to
        <filename>/www</filename>, do not export a Subversion
        repository in <literal>&lt;Location /www/repos&gt;</literal>.
        If a request comes in for the URI
        <filename>/www/repos/foo.c</filename>, Apache won't know
        whether to look for a file <filename>repos/foo.c</filename> in
        the <literal>DocumentRoot</literal>, or whether to delegate
        <command>mod_dav_svn</command> to return
        <filename>foo.c</filename> from the Subversion
        repository.</para>
      @ENGLISH }}} -->
      <para>Используя выше указанный синтаксис, Apache будет поручать обработку всех 
         URL, чья path-часть начинается с /svn/ Subversion провайдеру DAV, который затем
         предположит, что любые вхождения в каталог, определенный в директиве 
         <literal>SVNParentPath</literal>, фактически является Subversion
         хранилищем. Это черезвычайно удобный синтаксис в том, что, в отличие от 
         использования директивы <literal>SVNParentPath</literal>, Вам не нужно перезапускать 
         Apache, 
         когда нужно создать и обеспечить сетевой доступ к новым хранилищам.</para>

      <para> Убедитесь, что когда вы определяете новую <literal>Location</literal>, 
        то не пересекаетесь с уже экспортированными Locations. Например, если Ваш 
        <literal>DocumentRoot</literal> это <filename>/www</filename>, то не
        экспортируйте Subversion хранилище в <literal>&lt;Location /www/repos&gt;</literal>. 
        Если запрос приходит для  URI <filename>/www/repos/foo.c</filename>, то Apache не знает, 
     	 искать ли файл <filename>repos/foo.c</filename> в <literal>DocumentRoot</literal>, 
     	 или поручить <command>mod_dav_svn</command> возвратить <filename>foo.c</filename>
     	 из Subversion хранилища.
      </para>


      <sidebar>

        <!-- @ENGLISH {{{
        <title>Server Names and the COPY Request</title>

        <para>Subversion makes use of the <literal>COPY</literal>
          request type to perform server-side copies of files and
          directories.  As part of the sanity checking done by the
          Apache modules, the source of the copy is expected to be
          located on the same machine as the destination of the copy.
          To satisfy this requirement, you might need to tell mod_dav
          the name you use as the hostname of your server.  Generally,
          you can use the <literal>ServerName</literal> directive in
          <filename>httpd.conf</filename> to accomplish this.</para>
        @ENGLISH }}} -->
        <title>Имена сервера и запрос COPY</title>
      	<para>Subversion использует тип запроса <literal>COPY</literal>, 
     	    чтобы выполнить копирование на стороне сервера файлов и каталогов. 
          Как часть политики модулей Apache, ожидается, что источник копии будет
          расположен на той же машине, что и место для копирования.
          удовлетворять этому требованию, Вам, вероятно, нужно сообщить mod_dav 
          имя, которое является именем Вашего сервера. Обычно, чтобы сделать это, 
          Вы можете использовать директиву <literal>ServerName</literal> в 
          <filename>httpd.conf</filename>:</para>

        <screen>
ServerName svn.example.com
</screen>

        <!-- @ENGLISH {{{
        <para>If you are using Apache's virtual hosting support via
          the <literal>NameVirtualHost</literal> directive, you may
          need to use the <literal>ServerAlias</literal> directive to
          specify additional names that your server is known by.
          Again, refer to the Apache documentation for full
          details.</para>
        @ENGLISH }}} -->        
      	<para>Если Вы используете поддержку Apache виртуального хостинга, через 
	        директиву <literal>NameVirtualHost</literal>, то Вы можете 
      	   использовать директиву <literal>ServerAlias</literal>, для определения 
      	   дополнительных имен Вашего сервера. За полным описанием этого обратитесь 
          к документации Apache.</para>
        
      </sidebar>

      <!-- @ENGLISH {{{
      <para>At this stage, you should strongly consider the question
        of permissions.  If you've been running Apache for some time
        now as your regular web server, you probably already have a
        collection of content&mdash;web pages, scripts and such.
        These items have already been configured with a set of
        permissions that allows them to work with Apache, or more
        appropriately, that allows Apache to work with those files.
        Apache, when used as a Subversion server, will also need the
        correct permissions to read and write to your Subversion
        repository.</para>

      <para>You will need to determine a permission system setup that
        satisfies Subversion's requirements without messing up any
        previously existing web page or script installations.  This
        might mean changing the permissions on your Subversion
        repository to match those in use by other things that Apache
        serves for you, or it could mean using the
        <literal>User</literal> and <literal>Group</literal>
        directives in <filename>httpd.conf</filename> to specify that
        Apache should run as the user and group that owns your
        Subversion repository.  There is no single correct way to set
        up your permissions, and each administrator will have
        different reasons for doing things a certain way.  Just be
        aware that permission-related problems are perhaps the most
        common oversight when configuring a Subversion repository for
        use with Apache.</para>
      @ENGLISH }}} -->
      <para>На этом этапе Вы должны внимательно рассмотреть вопрос прав доступа. 
        Если вы уже пользовались Apache некоторое время как обычным веб-сервером, 
        то, возможно, Вы уже имеете накопленный контент&mdash; веб-страницы, 
        скрипты и прочее. К ним уже были выставлены определенные права доступа, 
        которые позволяли им работать с Apache, или более подходящим было бы сказать, 
        что эти файлы позволяли Apache работать с ними. Когда Apache используется как 
        сервер Subversion, он также нуждается в настройке у Вашего
        хранилища правильных прав доступа на чтение и запись.</para>

    	<para>Вы должны определить права системы, которые бы удовлетворяли 
        требованиям Subversion, и при этом не испортив работу до этого 
        существующих веб-страниц или скриптов. Это может означать изменения 
        прав доступа к Вашему хранилищу Subversion так, чтобы обеспечить его работу с 
        теми "вещами", которые обслуживает Apache, или может это означает 
        использование директив <literal>User</literal> и <literal>Group</literal> 
    	  в <filename>httpd.conf</filename>, которые устанавливают пользователя от чьего 
    	  лица должен работать Apache и группу которая владеет вашим хранилищем Subversion.
	      Не существует единственно правильного способа установки прав доступа, и 
    	  каждый администратор волен сделать это по-своему. Просто знайте, что проблемы 
	      связанные с правами доступа - возможно, наиболее частые оплошности
    	  при настройке хранилища Subversion с использованием Apache.</para>	
      

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.authn">

      <!-- @ENGLISH {{{
      <title>Authentication Options</title>

      <para>At this point, if you configured
        <filename>httpd.conf</filename> to contain something like</para>
      @ENGLISH }}} -->
      <title>Опции идентификации</title>
      <para>Сейчас, если Вы настроили <filename>httpd.conf</filename>, и он
	      содержит примерно следующее</para>

      <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
&lt;/Location&gt;
</screen>

      <!-- @ENGLISH {{{
      <para>&hellip;then your repository is <quote>anonymously</quote>
        accessible to the world.  Until you configure some
        authentication and authorization policies, the Subversion
        repositories you make available via the
        <literal>Location</literal> directive will be generally
        accessible to everyone.  In other words,</para>

      <itemizedlist>
        <listitem>
          <para>anyone can use their Subversion client to checkout a
            working copy of a repository URL (or any of its
            subdirectories),</para>
        </listitem>
        <listitem>
          <para>anyone can interactively browse the repository's
            latest revision simply by pointing their web browser to
            the repository URL, and</para>
        </listitem>
        <listitem>
          <para>anyone can commit to the repository.</para>
        </listitem>
      </itemizedlist>
      @ENGLISH }}} -->
      <para>&hellip;то Ваше хранилище доступно для всего мира без
      	 идентификации (<quote>анонимно</quote>). 
        Пока вы не настроите хоть какие-нибудь правила идентификации 
        и авторизации, открытые Вами через директиву <literal>Location</literal> 
        хранилища Subversion  будут доступны любому. Другими словами,</para>
      <itemizedlist>
        <listitem>
         	<para>любой с помощью своего клиента Subversion может извлечь 
            рабочую копию по URL хранилища (или любого из его 
            каталогов),</para>
        </listitem>
        <listitem>
       	  <para>любой может интерактивно просматривать последние ревизии
             хранилища просто указывая URL хранилища  в веб-браузере, и</para>
        </listitem>
        <listitem>
          <para>любой может фиксировать свои изменения в хранилище.</para>
        </listitem>
      </itemizedlist>


      <!-- @ENGLISH {{{
      <para>Of course, you might have already set up
        a <filename>pre-commit</filename> hook script to prevent
        commits (see <xref linkend="svn.reposadmin.create.hooks"/>).
        But as you read on, you'll see that it's also possible use
        Apache's built-in methods to restrict access in specific
        ways.</para>
      @ENGLISH }}} -->
      <para>Конечно, вы можете иметь уже насторенный хук скрипта 
        <filename>pre-commit</filename> для предотвращения фиксаций
        (смотри <xref linkend="svn.reposadmin.create.hooks"/>). Но как 
        вы прочитали выше, таже возможно использовать встроенные методы 
        Apache для ограничения доступа к конкретным путям.</para>


      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authn.basic">

        <!-- @ENGLISH {{{
        <title>Basic HTTP Authentication</title>

        <para>The easiest way to authenticate a client is via the
          HTTP Basic authentication mechanism, which simply uses a
          username and password to verify that a user is who she says
          she is.  Apache provides an <command>htpasswd</command>
          utility for managing the list of acceptable usernames and
          passwords, those to whom you wish to grant special access to
          your Subversion repository.  Let's grant commit access to
          Sally and Harry.  First, we need to add them to the password
          file.</para>
        @ENGLISH }}} -->
        <title>Основная (Basic) HTTP идентификация</title>
      
        <para> Наиболее простым способом идентификации клиента 
          является механизм основной (basic) HTTP идентификации, который просто берет 
          имя пользователя и пароль, чтобы проверить, что пользователь - тот за кого 
          он себя выдает. Apache предоставляет утилиту <command>htpasswd</command>, 
          управляющую списком пользователей и их паролями, тех кому Вы хотите 
          предоставлять специалный доступ к Вашему хранилищу. Давайте предоставим 
          доступ на 
          возможность фиксации изменений для Салли и Гарри. Сначала
          необходимо добавить их к password-файлу.</para>


        <screen>
$ ### First time: use -c to create the file
$ ### Use -m to use MD5 encryption of the password, which is more secure
$ htpasswd -cm /etc/svn-auth-file harry
New password: *****
Re-type new password: *****
Adding password for user harry
$ htpasswd -m /etc/svn-auth-file sally
New password: *******
Re-type new password: *******
Adding password for user sally
$
</screen>

        <!-- @ENGLISH {{{
        <para>Next, you need to add some more
          <filename>httpd.conf</filename> directives inside your
          <literal>Location</literal> block to tell Apache what to do
          with your new password file.  The
          <literal>AuthType</literal> directive specifies the type of
          authentication system to use.  In this case, we want to
          specify the <literal>Basic</literal> authentication system.
          <literal>AuthName</literal> is an arbitrary name that you
          give for the authentication domain.  Most browsers will
          display this name in the pop-up dialog box when the browser
          is querying the user for his name and password.  Finally,
          use the <literal>AuthUserFile</literal> directive to specify
          the location of the password file you created using
          <command>htpasswd</command>.</para>

        <para>After adding these three directives, your
          <literal>&lt;Location&gt;</literal> block should look
          something like this:</para>
        @ENGLISH }}} -->
        <para>Затем, Вам необходимо добавить несколько директив 
          <filename>httpd.conf</filename> внутрь Вашего блока <literal>Location</literal>, 
          чтобы сказать Apache, что делать с Вашим новым password-файлом. Директива 
          <literal>AuthType</literal> определяет тип используемой Вами системы 
          идентификации. В нашем случае, мы хотим указать систему идентификации 
          <literal>Basic</literal>. <literal>AuthName</literal> - это условное имя, 
          которое Вы даете для данной идентификационной области. Большинство браузеров 
          будут отображать это имя в всплывающем диалоговом окне, когда браузер будет 
           запрашивать 
          у пользователя его имя и пароль. Наконец, использование директивы 
          <literal>AuthUserFile</literal> определяет положение password-файла, 
           созданного Вами 
          с помощью <command>htpasswd</command>.</para>

        <para>  После добавления этих трех директив, Ваш блок
          <literal>&lt;Location&gt;</literal> будет выглядеть подобно
       	  такому:</para>


        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /etc/svn-auth-file
&lt;/Location&gt;
</screen>

        <!-- @ENGLISH {{{
        <para>This <literal>&lt;Location&gt;</literal> block is not
          yet complete, and will not do anything useful.  It's merely
          telling Apache that whenever authorization is required,
          Apache should harvest a username and password from the
          Subversion client.  What's missing here, however, are
          directives that tell Apache <emphasis>which</emphasis> sorts
          of client requests require authorization.  Wherever
          authorization is required, Apache will demand
          authentication as well.  The simplest thing to do is protect
          all requests.  Adding <literal>Require valid-user</literal>
          tells Apache that all requests require an authenticated
          user:</para>
        @ENGLISH }}} -->
       	<para>Это блок <literal>&lt;Location&gt;</literal> еще не закончен, в 
          таком виде не делает ничего полезного. Здесь только сказано, чтобы Apache 
           каждый раз когда 
          требовалась бы авторизация, будет забирать имя пользователя и пароль от 
           клиента Subversion. 
          Чего здесь не хватает? Это директивы, говорящей Apache
          <emphasis>какие</emphasis> клиентские запросы 
          требуют авторизации. Где бы авторизация не потребовалась, Apache будет требовать 
           также 
          идентификацию. Самая простая вещь - защищать все запросы. Добавление 
          <literal>Require valid-user</literal>, сообщает Apache, что все запросы требуют 
          идентификации пользователя: </para>



        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /etc/svn-auth-file
  Require valid-user
&lt;/Location&gt;
</screen>

        <!-- @ENGLISH {{{
        <para>Be sure to read the next section (<xref
          linkend="svn.serverconfig.httpd.authz"/>) for more detail on the
          <literal>Require</literal> directive and other ways to set
          authorization policies.</para>

        <para>One word of warning: HTTP Basic Auth passwords pass in
          very nearly plain-text over the network, and thus are
          extremely insecure.  If you're worried about password
          snooping, it may be best to use some sort of SSL encryption,
          so that clients authenticate via <literal>https://</literal>
          instead of <literal>http://</literal>; at a bare minimum,
          you can configure Apache to use a self-signed server
          certificate.
          <footnote>
            <para>While self-signed server certificates are still
              vulnerable to a <quote>man in the middle</quote> attack,
              such an attack is still much more difficult for a casual
              observer to pull off, compared to sniffing unprotected
              passwords.</para>
          </footnote>
          Consult Apache's documentation (and OpenSSL documentation)
          about how to do that.</para>
        @ENGLISH }}} -->
      	<para>Не забудьте прочитать следующую секцию (
          <xref linkend="svn.serverconfig.httpd.authz"/>) для получения более
          детальной информации об директиве <literal>Require</literal> и 
          других способах установки правил авторизации.</para>

      
        <para>Следует сказать одно слово предупреждения: пароли HTTP Basic Auth проходят 
          по сети почти в виде простого текста, а это очень небезопасно. Если Вы 
     	   беспокоитесь о том, что пароль может быть "подсмотрен", то может быть лучшим 
	        решением будет использование некоторого вида SSL шифрованием, 
     	   так что клиенты будут идентифицироваться через <literal>https://</literal> 
	        вместо <literal>http://</literal>; как минимум, вы можете настроить Apache на 
     	   использование самоподписанного сертификата сервера. 
          <footnote>
   	      <para>Пока само подписанные сертификаты сервера остаются уязвимыми
            для атак типа <quote>человек внутри</quote>, такая атака
	          остается довольно трудно обнаруживаемой, по сравнению с простым
            перехватом не зашифрованных паролей.</para>
          </footnote>
         Посмотрите документацию Apache (и ~OpenSSL документацию), чтобы
     	   узнать как это делать.</para>

      </sect3>


      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authn.sslcerts">

        <!-- @ENGLISH {{{
        <title>SSL Certificate Management</title>

        <para>Businesses that need to expose their repositories for access
          outside the company firewall should be conscious of the
          possibility that unauthorized parties could be
          <quote>sniffing</quote> their network traffic.  SSL makes
          that kind of unwanted attention less likely to result in
          sensitive data leaks.</para>

        <para>If a Subversion client is compiled to use OpenSSL, then
          it gains the ability to speak to an Apache server via
          <literal>https://</literal> URLs.  The Neon library used by
          the Subversion client is not only able to verify server
          certificates, but can also supply client certificates when
          challenged.  When the client and server have exchanged SSL
          certificates and successfully authenticated one another, all
          further communication is encrypted via a session key.</para>
        @ENGLISH }}} -->
        <title>Управление SSL сертификатами</title>	
        <para>Бизнес который нуждается в выставлении их них хранилищ 
          для доступа извне файервола компании, должны осознавать
          возможность что не авторизированные стороны могут 
          <quote>вынюхивать</quote> (<quote>sniffing</quote>) их сетевой трафик.
          SSL делает отчасти меньшим нежелательное внимание, и в результате менее 
          вероятным утечку чувствительных данных.</para>

        <para>Если клиент Subversion скомпилирован для использования OpenSSL,
          тогда он имеет возможность общаться с сервером Apache через 
          URL вида <literal>https://</literal>. Библиотека Neon используемая
          клиентом Subversion не только способна проверить сертификаты сервера,
          но также поддерживает клиентские сертификаты когда сомневается. 
          Когда клиент и сервер обменялись SSL сертификатами и успешно 
          идентифицировали друг друга, вся последующая информация зашифрована 
          через ключ сессии.</para>


        


        <!-- @ENGLISH {{{
        <para>It's beyond the scope of this book to describe how to
          generate client and server certificates, and how to
          configure Apache to use them.  Many other books, including
          Apache's own documentation, describe this task.  But what
          <emphasis>can</emphasis> be covered here is how to manage
          server and client certificates from an ordinary Subversion
          client.</para>

        <para>When speaking to Apache via <literal>https://</literal>,
          a Subversion client can receive two different types of
          information:</para>

        <itemizedlist>
          <listitem><para>a server certificate</para></listitem>
          <listitem><para>a demand for a client certificate</para></listitem>
        </itemizedlist>
      @ENGLISH }}} -->
        <para>Описание того, как генерировать клиентские и серверные сертификаты
          и как настроить Apache для их использования, выходит за рамки этой книги.
          Множество других книг, включая собственную документацию Apache, описывают
          эту задачу. Но что <emphasis>должно</emphasis> быть обсуждено сдесь, как 
          управлять серверными и клиентскими сертификатами из обычного клиента 
          Subversion.</para>
        <para>Когда клиент Subversion общается с Apache через <literal>https://</literal>,
          он может получать два различных типа информации:</para>

        <itemizedlist>
          <listitem><para>сертификат сервера</para></listitem>
          <listitem><para>запрос на сертификат клиента</para></listitem>
        </itemizedlist>
      
        <!-- @ENGLISH {{{
        <para>If the client receives a server certificate, it needs to
          verify that it trusts the certificate: is the server really
          who it claims to be?  The OpenSSL library does this by
          examining the signer of the server certificate, or
          <firstterm>certifying authority</firstterm> (CA).  If
          OpenSSL is unable to automatically trust the CA, or if some
          other problem occurs (such as an expired certificate or
          hostname mismatch), the Subversion command-line client will
          ask you whether you want to trust the server certificate
          anyway:</para>
        @ENGLISH }}} -->
        <para>Если клиент получает серверный сертификат, он должен проверить
          что он может доверять сертификату: сервер реально тот, за кого себя
          выдает? Библиотека OpenSSL делает это проверкой подписи сертификата 
          сервера или <firstterm>проверка подлинности </firstterm> (certifying authority (CA)).
          Если OpenSSL не может автоматически доверять CA, или возникли другие проблемы 
          (такие как просроченный сертификат или имя хоста не совпадает), Subversion 
          клиент командной строки спросит вас, хотите ли вы все равно доверять сертификату 
          сервера:</para>


        <screen>
$ svn list https://host.example.com/repos/project

Error validating server certificate for 'https://host.example.com:443':
 - The certificate is not issued by a trusted authority. Use the
   fingerprint to validate the certificate manually!
Certificate information:
 - Hostname: host.example.com
 - Valid: from Jan 30 19:23:56 2004 GMT until Jan 30 19:23:56 2006 GMT
 - Issuer: CA, example.com, Sometown, California, US
 - Fingerprint: 7d:e1:a9:34:33:39:ba:6a:e9:a5:c4:22:98:7b:76:5c:92:a0:9c:7b

(R)eject, accept (t)emporarily or accept (p)ermanently?
</screen>

        <!-- @ENGLISH {{{
        <para>This dialogue should look familiar; it's essentially the
          same question you've probably seen coming from your web
          browser (which is just another HTTP client like Subversion!).
          If you choose the (p)ermanent option, the server certificate
          will be cached in your private run-time
          <filename>auth/</filename> area in just the same way your
          username and password are cached (see <xref
          linkend="svn.serverconfig.netmodel.credcache"/>).  If cached,
          Subversion will automatically remember to trust this certificate
          in future negotiations.</para>

        <para>Your run-time <filename>servers</filename> file also gives
          you the ability to make your Subversion client automatically
          trust specific CAs, either globally or on a per-host basis.
          Simply set the <literal>ssl-authority-files</literal>
          variable to a semicolon-separated list of PEM-encoded CA
          certificates:</para>
        @ENGLISH }}} -->
        <para>Этот диалог должет выглядеть знакомым, это по существу тот-же 
          вопрос который вы обычно получаете от вашего веб-клиента (фактически это 
          просто другой HTTP-клиент подобный Subversion!). Если вы выберите опцию
          (p)ermanent (постоянно), сертификат сервера будет закеширован в вашей личной
          области <filename>auth/</filename>, таким же путем как кешируются ваше имя 
          пользователя и пароль (смотри <xref
          linkend="svn.serverconfig.netmodel.credcache"/>).  если закеширован, 
          subversion будет автоматически помнить что нужно доверять этому 
          сертификату в последующих переговорах.</para>

        <para>ваш файл времени исполнения <filename>servers</filename> также 
          предоставляет вам возможность указать клиенту subversion автоматически 
          доверять конкретным ca, либо глобально или на основе хоста.
          просто укажите в переменной <literal>ssl-authority-files</literal> список
          разделенных точкой запятой  ca сертификатов закодированных pem (pem-encoded ca
          certificates):</para>


        <screen>
[global]
ssl-authority-files = /path/to/cacert1.pem;/path/to/cacert2.pem
</screen>

        <!-- @ENGLISH {{{
        <para>Many OpenSSL installations also have a pre-defined set
          of <quote>default</quote> CAs that are nearly universally
          trusted.  To make the Subversion client automatically trust
          these standard authorities, set the
          <literal>ssl-trust-default-ca</literal> variable to
          <literal>true</literal>.</para>

        <para>When talking to Apache, a Subversion client might also
          receive a challenge for a client certificate.  Apache is
          asking the client to identify itself: is the client really
          who it says it is?  If all goes correctly, the Subversion
          client sends back a private certificate signed by a CA that
          Apache trusts.  A client certificate is usually stored on
          disk in encrypted format, protected by a local password.
          When Subversion receives this challenge, it will ask you for
          both a path to the certificate and the password which
          protects it:</para>
        @ENGLISH }}} -->
        <para>Многие OpenSSL установщики также имеют предопределенный набор
          CA <quote>по умолчанию</quote> которым обычно везде доверяют. 
          Для того чтобы клиент Subversion автоматически доверял этим 
          стандартным CA, 
          установите переменную <literal>ssl-trust-default-ca</literal> в
          <literal>true</literal>.</para>

        <para>При разговоре с Apache клиенет Subversion также может 
          передавать вызов на клиентский сертификат. Apache просит 
          клиента идентифицировать себя: этот клиент реально тот за кого 
          себя выдает? Если все впорядке, Subversion передает назад 
          частный сертификат обычно хранимый на диске в зашифрованном 
          формате, защишенный локальным паролем. Когда Subversion 
          получает этот вызов, он будет запрашивать у вас путь к 
          сертификату и пароль который зашищает его:</para>

        <screen>
$ svn list https://host.example.com/repos/project

Authentication realm: https://host.example.com:443
Client certificate filename: /path/to/my/cert.p12
Passphrase for '/path/to/my/cert.p12':  ********
&hellip;
</screen>

        <!-- @ENGLISH {{{
        <para>Notice that the client certificate is a
          <quote>p12</quote> file.  To use a client certificate with
          Subversion, it must be in PKCS#12 format, which is a
          portable standard.  Most web browsers are already able to
          import and export certificates in that format.   Another
          option is to use the OpenSSL command-line tools to convert
          existing certificates into PKCS#12.</para>

        <para>Again, the runtime <filename>servers</filename> file
          allows you to automate this challenge on a per-host basis.
          Either or both pieces of information can be described in
          runtime variables:</para>
        @ENGLISH }}} -->
        <para>Обратите внимание что клиентские сертификаты это файлы
          <quote>p12</quote>. Для использования клиентских сертификатов
          в Subversion, они должны быть в формате PKCS#12, который является 
          переносимым стандартом. Большинство web-просмотрщиков уже могут
          импортировать и экспортировать сертификаты а этом формате. Другая возможность
          состоит в использовании инструментов командной строки OpenSSL для           
          преобразования существующих сертификатов в PKCS#12.</para>

        <para>Снова, файл <filename>servers</filename> позволяет вам 
          автоматизировать это изменение на основе хоста. .
          Каждая или обе части информации может быть описаны в переменных времени 
          исполнения:</para>
        

        <screen>
[groups]
examplehost = host.example.com

[examplehost]
ssl-client-cert-file = /path/to/my/cert.p12
ssl-client-cert-password = somepassword
</screen>

        <!-- @ENGLISH {{{
        <para>Once you've set the
          <literal>ssl-client-cert-file</literal> and
          <literal>ssl-client-cert-password</literal> variables, the
          Subversion client can automatically respond to a client
          certificate challenge without prompting you.
          <footnote>
            <para>More security-conscious folk might not want to store
              the client certificate password in the runtime
              <filename>servers</filename> file.</para>
          </footnote>
        </para>
        @ENGLISH }}} -->
        <para>Как только вы установите переменные
          <literal>ssl-client-cert-file</literal> и
          <literal>ssl-client-cert-password</literal> клиент 
          Subversion может автоматически отвечать на запрос клиентского сертификата, без 
          уведомления вас.
          <footnote>
            <para>Люди более осознающие безопасность могут не захотеть хранить пароль
              клиентского сертификата в файле
              <filename>servers</filename>.</para>
          </footnote>
        </para>


      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.authz">

      <!-- @ENGLISH {{{
      <title>Authorization Options</title>

      <para>At this point, you've configured authentication, but not
        authorization.  Apache is able to challenge clients and
        confirm identities, but it has not been told how to allow or
        restrict access to the clients bearing those identities.  This
        section describes two strategies for controlling access to
        your repositories.</para>
      @ENGLISH }}} -->
      <title>Опции авторизации</title>
    	<para>На текущий момент у Вас настроена идентификация, но не авторизация. 
	      Apache способен вызвать клиентов и подтвердить их личность, но не может 
    	   сказать: разрешать или запрещать доступ клиентам прошедших это подтверждение. 
	      Этот раздел описывает две стратегии для контроля доступа к Вашему 
    	   хранилищу.</para>


      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authz.blanket">

        <!-- @ENGLISH {{{
        <title>Blanket Access Control</title>
        @ENGLISH }}} -->
        <title>Управление общим доступом (Blanket Access Control)</title>

        <!-- @ENGLISH {{{
        <para>The simplest form of access control is to authorize
          certain users for either read-only access to a repository,
          or read/write access to a repository.</para>
      	@ENGLISH }}} -->  
      	<para>Простейшая форма контроля доступа - это авторизовывать определенных 
      	   пользователей на доступ только для чтения к хранилищу, или для 
           чтения/записи.</para>
   

        <!-- @ENGLISH {{{
        <para>You can restrict access on all repository operations by
          adding the <literal>Require valid-user</literal> directive
          to your <literal>&lt;Location&gt;</literal> block.  Using
          our previous example, this would mean that only clients that
          claimed to be either <literal>harry</literal> or
          <literal>sally</literal>, and provided the correct
          password for their respective username, would be allowed to
          do anything with the Subversion repository:</para>
      	@ENGLISH }}} -->  
      	<para>Вы можете разграничить доступ на все операции, совершаемые над 
           хранилищем, добавлением директивы <literal>Require valid-user</literal> 
           в Ваш блок 
      	   <literal>&lt;Location&gt;</literal>. Используя наш предыдущий пример, это 
      	   означает, что только клиенты которые представились как 
           <literal>harry</literal> или 
    	   <literal>sally</literal>, и 
	       предоставили корректные пароли для соответствующих имен пользователя, будут 
    	   допущены выполнять какие-либо операции над Subversion хранилищем:</para> 


        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # how to authenticate a user
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file

  # only authenticated users may access the repository
  Require valid-user
&lt;/Location&gt;
</screen>

        <!-- @ENGLISH {{{
        <para>Sometimes you don't need to run such a tight ship.  For
          example, Subversion's own source code repository at
          <ulink url="http://svn.collab.net/repos/svn"/> allows anyone
          in the world to perform read-only repository tasks (like
          checking out working copies and browsing the repository with
          a web browser), but restricts all write operations to
          authenticated users.  To do this type of selective
          restriction, you can use the <literal>Limit</literal> and
          <literal>LimitExcept</literal> configuration directives.
          Like the <literal>Location</literal> directive, these blocks
          have starting and ending tags, and you would nest them
          inside your <literal>&lt;Location&gt;</literal>
          block.</para>
      	@ENGLISH }}} -->  
      	<para>Иногда, Вам не нужно будет запускать <quote>такую крепкую
          лодку</quote>. Например, собственное хранилище исходного кода
          Subversion (<ulink url="http://svn.collab.net/repos/svn"/>) доступно 
          каждому в мире в режиме только для чтения для выполнения задач над хранилищем,  
          (таких как создание рабочих копий, и просмотр хранилища с помощью 
          веб-браузера), а все операции записи разрешены для идентифицированных 
          пользователей. Чтобы сделать такие выборочные разграничения, Вы можете 
          использовать конфигурационные директивы <literal>Limit</literal> и           
          <literal>LimitExcept</literal>.
      	  Подобно директиве <literal>Location</literal>, эти блоки имеют начальный и           
          конечный теги, и Вы их будете располагать внутри блока 
          <literal>&lt;Location&gt;</literal>.</para>

        <!-- @ENGLISH {{{
       <para>The parameters present on the <literal>Limit</literal>
          and <literal>LimitExcept</literal> directives are HTTP
          request types that are affected by that block.  For example,
          if you wanted to disallow all access to your repository
          except the currently supported read-only operations, you
          would use the <literal>LimitExcept</literal> directive,
          passing the <literal>GET</literal>,
          <literal>PROPFIND</literal>, <literal>OPTIONS</literal>, and
          <literal>REPORT</literal> request type parameters.  Then the
          previously mentioned <literal>Require valid-user</literal>
          directive would be placed inside the
          <literal>&lt;LimitExcept&gt;</literal> block instead of just
      	  inside the <literal>&lt;Location&gt;</literal> block.</para>
       @ENGLISH }}} -->    
       <para>Параметры представляемые директивам <literal>Limit</literal> 
      	  и <literal>LimitExcept</literal> это типы запросов HTTP, которые 
      	  обрабатываются данным блоком. К примеру, если Вы хотите запретить 
      	  любой доступ к Вашему хранилищу, за исключением операций только 
      	  для чтения, Вы должны использовать директиву 
      	  <literal>LimitExcept</literal> с параметрами запроса 
      	  <literal>GET</literal>, <literal>PROPFIND</literal>, 
      	  <literal>OPTIONS</literal>, и <literal>REPORT</literal>. Тогда, 
      	  выше упомянутая, директива <literal>Require valid-user</literal> 
      	  будет располагаться внутри блока <literal>&lt;LimitExcept&gt;</literal>, 
      	  а не внутри блока <literal>&lt;Location&gt;</literal>. </para>

        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # how to authenticate a user
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file

  # For any operations other than these, require an authenticated user.
  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;
    Require valid-user
  &lt;/LimitExcept&gt;
&lt;/Location&gt;
</screen>

        <!-- @ENGLISH {{{
        <para>These are only a few simple examples.  For more in-depth
          information about Apache access control and the
          <literal>Require</literal> directive, take a look at the
          <literal>Security</literal> section of the Apache
          documentation's tutorials collection at <ulink
           url="http://httpd.apache.org/docs-2.0/misc/tutorials.html"/>.</para>
       @ENGLISH }}} -->
       <para>Это только несколько простых примеров. Для более полной информации 
         о управлении доступом в Apache и директиве <literal>Require</literal>, 
      	  взгляние на секцию <literal>Security</literal> в сборнике обучающей 
      	  документации Apache <ulink
           url="http://httpd.apache.org/docs-2.0/misc/tutorials.html"/>.</para>


      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authz.perdir">

        <!-- @ENGLISH {{{      
          <title>Per-Directory Access Control</title>
        @ENGLISH }}} -->
	      <title>Контроль доступа <quote>по папкам</quote> </title>

      	<!-- @ENGLISH {{{
        <para>It's possible to set up finer-grained permissions using
          a second Apache httpd module,
          <command>mod_authz_svn</command>.  This module grabs the
          various opaque URLs passing from client to server, asks
          <command>mod_dav_svn</command> to decode them, and then
          possibly vetoes requests based on access policies defined in
          a configuration file.</para>
        @ENGLISH }}} -->  
      	<para>Возможно установить более точные разрешения, используя второй 
     	    Apache httpd модуль - <command>mod_authz_svn</command>. Этот модуль 
    	   перехватывает различные не прозрачные URL, идущие от клиента к 
	       серверу, просит <command>mod_dav_svn</command> декодировать их для него, 
    	   и затем, возможно запрещает запросы, основываясь на правилах доступа, 
	       определенных в конфигурационном файле.</para>
      
 

        <!-- @ENGLISH {{{
        <para>If you've built Subversion from source code,
          <command>mod_authz_svn</command> is automatically built
          and installed alongside <command>mod_dav_svn</command>.
          Many binary distributions install it automatically as well.
          To verify that it's installed correctly, make sure it comes
          right after <command>mod_dav_svn</command>'s
          <literal>LoadModule</literal> directive in
          <filename>httpd.conf</filename>:</para>
        @ENGLISH }}} -->  
      	<para>Если вы собирали Subversion из исходного кода, 
      	   <command>mod_authz_svn</command> автоматически собирается и 
	         устанавливается рядом с <command>mod_dav_svn</command>. 
	         Большинство бинарных дистрибутивов также устанавливают его автоматически. 
	         Для того, что бы проверить, что он установлен правильно, убедитесь
	         что в <filename>httpd.conf</filename> он расположен после 
	         директивы загрузки <command>mod_dav_svn</command>            
           <literal>LoadModule</literal>:</para>

        <screen>
LoadModule dav_module         modules/mod_dav.so
LoadModule dav_svn_module     modules/mod_dav_svn.so
LoadModule authz_svn_module   modules/mod_authz_svn.so
</screen>

        <!-- @ENGLISH {{{
        <para>To activate this module, you need to configure your
          <literal>Location</literal> block to use the
          <literal>AuthzSVNAccessFile</literal> directive, which
          specifies a file containing the permissions policy for paths
          within your repositories.  (In a moment, we'll discuss the
          format of that file.)</para>
        @ENGLISH }}} -->  
	<para>Чтобы активировать этот модуль, Вам нужно изменить Ваш 
	    блок <literal>Location</literal> для использования 
	    директивы <literal>AuthzSVNAccessFile</literal>, который 
	    определяет файл содержащий правила разграничений для путей с 
	    Вашими хранилищами (Позднее мы обсудим формат этого файла).</para>

        <!-- @ENGLISH {{{
        <para>Apache is flexible, so you have the option to configure
          your block in one of three general patterns.  To begin,
          choose one of these basic configuration patterns.  (The
          examples below are very simple; look at Apache's own
          documentation for much more detail on Apache authentication
          and authorization options.)</para>
        @ENGLISH }}} -->  
	<para>Apache - гибкий, поэтому у Вас есть опция, с помощью которой
	   Вы можете настроить блок, по одному из трех основных шаблонов. 
	   Для начала - выберите один их этих основных конфигурационных 
	   шаблонов (Примеры ниже - очень простые, смотрите документацию 
	   Apache для получения больших деталей по опциям идентификации и 
	   авторизации в Apache).</para>
 

        <!-- @ENGLISH {{{
        <para>The simplest block is to allow open access to everyone.
          In this scenario, Apache never sends authentication
          challenges, so all users are treated as
          <quote>anonymous</quote>.</para>
        @ENGLISH }}} -->
        <para>Простейший блок допускает открытый доступ для каждого. 
           По этому сценарию, Apache никогда не отправит запрос на
           идентификацию, поэтому пользователи рассматриваются как 
           <quote>анонимные</quote>.</para>



        <example id="svn.serverconfig.httpd.authz.perdir.ex-1">
          <!-- @ENGLISH {{{
          <title>A sample configuration for anonymous access.</title>
          @ENGLISH }}} -->
          <title>Пример конфигурации для анонимного доступа.</title>

    
          <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # our access control policy
  AuthzSVNAccessFile /path/to/access/file
&lt;/Location&gt;
          </programlisting>
        </example>

       	<!-- @ENGLISH {{{
        <para>On the opposite end of the paranoia scale, you can
          configure your block to demand authentication from everyone.
          All clients must supply credentials to identify themselves.
          Your block unconditionally requires authentication via the

          <literal>Require valid-user</literal> directive, and defines
          a means to authenticate.</para>
          @ENGLISH }}} -->
        <para>С противоположной стороны - паранойя, Вы можете настроить 
            Ваш блок так, чтобы идентификация требовалась для каждого. 
            Все клиенты должны будут выдать свои данные, чтобы 
            идентифицировать себя. Ваш блок безоговорочно требует 
            идентификацию через директиву <literal>Require valid-user</literal> 
            и определяет средства идентификации.</para>


        <example id="svn.serverconfig.httpd.authz.perdir.ex-2">

           <!-- @ENGLISH {{{      
           <title>A sample configuration for authenticated access.</title>
           @ENGLISH }}} -->
           <title>Пример конфигурации для идентифицированного доступа.</title> 


          <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # our access control policy
  AuthzSVNAccessFile /path/to/access/file

  # only authenticated users may access the repository
  Require valid-user

  # how to authenticate a user
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file
&lt;/Location&gt;
          </programlisting>
        </example>

        <!-- @ENGLISH {{{
        <para>A third very popular pattern is to allow a combination
          of authenticated and anonymous access.  For example, many
          administrators want to allow anonymous users to read certain
          repository directories, but want only authenticated users to
          read (or write) more sensitive areas.  In this setup, all
          users start out accessing the repository anonymously.  If
          your access control policy demands a real username at any
          point, Apache will demand authentication from the client.
          To do this, you use both the <literal>Satisfy Any</literal>
          and <literal>Require valid-user</literal> directives
          together.</para>
        @ENGLISH }}} -->
        <para>Третий очень популярный шаблон позволяет комбинировать 
           идентифицированный и анонимный доступ. На пример, довольно 
           много администраторов хотят допускать анонимных 
           пользователей на чтение к определенным каталогам хранилища, 
           а к более <quote>нежным</quote> местам - только идентифицированных 
           пользователей на чтение (и/или запись). В этом случае все 
           пользователи начинают с анонимного доступа к хранилищу. Если 
           Ваша политика контроля доступа требует <quote>реального</quote> 
           имени пользователя в любом месте доступа, то Apache будет 
           требовать от клиента идентифицировать себя. Чтобы сделать это 
           используйте вместе директивы <literal>Satisfy Any</literal> и 
           <literal>Require valid-user</literal>.</para>


        <example id="svn.serverconfig.httpd.authz.perdir.ex-3">

          <!-- @ENGLISH {{{
          <title>A sample configuration for mixed	
            authenticated/anonymous access.</title> 
          @ENGLISH }}} -->
          <title>Пример конфигурации для смешанного 
            идентифицированного/анонимного доступа.</title>
 


          <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # our access control policy
  AuthzSVNAccessFile /path/to/access/file

  # try anonymous access first, resort to real
  # authentication if necessary.
  Satisfy Any
  Require valid-user

  # how to authenticate a user
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file
&lt;/Location&gt;
          </programlisting>
        </example>

        <!-- @ENGLISH {{{
        <para>Once you've settled on one of these three
          basic <filename>httpd.conf</filename> templates, you need to
          create your file containing access rules for particular
          paths within the repository.  This is described in
          <xref linkend="svn.serverconfig.pathbasedauthz"/>.</para>
        @ENGLISH }}} -->
        <para>Как только вы установлили один из трех базовых 
          <filename>httpd.conf</filename> шаблонов, вы должны создать 
          файл содержащий правила для конкретных путей в хранилище. Это 
          описано в <xref linkend="svn.serverconfig.pathbasedauthz"/>.</para>


      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authz.pathauthzoff">

        <!-- @ENGLISH {{{
        <title>Disabling Path-based Checks</title>

        <para>The <command>mod_dav_svn</command> module goes through a
          lot of work to make sure that data you've marked
          <quote>unreadable</quote> doesn't get accidentally leaked.
          This means that it needs to closely monitor all of the paths
          and file-contents returned by commands like <command>svn
          checkout</command> or <command>svn update</command>
          commands.  If these commands encounter a path that isn't
          readable according to some authorization policy, then the
          path is typically omitted altogether.  In the case of
          history or rename tracing&mdash;e.g. running a command like
          <command>svn cat -r OLD foo.c</command> on a file that was
          renamed long ago&mdash;the rename tracking will simply halt
          if one of the object's former names is determined to be
          read-restricted.</para>

        <para>All of this path-checking can sometimes be quite
          expensive, especially in the case of <command>svn
          log</command>.  When retrieving a list of revisions, the server
          looks at every changed path in each revision and checks it
          for readability.  If an unreadable path is discovered, then
          it's omitted from the list of the revision's changed paths
          (normally seen with the <option>--><!--verbose</option> option),
          and the whole log message is suppressed.  Needless to say,
          this can be time-consuming on revisions that affect a large
          number of files.  This is the cost of security: even if you
          haven't configured a module like
          <command>mod_authz_svn</command> at all, the
          <command>mod_dav_svn</command> module is still asking Apache
          <command>httpd</command> to run authorization checks on
          every path.  The <command>mod_dav_svn</command> module has
          no idea what authorization modules have been installed, so
          all it can do is ask Apache to invoke whatever might be
          present.</para>
        @ENGLISH }}} -->
        <title>Запрещение проверок основанных на пути</title>
        <para>Модуль <command>mod_dav_svn</command> делает массу работы для 
          того чтобы данные которые вы пометили как <quote>нечитаемые</quote>
          случайно не просочились. Это означает что нужно внимательно
          контролировать все пути и содержимое файлов возвращаемые командами 
          подобными <command>svn checkout</command> или 
          <command>svn update</command>. Если эти команды встречают путь, 
          который не читается из-за некоторых правил идентификации, то такой 
          путь обычно пропускается полностью. В этом случае прослеживание истории или 
          переименований файла (например выполнение команд подобных  
          <command>svn cat -r OLD foo.c</command>) которые были переименованы 
          очень давно, прослеживание переименований будет просто прекращено 
          если один из объектов определится как ограниченный для чтения.</para>

        <para>Все эти проверки пути могут иногда быть очень дорогостоящими
          особенно в случае <command>svn log</command>. Когда извлекается 
          список ревизий, сервер просматривает каждый измененный путь в 
          каждой ревизии и проверяет его на возможность чтения. Если 
          обнаруживается нечитаемый путь, тогда он исключается из списка
          измененных путей в ревизиях (обычно это видно с параметром  
          <option>--verbose</option>), и запрещается сообщение логирования 
          в целом. Излишне говорить, это может быть что это может  
          занимать много времени на ревизиях которые затрагивают большое
          количество файлов. Это стоимость безопасности: даже если вы вообще
          не имеете настроенного модуля подобного <command>mod_authz_svn</command>,
          модуль <command>mod_dav_svn</command> продолжает запрашивать у
          Apache <command>httpd</command>  запуск проверок идентификации
          каждого пути. Модуль <command>mod_dav_svn</command> не знает
          был ли установлен модуль авторизации, так все что он может 
          делать, это просить Apache вызвать его не зависимо от его наличия.</para>

        <!-- @ENGLISH {{{
        <para>On the other hand, there's also an escape-hatch of
          sorts, one which allows you to trade security features for
          speed.  If you're not enforcing any sort of per-directory
          authorization (i.e. not using
          <command>mod_authz_svn</command> or similar module), then
          you can disable all of this path-checking.  In your
          <filename>httpd.conf</filename> file, use the
          <literal>SVNPathAuthz</literal> directive:</para>
        @ENGLISH }}} -->
        <para>С другой стороны, также есть своего рода запасной выход, 
          который позволяет вам обменять возможности безопасности на скорость.
          Если вы не предписываете выполнение любого вида авторизации на основе
          директорий, (например не используете <command>mod_authz_svn</command>
          или подобного модуля), то вы можете запретить все проверки путей. В
          файле <filename>httpd.conf</filename>, используйте директиву
          <literal>SVNPathAuthz</literal>:</para>


        <example id="svn.serverconfig.httpd.authz.pathauthzoff.ex-1">

          <!-- @ENGLISH {{{
          <title>Disabling path checks altogether</title>
          @ENGLISH }}} -->
          <title>Полное запрещение проверок путей</title>


          <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  SVNPathAuthz off
&lt;/Location&gt;
          </programlisting>
        </example>

        <!-- @ENGLISH {{{
        <para>The <literal>SVNPathAuthz</literal> directive is <quote>on</quote> by
          default.  When set <quote>off</quote>, all path-based
          authorization checking is disabled;
          <command>mod_dav_svn</command> stops invoking authorization
          checks on every path it discovers.</para>
        @ENGLISH }}} -->
       <para>Директива <literal>SVNPathAuthz</literal> по умолчанию 
          <quote>включена</quote> 
          (<quote>on</quote>). Когда устанавливается в <quote>off</quote>, все проверки
          авторизации основанные на пути запрещаются, 
          <command>mod_dav_svn</command> 
          прекращает вовлекать авторизационные проверки для всех путей которые он 
          открывает.</para>
        
      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.extra">

      <!-- @ENGLISH {{{
      <title>Extra Goodies</title>

      <para>We've covered most of the authentication and authorization
        options for Apache and mod_dav_svn.  But there are a few other
        nice features that Apache provides.</para>
      @ENGLISH }}} -->
      <title>Дополнительные вкусности</title>

      <para>Мы рассказали о большинстве опций идентификации и авторизации 
         Apache и mod_dav_svn. А здесь рассмотрим еще несколько хороших 
        возможностей, которые предоставляет Apache.</para>


      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.extra.browsing">

        <!-- @ENGLISH {{{
        <title>Repository Browsing</title>

        <para>One of the most useful benefits of an Apache/WebDAV
          configuration for your Subversion repository is that the
          youngest revisions of your versioned files and directories
          are immediately available for viewing via a regular web
          browser.  Since Subversion uses URLs to identify versioned
          resources, those URLs used for HTTP-based repository access
          can be typed directly into a Web browser.  Your browser will
          issue an HTTP <literal>GET</literal> request for that URL, and
          based on whether that URL represents a versioned directory
          or file, mod_dav_svn will respond with a directory listing
          or with file contents.</para>

        <para>Since the URLs do not contain any information about
          which version of the resource you wish to see, mod_dav_svn
          will always answer with the youngest version.  This
          functionality has the wonderful side-effect that you can
          pass around Subversion URLs to your peers as references to
          documents, and those URLs will always point at the latest
          manifestation of that document.  Of course, you can even use
          the URLs as hyperlinks from other web sites, too.</para>
        @ENGLISH }}} -->
        <title>Просмотр хранилища</title>
        <para>Одно из наиболее полезных свойств настройки Apache/WebDAV 
          для работы с Subversion хранилищем - это то, что свежие исправления 
          Ваших  версионированных  файлов и каталогов будет немедленно 
          доступны для просмотра через обычный веб-браузер. Поскольку 
          Subversion использует URL для доступа к версионированным ресурсам, 
          эти URL, используемые для доступа к базирующемуся на HTTP 
          хранилищу, 
          могут быть введены прямо в веб-браузере. Вашим браузером для 
          этого URL будет сформирован HTTP запрос <literal>GET</literal>, и, в 
          зависимости от того, что из себя представляет URL - версионированный 
          каталог или файл, mod_dav_svn сформирует ответ с 
          листингом каталога или содержимым файла.</para>

        <para>Поскольку URL не содержит информации о том какую версию 
            ресурсов Вы хотите увидеть, mod_dav_svn будет всегда 
            выдавать последнюю версию. Эта функциональность имеет 
            замечательный побочный эффект - Вы можете передавать 
            другим адрес документа в хранилище Subversion как ссылку на 
            документ, а эти URL будут всегда указывать на последнюю версию 
            этого документа. Конечно, Вы также можете использовать URL 
            как гиперссылки с других Веб-сайтов. </para>


        <sidebar>

          <!-- @ENGLISH {{{
          <title>Can I view older revisions?</title>
          <para>With an ordinary web browser?  In one word: nope.  At
            least, not with <command>mod_dav_svn</command> as your
            only tool.</para>
          @ENGLISH }}} -->
          <title>Как я могу просмотреть старые версии?</title>

          <para>Обычным веб-браузером? Одним словом - никак. По крайней мере, 
             при использовании <command>mod_dav_svn</command> в качестве единственного 
             иструмента.</para>

          <!-- @ENGLISH {{{
          <para>Your web browser only speaks ordinary HTTP.  That
            means it only knows how to GET public URLs, which
            represent the latest versions of files and directories.
            According to the WebDAV/DeltaV specification, each server
            defines a private URL syntax for older versions of
            resources, and that syntax is opaque to clients.  To find
            an older version of a file, a client must follow a
            specific procedure to <quote>discover</quote> the proper
            URL; the procedure involves issuing a series of WebDAV
            PROPFIND requests and understanding DeltaV concepts.  This
            is something your web browser simply can't do.</para>

          <para>So to answer the question, one obvious way to see
            older revisions of files and directories is by passing the
            <option>--><!--revision (-r)</option> argument to
            the <command>svn list</command> and <command>svn
            cat</command> commands.  To browse old revisions with your
            web browser, however, you can use third-party software.  A
            good example of this is ViewVC
            (<ulink url="http://viewvc.tigris.org/"/>).  ViewVC was
            originally written to display CVS repositories through the
            web,
            <footnote>
              <para>Back then, it was called <quote>ViewCVS</quote>.</para>
            </footnote>
            and the latest releases are able to understand Subversion
            repositories as well.</para>
          @ENGLISH }}} -->
          <para>Ваш веб-браузер <quote>говорит</quote> только обычным HTTP. 
            Это означает, что он знает только как ПОЛУЧИТЬ доступные URL, 
            которые представляют последние версии файлов и каталогов. Согласно 
            спецификации WebDAV/DeltaV, каждый север определяет собственный 
            синтаксис URL для старых версий ресурсов, и этот синтаксис не явен 
            для клиентов. Чтобы найти старые версии файла, клиент должен 
            следовать определенной процедуре, чтобы <quote>обнаружить</quote> 
            соответствующий URL; процедура включает в себя создание серии запросов 
            WebDAV PROPFIND и требует понимания концепций DeltaV. 
            Это Ваш веб-браузер просто не сможет сделать.</para>

          <para>Так что ответом на вопрос является: единственный путь просмотра 
             старых версий файлов и каталогов это передача аргумента 
             <option>--revision (-r)</option> у команд <command>svn
            list</command> и <command>svn cat</command>. Однако, чтобы 
            просмотреть старые версии в Вашем веб-браузере, вы можете 
            использовать сторонние разработки. Хороший пример этого &mdash; 
            ViewCVS (<ulink url="http://viewvc.tigris.org/"/>). 
            ViewCVS был первоначально написан для отображения хранилищ CVS через Веб, 
            <footnote>
              <para>По этому он и называется <quote>ViewCVS</quote>.</para>
            </footnote>
            и самые последние версии также хорошо понимают хранилища Subversion.
            </para>

          
        </sidebar>

        <sect4 id="svn.serverconfig.httpd.extra.browsing.mimetype">

          <!-- @ENGLISH {{{
          <title>Proper MIME Type</title>

          <para>When browsing a Subversion repository, the web browser
            gets a clue about how to render a file's contents by
            looking at the <literal>Content-Type:</literal> header
            returned in Apache's response to the
            HTTP <literal>GET</literal> request.  The value of this
            header is some sort of MIME type.  By default, Apache will
            tell the web browsers that all repository files are of
            the <quote>default</quote> MIME type,
            typically <literal>text/plain</literal>.  This can be
            frustrating, however, if a user wishes repository files to
            render as something more meaningful &mdash; for example,
            it might be nice to have a <filename>foo.html</filename> file
            in the repository actually render as HTML when
            browsing.</para>
          @ENGLISH }}} -->
          <title>Правильный тип MIME</title>

          <para>Когда просматривается хранилище Subversion, 
            web-обозреватель получает ключ для правильного отображения 
            содержимого файлов из заголовка 
            <literal>Content-Type:</literal> возращаемого Apache в ответ 
            на запрос HTTP <literal>GET</literal>.  Значение этого 
            заголовка некторый сорт MIME типа. По умолчанию, Apache 
            будет говорить что все файлы хранилища имеют MIME-тип 
            <quote>по умолчанию</quote>, обычно 
            <literal>text/plain</literal>. Это может расстраивать, 
            однако если пользователь желает отобразить файлы хранилища 
            как нечто более полезное &mdash; например, может быть лучшим 
            иметь файл <filename>foo.html</filename> в хранилище который 
            отображается как HTML при просмотре.</para>

          <!-- @ENGLISH {{{
          <para>To make this happen, you only need to make sure that
            your files have the
            proper <literal>svn:mime-type</literal> set.  This is
            discussed in more detail in
            <xref linkend="svn.advanced.props.special.mime-type"/>,
            and you can even configure your client to automatically
            attach proper <literal>svn:mime-type</literal> properties
            to files entering the repository for the first time;  see
            <xref linkend="svn.advanced.props.auto"/>.</para>

          <para>So in our example, if one were to set
            the <literal>svn:mime-type</literal> property
            to <literal>text/html</literal> on
            file <filename>foo.html</filename>, then Apache would
            properly tell your web browser to render the file as
            HTML.  One could also attach
            proper <literal>image/*</literal> mime-type properties to
            images, and by doing this, ultimately get an entire web
            site to be viewable directly from a repository!  There's
            generally no problem with doing this, as long as the
            website doesn't contain any dynamically-generated
            content.</para>
          @ENGLISH }}} -->
          <para>Для того чтобы это случилось, вы нуждаетесь только в в 
            том, что вашим файлам установлены правильное свойство 
            <literal>svn:mime-type</literal>. Более детально это 
            обсуждается в <xref 
              linkend="svn.advanced.props.special.mime-type"/>, и вы 
            даже можете настроить вашего клиента для автоматического 
            присоединения правильных свойств 
            <literal>svn:mime-type</literal> к файлам вводимых в 
            хранилище в первый раз, смотрите 
            <xref linkend="svn.advanced.props.auto"/>.</para>

          <para>Так в нашем примере, если кто-либо установил свойство 
            <literal>svn:mime-type</literal> в 
            <literal>text/html</literal> для файла 
            <filename>foo.html</filename>, тогда Apache будет 
            говорить вашему web-браузеру что нужно отображать этот файл 
            как HTML.  Он также может присоединять соответствующий 
            mime-тип <literal>image/*</literal> к картинкам, и делая 
            так, в конце концов получите весь web-сайт просматриваемый 
            напрямую из хранилища! В общем нет проблем делать так, 
            только если сайт не содержит любого динамичеки генерируемого 
            содержимого.</para>
          


        </sect4>

        <sect4 id="svn.serverconfig.httpd.extra.browsing.xslt">

          <!-- @ENGLISH {{{
          <title>Customizing the Look</title>

          <para>You generally will get more use out of URLs to
            versioned files&mdash;after all, that's where the
            interesting content tends to lie.  But you might have
            occasion to browse a Subversion directory listing, where
            you'll quickly note that the generated HTML used to
            display that listing is very basic, and certainly not
            intended to be aesthetically pleasing (or even
            interesting).  To enable customization of these directory
            displays, Subversion provides an XML index feature.  A
            single <literal>SVNIndexXSLT</literal> directive in your
            repository's <literal>Location</literal> block of
            <filename>httpd.conf</filename> will instruct mod_dav_svn
            to generate XML output when displaying a directory
            listing, and to reference the XSLT stylesheet of your
            choice:</para>
          @ENGLISH }}} -->
          <title>Подгонка отображения</title>

          <para>You generally will get more use out of URLs to
            versioned files&mdash;after all, that's where the
            interesting content tends to lie.  But you might have
            occasion to browse a Subversion directory listing, where
            you'll quickly note that the generated HTML used to
            display that listing is very basic, and certainly not
            intended to be aesthetically pleasing (or even
            interesting).  To enable customization of these directory
            displays, Subversion provides an XML index feature.  A
            single <literal>SVNIndexXSLT</literal> directive in your
            repository's <literal>Location</literal> block of
            <filename>httpd.conf</filename> will instruct mod_dav_svn
            to generate XML output when displaying a directory
            listing, and to reference the XSLT stylesheet of your
            choice:</para>


        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  SVNIndexXSLT "/svnindex.xsl"
  &hellip;
&lt;/Location&gt;
</screen>

         <!-- @ENGLISH {{{
         <para>Using the <literal>SVNIndexXSLT</literal> directive and
           a creative XSLT stylesheet, you can make your directory
           listings match the color schemes and imagery used in other
           parts of your website.  Or, if you'd prefer, you can use
           the sample stylesheets provided in the Subversion source
           distribution's <filename>tools/xslt/</filename> directory.
           Keep in mind that the path provided to the
           <literal>SVNIndexXSLT</literal> directory is actually a URL
           path&mdash;browsers need to be able to read your
           stylesheets in order to make use of them!</para>
         @ENGLISH }}} -->
         <para>Используя директиву <literal>SVNIndexXSLT</literal> и творчески 
           созданную XSLT таблицу стилей, Вы можете сделать Ваши листинги каталогов, 
           так чтобы они соответствовали цветовой палитре и графическому оформлению 
           остального содержимого Вашего веб-сайта. Или, если Вы предпочитаете, Вы 
           можете использовать примеры таблиц стилей, идущих с дистрибутивом 
           Subversion, из каталога <filename>tools/xslt/</filename> . Имейте в виду, 
           что путь указанный в <literal>SVNIndexXSLT</literal> &mdash;действующий путь URL, 
           и браузеры должны иметь возможность прочитать Ваши таблицы стилей, чтобы 
           использовать их!</para>
         
         </sect4>

        <sect4 id="svn.serverconfig.httpd.extra.browsing.reposlisting">
          <!-- @ENGLISH {{{
          <title>Listing Repositories</title>

          <para>If you're serving a collection of repositories from a
            single URL via the <literal>SVNParentPath</literal>
            directive, then it's also possible to have Apache display
            all available repositories to a web browser.  Just
            activate the <literal>SVNListParentPath</literal>
            directive:</para>
          @ENGLISH }}} -->
          <title>Listing Repositories</title>

          <para>If you're serving a collection of repositories from a
            single URL via the <literal>SVNParentPath</literal>
            directive, then it's also possible to have Apache display
            all available repositories to a web browser.  Just
            activate the <literal>SVNListParentPath</literal>
            directive:</para>


          <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  SVNListParentPath on
  &hellip;
&lt;/Location&gt;
</screen>

        <!-- @ENGLISH {{{
        <para>If a user now points her web browser to the
          URL <literal>http://host.example.com/svn/</literal>, she'll
          see list of all Subversion repositories sitting
          in <filename>/usr/local/svn</filename>.  Obviously, this can
          be a security problem, so this feature is turned off by
          default.</para>
        @ENGLISH }}} -->
        <para>If a user now points her web browser to the
          URL <literal>http://host.example.com/svn/</literal>, she'll
          see list of all Subversion repositories sitting
          in <filename>/usr/local/svn</filename>.  Obviously, this can
          be a security problem, so this feature is turned off by
          default.</para>

        </sect4>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.extra.logging">

        <!-- @ENGLISH {{{
        <title>Apache Logging</title>

        <para>Because Apache is an HTTP server at heart, it contains
          fantastically flexible logging feature.  It's beyond the
          scope of this book to discuss all ways logging can be
          configured, but we should point out that even the most
          generic <filename>httpd.conf</filename> file will cause
          Apache to produce two logs:
          <filename>error_log</filename>
          and <filename>access_log</filename>.  These logs may appear
          in different places, but are typically created in the
          logging area of your Apache installation.  (On Unix, they
          often live
          in <filename>/usr/local/apache2/logs/</filename>.)</para>
        @ENGLISH }}} -->
        <title>Apache Logging</title>

        <para>Because Apache is an HTTP server at heart, it contains
          fantastically flexible logging feature.  It's beyond the
          scope of this book to discuss all ways logging can be
          configured, but we should point out that even the most
          generic <filename>httpd.conf</filename> file will cause
          Apache to produce two logs:
          <filename>error_log</filename>
          and <filename>access_log</filename>.  These logs may appear
          in different places, but are typically created in the
          logging area of your Apache installation.  (On Unix, they
          often live
          in <filename>/usr/local/apache2/logs/</filename>.)</para>
        
        <!-- @ENGLISH {{{
        <para>The <filename>error_log</filename> describes any internal
          errors that Apache runs into as it works.
          The <filename>access_log</filename> file records every
          incoming HTTP request received by Apache.  This makes it
          easy to see, for example, which IP addresses Subversion
          clients are coming from, how often particular clients use
          the server, which users are authenticating properly, and
          which requests succeed or fail.</para>

        <para>Unfortunately, because HTTP is a stateless protocol,
          even the simplest Subversion client operation generates
          multiple network requests.  It's very difficult to look at
          the <filename>access_log</filename> and deduce what the
          client was doing &mdash; most operations look like a series
          of cryptic <literal>PROPPATCH</literal>, <literal>GET</literal>,
          <literal>PUT</literal>, and <literal>REPORT</literal>
          requests.  To make things worse, many client operations send
          nearly-identical series of requests, so it's even harder to
          tell them apart.</para>
        @ENGLISH }}} -->
        <para>The <filename>error_log</filename> describes any internal
          errors that Apache runs into as it works.
          The <filename>access_log</filename> file records every
          incoming HTTP request received by Apache.  This makes it
          easy to see, for example, which IP addresses Subversion
          clients are coming from, how often particular clients use
          the server, which users are authenticating properly, and
          which requests succeed or fail.</para>

        <para>Unfortunately, because HTTP is a stateless protocol,
          even the simplest Subversion client operation generates
          multiple network requests.  It's very difficult to look at
          the <filename>access_log</filename> and deduce what the
          client was doing &mdash; most operations look like a series
          of cryptic <literal>PROPPATCH</literal>, <literal>GET</literal>,
          <literal>PUT</literal>, and <literal>REPORT</literal>
          requests.  To make things worse, many client operations send
          nearly-identical series of requests, so it's even harder to
          tell them apart.</para>
        
        <!-- @ENGLISH {{{
        <para><literal>mod_dav_svn</literal>, however, can come to
          your aid.  By activating an <quote>operational
          logging</quote> feature, you can
          ask <literal>mod_dav_svn</literal> to create a separate log
          file describing what sort of high-level operations your
          clients are performing.</para>

        <para>To do this, you need to make use of
          Apache's <literal>CustomLog</literal> directive (which is
          explained in more detail in Apache's own documentation).
          Be sure to invoke this
          directive <emphasis>outside</emphasis> of your
          Subversion <literal>Location</literal> block:</para>
        @ENGLISH }}} -->
        <para><literal>mod_dav_svn</literal>, however, can come to
          your aid.  By activating an <quote>operational
          logging</quote> feature, you can
          ask <literal>mod_dav_svn</literal> to create a separate log
          file describing what sort of high-level operations your
          clients are performing.</para>

        <para>To do this, you need to make use of
          Apache's <literal>CustomLog</literal> directive (which is
          explained in more detail in Apache's own documentation).
          Be sure to invoke this
          directive <emphasis>outside</emphasis> of your
          Subversion <literal>Location</literal> block:</para>


        <screen>
&lt;Location /svn&gt;
  DAV svn
  &hellip;
&lt;/Location&gt;

CustomLog logs/svn_logfile "%t %u %{SVN-ACTION}e" env=SVN-ACTION
</screen>

        <!-- @ENGLISH {{{
        <para>In this example, we're asking Apache to create a special
          logfile <filename>svn_logfile</filename> in the standard
          Apache <filename>logs</filename> directory.
          The <literal>%t</literal> and <literal>%u</literal>
          variables are replaced by the time and username of the
          request, respectively.  The really important part are the
          two instances of <literal>SVN-ACTION</literal>.
          When Apache sees that variable, it substitutes the value of
          the <literal>SVN-ACTION</literal> environment variable,
          which is automatically set by <literal>mod_dav_svn</literal>
          whenever it detects a high-level client action.</para>

        <para>So instead of having to interpret a
          traditional <filename>access_log</filename> like
          this:</para>
        @ENGLISH }}} -->
        <para>In this example, we're asking Apache to create a special
          logfile <filename>svn_logfile</filename> in the standard
          Apache <filename>logs</filename> directory.
          The <literal>%t</literal> and <literal>%u</literal>
          variables are replaced by the time and username of the
          request, respectively.  The really important part are the
          two instances of <literal>SVN-ACTION</literal>.
          When Apache sees that variable, it substitutes the value of
          the <literal>SVN-ACTION</literal> environment variable,
          which is automatically set by <literal>mod_dav_svn</literal>
          whenever it detects a high-level client action.</para>

        <para>So instead of having to interpret a
          traditional <filename>access_log</filename> like
          this:</para>


        <screen>
[26/Jan/2007:22:25:29 -0600] "PROPFIND /svn/calc/!svn/vcc/default HTTP/1.1" 207 398
[26/Jan/2007:22:25:29 -0600] "PROPFIND /svn/calc/!svn/bln/59 HTTP/1.1" 207 449
[26/Jan/2007:22:25:29 -0600] "PROPFIND /svn/calc HTTP/1.1" 207 647
[26/Jan/2007:22:25:29 -0600] "REPORT /svn/calc/!svn/vcc/default HTTP/1.1" 200 607
[26/Jan/2007:22:25:31 -0600] "OPTIONS /svn/calc HTTP/1.1" 200 188
[26/Jan/2007:22:25:31 -0600] "MKACTIVITY /svn/calc/!svn/act/e6035ef7-5df0-4ac0-b811-4be7c823f998 HTTP/1.1" 201 227
&hellip;
</screen>

        <!-- @ENGLISH {{{
        <para>&hellip; you can instead peruse a much more
          intelligible <filename>svn_logfile</filename> like this:</para>
        @ENGLISH }}} -->
        <para>&hellip; you can instead peruse a much more
          intelligible <filename>svn_logfile</filename> like this:</para>


        <screen>
[26/Jan/2007:22:24:20 -0600] - list-dir '/'
[26/Jan/2007:22:24:27 -0600] - update '/'
[26/Jan/2007:22:25:29 -0600] - remote-status '/'
[26/Jan/2007:22:25:31 -0600] sally commit r60
</screen>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.extra.other">

        <!-- @ENGLISH {{{
        <title>Other Features</title>

        <para>Several of the features already provided by Apache in
          its role as a robust Web server can be leveraged for
          increased functionality or security in Subversion as well.
          Subversion communicates with Apache using Neon, which is a
          generic HTTP/WebDAV library with support for such mechanisms
          as SSL (the Secure Socket Layer, discussed earlier).  If
          your Subversion client is built to support SSL, then it can
          access your Apache server
          using <literal>https://</literal>.</para>
        @ENGLISH }}} -->
        <title>Другие возможности</title>

        <para>Некоторые возможности которые предоставляет Apache в
          роле устойчивого  Web-сервера также может быть использовано для усиления
          функционала или безопасности Subversion. Subversion взаимодействует 
          с Apache используя Neon, которая является общей библиотекой 
          HTTP/WebDAV с поддержкой механизмов таких как SSL (Secure Socket Layer, 
          обсуждавшийся ранее).  
          If your Subversion client is built to support SSL, then it can
          access your Apache server
          using <literal>https://</literal>.</para>
        

        <!-- @ENGLISH {{{
        <para>Equally useful are other features of the Apache and
          Subversion relationship, such as the ability to specify a
          custom port (instead of the default HTTP port 80) or a
          virtual domain name by which the Subversion repository
          should be accessed, or the ability to access the repository
          through an HTTP proxy.  These things are all supported by
          Neon, so Subversion gets that support for free.</para>
        @ENGLISH }}} -->
        <para>Equally useful are other features of the Apache and
          Subversion relationship, such as the ability to specify a
          custom port (instead of the default HTTP port 80) or a
          virtual domain name by which the Subversion repository
          should be accessed, or the ability to access the repository
          through an HTTP proxy.  These things are all supported by
          Neon, so Subversion gets that support for free.</para>

        <!-- @ENGLISH {{{
        <para>Finally, because <command>mod_dav_svn</command> is
          speaking a subset of the WebDAV/DeltaV protocol, it's
          possible to access the repository via third-party DAV
          clients.  Most modern operating systems (Win32, OS X, and
          Linux) have the built-in ability to mount a DAV server as a
          standard network share.  This is a complicated topic; for
          details, read <xref linkend="svn.webdav"/>.</para>
        @ENGLISH }}} -->
        <para>В заключение, так как <command>mod_dav_svn</command> 
          общается на подмножестве протокола WebDAV/DeltaV, он 
          может получать доступ к хранилищу через сторонние клиенты DAV.
          Многие современные операционные системы (Win32, OS X и
          Linux) имеют встроенную возможность монтировать DAV как 
          обычную сетевую <quote>шару</quote>. Это сложная тема, 
          подробности читайте в <xref
          linkend="svn.webdav"/>.</para>
      </sect3>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.pathbasedauthz">

    <!-- @ENGLISH {{{
    <title>Path-Based Authorization</title>

    <para>Both Apache and <command>svnserve</command> are capable of
      granting (or denying) permissions to users.  Typically this is
      done over the entire repository: a user can read the repository
      (or not), and she can write to the repository (or not).  It's
      also possible, however, to define finer-grained access rules.
      One set of users may have permission to write to a certain
      directory in the repository, but not others; another directory
      might not even be readable by all but a few special
      people.</para>

    <para>Both servers use a common file format to describe these
      path-based access rules.  In the case of Apache, one needs to
      load the <command>mod_authz_svn</command> module and then add
      the <literal>AuthzSVNAccessFile</literal> directive (within
      the <filename>httpd.conf</filename> file) pointing to your own
      rules-file.  (For a full explanation, see
      <xref linkend="svn.serverconfig.httpd.authz.perdir"/>.)  If
      you're using <command>svnserve</command>, then you need to make
      the <literal>authz-db</literal> variable
      (within <filename>svnserve.conf</filename>) point to your
      rules-file.</para>
    @ENGLISH }}} -->
    <title>Path-Based Authorization</title>

    <para>Both Apache and <command>svnserve</command> are capable of
      granting (or denying) permissions to users.  Typically this is
      done over the entire repository: a user can read the repository
      (or not), and she can write to the repository (or not).  It's
      also possible, however, to define finer-grained access rules.
      One set of users may have permission to write to a certain
      directory in the repository, but not others; another directory
      might not even be readable by all but a few special
      people.</para>

    <para>Both servers use a common file format to describe these
      path-based access rules.  In the case of Apache, one needs to
      load the <command>mod_authz_svn</command> module and then add
      the <literal>AuthzSVNAccessFile</literal> directive (within
      the <filename>httpd.conf</filename> file) pointing to your own
      rules-file.  (For a full explanation, see
      <xref linkend="svn.serverconfig.httpd.authz.perdir"/>.)  If
      you're using <command>svnserve</command>, then you need to make
      the <literal>authz-db</literal> variable
      (within <filename>svnserve.conf</filename>) point to your
      rules-file.</para>

    <sidebar>

      <!-- @ENGLISH {{{
      <title>Do you really need path-based access control?</title>

      <para>A lot of administrators setting up Subversion for the
        first time tend to jump into path-based access control without
        giving it a lot of thought.  The administrator usually knows
        which teams of people are working on which projects, so it's
        easy to jump in and grant certain teams access to certain
        directories and not others.  It seems like a natural thing,
        and it appeases the administrator's desire to maintain tight
        control of the repository.</para>
      @ENGLISH }}} -->
      <title>Do you really need path-based access control?</title>

      <para>A lot of administrators setting up Subversion for the
        first time tend to jump into path-based access control without
        giving it a lot of thought.  The administrator usually knows
        which teams of people are working on which projects, so it's
        easy to jump in and grant certain teams access to certain
        directories and not others.  It seems like a natural thing,
        and it appeases the administrator's desire to maintain tight
        control of the repository.</para>
      
      <!-- @ENGLISH {{{
      <para>Note, though, that there are often invisible (and
        visible!) costs associated with this feature.  In the visible
        category, the server needs to do a lot more work to ensure
        that the user has the right to read or write each specific
        path; in certain situations, there's very noticeable
        performance loss.  In the invisible category, consider the
        culture you're creating.  Most of the time, while certain
        users <emphasis>shouldn't</emphasis> be committing changes to
        certain parts of the repository, that social contract doesn't
        need to be technologically enforced.  Teams can sometimes
        spontaneously collaborate with each other; someone may want to
        help someone else out by committing to an area she doesn't
        normally work on.  By preventing this sort of thing at the
        server level, you're setting up barriers to unexpected
        collaboration.  You're also creating a bunch of rules that
        need to be maintained as projects develop, new users are
        added, and so on.  It's a bunch of extra work to
        maintain.</para>

        <para>Remember that this is a version control system!  Even if
        somebody accidentally commits a change to something they
        shouldn't, it's easy to undo the change.  And if a user
        commits to the wrong place with deliberate malice, then it's a
        social problem anyway, and that the problem needs to be dealt
        with outside of Subversion.</para>
      @ENGLISH }}} -->
      <para>Note, though, that there are often invisible (and
        visible!) costs associated with this feature.  In the visible
        category, the server needs to do a lot more work to ensure
        that the user has the right to read or write each specific
        path; in certain situations, there's very noticeable
        performance loss.  In the invisible category, consider the
        culture you're creating.  Most of the time, while certain
        users <emphasis>shouldn't</emphasis> be committing changes to
        certain parts of the repository, that social contract doesn't
        need to be technologically enforced.  Teams can sometimes
        spontaneously collaborate with each other; someone may want to
        help someone else out by committing to an area she doesn't
        normally work on.  By preventing this sort of thing at the
        server level, you're setting up barriers to unexpected
        collaboration.  You're also creating a bunch of rules that
        need to be maintained as projects develop, new users are
        added, and so on.  It's a bunch of extra work to
        maintain.</para>

        <para>Remember that this is a version control system!  Even if
        somebody accidentally commits a change to something they
        shouldn't, it's easy to undo the change.  And if a user
        commits to the wrong place with deliberate malice, then it's a
        social problem anyway, and that the problem needs to be dealt
        with outside of Subversion.</para>
      
      <!-- @ENGLISH {{{
      <para>So before you begin restricting users' access rights, ask
        yourself if there's a real, honest need for this, or if it's
        just something that <quote>sounds good</quote> to an
        administrator.  Decide whether it's worth sacrificing some
        server speed for, and remember that there's very little risk
        involved; it's bad to become dependent on technology as a
        crutch for social problems.<footnote><para>A common theme in
        this book!</para></footnote>.</para>

      <para>As an example to ponder, consider that the Subversion
        project itself has always had a notion of who is allowed to
        commit where, but it's always been enforced socially.  This is
        a good model of community trust, especially for open-source
        projects.  Of course, sometimes there <emphasis>are</emphasis>
        truly legitimate needs for path-based access control; within
        corporations, for example, certain types of data really can be
        sensitive, and access needs to be genuinely restricted to
        small groups of people.</para>
      @ENGLISH }}} -->
      <para>So before you begin restricting users' access rights, ask
        yourself if there's a real, honest need for this, or if it's
        just something that <quote>sounds good</quote> to an
        administrator.  Decide whether it's worth sacrificing some
        server speed for, and remember that there's very little risk
        involved; it's bad to become dependent on technology as a
        crutch for social problems.<footnote><para>A common theme in
        this book!</para></footnote>.</para>

      <para>As an example to ponder, consider that the Subversion
        project itself has always had a notion of who is allowed to
        commit where, but it's always been enforced socially.  This is
        a good model of community trust, especially for open-source
        projects.  Of course, sometimes there <emphasis>are</emphasis>
        truly legitimate needs for path-based access control; within
        corporations, for example, certain types of data really can be
        sensitive, and access needs to be genuinely restricted to
        small groups of people.</para>


    </sidebar>

    <!-- @ENGLISH {{{
    <para>Once your server knows where to find your rules-file, it's
      time to define the rules.</para>

    <para>The syntax of the file is the same familiar one used
      by <command>svnserve.conf</command> and the runtime
      configuration files.  Lines that start with a hash
      (<literal>#</literal>) are ignored.  In its simplest form, each
      section names a repository and path within it, and the
      authenticated usernames are the option names within each
      section.  The value of each option describes the user's level of
      access to the repository path: either
      <literal>r</literal> (read-only) or <literal>rw</literal>
      (read-write).  If the user is not mentioned at all, no access is
      allowed.</para>

    <para>To be more specific: the value of the section-names are
      either of the form <literal>[repos-name:path]</literal> or the
      form <literal>[path]</literal>.  If you're using the
      <literal>SVNParentPath</literal> directive, then it's important
      to specify the repository names in your sections.  If you omit
      them, then a section like
      <literal>[/some/dir]</literal> will match the path
      <filename>/some/dir</filename> in <emphasis>every</emphasis>
      repository.  If you're using the <literal>SVNPath</literal>
      directive, however, then it's fine to only define paths in your
      sections&mdash;after all, there's only one repository.</para>
    @ENGLISH }}} -->
    <para>Once your server knows where to find your rules-file, it's
      time to define the rules.</para>

    <para>The syntax of the file is the same familiar one used
      by <command>svnserve.conf</command> and the runtime
      configuration files.  Lines that start with a hash
      (<literal>#</literal>) are ignored.  In its simplest form, each
      section names a repository and path within it, and the
      authenticated usernames are the option names within each
      section.  The value of each option describes the user's level of
      access to the repository path: either
      <literal>r</literal> (read-only) or <literal>rw</literal>
      (read-write).  If the user is not mentioned at all, no access is
      allowed.</para>

    <para>To be more specific: the value of the section-names are
      either of the form <literal>[repos-name:path]</literal> or the
      form <literal>[path]</literal>.  If you're using the
      <literal>SVNParentPath</literal> directive, then it's important
      to specify the repository names in your sections.  If you omit
      them, then a section like
      <literal>[/some/dir]</literal> will match the path
      <filename>/some/dir</filename> in <emphasis>every</emphasis>
      repository.  If you're using the <literal>SVNPath</literal>
      directive, however, then it's fine to only define paths in your
      sections&mdash;after all, there's only one repository.</para>

    <screen>
[calc:/branches/calc/bug-142]
harry = rw
sally = r
</screen>

    <!-- @ENGLISH {{{
    <para>In this first example, the user <literal>harry</literal> has
      full read and write access on the
      <filename>/branches/calc/bug-142</filename> directory in the
      <literal>calc</literal> repository, but the user
      <literal>sally</literal> has read-only access.  Any other users
      are blocked from accessing this directory.</para>

    <para>Of course, permissions are inherited from parent to child
      directory.  That means that we can specify a subdirectory with a
      different access policy for Sally:</para>
    @ENGLISH }}} -->
    <para>In this first example, the user <literal>harry</literal> has
      full read and write access on the
      <filename>/branches/calc/bug-142</filename> directory in the
      <literal>calc</literal> repository, but the user
      <literal>sally</literal> has read-only access.  Any other users
      are blocked from accessing this directory.</para>

    <para>Of course, permissions are inherited from parent to child
      directory.  That means that we can specify a subdirectory with a
      different access policy for Sally:</para>


    <screen>
[calc:/branches/calc/bug-142]
harry = rw
sally = r

# give sally write access only to the 'testing' subdir
[calc:/branches/calc/bug-142/testing]
sally = rw
</screen>

    <!-- @ENGLISH {{{
    <para>Now Sally can write to the <filename>testing</filename>
      subdirectory of the branch, but can still only read other parts.
      Harry, meanwhile, continues to have complete read-write access
      to the whole branch.</para>

    <para>It's also possible to explicitly deny permission to someone
      via inheritance rules, by setting the username variable to
      nothing:</para>
    @ENGLISH }}} -->
    <para>Now Sally can write to the <filename>testing</filename>
      subdirectory of the branch, but can still only read other parts.
      Harry, meanwhile, continues to have complete read-write access
      to the whole branch.</para>

    <para>It's also possible to explicitly deny permission to someone
      via inheritance rules, by setting the username variable to
      nothing:</para>


    <screen>
[calc:/branches/calc/bug-142]
harry = rw
sally = r

[calc:/branches/calc/bug-142/secret]
harry =
</screen>

    <!-- @ENGLISH {{{
    <para>In this example, Harry has read-write access to the
      entire <filename>bug-142</filename> tree, but has absolutely no
      access at all to the <filename>secret</filename> subdirectory
      within it.</para>

    <para>The thing to remember is that the most specific path always
      matches first.  The server tries to match the path itself, and
      then the parent of the path, then the parent of that, and so on.
      The net effect is that mentioning a specific path in the
      accessfile will always override any permissions inherited from
      parent directories.</para>

    <para>By default, nobody has any access to the repository at all.
      That means that if you're starting with an empty file, you'll
      probably want to give at least read permission to all users at
      the root of the repository.  You can do this by using the
      asterisk variable (<literal>*</literal>), which means <quote>all
      users</quote>:</para>
    @ENGLISH }}} -->
    <para>In this example, Harry has read-write access to the
      entire <filename>bug-142</filename> tree, but has absolutely no
      access at all to the <filename>secret</filename> subdirectory
      within it.</para>

    <para>The thing to remember is that the most specific path always
      matches first.  The server tries to match the path itself, and
      then the parent of the path, then the parent of that, and so on.
      The net effect is that mentioning a specific path in the
      accessfile will always override any permissions inherited from
      parent directories.</para>

    <para>By default, nobody has any access to the repository at all.
      That means that if you're starting with an empty file, you'll
      probably want to give at least read permission to all users at
      the root of the repository.  You can do this by using the
      asterisk variable (<literal>*</literal>), which means <quote>all
      users</quote>:</para>
  
    <screen>
[/]
* = r
</screen>

    <!-- @ENGLISH {{{
    <para>This is a common setup; notice that there's no repository
      name mentioned in the section name.  This makes all repositories
      world readable to all users. Once all users have read-access to
      the repositories, you can give explicit
      <literal>rw</literal> permission to certain users on specific
      subdirectories within specific repositories.</para>

    <para>The asterisk variable (<literal>*</literal>) is also worth
      special mention here: it's the
      <emphasis>only</emphasis> pattern which matches an anonymous
      user.  If you've configured your server block to allow a mixture
      of anonymous and authenticated access, all users start out
      accessing anonymously.  The server looks for a
      <literal>*</literal> value defined for the path being accessed;
      if it can't find one, then it demands real authentication from
      the client.</para>

    <para>The access file also allows you to define whole groups of
      users, much like the Unix <filename>/etc/group</filename>
      file:</para>
    @ENGLISH }}} -->
    <para>This is a common setup; notice that there's no repository
      name mentioned in the section name.  This makes all repositories
      world readable to all users. Once all users have read-access to
      the repositories, you can give explicit
      <literal>rw</literal> permission to certain users on specific
      subdirectories within specific repositories.</para>

    <para>The asterisk variable (<literal>*</literal>) is also worth
      special mention here: it's the
      <emphasis>only</emphasis> pattern which matches an anonymous
      user.  If you've configured your server block to allow a mixture
      of anonymous and authenticated access, all users start out
      accessing anonymously.  The server looks for a
      <literal>*</literal> value defined for the path being accessed;
      if it can't find one, then it demands real authentication from
      the client.</para>

    <para>The access file also allows you to define whole groups of
      users, much like the Unix <filename>/etc/group</filename>
      file:</para>


    <screen>
[groups]
calc-developers = harry, sally, joe
paint-developers = frank, sally, jane
everyone = harry, sally, joe, frank, sally, jane
</screen>
    <!-- @ENGLISH {{{
    <para>Groups can be granted access control just like users.
      Distinguish them with an <quote>at</quote>
      (<literal>@</literal>) prefix:</para>
    @ENGLISH }}} -->
    <para>Groups can be granted access control just like users.
      Distinguish them with an <quote>at</quote>
      (<literal>@</literal>) prefix:</para>

    <screen>
[calc:/projects/calc]
@calc-developers = rw

[paint:/projects/paint]
@paint-developers = rw
jane = r
</screen>

    <!-- @ENGLISH {{{
    <para>Groups can also be defined to contain other groups:</para>
    @ENGLISH }}} -->
    <para>Groups can also be defined to contain other groups:</para>


    <screen>
[groups]
calc-developers = harry, sally, joe
paint-developers = frank, sally, jane
everyone = @calc-developers, @paint-developers
</screen>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.multimethod">

    <!-- @ENGLISH {{{
    <title>Supporting Multiple Repository Access Methods</title>
    @ENGLISH }}} -->
    <title>Поддержка нескольких методов доступа к хранилищу</title>

    <!-- @ENGLISH {{{
    <para>You've seen how a repository can be accessed in many
      different ways.  But is it possible&mdash;or safe&mdash;for your
      repository to be accessed by multiple methods simultaneously?
      The answer is yes, provided you use a bit of foresight.</para>
    @ENGLISH }}} -->
    <para>Вы уже видели как получить доступ к хранилищу несколькими
      различными путями. Но возможно ли получить и безопасно ли доступ
      к хранилищу несколькими методами одновременно? Ответ да, если вы
      используете немного предвиденья.</para>


    <!-- @ENGLISH {{{
    <para>At any given time, these processes may require read and
      write access to your repository:</para>
    @ENGLISH }}} -->
    <para>В любой момент времени, эти процессы могут требовать доступа
      для чтения и записи в ваше хранилище:</para>


    <itemizedlist>
      <listitem>
        <!-- @ENGLISH {{{
        <para>regular system users using a Subversion client (as
          themselves) to access the repository directly via
          <literal>file://</literal> URLs;</para>
        @ENGLISH }}} -->
        <para>обычный пользователь системы использует клиента Subversion 
          (как обычно) для доступа к хранилищу непосредственно через URL
          <literal>file://</literal>;</para>
      </listitem>
      <listitem>
        <!-- @ENGLISH {{{
        <para>regular system users connecting to SSH-spawned private
          <command>svnserve</command> processes (running as
          themselves) which access the repository;</para>
        @ENGLISH }}} -->
        <para>обычный пользователь системы соединяется через порожденный 
          SSH личный процесс <command>svnserve</command> (запущенный как обычно)
          с доступом к хранилищу;</para>
      </listitem>
      <listitem>
        <!-- @ENGLISH {{{
        <para>an <command>svnserve</command> process&mdash;either a
          daemon or one launched by
          <command>inetd</command>&mdash;running as a particular fixed
          user;</para>
        @ENGLISH }}} -->
        <para>процесс <command>svnserve</command>&mdash;или как демон, или 
          запущенный через <command>inetd</command>&mdash;выполняется 
          под некоторым фиксированным пользователем;</para>
      </listitem>
      <listitem>
        <!-- @ENGLISH {{{
        <para>an Apache <command>httpd</command> process, running as a
          particular fixed user.</para>
        @ENGLISH }}} -->
        <para>процесс <command>httpd</command> Apache, выполняемый
         под некоторым фиксированным пользователем.</para>
      </listitem>
    </itemizedlist>

    <!-- @ENGLISH {{{
    <para>The most common problem administrators run into is repository
      ownership and permissions.  Does every process (or user) in the
      previous list have the rights to read and write the Berkeley DB
      files?  Assuming you have a Unix-like operating system, a
      straightforward approach might be to place every potential
      repository user into a new <literal>svn</literal> group, and
      make the repository wholly owned by that group.  But even that's
      not enough, because a process may write to the database files
      using an unfriendly umask&mdash;one that prevents access by
      other users.</para>
    @ENGLISH }}} -->
    <para>Наиболее общией проблемой администраторов при запуске их 
      хранилищ является владение и права доступа. Каждый ли процесс (или 
      пользователь) в предыдущем списке имеет права для чтения и записи
      файлов Berkeley DB? Предположим вы имеете Unix-подобную операционную
      систему, простой подход мог заключаться в помещении каждого потенциального
      пользователя хранилища в новую группу <literal>svn</literal> и
      назначении этой группы полным владельцем хранилищае. Но даже это
      не достаточно, так как процесс может писать в файлы базы данных 
      используя не дружелюбный umask&mdash;одно это препятствует доступу 
      других пользователей.</para>

    <!-- @ENGLISH {{{
    <para>So the next step beyond setting up a common group for
      repository users is to force every repository-accessing process
      to use a sane umask.  For users accessing the repository
      directly, you can make the <command>svn</command> program into a
      wrapper script that first sets <command>umask 002</command> and
      then runs the real <command>svn</command> client program.  You
      can write a similar wrapper script for the
      <command>svnserve</command> program, and add a <command>umask
      002</command> command to Apache's own startup script,
      <filename>apachectl</filename>.  For example:</para>
    @ENGLISH }}} -->
    <para>Так что следующим шагом будет установка общей группы для пользователей
      хранилища, которая навязывает использование каждым процессом получающим доступ
      к хранилищу одно и того же umask. Для пользователей получающих доступ к 
      хранилищу напрямую, вы можете сделать обертку над программой <command>svn</command>
      которая сначала устанавливает <command>umask 002</command>, а затем
      выполняет реальную программу <command>svn</command>. Вы можете написать
      подобную обертку над <command>svn</command> и добавить команду
      <command>umask 002</command> в скрипт запуска Apache 
      <filename>apachectl</filename>. Например:</para>

    <screen>
$ cat /usr/bin/svn

#!/bin/sh

umask 002
/usr/bin/svn-real "$@"

</screen>

    <!-- @ENGLISH {{{
    <para>Another common problem is often encountered on Unix-like
      systems.  As a repository is used, Berkeley DB occasionally
      creates new log files to journal its actions.  Even if the
      repository is wholly owned by the <command>svn</command> group,
      these newly created files won't necessarily be owned by that
      same group, which then creates more permissions problems for
      your users.  A good workaround is to set the group SUID bit on
      the repository's <filename>db</filename> directory.  This causes
      all newly-created log files to have the same group owner as the
      parent directory.</para>
    @ENGLISH }}} -->
    <para>Другой общей проблемой является часто встречается на Unix-подобных
      системах. Как используется хранилище,  Berkeley DB порой создает
      новый файл лога для журналирования действий. Даже если хранилищем
      полностью владеет группа <command>svn</command>, вновь созданный 
      файл не обязательно будет принадлежать тойже группе, что в результате
      создает больше проблем с доступом для ваших пользователей. 
      Хорошим способом решения проблемы является установка бита SUID группы 
      на директорию <filename>db</filename> хранилища. В этом случае все
      вновь созданные файлы лога будут иметь владельцем туже группу, что и
      родительская директория.</para>


    <!-- @ENGLISH {{{
    <para>Once you've jumped through these hoops, your repository
      should be accessible by all the necessary processes.  It may
      seem a bit messy and complicated, but the problems of having
      multiple users sharing write-access to common files are classic
      ones that are not often elegantly solved.</para>
    @ENGLISH }}} -->
    <para>Once you've jumped through these hoops, your repository
      should be accessible by all the necessary processes.  It may
      seem a bit messy and complicated, but the problems of having
      multiple users sharing write-access to common files are classic
      ones that are not often elegantly solved.</para>

    <!-- @ENGLISH {{{
    <para>Fortunately, most repository administrators will never
      <emphasis>need</emphasis> to have such a complex configuration.
      Users who wish to access repositories that live on the same
      machine are not limited to using <literal>file://</literal>
      access URLs&mdash;they can typically contact the Apache HTTP
      server or <command>svnserve</command> using
      <literal>localhost</literal> for the server name in their
      <literal>http://</literal> or <literal>svn://</literal> URLs.
      And to maintain multiple server processes for your Subversion
      repositories is likely to be more of a headache than necessary.
      We recommend you choose the server that best meets your needs
      and stick with it!</para>
    @ENGLISH }}} -->
    <para>К счастью, большинство администраторов хранилищ вряд ли 
      будут <emphasis>нуждаться</emphasis> в такой комплексной настройке.
      Пользователи которые хотят получать доступ к хранилищам, которые
      живут на той же самой машине не ограничены в использовании доступа
      <literal>file://</literal>&mdash; они могут обычно соединяться через
      сервер HTTP Apache, или <command>svnserve</command> используя 
      <literal>localhost</literal> для имени сервера в их URL
      <literal>http://</literal> или <literal>svn://</literal>.
      И для поддержки нескольких процессов сервера для ваших хранилищ
      Subversion будет более чем достаточной головной болью. Мы 
      рекомендуем вам выбрать сервер который больше всего удовлетворяет
      вашим потребностям, и придерживаться его!</para>

    <sidebar>
     <!-- @ENGLISH {{{
      <title>The svn+ssh:// server checklist</title>
      @ENGLISH }}} -->
      <title>svn+ssh:// проверочная таблица сервера</title>

      <!-- @ENGLISH {{{
      <para>It can be quite tricky to get a bunch of users with
        existing SSH accounts to share a repository without
        permissions problems.  If you're confused about all the things
        that you (as an administrator) need to do on a Unix-like
        system, here's a quick checklist that resummarizes some of
        things discussed in this section:</para>
      @ENGLISH }}} -->
      <para>Может быть весьма не просто получить группу пользователей
        с существующими учетными записями SSH совместно использовать хранилище
        без проблем с доступом. Если вы запутались во всех этих вещах, которые
        вы (как администратор) должны делать на Unix-подобной системе, вот
        быстрый список, который суммирует некоторые из вещей обсуждаемых в 
        в этом разделе:</para>

      <itemizedlist>
        <listitem>
          <!-- @ENGLISH {{{
          <para>All of your SSH users need to be able to read and
            write to the repository.  Put all the SSH users into a
            single group.  Make the repository wholly owned by that
            group, and set the group permissions to read/write.</para>
          @ENGLISH }}} -->
          <para>Все ваши пользователи SSH нуждаются в возможности
            чтения и записи в хранилище. Поместите всех пользователей
            SSH  в одну группу.  Сделайте эту группу полным владельцем 
            хранилища, и установите права группы на запись и чтение.</para>

        </listitem>

        <listitem>
          <!-- @ENGLISH {{{
          <para>Your users need to use a sane umask when accessing the
            repository.  Make sure that <command>svnserve</command>
            (<filename>/usr/bin/svnserve</filename>, or wherever
            it lives in <literal>$PATH</literal>) is actually a
            wrapper script which sets <command>umask 002</command> and
            executes the real <command>svnserve</command>
            binary.  Take similar measures when using
            <command>svnlook</command> and
            <command>svnadmin</command>.  Either run them with a sane
            umask, or wrap them as described above.</para>
          @ENGLISH }}} -->
          <para>Ваши пользователи нуждаются в использовании нормального
            umask когда получают доступ к хранилищу. Убедитесь что 
            <command>svnserve</command> ((<filename>/usr/bin/svnserve</filename>)
            или расположенный в другом месте в <literal>$PATH</literal>)
            в данный момент обернут скриптом, который устанавливает
            <command>umask 002</command> и выполняет программу
<command>svnserve</command>. Сделайте подобные мероприятия когда 
            используете <command>svnlook</command> и
            <command>svnadmin</command>.  Либо запускайте их с нормальным
            umask или оберните их как описанно выше.</para>
        </listitem>
      </itemizedlist>

    </sidebar>

  </sect1>




</chapter>

<!--
local variables:
sgml-parent-document: ("book.xml" "chapter")
end:
vim: tw=78:ft=svnbook 

-->
     
