<?xml version="1.0" encoding="UTF-8"?>
<chapter id="svn.basic">

  <!-- @ENGLISH {{{
  <title>Basic Concepts</title>
  @ENGLISH }}} -->
  <title>Основные понятия</title>
  <chapterinfo>
    <!-- See also svn.preface.organization -->
    <othername id="svn.basic.accusative-case" role="title-variant">главу
      2, &laquo;Основные понятия&raquo;</othername>
  </chapterinfo>

  <simplesect>
    <!-- @ENGLISH {{{
    <para>This chapter is a short, casual introduction to Subversion.
      If you're new to version control, this chapter is definitely for
      you.  We begin with a discussion of general version control
      concepts, work our way into the specific ideas behind
      Subversion, and show some simple examples of Subversion in
      use.</para>
    @ENGLISH }}} -->
    <para>Эта глава представляет собой краткое, промежуточное введение
      в Subversion. Если контроль версий для вас в новинку, то эта глава
      специально для вас. Мы начнем с обсуждения основных понятий
      контроля версий, подойдем к основным идеям, лежащим в основе Subversion
      и покажем несколько простых примеров использования Subversion.</para>

    <!-- @ENGLISH {{{
    <para>Even though the examples in this chapter show people sharing
      collections of program source code, keep in mind that Subversion
      can manage any sort of file collection&mdash;it's not limited to
      helping computer programmers.</para>
    @ENGLISH }}} -->
    <para>Несмотря на то, что примеры в этой главе показывают людей
      делящих между собой набор исходников программы, помните, что
      Subversion может управлять набором файлов любого типа &mdash; она не
      ограничивается помощью компьютерным программистам.</para>
  </simplesect>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.repository">
    <!-- @ENGLISH {{{
    <title>The Repository</title>
    @ENGLISH }}} -->
    <title>Хранилище</title>

    <!-- @ENGLISH {{{
    <para>Subversion is a centralized system for sharing information.
      At its core is a repository, which is a central store of data.
      The repository stores information in the form of a
      <firstterm>filesystem tree</firstterm>&mdash;a typical hierarchy
      of files and directories.  Any number of
      <firstterm>clients</firstterm> connect to the repository, and
      then read or write to these files.  By writing data, a client
      makes the information available to others; by reading data, the
      client receives information from others.  <xref
      linkend="svn.basic.repository.dia-1"/> illustrates this.</para>
    @ENGLISH }}} -->
    <para>Subversion является централизованной системой для разделения
      информации. В ее основе хранилище, являющееся центром хранения
      данных. Хранилище хранит информацию в форме
      <firstterm>дерева файлов</firstterm> &mdash; типичном
      представлении файлов и каталогов. Любое количество
      <firstterm>клиентов</firstterm> подключается к хранилищу и
      читает или записывает эти файлы. Записывая данные, клиент
      делает информацию доступной для остальных; читая данные
      клиент получает информацию от других. <xref
      linkend="svn.basic.repository.dia-1"/> иллюстрирует это.</para>

    <figure id="svn.basic.repository.dia-1">
      <!-- @ENGLISH {{{
      <title>A typical client/server system</title>
      @ENGLISH }}} -->
      <title>Типичная клиент/серверная система</title>
      <graphic fileref="images/ch02dia1.png"/>
    </figure>

    <!-- @ENGLISH {{{
    <para>So why is this interesting?  So far, this sounds like the
      definition of a typical file server.  And indeed, the repository
      <emphasis>is</emphasis> a kind of file server, but it's not your
      usual breed.  What makes the Subversion repository special is
      that <emphasis>it remembers every change</emphasis> ever written
      to it: every change to every file, and even changes to the
      directory tree itself, such as the addition, deletion, and
      rearrangement of files and directories.</para>
    @ENGLISH }}} -->
    <para>Почему мы заостряем на этом внимание? Пока это звучит как
      определение типичного файл-сервера. И действительно, хранилище
      <emphasis>является</emphasis> разновидностью файл-сервера, однако не
      совсем обычного. Что делает хранилище Subversion особенным &mdash; это то,
      что он <emphasis>запоминает каждое внесенное изменение</emphasis>:
      любое изменение любого файла, равно как изменения в самом дереве
      каталогов, такие как добавление, удаление и реорганизация файлов и
      каталогов.</para>

    <!-- @ENGLISH {{{
    <para>When a client reads data from the repository, it normally
      sees only the latest version of the filesystem tree.  But the
      client also has the ability to view
      <emphasis>previous</emphasis> states of the filesystem.  For
      example, a client can ask historical questions like, <quote>What
      did this directory contain last Wednesday?</quote> or <quote>Who
      was the last person to change this file, and what changes did
      he make?</quote> These are the sorts of questions that are at
      the heart of any <firstterm>version control system</firstterm>:
      systems that are designed to record and track changes to data
      over time.
    </para>
    @ENGLISH }}} -->
    <para>При чтении данных из хранилища клиент обычно видит только
      последнюю версию дерева файлов. Но клиент также имеет возможность
      просмотреть <emphasis>предыдущие</emphasis> состояния файловой системы.
      Например, клиент может запросить такие данные как, <quote>Что
      содержал этот каталог в прошлую среду?</quote> или <quote>Кто
      был последним изменявшим этот файл и какие вносились изменения?</quote>
      Вопросы подобного типа основные для любой <firstterm>системы
      контроля версий</firstterm>: системы разработанной для записи и
      отслеживания изменений информации во времени.
    </para>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.vsn-models">
    <!-- @ENGLISH {{{
    <title>Versioning Models</title>
    @ENGLISH }}} -->
    <title>Модели версионирования</title>

    <!-- @ENGLISH {{{
    <para>The core mission of a version control system is to enable
      collaborative editing and sharing of data.  But different
      systems use different strategies to achieve this.</para>
    @ENGLISH }}} -->
    <para>Основной задачей системы управления версиями является
      обеспечение совместного редактирования и распределения информации.
      Однако разные системы используют разные способы для
      достижения этого.</para>

    <!-- =============================================================== -->
    <!-- =============================================================== -->
    <sect2 id="svn.basic.vsn-models.problem-sharing">
      <!-- @ENGLISH {{{
      <title>The Problem of File-Sharing</title>
      @ENGLISH }}} -->
      <title>Проблема разделения файлов</title>

      <!-- @ENGLISH {{{
      <para>All version control systems have to solve the same
        fundamental problem: how will the system allow users to share
        information, but prevent them from accidentally stepping on
        each other's feet?  It's all too easy for users to
        accidentally overwrite each other's changes in the
        repository.</para>
      @ENGLISH }}} -->
      <para>Всем системам контроля версий приходится решать одну и ту же
        основную проблему: как предоставить пользователям возможность
        совместного использования информации, при этом, не позволяя им
        наступать друг другу на пятки? Пользователи могут просто
        непреднамеренно перезаписать в хранилище изменения друг
        друга.</para>

      <!-- @ENGLISH {{{
      <para>Consider the scenario shown in <xref
        linkend="svn.basic.vsn-models.problem-sharing.dia-1"/>.
        Suppose we have two co-workers, Harry and Sally.  They each
        decide to edit the same repository file at the same time.  If
        Harry saves his changes to the repository first, then it's
        possible that (a few moments later) Sally could accidentally
        overwrite them with her own new version of the file.  While
        Harry's version of the file won't be lost forever (because the
        system remembers every change), any changes Harry made
        <emphasis>won't</emphasis> be present in Sally's newer version
        of the file, because she never saw Harry's changes to begin
        with.  Harry's work is still effectively lost&mdash;or at
        least missing from the latest version of the file&mdash;and
        probably by accident.  This is definitely a situation we want
        to avoid!</para>
      @ENGLISH }}} -->
      <para>Рассматриваемую ситуацию иллюстрирует <xref
        linkend="svn.basic.vsn-models.problem-sharing.dia-1"/>.
        Допустим у нас есть два
        со-разработчика Гарри и Салли. Они вдвоем решили
        одновременно поредактировать один и тот же файл из хранилища.
        Если первым свои изменения в хранилище сохранит Гарри, то
        возможно, что (несколькими минутами позже) Салли может
        непреднамеренно перезаписать их своей новой версией файла.
        Несмотря на то, что версия файла Гарри не будет полностью потеряна
        (так как система помнит каждое изменение) внесенные Гарри изменения
        <emphasis>не будут </emphasis>отражены в новой версии файла Сэлли,
        потому что, начиная, она, не видела изменения Гарри. Работа Гарри
        фактически потеряна &mdash; или, по крайней мере, отсутствует в
        последней версии файла &mdash; по случайности. Как раз этой ситуации
        мы и хотим избежать!</para>

      <figure id="svn.basic.vsn-models.problem-sharing.dia-1">
        <title>Проблема потери изменений</title>
        <graphic fileref="images/ch02dia2.png"/>
      </figure>

      </sect2>

    <!-- =============================================================== -->
    <!-- =============================================================== -->
    <sect2 id="svn.basic.vsn-models.lock-unlock">
      <!-- @ENGLISH {{{
      <title>The Lock-Modify-Unlock Solution</title>
      @ENGLISH }}} -->
      <title>Модель Блокирование-Изменение-Разблокирование</title>

      <!-- @ENGLISH {{{
      <para>Many version control systems use a
        <firstterm>lock-modify-unlock</firstterm> model to address the
        problem of many authors clobbering each other's work.  In this
        model, the repository allows only one person to change a file
        at a time.  This exclusivity policy is managed using locks.
        Harry must <quote>lock</quote> a file before he can begin
        making changes to it.  If Harry has locked a file, then Sally
        cannot also lock it, and therefore cannot make any changes to
        that file.  All she can do is read the file, and wait for
        Harry to finish his changes and release his lock.  After Harry
        unlocks the file, Sally can take her turn by locking and
        editing the file.  <xref
        linkend="svn.basic.vsn-models.lock-unlock.dia-1"/>
        demonstrates this simple solution.</para>
      @ENGLISH }}} -->
      <para>Для того, что бы несколько авторов не мешало друг другу
        многие системы управления версиями применяют модель
        <firstterm>блокирование-изменение-разблокирование</firstterm>.
        Эта модель запрещает одновременное редактирование файла несколькими
        пользователями. Эксклюзивность доступа гарантируется блокировками.
        Перед началом редактирования Гарри должен <quote>заблокировать</quote>
        файл. Если файл заблокировал Гарри, Салли уже не сможет
        его заблокировать и не сможет внести в него изменения.
        Ей остается только читать файл и ждать пока Гарри закончит свои
        изменения и снимет свою блокировку. После того как Гарри разблокирует
        файл, файл сможет получить Салли, заблокировать его и начать
        редактирование. <xref
        linkend="svn.basic.vsn-models.lock-unlock.dia-1"/>
        демонстрирует это простое решение.</para>

      <figure id="svn.basic.vsn-models.lock-unlock.dia-1">
        <!-- @ENGLISH {{{
        <title>The lock-modify-unlock solution</title>
        @ENGLISH }}} -->
        <title>Модель блокирование-изменение-разблокирование</title>
        <graphic fileref="images/ch02dia3.png"/>
      </figure>

      <!-- @ENGLISH {{{
      <para>The problem with the lock-modify-unlock model is that it's
        a bit restrictive, and often becomes a roadblock for
        users:</para>
      @ENGLISH }}} -->
      <para>Проблемой модели блокирование-изменение-разблокирование
        является то, что она немного ограниченная и часто доставляет
        неудобства пользователям:</para>

      <itemizedlist>
        <listitem>
          <!-- @ENGLISH {{{
          <para><emphasis>Locking may cause administrative
            problems.</emphasis>

            Sometimes Harry will lock a file and then forget about it.
            Meanwhile, because Sally is still waiting to edit the file,
            her hands are tied.  And then Harry goes on vacation.  Now
            Sally has to get an administrator to release Harry's lock.
            The situation ends up causing a lot of unnecessary delay
            and wasted time.
          @ENGLISH }}} -->
          <para><emphasis>Блокирование может вызвать проблемы
            администрирования.</emphasis>

            Иногда Гарри заблокирует файл, а затем забудет об этом.
            Между тем, ожидая редактирования файла, у Салли будут
            связаны руки. А Гарри уехал в отпуск. Теперь Салли,
            для снятия блокировки Гарри, нужно обращаться к администратору.
            Ситуация заканчивается не нужной задержкой и потерянным
            временем.</para>
        </listitem>

        <listitem>
          <!-- @ENGLISH {{{
          <para><emphasis>Locking may cause unnecessary
            serialization.</emphasis>

            What if Harry is editing the beginning of a text file,
            and Sally simply wants to edit the end of the same file?
            These changes don't overlap at all.  They could easily
            edit the file simultaneously, and no great harm would
            come, assuming the changes were properly merged together.
            There's no need for them to take turns in this
            situation.</para>
          @ENGLISH }}} -->
          <para><emphasis>Блокирование может вызвать излишнюю
            пошаговость.</emphasis>

            Что если Гарри редактирует начало текстового файла, а Салли нужно
            отредактировать концовку этого же файла? Эти изменения совсем не
            перекрываются. Они могли бы легко редактировать файл одновременно
            и никаких особенных проблем это не вызвало бы, предполагая
            корректное слияние изменений. Блокирование файла в такой ситуации
            не требуется.</para>
        </listitem>

        <listitem>
          <!-- @ENGLISH {{{
          <para><emphasis>Locking may create a false sense of
            security.</emphasis>

            Pretend that Harry locks and edits file A, while
            Sally simultaneously locks and edits file B.  But suppose
            that A and B depend on one another, and the changes made
            to each are semantically incompatible.  Suddenly A and B
            don't work together anymore.  The locking system was
            powerless to prevent the problem&mdash;yet it somehow
            provided a false sense of security.  It's easy for Harry and
            Sally to imagine that by locking files, each is beginning a
            safe, insulated task, and thus not bother
            discussing their incompatible changes early
            on.</para>
          @ENGLISH }}} -->
          <para><emphasis>Блокирование может вызвать ложное чувство
            безопасности.</emphasis>

            Предположим, что Гарри блокирует и редактирует файл А, в
            то время как Салли одновременно блокирует и редактирует
            файл В. Но допустим, что А и В зависят друг от друга и
            сделанные в каждом изменения семантически не совместимы.
            Неожиданно А и В больше не работают вместе. Блокирующая система
            бессильна в предотвращении проблемы &mdash; вместо этого она
            обеспечила ложное чувство безопасности. Для Гарри и Салли
            просто вообразить, что, блокируя файлы каждый начинает безопасную
            изолированную задачу и не беспокоиться в начале об обсуждении их
            несовместимых изменений.</para>
        </listitem>
      </itemizedlist>

      </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.vsn-models.copy-merge">
      <!-- @ENGLISH {{{
      <title>The Copy-Modify-Merge Solution</title>
      @ENGLISH }}} -->
      <title>Модель Копирование-Изменение-Слияние</title>

      <!-- @ENGLISH {{{
      <para>Subversion, CVS, and other version control systems use a
        <firstterm>copy-modify-merge</firstterm> model as an
        alternative to locking.  In this model, each user's client
        contacts the project repository and creates a personal
        <firstterm>working copy</firstterm>&mdash;a local reflection
        of the repository's files and directories.  Users then work in
        parallel, modifying their private copies.  Finally, the
        private copies are merged together into a new, final version.
        The version control system often assists with the merging, but
        ultimately a human being is responsible for making it happen
        correctly.</para>
      @ENGLISH }}} -->
      <para>Subversion, CVS и другие системы управления версиями
        пользуются моделью
        <firstterm>копирование-изменение-слияние</firstterm> в качестве
        альтернативы блокированию. В этой модели каждый пользовательский
        клиент связывается с хранилищем проекта и создает персональную
        <firstterm>рабочую копию</firstterm> &mdash; локальное отражение
        файлов и каталогов хранилища. После этого пользователи работают
        параллельно, изменяя свои личные копии. В конце концов, личные копии
        сливаются в новую, финальную версию. Обычно система управления
        версиями помогает в слиянии, но, разумеется, за его корректное
        выполнение отвечает человек.</para>

      <!-- @ENGLISH {{{
      <para>Here's an example.  Say that Harry and Sally each create
        working copies of the same project, copied from the
        repository.  They work concurrently, and make changes to the
        same file A within their copies.  Sally saves her changes to
        the repository first.  When Harry attempts to save his changes
        later, the repository informs him that his file A is
        <firstterm>out-of-date</firstterm>.  In other words, that file
        A in the repository has somehow changed since he last copied
        it.  So Harry asks his client to <firstterm>merge</firstterm>
        any new changes from the repository into his working copy of
        file A.  Chances are that Sally's changes don't overlap with
        his own; so once he has both sets of changes integrated, he
        saves his working copy back to the repository.  <xref
        linkend="svn.basic.vsn-models.copy-merge.dia-1"/> and <xref linkend="svn.basic.vsn-models.copy-merge.dia-2"/>
        show this process.</para>
      @ENGLISH }}} -->
      <para>Вот пример. Скажем и Гарри и Салли создали копированием из
        хранилища рабочие копии одного и того же проекта. Они работают
        одновременно и в своих рабочих копиях вносят изменения в один и
        тот же файл А. Первой свои изменения в хранилище сохраняет
        Салли. Когда позже Гарри попытается сохранить свои изменения,
        хранилище проинформирует его о том, что его файл А
        <firstterm>устарел</firstterm>. Другими словами, файл А каким
        то образом изменился со времени, когда он его последний раз
        копировал. Поэтому Гарри просит свой клиент
        <firstterm>слить</firstterm> любые изменения из хранилища
        в его рабочую копию файла А. По счастливому совпадению,
        изменения Салли не перекрываются с его собственными; после
        объединения обоих наборов изменений он сохраняет свою рабочую копию
        обратно в хранилище. <xref
        linkend="svn.basic.vsn-models.copy-merge.dia-1"/> и
        <xref linkend="svn.basic.vsn-models.copy-merge.dia-2"/>
        показывают этот процесс.</para>

      <figure id="svn.basic.vsn-models.copy-merge.dia-1">
        <!-- @ENGLISH {{{
        <title>The copy-modify-merge solution</title>
        @ENGLISH }}} -->
        <title>Модель копирование-изменение-слияние</title>
        <graphic fileref="images/ch02dia4.png"/>
      </figure>

      <figure id="svn.basic.vsn-models.copy-merge.dia-2">
        <!-- @ENGLISH {{{
        <title>The copy-modify-merge solution (continued)</title>
        @ENGLISH }}} -->
        <title>Модель копирование-изменение-слияние (продолжение)</title>
        <graphic fileref="images/ch02dia5.png"/>
      </figure>

      <!-- @ENGLISH {{{
      <para>But what if Sally's changes <emphasis>do</emphasis> overlap
        with Harry's changes?  What then?  This situation is called a
        <firstterm>conflict</firstterm>, and it's usually not much of
        a problem.  When Harry asks his client to merge the latest
        repository changes into his working copy, his copy of file A
        is somehow flagged as being in a state of conflict: he'll be
        able to see both sets of conflicting changes, and manually
        choose between them.  Note that software can't automatically
        resolve conflicts; only humans are capable of understanding
        and making the necessary intelligent choices.  Once Harry has
        manually resolved the overlapping changes&mdash;perhaps after
        a discussion with Sally&mdash;he can safely save the
        merged file back to the repository.</para>
      @ENGLISH }}} -->
      <para>А что если изменения Салли перекрываются с
        <emphasis>изменениями</emphasis> Гарри? Что тогда? Эта ситуация
        называется <firstterm>конфликтом</firstterm> и, как правило, это не
        является большой проблемой. Когда Гарри просит свой клиент слить
        последние изменения хранилища в рабочую копию, его копия файла А
        как-то помечается как находящаяся в состоянии конфликта: у него будет
        возможность видеть оба набора конфликтующих изменений и вручную
        сделать между ними выбор. Помните, что ПО не может автоматически
        разрешать конфликты; только человек способен к пониманию и выполнению
        осмысленного выбора. Разрешив вручную перекрывающиеся изменения -
        возможно, после обсуждения с Салли &mdash; он может безопасно сохранить
        объединенный файл обратно в хранилище.</para>

      <!-- @ENGLISH {{{
      <para>The copy-modify-merge model may sound a bit chaotic, but
        in practice, it runs extremely smoothly.  Users can work in
        parallel, never waiting for one another.  When they work on
        the same files, it turns out that most of their concurrent
        changes don't overlap at all; conflicts are infrequent.  And
        the amount of time it takes to resolve conflicts is far less
        than the time lost by a locking system.</para>
      @ENGLISH }}} -->
      <para>Модель копирование-изменение-слияние может выглядеть немного
        хаотично, однако, на практике она отлично работает. Пользователи могут
        работать параллельно, не тратя время на ожидание друг друга. При
        работе над одними и теми же файлами оказывается, что большинство
        параллельно вносимых изменений совсем не перекрываются; конфликты
        бывают редко. И время, которое было потрачено на разрешение
        конфликтов значительно меньше времени отнимаемого блокирующей
        системой.</para>

      <!-- @ENGLISH {{{
      <para>In the end, it all comes down to one critical factor: user
        communication.  When users communicate poorly, both syntactic
        and semantic conflicts increase.  No system can force users to
        communicate perfectly, and no system can detect semantic
        conflicts.  So there's no point in being lulled into a false
        promise that a locking system will somehow prevent conflicts;
        in practice, locking seems to inhibit productivity more than
        anything else.</para>
      @ENGLISH }}} -->
      <para>Наконец, все сходится к такому критическому фактору, как
        взаимодействие пользователей. При плохом взаимопонимании увеличивается
        количество как синтаксических, так и семантических конфликтов.
        Нет системы, которая может повысить уровень взаимопонимания, и нет
        системы, которая может определять семантические конфликты. Не стоит
        возлагать большие надежды на то, что блокирующая система лучше
        защищена от конфликтов; на практике блокирование снижает
        продуктивность как ничто другое.</para>

      <sidebar id="svn.basic.vsn-models.copy-merge.sb-1">
        <!-- @ENGLISH {{{
        <title>When Locking is Necessary</title>
        @ENGLISH }}} -->
        <title>Когда блокирование необходимо</title>

        <!-- @ENGLISH {{{
        <para>While the lock-modify-unlock model is considered
          generally harmful to collaboration, there are still times
          when locking is appropriate.</para>
        @ENGLISH }}} -->
        <para>Несмотря на то, что модель
          блокирование-изменение-разблокирование названа, в целом, губительной
          для командной работы, все-таки есть моменты когда блокирование
          уместно.</para>

        <!-- @ENGLISH {{{
        <para>The copy-modify-merge model is based on the assumption
          that files are contextually mergeable: that is, that the
          majority of the files in the repository are line-based text
          files (such as program source code).  But for files with
          binary formats, such as artwork or sound, it's often
          impossible to merge conflicting changes.  In these
          situations, it really is necessary to users to take strict
          turns when changing the file.  Without serialized access,
          somebody ends up wasting time on changes that are ultimately
          discarded.</para>
        @ENGLISH }}} -->
        <para>Модель копирование-изменение-слияние основывается на
          предположении о том, что файлы контекстно-объединяемы: это так
          если большинство файлов в хранилище &mdash;
          текстовые файлы (например исходный код программы). Но для файлов
          бинарных форматов, таких как графические или звуковые, как правило
          не возможно объединить конфликтующие изменения. В таких ситуациях
          пользователям действительно необходимо быть внимательными при
          изменении файла. Без раздельного доступа кто-то может впустую
          потратить время на изменения, которые в конце концов
          будут потеряны.</para>

        <!-- @ENGLISH {{{
        <para>While CVS and Subversion are still primarily
          copy-modify-merge systems, they both recognize the need to
          lock an occasional file and provide mechanisms for this.
          See <xref linkend="svn.advanced.locking"/>.</para>
        @ENGLISH }}} -->
        <para>Так как и CVS, и Subversion, &mdash; в первую очередь системы типа
          копирование-изменение-слияние, то в них обоих признается необходимость
          блокирования определенных файлов и предлагаются механизмы для
          этого. См. <xref linkend="svn.advanced.locking"/>.</para>

      </sidebar>


    </sect2>

  </sect1>

  <!-- How svn implements the philosophy -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.in-action">
    <!-- @ENGLISH {{{
    <title>Subversion in Action</title>
    @ENGLISH }}} -->
    <title>Subversion в действии</title>

    <!-- @ENGLISH {{{
    <para>It's time to move from the abstract to the concrete.  In
      this section, we'll show real examples of Subversion being
      used.</para>
    @ENGLISH }}} -->
    <para>Настало время перейти от абстракций к конкретике. В этом разделе мы покажем
      реальные примеры использования Subversion.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.wc">
      <!-- @ENGLISH {{{
      <title>Working Copies</title>
      @ENGLISH }}} -->
      <title>Рабочие копии</title>

      <!-- @ENGLISH {{{
      <para>You've already read about working copies; now we'll
        demonstrate how the Subversion client creates and uses
        them.</para>
      @ENGLISH }}} -->
      <para>Вы уже читали о рабочих копиях; теперь мы покажем как
        Subversion-клиент создает и использует их.</para>

      <!-- @ENGLISH {{{
      <para>A Subversion working copy is an ordinary directory tree on
        your local system, containing a collection of files.  You can
        edit these files however you wish, and if they're source code
        files, you can compile your program from them in the usual
        way.  Your working copy is your own private work area:
        Subversion will never incorporate other people's changes, nor
        make your own changes available to others, until you
        explicitly tell it to do so.  You can even have multiple
        working copies of the same project.</para>
      @ENGLISH }}} -->
      <para>Рабочая копия Subversion представляет собой обычное дерево
        каталогов на вашем компьютере, содержащее набор файлов. Вы можете
        по-своему усмотрению редактировать эти файлы и, если это исходные коды,
        вы можете обычным способом скомпилировать программу. Ваша рабочая
        копия это ваше личное рабочее пространство: Subversion как не
        смешивает вносимые другими изменения с вашими, так и не делает
        доступными для других изменения сделанные вами, пока вы не
        прикажете сделать это. Вы даже можете иметь несколько рабочих копий
	одного и того же проекта.</para>

      <!-- @ENGLISH {{{
      <para>After you've made some changes to the files in your
        working copy and verified that they work properly, Subversion
        provides you with commands to <quote>publish</quote> your
        changes to the other people working with you on your project
        (by writing to the repository).  If other people publish their
        own changes, Subversion provides you with commands to merge
        those changes into your working directory (by reading from the
        repository).</para>
      @ENGLISH }}} -->
      <para>После того, как вы внесли изменения в файлы вашей рабочей копии и
        убедились в том, что они корректно работают, Subversion предлагает вам
        команды <quote>публикации</quote> (записи в хранилище) ваших
        изменений, в результате чего они станут доступными для всех участников
        проекта. Если другие участники проекта опубликовали свои изменения,
        Subversion предлагает вам команды для объединения (путем чтения
        информации из хранилища) этих изменений с вашей рабочей
        копией.</para>

      <!-- @ENGLISH {{{
      <para>A working copy also contains some extra files, created and
        maintained by Subversion, to help it carry out these commands.
        In particular, each directory in your working copy contains a
        subdirectory named <filename>.svn</filename>, also known as
        the working copy <firstterm>administrative
        directory</firstterm>.  The files in each administrative
        directory help Subversion recognize which files contain
        unpublished changes, and which files are out-of-date with
        respect to others' work.</para>
      @ENGLISH }}} -->
      <para>Рабочая копия содержит несколько дополнительных файлов, созданных
        и обслуживаемых Subversion, которые помогают ей при выполнении этих
        команд. В частности, каждый каталог в вашей рабочей копии содержит
        подкаталог с именем <filename>.svn</filename> который называется
        <firstterm>служебным каталогом</firstterm> рабочей копии.
        Файлы в служебном каталоге помогают Subversion определить
        какие файлы рабочей копии содержат неопубликованные изменения, и какие
        файлы устарели по отношению к файлам других участников.</para>

      <!-- @ENGLISH {{{
      <para>A typical Subversion repository often holds the files (or
        source code) for several projects; usually, each project is a
        subdirectory in the repository's filesystem tree.  In this
        arrangement, a user's working copy will usually correspond to
        a particular subtree of the repository.</para>
      @ENGLISH }}} -->
      <para>Как правило, хранилище Subversion содержит файлы (или исходный
        код) нескольких проектов; обычно каждый проект представляется в виде
        подкаталога файловой системы хранилища. При таком подходе,
        пользовательская рабочая копия обычно соответствует отдельному
        подкаталогу хранилища.</para>

      <!-- @ENGLISH {{{
      <para>For example, suppose you have a repository that contains
        two software projects, <literal>paint</literal> and
        <literal>calc</literal>.  Each project lives in its own
        top-level subdirectory, as shown in <xref
        linkend="svn.basic.in-action.wc.dia-1"/>.</para>
      @ENGLISH }}} -->
      <para>Например, предположим, что у вас есть хранилище, содержащее два
        программных проекта: <literal>paint</literal> и
        <literal>calc</literal>. Каждый проект располагается в своем
        собственном каталоге, как показано на
        <xref linkend="svn.basic.in-action.wc.dia-1"/>.</para>

      <figure id="svn.basic.in-action.wc.dia-1">
        <!-- @ENGLISH {{{
        <title>The repository's filesystem</title>
        @ENGLISH }}} -->
        <title>Файловая система хранилища</title>
        <graphic fileref="images/ch02dia6.png"/>
      </figure>

      <!-- @ENGLISH {{{
      <para>To get a working copy, you must <firstterm>check
        out</firstterm> some subtree of the repository.  (The term
        <quote>check out</quote> may sound like it has something to do
        with locking or reserving resources, but it doesn't; it simply
        creates a private copy of the project for you.) For example,
        if you check out <filename>/calc</filename>, you will get a
        working copy like this:</para>
      @ENGLISH }}} -->
      <para>Для того чтобы создать рабочую копию, вам нужно
        <firstterm>получить</firstterm> какую-либо из подкаталогов
        хранилища. (Возможно, термин <firstterm>получить</firstterm>
        звучит как что-то связанное с блокированием или резервированием
        ресурсов, но это не так; эта команда просто создает для вас личную
        копию проекта.) Например, если вы получите
        <filename>/calc</filename>, у вас будет рабочая копия, наподобие
        этой:</para>

      <screen>
$ svn checkout http://svn.example.com/repos/calc
A    calc/Makefile
A    calc/integer.c
A    calc/button.c
Checked out revision 56.

$ ls -A calc
Makefile  integer.c  button.c  .svn/
</screen>

      <!-- @ENGLISH {{{
      <para>The list of letter A's indicates that Subversion is adding
        a number of items to your working copy.  You now have a
        personal copy of the repository's <filename>/calc</filename>
        directory, with one additional
        entry&mdash;<filename>.svn</filename>&mdash;which holds the
        extra information needed by Subversion, as mentioned
        earlier.</para>
      @ENGLISH }}} -->
      <para>Буквы А говорят о том, что Subversion добавил этот элемент в
        вашу рабочую копию. Теперь у вас есть личная копия каталога
        <filename>/calc</filename> хранилища, с одним небольшим добавлением
        &mdash; каталогом <filename>.svn</filename>, содержащим, как было
        указано выше, дополнительную информацию, необходимую Subversion.</para>

      <sidebar id="svn.basic.in-action.wc.sb-1">
        <!-- @ENGLISH {{{
        <title>Repository URLs</title>
        @ENGLISH }}} -->
        <title>URL хранилища</title>

        <!-- @ENGLISH {{{
        <para>Subversion repositories can be accessed through many
          different methods&mdash;on local disk, or through various
          network protocols.  A repository location, however, is
          always a URL.  <xref linkend="svn.basic.in-action.wc.tbl-1"/> describes how
          different URL schemas map to the available access methods.</para>
        @ENGLISH }}} -->
        <para>Получить доступ к хранилищу Subversion можно различными
          способами &mdash; на локальном диске или через ряд сетевых протоколов.
          Местоположение хранилища всегда определяется при помощи URL.
          Таблица <xref linkend="svn.basic.in-action.wc.tbl-1"/>
          показывает соответствие разных URL-схем возможным
          методам доступа.</para>

        <table id="svn.basic.in-action.wc.tbl-1">
          <!-- @ENGLISH {{{
          <title>Repository Access URLs</title>
          @ENGLISH }}} -->
          <title>URL для доступа к хранилищу.</title>
          <tgroup cols="2">
            <thead>
              <row>
                <!-- @ENGLISH {{{
                <entry>Schema</entry>
                <entry>Access Method</entry>
                @ENGLISH }}} -->
                <entry>Схема</entry>
                <entry>Метод доступа</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><literal>file:///</literal></entry>
                <!-- @ENGLISH {{{
                <entry>direct repository access (on local disk)</entry>
                @ENGLISH }}} -->
                <entry>прямой доступ к хранилищу
                  (на локальном диске)</entry>
              </row>
              <row>
                <entry><literal>http://</literal></entry>
                <!-- @ENGLISH {{{
                <entry>access via WebDAV protocol to Subversion-aware
                  Apache server</entry>
                @ENGLISH }}} -->
                <entry>доступ через протокол WebDAV (если Subversion-сервер
                работает через Apache)</entry>
              </row>
              <row>
                <entry><literal>https://</literal></entry>
                <!-- @ENGLISH {{{
                <entry>same as <literal>http://</literal>, but with
                  SSL encryption.</entry>
                @ENGLISH }}} -->
                <entry>тоже что и <literal>http://</literal> но с
                  SSL-шифрованием</entry>
              </row>
              <row>
                <entry><literal>svn://</literal></entry>
                <!-- @ENGLISH {{{
                <entry>access via custom protocol to an
                  <literal>svnserve</literal> server</entry>
                @ENGLISH }}} -->
                <entry>доступ через собственный протокол к серверу
                  <literal>svnserve</literal></entry>
              </row>
              <row>
                <entry><literal>svn+ssh://</literal></entry>
                <!-- @ENGLISH {{{
                <entry>same as <literal>svn://</literal>, but through
                  an SSH tunnel.</entry>
                @ENGLISH }}} -->
                <entry>тоже что и <literal>svn://</literal>, но через
                  SSH-соединение</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <!-- @ENGLISH {{{
        <para>For more information on how Subversion parses URLs, see
        <xref linkend="svn.advanced.reposurls"/>.</para>
        @ENGLISH }}} -->
        <para>Подробнее о том, как Subversion обрабатывает URL, см. в
          <xref linkend="svn.advanced.reposurls"/>.</para>

      </sidebar>

      <!-- @ENGLISH {{{
      <para>Suppose you make changes to <filename>button.c</filename>.
        Since the <filename>.svn</filename> directory remembers the
        file's modification date and original contents, Subversion can
        tell that you've changed the file.  However, Subversion does
        not make your changes public until you explicitly tell it to.
        The act of publishing your changes is more commonly known as
        <firstterm>committing</firstterm> (or <firstterm>checking
        in</firstterm>) changes to the repository.</para>
      @ENGLISH }}} -->
      <para>Предположим, вы внесли изменения в <filename>button.c</filename>.
        Так как каталог <filename>.svn</filename> помнит дату изменения
        файла и его оригинальное содержимое, Subversion может сказать о том,
        что вы изменили файл. Subversion не публикует ваших изменений пока
        вы не прикажете это сделать. Публикация ваших изменений более известна
        как <firstterm>фиксация</firstterm> (или <firstterm>checking
        in</firstterm>) изменений в хранилище.</para>

      <!-- @ENGLISH {{{
      <para>To publish your changes to others, you can use
        Subversion's <command>commit</command> command:</para>
      @ENGLISH }}} -->
      <para>Для того, что бы опубликовать ваши изменения вы можете
        воспользоваться командой <command>commit</command>:</para>

      <screen>
$ svn commit button.c
Sending        button.c
Transmitting file data .
Committed revision 57.
</screen>

      <!-- @ENGLISH {{{
      <para>Now your changes to <filename>button.c</filename> have
        been committed to the repository; if another user checks out a
        working copy of <filename>/calc</filename>, they will see
        your changes in the latest version of the file.</para>
      @ENGLISH }}} -->
      <para>Теперь ваши изменения в <filename>button.c</filename>
        зафиксированы в хранилище; если другой пользователь
        создаст рабочую копию <filename>/calc</filename>, он увидит
        ваши изменения в последней версии файла.</para>

      <!-- @ENGLISH {{{
      <para>Suppose you have a collaborator, Sally, who checked out a
        working copy of <filename>/calc</filename> at the same time
        you did.  When you commit your change to
        <filename>button.c</filename>, Sally's working copy is left
        unchanged; Subversion only modifies working copies at the
        user's request.</para>
      @ENGLISH }}} -->
      <para>Предположим, у вас есть партнер, Салли, которая
        создала рабочую копию <filename>/calc</filename> одновременно
        с вами. Когда вы зафиксировали изменения в
        <filename>button.c</filename>, рабочая копия Салли осталась не
        измененной; Subversion модифицирует рабочие копии только
        по запросу пользователей.</para>

      <!-- @ENGLISH {{{
      <para>To bring her project up to date, Sally can ask
        Subversion to <firstterm>update</firstterm> her working copy,
        by using the Subversion <command>update</command> command.
        This will incorporate your changes into her working copy, as
        well as any others that have been committed since she checked
        it out.</para>
      @ENGLISH }}} -->
      <para>Для приведения рабочей копии в актуальное состояние, Салли
        может попросить Subversion <firstterm>обновить</firstterm> её
        рабочую копию, используя команду Subversion
        <command>update</command>. Это внедрит ваши изменения в ее рабочую
        копию вместе с другими изменениями, которые были зафиксированы с момента
        когда она создавала рабочую копию.</para>

      <screen>
$ pwd
/home/sally/calc

$ ls -A
.svn/ Makefile integer.c button.c

$ svn update
U    button.c
Updated to revision 57.
</screen>

      <!-- @ENGLISH {{{
      <para>The output from the <command>svn update</command> command
        indicates that Subversion updated the contents of
        <filename>button.c</filename>.  Note that Sally didn't need to
        specify which files to update; Subversion uses the information
        in the <filename>.svn</filename> directory, and further
        information in the repository, to decide which files need to
        be brought up to date.</para>
      @ENGLISH }}} -->
      <para>Вывод команды <command>svn update</command> говорит, что
        Subversion обновила содержимое <filename>button.c</filename>.
        Обратите внимание, что Салли не должна указывать, какой файл обновить;
        для определения файлов, которые необходимо привести в актуальное
        состояние, Subversion использует информацию в каталоге
        <filename>.svn</filename>, а также информацию из хранилища.</para>

    </sect2>


    <!-- =============================================================== -->
    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.revs">
      <!-- @ENGLISH {{{
      <title>Revisions</title>
      @ENGLISH }}} -->
      <title>Правки</title>

      <!-- @ENGLISH {{{
      <para>An <command>svn commit</command> operation can publish
        changes to any number of files and directories as a single
        atomic transaction.  In your working copy, you can change
        files' contents, create, delete, rename and copy files and
        directories, and then commit the complete set of changes as a
        unit.</para>
      @ENGLISH }}} -->
      <para>Операция <command>svn commit</command> может опубликовать
        изменения любого количества файлов и каталогов за одну
        атомарную операцию. В своей рабочей копии вы можете менять
        содержимое файлов, создавать, удалять, переименовывать и
        копировать файлы и каталоги, а затем зафиксировать все
        изменения за один раз.</para>

      <!-- @ENGLISH {{{
      <para>In the repository, each commit is treated as an atomic
        transaction: either all the commit's changes take place, or
        none of them take place.  Subversion tries to retain this
        atomicity in the face of program crashes, system crashes,
        network problems, and other users' actions.</para>
      @ENGLISH }}} -->
      <para>В хранилище каждая фиксация отражается как атомарная
        операция: либо изменения вносятся полностью, либо не вносятся
        вообще. Subversion ведёт себя так, принимая в расчет возможные
        сбои в программах, системные сбои, проблемы с сетью, а также
        неверные действия пользователя.</para>

      <!-- @ENGLISH {{{
      <para>Each time the repository accepts a commit, this creates a
        new state of the filesystem tree, called a
        <firstterm>revision</firstterm>.  Each revision is assigned a
        unique natural number, one greater than the number of the
        previous revision.  The initial revision of a freshly created
        repository is numbered zero, and consists of nothing but an
        empty root directory.</para>
      @ENGLISH }}} -->
      <para>Каждый раз, когда происходит фиксация, создаётся
        новое состояние файловой системы, которое называется
        <firstterm>правка</firstterm>. Каждая правка получает
        уникальный номер, на единицу больший номера
        предыдущей правки. Начальная правка только что созданного
        хранилища получает номер 0 и не содержит ничего, кроме
        пустого корневого каталога.</para>

      <!-- @ENGLISH {{{
      <para><xref linkend="svn.basic.in-action.revs.dia-1"/> illustrates a nice way to
        visualize the repository.  Imagine an array of revision
        numbers, starting at 0, stretching from left to right.  Each
        revision number has a filesystem tree hanging below it, and
        each tree is a <quote>snapshot</quote> of the way the
        repository looked after a commit.</para>
      @ENGLISH }}} -->
      <para><xref linkend="svn.basic.in-action.revs.dia-1"/> отлично
        иллюстрирует хранилище. Представьте массив номеров правок,
        начинающийся с 0, с направлением слева направо. Каждый номер
        правки имеет соответствующее дерево файлов, а каждое дерево
        представляет собой <quote>снимок</quote> того, как хранилище
        выглядело после фиксации.</para>

      <figure id="svn.basic.in-action.revs.dia-1">
        <!-- @ENGLISH {{{
        <title>The repository</title>
        @ENGLISH }}} -->
        <title>Хранилище</title>
        <graphic fileref="images/ch02dia7.png"/>
      </figure>

      <sidebar>
        <!-- @ENGLISH {{{
        <title>Global Revision Numbers</title>
        @ENGLISH }}} -->
        <title>Глобальные номера правок</title>

        <!-- @ENGLISH {{{
        <para>Unlike those of many other version control systems,
          Subversion's revision numbers apply to <emphasis>entire
          trees</emphasis>, not individual files.  Each revision
          number selects an entire tree, a particular state of the
          repository after some committed change.  Another way to
          think about it is that revision N represents the state of
          the repository filesystem after the Nth commit.  When
          Subversion users talk about <quote>revision 5 of
          <filename>foo.c</filename></quote>, they really mean
          <quote><filename>foo.c</filename> as it appears in revision
          5.</quote> Notice that in general, revisions N and M of a
          file do <emphasis>not</emphasis> necessarily differ!  Because
          CVS uses per-file revision numbers, CVS users might want to
          see <xref linkend="svn.forcvs"/> for more details.</para>
        @ENGLISH }}} -->
        <para>В отличие от многих других систем управления версиями, номера правок
          в Subversion относятся <emphasis>ко всем</emphasis>, а не только к
          отдельно взятым файлам. Каждый номер правки соответствует целому
          дереву, отдельному состоянию хранилища после зафиксированного
          изменения. Иначе говоря &mdash; правка N представляет состояние
          файловой системы хранилища после выполнения N-ой фиксации. Когда
          пользователи Subversion говорят о <quote>правке 5 <filename>foo.c
          </filename></quote>, на самом деле речь идет о <quote><filename>
          foo.c</filename> входящем в правку 5</quote>. Заметьте, что
          обычно правки N и M файла <emphasis>не обязательно</emphasis>
          будут отличаться. Поскольку в CVS используется пофайловая нумерация
          правок, пользователи CVS могут обратиться за более подробной
          информацией к <xref linkend="svn.forcvs"/>.</para>
      </sidebar>

      <!-- @ENGLISH {{{
      <para>It's important to note that working copies do not always
        correspond to any single revision in the repository; they may
        contain files from several different revisions.  For example,
        suppose you check out a working copy from a repository whose
        most recent revision is 4:</para>
      @ENGLISH }}} -->
      <para>Важно помнить то, что рабочие копии не всегда соответствуют
        какой-то одной правке в хранилище; они могут содержать файлы из
        разных правок. Например, вы получили рабочую копию из хранилища,
        у которого самая последняя правка &mdash; 4:</para>

      <screen>
calc/Makefile:4
     integer.c:4
     button.c:4
</screen>

      <!-- @ENGLISH {{{
      <para>At the moment, this working directory corresponds exactly
        to revision 4 in the repository.  However, suppose you make a
        change to <filename>button.c</filename>, and commit that
        change.  Assuming no other commits have taken place, your
        commit will create revision 5 of the repository, and your
        working copy will now look like this:</para>
      @ENGLISH }}} -->
      <para>На данный момент рабочий каталог полностью соответствует
        правке 4 в хранилище. Допустим, что вы внесли изменения в
        <filename>button.c</filename>, и зафиксировали эти изменения.
        При отсутствии других фиксаций ваша фиксация создаст правку
        под номером 5, и теперь ваша рабочая копия выглядит следующим
        образом:</para>

      <screen>
calc/Makefile:4
     integer.c:4
     button.c:5
</screen>

      <!-- @ENGLISH {{{
      <para>Suppose that, at this point, Sally commits a change to
        <filename>integer.c</filename>, creating revision 6.  If you
        use <command>svn update</command> to bring your working copy
        up to date, then it will look like this:</para>
      @ENGLISH }}} -->
      <para>Предположим, что после этого Салли фиксирует изменения <filename>
        integer.c</filename>, создавая правку 6. Если вы воспользуетесь
        <command>svn update</command> для приведения своей рабочей копии
        в актуальное состояние, то она станет выглядеть так:</para>

      <screen>
calc/Makefile:6
     integer.c:6
     button.c:6
</screen>

      <!-- @ENGLISH {{{
      <para>Sally's change to <filename>integer.c</filename> will
        appear in your working copy, and your change will still be
        present in <filename>button.c</filename>.  In this example,
        the text of <filename>Makefile</filename> is identical in
        revisions 4, 5, and 6, but Subversion will mark your working
        copy of <filename>Makefile</filename> with revision 6 to
        indicate that it is still current.  So, after you do a clean
        update at the top of your working copy, it will generally
        correspond to exactly one revision in the repository.</para>
      @ENGLISH }}} -->
      <para>Изменения, внесенные Салли в <filename>integer.c</filename> будут
        отражены в вашей рабочей копии, и ваши изменения в
        <filename>button.c</filename> также будут присутствовать. В этом
        примере текст <filename>Makefile</filename> в правках 4, 5 и 6
        идентичен, однако, Subversion проставляет номер правки 6 для вашей
        рабочей копии <filename>Makefile</filename>, чтобы показать что файл
        не устарел. Таким образом, после того как вы выполните полное
        обновление вашей рабочей копии, она будет полностью соответствовать
        текущему состоянию хранилища.</para>

    </sect2>


    <!-- =============================================================== -->
    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.track-repos">
      <!-- @ENGLISH {{{
      <title>How Working Copies Track the Repository</title>
      @ENGLISH }}} -->
      <title>Как рабочие копии отслеживают хранилище</title>

      <!-- @ENGLISH {{{
      <para>For each file in a working directory, Subversion records
        two essential pieces of information in the
        <filename>.svn/</filename> administrative area:</para>
      @ENGLISH }}} -->
      <para>В служебном каталоге <filename>.svn/</filename> для каждого
      файла рабочего каталога Subversion записывает информацию о двух
        важнейших свойствах:</para>


      <itemizedlist>
        <listitem>
          <!-- @ENGLISH {{{
          <para>what revision your working file is based on (this is
            called the file's <firstterm>working
            revision</firstterm>), and</para>
          @ENGLISH }}} -->
          <para>на какой правке основан ваш рабочий файл (это
            называется <firstterm>рабочая правка</firstterm> файла),
            и</para>
        </listitem>

        <listitem>
          <!-- @ENGLISH {{{
          <para>a timestamp recording when the local copy was last
            updated by the repository.</para>
          @ENGLISH }}} -->
          <para>временной (ударение на последний слог) метке, определяющей,
          когда рабочая копия последний раз обновлялась из хранилища.</para>
        </listitem>
      </itemizedlist>

      <!-- @ENGLISH {{{
      <para>Given this information, by talking to the repository,
        Subversion can tell which of the following four states a
        working file is in:</para>
      @ENGLISH }}} -->
      <para>Используя эту информацию при соединении с хранилищем, Subversion
        может сказать, в каком из следующих четырех состояний находится рабочий
        файл:</para>

      <variablelist>
        <varlistentry>
          <!-- @ENGLISH {{{
          <term>Unchanged, and current</term>
          @ENGLISH }}} -->
          <term>Не изменялся и не устарел</term>

          <listitem>
            <!-- @ENGLISH {{{
            <para>The file is unchanged in the working directory, and
              no changes to that file have been committed to the
              repository since its working revision.  An <command>svn
              commit</command> of the file will do nothing, and an
              <command>svn update</command> of the file will do
              nothing.</para>
            @ENGLISH }}} -->
            <para>Файл не изменялся в рабочем каталоге, в хранилище не
              фиксировались изменения этого файла со времени создания его
              рабочей правки. Команды <command>svn commit</command> и
              <command>svn update</command> никаких операций делать не
              будут.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <!-- @ENGLISH {{{
          <term>Locally changed, and current</term>
          @ENGLISH }}} -->
          <term>Изменялся локально и не устарел</term>

          <listitem>
            <!-- @ENGLISH {{{
            <para>The file has been changed in the working directory,
              and no changes to that file have been committed to the
              repository since its base revision.  There are local
              changes that have not been committed to the repository,
              thus an <command>svn commit</command> of the file will
              succeed in publishing your changes, and an <command>svn
              update</command> of the file will do nothing.</para>
            @ENGLISH }}} -->
            <para>Файл был изменен в рабочей копии, но в хранилище не
              фиксировались изменения этого файла после правки, на которой он
              основан. Есть локальные изменения, которые не были зафиксированы
              в хранилище, поэтому <command>svn commit</command>
              выполнит фиксацию ваших изменений, а
              <command>svn update</command> не сделает ничего.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <!-- @ENGLISH {{{
          <term>Unchanged, and out-of-date</term>
          @ENGLISH }}} -->
          <term>Не изменялся и устарел</term>

          <listitem>
            <!-- @ENGLISH {{{
            <para>The file has not been changed in the working
              directory, but it has been changed in the repository.
              The file should eventually be updated, to make it
              current with the public revision.  An <command>svn
              commit</command> of the file will do nothing, and an
              <command>svn update</command> of the file will fold the
              latest changes into your working copy.</para>
            @ENGLISH }}} -->
            <para>В рабочем каталоге файл не изменялся, но был изменен в
              хранилище. Необходимо выполнить обновление файла для того,
              чтобы он соответствовал текущей правке. Команда <command>
              svn commit</command> не сделает ничего, а
              <command>svn update</command> обновит вашу рабочую копию файла в
              соответствии с последними изменениями.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <!-- @ENGLISH {{{
          <term>Locally changed, and out-of-date</term>
          @ENGLISH }}} -->
          <term>Изменялся локально и устарел</term>

          <listitem>
            <!-- @ENGLISH {{{
            <para>The file has been changed both in the working
              directory, and in the repository.  An <command>svn
              commit</command> of the file will fail with an
              <quote>out-of-date</quote> error.  The file should be
              updated first; an <command>svn update</command> command
              will attempt to merge the public changes with the local
              changes.  If Subversion can't complete the merge in a
              plausible way automatically, it leaves it to the user to
              resolve the conflict.</para>
            @ENGLISH }}} -->
            <para>Файл был изменен как в рабочем каталоге, так и в
              хранилище. <command>svn commit</command> потерпит неудачу, выдав
              ошибку <quote>out-of-date</quote>. Файл необходимо сначала
              обновить; <command>svn update</command> попытается объединить
              локальные изменения с опубликованными. Если Subversion не сможет
              самостоятельно совершить объединение, он предложит пользователю
              разрешить конфликт вручную.</para>
          </listitem>
        </varlistentry>
      </variablelist>


      <!-- @ENGLISH {{{
      <para>This may sound like a lot to keep track of, but the
        <command>svn status</command> command will show you the state
        of any item in your working copy.  For more information on
        that command, see <xref linkend="svn.tour.cycle.examine.status" />.</para>
      @ENGLISH }}} -->
      <para>Может показаться, что следить за актуальным состоянием рабочей
        копии сложно. Это не так. Для того, чтобы узнать состояние любого
        элемента в вашей рабочей копии существует команда <command>svn
        status</command>. За более подробной информацией об этой команде
        обратитесь к <xref linkend="svn.tour.cycle.examine.status" />.</para>

    </sect2>

    <!-- =============================================================== -->
    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.mixedrevs">
      <!-- @ENGLISH {{{
      <title>Mixed Revision Working Copies</title>
      @ENGLISH }}} -->
      <title>Смешивание правок в рабочих копиях</title>

      <!-- @ENGLISH {{{
      <para>As a general principle, Subversion tries to be as flexible
        as possible.  One special kind of flexibility is the ability
        to have a working copy containing files and directories with a
        mix of different working revision numbers.  Unfortunately,
        this flexibility tends to confuse a number of new users.  If
        the earlier example showing mixed revisions perplexed you,
        here's a primer on both why the feature exists and how to make
        use of it.</para>
      @ENGLISH }}} -->
      <para>Subversion старается быть гибкой настолько, насколько это возможно.
        Например, существует возможность иметь рабочую копию, содержащую
        файлы и каталоги, имеющие смешанные номера рабочих правок. Но, к
        сожалению, эта гибкость иногда смущает некоторых новых
        пользователей. Если раньше примеры, показывающие смешанные правки,
        вызывали у вас чувство растерянности, то это руководство, которое
        рассказывает для чего такая возможность существует и как ее
        использовать, для вас.</para>

      <sect3 id="svn.basic.in-action.mixedrevs.update-commit">
        <!-- @ENGLISH {{{
        <title>Updates and Commits are Separate</title>
        @ENGLISH }}} -->
        <title>Обновления и фиксации отделены друг от друга</title>

        <!-- @ENGLISH {{{
        <para>One of the fundamental rules of Subversion is that
          a <quote>push</quote> action does not cause
          a <quote>pull</quote>, nor the other way around.  Just
          because you're ready to submit new changes to the repository
          doesn't mean you're ready to receive changes from other
          people.  And if you have new changes still in progress,
          then <command>svn update</command> should gracefully merge
          repository changes into your own, rather than forcing you to
          publish them.</para>
      @ENGLISH }}} -->
        <para>Одно из фундаментальных правил Subversion заключается в том,
          что <quote>передающее</quote> действие не приводит к
          <quote>принимаемому</quote>, и наоборот. То, что вы готовы
          внести изменения в хранилище, не означает то, что вы готовы принять
          изменения от других. А если вы все еще работаете над новыми изменениями,
          то <command>svn update</command> изящно объединит изменения из
          хранилища с вашими собственными, вместо того, что бы заставлять вас
          опубликовать их.</para>

        <!-- @ENGLISH {{{
        <para>The main side-effect of this rule is that it means a
          working copy has to do extra bookkeeping to track mixed
          revisions, and be tolerant of the mixture as well.  It's
          made more complicated by the fact that directories
          themselves are versioned.</para>
        @ENGLISH }}} -->
        <para>Главным побочным эффектом этого правила является то, что
          рабочая копия должна вести дополнительный учет при смешивании
          правок и быть аккуратной при любом смешивании. И то, что каталоги
          попадают под контроль версий, делает это еще более сложным
          для понимания.</para>

        <!-- @ENGLISH {{{
        <para>For example, suppose you have a working copy entirely at
          revision 10.  You edit the
          file <filename>foo.html</filename> and then perform
          an <command>svn commit</command>, which creates revision 15
          in the repository.  After the commit succeeds, many new
          users would expect the working copy to be entirely at
          revision 15, but that's not the case!  Any number of changes
          might have happened in the repository between revisions 10
          and 15.  The client knows nothing of those changes in the
          repository, since you haven't yet run <command>svn
          update</command>, and <command>svn commit</command> doesn't
          pull down new changes.  If, on the other hand,
          <command>svn commit</command> <emphasis>were</emphasis> to
          automatically download the newest changes, then it would be
          possible to set the entire working copy to revision
          15&mdash;but then we'd be breaking the fundamental rule
          of <quote>push</quote> and <quote>pull</quote> remaining
          separate actions.  Therefore the only safe thing the
          Subversion client can do is mark the one
          file&mdash;<filename>foo.html</filename>&mdash;as being at
          revision 15.  The rest of the working copy remains at
          revision 10.  Only by running <command>svn update</command>
          can the latest changes be downloaded, and the whole working
          copy be marked as revision 15.</para>
        @ENGLISH }}} -->
        <para>Допустим, у вас есть рабочая копия, полностью соответствующая
          правке 10. После изменения файла <filename>foo.html</filename>,
          вы выполняете команду <command>svn commit</command>,
          которая создает в хранилище правку 15. После выполнения
          фиксации большая часть новичков ожидают, что вся
          рабочая копия будет иметь правку 15, однако это не так.
          Между правками 10 и 15 в хранилище могло быть внесено любое
	   количество изменений. Так как команда <command>svn update</command>
          не выполнялась, а <command>svn commit</command>
	   не загружает изменений, клиент ничего не знает о находящихся в
          хранилище изменениях. С другой стороны, если команда <command>svn
	   commit</command> будет автоматически загружать последние изменения,
          то всей рабочей копии можно будет назначить соответствующий номер
          правки - 15. Однако нарушится фундаментальное правило,
          согласно которому <quote>передача</quote> и
          <quote>получение</quote> являются независимыми операциями.
          Следовательно, все, что может сделать клиент Subversion, это
          пометить один файл &mdash; <filename>foo.html</filename> &mdash;
          как соответствующий правке 15. Остальная рабочая копия
          продолжает соответствовать правке 10. Только при выполнении
          <command>svn update</command> будут загружены последние
          изменения и вся рабочая копия будет помечена как соответствующая
          правке 15.</para>

        </sect3>

        <sect3 id="svn.basic.in-action.mixedrevs.normal">
          <!-- @ENGLISH {{{
          <title>Mixed revisions are normal</title>

          <para>The fact is, <emphasis>every time</emphasis> you
            run <command>svn commit</command>, your working copy ends
            up with some mixture of revisions.  The things you just
            committed are marked as having larger working revisions
            than everything else.  After several commits (with no
            updates in-between) your working copy will contain a whole
            mixture of revisions.  Even if you're the only person
            using the repository, you will still see this phenomenon.
            To examine your mixture of working revisions, use
            the <command>svn status -&#64738;-verbose</command> command (see
            <xref linkend="svn.tour.cycle.examine.status"/> for more
            information.)</para>

          <para>Often, new users are completely unaware that their
            working copy contains mixed revisions.  This can be
            confusing, because many client commands are sensitive to
            the working revision of the item they're examining.  For
            example, the <command>svn log</command> command is used to
            display the history of changes to a file or directory (see
            <xref linkend="svn.tour.history.log"/>).  When the user
            invokes this command on a working copy object, they expect
            to see the entire history of the object.  But if the
            object's working revision is quite old (often
            because <command>svn update</command> hasn't been run in a
            long time), then the history of
            the <emphasis>older</emphasis> version of the object is
            shown.</para>
          @ENGLISH }}} -->
          <title>Смешивание правок &mdash; это нормально</title>

          <para>Фактически, <emphasis>каждый раз</emphasis> при
            выполнении <command>svn commit</command> правки рабочей
            копии смешиваются. Только что зафиксированные элементы
            отмечаются как имеющие больший номер рабочей правки, чем все
            остальные. После нескольких фиксаций (без выполнения
            обновлений между ними) правки рабочей копии будут полностью
            перемешаны. Даже если вы являетесь единственным пользователем
            хранилища, вы все равно с этим столкнетесь. Для просмотра
            этой смеси рабочих правок воспользуйтесь командой
            <command>svn status --verbose</command> (см.
            <xref linkend="svn.tour.cycle.examine.status"/>).</para>

          <para>Часто новые пользователи даже не подозревают о том,
            что их рабочая копия содержит смешанные правки. Это может
            сбить с толку, так как многие команды клиента чувствительны
            к рабочей правке элемента, с которым он работает. Например,
            команда <command>svn log</command> используется для вывода
            истории изменения файла или каталога (см. <xref
            linkend="svn.tour.history.log"/>). Когда пользователь
            вызывает эту команду применительно к объекту рабочей копии,
            он ожидает увидеть полную историю этого объекта. Однако
            если рабочая правка объекта очень старая (из-за того, что
            команда <command>svn update</command> долго не выполнялась)
            будет показана история для <emphasis>более старой</emphasis>
            версии этого объекта.</para>

        </sect3>

        <sect3 id="svn.basic.in-action.mixedrevs.useful">
          <!-- @ENGLISH {{{
          <title>Mixed revisions are useful</title>

          <para>If your project is sufficiently complex, you'll
            discover that it's sometimes nice to forcibly
            <quote>backdate</quote> portions of your working copy to
            an earlier revision; you'll learn how to do that in
            Chapter 3.  Perhaps you'd like to test an earlier version
            of a sub-module contained in a subdirectory, or perhaps
            you'd like to figure out when a bug first came into
            existence in a specific file.  This is the <quote>time
            machine</quote> aspect of a version control system &mdash;
            the feature which allows you to move any portion of your
            working copy forward and backward in history.</para>
          @ENGLISH }}} -->
          <title>Смешивание правок &mdash; это полезно</title>

          <para>Если у вас очень большой проект, вы можете найти
            полезным, время от времени принудительно
            <quote>возвращать</quote> части рабочей копии к более
            ранним правкам; как это делается, вы узнаете в Главе 3.
            Возможно вы захотите протестировать более раннюю версию
            модуля, находящегося в подкаталоге или точно
            узнать, когда в конкретном файле появилась
            ошибка. Это &mdash; <quote>машина времени</quote> &mdash;
            тот аспект системы управления версиями, который
            позволяет перемещать в истории любую часть рабочей копии
            вперед и назад.</para>

        </sect3>

        <sect3 id="svn.basic.in-action.mixedrevs.limits">
          <!-- @ENGLISH {{{
          <title>Mixed revisions have limitations</title>
          @ENGLISH }}} -->
          <title>Смешивание правок имеет ограничения</title>

          <!-- @ENGLISH {{{
          <para>However you make use of mixed revisions in your
            working copy, there are limitations to this
            flexibility.</para>
          @ENGLISH }}} -->
          <para>Несмотря на то, что в рабочей копии можно использовать
            смешивание правок, у этой гибкости существуют
            ограничения.</para>

          <!-- @ENGLISH {{{
          <para>First, you cannot commit the deletion of a file or
            directory which isn't fully up-to-date.  If a newer
            version of the item exists in the repository, your attempt
            to delete will be rejected, to prevent you from
            accidentally destroying changes you've not yet
            seen.</para>
          @ENGLISH }}} -->

          <para>Во-первых, нельзя зафиксировать удаление устаревшего
            файла или каталога. Если в хранилище существует более новая
            версия элемента, попытка удаления будет отклонена для
            предотвращения возможности непреднамеренного уничтожения
            изменений о которых вы не в курсе.</para>

          <!-- @ENGLISH {{{
          <para>Second, you cannot commit a metadata change to a
            directory unless it's fully up-to-date.  You'll learn
            about attaching
            <quote>properties</quote> to items in Chapter 6.  A
            directory's working revision defines a specific set of
            entries and properties, and thus committing a property
            change to an out-of-date directory may destroy properties
            you've not yet seen.</para>
          @ENGLISH }}} -->
          <para>Во-вторых, нельзя зафиксировать изменение метаданных
            для не обновленного каталога. О присвоении
            <quote>свойств</quote> к элементам вы узнаете в Главе 6.
            Рабочая правка каталога определяет конкретный набор входящих
            в нее элементов и свойств, поэтому фиксация изменений свойств
            для устаревшего каталога может привести к уничтожению
            свойств о которых вы не знаете.</para>

        </sect3>


    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.summary">
    <!-- @ENGLISH {{{
    <title>Summary</title>
    @ENGLISH }}} -->
    <title>Подводя итоги</title>

    <!-- @ENGLISH {{{
    <para>We've covered a number of fundamental Subversion concepts in
      this chapter:</para>
    @ENGLISH }}} -->
    <para>В этой главе мы рассмотрели ряд фундаментальных вещей о
      Subversion:</para>

    <itemizedlist>
      <listitem>
        <!-- @ENGLISH {{{
        <para>We've introduced the notions of the central repository,
          the client working copy, and the array of repository
          revision trees.</para>
        @ENGLISH }}} -->
        <para>Мы ввели такие понятия, как центральное хранилище, рабочая
          копия и массив правок хранилища.</para>
      </listitem>

      <listitem>
        <!-- @ENGLISH {{{
        <para>We've seen some simple examples of how two collaborators
          can use Subversion to publish and receive changes from one
          another, using the <quote>copy-modify-merge</quote>
          model.</para>
        @ENGLISH }}} -->
        <para>Мы рассмотрели на нескольких простых примерах, как при помощи
          Subversion два партнера могут публиковать и получать
          изменения, сделанные друг другом, используя модель
          <quote>копирование-изменение-слияние</quote>.</para>
      </listitem>

      <listitem>
        <!-- @ENGLISH {{{
        <para>We've talked a bit about the way Subversion tracks and
          manages information in a working copy.</para>
        @ENGLISH }}} -->
        <para>Мы немного поговорили о том, как Subversion отслеживает и
          управляет информацией в рабочей копии.</para>
      </listitem>

    </itemizedlist>

    <!-- @ENGLISH {{{
    <para>At this point, you should have a good idea of how Subversion
      works in the most general sense.  Armed with this knowledge, you
      should now be ready to jump into the next chapter, which is a
      detailed tour of Subversion's commands and features.</para>
    @ENGLISH }}} -->
    <para>На данный момент у вас должно быть хорошее представление о том, как
      вообще работает Subversion. Теперь, вооруженные этими знаниями, вы
      готовы перейти к следующей главе, которая представляет собой подробный
      обзор команд и возможностей Subversion.</para>

  </sect1>

</chapter>

<!--
local variables:
sgml-parent-document: ("book.xml" "chapter")
end:
vim: tw=78:ft=svnbook
-->

