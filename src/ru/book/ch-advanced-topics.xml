<?xml version="1.0" encoding="UTF-8"?>
<chapter id="svn.advanced">

  <!-- @ENGLISH {{{
  <title>Advanced Topics</title>
  @ENGLISH }}} -->
  <title>Профессиональное использование Subversion</title>
  <!-- See also svn.preface.organization -->

  <!-- @ENGLISH {{{
  <para>If you've been reading this book chapter by chapter, from
    start to finish, you should by now have acquired enough
    knowledge to use the Subversion client to perform the most
    common version control operations.  You understand how to
    checkout a working copy from a Subversion repository.  You are
    comfortable with submitting and receiving changes using the
    <command>svn commit</command> and <command>svn update</command>
    functions.  You've probably even developed a reflex which causes
    you to run the <command>svn status</command> command almost
    unconsciously.  For all intents and purposes, you are ready to
    use Subversion in a typical environment.</para>
  @ENGLISH }}} -->
  <para>Если вы читали эту книгу последовательно, глава за главой, 
    то к настоящему моменту должны иметь достаточно знаний
    для выполнения с помощью Subversion-клиента типовых
    операций управления версиями. Вы умеете создавать
    рабочую копию, знаете, как с помощью команд <command>svn
    commit</command> и <command>svn update</command> отправлять и
    получать изменения. Возможно, у вас уже даже выработался рефлекс
    бессознательного запуска <command>svn status</command>. Вы готовы
    применять Subversion в большинстве типовых ситуаций.</para>

  <!-- @ENGLISH {{{
  <para>But the Subversion feature set doesn't stop at <quote>common
    version control operations</quote>.  It has other bits of
    functionality that extend beyond just communicating file and
    directory changes to and from a central repository.</para>
  @ENGLISH }}} -->
  <para>Однако возможности Subversion не ограничиваются 
    <quote>типовыми операциями управления версиями</quote>.  
    В Subversion реализован функционал, выходящий за пределы
    простого обмена различиями с центральным хранилищем.
  </para>

  <!-- @ENGLISH {{{
  <para>This chapter highlights some of Subversion's features that,
    while important, aren't part of the typical user's daily routine.
    It assumes that you are familiar with Subversion's basic file and
    directory versioning capabilities.  If you aren't, you'll want to
    first read <xref linkend="svn.basic" /> and <xref
    linkend="svn.tour" />.  Once you've mastered those basics and
    consumed this chapter, you'll be a Subversion power-user!</para>
  @ENGLISH }}} -->
  <para>В этой главе рассказывается о тех возможностях Subversion, которые,
    несмотря на свою важность, не используются в типичном ежедневном рабочем
    цикле. Чтобы читать дальше эту главу, необходимо хорошо представлять себе
    механизмы версионированния файлов и каталогов в Subversion.
    Если вы этого не знаете, прочитайте сначала <xref linkend="svn.basic" /> 
    и <xref linkend="svn.tour" />.
    Овладев основами и изучив приемы, рассмотренные в этой главе, 
    вы станете действительно продвинутым пользователем Subversion!</para>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.revs.specifiers">
  <!-- @ENGLISH {{{
    <title>Revision Specifiers</title>
  @ENGLISH }}} -->
    <title>Способы обозначения правок</title>

  <!-- @ENGLISH {{{
    <para>As you saw in <xref linkend="svn.tour.revs" />, revision
      numbers in Subversion are pretty straightforward&mdash;integers
      that keep getting larger as you commit more changes to your
      versioned data.  Still, it doesn't take long before you can no
      longer remember exactly what happened in each and every
      revision.  Fortunately, the typical Subversion workflow doesn't
      often demand that you supply arbitrary revisions to the
      Subversion operations you perform.  For operations that
      <emphasis>do</emphasis> require a revision specifier, you
      generally supply a revision number that you saw in a commit
      email, in the output of some other Subversion operation, or in
      some other context that would yield meaning to that particular
      number.</para>
  @ENGLISH }}} -->
    <para>Как вы уже заметили в <xref linkend="svn.tour.revs" />, 
      номера правок в Subversion &mdash; это не более чем целые числа,
      монотонно возрастающие при каждой фиксации изменений 
      версионированных данных. Пройдет совсем немного времени, и вы уже
      не сможете точно вспомнить, что произошло в каждой из правок.
      К счастью, типовая практика работы с Subversion не часто 
      предполагает указание вами конкретных правок, к которым 
      следует применить ту или иную операцию. 
      Для операций, которые требуют <emphasis>обязательной</emphasis> 
      ссылки на конкретную правку, чаще всего указывают номер правки,
      который известен из сообщения о фиксации, вывода некоторых других 
      операций Subversion или из каких-либо других обстоятельств,
      которые могли бы дать этот конкретный номер.</para>


  <!-- @ENGLISH {{{
    <para>But occasionally, you need to pinpoint a moment in time for
      which you don't already have a revision number memorized or
      handy.  So besides the integer revision numbers,
      <command>svn</command> allows as input some additional forms of
      revision specifiers&mdash;revision keywords, and revision
      dates.</para>
  @ENGLISH }}} -->
    <para>Однако, иногда у вас может возникнуть необходимость сослаться
      на момент времени, для которого у вас уже не осталось в памяти 
      или в записях точного номера правки. Поэтому, кроме целочисленных
      номеров правок, <command>svn</command> позволяет использовать
      дополнительные формы обозначения правок &mdash; ключевые 
      слова и даты правок.</para>

    <note>
  <!-- @ENGLISH {{{
      <para>The various forms of Subversion revision specifiers can be
        mixed and matched when used to specify revision ranges.  For
        example, you can use <option>-r
        <replaceable>REV1</replaceable>:<replaceable>REV2</replaceable></option>
        where <replaceable>REV1</replaceable> is a revision keyword
        and <replaceable>REV2</replaceable> is a revision number, or
        where <replaceable>REV1</replaceable> is a date and
        <replaceable>REV2</replaceable> is a revision keyword, and so
        on.  The individual revision specifiers are independently
        evaluated, so you can put whatever you want on the opposite
        sides of that colon.</para>
  @ENGLISH }}} -->
      <para>При указании диапазонов правок можно смешивать различные 
        способы их обозначения, допустимые в Subversion.  Например, вы 
        можете использовать <option>-r
        <replaceable>REV1</replaceable>:<replaceable>REV2</replaceable></option>,
        где <replaceable>REV1</replaceable> &mdash; это ключевое слово, 
        а <replaceable>REV2</replaceable> &mdash; обычный номер правки, или
        где <replaceable>REV1</replaceable> &mdash; дата, а 
        <replaceable>REV2</replaceable> &mdash; ключевое слово, и так далее.  
        Каждое обозначение правки будет интерпретироваться независимо друг 
        от друга, поэтому вы можете указать по другую сторону от двоеточия 
        что угодно.</para>
    </note>
    
    <!-- =============================================================== -->
    <sect2 id="svn.tour.revs.keywords">
  <!-- @ENGLISH {{{
      <title>Revision Keywords</title>
  @ENGLISH }}} -->
      <title>Ключевые слова правок</title>
      
  <!-- @ENGLISH {{{
      <para>The Subversion client understands a number of
        <firstterm>revision keywords</firstterm>.  These keywords can
        be used instead of integer arguments to the
        <option>-&#64738;-revision</option> switch, and are resolved into
        specific revision numbers by Subversion:</para>
  @ENGLISH }}} -->
      <para>Клиент Subversion понимает ряд 
        <firstterm>ключевых слов</firstterm>.  Эти ключевые слова можно
        использовать вместо целочисленных аргументов опции 
        <option>--revision</option>, при этом Subversion переведет их в 
        конкретные номера правок:</para>

      <variablelist>

        <varlistentry>
          <term>HEAD</term>
          <listitem>
            <!-- @ENGLISH {{{
            <para>The latest (or <quote>youngest</quote>) revision in
              the repository.</para>
            @ENGLISH }}} -->
            <para>Последняя (или <quote>самая новая</quote>) правка
              хранилища</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>BASE</term>
          <listitem>
            <!-- @ENGLISH {{{
            <para>The revision number of an item in a working copy.
              If the item has been locally modified, the <quote>BASE
              version</quote> refers to the way the item appears
              without those local modifications.</para>
            @ENGLISH }}} -->
            <para>Номер правки элемента в рабочей копии. Если элемент
              редактировался, то <quote>BASE версия</quote> соответствует тому,
              как выглядел этот элемент до внесения локальных изменений.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>COMMITTED</term>
          <listitem>
            <!-- @ENGLISH {{{
            <para>The most recent revision prior to, or equal to,
              <literal>BASE</literal>, in which an item changed.</para>
            @ENGLISH }}} -->
            <para>Правка, в которой элемент последний раз изменялся
              (предшествующая либо равная <literal>BASE</literal>).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>PREV</term>
          <listitem>
            <!-- @ENGLISH {{{
            <para>The revision immediately <emphasis>before</emphasis>
              the last revision in which an item changed.
              (Technically, <literal>COMMITTED</literal> - 1.)</para>
            @ENGLISH }}} -->
            <para>Правка, непосредственно <emphasis>предшествующая</emphasis> 
              той правке, в которой элемент был последний раз изменен. 
              (То есть, фактически, <literal>COMMITTED</literal> - 1.)</para>
          </listitem>
        </varlistentry>

      </variablelist>

  <!-- @ENGLISH {{{
      <para>As can be derived from their descriptions, the
        <literal>PREV</literal>, <literal>BASE</literal>, and
        <literal>COMMITTED</literal> revision keywords are used only
        when referring to a working copy path&mdash;they don't apply
        to repository URLs.  <literal>HEAD</literal>, on the other
        hand, can be used in conjuction with both of these path
        types.</para>
  @ENGLISH }}} -->
      <para>Из данного описания можно сделать очевидный вывод о том, что
        ключевые слова <literal>PREV</literal>, <literal>BASE</literal>, 
        и <literal>COMMITTED</literal> могут использоваться только при ссылках 
        на пути в рабочей копии; они не применимы к URL-адресам хранилища.
        Напротив, ключевое слово <literal>HEAD</literal> можно использовать
        совместно с обоими типами путей.</para>
      
      <!-- @ENGLISH {{{
      <para>Here are some examples of revision keywords in
        action:</para>
      @ENGLISH }}} -->
      <para>Ниже приведено несколько примеров использования ключевых слов
        правок:</para>

      <screen>
$ svn diff --revision PREV:COMMITTED foo.c
<!-- @ENGLISH {{{
# shows the last change committed to foo.c
@ENGLISH }}} -->
# показать последнее изменение, зафиксированное для foo.c

$ svn log --revision HEAD
<!-- @ENGLISH {{{
# shows log message for the latest repository commit
@ENGLISH }}} -->
# показать лог-сообщение для последней фиксации в хранилище

$ svn diff --revision HEAD
<!-- @ENGLISH {{{
# compares your working file (with local changes) to the latest version
# in the repository
@ENGLISH }}} -->
# сравнить ваш рабочий файл (с учетом локальных изменений)
# с последней правкой в хранилище

$ svn diff --revision BASE:HEAD foo.c
<!-- @ENGLISH {{{
# compares your <quote>pristine</quote> foo.c (no local changes) with the 
# latest version in the repository
@ENGLISH }}} -->
# сравнить ваш <quote>исходный</quote> foo.c (без учета локальных
# изменений) с последней версией в хранилище

$ svn log --revision BASE:HEAD
<!-- @ENGLISH {{{
# shows all commit logs since you last updated
@ENGLISH }}} -->
# показать все логи фиксаций со времени вашего последнего обновления

$ svn update --revision PREV foo.c
<!-- @ENGLISH {{{
# rewinds the last change on foo.c, decreasing foo.c's working revision
@ENGLISH }}} -->
# отменить последние изменения в foo.c, понизив рабочую правку foo.c
      
$ svn diff -r BASE:14 foo.c
<!-- @ENGLISH {{{
# compares the unmodified version of foo.c with the way foo.c looked
# in revision 14
@ENGLISH }}} -->
# сравнить неизмененную версию foo.c и версию foo.c в правке 14
</screen>
      
    </sect2>
    
    <!-- =============================================================== -->   
    <sect2 id="svn.tour.revs.dates">

      <!-- @ENGLISH {{{
      <title>Revision Dates</title>
      @ENGLISH }}} -->
      <title>Даты правок</title>
      
<!-- @ENGLISH {{{
      <para>Revision numbers reveal nothing about the world outside
        the version control system, but sometimes you need to
        correlate a moment in real time with a moment in version
        history.  To facilitate this, the <option>-&#64738;-revision</option>
        option can also accept as input date specifiers wrapped in
        curly braces (<literal>{</literal> and <literal>}</literal>).
        Subversion accepts the standard ISO-8601 date and time
        formats, plus a few others.  Here are some examples.
        (Remember to use quotes around any date that contains
        spaces.)</para>
@ENGLISH }}} -->
      <para>Номера правок не несут никакой информации об окружающем мире
        за пределами системы управления версиями, тогда как вам иногда 
        требуется сопоставить момент времени в реальной жизни
        с моментом в истории версий. Чтобы помочь вам в этом, опция
        <option>--revision</option> допускает указание даты, которую
        заключают в фигурные скобки (<literal>{</literal> и 
        <literal>}</literal>). Subversion принимает дату и время в формате,
        соответствующем стандарту ISO-8601, а также в некоторых других.
        Ниже приведено несколько примеров. (Не забывайте брать в кавычки
        любые даты, содержащие пробелы.)</para>

      <screen>
$ svn checkout -r {2006-02-17}
$ svn checkout -r {15:30}
$ svn checkout -r {15:30:00.200000}
$ svn checkout -r {"2006-02-17 15:30"}
$ svn checkout -r {"2006-02-17 15:30 +0230"}
$ svn checkout -r {2006-02-17T15:30}
$ svn checkout -r {2006-02-17T15:30Z}
$ svn checkout -r {2006-02-17T15:30-04:00}
$ svn checkout -r {20060217T1530}
$ svn checkout -r {20060217T1530Z}
$ svn checkout -r {20060217T1530-0500}
&hellip;
</screen>
      
<!-- @ENGLISH {{{
      <para>When you specify a date, Subversion resolves that date to
        the most recent revision of the repository as of that date,
        and then continues to operate against that resolved revision
        number:</para>
@ENGLISH }}} -->
      <para>Когда вы указываете дату, Subversion находит в хранилище 
        наиболее близкую к ней правку, после чего продолжает работу с 
        вычисленным номером правки. </para>

      <screen>
$ svn log -r {2006-11-28}
------------------------------------------------------------------------
r12 | ira | 2006-11-27 12:31:51 -0600 (Mon, 27 Nov 2006) | 6 lines
&hellip;
</screen>

      <sidebar>
        <!-- @ENGLISH {{{
        <title>Is Subversion a Day Early?</title>
        @ENGLISH }}} -->
        <title>Почему Subversion выдает правку за предыдущий день?</title>

        <!-- @ENGLISH {{{
        <para>If you specify a single date as a revision without
          specifying a time of day (for example
          <literal>2006-11-27</literal>), you may think that Subversion
          should give you the last revision that took place on the
          27th of November.  Instead, you'll get back a revision from
          the 26th, or even earlier.  Remember that Subversion will
          find the <emphasis>most recent revision of the
          repository</emphasis> as of the date you give.  If you give
          a date without a timestamp, like
          <literal>2006-11-27</literal>, Subversion assumes a time of
          00:00:00, so looking for the most recent revision won't
          return anything on the day of the 27th.</para>
        @ENGLISH }}} -->
        <para>Указав при обращении к правке только дату, без уточнения
          времени (например, <literal>2006-11-27</literal>), вы, 
          наверное, предположите, что Subversion должен выдать вам последнюю 
          правку за 27 ноября. 
          Однако, вместо этого вы можете получить правку за 26-е число или
          даже более раннюю. Помните, что Subversion будет искать в хранилище
          правку, <emphasis>наиболее отвечающую</emphasis> указанной вами 
          дате. Если вы укажете дату без уточнения времени,
          например <literal>2006-11-27</literal>, Subversion примет за
          временную метку 00:00:00, и таким образом поиск ближайшей к 27-му
          числу правки не даст ничего, относящегося к 27 ноября.</para>

        <!-- @ENGLISH {{{
        <para>If you want to include the 27th in your search, you can
          either specify the 27th with the time (<literal>{"2006-11-27
          23:59"}</literal>), or just specify the next day
          (<literal>{2006-11-28}</literal>).</para>
        @ENGLISH }}} -->
        <para>Если вам необходимо найти именно 27-е число, вы можете либо
          указать это число с временной меткой (<literal>{"2006-11-27
          23:59"}</literal>), либо просто использовать в запросе следующий
          день (<literal>{2006-11-28}</literal>).</para>

      </sidebar>

      <!-- @ENGLISH {{{
      <para>You can also use a range of dates.  Subversion will find
        all revisions between both dates, inclusive:</para>
      @ENGLISH }}} -->
      <para>Также вы можете задавать диапазоны дат. Subversion
        найдет все правки между обеими датами включительно:</para>
        
      <screen>
$ svn log -r {2006-11-20}:{2006-11-29}
&hellip;
</screen>
        
      <warning>
<!-- @ENGLISH {{{
        <para>Since the timestamp of a revision is stored as an
          unversioned, modifiable property of the revision (see <xref
          linkend="svn.advanced.props" />, revision timestamps can be
          changed to represent complete falsifications of true
          chronology, or even removed altogether.  This will wreak
          havoc on the internal date-to-revision conversion that
          Subversion performs.</para>
@ENGLISH }}} -->
        <para>Временн<emphasis>ы</emphasis>е метки правок 
          сохраняются как их неверсионированные изменяемые свойства 
          (см. <xref linkend="svn.advanced.props" /> ). Исходя из этого, 
          изменением временн<emphasis>ы</emphasis>х меток можно легко 
          исказить истинную хронологию, или даже удалить совсем информацию
          о времени правки.  Это может привести
          к неожиданным результатам при внутреннем преобразовании
          дат в номера правок, выполняемом Subversion.</para>
      </warning>
        
    </sect2>
      
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.props">
    <!-- @ENGLISH {{{
    <title>Properties</title>
    @ENGLISH }}} -->
    <title>Свойства</title>

<!-- @ENGLISH {{{
    <para>We've already covered in detail how Subversion stores and
      retrieves various versions of files and directories in its
      repository.  Whole chapters have been devoted to this most
      fundamental piece of functionality provided by the tool.  And
      if the versioning support stopped there, Subversion would still
      be complete from a version control perspective.</para>
@ENGLISH }}} -->
    <para>Мы уже подробно рассмотрели, каким образом Subversion сохраняет 
      и извлекает различные версии файлов и каталогов из хранилища. 
      Несколько глав было посвящено этой самой фундаментальной  
      функциональной возможности данного инструмента. И даже если бы
      поддержка версионирования этим исчерпывалась, Subversion все равно 
      мог бы считаться полноценным средством управления версиями.</para>

<!-- @ENGLISH {{{
    <para>But it doesn't stop there.</para>
@ENGLISH }}} -->
    <para>Однако Subversion этим не ограничивается.</para>

<!-- @ENGLISH {{{
    <para>In addition to versioning your directories and files,
      Subversion provides interfaces for adding, modifying, and
      removing versioned metadata on each of your versioned
      directories and files.  We refer to this metadata as
      <firstterm>properties</firstterm>, and they can be thought of as
      two-column tables that map property names to arbitrary values
      attached to each item in your working copy.  Generally speaking,
      the names and values of the properties can be whatever you want
      them to be, with the constraint that the names must be
      human-readable text.  And the best part about these properties
      is that they, too, are versioned, just like the textual contents
      of your files.  You can modify, commit, and revert property
      changes as easily as you can file content changes.  And the
      sending and receiving of property changes occurs as part of your
      typical commit and update operations&mdash;you don't have to
      change your basic processes to accomodate them.</para>
@ENGLISH }}} -->
    <para>Помимо версионированния каталогов и файлов,
      Subversion позволяет для каждого версионированного каталога или файла
      добавлять, изменять и удалять версионированные метаданные.
      Мы обращаемся к этим метаданным как
      к <firstterm>свойствам</firstterm>, которые можно представить
      в виде таблицы с двумя столбцами, присоединенной к каждому
      элементу рабочей копии и сопоставляющей имена свойств 
      соответствующим значениям. Вообще, имена и значения свойств могут быть 
      какими угодно; единственное ограничение &mdash; имена должны быть 
      читаемым текстом.
      Самое главное &mdash; то, что свойства версионированы точно
      так же, как и текстовое содержимое файлов. Изменять, фиксировать
      свойства или возвращать их в исходное состояние так же просто,
      как и делать то же самое с содержимым файлов.
      Отправка и получение измененных свойств происходит точно
      так же, как и обычные фиксации и обновления &mdash; для этого нет
      необходимости менять обычный порядок действий.</para>

    <!-- @ENGLISH {{{
    <para>Properties show up elsewhere in Subversion, too.  Just as
      files and directories may have arbitrary property names and
      values attached to them, each revision as a whole may have
      arbitrary properties attached to it.  The same constraints
      apply&mdash;human-readable names and anything-you-want binary
      values.  The main difference is that revision properties are not
      versioned.  In other words, if you change the value of, or
      delete, a revision property, there's no way within the scope of
      Subversion's functionality to recover the previous value.</para>
      @ENGLISH }}} -->
    <para>В Subversion существует еще одна разновидность свойств.
      Так же, как и файлы и каталоги, произвольные свойства и 
      соответствующие им значения может иметь каждая правка. 
      Ограничения здесь те же самые &mdash; свойство должно иметь 
      читаемое имя и может принимать любое бинарное значение. 
      Главное отличие заключается в том, что свойства правок 
      не версионируются.  Другими словами, если изменить
      значение свойства правки или удалить такое свойство, Subversion не
      сможет восстановить предыдущее значение.</para>

    <!-- @ENGLISH {{{
    <para>Subversion has no particular policy regarding the use of
      properties.  It asks only that you not use property names that
      begin with the prefix <literal>svn:</literal>.  That's the
      namespace that it sets aside for its own use.  And Subversion
      does, in fact, use properties, both the versioned and
      unversioned variety.  Certain versioned properties have special
      meaning or effects when found on files and directories, or house
      a particular bit of information about the revisions on which
      they are found.  Certain revision properties are automatically
      attached to revisions by Subversion's commit process, and carry
      information about the revision.  Most of these properties are
      mentioned elsewhere in this or other chapters as part of the
      more general topics to which they are related.  For an
      exhaustive list of Subversion's pre-defined properties, see
      <xref linkend="svn.ref.svnprops"/>.</para>
    @ENGLISH }}} -->
    <para>В Subversion нет жестко определенных правил по использованию
      свойств.  Она требует только того, чтобы имена свойств не 
      начинались с префикса <literal>svn:</literal>, поскольку
      это пространство имен закреплено для служебного использования.  
      Subversion действительно использует свойства, как версионированные, 
      так и неверсионированные, для внутренних целей. Ряд версионированных
      свойств играет особую роль при поиске файлов и каталогов
      или хранит определенную информацию о правках, в которых они найдены.
      Ряд свойств автоматически присоединяется к правкам в процессе
      фиксации, и несет о них определенную информацию . Большинство таких 
      свойств упоминаются в этой или других главах при обсуждении более 
      обших тем, к которым они относятся. Исчерпывающий список 
      предопределенных свойств
      Subversion приводится в <xref linkend="svn.ref.svnprops"/>.</para>

    <!-- @ENGLISH {{{
    <para>In this section, we will examine the utility&mdash;both to
      users of Subversion, and to Subversion itself&mdash;of property
      support.  You'll learn about the property-related
      <command>svn</command> subcommands, and how property
      modifications affect your normal Subversion workflow.
      Hopefully, you'll be convinced that Subversion properties can
      enhance your version control experience.</para>
    @ENGLISH }}} -->
    <para>В этом разделе мы рассмотрим полезность поддержки свойств как 
      для пользователя, так и для самой Subversion. Вы узнаете о 
      командах <command>svn</command>, относящихся к
      свойствам, и о том, как изменение свойств влияет на привычный рабочий
      цикл. Надеемся, вы убедитесь в том, что свойства в Subversion
      расширяют возможности управления версиями.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.why">
      <!-- @ENGLISH {{{
      <title>Why Properties?</title>
      @ENGLISH }}} -->
      <title>Зачем нужны свойства?</title>

      <!-- @ENGLISH {{{
      <para>Just as Subversion uses properties to store extra
        information about the files, directories, and revisions that
        it contains, you might also find properties to be of similar
        use.  Some part of the processes around Subversion's usage
        to which you adhere, or maybe some additional tooling around
        Subversion that you use, might find utility in having a place
        close to your versioned data to hang custom metadata about
        that data.</para>
      @ENGLISH }}} -->
      <para>Итак, Subversion использует свойства, чтобы хранить
        дополнительную информацию файлах, каталогах и правках.
        Вы можете найти свойствам аналогичное применение. 
        Наличие места рядом с версионированными данными, в котором 
        можно хранить пользовательские метаданные об этих данных,
        может пригодиться для поддержки ваших регламентов
        работы с кодом, или, возможно, для использования 
        какими-то дополнительными утилитами.</para>

      <!-- @ENGLISH {{{
      <para>Say you wish to design a website that houses many digital
        photos, and displays them with captions and a datestamp.  Now,
        your set of photos is constantly changing, so you'd like to
        have as much of this site automated as possible.  These photos
        can be quite large, so as is common with sites of this nature,
        you want to provide smaller thumbnail images to your site
        visitors.</para>
      @ENGLISH }}} -->
      <para>Допустим, вы разрабатываете веб-сайт, содержащий много
        цифровых фотографий и показывающий их с подписями и датой.
        Набор этих фотографий постоянно изменяется, поэтому сайт нужно
        по возможности максимально автоматизировать. Фотографии
        могут быть большого размера, поэтому, как обычно делают на таких
        сайтах, посетителям потребуется показывать миниатюры 
        изображений.</para>

      <!-- @ENGLISH {{{
      <para>Now, you can get this functionality using traditional
        files.  That is, you can have your
        <filename>image123.jpg</filename> and an
        <filename>image123-thumbnail.jpg</filename> side-by-side in a
        directory.  Or if you want to keep the filenames the same, you
        might have your thumbnails in a different directory, like
        <filename>thumbnails/image123.jpg</filename>.  You can also
        store your captions and datestamps in a similar fashion, again
        separated from the original image file.  But the problem here
        is that your collection of files grows in multiples with each
        new photo added to the site.</para>
      @ENGLISH }}} -->
      <para>Эту задачу можно решить с помощью обычных файлов. 
        Рядом, в одном каталоге, вы можете иметь файлы
        <filename>image123.jpg</filename> и
        <filename>image123-thumbnail.jpg</filename>. Если важно
        сохранить оригинальное имя файла, миниатюры могут размещаться в
        отдельном каталоге (например, 
        <filename>thumbnails/image123.jpg</filename>). Таким же образом,
        отдельно от основного графического файла, можно хранить описание и
        дату. Проблема заключается в том, что файловая структура будет сильно
        разрастаться при каждом добавлении фотографии на сайт.</para>

      <!-- @ENGLISH {{{
      <para>Now consider the same website deployed in a way that makes
        use of Subversion's file properties.  Imagine having a single
        image file, <filename>image123.jpg</filename>, and then
        properties set on that file named <literal>caption</literal>,
        <literal>datestamp</literal>, and even
        <literal>thumbnail</literal>.  Now your working copy directory
        looks much more manageable&mdash;in fact, it looks to the
        casual browser like there are nothing but image files in it.
        But your automation scripts know better.  They know that they
        can use <command>svn</command> (or better yet, they can use
        the Subversion language bindings&mdash;see <xref
        linkend="svn.developer.usingapi.otherlangs" />) to dig out the
        extra information that your site needs to display without
        having to read an index file or play path manipulation
        games.</para>
      @ENGLISH }}} -->
      <para>Теперь представим, как можно организовать работу того же веб-сайта,
        используя Subversion-свойства файлов. Допустим, имеется файл 
        <filename>image123.jpg</filename> и у этого файла установлены свойства
        <literal>caption</literal>, <literal>datestamp</literal> и даже
        <literal>thumbnail</literal>. В этом случае рабочая копия выглядит
        гораздо нагляднее. Фактически, она выглядит так, как будто содержит
        только сами графические файлы, и ничего больше.
        Однако ваши скрипты автоматизации знают, что с помощью 
        <command>svn</command> (а еще лучше языковой обвязки
        Subversion &mdash; см. <xref
        linkend="svn.developer.usingapi.otherlangs" />) можно получить
        дополнительную, необходимую для показа на сайте информацию,
        не занимаясь чтением индексного файла или манипуляциями с 
        путями.</para>

      <!-- @ENGLISH {{{
      <para>Custom revision properties are also frequently used.  One
        common such use is a property whose value contains an issue
        tracker ID with which the revision is associated, perhaps
        because the change made in that revision fixes a bug filed in
        the tracker issue with that ID.  Other uses include hanging
        more friendly names on the revision&mdash;it might be hard to
        remember that revision 1935 was a fully tested revision.  But
        if there's, say, a <literal>test-results</literal> property on
        that revision with a value <literal>all passing</literal>,
        that's meaningful information to have.</para>
      @ENGLISH }}} -->
      <para>Не менее часто используются пользовательские свойства правок.
        Одним из типичных примеров является свойство, хранящее ID
        записи в трекере, с которой сопоставлена данная правка &mdash; 
        например, потому что внесенные в правке изменения 
        исправляют ошибку, зафиксированную в трекере с данным ID.
        Другие варианты использования свойств правок &mdash; задание правке 
        более содержательного имени. Нелегко запомнить, что, к примеру, 
        правка 1935 полностью протестирована! Если же, скажем, задать свойству
        <literal>результаты тестирования</literal> в этой правке значение 
        <literal>пройдены все тесты</literal>, получится
        абсолютно четкая информация.</para>

      <sidebar>
      <!-- @ENGLISH {{{
        <title>Searchability (or, Why <emphasis>Not</emphasis>
          Properties)</title>
      @ENGLISH }}} -->
        <title>Эффективность поиска (или Что <emphasis>препятствует</emphasis>
          использованию свойств)</title>

      <!-- @ENGLISH {{{
        <para>For all their utility, Subversion properties&mdash;or,
          more accurately, the available interfaces to them&mdash;have
          a major shortcoming which diminishes their practicality.
          While it is a simple matter to set a custom property,
          <emphasis>finding</emphasis> that property later is whole
          different ball of wax.</para>
      @ENGLISH }}} -->
        <para>Несмотря на всю пользу, свойства Subversion &mdash; или,
          точнее, доступные способы обращения к ним &mdash; обладают
          большим недостатком, снижающим их практическую ценность.
          Дело в том, что пользовательские свойства очень легко задать, 
          но их последующий <emphasis>поиск</emphasis> 
          может оказаться серьезной проблемой.</para>

      <!-- @ENGLISH {{{
        <para>Trying to locate a custom revision property generally
          involves performing a linear walk across all the revisions
          of the repository, asking of each revision, "Do you have the
          property I'm looking for?"  Trying to find a custom
          versioned property is painful, too, and often involves a
          recursive <command>svn propget</command> across an entire
          working copy.  In your situation, that might not be as bad
          as a linear walk across all revisions.  But it certainly
          leaves much to be desired in terms of both performance and
          likelihood of success, especially if the scope of your
          search would require a working copy from the root of your
          repository.</para>
      @ENGLISH }}} -->
        <para>Обращение к пользовательскому свойству правки
          обычно приводит к последовательному просмотру всех правок 
          хранилища. При этом каждая правка опрашивается: "Есть ли у тебя
          свойство, которое я ищу?" Поиск версионированного 
          пользовательского свойства также оказывается затратной, и часто
          приводит к рекурсивному вызову <command>svn propget</command> 
          по всей рабочей копии.  В вашей ситуации это, возможно, окажется
          не таким плохим вариантом, как последовательный просмотр всех правок.
          Но, в любом случае, такой подход оставляет желать лучшего 
          как с точки зрения производительности, так и с точки зрения 
          вероятности успеха, особенно если поиск потребует получения 
          рабочей копии корневой папки хранилища.</para>

      <!-- @ENGLISH {{{
        <para>For this reason, you might choose&mdash;especially in
          the revision property use-case&mdash;to simply add your
          metadata to the revision's log message, using some
          policy-driven (and perhaps programmatically-enforced)
          formatting that is designed to be quickly parsed from the
          output of <command>svn log</command>.  It is quite common to
          see in Subversion log messages the likes of:</para>
      @ENGLISH }}} -->
        <para>По этой причине стоит подумать над тем (в особенности,
          в случае со свойствами правок), чтобы просто добавить ваши 
          метаданные в лог-сообщение правки, придерживаясь при этом
          некоторого заранее оговоренного (и, возможно, программно 
          поддерживаемого) форматирования, допускающего впоследствии
          легкий разбор и анализ вывода команды <command>svn log</command>.
          В Subversion можно частенько увидеть такие характерные
          лог-сообщения:</para>

        <programlisting>
Issue(s): IZ2376, IZ1919
Reviewed by:  sally

This fixes a nasty segfault in the wort frabbing process
&hellip;
</programlisting>

      <!-- @ENGLISH {{{
        <para>But here again lies some misfortune.  Subversion doesn't
          yet provide a log message templating mechanism, which would
          go a long way toward helping users be consistent with the
          formatting of their log-embedded revision metadata.</para>
      @ENGLISH }}} -->
        <para>Но и здесь вас поджидает одна неприятность.  Subversion пока 
          еще не поддерживает механизма задания шаблонов для лог-сообщений,
          поэтому вам придется довольно долго разъяснять пользователям, 
          как им правильно форматировать сообщения, включая в них  
          метаданные правки.</para>

      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.manip">
      <!-- @ENGLISH {{{
      <title>Manipulating Properties</title>
      @ENGLISH }}} -->
      <title>Использование свойств</title>

      <!-- @ENGLISH {{{
      <para>The <command>svn</command> command affords a few ways to
        add or modify file and directory properties.  For properties
        with short, human-readable values, perhaps the simplest way to
        add a new property is to specify the property name and value
        on the command-line of the <command>propset</command>
        subcommand.</para>
      @ENGLISH }}} -->
      <para>Команда <command>svn</command> предоставляет несколько
        способов добавления или изменения свойств файлов и каталогов.
        Чтобы добавить свойство с коротким читаемым значением, наверное, 
        проще всего указать его имя и значение в командной строке
        подкоманды <command>propset</command>.</para>

      <screen>
$ svn propset copyright '(c) 2006 Red-Bean Software' calc/button.c
property 'copyright' set on 'calc/button.c'
$
</screen>

      <!-- @ENGLISH {{{
      <para>But we've been touting the flexibility that Subversion
        offers for your property values.  And if you are planning to
        have a multi-line textual, or even binary, property value, you
        probably do not want to supply that value on the command-line.
        So the <command>propset</command> subcommand takes a
        <option>-&#64738;-file</option> (<option>-F</option>) option for
        specifying the name of
        a file which contains the new property value.</para>
      @ENGLISH }}} -->
      <para>Однако мы уже знаем о том, насколько гибкими могут быть 
        свойства Subversion. И если вам необходимо задать свойству
        многострочное текстовое или даже бинарное значение, передавать
        его через командную строку будет неудобно. Для
        таких случаев команда <command>propset</command> имеет
        параметр <option>--file</option> (<option>-F</option>), 
        позволяющий указать имя файла с новым значением свойства.</para>

      <screen>
$ svn propset license -F /path/to/LICENSE calc/button.c
property 'license' set on 'calc/button.c'
$
</screen>

      <!-- @ENGLISH {{{
      <para>There are some restrictions on the names you can use for
        properties.  A property name must start with a letter, a colon
        (<literal>:</literal>), or an underscore
        (<literal>_</literal>); after that, you can also use digits,
        hyphens (<literal>-</literal>), and periods
        (<literal>.</literal>).
        <footnote>
          <para>If you're familiar with XML, this is pretty much the
            ASCII subset of the syntax for XML "Name".</para>
          </footnote>
      </para>
      @ENGLISH }}} -->
      <para>На имена свойств накладывается ряд ограничений. Имя должно
        начинаться с буквы, двоеточия (<literal>:</literal>) или подчеркивания
        (<literal>_</literal>); после них можно использовать цифры, тире
        (<literal>-</literal>) и точки (<literal>.</literal>).
          <footnote>
            <para>Если вы знакомы с XML, то синтаксис XML "Name" допускает
            практически то же подмножество символов ASCII.</para>
          </footnote>
      </para>

      <!-- @ENGLISH {{{
      <para>In addition to the <command>propset</command> command, the
        <command>svn</command> program supplies the
        <command>propedit</command> command.  This command uses the
        configured editor program (see <xref
        linkend="svn.advanced.confarea.opts.config" />) to add or
        modify properties.  When you run the command,
        <command>svn</command> invokes your editor program on a
        temporary file that contains the current value of the property
        (or which is empty, if you are adding a new property).  Then,
        you just modify that value in your editor program until it
        represents the new value you wish to store for the property,
        save the temporary file, and then exit the editor program.  If
        Subversion detects that you've actually changed the existing
        value of the property, it will accept that as the new property
        value.  If you exit your editor without making any changes, no
        property modification will occur.</para>
      @ENGLISH }}} -->
      <para>Кроме команды <command>propset</command>,
        <command>svn</command> предлагает команду <command>propedit</command>.
        Эта команда использует для добавления или изменения свойства заданную
        программу-редактор (см. <xref
        linkend="svn.advanced.confarea.opts.config" />). При выполнении
        команды <command>svn</command> вызывает редактор с временным файлом,
        содержащим текущее значение свойства (или с пустым файлом, если
        добавляется новое свойство). Затем вы просто изменяете в редакторе
        значение, пока оно не станет таким, каким вы хотели бы его видеть,
        сохраняете временный файл и выходите из редактора. Если Subversion
        обнаружит, что вы действительно изменили существующее значение
        свойства, будет записано новое значение. Если вы вышли из
        редактора, не внеся никаких изменений, модификации свойства не
        произойдет.</para>

      <screen>
$ svn propedit copyright calc/button.c  ### exit the editor without changes
No changes to property 'copyright' on 'calc/button.c'
$
</screen>

      <!-- @ENGLISH {{{
      <para>We should note that, as with other <command>svn</command>
        subcommands, those related to properties can act on multiple
        paths at once.  This enables you to modify properties on whole
        sets of files with a single command.  For example, we could
        have done:</para>
      @ENGLISH }}} -->
      <para>Обращаем ваше внимание на то, что, подобно другим командам
        <command>svn</command>, команды, относящиеся к свойствам,
        могут применяться к нескольким путям за раз. Это дает возможность
        одной командой изменять свойства целого набора файлов. Например,
        можно сделать вот так:</para>

      <screen>
$ svn propset copyright '(c) 2006 Red-Bean Software' calc/*
property 'copyright' set on 'calc/Makefile'
property 'copyright' set on 'calc/button.c'
property 'copyright' set on 'calc/integer.c'
&hellip;
$
</screen>

      <!-- @ENGLISH {{{
      <para>All of this property adding and editing isn't really very
        useful if you can't easily get the stored property value.  So
        the <command>svn</command> program supplies two subcommands
        for displaying the names and values of properties stored on
        files and directories.  The <command>svn proplist</command>
        command will list the names of properties that exist on a
        path.  Once you know the names of the properties on the node,
        you can request their values individually using <command>svn
        propget</command>.  This command will, given a path (or set of
        paths) and a property name, print the value of the property to
        the standard output stream.</para>
      @ENGLISH }}} -->
      <para>Все эти добавления и редактирования свойств были бы не слишком 
        полезны, если бы нельзя было просто узнать значение свойства. 
        Чтобы посмотреть имена и значения свойств, заданных для файлов и 
        каталогов, в <command>svn</command> есть две подкоманды.
        Команда <command>svn proplist</command> перечисляет существующие
        для указанного пути свойства. После того как вы узнаете имя свойства,
        с помощью <command>svn propget</command> можно запросить его
        значение. Эта команда выведет в стандартный поток ввода-вывода
        значение свойства для элемента по указанному пути (или путям) и с
        указанным именем.</para>

      <screen>
$ svn proplist calc/button.c
Properties on 'calc/button.c':
  copyright
  license
$ svn propget copyright calc/button.c
(c) 2006 Red-Bean Software
</screen>

      <!-- @ENGLISH {{{
      <para>There's even a variation of the
        <command>proplist</command> command that will list both the
        name and value of all of the properties.  Simply supply the
        <option>-&#64738;-verbose</option> (<option>-v</option>) option.</para>
      @ENGLISH }}} -->
      <para>Существует даже вариант команды <command>proplist</command>,
        перечисляющий как имена, так и значения свойств. Нужно просто
        добавить параметр <option>--verbose</option>
        (<option>-v</option>).</para>

      <screen>
$ svn proplist --verbose calc/button.c
Properties on 'calc/button.c':
  copyright : (c) 2006 Red-Bean Software
  license : ================================================================
Copyright (c) 2006 Red-Bean Software.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

1. Redistributions of source code must retain the above copyright
notice, this list of conditions, and the recipe for Fitz's famous
red-beans-and-rice.
&hellip;
</screen>

      <!-- @ENGLISH {{{
      <para>The last property-related subcommand is
        <command>propdel</command>.  Since Subversion allows you to
        store properties with empty values, you can't remove a
        property altogether using <command>propedit</command> or
        <command>propset</command>.  For example, this command will
        <emphasis>not</emphasis> yield the desired effect:</para>
      @ENGLISH }}} -->
      <para>Последняя команда, относящаяся к свойствам &mdash; 
        <command>propdel</command>. Несмотря на то, что Subversion
        позволяет сохранять свойства с пустыми значениями, полностью
        удалить свойство с помощью <command>propedit</command> или
        <command>propset</command> нельзя. Например, такая команда
        не даст желаемого эффекта:</para>

      <screen>
$ svn propset license '' calc/button.c
property 'license' set on 'calc/button.c'
$ svn proplist --verbose calc/button.c
Properties on 'calc/button.c':
  copyright : (c) 2006 Red-Bean Software
  license :
$
</screen>

      <!-- @ENGLISH {{{
      <para>You need to use the <command>propdel</command> subcommand
        to delete properties altogether.  The syntax is similar to the
        other property commands:</para>
      @ENGLISH }}} -->
      <para>Для полного удаления свойств необходимо пользоваться
        подкомандой <command>propdel</command>. Ее синтаксис такой же,
        как и у других команд для работы со свойствами:</para>

      <screen>
$ svn propdel license calc/button.c
property 'license' deleted from 'calc/button.c'.
$ svn proplist --verbose calc/button.c
Properties on 'calc/button.c':
  copyright : (c) 2006 Red-Bean Software
$
</screen>

      <!-- @ENGLISH {{{
      <para>Remember those unversioned revision properties?  You can
        modify those, too, using the same <command>svn</command>
        subcommands that we just described.  Simply add the
        <option>-&#64738;-revprop</option> command-line parameter, and specify
        the revision whose property you wish to modify.  Since
        revisions are global, you don't need to specify a target path
        to these property-related commands so long as you are
        positioned in a working copy of the repository whose
        revision property you wish to modify.  Otherwise, you can
        simply provide the URL of any path in the repository of
        interest (including the repository's root URL).  For example,
        you might want to replace the commit log message of an
        existing revision.
        <footnote>
          <para>Fixing spelling errors, grammatical gotchas, and
            <quote>just-plain-wrongness</quote> in commit log
            messages is perhaps the most common use case for the
            <option>-&#64738;-revprop</option> option.</para>
        </footnote>
        If your current working directory is part of a working copy of
        your repository, you can simply run the
        <command>svn propset</command> command with no target path:</para>
      @ENGLISH }}} -->
      <para>Помните, мы говорили о неверсионированных свойствах
        правок? Их тоже можно изменять с помощью <command>svn</command>.
        Просто добавьте параметр командной строки <option>--revprop</option>
        и укажите правку, свойство которой вы хотите изменить. Поскольку
        правки глобальны, указывать пути не требуется до тех пор, пока 
        вы находитесь в рабочей копии того хранилища, свойство правки в
        котором вам нужно изменить. В противном случае, нужно просто указать
        URL любого пути в интересующем вас хранилище (в том числе это может 
        быть и корневой URL хранилища). Например, вы можете заменить
        лог-сообщение фиксации в существующей правке. 
        <footnote>
        <para>Исправление в лог-сообщениях орфографических, грамматических
        ошибок, <quote>просто ошибочных</quote> записей &mdash; наверное,
        самый распространенный случай использования параметра
        <option>--revprop</option>.</para></footnote>
        Если текущий рабочий каталог является частью рабочей копии хранилища, 
        можно просто выполнить команду <command>svn propset</command>, 
        не указывая целевой путь:</para>

      <screen>
$ svn propset svn:log '* button.c: Fix a compiler warning.' -r11 --revprop
property 'svn:log' set on repository revision '11'
$
</screen>

      <!-- @ENGLISH {{{
      <para>But even if you haven't checked out a working copy from
        that repository, you can still affect the property change by
        providing the repository's root URL:</para>
      @ENGLISH }}} -->
      <para>Но даже если вы не выгружали из хранилища рабочую копию, 
        можно изменить свойство, указав корневой URL хранилища:</para>

      <screen>
$ svn propset svn:log '* button.c: Fix a compiler warning.' -r11 --revprop \
              http://svn.example.com/repos/project
property 'svn:log' set on repository revision '11'
$
</screen>

      <!-- @ENGLISH {{{
      <para>Note that the ability to modify these unversioned
        properties must be explicitly added by the repository
        administrator (see <xref linkend="svn.reposadmin.create.hooks" />).
        Since the properties aren't versioned, you run the risk of
        losing information if you aren't careful with your edits.
        The repository administrator can setup methods to protect
        against this loss, and by default, modification of
        unversioned properties is disabled.</para>
      @ENGLISH }}} -->
      <para>Обратите внимание на то, что изменение этих
        неверсионированных свойств должно быть явно разрешено
        администратором (см. <xref linkend="svn.reposadmin.create.hooks" />). 
        Учитывая то, что свойства не версионируются, при неаккуратном 
        редактировании вы рискуете потерять информацию. Чтобы предотвратить 
        потерю информации,
        администратор хранилища может принять меры предосторожности, и
        по умолчанию изменение неверсионированных свойств
        запрещено.</para>

      <tip>
      <!-- @ENGLISH {{{
        <para>Users should, where possible, use <command>svn
          propedit</command> instead of <command>svn
          propset</command>.  While the end result of the commands is
          identical, the former will allow them to see the current
          value of the property they are about to change, which helps
          them to verify that they are, in fact, making the change
          they think they are making.  This is especially true when
          modifying unversioned revision properties.  Also, it is
          significantly easier to modify multiline property values in
          a text editor than at the command line.</para>
      @ENGLISH }}} -->
        <para>Пользователям следует, по возможности, пользоваться <command>svn
          propedit</command> вместо <command>svn
          propset</command>.  Хотя конечный результат обеих команд будет 
          одинаков, первая позволит увидеть текущее значение свойства перед
          изменением, и таким образом удостовериться, что вносятся именно 
          те изменения, которые были задуманы. В особенности это справедливо
          для модификации неверсионированных свойств правок. Да и изменять
          свойства с многострочными значениями гораздо проще в текстовом 
          редакторе, а не в командной строке.</para>
      </tip>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.workflow">
      <!-- @ENGLISH {{{
      <title>Properties and the Subversion Workflow</title>
      @ENGLISH }}} -->
      <title>Свойства и рабочий цикл Subversion</title>

      <!-- @ENGLISH {{{
      <para>Now that you are familiar with all of the
        property-related <command>svn</command> subcommands, let's see
        how property modifications affect the usual Subversion
        workflow.  As we mentioned earlier, file and directory
        properties are versioned, just like your file contents.  As a
        result, Subversion provides the same opportunities for
        merging&mdash;in cleanly or conflicting fashions&mdash;someone
        else's modifications into your own.</para>
      @ENGLISH }}} -->
      <para>Теперь, когда вы познакомились со всеми командами 
        <command>svn</command>, имеющими отношение к свойствам, 
        давайте посмотрим,
        как изменения свойств влияют на привычный порядок работы с
        Subversion. Как мы уже говорили, свойства файлов и каталогов 
        версионированы аналогично содержимому файлов. Поэтому
        Subversion предоставляет те же возможности по слиянию
        &mdash; в случае конфликтных ситуаций &mdash; чужих изменений
        с вашими собственными.</para>

      <!-- @ENGLISH {{{
      <para>And as with file contents, your property changes are local
        modifications, only made permanent when you commit them to the
        repository with <command>svn commit</command>.  Your property
        changes can be easily unmade, too&mdash;the <command>svn
        revert</command> command will restore your files and
        directories to their un-edited states, contents, properties,
        and all.  Also, you can receive interesting information about
        the state of your file and directory properties by using the
        <command>svn status</command> and <command>svn diff</command>
        commands.</para>
      @ENGLISH }}} -->
      <para>Так же как и в случае с содержимым файлов, изменения свойств
        являются локальной модификацией и становятся постоянными только при их
        фиксации в хранилище с помощью <command>svn commit</command>.
        Изменение свойств можно легко отменить &mdash; команда
        <command>svn revert</command> восстановит файлы и каталоги
        в их первоначальное состояние, включая содержимое, свойства и
        все остальное. Кроме того, интересную информацию о состоянии
        свойств файлов и каталогов можно получить с помощью команд
        <command>svn status</command> и <command>svn
        diff</command>.</para>

      <screen>
$ svn status calc/button.c
 M     calc/button.c
$ svn diff calc/button.c
Property changes on: calc/button.c
___________________________________________________________________
Name: copyright
   + (c) 2006 Red-Bean Software

$
</screen>

      <!-- @ENGLISH {{{
      <para>Notice how the <command>status</command> subcommand
        displays <literal>M</literal> in the second column instead of
        the first.  That is because we have modified the properties on
        <filename>calc/button.c</filename>, but not modified its
        textual contents.  Had we changed both, we would have seen
        <literal>M</literal> in the first column, too (see <xref
        linkend="svn.tour.cycle.examine.status" />).</para>
      @ENGLISH }}} -->
      <para>Обратите внимание на то, что подкоманда <command>status</command>
        показала <literal>M</literal> не в первой, а во второй колонке.
        Это произошло потому, что в <filename>calc/button.c</filename> 
        изменились свойства, а не текстовое содержимое. Если бы мы изменили 
        и то и другое, в первой колонке также стояла бы буква 
        <literal>M</literal> (см. 
        <xref linkend="svn.tour.cycle.examine.status" />).</para>

      <sidebar>
        <!-- @ENGLISH {{{
        <title>Property Conflicts</title>

        <para>As with file contents, local property modifications can
          conflict with changes committed by someone else.  If you
          update your working copy directory and receive property
          changes on a versioned object that clash with your own,
          Subversion will report that the object is in a conflicted
          state.</para>
        @ENGLISH }}} -->
        <title>Конфликты свойств</title>

        <para>Как и в случае с содержимым файлов, локальные
          модификации свойств могут конфликтовать с изменениями,
          зафиксированными кем-то другим. При обновлении каталога 
          рабочей копии и получении изменений свойств версионированного
          объекта, которые идут вразрез с вашими собственными, Subversion
          сообщит о конфликтном состоянии объекта.</para>

        <screen>
% svn update calc
M  calc/Makefile.in
 C calc/button.c
Updated to revision 143.
$
</screen>

        <!-- @ENGLISH {{{
        <para>Subversion will also create, in the same directory as
          the conflicted object, a file with a
          <filename>.prej</filename> extension which contains the
          details of the conflict.  You should examine the contents of
          this file so you can decide how to resolve the conflict.
          Until the conflict is resolved, you will see a
          <literal>C</literal> in the second column of <command>svn
          status</command> output for that object, and attempts to
          commit your local modifications will fail.</para>
        @ENGLISH }}} -->
        <para>В каталоге с конфликтующим объектом Subversion
          создаст файл с расширением <filename>.prej</filename>,
          содержащий подробную информацию о конфликте. Для разрешения 
          конфликта необходимо посмотреть содержимое этого файла. Пока
          не будет решен конфликт, во второй колонке вывода
          команды <command>svn status</command> будет присутствовать
          буква <literal>C</literal>, а попытки фиксации локальных
          изменений будут отклоняться.</para>

        <screen>
$ svn status calc
 C     calc/button.c
?      calc/button.c.prej
$ cat calc/button.c.prej
prop 'linecount': user set to '1256', but update set to '1301'.
$
</screen>

        <!-- @ENGLISH {{{
        <para>To resolve property conflicts, simply ensure that the
          conflicting properties contain the values that they should,
          and then use the <command>svn resolved</command> command to
          alert Subversion that you have manually resolved the
          problem.</para>
        @ENGLISH }}} -->
        <para>Для разрешения конфликтов свойств просто убедитесь,
          что свойства имеют нужные значения, после чего с помощью команды
          <command>svn resolved</command> уведомите Subversion о том, что
          вы решили проблему вручную.</para>

      </sidebar>

      <!-- @ENGLISH {{{
      <para>You might also have noticed the non-standard way that
        Subversion currently displays property differences.  You can
        still run <command>svn diff</command> and redirect the output
        to create a usable patch file.  The <command>patch</command>
        program will ignore property patches&mdash;as a rule, it
        ignores any noise it can't understand.  This does
        unfortunately mean that to fully apply a patch generated by
        <command>svn diff</command>, any property modifications will
        need to be applied by hand.</para>
      @ENGLISH }}} -->
      <para>Кроме того, нужно помнить о нестандартном подходе, используемом
        Subversion при выводе различий для свойств. Безусловно, можно
        запустить <command>svn diff</command> и перенаправить вывод для создания
        работоспособного патч-файла. Но программа <command>patch</command>
        будет просто игнорировать различия свойств &mdash; как правило,
        она игнорирует любой мусор, который не может обработать. К сожалению,
        это означает, что для полного применения патча, сгенерированного
        <command>svn diff</command>, изменения свойств придется вносить 
        вручную.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.auto">
      <!-- @ENGLISH {{{
      <title>Automatic Property Setting</title>
        @ENGLISH }}} -->
      <title>Автоматическая установка свойств</title>

      <!-- @ENGLISH {{{
      <para>Properties are a powerful feature of Subversion, acting as
        key components of many Subversion features discussed elsewhere
        in this and other chapters&mdash;textual diff and merge
        support, keyword substitution, newline translation, etc.  But
        to get the full benefit of properties, they must be set on the
        right files and directories.  Unfortunately, that can be a
        step easily forgotten in the routine of things, especially
        since failing to set a property doesn't usually result in an
        obvious error condition (at least compared to, say, failing to
        add a file to version control).  To help your properties get
        applied to the places that need them, Subversion provides a
        couple of simple but useful features.</para>
        @ENGLISH }}} -->
      <para>Поддержка свойств &mdash; мощная функциональная особенность
        Subversion. Свойства служат базовым механизмом для реализации многих 
        других функций Subversion, обсуждаемых в книге &mdash; 
        поддержки текстового поиска различий и слияния, 
        подстановки ключевых слов, трансляции символов перевода
        строки и т. д. Однако, чтобы получить реальную выгоду от свойств,
        их нужно задавать для соответствующих файлов и каталогов. К сожалению,
        среди повседневных забот об этом очень легко забыть, особенно 
        учитывая то, что неустановка значения свойства обычно не приводит
        к явно заметным ошибкам (по сравнению, скажем, с 
        недобавлением файла под версионный контроль). Чтобы помочь в
        установке свойств для нужных элементов, Subversion 
        обеспечивает пару простых, но полезных функций.</para>

      <!-- @ENGLISH {{{
      <para>Whenever you introduce a file to version control using the
        <command>svn add</command> or <command>svn import</command>
        commands, Subversion tries to assist by setting some common
        file properties automatically.  First, on operating systems
        whose filesystems support an execute permission bit,
        Subversion will automatically set the
        <literal>svn:executable</literal> property on newly added or
        imported files whose execute bit is enabled.  (See <xref
        linkend="svn.advanced.props.special.executable" /> for more
        about this property.)  Secondly, it runs a very basic
        heuristic to determine if that file contains human-readable
        content.  If not, Subversion will automatically set the
        <literal>svn:mime-type</literal> property on that file to
        <literal>application/octet-stream</literal> (the generic
        <quote>this is a collection of bytes</quote> MIME type).  Of
        course, if Subversion guesses incorrectly, or if you wish to
        set the <literal>svn:mime-type</literal> property to something
        more precise&mdash;perhaps <literal>image/png</literal> or
        <literal>application/x-shockwave-flash</literal>&mdash;you can
        always remove or edit that property.  (For more on
        Subversion's use of MIME types, see <xref
        linkend="svn.advanced.props.special.mime-type" />.)</para>
        @ENGLISH }}} -->
      <para>При каждом добавлении файла под версионный контроль с помощью
        команд <command>svn add</command> или <command>svn import</command>
        Subversion пытается автоматически установить несколько базовых 
        свойств файлов. Во-первых, в операционных системах, файловые
        системы которых поддерживают бит разрешения выполнения, Subversion
        автоматически задает свойство <literal>svn:executable</literal> 
        для вновь добавленных или импортированных файлов, у которых
        этот бит установлен. (Обратитесь к <xref
        linkend="svn.advanced.props.special.executable" /> за 
        дополнительной информации об этом свойстве.)  Во-вторых, 
        Subversion выполняет очень простую эвристическую процедуру, 
        чтобы определить, имеет ли файл читаемое содержимое. Если это 
        не так, Subversion автоматически устанавливает 
        свойство <literal>svn:mime-type</literal> этого файла в значение 
        <literal>application/octet-stream</literal> (это базовый 
        MIME-тип, обозначающий <quote>набор байтов</quote>).  Конечно,
        если Subversion угадает тип файла неправильно, или если вы 
        пожелаете присвоить свойству <literal>svn:mime-type</literal> 
        более точное значение &mdash; например, <literal>image/png</literal>
        или <literal>application/x-shockwave-flash</literal> &mdash; 
        вы всегда можете удалить или отредактировать это свойство. 
        (За дополнительной информацией об использовании MIME-типов 
        в Subversion обратитесь к 
        <xref linkend="svn.advanced.props.special.mime-type" />.)</para>

      <!-- @ENGLISH {{{
      <para>Subversion also provides, via its runtime configuration
        system (see <xref linkend="svn.advanced.confarea" />), a more
        flexible automatic property setting feature which allows you
        to create mappings of filename patterns to property names and
        values.  Once again, these mappings affect adds and imports,
        and not only can override the default MIME type decision made
        by Subversion during those operations, but can also set
        additional Subversion or custom properties, too.  For example,
        you might create a mapping that says that any time you add
        JPEG files&mdash;ones that match the pattern
        <literal>*.jpg</literal>&mdash;Subversion should automatically
        set the <literal>svn:mime-type</literal> property on those
        files to <literal>image/jpeg</literal>.  Or perhaps any files
        that match <literal>*.cpp</literal> should have
        <literal>svn:eol-style</literal> set to
        <literal>native</literal>, and <literal>svn:keywords</literal>
        set to <literal>Id</literal>.  Automatic property support is
        perhaps the handiest property related tool in the Subversion
        toolbox.  See <xref
        linkend="svn.advanced.confarea.opts.config"/> for more about
        configuring that support.</para>
        @ENGLISH }}} -->
      <para>Через собственную систему конфигурирования среды исполнения 
        (см. <xref linkend="svn.advanced.confarea" />) Subversion
        также поддерживает более гибкую возможность автоматической 
        установки свойств, которая позволяет задавать соответствия
        между масками имен файлов и именами и значениями свойств.
        Еще раз: эти соответствия воздействуют на добавление и импорт,
        и могут не только переопределять решение о MIME-типе по 
        умолчанию, принимаемое Subversion в ходе этих операций,
        но и устанавливать другие стандартные или пользовательские
        свойства. Например, вы могли бы задать соответствие, чтобы 
        при каждом добавлении JPEG-файла &mdash; то есть
        элемента, соответствующего маске <literal>*.jpg</literal> &mdash;
        Subversion автоматически присваивал бы свойству
        <literal>svn:mime-type</literal> значение 
        <literal>image/jpeg</literal>. Или, к примеру, для всех файлов,
        соответствующих маске <literal>*.cpp</literal>, свойство 
        <literal>svn:eol-style</literal> устанавливалось бы в 
        <literal>native</literal>, а <literal>svn:keywords</literal>
        &mdash; в <literal>Id</literal>.  Поддержка автоматических свойств
        &mdash; это, пожалуй, наиболее удобный инструмент Subversion
        в части работы со свойствами среди всего набора доступных средств. 
        См. <xref linkend="svn.advanced.confarea.opts.config"/> для
        дополнительной информации о настройке такой поддержки.</para>

    </sect2>     
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.props.file-portability">
      <!-- @ENGLISH {{{
    <title>File Portability</title>
        @ENGLISH }}} -->
    <title>Переносимость файлов</title>

      <!-- @ENGLISH {{{
    <para>Fortunately for Subversion users who routinely find
      themselves on different computers with different operating
      systems, Subversion's command-line program behaves almost
      identically on all those systems.  If you know how to wield
      <command>svn</command> on one platform, you know how to wield it
      everywhere.</para>
        @ENGLISH }}} -->
    <para>К радости пользователей Subversion, регулярно работающих
      с различными компьютерами и операционными системами,
      утилита командной строки Subversion везде работает практически 
      одинаково. Если вы знаете, как обращаться с <command>svn</command> 
      на одной платформе, вы справитесь с ней и на любой другой 
      платформе.</para>

      <!-- @ENGLISH {{{
    <para>However, the same is not always true of other general classes
      of software, or of the actual files you keep in Subversion.  For
      example, on a Windows machine, the definition of a <quote>text
      file</quote> would be similar to that used on a Linux box, but
      with a key difference&mdash;the character sequences used to mark
      the ends of the lines of those files.  There are other
      differences, too.  Unix platforms have (and Subversion supports)
      symbolic links; Windows does not.  Unix platforms use filesystem
      permission to determine executability; Windows uses filename
      extensions.</para>
        @ENGLISH }}} -->
    <para>Однако, это не всегда справедливо для других классов  
      программного обеспечения, а также для конкретных файлов, хранящихся
      в Subversion. Например, на компьютере под управлением
      Windows <quote>текстовые файлы</quote> выглядят почти так же
      как и в Linux, но при этом есть одно существенное отличие &mdash; 
      последовательность символов, используемая для маркировки
      конца строки в таких файлах.  Имеются и другие различия. 
      Unix-платформы имеют символьные ссылки (и Subversion их 
      поддерживает), а Windows &mdash; не имеет. На Unix-платформах
      исполнимость файла определяется с помощью прав доступа на уровне
      файловой системы; Windows использует для этого
      расширения имен файлов.</para>

      <!-- @ENGLISH {{{
    <para>Because Subversion is in no position to unite the whole
      world in common definitions and implementations of all of these
      things, the best it can do is to try to help make your life
      simpler when you need to work with your versioned files and
      directories on multiple computers and operating systems.  This
      section describes some of the ways Subversion does this.</para>
        @ENGLISH }}} -->
    <para>Subversion не ставит цели подчинить весь мир 
      некоторым общим определениям и реализовать все на свете.
      Поэтому максимум, что она может сделать &mdash; попытаться 
      упростить жизнь при работе с версионированными файлами и каталогами 
      на различных компьютерах и операционных системах.
      Далее мы опишем, каким образом Subversion
      достигает этой цели.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.special.mime-type">
      <!-- @ENGLISH {{{
      <title>File Content Type</title>
        @ENGLISH }}} -->
      <title>Тип содержимого файла</title>

      <!-- @ENGLISH {{{
      <para>Subversion joins the ranks of the many applications which
        recognize and make use of Multipurpose Internet Mail
        Extensions (MIME) content types.  Besides being a
        general-purpose storage location for a file's content type,
        the value of the <literal>svn:mime-type</literal> file
        property determines some behavioral characteristics of
        Subversion itself.</para>
        @ENGLISH }}} -->
      <para>Subversion принадлежит к многочисленному семейству
        приложений, распознающих и использующих для типизации содержимого
        многоцелевые расширения интернет-почты (Multipurpose Internet 
        Mail Extensions &mdash; MIME). Свойство
        <literal>svn:mime-type</literal> не только является универсальным
        местом хранения информации о типе содержимого файла,
        но и определяет некоторые особенности поведения Subversion.</para>

      <sidebar>
      <!-- @ENGLISH {{{
        <title>Identifying File Types</title>
        @ENGLISH }}} -->
        <title>Определение типа файла</title>
    
      <!-- @ENGLISH {{{
        <para>Software programs on most modern operating systems make
          assumptions about the type and format of the contents of a
          file by the file's name, specifically its file extension.
          For example, files whose names end in
          <filename>.txt</filename> are generally assumed to be
          human-readable, able to be understood by simple perusal
          rather than requiring complex processing to decipher.  Files
          whose names end in <filename>.png</filename>, on the other
          hand, are assumed to be of the Portable Network Graphics
          type&mdash;not human-readable at all, and sensible only when
          interpreted by software which understands the PNG format and
          can render the information in that format as a raster
          image.</para>
        @ENGLISH }}} -->
        <para>Программы, работающие в современных операционных
          системах, делают предположение о типе и формате содержимого файла,
          исходя из имени файла, в частности, его расширения.
          Например, файлы, имена которых заканчиваются на 
          <filename>.txt</filename>, обычно рассматриваются как читаемые
          текстовые файлы; для понимания их достаточно внимательно
          прочитать, отсутствует необходимость в сложных процедурах
          расшифровывания. Файлы, имена которых заканчиваются на 
          <filename>.png</filename>, напротив, рассматриваются как файлы
          переносимой сетевой графики (Portable Network Graphics); они
          совершенно не читаемы человеком и воспринимаются только в 
          случае их интерпретации программой, понимающей формат PNG и 
          способной на основе информации в этом формате сформировать 
          растровое изображение.</para>

      <!-- @ENGLISH {{{
        <para>Unfortunately, some of those extensions have changed
          meanings over time.  When personal computers first appeared,
          a file named <filename>README.DOC</filename> would have
          almost certainly been a plaintext file, just like today's
          <filename>.txt</filename> files.  But by the mid-1990's, you
          could almost bet that a file of that name would not be a
          plaintext file at all, but instead a Microsoft Word document
          with a proprietary, non-human-readable format.  But this
          change didn't occur overnight&mdash;there was certainly a
          period of confusion for computer users over what exactly
          they had in hand when they saw a <filename>.DOC</filename>
          file.
          <footnote>
            <para>You think that was rough?  During that same era,
              WordPerfect also used <filename>.DOC</filename> for their
              proprietary file format's preferred extension!</para>
          </footnote>
        </para>
        @ENGLISH }}} -->
        <para>К сожалению, смысл некоторых расширений изменился с 
          течением времени. Когда только появились первые персональные
          компьютеры, файл с именем <filename>README.DOC</filename> 
          совершенно однозначно означал неформатированный текстовый
          файл, подобно файлам <filename>.txt</filename> в наши дни.
          Однако, с середины 1990-х пользователи стали уверенными
          в том, что файл с таким именем является вовсе не текстом 
          без форматирования, а документом Microsoft Word с закрытым,
          нечитаемым форматом. Но ведь это изменение не свершилось
          за одну ночь &mdash; для компьютерных пользователей существовал
          достаточно долгий период путаницы, когда при встрече с 
          файлом <filename>.DOC</filename> было непонятно, с чем же мы,
          собственно, имеем дело.
          <footnote>
            <para>Вы думаете, это всё?  В тот же самый период времени
              WordPerfect также предпочитал использовать расширение 
              <filename>.DOC</filename> для своего собственного 
              закрытого формата файлов!</para>
          </footnote>
        </para>

      <!-- @ENGLISH {{{
        <para>The popularity of computer networking cast still more
          doubt on the mapping between a file's name and its content.
          With information being served across networks and generated
          dynamically by server-side scripts, there was often no real
          file <foreignphrase>per se</foreignphrase> to speak of, and
          therefore no file name.  Web servers, for example, needed
          some other way to tell browsers what they were downloading
          so the browser could do something intelligent with that
          information, whether that was to display the data using a
          program registered to handle that data type, or to prompt
          the user for where on the client machine to store the
          downloaded data.</para>
        @ENGLISH }}} -->
        <para>Популярность компьютерных сетей привела к еще большим
          трудностям в установлении соответствия между именами файлов 
          и их содержимым. Когда информация стала проходить по сети и 
          генерироваться динамически серверными скриптами, о физическом
          файле <foreignphrase>как таковом</foreignphrase> часто 
          стало говорить просто невозможно, и, соответственно, не стало
          никакого имени файла. К примеру, Web-серверы нуждались в 
          некотором способе сообщить браузеру, что же он загружает, чтобы
          браузер мог правильно поступить с этой информацией (например,
          отобразить данные, используя программу, зарегистрированную
          в качестве обработчика файлов данного типа, либо спросить 
          у пользователя, где на клиентской машине сохранить загружаемые
          данные).</para>

      <!-- @ENGLISH {{{
        <para>Eventually, a standard emerged for, among other things,
          describing the contents of a data stream.  In 1996, RFC2045
          was published, the first of five RFCs describing MIME.  In
          it, this RFC describes the concept of media types and
          subtypes, and recommends a syntax for the representation of
          those types.  Today, MIME media types&mdash;or, MIME
          types&mdash; are used almost universally across e-mail
          applications, Web servers, and other software as the
          <foreignphrase>de facto</foreignphrase> mechanism for
          clearing up the file content confusion.</para>
        @ENGLISH }}} -->
        <para>В конечном счете появился стандарт, среди прочего
          описывающий виды содержимого потоков данных. В 1996 году
          был опубликован RFC2045, первый из пяти RFC-документов,
          описывающих MIME. В нем описана концепция медиатипов и подтипов,
          и рекомендован синтаксис для представления этих типов.
          В настоящее время медиатипы MIME &mdash; или просто MIME-типы
          &mdash; используются практически во всех
          приложениях электронной почты, на Web-серверах и в других
          программах как механизм, <foreignphrase>де-факто</foreignphrase>
          исключающий трудности при определении
          характера содержимого файлов.</para>

      </sidebar>
    
      <!-- @ENGLISH {{{
      <para>For example, one of the benefits that Subversion typically
        provides is contextual, line-based merging of changes received
        from the server during an update into your working file.  But
        for files containing non-textual data, there is often no
        concept of a <quote>line</quote>.  So, for versioned files
        whose <literal>svn:mime-type</literal> property is set to a
        non-textual MIME type (generally, something that doesn't begin
        with <literal>text/</literal>, though there are exceptions),
        Subversion does not attempt to perform contextual merges
        during updates.  Instead, any time you have locally modified a
        binary working copy file that is also being updated, your file
        is renamed with a <filename>.orig</filename> extension, and
        then Subversion stores a new working copy file that contains
        the changes received during the update, but not your own local
        modifications, at the original filename.  This behavior is
        really for the protection of the user against failed attempts
        at performing contextual merges on files that simply cannot be
        contextually merged.</para>
        @ENGLISH }}} -->
      <para>Например, одной из полезных возможностей Subversion
        является контекстное, построчное слияние изменений,
        полученных от сервера во время обновления, с рабочей 
        копией. Однако, для файлов, не содержащих текстовых данных, как 
        правило, не существует понятия <quote>строки</quote>.
        Поэтому для версионированных файлов, чье свойство 
        <literal>svn:mime-type</literal> указывает на нетекстовый
        MIME-тип (как правило, это все, что не начинается с 
        <literal>text/</literal>, хотя есть несколько исключений), 
        Subversion не будет пытаться провести контекстное слияние 
        во время обновления. Вместо этого, каждый раз когда вы локально
        модифицируете рабочую копию бинарного файла, и выполняете после
        этого обновление, файл будет переименован с добавлением 
        расширения <filename>.orig</filename>, после чего Subversion
        запишет под оригинальным именем новый файл рабочей копии, 
        c изменениями, полученными в процессе обновления, но без
        ваших локальных исправлений. Такое поведение призвано
        защитить пользователя от неудачных попыток выполнить
        контекстное слияние для файлов, к которым его нельзя 
        применить.</para>

      <!-- @ENGLISH {{{
      <para>Also, if the <literal>svn:mime-type</literal> property is
        set, then the Subversion Apache module will use its value to
        populate the <literal>Content-type:</literal> HTTP header when
        responding to GET requests.  This gives your web browser a
        crucial clue about how to display a file when using it to
        peruse your Subversion repository's contents.</para>
        @ENGLISH }}} -->
      <para>Кроме того, если для файла определено свойство 
        <literal>svn:mime-type</literal>, Apache-модуль Subversion 
        будет использовать его значение при формировании HTTP-заголовка 
        <literal>Content-type:</literal> в ответ на GET-запросы.
        Благодаря этому ваш браузер (в том случае, если он будет 
        использоваться для просмотра содержимого Subversion-хранилища)
        будет знать, как правильно отобразить этот файл.</para>

    </sect2>
  
    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.special.executable">
      <!-- @ENGLISH {{{
      <title>File Executability</title>
        @ENGLISH }}} -->
      <title>Исполнимость файла</title>

      <!-- @ENGLISH {{{
      <para>On many operating systems, the ability to execute a file
        as a command is governed by the presence of an execute
        permission bit.  This bit usually defaults to being disabled,
        and must be explicitly enabled by the user for each file that
        needs it.  But it would be a monumental hassle to have to
        remember exactly which files in freshly checked-out working
        copy were supposed to have their executable bits toggled on,
        and then to have to do that toggling.  So, Subversion provides
        the <literal>svn:executable</literal> property as a way to
        specify that the executable bit for the file on which that
        property is set should be enabled, and Subversion honors that
        request when populating working copies with such files.</para>
        @ENGLISH }}} -->
      <para>На многих операционных системах возможность выполнения файла
        как команды определяется битом разрешения выполнения. Обычно по
        умолчанию этот бит не задан; он должен быть явно установлен 
        пользователем для тех файлов, которым это необходимо.
        Однако, было бы слишком сложным запоминать, какие именно файлы 
        в только что созданной рабочей копии должны иметь установленный 
        бит выполнения, и устанавливать этот бит. Поэтому Subversion 
        поддерживает свойство <literal>svn:executable</literal>,
        позволяющее указать, для каких файлов должен быть установлен 
        бит исполнения. При создании рабочей копии Subversion самостоятельно 
        установит этот бит для таких файлов.</para>

      <!-- @ENGLISH {{{
      <para>This property has no effect on filesystems that have no
        concept of an executable permission bit, such as FAT32 and
        NTFS.
        <footnote>
          <para>The Windows filesystems use file extensions (such as
            <literal>.EXE</literal>, <literal>.BAT</literal>, and
            <literal>.COM</literal>) to denote executable
            files.</para>
        </footnote>
        Also, although it has no defined values, Subversion will force
        its value to <literal>*</literal> when setting this property.
        Finally, this property is valid only on files, not on
        directories.</para>
        @ENGLISH }}} -->
      <para>Это свойство не оказывает никакого эффекта на файловых
        системах, не использующих бита разрешения выполнения, таких
        как FAT32 и NTFS.
          <footnote>
            <para>Для указания исполняемых файлов файловая система Windows 
              использует расширения файлов (а именно 
              <literal>.EXE</literal>, <literal>.BAT</literal> и
              <literal>.COM</literal>).</para>
        </footnote>. 
        Кроме того, хотя значение этого свойства не задано, 
        Subversion принудительно устанавливает ему значение
        <literal>*</literal>. Наконец, это свойство действительно 
        только для файлов, но не для каталогов.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.special.eol-style">
      <!-- @ENGLISH {{{
      <title>End-of-Line Character Sequences</title>
        @ENGLISH }}} -->
      <title>Символы конца строки</title>

      <!-- @ENGLISH {{{
      <para>Unless otherwise noted using a versioned file's
        <literal>svn:mime-type</literal> property, Subversion
        assumes the file contains human-readable data.  Generally
        speaking, Subversion only uses this knowledge to determine
        if contextual difference reports for that file are
        possible.  Otherwise, to Subversion, bytes are bytes.</para>
        @ENGLISH }}} -->
      <para>Subversion считает, что файл содержит читаемые данные,
        если на обратное не указывает версионированное свойство файла
        <literal>svn:mime-type</literal>.  В общем-то, Subversion 
        необходимо знать об этом только для того, чтобы определить
        возможность построения контекстного отчета о различиях. 
        В противном случае Subversion будет воспринимать 
        файл лишь как набор байтов.</para>
      
      <!-- @ENGLISH {{{
      <para>This means that by default, Subversion doesn't pay any
        attention to the type of <firstterm>end-of-line (EOL)
        markers</firstterm> used in your files.  Unfortunately,
        different operating systems have different conventions about
        which character sequences represent the end of a line of text
        in a file.  For example, the usual line ending token used by
        software on the Windows platform is a pair of ASCII control
        characters&mdash;a carriage return (<literal>CR</literal>)
        followed by a line feed (<literal>LF</literal>).  Unix
        software, however, just uses the <literal>LF</literal>
        character to denote the end of a line.</para>
        @ENGLISH }}} -->
      <para>Сказанное означает, что по умолчанию Subversion не уделяет
        никакого внимания используемой в файлах разновидности 
        <firstterm>маркера конца строки (EOL)</firstterm>.  К сожалению,
        различные операционные системы используют различные соглашения 
        о том, какая последовательность символов означает конец 
        текстовой строки в файле. Например, программы под
        Windows обычно используют в качестве признака конца 
        строки последовательность из двух управляющих символов ASCII 
        &mdash; возврата каретки (<literal>CR</literal>) и перевода строки
        (<literal>LF</literal>).  В то же время программы под Unix 
        для обозначения конца строки используют единственный
        символ <literal>LF</literal>.</para>

      <!-- @ENGLISH {{{
      <para>Not all of the various tools on these operating systems
        are prepared to understand files that contain line endings
        in a format that differs from the <firstterm>native line
        ending style</firstterm> of the operating system on which
        they are running.  Common results are that Unix programs
        treat the <literal>CR</literal> character present in Windows
        files as a regular character (usually rendered as
        <literal>^M</literal>), and that Windows programs combine
        all of the lines of a Unix file into one giant line because
        no carriage return-linefeed (or <literal>CRLF</literal>)
        character combination was found to denote the end of
        line.</para>
        @ENGLISH }}} -->
      <para>Далеко не все програмы способны понимать файлы, в которых
        признак конца строки отличается по формату от
        <firstterm>принятого стиля завершения строк</firstterm> 
        в данной операционной системе. 
        Обычным делом является ситуация,
        когда программы под Unix рассматривают символ 
        <literal>CR</literal>, присутствующий в файлах Windows, 
        как обычный символ (часто представляя его как 
        <literal>^M</literal>), или когда программы под Windows 
        слепляют все строки файла Unix в одну гигантскую строку, 
        поскольку в нем отсутствуют комбинации символов возврата 
        каретки и перевода строки (или <literal>CRLF</literal>),
        обозначающие концы строк.</para>

      <!-- @ENGLISH {{{
      <para>This sensitivity to foreign EOL markers can become
        frustrating for folks who share a file across different
        operating systems.  For example, consider a source code
        file, and developers that edit this file on both Windows and
        Unix systems.  If all the developers always use tools which
        preserve the line ending style of the file, no problems
        occur.</para>
        @ENGLISH }}} -->
      <para>Такая чувствительность к чужеродным EOL-маркерам может
        стать серьезной проблемой для людей, совместно использующих
        одни и те же файлы в различных операционных системах.
        Возьмем для примера файл с исходным кодом программы и 
        разработчиков, редактирующих этот файл как под Windows, так 
        и под Unix. Если все разработчики будут всегда использовать
        инструменты, сохраняющие в файле прежний стиль завершения 
        строк, проблем не возникнет.</para>

      <!-- @ENGLISH {{{
      <para>But in practice, many common tools either fail to
        properly read a file with foreign EOL markers, or they
        convert the file's line endings to the native style when the
        file is saved.  If the former is true for a developer, he
        has to use an external conversion utility (such as
        <command>dos2unix</command> or its companion,
        <command>unix2dos</command>) to prepare the file for
        editing.  The latter case requires no extra preparation.
        But both cases result in a file that differs from the
        original quite literally on every line!  Prior to committing
        his changes, the user has two choices.  Either he can use a
        conversion utility to restore the modified file to the same
        line ending style that it was in before his edits were made.
        Or, he can simply commit the file&mdash;new EOL markers and
        all.</para>
        @ENGLISH }}} -->
      <para>Но на практике многие распространенные утилиты либо 
        не умеют правильно считывать файлы с чужеродными EOL-маркерами,
        либо конвертируют концы строк в файле к родному стилю при
        сохранении файла. Если разработчик сталкивается с первым случаем, 
        он оказывается вынужденным пользоваться 
        внешними утилитами конвертации (такими как 
        <command>dos2unix</command> или ее аналоги,
        <command>unix2dos</command>), чтобы подготовить файл к 
        редактированию. Во втором случае дополнительная подготовка
        файлов не требуется. Однако, в обоих случаях получается 
        файл, каждая строка в котором отличается от исходной!
        Прежде чем фиксировать свои изменения, пользователь может сделать
        одно из двух. Он может либо использовать утилиту конвертации,
        чтобы восстановить в модифицированном файле прежний стиль 
        завершения строк; либо просто зафиксировать файл 
        с новыми EOL-маркерами.</para>

      <!-- @ENGLISH {{{
      <para>The result of scenarios like these include wasted time
        and unnecessary modifications to committed files.  Wasted
        time is painful enough.  But when commits change every line
        in a file, this complicates the job of determining which of
        those lines were changed in a non-trivial way.  Where was
        that bug really fixed?  On what line was a syntax error
        introduced?</para>
        @ENGLISH }}} -->
      <para>Результатом такого сценария станут напрасная
        трата времени и нежелательные изменения в фиксируемых
        файлах. Напрасная трата времени сама по себе обходится довольно 
        дорого. А когда фиксация вносит изменения в каждую строку 
        файла, становится невозможным определить, какие строки
        файла действительно изменились по существу. Был ли 
        устранен тот самый баг? В какой строке имелась синтаксическая 
        ошибка?</para>

      <!-- @ENGLISH {{{
      <para>The solution to this problem is the
        <literal>svn:eol-style</literal> property.  When this
        property is set to a valid value, Subversion uses it to
        determine what special processing to perform on the file so
        that the file's line ending style isn't flip-flopping with
        every commit that comes from a different operating
        system.  The valid values are:</para>
        @ENGLISH }}} -->
      <para>Данную проблему решает свойство 
        <literal>svn:eol-style</literal>. Когда этому свойству 
        задано одно из допустимых значений, Subversion 
        использует его для того, чтобы определить вариант 
        специальной обработки файла, производимой для того,
        чтобы стиль завершения строки не изменялся туда-сюда
        при каждой фиксации, выполняемой из другой операционной
        системы. Допустимы следующие значения:</para>

      <variablelist>
        <varlistentry>
          <term><literal>native</literal></term>
          <listitem>
      <!-- @ENGLISH {{{
            <para>This causes the file to contain the EOL markers
              that are native to the operating system on which
              Subversion was run.  In other words, if a user on a
              Windows machine checks out a working copy that
              contains a file with an
              <literal>svn:eol-style</literal> property set to
              <literal>native</literal>, that file will contain
              <literal>CRLF</literal> EOL markers.  A Unix user
              checking out a working copy which contains the same
              file will see <literal>LF</literal> EOL markers in his
              copy of the file.</para>
        @ENGLISH }}} -->
            <para>Файл будет содержать EOL-маркеры, принятые в 
              той операционной системе, на которой работает
              Subversion. Иными словами, если пользователь
              на машине с Windows создает рабочую копию файла,
              у которого свойство <literal>svn:eol-style</literal> 
              установлено в <literal>native</literal>, этот 
              файл будет содержать EOL-маркеры 
              <literal>CRLF</literal>.  Пользователь Unix, создавая
              рабочую копию того же самого файла,
              увидит в нем EOL-маркер <literal>LF</literal>.</para>

      <!-- @ENGLISH {{{
            <para>Note that Subversion will actually store the file
              in the repository using normalized
              <literal>LF</literal> EOL markers regardless of the
              operating system.  This is basically transparent to
              the user, though.</para>
        @ENGLISH }}} -->
            <para>Учтите, что на самом деле Subvversion 
              будет записывать файл в хранилище, используя нормализованный
              EOL-маркер <literal>LF</literal>, вне зависимости от 
              операционной системы. Хотя обычно это прозрачно 
              для пользователя.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>CRLF</literal></term>
          <listitem>
      <!-- @ENGLISH {{{
            <para>This causes the file to contain
              <literal>CRLF</literal> sequences for EOL markers,
              regardless of the operating system in use.</para>
        @ENGLISH }}} -->
            <para>Файл будет содержать в качестве EOL-маркеров
              последовательность <literal>CRLF</literal>,
              независимо от используемой операционной системы.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>LF</literal></term>
          <listitem>
      <!-- @ENGLISH {{{
            <para>This causes the file to contain
              <literal>LF</literal> characters for EOL markers,
              regardless of the operating system in use.</para>
        @ENGLISH }}} -->
            <para>Файл будет содержать в качестве EOL-маркера
              символ <literal>LF</literal>, независимо от 
              используемой операционной системы.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>CR</literal></term>
          <listitem>
      <!-- @ENGLISH {{{
            <para>This causes the file to contain
              <literal>CR</literal> characters for EOL markers,
              regardless of the operating system in use.  This line
              ending style is not very common.  It was used on older
              Macintosh platforms (on which Subversion doesn't even
              run).</para>
        @ENGLISH }}} -->
            <para>Файл будет содержать в качестве EOL-маркера
              символ <literal>CR</literal>, независимо от используемой
              операционной системы. Данный стиль завершения строки
              не слишком распространен. Он использовался на
              устаревших платформах Macintosh (на которых Subversion 
              даже никогда не запускался).</para>
          </listitem>
        </varlistentry>
      </variablelist> 
      
    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.props.special.ignore">
      <!-- @ENGLISH {{{
    <title>Ignoring Unversioned Items</title>
        @ENGLISH }}} -->
    <title>Пропуск неверсионированных элементов</title>

      <!-- @ENGLISH {{{
    <para>In any given working copy there is a good chance that
      alongside all those versioned files and directories are other
      files and directories which are neither versioned nor intended
      to be.  Text editors litter directories with backup files.  Code
      compilation processes generate intermediate&mdash;or even
      final&mdash;files which you typically wouldn't bother to
      version.  And users themselves drop various other files and
      directories wherever they see fit, often in version control
      working copies.</para>
        @ENGLISH }}} -->
    <para>В любой реальной рабочей копии среди версионированных
      файлов и каталогов почти наверняка обнаружатся и другие файлы и
      каталоги, которые не версионированы и не должны быть 
      таковыми. Текстовые редакторы мусорят, создавая каталоги с 
      резервными копиями файлов. Компиляторы программного кода
      генерируют временные &mdash; или даже результирующие &mdash;
      файлы, которые обычно нет смысла версионировать. Сами 
      пользователи также бросают различные файлы и каталоги там,
      где им проще &mdash; в том числе нередко и в каталогах
      рабочей копии.</para>

      <!-- @ENGLISH {{{
    <para>It's ludicrous to expect Subversion working copies to be
      somehow impervious to this kind of clutter and impurity.  In
      fact, Subversion counts it as a <emphasis>feature</emphasis>
      that its working copies are just typical directories, just like
      unversioned trees.  But these not-to-be-versioned files and
      directories can cause some annoyance for Subversion users.  For
      example, because the <command>svn add</command> and <command>svn
      import</command> commands act recursively by default, and don't
      know which files in a given tree you do and don't wish to
      version, it's easy to accidentally add stuff to version control
      that you didn't mean to.  And because <command>svn
      status</command> reports, by default, every item of interest in
      a working copy&mdash;including unversioned files and
      directories&mdash;its output can get quite noisy where many of
      these things exist.</para>
        @ENGLISH }}} -->
    <para>Было бы нелепо ожидать, что рабочие копии Subversion окажутся
      в стороне от такого рода мусора и беспорядка. При этом
      Subversion считает своей важной <emphasis>особенностью</emphasis> то, 
      что ее рабочие копии являются самыми обычными каталогами, такими же
      как и неверсионированные структуры каталогов. Однако не подлежащие
      версионированию файлы и каталоги могут вызывать у пользователей
      Subversion некоторое раздражение. Например, поскольку команды 
      <command>svn add</command> и <command>svn import</command> 
      по умолчанию действуют рекурсивно и не знают, какие
      из вновь созданных файлов в данном каталоге вы не собираетесь
      версионировать, очень легко случайно добавить под версионный 
      контроль всякий хлам, о котором вы даже не думали. Кроме того, 
      много лишнего может выводить команда <command>svn status</command>,
      поскольку по умолчанию она выдает отчет по каждому
      элементу в рабочей копии, включая неверсионированные файлы
      и каталоги.</para>

      <!-- @ENGLISH {{{
    <para>So Subversion provides two ways for telling it which
      files you would prefer that it simply disregard.  One of the
      ways involves the use of Subversion's runtime configuration
      system (see <xref linkend="svn.advanced.confarea" />), and
      therefore applies to all the Subversion operations which make
      use of that runtime configuration, generally those performed on
      a particular computer, or by a particular user of a computer.
      The other way makes use of Subversion's directory property
      support, is more tightly bound to the versioned tree itself, and
      therefore affects everyone who has a working copy of that tree.
      Both of the mechanisms use file patterns.</para>
        @ENGLISH }}} -->
    <para>Исходя из этого, Subversion поддерживает два способа для того,
      чтобы указать, на какие файлы желательно просто не обращать
      внимание. Первый способ затрагивает систему настройки
      среды исполнения Subversion 
      (см. <xref linkend="svn.advanced.confarea" />), и,
      следовательно, применяется ко всем операциям Subversion,
      использующим эти настройки среды исполнения (которые, как правило,
      производятся на конкретном компьютере или конкретным пользователем
      компьютера). Другой способ использует поддерживаемые в Subversion
      свойства каталогов, он более тесно связан с 
      самим версионированным деревом каталогов и, следовательно,
      действует для всех, кто оперирует рабочей копией этого дерева. 
      Оба механизма используют маски файлов.</para>

      <!-- @ENGLISH {{{
    <para>The Subversion runtime configuration system provides an
      option, <literal>global-ignores</literal>, whose value is a
      whitespace-delimited collection of file patterns (or globs).
      These patterns are applied to files which are candidates for
      addition to version control, as well as to unversioned files
      which the <command>svn status</command> command notices.  If the
      filenames match one of the patterns, Subversion will basically
      act as if the file didn't exist at all.  This is really useful
      for file patterns which are nearly universally of the variety
      that you don't want to version, such as editor backup files like
      Emacs' <literal>*~</literal> and <literal>.*~</literal>
      files.</para>
        @ENGLISH }}} -->
    <para>Система настройки среды исполнения Subversion 
      имеет параметр <literal>global-ignores</literal>, 
      значением которой служит разделенный пробелами набор масок 
      файлов. Эти маски применяются к файлам, являющимся кандидатами
      на добавление под версионный контроль, а также к неверсионированным
      файлам, попадающим в поле зрения команды <command>svn status</command>.
      Если имя файла соответствуют одной из масок, Subversion будет
      действовать так, как будто файла вовсе не существует.
      Это действительно полезно для масок файлов, которые вы однозначно
      не хотите версионировать &mdash; например, файлов резервных копий,
      создаваемых редакторами, таких как файлы <literal>*~</literal> 
      и <literal>.*~</literal> от Emacs.</para>

      <!-- @ENGLISH {{{
    <para>When found on a versioned directory, the
      <literal>svn:ignore</literal> property is expected to contain a
      list of newline-delimited file patterns which Subversion should
      use to determine ignorable objects in that same directory.
      These patterns do not override those found in the
      <literal>global-ignores</literal> runtime configuration option,
      but are instead appended to that list.  And it's worth noting
      again that, unlike the <literal>global-ignores</literal> option,
      the patterns found in the <literal>svn:ignore</literal>
      property apply only to the directory on which that property is
      set, and not to any of its subdirectories.  The
      <literal>svn:ignore</literal> property is a good way to tell
      Subversion to ignore files that are likely to be present in
      every user's working copy of that directory, such as compiler
      output or&mdash;to use an example more appropriate to this
      book&mdash;the HTML, PDF, or PostScript files generated as the
      result of a conversion of some source DocBook XML files to a
      more legible output format.</para>
        @ENGLISH }}} -->
    <para>Свойство <literal>svn:ignore</literal>, задаваемое для
      версионированного каталога, содержит список масок файлов
      (каждая маска записывается с новой строки), с помощью которого
      Subversion должна определять, какие объекты следует игнорировать
      в этом каталоге. Эти маски не переопределяют те, что заданы
      параметром среды исполнения <literal>global-ignores</literal>,
      а дополняют их. Стоит отметить, что в отличие от параметра 
      <literal>global-ignores</literal>, маски, перечисленные в свойстве
      <literal>svn:ignore</literal>, применяются только к тому каталогу, 
      в свойстве которого они заданы, не затрагивая любые его подкаталоги.
      Свойство <literal>svn:ignore</literal> &mdash; это хороший способ
      попросить Subversion пропускать файлы, которые, вероятно,
      присутствуют во всех пользовательских рабочих копиях &mdash;
      например, результаты компиляции или, если взять пример, более 
      подходящий этой книге, файлы HTML, PDF или PostScript,
      генерируемые в результате преобразования исходных файлов
      формата DocBook XML в более удобный для чтения выходной формат.</para>

    <warning>
      <!-- @ENGLISH {{{
      <para>Subversion's support for ignorable file patterns extends
        only to the one-time process of adding unversioned
        files and directories to version control.  Once an object is
        under Subversion's control, the ignore pattern mechanisms no
        longer apply to it.  In other words, don't expect Subversion
        to avoid committing changes you've made to a versioned file
        simply because that file's name matches an ignore
        pattern&mdash;Subversion <emphasis>always</emphasis> notices
        all of its versioned objects.</para>
        @ENGLISH }}} -->
      <para>Реализованная в Subverion поддержка масок пропуска файлов
        действует только в момент добавления 
        неверсионированного файла или каталога под версионный контроль. 
        Если объект уже находится под управлением Subversion, 
        механизм масок пропуска больше к нему не применяется.
        Иными словами, не следует ожидать, что Subversion не будет
        фиксировать изменения, сделанные в версионированном файле,
        только на том основании, что его имя соответствует
        маске пропуска &mdash; Subversion <emphasis>всегда</emphasis> 
        просматривает все версионированные объекты.</para>
    </warning>

    <sidebar>
      <!-- @ENGLISH {{{
      <title>Ignore Patterns for CVS Users</title>
        @ENGLISH }}} -->
      <title>Маски пропуска для пользователей CVS</title>
    
      <!-- @ENGLISH {{{
      <para>The Subversion <literal>svn:ignore</literal> property is
        very similar in syntax and function to the CVS
        <filename>.cvsignore</filename> file.  In fact, if you are
        migrating a CVS working copy to Subversion, you can directly
        migrate the ignore patterns by using the
        <filename>.cvsignore</filename> file as input file to the
        <command>svn propset</command> command:</para>
        @ENGLISH }}} -->
      <para>Свойство <literal>svn:ignore</literal> в Subversion по 
        синтаксису и назначению очень похоже на файл 
        <filename>.cvsignore</filename> в CVS.  По сути, если
        вы переносите свою рабочую копию в Subversion, вы можете 
        перенести маски пропуска напрямую, используя файл 
        <filename>.cvsignore</filename> в качестве входного для команды
        <command>svn propset</command>:</para>
   
      <screen>
$ svn propset svn:ignore -F .cvsignore .
property 'svn:ignore' set on '.'
$
</screen>
    
      <!-- @ENGLISH {{{
      <para>There are, however, some differences in the ways that CVS
        and Subversion handle ignore patterns.  The two systems use
        the ignore patterns at some different times, and there are
        slight discrepancies in what the ignore patterns apply to.
        Also, Subversion does not recognize the use of the
        <literal>!</literal> pattern as a reset back to having no
        ignore patterns at all.</para>
        @ENGLISH }}} -->
      <para>Тем не менее, в работе CVS и Subversion с масками пропуска имеются
        некоторые отличия. Системы используют маски пропуска в несколько 
        различные моменты времени, и есть небольшое различие
        в том, как эти маски применяются. Также Subversion не понимает
        использование маски <literal>!</literal> как способа
        полного отказа от масок пропуска.</para>

    </sidebar>

      <!-- @ENGLISH {{{
    <para>The global list of ignore patterns tends to be more a
      matter of personal taste, and tied more closely to a user's
      particular tool chain than to the details of any particular
      working copy's needs.  So, the rest of this section will focus
      on the <literal>svn:ignore</literal> property and its
      uses.</para>
        @ENGLISH }}} -->
    <para>Глобальный список масок пропуска в большей степени подходит
      для задания личных предпочтений, и завязан больше на
      конкретный набор пользовательских инструментов, чем на 
      специфику конкретной рабочей копии. Исходя из этого,
      остаток данной главы будет посвящен использованию свойства
      <literal>svn:ignore</literal>.</para>

      <!-- @ENGLISH {{{
    <para>Say you have the following output from <command>svn
      status</command>:</para>
        @ENGLISH }}} -->
    <para>Допустим, что команда <command>svn status</command> выдает 
      нам следующее:</para>

    <screen>
$ svn status calc
 M     calc/button.c
?      calc/calculator
?      calc/data.c
?      calc/debug_log
?      calc/debug_log.1
?      calc/debug_log.2.gz
?      calc/debug_log.3.gz
</screen>
    
      <!-- @ENGLISH {{{
    <para>In this example, you have made some property modifications
      to <filename>button.c</filename>, but in your working copy you
      also have some unversioned files: the latest
      <filename>calculator</filename> program that you've compiled
      from your source code, a source file named
      <filename>data.c</filename>, and a set of debugging output log
      files.  Now, you know that your build system always results in
      the <filename>calculator</filename> program being generated.
      <footnote>
        <para>Isn't that the whole point of a build system?</para>
      </footnote>
      And you know that your test suite always leaves those debugging
      log files lying around.  These facts are true for all working
      copies of this project, not just your own.  And you know that
      you aren't interested in seeing those things every time you run
      <command>svn status</command>, and pretty sure that nobody else
      is interested in them either.  So you use <command>svn propedit
      svn:ignore calc</command> to add some ignore patterns to the
      <filename>calc</filename> directory.  For example, you might add
      this as the new value of the <literal>svn:ignore</literal>
      property:</para>
        @ENGLISH }}} -->
    <para>В примере видно, что вы изменили некоторые свойства файла 
      <filename>button.c</filename>, и, кроме того, в рабочей копии
      есть несколько неверсионированных файлов: программа 
      <filename>calculator</filename>, скомпилированная из
      исходных кодов, файл исходного кода <filename>data.c</filename>
      и набор файлов с отладочными сообщениями. Вам известно, что 
      ваша система сборки всегда генерирует программу с именем
      <filename>calculator</filename>.
      <footnote>
        <para>Это все, что создает система сборки?</para>
      </footnote>
      Также вам известно, что после тестового прогона всегда остаются
      те самые файлы с отладочными сообщениями. Это справедливо
      не только для вашей, но и для всех остальных рабочих копий 
      данного проекта.
      Вы точно знаете, что вам не хотелось бы видеть эти отладочные
      файлы при каждом запуске команды <command>svn status</command>, 
      и вы абсолютно уверены, что так же их не хотелось бы видеть и 
      остальным. Исходя из этого, можно добавить необходимые маски 
      пропуска для каталога <filename>calc</filename>, выполнив
      команду <command>svn propedit svn:ignore calc</command>.
      Например, вы могли бы добавить в значение свойства 
      <literal>svn:ignore</literal> такие строки:</para>

    <programlisting>
calculator
debug_log*
</programlisting>
    
      <!-- @ENGLISH {{{
    <para>After you've added this property, you will now have a local
      property modification on the <filename>calc</filename>
      directory.  But notice what else is different about your
      <command>svn status</command> output:</para>
        @ENGLISH }}} -->
    <para>Результатом добавления этого свойства станет локальное 
      изменение свойств в каталоге <filename>calc</filename>.  
      Обратите внимание, чем еще отличается теперь вывод 
      команды <command>svn status</command>:</para>

    <screen>
$ svn status
 M     calc
 M     calc/button.c
?      calc/data.c
</screen>
    
      <!-- @ENGLISH {{{
    <para>Now, all that cruft is missing from the output!  Of course,
      your <filename>calculator</filename> compiled program and all
      those logfiles are still in your working copy.  Subversion is
      simply not reminding you that they are present and unversioned.
      And now with all the uninteresting noise removed from the
      display, you are left with more interesting items&mdash;such as
      that source code file <filename>data.c</filename> that you
      probably forgot to add to version control.</para>
        @ENGLISH }}} -->
    <para>Заметьте, весь "мусор" исчез из вывода!  Конечно, скомпилированная
      программа <filename>calculator</filename> и упоминавшиеся файлы 
      отладочных сообщений никуда не делись из вашей рабочей копии.
      Просто Subversion больше не напоминает вам об их существовании. Теперь, 
      когда весь не представляющий интереса "мусор" исчез с экрана, вам 
      остается разобраться с более интересными элементами &mdash; в частности,
      с исходным файлом <filename>data.c</filename>, который вы, вероятно,
      забыли добавить под версионный контроль.</para>

      <!-- @ENGLISH {{{
    <para>Of course, this less-verbose report of your working copy
      status isn't the only one available.  If you actually want to
      see the ignored files as part of the status report, you can pass
      the <option>-&#64738;-no-ignore</option> option to Subversion:</para>
        @ENGLISH }}} -->
    <para>Конечно же, вам доступен не только этот короткий отчет 
      о статусе вашей рабочей копии. Если в какой-то момент времени вам
      действительно захочется увидеть в составе статусного отчета 
      проигнорированные файлы, вы можете воспользоваться опцией
      <option>--no-ignore</option>:</para>

    <screen>
$ svn status --no-ignore
 M     calc
 M     calc/button.c
I      calc/calculator
?      calc/data.c
I      calc/debug_log
I      calc/debug_log.1
I      calc/debug_log.2.gz
I      calc/debug_log.3.gz
</screen>
    
      <!-- @ENGLISH {{{
    <para>As mentioned earlier, the list of file patterns to ignore is
      also used by <command>svn add</command> and <command>svn
      import</command>.  Both of these operations involve asking
      Subversion to begin managing some set of files and directories.
      Rather than force the user to pick and choose which files in a
      tree she wishes to start versioning, Subversion uses the ignore
      patterns&mdash;both the global and the per-directory
      lists&mdash;to determine which files should not be swept into
      the version control system as part of a larger recursive
      addition or import operation.  And here again, you can use the
      <option>-&#64738;-no-ignore</option> option to tell Subversion ignore
      its ignores list and operate on all the files and directories
      present.</para>
        @ENGLISH }}} -->
    <para>Как отмечалось выше, список файловых масок для пропуска 
      также учитывается командами <command>svn add</command> и <command>svn
      import</command>.  В результате обеих операций Subversion
      берет под управление некоторое множество файлов и каталогов.
      Прежде чем требовать у пользователя, чтобы он выбирал те файлы 
      в структуре каталогов, которые необходимо версионировать,
      Subversion применяет маски пропуска &mdash; как глобальные,
      так и назначенные отдельным каталогам &mdash; чтобы определить,
      какие файлы не должны подхватываться системой управления версиями
      в ходе рекурсивной операции добавления или импорта. И снова вы можете
      воспользоваться опцией <option>--no-ignore</option>, чтобы предложить
      Subversion не учитывать списки пропуска и обрабатывать все имеющиеся
      файлы и каталоги.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.props.special.keywords">
      <!-- @ENGLISH {{{
    <title>Keyword Substitution</title>
        @ENGLISH }}} -->
    <title>Подстановка ключевых слов</title>

      <!-- @ENGLISH {{{
    <para>Subversion has the ability to substitute
      <firstterm>keywords</firstterm>&mdash;pieces of useful,
      dynamic information about a versioned file&mdash;into the
      contents of the file itself.  Keywords generally describe
      information about the last time the file was known to be
      modified.  Because this information changes each time the
      file changes, and more importantly, just
      <emphasis>after</emphasis> the file changes, it is a hassle
      for any process except the version control system to keep
      the data completely up-to-date.  Left to human authors, the
      information would inevitably grow stale.</para>
        @ENGLISH }}} -->
    <para>Subversion умеет выполнять подстановку 
      <firstterm>ключевых слов</firstterm> &mdash; элементов полезной 
      динамической информации о версионированном файле &mdash;
      в составе этого файла. Чаще всего ключевые слова 
      замещают информацию о времени последнего изменения файла.
      Поскольку эта информация меняется при каждом изменении файла,
      и, что особенно важно, сразу <emphasis>после</emphasis> 
      того, как файл будет изменен, никакой другой процесс, кроме
      системы управления версиями, не в состоянии 
      поддерживать полную актуальность этих данных. Будучи
      отданной на откуп человеку, эта информация неизбежно 
      будет оказываться устаревшей.</para>

      <!-- @ENGLISH {{{
    <para>For example, say you have a document in which you would
      like to display the last date on which it was modified.  You
      could burden every author of that document to, just before
      committing their changes, also tweak the part of the
      document that describes when it was last changed.  But
      sooner or later, someone would forget to do that.  Instead
      simply ask Subversion to perform keyword substitution on the
      <literal>LastChangedDate</literal> keyword.  You control
      where the keyword is inserted into your document by placing
      a <firstterm>keyword anchor</firstterm> at the desired
      location in the file.  This anchor is just a string of text
      formatted as
      <literal>$</literal><replaceable>KeywordName</replaceable><literal>$</literal>.</para>
        @ENGLISH }}} -->
    <para>Предположим, у вас есть файл, в тексте которого
      вы хотели бы всегда видеть дату его последнего изменения.
      Вы могли бы вменить в обязанность каждому автору
      этого документа, чтобы непосредственно перед фиксацией своих
      изменений он также исправлял в нем запись о времени
      последнего внесения изменений. Но рано или поздно 
      кто-нибудь забудет сделать это! Чтобы такого не случалось, 
      мы можем попросить Subversion производить
      подстановку на место ключевого слова <literal>LastChangedDate</literal>.  
      Позиция, куда должна производиться подстановка, определяется 
      местоположением <firstterm>указателя ключевого слова</firstterm> 
      в содержании файла.  Этот указатель представляет собой
      обычную текстовую строку, имеющую формат
      <literal>$</literal><replaceable>KeywordName</replaceable>
      <literal>$</literal>.</para>

      <!-- @ENGLISH {{{
    <para>All keywords are case-sensitive where they appear as
      anchors in files: you must use the correct capitalization in
      order for the keyword to be expanded.  You should consider the
      value of the <literal>svn:keywords</literal> property to be
      case-sensitive too&mdash;certain keyword names will be recognized
      regardless of case, but this behavior is deprecated.</para>
        @ENGLISH }}} -->
    <para>Все ключевые слова чувствительны к регистру, когда идет речь
      об указателях на них в файлах: вы должны использовать правильный
      регистр символов в написании ключевого слова. Значение свойства
      <literal>svn:keywords</literal> также следует рассматривать как
      чувствительное к регистру &mdash; и хотя некоторые имена ключевых 
      слов распознаются независимо от регистра, рассчитывать на это 
      не стоит.</para>

      <!-- @ENGLISH {{{
    <para>Subversion defines the list of keywords available for
      substitution.  That list contains the following five keywords, 
      some of which have aliases that you can also use:</para>
        @ENGLISH }}} -->
    <para>В Subversion определен список ключевых слов, доступных для 
      подстановки.  Он содержит следующие пять ключевых слов; 
      некоторые из них имеют псевдонимы, которые
      вы также можете использовать:</para>

    <variablelist>
      <varlistentry>
        <term><literal>Date</literal></term>
        <listitem>
      <!-- @ENGLISH {{{
          <para>This keyword describes the last time the file was
            known to have been changed in the repository, and
            looks something like <literal>$Date:
            2006-07-22 21:42:37 -0700 (Sat, 22 Jul 2006)
            $</literal>.  It may also be specified as
            <literal>LastChangedDate</literal>.</para>
        @ENGLISH }}} -->
          <para>Это ключевое слово замещает время последнего
            изменения файла в хранилище и выглядит примерно так:
            <literal>$Date: 2006-07-22 21:42:37 -0700 (Sat, 22 Jul 2006)
            $</literal>.  Также его можно задать как 
            <literal>LastChangedDate</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>Revision</literal></term>
        <listitem>
      <!-- @ENGLISH {{{
          <para>This keyword describes the last known revision in
            which this file changed in the repository, and looks
            something like <literal>$Revision: 144 $</literal>.  
            It may also be specified as
            <literal>LastChangedRevision</literal> or
            <literal>Rev</literal>.</para>
        @ENGLISH }}} -->
          <para>Это ключевое слово замещает номер последней правки,
            в которой файл был изменен в хранилище, и выглядит
            примерно так: <literal>$Revision: 144 $</literal>.  
            Также его можно задать как 
            <literal>LastChangedRevision</literal> или
            <literal>Rev</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>Author</literal></term>
        <listitem>
      <!-- @ENGLISH {{{
          <para>This keyword describes the last known user to
            change this file in the repository, and looks
            something like <literal>$Author: harry $</literal>.  
            It may also be specified as 
            <literal>LastChangedBy</literal>.</para>
        @ENGLISH }}} -->
          <para>Это ключевое слово замещает имя пользователя,
            который последним изменил этот файл в хранилище,
            и выглядит примерно так: <literal>$Author: harry $</literal>.  
            Также его можно задать как 
            <literal>LastChangedBy</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>HeadURL</literal></term>
        <listitem>
      <!-- @ENGLISH {{{
          <para>This keyword describes the full URL to the latest
            version of the file in the repository, and looks
            something like <literal>$HeadURL:
            http://svn.collab.net/repos/trunk/README $</literal>.
            It may be abbreviated as
            <literal>URL</literal>.</para>
        @ENGLISH }}} -->
          <para>Это ключевое слово замещает полный URL
            к последней версии файла в хранилище, и 
            выглядит примерно так: <literal>$HeadURL:
            http://svn.collab.net/repos/trunk/README $</literal>.
            Оно может быть сокращено до
            <literal>URL</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>Id</literal></term>
        <listitem>
      <!-- @ENGLISH {{{
          <para>This keyword is a compressed combination of the
            other keywords.  Its substitution looks something like
            <literal>$Id: calc.c 148 2006-07-28 21:30:43Z sally
            $</literal>, and is interpreted to mean that the file
            <filename>calc.c</filename> was last changed in revision
            148 on the evening of July 28, 2006 by the user
            <literal>sally</literal>.</para>
        @ENGLISH }}} -->
          <para>Это ключевое слово &mdash; компактная комбинация
            всех остальных. Его подстановка выглядит примерно так:
            <literal>$Id: calc.c 148 2006-07-28 21:30:43Z sally
            $</literal>, и означает, что файл 
            <filename>calc.c</filename> последний раз был изменен в правке
            148, зафиксированной вечером 28 июля 2006 года пользователем 
            <literal>sally</literal>.</para>
        </listitem>
      </varlistentry>
    </variablelist>

      <!-- @ENGLISH {{{
    <para>Simply adding keyword anchor text to your file does
      nothing special.  Subversion will never attempt to perform
      textual substitutions on your file contents unless
      explicitly asked to do so.  After all, you might be writing
      a document
      <footnote>
        <para>&hellip; or maybe even a section of a book &hellip;</para>
      </footnote> 
      about how to use keywords, and you don't want Subversion to
      substitute your beautiful examples of un-substituted keyword
      anchors!</para>
        @ENGLISH }}} -->
    <para>Если просто разместить в тексте файла указатель ключевого слова,
      ничего не произойдет. Subversion никогда не пытается осуществить
      текстовую подстановку в содержании файла, пока вы явно его об 
      этом не попросите.  В конце концов, вы ведь могли бы написать
      документ 
      <footnote>
        <para>&hellip; или даже, возможно, параграф в книге &hellip;</para>
      </footnote> 
      о том, как пользоваться ключевыми словами, и вы, очевидно, не захотите,
      чтобы Subversion заместил указатели на ключевые слова, приведенные 
      вами в качестве примера!</para>

      <!-- @ENGLISH {{{
    <para>To tell Subversion whether or not to substitute keywords
      on a particular file, we again turn to the property-related
      subcommands.  The <literal>svn:keywords</literal> property,
      when set on a versioned file, controls which keywords will
      be substituted on that file.  The value is a space-delimited
      list of the keyword names or aliases found in the previous
      table.</para>
        @ENGLISH }}} -->
    <para>Чтобы указать Subversion, следует ли ему выполнять подстановку
      ключевых слов в конкретном файле, снова обратимся к подкомандам
      для работы со свойствами.  Свойство <literal>svn:keywords</literal>,
      устанавливаемое для версионированного файла, задает перечень ключевых
      слов, которые будут замещаться в этом файле. Его значение представляет
      собой список имен ключевых слов или псевдонимов из приведенной
      выше таблицы, разделенных пробелами.</para>

      <!-- @ENGLISH {{{
    <para>For example, say you have a versioned file named
      <filename>weather.txt</filename> that looks like
      this:</para>
        @ENGLISH }}} -->
    <para>В качестве примера допустим, что у вас есть версионированный
      файл с именем <filename>weather.txt</filename>, который выглядит
      следующим образом::</para>

    <programlisting>
Here is the latest report from the front lines.
$LastChangedDate$
$Rev$
Cumulus clouds are appearing more frequently as summer approaches.
</programlisting>

      <!-- @ENGLISH {{{
    <para>With no <literal>svn:keywords</literal> property set on
      that file, Subversion will do nothing special.  Now, let's
      enable substitution of the
      <literal>LastChangedDate</literal> keyword.</para>
        @ENGLISH }}} -->
    <para>Если для этого файла не задать свойство 
      <literal>svn:keywords</literal>, Subversion не будет делать 
      ничего особенного. Давайте разрешим теперь подстановку ключевого 
      слова <literal>LastChangedDate</literal>.</para>

    <screen>
$ svn propset svn:keywords "Date Author" weather.txt
property 'svn:keywords' set on 'weather.txt'
$
</screen>
    
      <!-- @ENGLISH {{{
    <para>Now you have made a local property modification on the
      <filename>weather.txt</filename> file.  You will see no
      changes to the file's contents (unless you made some of your
      own prior to setting the property).  Notice that the file
      contained a keyword anchor for the <literal>Rev</literal>
      keyword, yet we did not include that keyword in the property
      value we set.  Subversion will happily ignore requests to
      substitute keywords that are not present in the file, and
      will not substitute keywords that are not present in the
      <literal>svn:keywords</literal> property value.</para>
        @ENGLISH }}} -->
    <para>Итак, вы произвели локальное изменение свойства файла 
      <filename>weather.txt</filename>.  Вы не увидите никаких
      изменений в содержании файла (если вы, конечно, не вносили
      своих изменений до того, как задать свойство).  Заметьте, что
      файл содержал также указатель на ключевое слово <literal>Rev</literal>,
      которое мы не стали включать в значение свойства. 
      Subversion без проблем проигнорирует подстановку тех 
      ключевых слов, которые не присутствуют в файле, а также не 
      будет замещать ключевые слова, не перечисленные в
      значении свойства <literal>svn:keywords</literal>.</para>

      <!-- @ENGLISH {{{
    <para>Immediately after you commit this property change,
      Subversion will update your working file with the new
      substitute text.  Instead of seeing your keyword anchor
      <literal>$LastChangedDate$</literal>, you'll see its
      substituted result.  That result also contains the name of
      the keyword, and continues to be bounded by the dollar sign
      (<literal>$</literal>) characters.  And as we predicted, the
      <literal>Rev</literal> keyword was not substituted because
      we didn't ask for it to be.</para>
        @ENGLISH }}} -->
    <para>Сразу же после того, как вы зафиксируете изменение свойства,
      Subversion обновит файл рабочей копии с новым текстом подстановки.
      Вместо указателя ключевого слова <literal>$LastChangedDate$</literal>
      вы увидите результат подстановки.  Этот результат так же
      будет содержать имя ключевого слова, и по-прежнему будет
      ограничен знаками доллара (<literal>$</literal>).  
      Как мы и предсказывали, подстановки ключевого слова 
      <literal>Rev</literal> не произошло, поскольку мы не просили 
      об этом Subversion.</para>

      <!-- @ENGLISH {{{
    <para>Note also that we set the <literal>svn:keywords</literal>
      property to <quote>Date Author</quote> yet the keyword
      anchor used the alias <literal>$LastChangedDate$</literal>
      and still expanded correctly.</para>
        @ENGLISH }}} -->
    <para>Заметим также, что мы установили свойству 
      <literal>svn:keywords</literal> значение <quote>Date Author</quote>,
      в то время как указатель ключевого слова использовал псевдоним 
      <literal>$LastChangedDate$</literal>. Тем не менее, его замещение 
      прошло корректно.</para>

    <screen>
Here is the latest report from the front lines.
$LastChangedDate: 2006-07-22 21:42:37 -0700 (Sat, 22 Jul 2006) $
$Rev$
Cumulus clouds are appearing more frequently as summer approaches.
</screen>

      <!-- @ENGLISH {{{
    <para>If someone else now commits a change to
      <filename>weather.txt</filename>, your copy of that file
      will continue to display the same substituted keyword value
      as before&mdash;until you update your working copy.  At that
      time the keywords in your <filename>weather.txt</filename>
      file will be re-substituted with information that
      reflects the most recent known commit to that file.</para>
        @ENGLISH }}} -->
    <para>Теперь, если кто-то другой зафиксирует изменения в 
      <filename>weather.txt</filename>, ваша копия этого файла
      продолжит показывать прежний результат подстановки &mdash;
      до тех пор, пока вы не обновите рабочую копию.
      При обновлении в вашем файле <filename>weather.txt</filename>
      будет произведена переподстановка ключевого слова 
      той информацией, которая отражает наиболее свежую
      фиксацию этого файла.</para>

    <sidebar>
      <!-- @ENGLISH {{{
      <title>Where's $GlobalRev$?</title>
        @ENGLISH }}} -->
      <title>Где взять $GlobalRev$?</title>

      <!-- @ENGLISH {{{
      <para>New users are often confused by how the
        <literal>$Rev$</literal> keyword works.  Since the repository
        has a single, globally increasing revision number, many people
        assume that it is this number which is reflected by the
        <literal>$Rev$</literal> keyword's value.  But
        <literal>$Rev$</literal> expands to show the last revision in
        which the file <emphasis>changed</emphasis>, not the last
        revision to which it was updated.  Understanding this clears
        the confusion, but frustration often remains&mdash;without the
        support of a Subversion keyword to do so, how can you
        automatically get the global revision number into your
        files?</para>
        @ENGLISH }}} -->
      <para>Новые пользователи часто не понимают, как работает ключевое
        слово <literal>$Rev$</literal>. Поскольку хранилище имеет единый,
        глобально возрастающий номер правки, многие предполагают,
        что именно этот номер отражается значением ключевого слова 
        <literal>$Rev$</literal>. На самом же деле 
        <literal>$Rev$</literal> показывает последнюю правку,
        в которой файл <emphasis>был изменен</emphasis>, а не 
        правку, из которой обновлена рабочая копия. Осознание этого
        устраняет путаницу, но часто остается недоумение
        &mdash; как еще, если не через ключевые слова Subversion,
        автоматически получить в файлах глобальный номер 
        правки?</para>

      <!-- @ENGLISH {{{
      <para>To do this, you need external processing.  Subversion
        ships with a tool called <command>svnversion</command> which
        was designed for just this purpose.
        <command>svnversion</command> crawls your working copy and
        generates as output the revision(s) it finds.  You can use
        this program, plus some additionally tooling, to embed that
        revision information into your files.  For more information on
        <command>svnversion</command>, see <xref
        linkend="svn.ref.svnversion"/>.</para>
        @ENGLISH }}} -->
      <para>Чтобы добиться этого, потребуется внешняя обработка. 
        Subversion поставляется вместе с утилитой 
        <command>svnversion</command>, которая специально создана
        для этой цели. <command>svnversion</command> просматривает
        вашу рабочую копию и выдает номера найденных правок. 
        Вы можете пользоваться этой программой вместе с 
        дополнительными утилитами, чтобы записать эту информацию
        о правках в ваши файлы. За дополнительной информацией по
        <command>svnversion</command>, обращайтесь в раздел <xref
        linkend="svn.ref.svnversion"/>.</para>

    </sidebar>

      <!-- @ENGLISH {{{
    <para>Subversion 1.2 introduced a new variant of the keyword
      syntax which brought additional, useful&mdash;though perhaps
      atypical&mdash;functionality.  You can now tell Subversion
      to maintain a fixed length (in terms of the number of bytes
      consumed) for the substituted keyword.  By using a
      double-colon (<literal>::</literal>) after the keyword name,
      followed by a number of space characters, you define that
      fixed width.  When Subversion goes to substitute your
      keyword for the keyword and its value, it will essentially
      replace only those space characters, leaving the overall
      width of the keyword field unchanged.  If the substituted
      value is shorter than the defined field width, there will be
      extra padding characters (spaces) at the end of the
      substituted field; if it is too long, it is truncated with a
      special hash (<literal>#</literal>) character just before
      the final dollar sign terminator.</para>
        @ENGLISH }}} -->
    <para>Subversion 1.2 предлагает новый вариант синтаксиса для
      работы с ключевыми словами, который предоставляет дополнительные, 
      весьма полезные &mdash; хотя, вероятно, не совсем типичные
      &mdash; функциональные возможности.  Теперь вы можете
      попросить Subversion сохранять фиксированную длину для результата
      подстановки ключевого слова (имеется в виду число занимаемых
      байтов). Для этого используйте удвоенное двоеточие 
      (<literal>::</literal>) после имени ключевого слова, вслед за 
      которым поместите столько пробелов, сколько нужно для 
      задания фиксированной длины. Когда Subversion на место ключевого
      слова будет подставлять ключевое слово и его значение, 
      она заменит только эти пробельные символы, оставив неизменной 
      полную длину поля с ключевым словом. Если подставляемое
      значение окажется короче, чем заданная ширина поля, оно
      будет дополнено на конце символами-заполнителями
      (пробелами). Если подставляемое значение окажется слишком
      длинным, оно будет усечено, при этом непосредственно перед
      закрывающим знаком доллара (ограничителем) будет помещен
      специальный хэш-символ (<literal>#</literal>).</para>

      <!-- @ENGLISH {{{
    <para>For example, say you have a document in which you have
      some section of tabular data reflecting the document's
      Subversion keywords.  Using the original Subversion keyword
      substitution syntax, your file might look something
      like:</para>
        @ENGLISH }}} -->
    <para>Допустим, к примеру, что в вашем документе имеется
      раздел табулированных данных, отражающих значение ключевых
      слов Subversion для этого документа.  При использовании 
      исходного синтаксиса подстановки ключевых слов Subversion
      ваш файл мог бы выглядеть примерно так:</para>

    <screen>
$Rev$:     Revision of last commit
$Author$:  Author of last commit
$Date$:    Date of last commit
</screen>
    
      <!-- @ENGLISH {{{
    <para>Now, that looks nice and tabular at the start of things.
      But when you then commit that file (with keyword substitution
      enabled, of course), you see:</para>
        @ENGLISH }}} -->
    <para>Поначалу он выглядит красиво и похож на таблицу.
      Но когда вы выполните фиксацию этого файла (конечно же,
      при разрешенной подстановке ключевых слов), то увидите 
      следующее:</para>

    <screen>
$Rev: 12 $:     Revision of last commit
$Author: harry $:  Author of last commit
$Date: 2006-03-15 02:33:03 -0500 (Wed, 15 Mar 2006) $:    Date of last commit
</screen>
    
      <!-- @ENGLISH {{{
    <para>The result is not so beautiful.  And you might be
      tempted to then adjust the file after the substitution so
      that it again looks tabular.  But that only holds as long as
      the keyword values are the same width.  If the last
      committed revision rolls into a new place value (say, from
      99 to 100), or if another person with a longer username
      commits the file, stuff gets all crooked again.  However, if
      you are using Subversion 1.2 or better, you can use the new
      fixed-length keyword syntax, define some field widths that
      seem sane, and now your file might look like this:</para>
        @ENGLISH }}} -->
    <para>Результат уже не столь красив. Возможно, вам даже захочется
      выровнять содержимое файла после подстановки, чтобы он снова
      выглядел как таблица. Но выравнивание будет держаться
      только до тех пор, пока значение ключевого слова будет 
      иметь неизменную длину. Если в номере последней зафиксированной
      правки добавится новый разряд  (скажем, при переходе от 99 к 100),
      или фиксацию выполнит другой человек с более длинным именем
      пользователя, ваши труды снова пойдут насмарку. 
      Однако, если вы используете Subversion версии 1.2 или выше, 
      вы можете пользоваться новым синтаксисом ключевых слов с 
      фиксированной длиной, задавая полям такую длину, чтобы 
      получить аккуратный внешний вид. Теперь ваш файл мог бы
      выглядеть примерно так:</para>

    <screen>
$Rev::               $:  Revision of last commit
$Author::            $:  Author of last commit
$Date::              $:  Date of last commit
</screen>
    
      <!-- @ENGLISH {{{
    <para>You commit this change to your file.  This time,
      Subversion notices the new fixed-length keyword syntax, and
      maintains the width of the fields as defined by the padding
      you placed between the double-colon and the trailing dollar
      sign.  After substitution, the width of the fields is
      completely unchanged&mdash;the short values for
      <literal>Rev</literal> and <literal>Author</literal> are
      padded with spaces, and the long <literal>Date</literal>
      field is truncated by a hash character:</para>
        @ENGLISH }}} -->
    <para>Зафиксируем эти изменения в вашем файле. Теперь 
      Subversion заметит новый синтаксис ключевых слов с 
      фиксированной длиной и сохранит ширину полей такой,
      какой она была задана с помощью пробелов, помещенных вами
      между удвоенным двоеточием и замыкающим знаком доллара.
      После выполнения подстановки ширина поля совершенно не 
      изменится &mdash; короткие значения для 
      <literal>Rev</literal> и <literal>Author</literal> будут
      дополнены пробелами, а длинное поле <literal>Date</literal>
      будет обрезано хэш-символом:</para>

    <screen>
$Rev:: 13            $:  Revision of last commit
$Author:: harry      $:  Author of last commit
$Date:: 2006-03-15 0#$:  Date of last commit
</screen>
       
      <!-- @ENGLISH {{{
    <para>The use of fixed-length keywords is especially handy
      when performing substitutions into complex file formats that
      themselves use fixed-length fields for data, or for which
      the stored size of a given data field is overbearingly
      difficult to modify from outside the format's native
      application (such as for Microsoft Office documents).</para>
        @ENGLISH }}} -->
    <para>Использование ключевых слов с фиксированной длиной 
      особенно удобно, когда подстановки производятся в сложных
      файловых форматах, которые сами используют поля фиксированной
      длины для своих данных, либо в которых достаточно трудно изменить 
      размер определенного поля данных, не прибегая к использованию
      родного для данного формата приложения (в качестве примера
      можно привести документы Microsoft Office).</para>

    <warning>
      <!-- @ENGLISH {{{
      <para>Be aware that because the width of a keyword field is
        measured in bytes, the potential for corruption of
        multi-byte values exists.  For example, a username which
        contains some multi-byte UTF-8 characters might suffer
        truncation in the middle of the string of bytes which make
        up one of those characters.  The result will be a mere
        truncation when viewed at the byte level, but will likely
        appear as a string with an incorrect or garbled final
        character when viewed as UTF-8 text.  It is conceivable
        that certain applications, when asked to load the file,
        would notice the broken UTF-8 text and deem the entire
        file corrupt, refusing to operate on the file
        altogether.</para> 
        @ENGLISH }}} -->
      <para>Помните, что, поскольку ширина поля для 
        ключевого слова измеряется в байтах, существует опасность 
        повреждения многобайтовых символов. Например, имя пользователя,
        содержащее многобайтовые символы UTF-8, может подвергнуться
        усечению посреди строки байтов, отрезав часть байтов одного
        из символов. Результатом может стать не только усечение,
        видимое на байтовом уровне, но и строка с некорректным или
        искаженным последним символом при ее просмотре как текста 
        в формате UTF-8. Вполне возможно, что некоторые приложения 
        при загрузке такого файла обнаружат поврежденный текст UTF-8
        и посчитают поврежденным весь файл, отказавшись из-за этого
        с ним работать.</para> 
    </warning>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.locking">
    <title>Locking</title>

    <para>Subversion's copy-modify-merge version control model lives
      and dies on its data merging algorithms, specifically on how
      well those algorithms perform when trying to resolve conflicts
      caused by multiple users modifying the same file concurrently.
      Subversion itself provides only one such algorithm, a three-way
      differencing algorithm which is smart enough to handle data at a
      granularity of a single line of text.  Subversion also allows
      you to supplement its content merge processing with external
      differencing utilities (as described in <xref
      linkend="svn.advanced.externaldifftools.diff3" />), some of
      which may do an even better job, perhaps providing granularity
      of a word or a single character of text.  But common among those
      algorithms is that they generally work only on text files.  The
      landscape starts to look pretty grim when you start talking
      about content merges of non-textual file formats.  And when you
      can't find a tool that can handle that type of merging, you
      begin to run into problems with the copy-modify-merge
      model.</para>

   <para>Let's look at a real-life example of where this model runs
      aground.  Harry and Sally are both graphic designers working on
      the same project, a bit of marketing collateral for an
      automobile mechanic.  Central to the design of a particular
      poster is an image of a car in need of some body work, stored in
      a file using the PNG image format.  The poster's layout is
      almost finished, and both Harry and Sally are pleased with the
      particular photo they chose for their damaged car&mdash;a baby
      blue 1967 Ford Mustang with an unfortunate bit of crumpling on
      the left front fender.</para>

    <para>Now, as is common in graphic design work, there's a change
      in plans which causes the car's color to be a concern.  So Sally
      updates her working copy to <literal>HEAD</literal>, fires up
      her photo editing software, and sets about tweaking the image so
      that the car is now cherry red.  Meanwhile, Harry, feeling
      particularly inspired that day, decides that the image would
      have greater impact if the car also appears to have suffered
      greater impact.  He, too, updates to <literal>HEAD</literal>,
      and then draws some cracks on the vehicle's windshield.  He
      manages to finish his work before Sally finishes hers, and after
      admiring the fruits of his undeniable talent, commits the
      modified image.  Shortly thereafter, Sally is finished with the
      car's new finish, and tries to commit her changes.  But, as
      expected, Subversion fails the commit, informing Sally that now
      her version of the image is out of date.</para>

    <para>Here's where the difficulty sets in.  Were Harry and Sally
      making changes to a text file, Sally would simply update her
      working copy, receiving Harry's changes in the process.  In the
      worst possible case, they would have modified the same region of
      the file, and Sally would have to work out by hand the proper
      resolution to the conflict.  But these aren't text
      files&mdash;they are binary images.  And while it's a simple
      matter to describe what one would expect the results of this
      content merge to be, there is precious little chance that any
      software exists which is smart enough to examine the common
      baseline image that each of these graphic artists worked
      against, the changes that Harry made, and the changes that Sally
      made, and spit out an image of a busted-up red Mustang with a
      cracked windshield!</para>

    <para>Clearly, things would have gone more smoothly if Harry and
      Sally had serialized their modifications to the image.  If, say,
      Harry had waited to draw his windshield cracks on Sally's
      now-red car, or if Sally had tweaked the color of a car whose
      windshield was already cracked.  As is discussed in <xref
      linkend="svn.basic.vsn-models.copy-merge" />, much of these
      types problems go away entirely where perfect communication
      between Harry and Sally exists.
      <footnote>
        <para>Communication wouldn't have been such bad medicine for
          Harry and Sally's Hollywood namesakes, either, for that
          matter.</para>
      </footnote>
      But as one's version control system is, in fact, one form of
      communication, it follows that having that software facilitate
      the serialization of non-parallelizable energies is no bad
      thing.  And this where Subversion's implementation of the
      lock-modify-unlock model steps into the spotlight.  This is
      where we talk about Subversion's <firstterm>locking</firstterm>
      feature, which is similar to the <quote>reserved
      checkouts</quote> mechanisms of other version control
      systems.</para>

    <para>Subversion's locking feature serves two main
      purposes:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Serializing access to a versioned
          object</emphasis>.  By allowing a user to
          programmatically claim the exclusive right to change to a
          file in the repository, that user can be reasonably
          confident that energy invested on unmergeable changes won't
          be wasted&mdash;his commit of those changes will succeed.</para>
      </listitem>
      <listitem>
        <para><emphasis>Aiding communication</emphasis>.  By alerting
          other users that serialization is in effect for particular
          versioned object, those other users can reasonably expect
          that the object is about to be changed by someone else,
          and they, too, can avoid wasting their time and energy on
          unmergeable changes that won't be committable due to eventual
          out-of-dateness.</para>
      </listitem>
    </itemizedlist>

    <para>When referring to Subversion's locking feature, one is
      actually talking about a fairly diverse collection of behaviors
      which include the ability to lock a versioned file
      <footnote>
        <para>Subversion does not currently allow locks on directories.</para>
      </footnote>
      (claiming the exclusive right to modify the file), to unlock
      that file (yielding that exclusive right to modify), to see
      reports about which files are locked and by whom, to annotate
      files for which locking before editing is strongly advised, and
      so on.  In this section, we'll cover all of these facets of the
      larger locking feature.</para>

    <sidebar id="svn.advanced.locking.meanings">
      <title>Three meanings of <quote>lock</quote></title>

      <para>In this section, and almost everywhere in this book, the
        words <quote>lock</quote> and <quote>locking</quote> describe
        a mechanism for mutual exclusion between users to avoid
        clashing commits. Unfortunately, there are two other sorts
        of <quote>lock</quote> with which Subversion, and therefore
        this book, sometimes needs to be concerned.</para>

      <para>The first is <firstterm>working copy locks</firstterm>,
        used internally by Subversion to prevent clashes between
        multiple Subversion clients operating on the same working
        copy.  This is the sort of lock indicated by an
        <computeroutput>L</computeroutput> in the third column of
        <command>svn status</command> output, and removed by the
        <command>svn cleanup</command> command, as described in <xref
        linkend="svn.tour.other.cleanup"/>.</para>

      <para>Secondly, there are <firstterm>database locks</firstterm>,
        used internally by the Berkeley DB backend to prevent clashes
        between multiple programs trying to access the database.  This
        is the sort of lock whose unwanted persistence after an error
        can cause a repository to be <quote>wedged</quote>, as
        described in <xref linkend="svn.reposadmin.maint.recovery"/>.</para> 

      <para>You can generally forget about these other kinds of locks
        until something goes wrong that requires you to care about
        them.  In this book, <quote>lock</quote> means the first sort
        unless the contrary is either clear from context or explicitly
        stated.</para>

    </sidebar>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.locking.creation">
      <title>Creating locks</title>

      <para>In the Subversion repository, a
        <firstterm>lock</firstterm> is a piece of metadata which
        grants exclusive access to one user to change a file.  This
        user is said to be the <firstterm>lock owner</firstterm>.
        Each lock also has a unique identifier, typically a long
        string of characters, known as the <firstterm>lock
        token</firstterm>.  The repository manages locks, ultimately
        handling their creation, enforcement, and removal.  If any
        commit transaction attempts to modify or delete a locked file
        (or delete one of the parent directories of the file), the
        repository will demand two pieces of information&mdash;that
        the client performing the commit be authenticated as the lock
        owner, and that the lock token has been provided as part of
        the commit process as a sort of proof that client knows which
        lock it is using.</para>

      <para>To demonstrate lock creation, let's refer back to our
        example of multiple graphic designers working with on the same
        binary image files.  Harry has decided to change a JPEG image.
        To prevent other people from committing changes to the file
        while he is modifying it (as well as alerting them that he is
        about to change it), he locks the file in the repository using
        the <command>svn lock</command> command.</para>

      <screen>
$ svn lock banana.jpg --message "Editing file for tomorrow's release."
'banana.jpg' locked by user 'harry'.
$
</screen>

      <para>There are a number of new things demonstrated in the
        previous example.  First, notice that Harry passed the
        <option>--message</option> option to <command>svn
        lock</command>.  Similar to <command>svn commit</command>, the
        <command>svn lock</command> command can take comments (either
        via <option>--message (-m)</option> or <option>--file
        (-F)</option>) to describe the reason for locking the file.
        Unlike <command>svn commit</command>, however, <command>svn
        lock</command> will not demand a message by launching your
        preferred text editor.  Lock comments are optional, but still
        recommended to aid communication.</para>

      <para>Secondly, the lock attempt succeeded.  This means that the
        file wasn't already locked, and that Harry had the latest
        version of the file.  If Harry's working copy of the file had
        been out-of-date, the repository would have rejected the
        request, forcing Harry to <command>svn update</command> and
        reattempt the locking command.  The locking command would also
        have failed if the file already been locked by someone
        else.</para>

      <para>As you can see, the <command>svn lock</command> command
        prints confirmation of the successful lock.  At this point,
        the fact that the file is locked becomes apparent in the
        output of the <command>svn status</command> and <command>svn
        info</command> reporting subcommands.</para>

      <screen>
$ svn status
     K banana.jpg

$ svn info banana.jpg
Path: banana.jpg
Name: banana.jpg
URL: http://svn.example.com/repos/project/banana.jpg
Repository UUID: edb2f264-5ef2-0310-a47a-87b0ce17a8ec
Revision: 2198
Node Kind: file
Schedule: normal
Last Changed Author: frank
Last Changed Rev: 1950
Last Changed Date: 2006-03-15 12:43:04 -0600 (Wed, 15 Mar 2006)
Text Last Updated: 2006-06-08 19:23:07 -0500 (Thu, 08 Jun 2006)
Properties Last Updated: 2006-06-08 19:23:07 -0500 (Thu, 08 Jun 2006)
Checksum: 3b110d3b10638f5d1f4fe0f436a5a2a5
Lock Token: opaquelocktoken:0c0f600b-88f9-0310-9e48-355b44d4a58e
Lock Owner: harry
Lock Created: 2006-06-14 17:20:31 -0500 (Wed, 14 Jun 2006)
Lock Comment (1 line):
Editing file for tomorrow's release.

$
</screen>

      <para>That the <command>svn info</command> command, which does
        not contact the repository when run against working copy
        paths, can display the lock token reveals an important fact
        about lock tokens&mdash;that they are cached in the working
        copy.  The presence of the lock token is critical.  It gives
        the working copy authorization to make use of the lock later
        on.  Also, the <command>svn status</command> command shows a
        <literal>K</literal> next to the file (short for locKed),
        indicating that the lock token is present.</para>

      <sidebar>
        <title>Regarding lock tokens</title>

        <para>A lock token isn't an authentication token, so much as
          an <emphasis>authorization</emphasis> token.  The token
          isn't a protected secret.  In fact, a lock's unique token is
          discoverable by anyone who runs <command>svn info
          URL</command>.  A lock token is special only when it lives
          inside a working copy.  It's proof that the lock was created
          in that particular working copy, and not somewhere else by
          some other client.  Merely authenticating as the lock owner
          isn't enough to prevent accidents.</para>

        <para>For example, suppose you lock a file using a computer at
          your office, but leave work for the day before you finish
          your changes to that file.  It should not be possible to
          accidentally commit changes to that same file from your home
          computer later that evening simply because you've
          authenticated as the lock's owner.  In other words, the lock
          token prevents one piece of Subversion-related software from
          undermining the work of another.  (In our example, if you
          really need to change the file from an alternate working
          copy, you would need to break the lock and re-lock the
          file.)</para>

      </sidebar>

      <para>Now that Harry has locked <filename>banana.jpg</filename>,
        Sally is unable to change or delete that file:</para>

      <screen>
$ svn delete banana.jpg
D         banana.jpg
$ svn commit -m "Delete useless file."
Deleting       banana.jpg
svn: Commit failed (details follow):
svn: DELETE of
'/repos/project/!svn/wrk/64bad3a9-96f9-0310-818a-df4224ddc35d/banana.jpg':
423 Locked (http://svn.example.com)
$
</screen>

      <para>But Harry, after touching up the banana's shade of yellow,
        is able to commit his changes to the file.  That's because he
        authenticates as the lock owner, and also because his working
        copy holds the correct lock token:</para>

      <screen>
$ svn status
M    K banana.jpg
$ svn commit -m "Make banana more yellow"
Sending        banana.jpg
Transmitting file data .
Committed revision 2201.
$ svn status
$
</screen>

      <para>Notice that after the commit is finished, <command>svn
        status</command> shows that the lock token is no longer
        present in working copy.  This is the standard behavior of
        <command>svn commit</command>&mdash;it searches the working
        copy (or list of targets, if you provide such a list) for
        local modifications, and sends all the lock tokens it
        encounters during this walk to the server as part of the
        commit transaction.  After the commit completes successfully,
        all of the repository locks that were mentioned are
        released&mdash;<emphasis>even on files that weren't
        committed</emphasis>.  This is meant to discourage users from
        being sloppy about locking, or from holding locks for too
        long.  If Harry haphazardly locks thirty files in a directory
        named <filename>images</filename> because he's unsure of which
        files he needs to change, yet only only changes four of those
        file, when he runs <command>svn commit images</command>, the
        process will still release all thirty locks.</para>

      <para>This behavior of automatically releasing locks can be
        overridden with the <option>--no-unlock</option> option to
        <command>svn commit</command>.  This is best used for those
        times when you want to commit changes, but still plan to make
        more changes and thus need to retain existing locks.  You can
        also make this your default behavior by setting the
        <literal>no-unlock</literal> runtime configuration option (see
        <xref linkend="svn.advanced.confarea" />).</para>

      <para>Of course, locking a file doesn't oblige one to commit a
        change to it.  The lock can be released at any time with a
        simple <command>svn unlock</command> command:</para>

      <screen>
$ svn unlock banana.c
'banana.c' unlocked.
</screen>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.locking.discovery">
      <title>Discovering locks</title>

      <para>When a commit fails due to someone else's locks, it's
        fairly easy to learn about them.  The easiest of
        these is <command>svn status --show-updates</command>:</para>

      <screen>
$ svn status --show-updates
M              23   bar.c
M    O         32   raisin.jpg
       *       72   foo.h
Status against revision:     105
$
</screen>

      <para>In this example, Sally can see not only that her copy of
        <filename>foo.h</filename> is out-of-date, but that one of the
        two modified files she plans to commit is locked in the
        repository.  The <literal>O</literal> symbol stands for
        <quote>Other</quote>, meaning that a lock exists on the file,
        and was created by somebody else.  If she were to attempt a
        commit, the lock on <filename>raisin.jpg</filename> would
        prevent it.  Sally is left wondering who made the lock, when,
        and why.  Once again, <command>svn info</command> has the
        answers:</para>

      <screen>
$ svn info http://svn.example.com/repos/project/raisin.jpg
Path: raisin.jpg
Name: raisin.jpg
URL: http://svn.example.com/repos/project/raisin.jpg
Repository UUID: edb2f264-5ef2-0310-a47a-87b0ce17a8ec
Revision: 105
Node Kind: file
Last Changed Author: sally
Last Changed Rev: 32
Last Changed Date: 2006-01-25 12:43:04 -0600 (Sun, 25 Jan 2006)
Lock Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Lock Owner: harry
Lock Created: 2006-02-16 13:29:18 -0500 (Thu, 16 Feb 2006)
Lock Comment (1 line):
Need to make a quick tweak to this image.
$
</screen>
      <para>Just as <command>svn info</command> can be used to examine
        objects in the working copy, it can also be used to examine
        objects in the repository.  If the main argument to
        <command>svn info</command> is a working copy path, then all
        of the working copy's cached information is displayed; any
        mention of a lock means that the working copy is holding a
        lock token (if a file is locked by another user or in another
        working copy, <command>svn info</command> on a working copy
        path will show no lock information at all).  If the main
        argument to <command>svn info</command> is a URL, then the
        information reflects the latest version of an object in the
        repository, and any mention of a lock describes the current
        lock on the object.</para>

      <para>So in this particular example, Sally can see that Harry
        locked the file on February 16th to <quote>make a quick
        tweak</quote>.  It being June, she suspects that he probably
        forgot all about the lock.  She might phone Harry to complain
        and ask him to release the lock.  If he's unavailable, she
        might try to forcibly break the lock herself or ask an
        administrator to do so.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.locking.break-steal">
      <title>Breaking and stealing locks</title>

      <para>A repository lock isn't sacred&mdash;in Subversion's
        default configuration state, locks can be released not only by
        the person who created them, but by anyone at all.  When
        somebody other than the original lock creator destroys a lock,
        we refer to this as <firstterm>breaking</firstterm> the
        lock.</para>

      <para>From the administrator's chair, it's simple to break
        locks.  The <command>svnlook</command>
        and <command>svnadmin</command> programs have the ability to
        display and remove locks directly from the repository.  (For
        more information about these tools, see
        <xref linkend="svn.reposadmin.maint.tk"/>.)</para>

      <screen>
$ svnadmin lslocks /usr/local/svn/repos
Path: /project2/images/banana.jpg
UUID Token: opaquelocktoken:c32b4d88-e8fb-2310-abb3-153ff1236923
Owner: frank
Created: 2006-06-15 13:29:18 -0500 (Thu, 15 Jun 2006)
Expires:
Comment (1 line):
Still improving the yellow color.

Path: /project/raisin.jpg
UUID Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Owner: harry
Created: 2006-02-16 13:29:18 -0500 (Thu, 16 Feb 2006)
Expires:
Comment (1 line):
Need to make a quick tweak to this image.

$ svnadmin rmlocks /usr/local/svn/repos /project/raisin.jpg
Removed lock on '/project/raisin.jpg'.
$
</screen>

      <para>The more interesting option is allowing users to break
        each other's locks over the network.  To do this, Sally simply
        needs to pass the <option>--force</option> to the unlock
        command:</para>

      <screen>
$ svn status --show-updates
M              23   bar.c
M    O         32   raisin.jpg
       *       72   foo.h
Status against revision:     105
$ svn unlock raisin.jpg
svn: 'raisin.jpg' is not locked in this working copy
$ svn info raisin.jpg | grep URL
URL: http://svn.example.com/repos/project/raisin.jpg
$ svn unlock http://svn.example.com/repos/project/raisin.jpg
svn: Unlock request failed: 403 Forbidden (http://svn.example.com)
$ svn unlock --force http://svn.example.com/repos/project/raisin.jpg
'raisin.jpg' unlocked.
$
</screen>

      <para>Now, Sally's initial attempt to unlock failed because she
        ran <command>svn unlock</command> directly on her working copy
        of the file, and no lock token was present.  To remove the
        lock directly from the repository, she needs to pass a URL
        to <command>svn unlock</command>.  Her first attempt to unlock
        the URL fails, because she can't authenticate as the lock
        owner (nor does she have the lock token).  But when she
        passes <option>--force</option>, the authentication and
        authorization requirements are ignored, and the remote lock is
        broken.</para>

      <para>Of course, simply breaking a lock may not be enough.  In
        the running example, Sally may not only want to break Harry's
        long-forgotten lock, but re-lock the file for her own use.
        She can accomplish this by running <command>svn unlock
        --force</command> and then <command>svn lock</command>
        back-to-back, but there's a small chance that somebody else
        might lock the file between the two commands.  The simpler thing
        to is <firstterm>steal</firstterm> the lock, which involves
        breaking and re-locking the file all in one atomic step.  To
        do this, Sally passes the <option>--force</option> option
        to <command>svn lock</command>:</para>

      <screen>
$ svn lock raisin.jpg
svn: Lock request failed: 423 Locked (http://svn.example.com)
$ svn lock --force raisin.jpg
'raisin.jpg' locked by user 'sally'.
$
</screen>

      <para>In any case, whether the lock is broken or stolen, Harry
        may be in for a surprise.  Harry's working copy still contains
        the original lock token, but that lock no longer exists.  The
        lock token is said to be <firstterm>defunct</firstterm>.  The
        lock represented by the lock-token has either been broken (no
        longer in the repository), or stolen (replaced with a
        different lock).  Either way, Harry can see this by asking
        <command>svn status</command> to contact the
        repository:</para>

      <screen>
$ svn status
     K raisin.jpg
$ svn status --show-updates
     B         32   raisin.jpg
$ svn update
  B  raisin.jpg
$ svn status
$
</screen>

      <para>If the repository lock was broken, then <command>svn
        status --show-updates</command> displays a
        <literal>B</literal> (Broken) symbol next to the file.  If a
        new lock exists in place of the old one, then a
        <literal>T</literal> (sTolen) symbol is shown.  Finally,
        <command>svn update</command> notices any defunct lock tokens
        and removes them from the working copy.</para>

      <sidebar>
        <title>Locking Policies</title>

        <para>Different systems have different notions of how strict a
          lock should be.  Some folks argue that locks must be
          strictly enforced at all costs, releasable only by the
          original creator or administrator.  They argue that if
          anyone can break a lock, then chaos runs rampant and the
          whole point of locking is defeated.  The other side argues
          that locks are first and foremost a communication tool.  If
          users are constantly breaking each others' locks, then it
          represents a cultural failure within the team and the
          problem falls outside the scope of software enforcement.</para>

        <para>Subversion defaults to the <quote>softer</quote>
          approach, but still allows administrators to create stricter
          enforcement policies through the use of hook scripts.  In
          particular, the <filename>pre-lock</filename> and
          <filename>pre-unlock</filename> hooks allow administrators
          to decide when lock creation and lock releases are allowed
          to happen.  Depending on whether or not a lock already
          exists, these two hooks can decide whether or not to allow a
          certain user to break or steal a lock.  The
          <filename>post-lock</filename> and
          <filename>post-unlock</filename> hooks are also available,
          and can be used to send email after locking actions.  To
          learn more about repository hooks, see <xref
          linkend="svn.reposadmin.create.hooks" />.</para>

      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.locking.lock-communication">
      <title>Lock Communication</title>

      <para>We've seen how <command>svn lock</command>
        and <command>svn unlock</command> can be used to create,
        release, break, and steal locks.  This satisfies the goal of
        serializing commit access to a file.  But what about the
        larger problem of preventing wasted time?</para>

      <para>For example, suppose Harry locks an image file and then
        begins editing it.  Meanwhile, miles away, Sally wants to do
        the same thing.  She doesn't think to run <command>svn status
        --show-updates</command>, so she has no idea that Harry has
        already locked the file.  She spends hours editing the file,
        and when she tries to commit her change, she discovers that
        either the file is locked or that she's out-of-date.
        Regardless, her changes aren't mergeable with Harry's.  One of
        these two people has to throw away their work, and a lot of
        time has been wasted.</para>

      <para>Subversion's solution to this problem is to provide a
        mechanism to remind users that a file ought to be locked
        <emphasis>before</emphasis> the editing begins.  The mechanism
        is a special property, <literal>svn:needs-lock</literal>.  If
        that property is attached to a file (regardless of its value,
        which is irrelevant), then Subversion will try to use
        filesystem-level permissions to make the file read-only,
        unless, of course, the user has explicitly locked the file.
        When a lock-token is present (as a result of running
        <command>svn lock</command>), the file becomes read-write.
        When the lock is released, the file becomes read-only
        again.</para>

      <para>The theory, then, is that if the image file has this
        property attached, then Sally would immediately notice
        something is strange when she opens the file for editing.
        Many applications alert users immediately when a read-only
        file is opened for editing.  And nearly all applications would
        at least prevent her from saving changes to the file.  This
        reminds her to lock the file before editing, whereby she
        discovers the pre-existing lock:</para>

      <screen>
$ /usr/local/bin/gimp raisin.jpg
gimp: error: file is read-only!
$ ls -l raisin.jpg
-r--r--r--   1 sally   sally   215589 Jun  8 19:23 raisin.jpg
$ svn lock raisin.jpg
svn: Lock request failed: 423 Locked (http://svn.example.com)
$ svn info http://svn.example.com/repos/project/raisin.jpg | grep Lock
Lock Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Lock Owner: harry
Lock Created: 2006-06-08 07:29:18 -0500 (Thu, 08 June 2006)
Lock Comment (1 line):
Making some tweaks.  Locking for the next two hours.
$
</screen>

      <tip>
        <para>Users and administrators alike are encouraged to attach
          the <literal>svn:needs-lock</literal> property to any file
          which cannot be contextually merged.  This is the primary
          technique for encouraging good locking habits and preventing
          wasted effort.</para>
      </tip>

      <para>Note that this property is a communication tool which
        works independently from the locking system.  In other words,
        any file can be locked, whether or not this property is
        present.  And conversely, the presence of this property
        doesn't make the repository require a lock when
        committing.</para>

      <para>Unfortunately, the system isn't flawless.  It's possible
        that even when a file has the property, the read-only reminder
        won't always work.  Sometimes applications misbehave and
        <quote>hijack</quote> the read-only file, silently allowing
        users to edit and save the file anyway.  There's not much that
        Subversion can do in this situation&mdash;at the end of the
        day, there's simply no substitution for good interpersonal
        communication.
        <footnote>
          <para>Except, perhaps, a classic Vulcan mind-meld.</para>
        </footnote>
      </para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.externals">
    <!-- @ENGLISH {{{
    <title>Externals Definitions</title>
    @ENGLISH }}} -->
    <title>Внешние зависимости</title>    

    <!-- @ENGLISH {{{
    <para>Sometimes it is useful to construct a working copy that is
      made out of a number of different checkouts.  For example, you
      may want different subdirectories to come from different
      locations in a repository, or perhaps from different
      repositories altogether.  You could certainly setup such a
      scenario by hand&mdash;using <command>svn checkout</command> to
      create the sort of nested working copy structure you are trying
      to achieve.  But if this layout is important for everyone who
      uses your repository, every other user will need to perform the
      same checkout operations that you did.</para>
    @ENGLISH }}} -->
    <para>Иногда полезно иметь рабочую копию, собранную из разных источников.
      К примеру, может понадобиться, чтобы различные рабочие подкаталоги
      выгружались из разных каталогов хранилища, или даже из разных хранилищ.
      Безусловно, всё это можно сделать вручную, с помощью вызовов команды
      <command>svn checkout</command> создав рабочую копию с нужной структурой.
      Но, ели подобная структура требуется всем пользователям хранилища, 
      каждому из них нужно будет повторить все те же операции по созданию
      рабочей копии, которые делали вы сами.</para>

    <!-- @ENGLISH {{{
    <para>Fortunately, Subversion provides support for
      <firstterm>externals definitions</firstterm>.  An externals
      definition is a mapping of a local directory to the
      URL&mdash;and possibly a particular revision&mdash;of a
      versioned directory.  In Subversion, you declare externals
      definitions in groups using the <literal>svn:externals</literal>
      property.  You can create or modify this property using
      <command>svn propset</command> or <command>svn
      propedit</command> (see <xref linkend="svn.advanced.props.manip"
      />).  It can be set on any versioned directory, and its value is
      a multi-line table of subdirectories (relative to the versioned
      directory on which the property is set) and fully qualified,
      absolute Subversion repository URLs.</para>
    @ENGLISH }}} -->
    <para>Чтобы этого избежать, Subversion обеспечивает поддержку
      <firstterm>внешних зависимостей</firstterm>. Внешняя зависимость 
      является сопоставлением локального каталога к URL  
      версионированного каталога (или к его конкретной правке). Групповое 
      объявление внешних зависимостей делается в Subversion при помощи 
      свойства <literal>svn:externals</literal>. Установка и редактирование 
      этого свойства выполняется с помощью команд
      <command>svn propset</command> и <command>svn propedit</command>
      (см. <xref linkend="svn.advanced.props.manip" />). Свойство может быть 
      установлено для любого версионированного каталога, значение свойства 
      представляет собой таблицу с путями к подкаталогам (относительно того 
      каталога, для которого это свойство устанавливается) и полными 
      абсолютными URL в Subversion-хранилище.</para>

    <screen>
$ svn propget svn:externals calc
third-party/sounds             http://sounds.red-bean.com/repos
third-party/skins              http://skins.red-bean.com/repositories/skinproj
third-party/skins/toolkit -r21 http://svn.red-bean.com/repos/skin-maker
</screen>

    <!-- @ENGLISH {{{
    <para>The convenience of the <literal>svn:externals</literal>
      property is that once it is set on a versioned directory,
      everyone who checks out a working copy with that directory also
      gets the benefit of the externals definition.  In other words,
      once one person has made the effort to define those nested
      working copy checkouts, no one else has to
      bother&mdash;Subversion will, upon checkout of the original
      working copy, also checkout the external working copies.</para>
    @ENGLISH }}} -->
    <para>Удобство свойства <literal>svn:external</literal> заключается в том,
      что после его задания для версионированного каталога все, кто будет
      создавать рабочую копию с этим каталогом, получат возможность пользоваться
      преимуществами внешней зависимости. Другими словами, после того как 
      кто-то из участников проекта обозначил необходимую структуру рабочей
      копии, больше никому не придется об этом беспокоиться &mdash; при 
      создании рабочей копии Subversion, кроме оригинальных данных, сделает 
      рабочие копии данных, определенных как внешние зависимости.</para>

    <!-- @ENGLISH {{{
    <para>Note the previous externals definition example.  When
      someone checks out a working copy of the
      <filename>calc</filename> directory, Subversion also continues
      to checkout the items found in its externals definition.</para>
    @ENGLISH }}} -->
    <para>Посмотрите на предыдущий пример с внешними зависимостями. Когда 
      кто-нибудь будет создавать рабочую копию каталога
      <filename>calc</filename>, Subversion создаст, в том числе, и копии
      элементов, определенных как внешние зависимости.</para>

    <screen>
$ svn checkout http://svn.example.com/repos/calc
A  calc
A  calc/Makefile
A  calc/integer.c
A  calc/button.c
Checked out revision 148.

Fetching external item into calc/third-party/sounds
A  calc/third-party/sounds/ding.ogg
A  calc/third-party/sounds/dong.ogg
A  calc/third-party/sounds/clang.ogg
&hellip;
A  calc/third-party/sounds/bang.ogg
A  calc/third-party/sounds/twang.ogg
Checked out revision 14.

Fetching external item into calc/third-party/skins
&hellip;
</screen>

    <!-- @ENGLISH {{{
    <para>If you need to change the externals definition, you can do
      so using the regular property modification subcommands.  When
      you commit a change to the <literal>svn:externals</literal>
      property, Subversion will synchronize the checked-out items
      against the changed externals definition when you next run
      <command>svn update</command>.  The same thing will happen when
      others update their working copies and receive your changes to
      the externals definition.</para>
    @ENGLISH }}} -->
    <para>Если необходимо изменить внешние зависимости, сделать это можно с 
      помощью обычных команд редактирования свойств. После того как вы 
      зафиксируете изменения свойства <literal>svn:externals</literal>, 
      при следующем запуске
      <command>svn update</command> Subversion синхронизирует 
      существующие копии элементов в соответствии с внесенными во внешние 
      зависимости изменениями. Тоже самое произойдет и когда другие 
      участники проекта обновят свои рабочие копии и получат изменения во
      внешних зависимостях.</para>

    <tip>
      <!-- @ENGLISH {{{
      <para>Because the <literal>svn:externals</literal> property has
        a multiline value, we strongly recommend that you use
        <command>svn propedit</command> instead of <command>svn
        propset</command>.</para>
      @ENGLISH }}} -->
      <para>Учитывая, что свойство <literal>svn:externals</literal> имеет 
        многострочное значение, крайне рекомендуется вместо команды
        <command>svn propset</command> использовать
        <command>svn propedit</command>.</para>
    </tip>

    <tip>
      <!-- @ENGLISH {{{
      <para>You should strongly consider using explicit revision
        numbers in all of your externals definitions.  Doing so means
        that you get to decide when to pull down a different snapshot
        of external information, and exactly which snapshot to pull.
        Besides avoiding the surprise of getting changes to
        third-party repositories that you might not have any control
        over, using explicit revision numbers also means that as you
        backdate your working copy to a previous revision, your
        externals definitions will also revert to the way they looked
        in that previous revision, which in turn means that the
        external working copies will be updated to match they way
        <emphasis>they</emphasis> looked back when your repository was
        at that previous revision.  For software projects, this could
        be the difference between a successful and a failed build of
        an older snapshot of your complex codebase.</para> 
      @ENGLISH }}} -->
      <para>Вам стоит всерьез подумать про использование явно указанного
        номера правки для всех внешних зависимостей. Поступая таким образом, 
        вы сможете выбирать момент перехода на другой снимок внешней 
        информации и явно указывать какой это будет снимок. Кроме того что это 
        позволяет избежать получения неожиданных изменений из сторонних 
        хранилищ, которые вы, возможно, никак не контролируете, явное указание
        номера правки означает, что откат вашей рабочей копии к более ранней
        правке приведет к откату и для внешних зависимостей, к тому состоянию,
        в котором они были в той, предыдущей, правке, то есть это значит, что
        внешние рабочие копии будут выглядеть так, как <emphasis>они</emphasis>
        выглядели на момент той правки вашего хранилища. Для программных
        проектов это может быть вопросом удачной или неудачной сборки старого
        снимка сложной и запутанной базы программного кода.</para>
    </tip>

    <!-- @ENGLISH {{{
    <para>The <command>svn status</command> command also recognizes
      externals definitions, displaying a status code of
      <literal>X</literal> for the disjoint subdirectories into which
      externals are checked out, and then recursing into those
      subdirectories to display the status of the external items
      themselves.</para>
    @ENGLISH }}} -->
    <para>Команда <command>svn status</command> умеет определять внешние 
      зависимости, показывая код статуса <literal>X</literal> для 
      подкаталогов, выгруженных из внешних зависимостей, и рекурсивно 
      проходя по этим подкаталогам для отображения статуса самих внешних
      элементов.</para>

    <!-- @ENGLISH {{{
    <para>The support that exists for externals definitions in
      Subversion today can be a little misleading, though.  First, an
      externals definition can only point to directories, not files.
      Second, the externals definition cannot point to relative paths
      (paths like <filename>.&#64738;./.&#64738;./skins/myskin</filename>).  Third, the
      working copies created via the externals definition support are
      still disconnected from the primary working copy (on whose
      versioned directories the <literal>svn:externals</literal>
      property was actually set).  And Subversion still only truly
      operates on non-disjoint working copies.  So, for example, if
      you want to commit changes that you've made in one or more of
      those external working copies, you must run <command>svn
      commit</command> explicitly on those working
      copies&mdash;committing on the primary working copy will not
      recurse into any external ones.</para>
    @ENGLISH }}} -->
    <para>Вместе с тем, текущая реализация поддержки внешних зависимостей
      в Subversion может вводить в заблуждение. Во-первых, внешние зависимости
      могут указывать только на папки, но не на файлы. Во-вторых, внешние 
      зависимости не могут указывать на относительные пути (например, 
      такие как <filename>../../skins/myskin</filename>).  В-третьих, 
      рабочие копии, созданные через внешние зависимости, являются оторванными от 
      первичной рабочей копии (от того каталога, для которого установлено
      свойство <literal>svn:externals</literal>). А Subversion полноценно
      работает только на неотсоединенных рабочих копиях. Это означает, что
      если вы захотите зафиксировать изменения, сделанные в одной или
      нескольких таких рабочих копиях, вам придется принудительно выполнять
      команду <command>svn commit</command> для этих рабочих копий &mdash; 
      фиксация в первичной рабочей копии не распространяется на внешние 
      зависимости.</para>

    <!-- @ENGLISH {{{
    <para>Also, since the definitions themselves use absolute URLs,
      moving or copying a directory to which they are attached will
      not affect what gets checked out as an external (though the
      relative local target subdirectory will, of course, move with
      renamed directory).  This can be confusing&mdash;even
      frustrating&mdash;in certain situations.  For example, say you
      have a top-level directory named
      <filename>my-project</filename>, and you've created an externals
      definition on one of its subdirectories
      (<filename>my-project/some-dir</filename>) which tracks the
      latest revision of another of its subdirectories
      (<filename>my-project/external-dir</filename>).</para>
    @ENGLISH }}} -->
    <para>Кроме того, поскольку зависимости используют абсолютные URL,
      перемещение или копирование папки, к которой они присоединены, не
      будет влиять на то, что будет выгружаться из хранилища в виде
      внешней зависимости (при этом, локальные подкаталоги, назначенные
      как целевые для внешних зависимостей, при переименовании родительского
      каталога будут, естественно, перемещены вместе с ним).
      В определенных ситуациях это может сбивать с толку и запутывать.
      Например, у вас есть корневой каталог <filename>my-project</filename>
      и для одного из его подкаталогов (<filename>my-project/some-dir</filename>)
      вы назначаете внешнюю зависимость, отслеживающую изменения другого
      подкаталога (<filename>my-project/external-dir</filename>).</para>

    <screen>
$ svn co http://svn.example.com/projects .
A    my-project
A    my-project/some-dir
A    my-project/external-dir
&hellip;
Fetching external item into 'my-project/some-dir/subdir'
Checked out external at revision 11.

Checked out revision 11.
$ svn pget svn:externals my-project/some-dir
subdir http://svn.example.com/projects/my-project/external-dir

$
</screen>

    <!-- @ENGLISH {{{
    <para>Now you use <command>svn move</command> to rename the
      <filename>my-project</filename> directory.  At this point, your
      externals definition will still refer to a path under the
      <filename>my-project</filename> directory, even though that
      directory no longer exists.</para>
    @ENGLISH }}} -->
    <para>Переименуем с помощью команды <command>svn move</command> 
      каталог <filename>my-project</filename>. Теперь 
      внешние зависимости продолжают продолжают указывать на путь в каталоге
     <filename>my-project</filename>, а самого этого каталога уже не 
     существует.</para>

    <screen>
$ svn mv -q my-project renamed-project
$ svn ci -m "Rename my-project to renamed-project."
Deleting       my-project
Adding         my-renamed-project

Committed revision 12.
$ svn up

Fetching external item into 'renamed-project/some-dir/subdir'
svn: Target path does not exist
$
</screen>

    <!-- @ENGLISH {{{
    <para>Also, the fact that externals definitions use absolute URLs
      can cause problems with repositories that are available via
      multiple URL schemes.  For example, if your Subversion server is
      configured to allow everyone to checkout the repository over
      <literal>http://</literal> or <literal>https://</literal>, but
      only allow commits to come in via <literal>https://</literal>,
      you have an interesting problem on your hands.  If your
      externals definitions use the <literal>http://</literal> form
      of the repository URLs, you won't be able to commit anything
      from the working copies created by those externals.  On the
      other hand, if they use the <literal>https://</literal> form of
      the URLs, anyone who might be checking out via
      <literal>http://</literal> because their client doesn't support
      <literal>https://</literal> will be unable to fetch the external
      items.  Be aware, too, that if you need to re-parent your
      working copy (using <command>svn switch -&64738;-relocate</command>),
      externals definitions will <emphasis>not</emphasis> also be
      re-parented.</para>
    @ENGLISH }}} -->
    <para>Тот факт, что внешние зависимости используют абсолютные URL, может 
      вызвать проблемы при работе с хранилищами, доступными через несколько
      URL-схем. Интересная проблема может возникнуть, если, например, сервер 
      Subversion позволяет любому пользователю создать рабочую копию, подключившись
      через <literal>http://</literal> или <literal>https://</literal>, а
      фиксации позволяет выполнять только через <literal>https://</literal>.
      Если внешние зависимости используют <literal>http://</literal> вариант 
      URL хранилища, то для рабочих копий, созданных для этих внешних 
      зависимостей, нельзя будет выполнить фиксацию изменений. С другой 
      стороны, если использовался <literal>https://</literal> вариант URL, то 
      пользователи, которые создают рабочую копию через
      <literal>http://</literal> потому, что их клиент не поддерживает
      <literal>https://</literal>, не смогут получить внешние элементы.
      Обратите внимание и на то, что при переопределении рабочей копии
      (с помощью команды <command>svn --relocate</command>) внешние 
      зависимости <emphasis>не</emphasis> будут переопределены.</para>

    <!-- @ENGLISH {{{    
    <para>Finally, there might be times when you would prefer that
      <command>svn</command> subcommands would not recognize or
      otherwise operate on the external working copies created as the
      result of externals definition handling.  In those instances,
      you can pass the <option>--><!--ignore-externals</option> option to
      the subcommand.</para>
    @ENGLISH }}} -->
    <para>Наконец, могут быть ситуации, в которых предпочтительно, чтобы
      подкоманды <command>svn</command> не идентифицировали и не оперировали
      рабочими копиями, созданными как внешние зависимости. Для таких
      случаев при вызове подкоманды можно использовать параметр
      <option>--ignore-externals</option>.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.pegrevs">
    <title>Peg and Operative Revisions</title>

    <para>We make use of the ability to copy, move, rename, and
      completely replace files and directories on our computers all
      the time.  And your version control system shouldn't get in the
      way of your doing these things with your version-controlled
      files and directories, either.  Subversion's file management
      support is quite liberating, affording almost as much
      flexibility for versioned files as you'd expect when
      manipulating your unversioned ones.  But that flexibility means
      that across the lifetime of your repository, a given versioned
      object might have many paths, and a given path might represent
      several entirely different versioned objects.  And this
      introduces a certain level of complexity to your interactions
      with those paths and objects.</para>

    <para>Subversion is pretty smart about noticing when an object's
      version history includes such <quote>changes of address</quote>.
      For example, if you ask for the revision history log of a
      particular file that was renamed last week, Subversion happily
      provides all those logs&mdash;the revision in which the rename
      itself happened, plus the logs of relevant revisions both before
      and after that rename.  So, most of the time, you don't even
      have to think about such things.  But occasionally, Subversion
      needs your help to clear up ambiguities.</para>

    <para>The simplest example of this occurs when a directory or file
      is deleted from version control, and then a new directory or
      file is created with the same name and added to version control.
      Clearly the thing you deleted and the thing you later added
      aren't the same thing.  They merely happen to have had the same
      path, <filename>/trunk/object</filename> for example.  What,
      then, does it mean to ask Subversion about the history of
      <filename>/trunk/object</filename>?  Are you asking about the
      thing currently at that location, or the old thing you deleted
      from that location?  Are you asking about the operations that
      have happened to <emphasis>all</emphasis> the objects that have
      ever lived at that path?  Clearly, Subversion needs a hint about
      what you really want.</para>

    <para>And thanks to moves, versioned object history can get far
      more twisted than that, even.  For example, you might have a
      directory named <filename>concept</filename>, containing some
      nascent software project you've been toying with.  Eventually,
      though, that project matures to the point that the idea seems to
      actually have some wings, so you do the unthinkable and decide
      to give the project a name.
      <footnote>
        <para><quote>You're not supposed to name it.  Once you name it,
          you start getting attached to it.</quote> &mdash; Mike
          Wazowski</para>
      </footnote>
      Let's say you called your software Frabnaggilywort.  At this
      point, it makes sense to rename the directory to reflect the
      project's new name, so <filename>concept</filename> is renamed
      to <filename>frabnaggilywort</filename>.  Life goes on,
      Frabnaggilywort releases a 1.0 version, and is downloaded and
      used daily by hordes of people aiming to improve their
      lives.</para>
    
    <para>It's a nice story, really, but it doesn't end there.
      Entrepreneur that you are, you've already got another think in
      the tank.  So you make a new directory,
      <filename>concept</filename>, and the cycle begins again.  In
      fact, the cycle begins again many times over the years, each
      time starting with that old <filename>concept</filename>
      directory, then sometimes seeing that directory renamed as the
      idea cures, sometimes seeing it deleted when you scrap the idea.
      Or, to get really sick, maybe you rename
      <filename>concept</filename> to something else for a while, but
      later rename the thing back to <filename>concept</filename> for
      some reason.</para>

    <para>When scenarios like these occur, attempting to instruct
      Subversion to work with these re-used paths can be a little like
      instructing a motorist in Chicago's West Suburbs to drive east
      down Roosevelt Road and turn left onto Main Street.  In a mere
      twenty minutes, you can cross <quote>Main Street</quote> in
      Wheaton, Glen Ellyn, and Lombard.  And no, they aren't the same
      street.  Our motorist&mdash;and our Subversion&mdash;need a
      little more detail in order to do the right thing.</para>

    <para>In version 1.1, Subversion introduced a way for you to tell
      it exactly which Main Street you meant.  It's called the
      <firstterm>peg revision</firstterm>, and it is a revision
      provided to Subversion for the sole purpose of identifying a
      unique line of history.  Because at most one versioned object
      may occupy a path at any given time&mdash;or, more precisely, in
      any one revision&mdash;the combination of a path and a peg
      revision is all that is needed to refer to a specific line of
      history.  Peg revisions are specified to the Subversion
      command-line client using <firstterm>at syntax</firstterm>, so
      called because the syntax involves appending an <quote>at
      sign</quote> (<literal>@</literal>) and the peg revision to the
      end of the path with which the revision is associated.</para>

    <para>But what of the <option>--revision (-r)</option> of which
      we've spoken so much in this book?  That revision (or set of
      revisions) is called the <firstterm>operative
      revision</firstterm> (or <firstterm>operative revision
      range</firstterm>).  Once a particular line of history has been
      identified using a path and peg revision, Subversion performs
      the requested operation using the operative revision(s).  To map
      this to our Chicagoland streets analogy, if we are told to go to
      606 N. Main Street in Wheaton,
      <footnote>
        <para>606 N. Main Street, Wheaton, Illinois, is the home of
          the Wheaton History Center.  Get it&mdash;<quote>History
          Center</quote>?  It seemed appropriate&hellip;.</para>
      </footnote>
      we can think of <quote>Main Street</quote> as our path and
      <quote>Wheaton</quote> as our peg revision.  These two pieces of
      information identify a unique path which can travelled (north or
      south on Main Street), and will keep us from travelling up and
      down the wrong Main Street in search of our destination.  Now we
      throw in <quote>606 N.</quote> as our operative revision, of
      sorts, and we know <emphasis>exactly</emphasis> where to
      go.</para>

    <sidebar>
      <title>The peg revision algorithm</title>
      
      <para>The Subversion command-line performs the peg revision
        algorithm any time it needs to resolve possible ambiguities in
        the paths and revisions provided to it.  Here's an example of
        such an invocation for the purposes of illustrating that
        algorithm.</para>

      <screen>
$ svn <replaceable>command</replaceable> -r <replaceable>OPERATIVE-REV</replaceable> item@<replaceable>PEG-REV</replaceable>
</screen>
      
      <para>The algorithm has three simple steps:</para>

      <itemizedlist>
        
        <listitem>
          <para>Locate <replaceable>item</replaceable> in the revision
            identified by <replaceable>PEG-REV</replaceable>.  There
            can be only one such object.</para>
        </listitem>

        <listitem>
          <para>Trace the object's history backwards (through any
            possible renames) to its ancestor in the
            revision <replaceable>OPERATIVE-REV</replaceable>.</para>
        </listitem>

        <listitem>
          <para>Perform the requested action on that ancestor,
            wherever it is located, or whatever its name might
            be or have been at that time.</para>
        </listitem>

      </itemizedlist>

      <para>Note that even when you don't explicitly supply a peg
        revision or operative revision, they are still present.  For
        your convenience, the default peg revision is
        <literal>BASE</literal> for working copy items and
        <literal>HEAD</literal> for repository URLs.  And when no
        operative revision is provided, it defaults to being the same
        revision as the peg revision.</para>
        
    </sidebar>

    <para>Say that long ago we created our repository, and in revision 1
      added our first <filename>concept</filename> directory, plus an
      <filename>IDEA</filename> file in that directory talking about
      the concept.  After several revisions in which real code was
      added and tweaked, we, in revision 20, renamed this directory to
      <filename>frabnaggilywort</filename>.  By revision 27, we had a
      new concept, a new <filename>concept</filename> directory to
      hold it, and a new <filename>IDEA</filename> file to describe
      it.  And then five years and twenty thousand revisions flew by,
      just like they would in any good romance story.</para>

    <para>Now, years later, we wonder what the
      <filename>IDEA</filename> file looked like back in revision 1.
      But Subversion needs to know if we are asking about how the
      <emphasis>current</emphasis> file looked back in revision 1, or
      are we asking for the contents of whatever file lived at
      <filename>concepts/IDEA</filename> in revision 1?  Certainly
      those questions have different answers, and because of peg
      revisions, you can ask either of them.  To find out how the
      current <filename>IDEA</filename> file looked in that old
      revision, you run:</para>

    <screen>
$ svn cat -r 1 concept/IDEA 
svn: Unable to find repository location for 'concept/IDEA' in revision 1
</screen>

    <para>Of course, in this example, the current
      <filename>IDEA</filename> file didn't exist yet in revision 1,
      so Subversion gives an error.  The command above is shorthand
      for a longer notation which explicitly lists a peg revision.
      The expanded notation is:</para>

    <screen>
$ svn cat -r 1 concept/IDEA@BASE
svn: Unable to find repository location for 'concept/IDEA' in revision 1
</screen>

    <para>And when executed, it has the expected results.  Peg revisions
      generally default to a value of <literal>BASE</literal> (the
      revision currently present in the working copy) when applied to
      working copy paths, and of <literal>HEAD</literal> when applied
      to URLs.</para>

    <para>The perceptive reader is probably wondering at this point if
      the peg revision syntax causes problems for working copy paths
      or URLs that actually have at signs in them.  After
      all, how does <command>svn</command> know whether
      <literal>news@11</literal> is the name of a directory in my
      tree, or just a syntax for <quote>revision 11 of
      <filename>news</filename></quote>?  Thankfully, while
      <command>svn</command> will always assume the latter, there is a
      trivial workaround.  You need only append an at sign to the
      end of the path, such as <literal>news@11@</literal>.
      <command>svn</command> only cares about the last at sign in
      the argument, and it is not considered illegal to omit a literal
      peg revision specifier after that at sign.  This workaround
      even applies to paths that end in an at sign&mdash;you would
      use <literal>filename@@</literal> to talk about a file named
      <filename>filename@</filename>.</para>

    <para>Let's ask the other question, then&mdash;in revision 1, what
      were the contents of whatever file occupied the address
      <filename>concepts/IDEA</filename> at the time?  We'll use an
      explicit peg revision to help us out.</para>

    <screen>
$ svn cat concept/IDEA@1
The idea behind this project is to come up with a piece of software
that can frab a naggily wort.  Frabbing naggily worts is tricky
business, and doing it incorrectly can have serious ramifications, so
we need to employ over-the-top input validation and data verification
mechanisms.
</screen>

    <para>Notice that we didn't provide an operative revision this
      time.  That's because when no operative revision is specified,
      Subversion assumes a default operative revision that's the same
      as the peg revision.</para>

    <para>As you can see, the output from our operation appears to be
      correct.  The text even mentions frabbing naggily worts, so this
      is almost certainly the file which describes the software now
      called Frabnaggilywort.  In fact, we can verify this using the
      combination of an explicit peg revision and explicit operative
      revision.  We know that in <literal>HEAD</literal>, the
      Frabnaggilywort project is located in the
      <filename>frabnaggilywort</filename> directory.  So we specify
      that we want to see how the line of history identified in
      <literal>HEAD</literal> as the path
      <filename>frabnaggilywort/IDEA</filename> looked in revision
      1.</para>

    <screen>
$ svn cat -r 1 frabnaggilywort/IDEA@HEAD
The idea behind this project is to come up with a piece of software
that can frab a naggily wort.  Frabbing naggily worts is tricky
business, and doing it incorrectly can have serious ramifications, so
we need to employ over-the-top input validation and data verification
mechanisms.
</screen>

    <para>And the peg and operative revisions need not be so trivial,
      either.  For example, say <filename>frabnaggilywort</filename>
      had been deleted from <literal>HEAD</literal>, but we know it
      existed in revision 20, and we want to see the diffs for its
      <filename>IDEA</filename> file between revisions 4 and 10.  We
      can use the peg revision 20 in conjunction with the URL that
      would have held Frabnaggilywort's <filename>IDEA</filename> file
      in revision 20, and then use 4 and 10 as our operative revision
      range.</para>

    <screen>
$ svn diff -r 4:10 http://svn.red-bean.com/projects/frabnaggilywort/IDEA@20
Index: frabnaggilywort/IDEA
===================================================================
--- frabnaggilywort/IDEA	(revision 4)
+++ frabnaggilywort/IDEA	(revision 10)
@@ -1,5 +1,5 @@
-The idea behind this project is to come up with a piece of software
-that can frab a naggily wort.  Frabbing naggily worts is tricky
-business, and doing it incorrectly can have serious ramifications, so
-we need to employ over-the-top input validation and data verification
-mechanisms.
+The idea behind this project is to come up with a piece of
+client-server software that can remotely frab a naggily wort.
+Frabbing naggily worts is tricky business, and doing it incorrectly
+can have serious ramifications, so we need to employ over-the-top
+input validation and data verification mechanisms.
</screen>

    <para>Fortunately, most folks aren't faced with such complex
      situations.  But when you are, remember that peg revisions are
      that extra hint Subversion needs to clear up ambiguity.</para>

  </sect1>

</chapter>

<!--
local variables:
sgml-parent-document: ("book.xml" "chapter")
end:
vim: tw=78:ft=svnbook
-->
